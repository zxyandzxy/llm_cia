{
    "time": 1749456474.0441127,
    "messages": [
        {
            "role": "system",
            "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
        },
        {
            "role": "user",
            "content": "The project you need to analyze is `hsqldb`, a well-known Java open source project. The starting entity you need to deal with is Tokens.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
        },
        {
            "content": "",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_289f38fc58e14d3498a725",
                    "function": {
                        "arguments": "{\"entity\": \"Tokens.java\"}",
                        "name": "get_co_change_relationship"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "name": "get_co_change_relationship",
            "role": "tool",
            "content": "[[\"Log\", \"5\", \"0.11363636363636363\"], [\"ErrorCode\", \"3\", \"0.06818181818181818\"], [\"Session\", \"10\", \"0.22727272727272727\"], [\"Constraint\", \"3\", \"0.06818181818181818\"], [\"Table\", \"5\", \"0.11363636363636363\"], [\"HsqlDatabaseProperties\", \"10\", \"0.22727272727272727\"], [\"UserManager\", \"4\", \"0.09090909090909091\"], [\"ParserDDL\", \"16\", \"0.36363636363636365\"], [\"SessionManager\", \"1\", \"0.022727272727272728\"], [\"StatementDML\", \"3\", \"0.06818181818181818\"], [\"ParserCommand\", \"21\", \"0.4772727272727273\"], [\"CharacterType\", \"4\", \"0.09090909090909091\"], [\"SchemaManager\", \"6\", \"0.13636363636363635\"], [\"Database\", \"17\", \"0.38636363636363635\"], [\"Logger\", \"14\", \"0.3181818181818182\"], [\"ParserDML\", \"4\", \"0.09090909090909091\"], [\"NumberType\", \"3\", \"0.06818181818181818\"], [\"Grantee\", \"1\", \"0.022727272727272728\"], [\"Statement\", \"1\", \"0.022727272727272728\"], [\"ParserDQL\", \"23\", \"0.5227272727272727\"], [\"StatementCompound\", \"2\", \"0.045454545454545456\"], [\"StatementHandler\", \"1\", \"0.022727272727272728\"], [\"DatabaseInformationFull\", \"3\", \"0.06818181818181818\"], [\"JDBCConnection\", \"3\", \"0.06818181818181818\"], [\"Scanner\", \"4\", \"0.09090909090909091\"], [\"DateTimeType\", \"4\", \"0.09090909090909091\"], [\"DatabaseManager\", \"2\", \"0.045454545454545456\"], [\"IntervalType\", \"2\", \"0.045454545454545456\"], [\"DataFileCache\", \"9\", \"0.20454545454545456\"], [\"FunctionCustom\", \"17\", \"0.38636363636363635\"], [\"TestStoredProcedure\", \"2\", \"0.045454545454545456\"], [\"TransferHelper\", \"1\", \"0.022727272727272728\"], [\"TransferDb\", \"1\", \"0.022727272727272728\"], [\"TransferTable\", \"1\", \"0.022727272727272728\"], [\"Servlet\", \"1\", \"0.022727272727272728\"], [\"OpTypes\", \"6\", \"0.13636363636363635\"], [\"Routine\", \"6\", \"0.13636363636363635\"], [\"FunctionSQLInvoked\", \"2\", \"0.045454545454545456\"], [\"Expression\", \"3\", \"0.06818181818181818\"], [\"QuerySpecification\", \"7\", \"0.1590909090909091\"], [\"ExpressionColumn\", \"6\", \"0.13636363636363635\"], [\"SetFunction\", \"2\", \"0.045454545454545456\"], [\"ExpressionAggregate\", \"1\", \"0.022727272727272728\"], [\"ParserRoutine\", \"5\", \"0.11363636363636363\"], [\"RoutineSchema\", \"2\", \"0.045454545454545456\"], [\"HsqlName\", \"1\", \"0.022727272727272728\"], [\"DITableInfo\", \"1\", \"0.022727272727272728\"], [\"StatementSchema\", \"7\", \"0.1590909090909091\"], [\"ExpressionOp\", \"6\", \"0.13636363636363635\"], [\"DatabaseInformation\", \"1\", \"0.022727272727272728\"], [\"StatementTypes\", \"8\", \"0.18181818181818182\"], [\"DatabaseURL\", \"2\", \"0.045454545454545456\"], [\"FunctionSQL\", \"4\", \"0.09090909090909091\"], [\"StatementProcedure\", \"1\", \"0.022727272727272728\"], [\"JDBCDriver\", \"1\", \"0.022727272727272728\"], [\"ClobType\", \"1\", \"0.022727272727272728\"], [\"JDBCClobClient\", \"1\", \"0.022727272727272728\"], [\"JDBCBlobClient\", \"1\", \"0.022727272727272728\"], [\"BlobType\", \"1\", \"0.022727272727272728\"], [\"ArrayType\", \"2\", \"0.045454545454545456\"], [\"SubQuery\", \"1\", \"0.022727272727272728\"], [\"StatementCommand\", \"17\", \"0.38636363636363635\"], [\"ExpressionTable\", \"2\", \"0.045454545454545456\"], [\"RowSetNavigatorDataChange\", \"2\", \"0.045454545454545456\"], [\"JDBCResultSetMetaData\", \"2\", \"0.045454545454545456\"], [\"JDBCParameterMetaData\", \"1\", \"0.022727272727272728\"], [\"DatabaseInformationMain\", \"2\", \"0.045454545454545456\"], [\"StatementResultUpdate\", \"1\", \"0.022727272727272728\"], [\"SchemaObjectSet\", \"1\", \"0.022727272727272728\"], [\"ScriptWriterText\", \"2\", \"0.045454545454545456\"], [\"ScriptRunner\", \"1\", \"0.022727272727272728\"], [\"ScriptReaderText\", \"3\", \"0.06818181818181818\"], [\"StringConverter\", \"2\", \"0.045454545454545456\"], [\"RangeVariableResolver\", \"2\", \"0.045454545454545456\"], [\"Collation\", \"1\", \"0.022727272727272728\"], [\"StringUtil\", \"1\", \"0.022727272727272728\"], [\"SortAndSlice\", \"2\", \"0.045454545454545456\"], [\"ExpressionArrayAggregate\", \"2\", \"0.045454545454545456\"], [\"User\", \"2\", \"0.045454545454545456\"], [\"DataFileDefrag\", \"2\", \"0.045454545454545456\"], [\"RowStoreAVL\", \"2\", \"0.045454545454545456\"], [\"RangeVariable\", \"1\", \"0.022727272727272728\"], [\"IndexAVL\", \"1\", \"0.022727272727272728\"], [\"PersistentStore\", \"2\", \"0.045454545454545456\"], [\"ScaledRAFileNIO\", \"2\", \"0.045454545454545456\"], [\"RowAVLDiskData\", \"1\", \"0.022727272727272728\"], [\"RowStoreAVLDiskData\", \"1\", \"0.022727272727272728\"], [\"ScaledRAFileHybrid\", \"1\", \"0.022727272727272728\"], [\"ScaledRAFile\", \"1\", \"0.022727272727272728\"], [\"IndexRowIterator\", \"1\", \"0.022727272727272728\"], [\"RowStoreAVLDisk\", \"1\", \"0.022727272727272728\"], [\"RowStoreAVLHybridExtended\", \"1\", \"0.022727272727272728\"], [\"NumberSequence\", \"1\", \"0.022727272727272728\"], [\"Type\", \"1\", \"0.022727272727272728\"], [\"ExpressionArithmetic\", \"1\", \"0.022727272727272728\"], [\"DataFileCacheSession\", \"2\", \"0.045454545454545456\"], [\"RowSetNavigatorData\", \"1\", \"0.022727272727272728\"], [\"TriggerDefSQL\", \"1\", \"0.022727272727272728\"], [\"QueryExpression\", \"1\", \"0.022727272727272728\"], [\"SessionContext\", \"2\", \"0.045454545454545456\"], [\"StatementSession\", \"1\", \"0.022727272727272728\"], [\"JDBCPreparedStatement\", \"1\", \"0.022727272727272728\"], [\"ScriptWriterBase\", \"1\", \"0.022727272727272728\"], [\"TestTypeConversion\", \"1\", \"0.022727272727272728\"], [\"SimpleLog\", \"1\", \"0.022727272727272728\"], [\"OrderedLongKeyHashMap\", \"1\", \"0.022727272727272728\"], [\"HsqlProperties\", \"1\", \"0.022727272727272728\"], [\"Server\", \"2\", \"0.045454545454545456\"], [\"WebServer\", \"1\", \"0.022727272727272728\"], [\"ServerProperties\", \"1\", \"0.022727272727272728\"], [\"ServerConfiguration\", \"1\", \"0.022727272727272728\"], [\"HsqlServerFactory\", \"1\", \"0.022727272727272728\"], [\"ServerConstants\", \"1\", \"0.022727272727272728\"], [\"DataFileBlockManager\", \"2\", \"0.045454545454545456\"], [\"ArrayUtil\", \"1\", \"0.022727272727272728\"], [\"StatementSchemaDefinition\", \"2\", \"0.045454545454545456\"], [\"TextCache\", \"1\", \"0.022727272727272728\"], [\"TransactionManagerMVCC\", \"1\", \"0.022727272727272728\"], [\"RowAction\", \"1\", \"0.022727272727272728\"], [\"RowOutputTextLog\", \"1\", \"0.022727272727272728\"], [\"DatabaseFilenameFilter\", \"1\", \"0.022727272727272728\"], [\"ExpressionOrderBy\", \"1\", \"0.022727272727272728\"], [\"RangeVariableConditions\", \"1\", \"0.022727272727272728\"], [\"Token\", \"1\", \"0.022727272727272728\"], [\"ParserBase\", \"3\", \"0.06818181818181818\"], [\"TableBase\", \"1\", \"0.022727272727272728\"], [\"ExpressionColumnAccessor\", \"1\", \"0.022727272727272728\"], [\"StatementCursor\", \"1\", \"0.022727272727272728\"], [\"BitMap\", \"1\", \"0.022727272727272728\"], [\"TableSpaceManagerText\", \"1\", \"0.022727272727272728\"], [\"TableSpaceManager\", \"1\", \"0.022727272727272728\"], [\"TableSpaceManagerSession\", \"1\", \"0.022727272727272728\"], [\"HashSet\", \"1\", \"0.022727272727272728\"], [\"Row\", \"1\", \"0.022727272727272728\"], [\"Schema\", \"2\", \"0.045454545454545456\"], [\"HsqlDateTime\", \"1\", \"0.022727272727272728\"], [\"SimpleStore\", \"1\", \"0.022727272727272728\"], [\"ScriptReaderBase\", \"1\", \"0.022727272727272728\"], [\"RowSetNavigatorClient\", \"1\", \"0.022727272727272728\"], [\"StatementInsert\", \"1\", \"0.022727272727272728\"], [\"TestScript\", \"1\", \"0.022727272727272728\"], [\"RowSetNavigatorDataChangeMemory\", \"1\", \"0.022727272727272728\"], [\"NodeAVLDisk\", \"1\", \"0.022727272727272728\"], [\"LobManager\", \"1\", \"0.022727272727272728\"], [\"ParserTable\", \"1\", \"0.022727272727272728\"], [\"ReferenceObject\", \"1\", \"0.022727272727272728\"], [\"View\", \"2\", \"0.045454545454545456\"], [\"TableDerived\", \"1\", \"0.022727272727272728\"], [\"RowInputTextLog\", \"1\", \"0.022727272727272728\"]]"
        },
        {
            "content": "The co-change relationship analysis reveals that several entities frequently change together with `Tokens.java`. The higher the confidence value, the stronger the relationship between the changes of that entity and `Tokens.java`.\n\n### Key Observations from Co-Change Relationships:\n1. **ParserDQL.java (Confidence: 0.5227)**  \n   - This has the highest confidence score, indicating a very strong co-change relationship with `Tokens.java`. Likely, `Tokens.java` is heavily used in parsing query-related logic.\n\n2. **ParserCommand.java (Confidence: 0.4773)**  \n   - Strong relationship as well; this indicates significant interaction between `Tokens.java` and command parsing logic.\n\n3. **Database.java (0.386), FunctionCustom.java (0.386), StatementCommand.java (0.386)**  \n   - These also show relatively high confidence values, suggesting they are tightly coupled with `Tokens.java`.\n\n4. **ParserDDL.java, Logger.java, HsqlDatabaseProperties.java, ParserRoutine.java** etc.  \n   - Moderate coupling relationships based on their confidence scores.\n\n---\n\n### Next Steps for Analysis:\n\nTo determine which entities need synchronization with `Tokens.java`, we should further analyze these top candidates to identify actual dependencies. Let's begin by analyzing **ParserDQL.java**, which has the strongest co-change relationship.\n\n#### Action: Retrieve the origin code of `ParserDQL.java` to understand how it interacts with `Tokens.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_793a6ad980904c8285889b",
                    "function": {
                        "arguments": "{\"entity\": \"ParserDQL.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package org.hsqldb;\\nimport org.hsqldb.HsqlNameManager.HsqlName;\\nimport org.hsqldb.HsqlNameManager.SimpleName;\\nimport org.hsqldb.error.Error;\\nimport org.hsqldb.error.ErrorCode;\\nimport org.hsqldb.lib.ArrayUtil;\\nimport org.hsqldb.lib.HashMappedList;\\nimport org.hsqldb.lib.HsqlArrayList;\\nimport org.hsqldb.lib.HsqlList;\\nimport org.hsqldb.lib.Iterator;\\nimport org.hsqldb.lib.LongDeque;\\nimport org.hsqldb.lib.OrderedHashSet;\\nimport org.hsqldb.lib.OrderedIntKeyHashMap;\\nimport org.hsqldb.result.ResultConstants;\\nimport org.hsqldb.result.ResultProperties;\\nimport org.hsqldb.store.BitMap;\\nimport org.hsqldb.store.ValuePool;\\nimport org.hsqldb.types.ArrayType;\\nimport org.hsqldb.types.BlobType;\\nimport org.hsqldb.types.Charset;\\nimport org.hsqldb.types.ClobType;\\nimport org.hsqldb.types.Collation;\\nimport org.hsqldb.types.DTIType;\\nimport org.hsqldb.types.IntervalType;\\nimport org.hsqldb.types.NumberType;\\nimport org.hsqldb.types.Type;\\nimport org.hsqldb.types.Types;\\npublic class ParserDQL extends ParserBase {\\n    protected Database             database;\\n    protected Session              session;\\n    protected final CompileContext compileContext;\\n    HsqlException                  lastError;\\n    ParserDQL(Session session, Scanner t) {\\n        super(t);\\n        this.session   = session;\\n        database       = session.getDatabase();\\n        compileContext = new CompileContext(session, this);\\n    }\\n    void reset(String sql) {\\n        super.reset(sql);\\n        compileContext.reset();\\n        lastError = null;\\n    }\\n    void checkIsSchemaObjectName() {\\n        if (database.sqlEnforceNames) {\\n            checkIsNonReservedIdentifier();\\n        } else {\\n            checkIsNonCoreReservedIdentifier();\\n        }\\n    }\\n    Type readTypeDefinition(boolean allowCollation, boolean includeUserTypes) {\\n        int     typeNumber     = Integer.MIN_VALUE;\\n        boolean hasLength      = false;\\n        boolean hasScale       = false;\\n        boolean isCharacter    = false;\\n        boolean readByteOrChar = false;\\n        checkIsIdentifier();\\n        if (token.namePrefix == null) {\\n            typeNumber = Type.getTypeNr(token.tokenString);\\n        }\\n        if (typeNumber == Integer.MIN_VALUE) {\\n            if (includeUserTypes) {\\n                checkIsSchemaObjectName();\\n                String schemaName = session.getSchemaName(token.namePrefix);\\n                Type type =\\n                    database.schemaManager.getDomainOrUDT(token.tokenString,\\n                        schemaName, false);\\n                if (type != null) {\\n                    getRecordedToken().setExpression(type);\\n                    compileContext.addSchemaObject(type);\\n                    read();\\n                    return type;\\n                }\\n            }\\n            if (token.namePrefix != null) {\\n                throw Error.error(ErrorCode.X_42509, token.tokenString);\\n            }\\n            if (database.sqlSyntaxOra) {\\n                switch (token.tokenType) {\\n                    case Tokens.BINARY_DOUBLE :\\n                    case Tokens.BINARY_FLOAT :\\n                        read();\\n                        return Type.SQL_DOUBLE;\\n                    case Tokens.LONG :\\n                        read();\\n                        if (token.tokenType == Tokens.RAW) {\\n                            read();\\n                            return Type.getType(Types.SQL_VARBINARY, null,\\n                                                null,\\n                                                BlobType.defaultBlobSize, 0);\\n                        } else {\\n                            return Type.getType(Types.SQL_VARCHAR, null, null,\\n                                                ClobType.defaultClobSize, 0);\\n                        }\\n                    case Tokens.NUMBER :\\n                        read();\\n                        if (token.tokenType == Tokens.OPENBRACKET) {\\n                            read();\\n                            int precision = readInteger();\\n                            int scale     = 0;\\n                            if (token.tokenType == Tokens.COMMA) {\\n                                read();\\n                                scale = readInteger();\\n                            }\\n                            readThis(Tokens.CLOSEBRACKET);\\n                            return Type.getType(Types.SQL_DECIMAL, null, null,\\n                                                precision, scale);\\n                        } else {\\n                            return Type.SQL_DECIMAL_DEFAULT;\\n                        }\\n                    case Tokens.RAW :\\n                        typeNumber = Types.VARBINARY;\\n                        break;\\n                    case Tokens.VARCHAR2 :\\n                        typeNumber     = Types.VARCHAR;\\n                        readByteOrChar = true;\\n                        break;\\n                }\\n            }\\n            if (database.sqlSyntaxMys || database.sqlSyntaxPgs) {\\n                switch (token.tokenType) {\\n                    case Tokens.TEXT :\\n                        typeNumber     = Types.LONGVARCHAR;\\n                        readByteOrChar = true;\\n                        break;\\n                }\\n            }\\n            if (typeNumber == Integer.MIN_VALUE) {\\n                throw Error.error(ErrorCode.X_42509, token.tokenString);\\n            }\\n        }\\n        read();\\n        switch (typeNumber) {\\n            case Types.SQL_CHAR :\\n                if (token.tokenType == Tokens.VARYING) {\\n                    read();\\n                    typeNumber = Types.SQL_VARCHAR;\\n                } else if (token.tokenType == Tokens.LARGE) {\\n                    readThis(Tokens.OBJECT);\\n                    read();\\n                    typeNumber = Types.SQL_CLOB;\\n                }\\n                break;\\n            case Types.SQL_DOUBLE :\\n                if (token.tokenType == Tokens.PRECISION) {\\n                    read();\\n                }\\n                break;\\n            case Types.SQL_BINARY :\\n                if (token.tokenType == Tokens.VARYING) {\\n                    read();\\n                    typeNumber = Types.SQL_VARBINARY;\\n                } else if (token.tokenType == Tokens.LARGE) {\\n                    readThis(Tokens.OBJECT);\\n                    read();\\n                    typeNumber = Types.SQL_BLOB;\\n                }\\n                break;\\n            case Types.SQL_BIT :\\n                if (token.tokenType == Tokens.VARYING) {\\n                    read();\\n                    typeNumber = Types.SQL_BIT_VARYING;\\n                }\\n                break;\\n            case Types.SQL_INTERVAL :\\n                return readIntervalType(false);\\n            default :\\n        }\\n        long length = typeNumber == Types.SQL_TIMESTAMP\\n                      ? DTIType.defaultTimestampFractionPrecision\\n                      : 0;\\n        int scale = 0;\\n        if (Types.requiresPrecision(typeNumber)\\n                && token.tokenType != Tokens.OPENBRACKET\\n                && database.sqlEnforceSize && !session.isProcessingScript) {\\n            throw Error.error(ErrorCode.X_42599,\\n                              Type.getDefaultType(typeNumber).getNameString());\\n        }\\n        if (Types.acceptsPrecision(typeNumber)) {\\n            if (token.tokenType == Tokens.OPENBRACKET) {\\n                int multiplier = 1;\\n                read();\\n                switch (token.tokenType) {\\n                    case Tokens.X_VALUE :\\n                        if (token.dataType.typeCode != Types.SQL_INTEGER\\n                                && token.dataType.typeCode\\n                                   != Types.SQL_BIGINT) {\\n                            throw unexpectedToken();\\n                        }\\n                        break;\\n                    case Tokens.X_LOB_SIZE :\\n                        if (typeNumber == Types.SQL_BLOB\\n                                || typeNumber == Types.SQL_CLOB) {\\n                            switch (token.lobMultiplierType) {\\n                                case Tokens.K :\\n                                    multiplier = 1024;\\n                                    break;\\n                                case Tokens.M :\\n                                    multiplier = 1024 * 1024;\\n                                    break;\\n                                case Tokens.G :\\n                                    multiplier = 1024 * 1024 * 1024;\\n                                    break;\\n                                case Tokens.P :\\n                                case Tokens.T :\\n                                default :\\n                                    throw unexpectedToken();\\n                            }\\n                            break;\\n                        } else {\\n                            throw unexpectedToken(token.getFullString());\\n                        }\\n                    default :\\n                        throw unexpectedToken();\\n                }\\n                hasLength = true;\\n                length    = ((Number) token.tokenValue).longValue();\\n                if (length < 0\\n                        || (length == 0\\n                            && !Types.acceptsZeroPrecision(typeNumber))) {\\n                    throw Error.error(ErrorCode.X_42592);\\n                }\\n                length *= multiplier;\\n                read();\\n                if (typeNumber == Types.SQL_CHAR\\n                        || typeNumber == Types.SQL_VARCHAR\\n                        || typeNumber == Types.SQL_CLOB) {\\n                    if (token.tokenType == Tokens.CHARACTERS) {\\n                        read();\\n                    } else if (token.tokenType == Tokens.OCTETS) {\\n                        read();\\n                        length /= 2;\\n                    }\\n                }\\n                if (Types.acceptsScaleCreateParam(typeNumber)\\n                        && token.tokenType == Tokens.COMMA) {\\n                    read();\\n                    scale = readInteger();\\n                    if (scale < 0) {\\n                        throw Error.error(ErrorCode.X_42592);\\n                    }\\n                    hasScale = true;\\n                }\\n                readThis(Tokens.CLOSEBRACKET);\\n            } else if (typeNumber == Types.SQL_BIT) {\\n                length = 1;\\n            } else if (typeNumber == Types.SQL_BLOB\\n                       || typeNumber == Types.SQL_CLOB) {\\n                length = BlobType.defaultBlobSize;\\n            } else if (database.sqlEnforceSize) {\\n                                if (typeNumber == Types.SQL_CHAR\\n                        || typeNumber == Types.SQL_BINARY) {\\n                    length = 1;\\n                }\\n            }\\n            if (typeNumber == Types.SQL_TIMESTAMP\\n                    || typeNumber == Types.SQL_TIME) {\\n                if (length > DTIType.maxFractionPrecision) {\\n                    throw Error.error(ErrorCode.X_42592);\\n                }\\n                scale  = (int) length;\\n                length = 0;\\n                if (token.tokenType == Tokens.WITH) {\\n                    read();\\n                    readThis(Tokens.TIME);\\n                    readThis(Tokens.ZONE);\\n                    if (typeNumber == Types.SQL_TIMESTAMP) {\\n                        typeNumber = Types.SQL_TIMESTAMP_WITH_TIME_ZONE;\\n                    } else {\\n                        typeNumber = Types.SQL_TIME_WITH_TIME_ZONE;\\n                    }\\n                } else if (token.tokenType == Tokens.WITHOUT) {\\n                    read();\\n                    readThis(Tokens.TIME);\\n                    readThis(Tokens.ZONE);\\n                }\\n            }\\n        }\\n        switch (typeNumber) {\\n            case Types.LONGVARCHAR : {\\n                if (database.sqlLongvarIsLob) {\\n                    typeNumber = Types.SQL_CLOB;\\n                } else {\\n                    typeNumber = Types.SQL_VARCHAR;\\n                }\\n                if (!hasLength) {\\n                    length = ClobType.defaultClobSize;\\n                }\\n                break;\\n            }\\n            case Types.LONGVARBINARY : {\\n                if (database.sqlLongvarIsLob) {\\n                    typeNumber = Types.SQL_BLOB;\\n                } else {\\n                    typeNumber = Types.SQL_VARBINARY;\\n                }\\n                if (!hasLength) {\\n                    length = BlobType.defaultBlobSize;\\n                }\\n                break;\\n            }\\n            case Types.SQL_CLOB :\\n            case Types.VARCHAR_IGNORECASE :\\n            case Types.SQL_CHAR :\\n                isCharacter = true;\\n                break;\\n            case Types.SQL_VARCHAR :\\n                isCharacter = true;\\n                if (!hasLength) {\\n                    length = 32 * 1024;\\n                }\\n                break;\\n            case Types.SQL_BINARY :\\n                break;\\n            case Types.SQL_VARBINARY :\\n                if (!hasLength) {\\n                    length = 32 * 1024;\\n                }\\n                break;\\n            case Types.SQL_DECIMAL :\\n            case Types.SQL_NUMERIC :\\n                if (!hasLength && !hasScale && !database.sqlEnforceSize) {\\n                    length = NumberType.defaultNumericPrecision;\\n                    scale  = NumberType.defaultNumericScale;\\n                }\\n                break;\\n        }\\n        if (session.ignoreCase && typeNumber == Types.SQL_VARCHAR) {\\n            typeNumber = Types.VARCHAR_IGNORECASE;\\n        }\\n        if (readByteOrChar) {\\n            if (!readIfThis(Tokens.CHAR)) {\\n                readIfThis(Tokens.BYTE);\\n            }\\n        }\\n        Collation collation = database.collation;\\n        Charset   charset   = null;\\n        if (isCharacter) {\\n            if (token.tokenType == Tokens.CHARACTER) {\\n                read();\\n                readThis(Tokens.SET);\\n                checkIsSchemaObjectName();\\n                String schemaName = session.getSchemaName(token.namePrefix);\\n                charset = (Charset) database.schemaManager.getSchemaObject(\\n                    token.tokenString, schemaName, SchemaObject.CHARSET);\\n                read();\\n            }\\n            if (token.tokenType == Tokens.COLLATE) {\\n                read();\\n                checkIsSimpleName();\\n                try {\\n                    collation = Collation.getCollation(token.tokenString);\\n                } catch (HsqlException e) {\\n                    collation =\\n                        (Collation) database.schemaManager.getSchemaObject(\\n                            token.tokenString, null, SchemaObject.COLLATION);\\n                }\\n                read();\\n            }\\n        }\\n        Type typeObject = Type.getType(typeNumber, charset, collation, length,\\n                                       scale);\\n        if (token.tokenType == Tokens.ARRAY) {\\n            if (typeObject.isLobType()) {\\n                throw unexpectedToken();\\n            }\\n            read();\\n            int maxCardinality = ArrayType.defaultArrayCardinality;\\n            if (token.tokenType == Tokens.LEFTBRACKET) {\\n                read();\\n                maxCardinality = readInteger();\\n                if (scale < 0) {\\n                    throw Error.error(ErrorCode.X_42592);\\n                }\\n                readThis(Tokens.RIGHTBRACKET);\\n            }\\n            typeObject = new ArrayType(typeObject, maxCardinality);\\n        }\\n        return typeObject;\\n    }\\n    void readSimpleColumnNames(OrderedHashSet columns,\\n                               RangeVariable rangeVar) {\\n        while (true) {\\n            ColumnSchema col = readSimpleColumnName(rangeVar);\\n            if (!columns.add(col.getName().name)) {\\n                throw Error.error(ErrorCode.X_42579, col.getName().name);\\n            }\\n            if (readIfThis(Tokens.COMMA)) {\\n                continue;\\n            }\\n            if (token.tokenType == Tokens.CLOSEBRACKET) {\\n                break;\\n            }\\n            throw unexpectedToken();\\n        }\\n    }\\n    void readTargetSpecificationList(OrderedHashSet targets,\\n                                     RangeVariable[] rangeVars,\\n                                     LongDeque colIndexList) {\\n        while (true) {\\n            Expression target = XreadTargetSpecification(rangeVars,\\n                colIndexList);\\n            if (!targets.add(target)) {\\n                ColumnSchema col = target.getColumn();\\n                throw Error.error(ErrorCode.X_42579, col.getName().name);\\n            }\\n            if (readIfThis(Tokens.COMMA)) {\\n                continue;\\n            }\\n            if (token.tokenType == Tokens.CLOSEBRACKET) {\\n                break;\\n            }\\n            if (token.tokenType == Tokens.FROM) {\\n                break;\\n            }\\n            throw unexpectedToken();\\n        }\\n    }\\n    int[] readColumnList(Table table, boolean ascOrDesc) {\\n        OrderedHashSet set = readColumnNames(ascOrDesc);\\n        return table.getColumnIndexes(set);\\n    }\\n    void readSimpleColumnNames(OrderedHashSet columns, Table table) {\\n        while (true) {\\n            ColumnSchema col = readSimpleColumnName(table);\\n            if (!columns.add(col.getName().name)) {\\n                throw Error.error(ErrorCode.X_42577, col.getName().name);\\n            }\\n            if (readIfThis(Tokens.COMMA)) {\\n                continue;\\n            }\\n            if (token.tokenType == Tokens.CLOSEBRACKET) {\\n                break;\\n            }\\n            throw unexpectedToken();\\n        }\\n    }\\n    HsqlName[] readColumnNames(HsqlName tableName) {\\n        BitMap         quotedFlags = new BitMap(32);\\n        OrderedHashSet set         = readColumnNames(quotedFlags, false);\\n        HsqlName[]     colList     = new HsqlName[set.size()];\\n        for (int i = 0; i < colList.length; i++) {\\n            String  name   = (String) set.get(i);\\n            boolean quoted = quotedFlags.isSet(i);\\n            colList[i] = database.nameManager.newHsqlName(tableName.schema,\\n                    name, quoted, SchemaObject.COLUMN, tableName);\\n        }\\n        return colList;\\n    }\\n    OrderedHashSet readColumnNames(boolean readAscDesc) {\\n        return readColumnNames(null, readAscDesc);\\n    }\\n    OrderedHashSet readColumnNames(BitMap quotedFlags, boolean readAscDesc) {\\n        readThis(Tokens.OPENBRACKET);\\n        OrderedHashSet set = new OrderedHashSet();\\n        readColumnNameList(set, quotedFlags, readAscDesc);\\n        readThis(Tokens.CLOSEBRACKET);\\n        return set;\\n    }\\n    void readColumnNameList(OrderedHashSet set, BitMap quotedFlags,\\n                            boolean readAscDesc) {\\n        int i = 0;\\n        while (true) {\\n            if (session.isProcessingScript) {\\n                                if (!isSimpleName()) {\\n                    token.isDelimitedIdentifier = true;\\n                }\\n            } else {\\n                checkIsSimpleName();\\n            }\\n            if (!set.add(token.tokenString)) {\\n                throw Error.error(ErrorCode.X_42577, token.tokenString);\\n            }\\n            if (quotedFlags != null && isDelimitedIdentifier()) {\\n                quotedFlags.set(i);\\n            }\\n            read();\\n            i++;\\n            if (readAscDesc) {\\n                if (token.tokenType == Tokens.ASC\\n                        || token.tokenType == Tokens.DESC) {\\n                    read();\\n                }\\n            }\\n            if (readIfThis(Tokens.COMMA)) {\\n                continue;\\n            }\\n            break;\\n        }\\n    }\\n    SimpleName[] readColumnNameList(OrderedHashSet set) {\\n        BitMap columnNameQuoted = new BitMap(32);\\n        readThis(Tokens.OPENBRACKET);\\n        readColumnNameList(set, columnNameQuoted, false);\\n        readThis(Tokens.CLOSEBRACKET);\\n        SimpleName[] columnNameList = new SimpleName[set.size()];\\n        for (int i = 0; i < set.size(); i++) {\\n            SimpleName name =\\n                HsqlNameManager.getSimpleName((String) set.get(i),\\n                                              columnNameQuoted.isSet(i));\\n            columnNameList[i] = name;\\n        }\\n        return columnNameList;\\n    }\\n    int XreadUnionType() {\\n        int unionType = QueryExpression.NOUNION;\\n        switch (token.tokenType) {\\n            case Tokens.UNION :\\n                read();\\n                unionType = QueryExpression.UNION;\\n                if (token.tokenType == Tokens.ALL) {\\n                    unionType = QueryExpression.UNION_ALL;\\n                    read();\\n                } else if (token.tokenType == Tokens.DISTINCT) {\\n                    read();\\n                }\\n                break;\\n            case Tokens.INTERSECT :\\n                read();\\n                unionType = QueryExpression.INTERSECT;\\n                if (token.tokenType == Tokens.ALL) {\\n                    unionType = QueryExpression.INTERSECT_ALL;\\n                    read();\\n                } else if (token.tokenType == Tokens.DISTINCT) {\\n                    read();\\n                }\\n                break;\\n            case Tokens.EXCEPT :\\n            case Tokens.MINUS_EXCEPT :\\n                read();\\n                unionType = QueryExpression.EXCEPT;\\n                if (token.tokenType == Tokens.ALL) {\\n                    unionType = QueryExpression.EXCEPT_ALL;\\n                    read();\\n                } else if (token.tokenType == Tokens.DISTINCT) {\\n                    read();\\n                }\\n                break;\\n            default :\\n                break;\\n        }\\n        return unionType;\\n    }\\n    void XreadUnionCorrespondingClause(QueryExpression queryExpression) {\\n        if (token.tokenType == Tokens.CORRESPONDING) {\\n            read();\\n            queryExpression.setUnionCorresoponding();\\n            if (token.tokenType == Tokens.BY) {\\n                read();\\n                OrderedHashSet names = readColumnNames(false);\\n                queryExpression.setUnionCorrespondingColumns(names);\\n            }\\n        }\\n    }\\n    QueryExpression XreadQueryExpression() {\\n        if (token.tokenType == Tokens.WITH) {\\n            read();\\n            boolean recursive = readIfThis(Tokens.RECURSIVE);\\n            compileContext.initSubqueryNames();\\n            while (true) {\\n                checkIsSimpleName();\\n                HsqlName[] nameList = null;\\n                HsqlName queryName =\\n                    database.nameManager.newHsqlName(token.tokenString,\\n                                                     isDelimitedIdentifier(),\\n                                                     SchemaObject.SUBQUERY);\\n                queryName.schema = SqlInvariants.SYSTEM_SUBQUERY_HSQLNAME;\\n                read();\\n                if (token.tokenType == Tokens.OPENBRACKET) {\\n                    nameList = readColumnNames(queryName);\\n                } else if (recursive) {\\n                    super.unexpectedTokenRequire(Tokens.T_OPENBRACKET);\\n                }\\n                readThis(Tokens.AS);\\n                readThis(Tokens.OPENBRACKET);\\n                SubQuery subQuery;\\n                subQuery =\\n                    XreadTableNamedSubqueryBody(queryName, nameList,\\n                                                recursive\\n                                                ? OpTypes.RECURSIVE_SUBQUERY\\n                                                : OpTypes.TABLE_SUBQUERY);\\n                readThis(Tokens.CLOSEBRACKET);\\n                if (token.tokenType == Tokens.CYCLE) {\\n                    throw super.unsupportedFeature();\\n                }\\n                if (recursive && token.tokenType == Tokens.CYCLE) {\\n                    Table    table           = subQuery.getTable();\\n                    int[]    cycleColumnList = readColumnList(table, false);\\n                    HsqlName name;\\n                    readThis(Tokens.SET);\\n                    checkIsSimpleName();\\n                    name = database.nameManager.newColumnHsqlName(\\n                        table.getName(), token.tokenString,\\n                        token.isDelimitedIdentifier);\\n                    ColumnSchema cycleMarkColumn = new ColumnSchema(name,\\n                        null, true, false, null);\\n                    if (table.getColumnIndex(name.name) != -1) {\\n                        throw Error.error(ErrorCode.X_42578,\\n                                          token.tokenString);\\n                    }\\n                    read();\\n                    readThis(Tokens.TO);\\n                    String cycleMarkValue = readQuotedString();\\n                    if (cycleMarkValue.length() != 1) {\\n                        throw unexpectedToken(cycleMarkValue);\\n                    }\\n                    readThis(Tokens.DEFAULT);\\n                    String noncycleMarkValue = readQuotedString();\\n                    if (noncycleMarkValue.length() != 1) {\\n                        throw unexpectedToken(noncycleMarkValue);\\n                    }\\n                    if (cycleMarkValue.equals(noncycleMarkValue)) {\\n                        throw unexpectedToken(cycleMarkValue);\\n                    }\\n                    readThis(Tokens.USING);\\n                    checkIsSimpleName();\\n                    checkIsSimpleName();\\n                    name = database.nameManager.newColumnHsqlName(\\n                        table.getName(), token.tokenString,\\n                        token.isDelimitedIdentifier);\\n                    if (table.getColumnIndex(name.name) != -1) {\\n                        throw Error.error(ErrorCode.X_42578,\\n                                          token.tokenString);\\n                    }\\n                    read();\\n                    ColumnSchema pathColumn = new ColumnSchema(name, null,\\n                        true, false, null);\\n                }\\n                compileContext.registerSubquery(queryName.name, subQuery);\\n                if (token.tokenType == Tokens.COMMA) {\\n                    read();\\n                    continue;\\n                }\\n                break;\\n            }\\n        }\\n        QueryExpression queryExpression = XreadQueryExpressionBody();\\n        SortAndSlice    sortAndSlice    = XreadOrderByExpression();\\n        if (queryExpression.sortAndSlice == null) {\\n            queryExpression.addSortAndSlice(sortAndSlice);\\n        } else {\\n            if (queryExpression.sortAndSlice.hasLimit()) {\\n                if (sortAndSlice.hasLimit()) {\\n                    throw Error.error(ErrorCode.X_42549);\\n                }\\n                for (int i = 0; i < sortAndSlice.exprList.size(); i++) {\\n                    Expression e = (Expression) sortAndSlice.exprList.get(i);\\n                    queryExpression.sortAndSlice.addOrderExpression(e);\\n                }\\n            } else {\\n                queryExpression.addSortAndSlice(sortAndSlice);\\n            }\\n        }\\n        return queryExpression;\\n    }\\n    QueryExpression XreadQueryExpressionBody() {\\n        QueryExpression queryExpression = XreadQueryTerm();\\n        while (true) {\\n            switch (token.tokenType) {\\n                case Tokens.UNION :\\n                case Tokens.EXCEPT :\\n                case Tokens.MINUS_EXCEPT : {\\n                    queryExpression = XreadSetOperation(queryExpression);\\n                    break;\\n                }\\n                default : {\\n                    return queryExpression;\\n                }\\n            }\\n        }\\n    }\\n    QueryExpression XreadQueryTerm() {\\n        QueryExpression queryExpression = XreadQueryPrimary();\\n        while (true) {\\n            if (token.tokenType == Tokens.INTERSECT) {\\n                queryExpression = XreadSetOperation(queryExpression);\\n            } else {\\n                return queryExpression;\\n            }\\n        }\\n    }\\n    private QueryExpression XreadSetOperation(\\n            QueryExpression queryExpression) {\\n        queryExpression = new QueryExpression(compileContext, queryExpression);\\n        int unionType = XreadUnionType();\\n        XreadUnionCorrespondingClause(queryExpression);\\n        QueryExpression rightQueryExpression = XreadQueryTerm();\\n        queryExpression.addUnion(rightQueryExpression, unionType);\\n        return queryExpression;\\n    }\\n    QueryExpression XreadQueryPrimary() {\\n        switch (token.tokenType) {\\n            case Tokens.TABLE :\\n            case Tokens.VALUES :\\n            case Tokens.SELECT : {\\n                QuerySpecification select = XreadSimpleTable();\\n                return select;\\n            }\\n            case Tokens.OPENBRACKET : {\\n                read();\\n                QueryExpression queryExpression = XreadQueryExpressionBody();\\n                SortAndSlice    sortAndSlice    = XreadOrderByExpression();\\n                readThis(Tokens.CLOSEBRACKET);\\n                if (queryExpression.sortAndSlice == null) {\\n                    queryExpression.addSortAndSlice(sortAndSlice);\\n                } else {\\n                    if (queryExpression.sortAndSlice.hasLimit()) {\\n                        if (sortAndSlice.hasLimit()) {\\n                            throw Error.error(ErrorCode.X_42549);\\n                        }\\n                        for (int i = 0; i < sortAndSlice.exprList.size();\\n                                i++) {\\n                            Expression e =\\n                                (Expression) sortAndSlice.exprList.get(i);\\n                            queryExpression.sortAndSlice.addOrderExpression(e);\\n                        }\\n                    } else {\\n                        queryExpression.addSortAndSlice(sortAndSlice);\\n                    }\\n                }\\n                return queryExpression;\\n            }\\n            default : {\\n                throw unexpectedToken();\\n            }\\n        }\\n    }\\n    QuerySpecification XreadSimpleTable() {\\n        QuerySpecification select;\\n        switch (token.tokenType) {\\n            case Tokens.TABLE : {\\n                read();\\n                Table table = readTableName();\\n                if (table.isView()) {\\n                    table = ((View) table).getSubqueryTable();\\n                }\\n                select = new QuerySpecification(session, table,\\n                                                compileContext, false);\\n                break;\\n            }\\n            case Tokens.VALUES : {\\n                read();\\n                SubQuery sq = XreadRowValueExpressionList();\\n                select = new QuerySpecification(session, sq.getTable(),\\n                                                compileContext, true);\\n                break;\\n            }\\n            case Tokens.SELECT : {\\n                select = XreadQuerySpecification();\\n                break;\\n            }\\n            default : {\\n                throw unexpectedToken();\\n            }\\n        }\\n        return select;\\n    }\\n    QuerySpecification XreadQuerySpecification() {\\n        QuerySpecification select = XreadSelect();\\n        if (!select.isValueList) {\\n            XreadTableExpression(select);\\n        }\\n        return select;\\n    }\\n    void XreadTableExpression(QuerySpecification select) {\\n        XreadFromClause(select);\\n        readWhereGroupHaving(select);\\n    }\\n    QuerySpecification XreadSelect() {\\n        QuerySpecification select = new QuerySpecification(compileContext);\\n        readThis(Tokens.SELECT);\\n        if (token.tokenType == Tokens.TOP || token.tokenType == Tokens.LIMIT) {\\n            SortAndSlice sortAndSlice = XreadTopOrLimit();\\n            if (sortAndSlice != null) {\\n                select.addSortAndSlice(sortAndSlice);\\n            }\\n        }\\n        if (token.tokenType == Tokens.DISTINCT) {\\n            select.isDistinctSelect = true;\\n            read();\\n        } else if (token.tokenType == Tokens.ALL) {\\n            read();\\n        }\\n        while (true) {\\n            Expression e = XreadValueExpression();\\n            if (token.tokenType == Tokens.AS) {\\n                read();\\n                checkIsNonCoreReservedIdentifier();\\n            }\\n            if (isNonCoreReservedIdentifier()) {\\n                e.setAlias(HsqlNameManager.getSimpleName(token.tokenString,\\n                        isDelimitedIdentifier()));\\n                read();\\n            }\\n            select.addSelectColumnExpression(e);\\n            if (token.tokenType == Tokens.FROM) {\\n                break;\\n            }\\n            if (token.tokenType == Tokens.INTO) {\\n                break;\\n            }\\n            if (readIfThis(Tokens.COMMA)) {\\n                continue;\\n            }\\n            if (token.tokenType == Tokens.CLOSEBRACKET\\n                    || token.tokenType == Tokens.X_ENDPARSE) {\\n                if (database.sqlSyntaxMss || database.sqlSyntaxMys\\n                        || database.sqlSyntaxPgs) {\\n                    Expression[] exprList =\\n                        new Expression[select.exprColumnList.size()];\\n                    select.exprColumnList.toArray(exprList);\\n                    Expression valueList = new Expression(OpTypes.VALUELIST,\\n                                                          exprList);\\n                    for (int i = 0; i < valueList.nodes.length; i++) {\\n                        if (valueList.nodes[i].opType != OpTypes.ROW) {\\n                            valueList.nodes[i] =\\n                                new Expression(OpTypes.ROW,\\n                                               new Expression[]{\\n                                                   valueList.nodes[i] });\\n                        }\\n                    }\\n                    compileContext.subqueryDepth++;\\n                    SubQuery sq = prepareSubquery(valueList);\\n                    select = new QuerySpecification(session, sq.getTable(),\\n                                                    compileContext, true);\\n                    compileContext.subqueryDepth--;\\n                    return select;\\n                }\\n            }\\n            throw unexpectedToken();\\n        }\\n        return select;\\n    }\\n    void XreadFromClause(QuerySpecification select) {\\n        readThis(Tokens.FROM);\\n        while (true) {\\n            XreadTableReference(select);\\n            if (readIfThis(Tokens.COMMA)) {\\n                continue;\\n            }\\n            break;\\n        }\\n    }\\n    void XreadTableReference(QuerySpecification select) {\\n        boolean       natural = false;\\n        RangeVariable range   = readTableOrSubquery(null);\\n        select.addRangeVariable(range);\\n        while (true) {\\n            int     type;\\n            boolean left  = false;\\n            boolean right = false;\\n            boolean end   = false;\\n            type = token.tokenType;\\n            switch (token.tokenType) {\\n                case Tokens.INNER :\\n                    read();\\n                    readThis(Tokens.JOIN);\\n                    break;\\n                case Tokens.CROSS :\\n                    if (natural) {\\n                        throw unexpectedToken();\\n                    }\\n                    read();\\n                    readThis(Tokens.JOIN);\\n                    break;\\n                case Tokens.UNION :\\n                    if (natural) {\\n                        throw unexpectedToken();\\n                    }\\n                    int position = getPosition();\\n                    read();\\n                    if (token.tokenType == Tokens.JOIN) {\\n                        read();\\n                        break;\\n                    } else {\\n                        rewind(position);\\n                        end = true;\\n                        break;\\n                    }\\n                case Tokens.NATURAL :\\n                    if (natural) {\\n                        throw unexpectedToken();\\n                    }\\n                    read();\\n                    natural = true;\\n                    continue;\\n                case Tokens.LEFT :\\n                    read();\\n                    readIfThis(Tokens.OUTER);\\n                    readThis(Tokens.JOIN);\\n                    left = true;\\n                    break;\\n                case Tokens.RIGHT :\\n                    read();\\n                    readIfThis(Tokens.OUTER);\\n                    readThis(Tokens.JOIN);\\n                    right = true;\\n                    break;\\n                case Tokens.FULL :\\n                    read();\\n                    readIfThis(Tokens.OUTER);\\n                    readThis(Tokens.JOIN);\\n                    left  = true;\\n                    right = true;\\n                    break;\\n                case Tokens.JOIN :\\n                    read();\\n                    type = Tokens.INNER;\\n                    break;\\n                case Tokens.COMMA :\\n                    if (natural) {\\n                        throw unexpectedToken();\\n                    }\\n                    read();\\n                    type = Tokens.COMMA;\\n                    break;\\n                default :\\n                    if (natural) {\\n                        throw unexpectedToken();\\n                    }\\n                    end = true;\\n                    break;\\n            }\\n            if (end) {\\n                break;\\n            }\\n            range = readTableOrSubquery(null);\\n            Expression condition = null;\\n            switch (type) {\\n                case Tokens.COMMA :\\n                    range.isBoundary = true;\\n                    select.addRangeVariable(range);\\n                    break;\\n                case Tokens.CROSS :\\n                    select.addRangeVariable(range);\\n                    break;\\n                case Tokens.UNION :\\n                    select.addRangeVariable(range);\\n                    condition = Expression.EXPR_FALSE;\\n                    range.setJoinType(true, true);\\n                    break;\\n                case Tokens.LEFT :\\n                case Tokens.RIGHT :\\n                case Tokens.INNER :\\n                case Tokens.FULL : {\\n                    if (natural) {\\n                        OrderedHashSet columns =\\n                            range.getUniqueColumnNameSet();\\n                        condition = select.getEquiJoinExpressions(columns,\\n                                range, false);\\n                        select.addRangeVariable(range);\\n                    } else if (token.tokenType == Tokens.USING) {\\n                        read();\\n                        OrderedHashSet columns = new OrderedHashSet();\\n                        readThis(Tokens.OPENBRACKET);\\n                        readSimpleColumnNames(columns, range);\\n                        readThis(Tokens.CLOSEBRACKET);\\n                        condition = select.getEquiJoinExpressions(columns,\\n                                range, true);\\n                        select.addRangeVariable(range);\\n                    } else if (token.tokenType == Tokens.ON) {\\n                        read();\\n                        condition = XreadBooleanValueExpression();\\n                        select.addRangeVariable(range);\\n                    } else {\\n                        throw unexpectedToken();\\n                    }\\n                    range.setJoinType(left, right);\\n                    break;\\n                }\\n            }\\n            range.addJoinCondition(condition);\\n            natural = false;\\n        }\\n    }\\n    Expression getRowExpression(OrderedHashSet columnNames) {\\n        Expression[] elements = new Expression[columnNames.size()];\\n        for (int i = 0; i < elements.length; i++) {\\n            String name = (String) columnNames.get(i);\\n            elements[i] = new ExpressionColumn(null, null, name);\\n        }\\n        return new Expression(OpTypes.ROW, elements);\\n    }\\n    void readWhereGroupHaving(QuerySpecification select) {\\n                if (token.tokenType == Tokens.WHERE) {\\n            read();\\n            Expression e = XreadBooleanValueExpression();\\n            select.addQueryCondition(e);\\n        }\\n                if (token.tokenType == Tokens.GROUP) {\\n            read();\\n            readThis(Tokens.BY);\\n            while (true) {\\n                Expression e = XreadValueExpression();\\n                select.addGroupByColumnExpression(e);\\n                if (token.tokenType == Tokens.COMMA) {\\n                    read();\\n                    continue;\\n                }\\n                break;\\n            }\\n        }\\n                if (token.tokenType == Tokens.HAVING) {\\n            read();\\n            Expression e = XreadBooleanValueExpression();\\n            select.addHavingExpression(e);\\n        }\\n    }\\n    SortAndSlice XreadOrderByExpression() {\\n        SortAndSlice sortAndSlice = null;\\n        if (token.tokenType == Tokens.ORDER) {\\n            read();\\n            readThis(Tokens.BY);\\n            sortAndSlice = XreadOrderBy();\\n        }\\n        if (token.tokenType == Tokens.LIMIT || token.tokenType == Tokens.FETCH\\n                || token.tokenType == Tokens.OFFSET) {\\n            if (sortAndSlice == null) {\\n                sortAndSlice = new SortAndSlice();\\n            }\\n            XreadLimit(sortAndSlice);\\n        }\\n        return sortAndSlice == null ? SortAndSlice.noSort\\n                                    : sortAndSlice;\\n    }\\n    private SortAndSlice XreadTopOrLimit() {\\n        Expression e1 = null;\\n        Expression e2 = null;\\n        if (token.tokenType == Tokens.LIMIT) {\\n            int position = getPosition();\\n            read();\\n            e1 = XreadSimpleValueSpecificationOrNull();\\n            if (e1 == null) {\\n                rewind(position);\\n                return null;\\n            }\\n            e2 = XreadSimpleValueSpecificationOrNull();\\n            if (e2 == null) {\\n                throw Error.error(ErrorCode.X_42563,\\n                                  ErrorCode.M_INVALID_LIMIT);\\n            }\\n        } else if (token.tokenType == Tokens.TOP) {\\n            int position = getPosition();\\n            read();\\n            e2 = XreadSimpleValueSpecificationOrNull();\\n            if (e2 == null) {\\n                rewind(position);\\n                return null;\\n            }\\n            e1 = new ExpressionValue(ValuePool.INTEGER_0, Type.SQL_INTEGER);\\n        }\\n        boolean valid = true;\\n        if (e1.isUnresolvedParam()) {\\n            e1.setDataType(session, Type.SQL_INTEGER);\\n        } else {\\n            valid = (e1.getDataType().typeCode == Types.SQL_INTEGER\\n                     && ((Integer) e1.getValue(null)).intValue() >= 0);\\n        }\\n        if (e2.isUnresolvedParam()) {\\n            e2.setDataType(session, Type.SQL_INTEGER);\\n        } else {\\n            valid &= (e2.getDataType().typeCode == Types.SQL_INTEGER\\n                      && ((Integer) e2.getValue(null)).intValue() >= 0);\\n        }\\n        if (valid) {\\n            SortAndSlice sortAndSlice = new SortAndSlice();\\n            sortAndSlice.addLimitCondition(new ExpressionOp(OpTypes.LIMIT, e1,\\n                    e2));\\n            return sortAndSlice;\\n        }\\n        throw Error.error(ErrorCode.X_42563, ErrorCode.M_INVALID_LIMIT);\\n    }\\n    private void XreadLimit(SortAndSlice sortAndSlice) {\\n        Expression e1 = null;\\n        Expression e2 = null;\\n        if (token.tokenType == Tokens.OFFSET) {\\n            read();\\n            e1 = XreadSimpleValueSpecificationOrNull();\\n            if (e1 == null) {\\n                throw Error.error(ErrorCode.X_42563,\\n                                  ErrorCode.M_INVALID_LIMIT);\\n            }\\n            if (token.tokenType == Tokens.ROW\\n                    || token.tokenType == Tokens.ROWS) {\\n                read();\\n            }\\n        }\\n        if (token.tokenType == Tokens.LIMIT) {\\n            read();\\n            e2 = XreadSimpleValueSpecificationOrNull();\\n            if (e2 == null) {\\n                throw Error.error(ErrorCode.X_42563,\\n                                  ErrorCode.M_INVALID_LIMIT);\\n            }\\n            if (e1 == null && token.tokenType == Tokens.OFFSET) {\\n                read();\\n                e1 = XreadSimpleValueSpecificationOrNull();\\n            }\\n        } else if (token.tokenType == Tokens.FETCH) {\\n            read();\\n            if (token.tokenType == Tokens.FIRST\\n                    || token.tokenType == Tokens.NEXT) {\\n                read();\\n            }\\n            e2 = XreadSimpleValueSpecificationOrNull();\\n            if (e2 == null) {\\n                e2 = new ExpressionValue(ValuePool.INTEGER_1,\\n                                         Type.SQL_INTEGER);\\n            }\\n            if (token.tokenType == Tokens.ROW\\n                    || token.tokenType == Tokens.ROWS) {\\n                read();\\n            }\\n            readThis(Tokens.ONLY);\\n            sortAndSlice.setStrictLimit();\\n        }\\n        if (e1 == null) {\\n            e1 = new ExpressionValue(ValuePool.INTEGER_0, Type.SQL_INTEGER);\\n        }\\n        boolean valid = true;\\n        if (e1.isUnresolvedParam()) {\\n            e1.setDataType(session, Type.SQL_INTEGER);\\n        }\\n        if (e2 != null) {\\n            if (e2.isUnresolvedParam()) {\\n                e2.setDataType(session, Type.SQL_INTEGER);\\n            }\\n        }\\n        if (valid) {\\n            sortAndSlice.addLimitCondition(new ExpressionOp(OpTypes.LIMIT, e1,\\n                    e2));\\n            return;\\n        }\\n        throw Error.error(ErrorCode.X_42563, ErrorCode.M_INVALID_LIMIT);\\n    }\\n    private SortAndSlice XreadOrderBy() {\\n        SortAndSlice sortAndSlice = new SortAndSlice();\\n        while (true) {\\n            Expression        e = XreadValueExpression();\\n            ExpressionOrderBy o = new ExpressionOrderBy(e);\\n            if (token.tokenType == Tokens.DESC) {\\n                o.setDescending();\\n                read();\\n            } else if (token.tokenType == Tokens.ASC) {\\n                read();\\n            }\\n            if (token.tokenType == Tokens.NULLS) {\\n                read();\\n                if (token.tokenType == Tokens.FIRST) {\\n                    read();\\n                } else if (token.tokenType == Tokens.LAST) {\\n                    read();\\n                    o.setNullsLast();\\n                } else {\\n                    throw unexpectedToken();\\n                }\\n            }\\n            sortAndSlice.addOrderExpression(o);\\n            if (token.tokenType == Tokens.COMMA) {\\n                read();\\n                continue;\\n            }\\n            break;\\n        }\\n        return sortAndSlice;\\n    }\\n    protected RangeVariable readSimpleRangeVariable(int operation) {\\n        Table      table = readTableName();\\n        SimpleName alias = null;\\n        if (operation != StatementTypes.TRUNCATE) {\\n            if (token.tokenType == Tokens.AS) {\\n                read();\\n                checkIsNonCoreReservedIdentifier();\\n            }\\n            if (isNonCoreReservedIdentifier()) {\\n                alias = HsqlNameManager.getSimpleName(token.tokenString,\\n                                                      isDelimitedIdentifier());\\n                read();\\n            }\\n        }\\n        if (table.isView) {\\n            switch (operation) {\\n                case StatementTypes.MERGE :\\n                    if (table.isTriggerUpdatable()\\n                            && table.isTriggerDeletable()) {\\n                        break;\\n                    }\\n                    if (table.isUpdatable() && table.isInsertable()) {\\n                        break;\\n                    }\\n                    throw Error.error(ErrorCode.X_42545);\\n                case StatementTypes.UPDATE_WHERE :\\n                    if (table.isTriggerUpdatable()) {\\n                        break;\\n                    }\\n                    if (table.isUpdatable()) {\\n                        break;\\n                    }\\n                    throw Error.error(ErrorCode.X_42545);\\n                case StatementTypes.DELETE_WHERE :\\n                    if (table.isTriggerDeletable()) {\\n                        break;\\n                    }\\n                    if (table.isUpdatable()) {\\n                        break;\\n                    }\\n                    throw Error.error(ErrorCode.X_42545);\\n            }\\n            table = ((View) table).getSubqueryTable();\\n        }\\n        RangeVariable range = new RangeVariable(table, alias, null, null,\\n            compileContext);\\n        return range;\\n    }\\n    protected Table readNamedSubqueryOrNull() {\\n        if (!isSimpleName()) {\\n            return null;\\n        }\\n        SubQuery sq = compileContext.getNamedSubQuery(token.tokenString);\\n        if (sq == null) {\\n            return null;\\n        }\\n        read();\\n        return sq.getTable();\\n    }\\n    protected RangeVariable readTableOrSubquery(RangeVariable[] outerRanges) {\\n        Table          table          = null;\\n        SimpleName     alias          = null;\\n        SimpleName[]   columnNameList = null;\\n        OrderedHashSet columnList     = null;\\n        boolean        joinedTable    = false;\\n        switch (token.tokenType) {\\n            case Tokens.OPENBRACKET : {\\n                table = XreadTableSubqueryOrNull(outerRanges);\\n                if (table == null) {\\n                    SubQuery sq = XreadJoinedTableAsSubquery();\\n                    table       = sq.getTable();\\n                    joinedTable = true;\\n                }\\n                break;\\n            }\\n            case Tokens.UNNEST : {\\n                Expression e = XreadCollectionDerivedTable();\\n                table = e.getTable();\\n                break;\\n            }\\n            case Tokens.LATERAL : {\\n                Expression e = XreadLateralDerivedTable();\\n                table = e.getTable();\\n                break;\\n            }\\n            case Tokens.TABLE : {\\n                Expression e = XreadTableFunctionDerivedTable();\\n                table = e.getTable();\\n                break;\\n            }\\n            default : {\\n                table = readNamedSubqueryOrNull();\\n                if (table == null) {\\n                    table = readTableName();\\n                }\\n                if (table.isView()) {\\n                    table = ((View) table).getSubqueryTable();\\n                }\\n            }\\n        }\\n        boolean hasAs = false;\\n        if (token.tokenType == Tokens.AS) {\\n            read();\\n            checkIsNonCoreReservedIdentifier();\\n            hasAs = true;\\n        }\\n        if (isNonCoreReservedIdentifier()) {\\n            boolean limit = token.tokenType == Tokens.LIMIT\\n                            || token.tokenType == Tokens.OFFSET\\n                            || token.tokenType == Tokens.FETCH;\\n            boolean minus    = token.tokenType == Tokens.MINUS_EXCEPT;\\n            int     position = getPosition();\\n            alias = HsqlNameManager.getSimpleName(token.tokenString,\\n                                                  isDelimitedIdentifier());\\n            read();\\n            if (token.tokenType == Tokens.OPENBRACKET) {\\n                columnList     = new OrderedHashSet();\\n                columnNameList = readColumnNameList(columnList);\\n            } else if (!hasAs && limit) {\\n                if (token.tokenType == Tokens.COLON\\n                        || token.tokenType == Tokens.QUESTION\\n                        || token.tokenType == Tokens.X_VALUE) {\\n                    alias = null;\\n                    rewind(position);\\n                }\\n            } else if (!hasAs && minus) {\\n                rewind(position);\\n            }\\n        }\\n        RangeVariable range;\\n        if (joinedTable) {\\n            range = new RangeVariableJoined(table, alias, columnList,\\n                                            columnNameList, compileContext);\\n        } else {\\n            range = new RangeVariable(table, alias, columnList,\\n                                      columnNameList, compileContext);\\n        }\\n        return range;\\n    }\\n    private Expression readAggregate() {\\n        int        tokenT = token.tokenType;\\n        Expression e;\\n        read();\\n        readThis(Tokens.OPENBRACKET);\\n        e = readAggregateExpression(tokenT);\\n        readThis(Tokens.CLOSEBRACKET);\\n        readFilterClause(e);\\n        return e;\\n    }\\n    private void readFilterClause(Expression e) {\\n        int position = getPosition();\\n        if (token.tokenType == Tokens.FILTER) {\\n            read();\\n            if (token.tokenType != Tokens.OPENBRACKET) {\\n                rewind(position);\\n                return;\\n            }\\n            readThis(Tokens.OPENBRACKET);\\n            readThis(Tokens.WHERE);\\n            Expression condition = XreadBooleanValueExpression();\\n            e.setCondition(condition);\\n            readThis(Tokens.CLOSEBRACKET);\\n        }\\n    }\\n    private Expression readAggregateExpression(int tokenT) {\\n        int          type      = ParserDQL.getExpressionType(tokenT);\\n        boolean      distinct  = false;\\n        boolean      all       = false;\\n        SortAndSlice sort      = null;\\n        String       separator = null;\\n        if (token.tokenType == Tokens.DISTINCT) {\\n            distinct = true;\\n            read();\\n        } else if (token.tokenType == Tokens.ALL) {\\n            all = true;\\n            read();\\n        }\\n        Expression e = XreadValueExpression();\\n        switch (type) {\\n            case OpTypes.COUNT :\\n                if (e.getType() == OpTypes.MULTICOLUMN) {\\n                    if (((ExpressionColumn) e).tableName != null) {\\n                        throw unexpectedToken();\\n                    }\\n                    if (all || distinct) {\\n                        throw unexpectedToken();\\n                    }\\n                    e.opType = OpTypes.ASTERISK;\\n                    break;\\n                } else {\\n                    break;\\n                }\\n            case OpTypes.STDDEV_POP :\\n            case OpTypes.STDDEV_SAMP :\\n            case OpTypes.VAR_POP :\\n            case OpTypes.VAR_SAMP :\\n                if (all || distinct) {\\n                    throw Error.error(ErrorCode.X_42582, all ? Tokens.T_ALL\\n                                                             : Tokens\\n                                                             .T_DISTINCT);\\n                }\\n                break;\\n            case OpTypes.ARRAY_AGG :\\n            case OpTypes.GROUP_CONCAT : {\\n                if (token.tokenType == Tokens.ORDER) {\\n                    read();\\n                    readThis(Tokens.BY);\\n                    sort = XreadOrderBy();\\n                }\\n                if (type == OpTypes.GROUP_CONCAT) {\\n                    if (token.tokenType == Tokens.SEPARATOR) {\\n                        read();\\n                        super.checkIsValue(Types.SQL_CHAR);\\n                        separator = (String) token.tokenValue;\\n                        read();\\n                    }\\n                }\\n                return new ExpressionArrayAggregate(type, distinct, e, sort,\\n                                                    separator);\\n            }\\n            case OpTypes.MEDIAN : {\\n                return new ExpressionArrayAggregate(type, distinct, e, sort,\\n                                                    separator);\\n            }\\n            default :\\n                if (e.getType() == OpTypes.ASTERISK) {\\n                    throw unexpectedToken();\\n                }\\n        }\\n        Expression aggregateExp = new ExpressionAggregate(type, distinct, e);\\n        return aggregateExp;\\n    }\\n            Expression XreadValueSpecificationOrNull() {\\n        Expression e     = null;\\n        boolean    minus = false;\\n        switch (token.tokenType) {\\n            case Tokens.PLUS :\\n                read();\\n                break;\\n            case Tokens.MINUS :\\n                read();\\n                minus = true;\\n                break;\\n        }\\n        e = XreadUnsignedValueSpecificationOrNull();\\n        if (e == null) {\\n            return null;\\n        }\\n        if (minus) {\\n            e = new ExpressionArithmetic(OpTypes.NEGATE, e);\\n        }\\n        return e;\\n    }\\n            Expression XreadUnsignedValueSpecificationOrNull() {\\n        Expression e;\\n        switch (token.tokenType) {\\n            case Tokens.TRUE :\\n                read();\\n                return Expression.EXPR_TRUE;\\n            case Tokens.FALSE :\\n                read();\\n                return Expression.EXPR_FALSE;\\n            case Tokens.DEFAULT :\\n                if (compileContext.contextuallyTypedExpression) {\\n                    read();\\n                    e = new ExpressionColumn(OpTypes.DEFAULT);\\n                    return e;\\n                }\\n                break;\\n            case Tokens.NULL :\\n                e = new ExpressionValue(null, null);\\n                read();\\n                return e;\\n            case Tokens.X_VALUE :\\n                e = new ExpressionValue(token.tokenValue, token.dataType);\\n                read();\\n                return e;\\n            case Tokens.X_DELIMITED_IDENTIFIER :\\n            case Tokens.X_IDENTIFIER :\\n                if (!token.isHostParameter) {\\n                    return null;\\n                }\\n                return null;\\n            case Tokens.COLON :\\n                read();\\n                if (token.tokenType == Tokens.X_DELIMITED_IDENTIFIER\\n                        || token.tokenType == Tokens.X_IDENTIFIER) {}\\n                else {\\n                    throw unexpectedToken(Tokens.T_COLON);\\n                }\\n                        case Tokens.QUESTION :\\n                e = new ExpressionColumn(OpTypes.DYNAMIC_PARAM);\\n                compileContext.addParameter(e, getPosition());\\n                read();\\n                return e;\\n            case Tokens.COLLATION :\\n                return XreadCurrentCollationSpec();\\n            case Tokens.VALUE :\\n            case Tokens.CURRENT_CATALOG :\\n            case Tokens.CURRENT_DEFAULT_TRANSFORM_GROUP :\\n            case Tokens.CURRENT_PATH :\\n            case Tokens.CURRENT_ROLE :\\n            case Tokens.CURRENT_SCHEMA :\\n            case Tokens.CURRENT_TRANSFORM_GROUP_FOR_TYPE :\\n            case Tokens.CURRENT_USER :\\n            case Tokens.SESSION_USER :\\n            case Tokens.SYSTEM_USER :\\n            case Tokens.USER :\\n                FunctionSQL function =\\n                    FunctionSQL.newSQLFunction(token.tokenString,\\n                                               compileContext);\\n                if (function == null) {\\n                    return null;\\n                }\\n                return readSQLFunction(function);\\n                    }\\n        return null;\\n    }\\n        Expression XreadSimpleValueSpecificationOrNull() {\\n        Expression e;\\n        switch (token.tokenType) {\\n            case Tokens.X_VALUE :\\n                e = new ExpressionValue(token.tokenValue, token.dataType);\\n                read();\\n                return e;\\n            case Tokens.COLON :\\n                read();\\n                if (token.tokenType == Tokens.X_DELIMITED_IDENTIFIER\\n                        || token.tokenType == Tokens.X_IDENTIFIER) {}\\n                else {\\n                    throw unexpectedToken(Tokens.T_COLON);\\n                }\\n                        case Tokens.QUESTION :\\n                e = new ExpressionColumn(OpTypes.DYNAMIC_PARAM);\\n                compileContext.addParameter(e, getPosition());\\n                read();\\n                return e;\\n            case Tokens.X_IDENTIFIER :\\n            case Tokens.X_DELIMITED_IDENTIFIER :\\n                checkValidCatalogName(token.namePrePrePrefix);\\n                e = new ExpressionColumn(token.namePrePrefix,\\n                                         token.namePrefix, token.tokenString);\\n                read();\\n                return e;\\n            default :\\n                return null;\\n        }\\n    }\\n                Expression XreadAllTypesValueExpressionPrimary(boolean boole) {\\n        Expression e = null;\\n        switch (token.tokenType) {\\n            case Tokens.EXISTS :\\n            case Tokens.UNIQUE :\\n                if (boole) {\\n                    return XreadPredicate();\\n                }\\n                break;\\n            case Tokens.ROW :\\n                if (boole) {\\n                    break;\\n                }\\n                read();\\n                readThis(Tokens.OPENBRACKET);\\n                e = XreadRowElementList(true);\\n                readThis(Tokens.CLOSEBRACKET);\\n                break;\\n            default :\\n                e = XreadSimpleValueExpressionPrimary();\\n                if (e != null) {\\n                    e = XreadArrayElementReference(e);\\n                }\\n        }\\n        if (e == null && token.tokenType == Tokens.OPENBRACKET) {\\n            read();\\n            e = XreadRowElementList(true);\\n            readThis(Tokens.CLOSEBRACKET);\\n        }\\n        if (boole && e != null) {\\n            e = XreadPredicateRightPart(e);\\n        }\\n        return e;\\n    }\\n                Expression XreadValueExpressionPrimary() {\\n        Expression e;\\n        e = XreadSimpleValueExpressionPrimary();\\n        if (e != null) {\\n            e = XreadArrayElementReference(e);\\n            return e;\\n        }\\n        if (token.tokenType == Tokens.OPENBRACKET) {\\n            read();\\n            e = XreadValueExpression();\\n            readThis(Tokens.CLOSEBRACKET);\\n        } else {\\n            return null;\\n        }\\n        return e;\\n    }\\n                Expression XreadSimpleValueExpressionPrimary() {\\n        Expression e;\\n        e = XreadUnsignedValueSpecificationOrNull();\\n        if (e != null) {\\n            return e;\\n        }\\n        int position = getPosition();\\n        switch (token.tokenType) {\\n            case Tokens.OPENBRACKET :\\n                read();\\n                int subqueryPosition = getPosition();\\n                int brackets         = readOpenBrackets();\\n                switch (token.tokenType) {\\n                    case Tokens.TABLE :\\n                    case Tokens.VALUES :\\n                    case Tokens.SELECT :\\n                        SubQuery sq = null;\\n                        rewind(subqueryPosition);\\n                        try {\\n                            sq = XreadSubqueryBody(OpTypes.SCALAR_SUBQUERY);\\n                            readThis(Tokens.CLOSEBRACKET);\\n                        } catch (HsqlException ex) {\\n                            ex.setLevel(compileContext.subqueryDepth);\\n                            if (lastError == null\\n                                    || lastError.getLevel() < ex.getLevel()) {\\n                                lastError = ex;\\n                            }\\n                            rewind(position);\\n                            return null;\\n                        }\\n                        if (sq.queryExpression.isSingleColumn()) {\\n                            e = new Expression(OpTypes.SCALAR_SUBQUERY, sq);\\n                        } else {\\n                            e = new Expression(OpTypes.ROW_SUBQUERY, sq);\\n                        }\\n                        if (readCloseBrackets(brackets) != brackets) {\\n                            throw unexpectedToken();\\n                        }\\n                        return e;\\n                    default :\\n                        rewind(position);\\n                        return null;\\n                }\\n            case Tokens.ASTERISK :\\n                e = new ExpressionColumn(token.namePrePrefix,\\n                                         token.namePrefix);\\n                getRecordedToken().setExpression(e);\\n                read();\\n                return e;\\n            case Tokens.LEAST :\\n                return readLeastExpression();\\n            case Tokens.GREATEST :\\n                return readGreatestExpression();\\n            case Tokens.DECODE :\\n                return readDecodeExpression();\\n            case Tokens.CONCAT_WORD :\\n                return readConcatExpression();\\n            case Tokens.CASEWHEN :\\n                return readCaseWhenExpression();\\n            case Tokens.CASE :\\n                return readCaseExpression();\\n            case Tokens.NULLIF :\\n                return readNullIfExpression();\\n            case Tokens.COALESCE :\\n            case Tokens.IFNULL :\\n            case Tokens.ISNULL :\\n                return readCoalesceExpression();\\n            case Tokens.CAST :\\n            case Tokens.CONVERT :\\n                return readCastExpression();\\n            case Tokens.DATE :\\n            case Tokens.TIME :\\n            case Tokens.TIMESTAMP :\\n            case Tokens.INTERVAL :\\n                e = readDateTimeIntervalLiteral();\\n                if (e != null) {\\n                    return e;\\n                }\\n                break;\\n            case Tokens.ARRAY :\\n                return readCollection(OpTypes.ARRAY);\\n            case Tokens.ANY :\\n            case Tokens.SOME :\\n            case Tokens.EVERY :\\n            case Tokens.COUNT :\\n            case Tokens.MAX :\\n            case Tokens.MIN :\\n            case Tokens.SUM :\\n            case Tokens.AVG :\\n            case Tokens.STDDEV_POP :\\n            case Tokens.STDDEV_SAMP :\\n            case Tokens.VAR_POP :\\n            case Tokens.VAR_SAMP :\\n            case Tokens.GROUP_CONCAT :\\n            case Tokens.ARRAY_AGG :\\n            case Tokens.MEDIAN :\\n                return readAggregate();\\n            case Tokens.NEXT : {\\n                e = readSequenceExpressionOrNull(OpTypes.SEQUENCE);\\n                if (e != null) {\\n                    return e;\\n                }\\n                break;\\n            }\\n            case Tokens.CURRENT : {\\n                e = readSequenceExpressionOrNull(OpTypes.SEQUENCE_CURRENT);\\n                if (e != null) {\\n                    return e;\\n                }\\n                break;\\n            }\\n            case Tokens.CURRVAL : {\\n                if (database.sqlSyntaxPgs) {\\n                    read();\\n                    readThis(Tokens.OPENBRACKET);\\n                    String  spec    = readQuotedString();\\n                    Scanner scanner = session.getScanner();\\n                    scanner.reset(spec);\\n                    scanner.scanNext();\\n                    String schemaName =\\n                        session.getSchemaName(scanner.token.namePrefix);\\n                    NumberSequence sequence =\\n                        database.schemaManager.getSequence(\\n                            scanner.token.tokenString, schemaName, true);\\n                    e = new ExpressionColumn(sequence,\\n                                             OpTypes.SEQUENCE_CURRENT);\\n                    readThis(Tokens.CLOSEBRACKET);\\n                    return e;\\n                }\\n                break;\\n            }\\n            case Tokens.LASTVAL : {\\n                if (database.sqlSyntaxPgs) {\\n                    read();\\n                    readThis(Tokens.OPENBRACKET);\\n                    readThis(Tokens.CLOSEBRACKET);\\n                    return FunctionCustom.newCustomFunction(Tokens.T_IDENTITY,\\n                            Tokens.IDENTITY);\\n                }\\n                break;\\n            }\\n            case Tokens.NEXTVAL : {\\n                if (database.sqlSyntaxPgs) {\\n                    read();\\n                    readThis(Tokens.OPENBRACKET);\\n                    String  spec    = readQuotedString();\\n                    Scanner scanner = session.getScanner();\\n                    scanner.reset(spec);\\n                    scanner.scanNext();\\n                    String schemaName =\\n                        session.getSchemaName(scanner.token.namePrefix);\\n                    NumberSequence sequence =\\n                        database.schemaManager.getSequence(\\n                            scanner.token.tokenString, schemaName, true);\\n                    e = new ExpressionColumn(sequence, OpTypes.SEQUENCE);\\n                    readThis(Tokens.CLOSEBRACKET);\\n                    return e;\\n                }\\n                break;\\n            }\\n            case Tokens.LEFT :\\n            case Tokens.RIGHT :\\n                                break;\\n            case Tokens.TABLE : {\\n                read();\\n                readThis(Tokens.OPENBRACKET);\\n                SubQuery sq = XreadSubqueryBody(OpTypes.TABLE_SUBQUERY);\\n                readThis(Tokens.CLOSEBRACKET);\\n                return new Expression(OpTypes.TABLE_SUBQUERY, sq);\\n            }\\n            default :\\n                if (isCoreReservedKey()) {\\n                    throw unexpectedToken();\\n                }\\n        }\\n        e = readColumnOrFunctionExpression();\\n        if (e.isAggregate()) {\\n            readFilterClause(e);\\n        }\\n        return e;\\n    }\\n            Expression XreadAllTypesPrimary(boolean boole) {\\n        Expression e = null;\\n        switch (token.tokenType) {\\n            case Tokens.SUBSTRING :\\n            case Tokens.SUBSTRING_REGEX :\\n            case Tokens.LOWER :\\n            case Tokens.UPPER :\\n            case Tokens.TRANSLATE_REGEX :\\n            case Tokens.TRIM :\\n            case Tokens.OVERLAY :\\n            case Tokens.NORMALIZE :\\n                        case Tokens.POSITION :\\n            case Tokens.OCCURRENCES_REGEX :\\n            case Tokens.POSITION_REGEX :\\n            case Tokens.EXTRACT :\\n            case Tokens.CHAR_LENGTH :\\n            case Tokens.CHARACTER_LENGTH :\\n            case Tokens.OCTET_LENGTH :\\n            case Tokens.CARDINALITY :\\n            case Tokens.ABS :\\n            case Tokens.MOD :\\n            case Tokens.LN :\\n            case Tokens.EXP :\\n            case Tokens.POWER :\\n            case Tokens.SQRT :\\n            case Tokens.FLOOR :\\n            case Tokens.CEILING :\\n            case Tokens.CEIL :\\n            case Tokens.WIDTH_BUCKET :\\n                FunctionSQL function =\\n                    FunctionSQL.newSQLFunction(token.tokenString,\\n                                               compileContext);\\n                if (function == null) {\\n                    throw unsupportedFeature();\\n                }\\n                e = readSQLFunction(function);\\n                if (e != null) {\\n                    break;\\n                }\\n            default :\\n                e = XreadAllTypesValueExpressionPrimary(boole);\\n        }\\n        e = XreadModifier(e);\\n        return e;\\n    }\\n    Expression XreadModifier(Expression e) {\\n        switch (token.tokenType) {\\n            case Tokens.AT : {\\n                read();\\n                Expression e1 = null;\\n                if (token.tokenType == Tokens.LOCAL) {\\n                    read();\\n                } else {\\n                    readThis(Tokens.TIME);\\n                    readThis(Tokens.ZONE);\\n                    e1 = XreadValueExpressionPrimary();\\n                    switch (token.tokenType) {\\n                        case Tokens.YEAR :\\n                        case Tokens.MONTH :\\n                        case Tokens.DAY :\\n                        case Tokens.HOUR :\\n                        case Tokens.MINUTE :\\n                        case Tokens.SECOND : {\\n                            IntervalType type = readIntervalType(false);\\n                            if (e1.getType() == OpTypes.SUBTRACT) {\\n                                e1.dataType = type;\\n                            } else {\\n                                e1 = new ExpressionOp(e1, type);\\n                            }\\n                        }\\n                    }\\n                }\\n                e = new ExpressionOp(OpTypes.ZONE_MODIFIER, e, e1);\\n                break;\\n            }\\n            case Tokens.YEAR :\\n            case Tokens.MONTH :\\n            case Tokens.DAY :\\n            case Tokens.HOUR :\\n            case Tokens.MINUTE :\\n            case Tokens.SECOND : {\\n                IntervalType type = readIntervalType(true);\\n                if (e.getType() == OpTypes.SUBTRACT) {\\n                    e.dataType = type;\\n                } else {\\n                    e = new ExpressionOp(e, type);\\n                }\\n                break;\\n            }\\n            case Tokens.COLLATE : {\\n                read();\\n                if (token.namePrefix == null) {\\n                    Collation collation;\\n                    try {\\n                        collation = Collation.getCollation(token.tokenString);\\n                    } catch (HsqlException ex) {\\n                        collation =\\n                            (Collation) database.schemaManager.getSchemaObject(\\n                                session.getSchemaName(token.namePrefix),\\n                                token.tokenString, SchemaObject.COLLATION);\\n                    }\\n                    e.setCollation(collation);\\n                    read();\\n                }\\n            }\\n        }\\n        return e;\\n    }\\n    Expression XreadValueExpressionWithContext() {\\n        Expression e;\\n        compileContext.contextuallyTypedExpression = true;\\n        e = XreadValueExpressionOrNull();\\n        compileContext.contextuallyTypedExpression = false;\\n        return e;\\n    }\\n    Expression XreadValueExpressionOrNull() {\\n        Expression e = XreadAllTypesCommonValueExpression(true);\\n        if (e == null) {\\n            return null;\\n        }\\n        return e;\\n    }\\n    Expression XreadValueExpression() {\\n        Expression e = XreadAllTypesCommonValueExpression(true);\\n        if (token.tokenType == Tokens.LEFTBRACKET) {\\n            read();\\n            Expression e1 = XreadNumericValueExpression();\\n            readThis(Tokens.RIGHTBRACKET);\\n            e = new ExpressionAccessor(e, e1);\\n        }\\n        return e;\\n    }\\n        Expression XreadRowOrCommonValueExpression() {\\n        return XreadAllTypesCommonValueExpression(false);\\n    }\\n            Expression XreadAllTypesCommonValueExpression(boolean boole) {\\n        Expression e    = XreadAllTypesTerm(boole);\\n        int        type = 0;\\n        boolean    end  = false;\\n        while (true) {\\n            switch (token.tokenType) {\\n                case Tokens.PLUS :\\n                    type  = OpTypes.ADD;\\n                    boole = false;\\n                    break;\\n                case Tokens.MINUS :\\n                    type  = OpTypes.SUBTRACT;\\n                    boole = false;\\n                    break;\\n                case Tokens.CONCAT :\\n                    type  = OpTypes.CONCAT;\\n                    boole = false;\\n                    break;\\n                case Tokens.OR :\\n                    if (boole) {\\n                        type = OpTypes.OR;\\n                        break;\\n                    }\\n                                default :\\n                    end = true;\\n                    break;\\n            }\\n            if (end) {\\n                break;\\n            }\\n            read();\\n            Expression a = e;\\n            e = XreadAllTypesTerm(boole);\\n            e = boole ? (Expression) new ExpressionLogical(type, a, e)\\n                      : new ExpressionArithmetic(type, a, e);\\n        }\\n        return e;\\n    }\\n    Expression XreadAllTypesTerm(boolean boole) {\\n        Expression e    = XreadAllTypesFactor(boole);\\n        int        type = 0;\\n        boolean    end  = false;\\n        while (true) {\\n            switch (token.tokenType) {\\n                case Tokens.ASTERISK :\\n                    type  = OpTypes.MULTIPLY;\\n                    boole = false;\\n                    break;\\n                case Tokens.DIVIDE :\\n                    type  = OpTypes.DIVIDE;\\n                    boole = false;\\n                    break;\\n                case Tokens.AND :\\n                    if (boole) {\\n                        type = OpTypes.AND;\\n                        break;\\n                    }\\n                                default :\\n                    end = true;\\n                    break;\\n            }\\n            if (end) {\\n                break;\\n            }\\n            read();\\n            Expression a = e;\\n            e = XreadAllTypesFactor(boole);\\n            if (e == null) {\\n                throw unexpectedToken();\\n            }\\n            e = boole ? (Expression) new ExpressionLogical(type, a, e)\\n                      : new ExpressionArithmetic(type, a, e);\\n        }\\n        return e;\\n    }\\n    Expression XreadAllTypesFactor(boolean boole) {\\n        Expression e;\\n        boolean    minus   = false;\\n        boolean    not     = false;\\n        boolean    unknown = false;\\n        switch (token.tokenType) {\\n            case Tokens.PLUS :\\n                read();\\n                boole = false;\\n                break;\\n            case Tokens.MINUS :\\n                read();\\n                boole = false;\\n                minus = true;\\n                break;\\n            case Tokens.NOT :\\n                if (boole) {\\n                    read();\\n                    not = true;\\n                }\\n                break;\\n        }\\n        e = XreadAllTypesPrimary(boole);\\n        if (boole && token.tokenType == Tokens.IS) {\\n            read();\\n            if (token.tokenType == Tokens.NOT) {\\n                read();\\n                not = !not;\\n            }\\n            if (token.tokenType == Tokens.TRUE) {\\n                read();\\n            } else if (token.tokenType == Tokens.FALSE) {\\n                read();\\n                not = !not;\\n            } else if (token.tokenType == Tokens.UNKNOWN) {\\n                read();\\n                unknown = true;\\n            } else {\\n                throw unexpectedToken();\\n            }\\n        }\\n        if (unknown) {\\n            e = new ExpressionLogical(OpTypes.IS_NULL, e);\\n        } else if (minus) {\\n            e = new ExpressionArithmetic(OpTypes.NEGATE, e);\\n        } else if (not) {\\n            e = new ExpressionLogical(OpTypes.NOT, e);\\n        }\\n        return e;\\n    }\\n    Expression XreadStringValueExpression() {\\n        return XreadCharacterValueExpression();\\n    }\\n    Expression XreadCharacterValueExpression() {\\n        Expression   e         = XreadCharacterPrimary();\\n        SchemaObject collation = readCollateClauseOrNull();\\n        while (token.tokenType == Tokens.CONCAT) {\\n            read();\\n            Expression a = e;\\n            e         = XreadCharacterPrimary();\\n            collation = readCollateClauseOrNull();\\n            e         = new ExpressionArithmetic(OpTypes.CONCAT, a, e);\\n        }\\n        return e;\\n    }\\n    Expression XreadCharacterPrimary() {\\n        switch (token.tokenType) {\\n            case Tokens.SUBSTRING :\\n            case Tokens.LOWER :\\n            case Tokens.UPPER :\\n            case Tokens.TRIM :\\n            case Tokens.OVERLAY :\\n                FunctionSQL function =\\n                    FunctionSQL.newSQLFunction(token.tokenString,\\n                                               compileContext);\\n                Expression e = readSQLFunction(function);\\n                if (e != null) {\\n                    return e;\\n                }\\n            default :\\n        }\\n        return XreadValueExpressionPrimary();\\n    }\\n    Expression XreadNumericPrimary() {\\n        switch (token.tokenType) {\\n            case Tokens.POSITION :\\n            case Tokens.EXTRACT :\\n            case Tokens.CHAR_LENGTH :\\n            case Tokens.CHARACTER_LENGTH :\\n            case Tokens.OCTET_LENGTH :\\n            case Tokens.CARDINALITY :\\n            case Tokens.ABS :\\n            case Tokens.MOD :\\n            case Tokens.LN :\\n            case Tokens.EXP :\\n            case Tokens.POWER :\\n            case Tokens.SQRT :\\n            case Tokens.FLOOR :\\n            case Tokens.CEILING :\\n            case Tokens.CEIL :\\n                FunctionSQL function =\\n                    FunctionSQL.newSQLFunction(token.tokenString,\\n                                               compileContext);\\n                if (function == null) {\\n                    throw super.unexpectedToken();\\n                }\\n                Expression e = readSQLFunction(function);\\n                if (e != null) {\\n                    return e;\\n                }\\n            default :\\n        }\\n        return XreadValueExpressionPrimary();\\n    }\\n    Expression XreadNumericValueExpression() {\\n        Expression e = XreadTerm();\\n        while (true) {\\n            int type;\\n            if (token.tokenType == Tokens.PLUS) {\\n                type = OpTypes.ADD;\\n            } else if (token.tokenType == Tokens.MINUS) {\\n                type = OpTypes.SUBTRACT;\\n            } else {\\n                break;\\n            }\\n            read();\\n            Expression a = e;\\n            e = XreadTerm();\\n            e = new ExpressionArithmetic(type, a, e);\\n        }\\n        return e;\\n    }\\n    Expression XreadTerm() {\\n        Expression e = XreadFactor();\\n        int        type;\\n        while (true) {\\n            if (token.tokenType == Tokens.ASTERISK) {\\n                type = OpTypes.MULTIPLY;\\n            } else if (token.tokenType == Tokens.DIVIDE) {\\n                type = OpTypes.DIVIDE;\\n            } else {\\n                break;\\n            }\\n            read();\\n            Expression a = e;\\n            e = XreadFactor();\\n            if (e == null) {\\n                throw unexpectedToken();\\n            }\\n            e = new ExpressionArithmetic(type, a, e);\\n        }\\n        return e;\\n    }\\n    Expression XreadFactor() {\\n        Expression e;\\n        boolean    minus = false;\\n        if (token.tokenType == Tokens.PLUS) {\\n            read();\\n        } else if (token.tokenType == Tokens.MINUS) {\\n            read();\\n            minus = true;\\n        }\\n        e = XreadNumericPrimary();\\n        if (e == null) {\\n            return null;\\n        }\\n        if (minus) {\\n            e = new ExpressionArithmetic(OpTypes.NEGATE, e);\\n        }\\n        return e;\\n    }\\n    Expression XreadDatetimeValueExpression() {\\n        Expression e = XreadDateTimeIntervalTerm();\\n        while (true) {\\n            int type;\\n            if (token.tokenType == Tokens.PLUS) {\\n                type = OpTypes.ADD;\\n            } else if (token.tokenType == Tokens.MINUS) {\\n                type = OpTypes.SUBTRACT;\\n            } else {\\n                break;\\n            }\\n            read();\\n            Expression a = e;\\n            e = XreadDateTimeIntervalTerm();\\n            e = new ExpressionArithmetic(type, a, e);\\n        }\\n        return e;\\n    }\\n    Expression XreadIntervalValueExpression() {\\n        Expression e = XreadDateTimeIntervalTerm();\\n        while (true) {\\n            int type;\\n            if (token.tokenType == Tokens.PLUS) {\\n                type = OpTypes.ADD;\\n            } else if (token.tokenType == Tokens.MINUS) {\\n                type = OpTypes.SUBTRACT;\\n            } else {\\n                break;\\n            }\\n            read();\\n            Expression a = e;\\n            e = XreadDateTimeIntervalTerm();\\n            e = new ExpressionArithmetic(type, a, e);\\n        }\\n        return e;\\n    }\\n    Expression XreadDateTimeIntervalTerm() {\\n        switch (token.tokenType) {\\n            case Tokens.CURRENT_DATE :\\n            case Tokens.CURRENT_TIME :\\n            case Tokens.CURRENT_TIMESTAMP :\\n            case Tokens.LOCALTIME :\\n            case Tokens.LOCALTIMESTAMP :\\n                        case Tokens.ABS :\\n                FunctionSQL function =\\n                    FunctionSQL.newSQLFunction(token.tokenString,\\n                                               compileContext);\\n                if (function == null) {\\n                    throw super.unexpectedToken();\\n                }\\n                return readSQLFunction(function);\\n            default :\\n        }\\n        return XreadValueExpressionPrimary();\\n    }\\n        Expression XreadDateTimeValueFunctionOrNull() {\\n        FunctionSQL function = null;\\n        switch (token.tokenType) {\\n            case Tokens.CURRENT_DATE :\\n            case Tokens.CURRENT_TIME :\\n            case Tokens.CURRENT_TIMESTAMP :\\n            case Tokens.LOCALTIME :\\n            case Tokens.LOCALTIMESTAMP :\\n                function = FunctionSQL.newSQLFunction(token.tokenString,\\n                                                      compileContext);\\n                break;\\n            case Tokens.NOW :\\n            case Tokens.TODAY :\\n            case Tokens.SYSDATE :\\n                function = FunctionCustom.newCustomFunction(token.tokenString,\\n                        token.tokenType);\\n                break;\\n            default :\\n                return null;\\n        }\\n        if (function == null) {\\n            throw super.unexpectedToken();\\n        }\\n        return readSQLFunction(function);\\n    }\\n    Expression XreadBooleanValueExpression() {\\n        try {\\n            Expression e = XreadBooleanTermOrNull();\\n            if (e == null) {\\n                throw Error.error(ErrorCode.X_42568);\\n            }\\n            while (true) {\\n                int type;\\n                if (token.tokenType == Tokens.OR) {\\n                    type = OpTypes.OR;\\n                } else {\\n                    break;\\n                }\\n                read();\\n                Expression a = e;\\n                e = XreadBooleanTermOrNull();\\n                if (e == null) {\\n                    throw Error.error(ErrorCode.X_42568);\\n                }\\n                e = new ExpressionLogical(type, a, e);\\n            }\\n            if (e == null) {\\n                throw Error.error(ErrorCode.X_42568);\\n            }\\n            return e;\\n        } catch (HsqlException ex) {\\n            ex.setLevel(compileContext.subqueryDepth);\\n            if (lastError != null && lastError.getLevel() >= ex.getLevel()) {\\n                ex        = lastError;\\n                lastError = null;\\n            }\\n            throw ex;\\n        }\\n    }\\n    Expression XreadBooleanTermOrNull() {\\n        Expression e = XreadBooleanFactorOrNull();\\n        if (e == null) {\\n            return null;\\n        }\\n        int type;\\n        while (true) {\\n            if (token.tokenType == Tokens.AND) {\\n                type = OpTypes.AND;\\n            } else {\\n                break;\\n            }\\n            read();\\n            Expression a = e;\\n            e = XreadBooleanFactorOrNull();\\n            if (e == null) {\\n                throw unexpectedToken();\\n            }\\n            e = new ExpressionLogical(type, a, e);\\n        }\\n        return e;\\n    }\\n    Expression XreadBooleanFactorOrNull() {\\n        Expression e;\\n        boolean    not     = false;\\n        boolean    unknown = false;\\n        if (token.tokenType == Tokens.NOT) {\\n            read();\\n            not = true;\\n        }\\n        e = XreadBooleanPrimaryOrNull();\\n        if (e == null) {\\n            return null;\\n        }\\n        if (token.tokenType == Tokens.IS) {\\n            read();\\n            if (token.tokenType == Tokens.NOT) {\\n                read();\\n                not = !not;\\n            }\\n            if (token.tokenType == Tokens.TRUE) {\\n                read();\\n            } else if (token.tokenType == Tokens.FALSE) {\\n                not = !not;\\n                read();\\n            } else if (token.tokenType == Tokens.UNKNOWN) {\\n                unknown = true;\\n                read();\\n            } else {\\n                throw unexpectedToken();\\n            }\\n        }\\n        if (unknown) {\\n            e = new ExpressionLogical(OpTypes.IS_NULL, e);\\n        }\\n        if (not) {\\n            e = new ExpressionLogical(OpTypes.NOT, e);\\n        }\\n        return e;\\n    }\\n        Expression XreadBooleanPrimaryOrNull() {\\n        Expression e = null;\\n        int        position;\\n        switch (token.tokenType) {\\n            case Tokens.EXISTS :\\n            case Tokens.UNIQUE :\\n                return XreadPredicate();\\n            case Tokens.ROW :\\n                read();\\n                readThis(Tokens.OPENBRACKET);\\n                e = XreadRowElementList(true);\\n                readThis(Tokens.CLOSEBRACKET);\\n                break;\\n            default :\\n                position = getPosition();\\n                try {\\n                    e = XreadAllTypesCommonValueExpression(false);\\n                } catch (HsqlException ex) {\\n                    ex.setLevel(compileContext.subqueryDepth);\\n                    if (lastError == null\\n                            || lastError.getLevel() < ex.getLevel()) {\\n                        lastError = ex;\\n                    }\\n                    rewind(position);\\n                }\\n        }\\n        if (e == null && token.tokenType == Tokens.OPENBRACKET) {\\n            read();\\n            position = getPosition();\\n            try {\\n                e = XreadRowElementList(true);\\n                readThis(Tokens.CLOSEBRACKET);\\n            } catch (HsqlException ex) {\\n                ex.setLevel(compileContext.subqueryDepth);\\n                if (lastError == null\\n                        || lastError.getLevel() < ex.getLevel()) {\\n                    lastError = ex;\\n                }\\n                rewind(position);\\n                e = XreadBooleanValueExpression();\\n                readThis(Tokens.CLOSEBRACKET);\\n            }\\n        }\\n        if (e != null) {\\n            e = XreadPredicateRightPart(e);\\n        }\\n        return e;\\n    }\\n        Expression XreadBooleanPredicand() {\\n        Expression e;\\n        if (token.tokenType == Tokens.OPENBRACKET) {\\n            read();\\n            e = XreadBooleanValueExpression();\\n            readThis(Tokens.CLOSEBRACKET);\\n            return e;\\n        } else {\\n            e = XreadSimpleValueExpressionPrimary();\\n            if (e != null) {\\n                e = XreadArrayElementReference(e);\\n            }\\n            return e;\\n        }\\n    }\\n    Expression XreadPredicate() {\\n        switch (token.tokenType) {\\n            case Tokens.EXISTS : {\\n                read();\\n                Expression s = XreadTableSubquery(OpTypes.EXISTS);\\n                return new ExpressionLogical(OpTypes.EXISTS, s);\\n            }\\n            case Tokens.UNIQUE : {\\n                read();\\n                Expression s = XreadTableSubquery(OpTypes.UNIQUE);\\n                return new ExpressionLogical(OpTypes.UNIQUE, s);\\n            }\\n            default : {\\n                Expression a = XreadRowValuePredicand();\\n                return XreadPredicateRightPart(a);\\n            }\\n        }\\n    }\\n    Expression XreadPredicateRightPart(final Expression l) {\\n        boolean           hasNot = false;\\n        ExpressionLogical e      = null;\\n        Expression        r;\\n        if (token.tokenType == Tokens.NOT) {\\n            read();\\n            hasNot = true;\\n        }\\n        switch (token.tokenType) {\\n            case Tokens.IS : {\\n                if (hasNot) {\\n                    throw unexpectedToken();\\n                }\\n                read();\\n                if (token.tokenType == Tokens.NOT) {\\n                    hasNot = true;\\n                    read();\\n                }\\n                if (token.tokenType == Tokens.DISTINCT) {\\n                    read();\\n                    readThis(Tokens.FROM);\\n                    r      = XreadRowValuePredicand();\\n                    e      = new ExpressionLogical(OpTypes.NOT_DISTINCT, l, r);\\n                    hasNot = !hasNot;\\n                    break;\\n                }\\n                if (token.tokenType == Tokens.NULL\\n                        || token.tokenType == Tokens.UNKNOWN) {\\n                    read();\\n                    e = new ExpressionLogical(OpTypes.IS_NULL, l);\\n                    break;\\n                }\\n                throw unexpectedToken();\\n            }\\n            case Tokens.LIKE : {\\n                e                = XreadLikePredicateRightPart(l);\\n                e.noOptimisation = isCheckOrTriggerCondition;\\n                break;\\n            }\\n            case Tokens.BETWEEN : {\\n                e = XreadBetweenPredicateRightPart(l);\\n                break;\\n            }\\n            case Tokens.IN : {\\n                e                = XreadInPredicateRightPart(l);\\n                e.noOptimisation = isCheckOrTriggerCondition;\\n                break;\\n            }\\n            case Tokens.OVERLAPS : {\\n                if (hasNot) {\\n                    throw unexpectedToken();\\n                }\\n                e = XreadOverlapsPredicateRightPart(l);\\n                break;\\n            }\\n            case Tokens.EQUALS :\\n            case Tokens.GREATER_EQUALS :\\n            case Tokens.GREATER :\\n            case Tokens.LESS :\\n            case Tokens.LESS_EQUALS :\\n            case Tokens.NOT_EQUALS : {\\n                if (hasNot) {\\n                    throw unexpectedToken();\\n                }\\n                int type = getExpressionType(token.tokenType);\\n                read();\\n                switch (token.tokenType) {\\n                    case Tokens.ANY :\\n                    case Tokens.SOME :\\n                    case Tokens.ALL :\\n                        e = XreadQuantifiedComparisonRightPart(type, l);\\n                        break;\\n                    default : {\\n                        Expression row = XreadRowValuePredicand();\\n                        e = new ExpressionLogical(type, l, row);\\n                        break;\\n                    }\\n                }\\n                break;\\n            }\\n            case Tokens.MATCH : {\\n                e = XreadMatchPredicateRightPart(l);\\n                break;\\n            }\\n            default : {\\n                if (hasNot) {\\n                    throw unexpectedToken();\\n                }\\n                return l;\\n            }\\n        }\\n        if (hasNot) {\\n            e = new ExpressionLogical(OpTypes.NOT, e);\\n        }\\n        return e;\\n    }\\n    private ExpressionLogical XreadBetweenPredicateRightPart(\\n            final Expression a) {\\n        boolean symmetric = false;\\n        read();\\n        if (token.tokenType == Tokens.ASYMMETRIC) {\\n            read();\\n        } else if (token.tokenType == Tokens.SYMMETRIC) {\\n            symmetric = true;\\n            read();\\n        }\\n        Expression left = XreadRowValuePredicand();\\n        readThis(Tokens.AND);\\n        Expression right = XreadRowValuePredicand();\\n        Expression l = new ExpressionLogical(OpTypes.GREATER_EQUAL, a, left);\\n        Expression r = new ExpressionLogical(OpTypes.SMALLER_EQUAL, a, right);\\n        ExpressionLogical leftToRight = new ExpressionLogical(OpTypes.AND, l,\\n            r);\\n        if (symmetric) {\\n            l = new ExpressionLogical(OpTypes.SMALLER_EQUAL, a, left);\\n            r = new ExpressionLogical(OpTypes.GREATER_EQUAL, a, right);\\n            Expression rightToLeft = new ExpressionLogical(OpTypes.AND, l, r);\\n            return new ExpressionLogical(OpTypes.OR, leftToRight, rightToLeft);\\n        } else {\\n            return leftToRight;\\n        }\\n    }\\n    private ExpressionLogical XreadQuantifiedComparisonRightPart(int exprType,\\n            Expression l) {\\n        int        tokenT      = token.tokenType;\\n        int        exprSubType = 0;\\n        Expression e;\\n        switch (token.tokenType) {\\n            case Tokens.ANY :\\n            case Tokens.SOME :\\n                exprSubType = OpTypes.ANY_QUANTIFIED;\\n                break;\\n            case Tokens.ALL :\\n                exprSubType = OpTypes.ALL_QUANTIFIED;\\n                break;\\n            default :\\n                throw Error.runtimeError(ErrorCode.U_S0500, \\\"ParserDQL\\\");\\n        }\\n        read();\\n        readThis(Tokens.OPENBRACKET);\\n        int position = getPosition();\\n        readOpenBrackets();\\n        switch (token.tokenType) {\\n            case Tokens.TABLE :\\n            case Tokens.VALUES :\\n            case Tokens.SELECT :\\n                rewind(position);\\n                SubQuery sq = XreadSubqueryBody(OpTypes.IN);\\n                e = new Expression(OpTypes.TABLE_SUBQUERY, sq);\\n                readThis(Tokens.CLOSEBRACKET);\\n                break;\\n            default :\\n                rewind(position);\\n                e = readAggregateExpression(tokenT);\\n                readThis(Tokens.CLOSEBRACKET);\\n                readFilterClause(e);\\n        }\\n        ExpressionLogical r = new ExpressionLogical(exprType, l, e);\\n        r.setSubType(exprSubType);\\n        return r;\\n    }\\n    private ExpressionLogical XreadInPredicateRightPart(Expression l) {\\n        int        degree = l.getDegree();\\n        Expression e      = null;\\n        read();\\n        readThis(Tokens.OPENBRACKET);\\n        int position = getPosition();\\n        int brackets = readOpenBrackets();\\n        switch (token.tokenType) {\\n            case Tokens.UNNEST :\\n                e = XreadCollectionDerivedTable();\\n                e.getTable().getSubQuery().setUniqueRows();\\n                readThis(Tokens.CLOSEBRACKET);\\n                this.readCloseBrackets(brackets);\\n                break;\\n            case Tokens.TABLE :\\n            case Tokens.VALUES :\\n            case Tokens.SELECT : {\\n                rewind(position);\\n                SubQuery sq = XreadSubqueryBody(OpTypes.IN);\\n                e = new Expression(OpTypes.TABLE_SUBQUERY, sq);\\n                readThis(Tokens.CLOSEBRACKET);\\n                break;\\n            }\\n            default : {\\n                rewind(position);\\n                e = XreadInValueListConstructor(degree);\\n                readThis(Tokens.CLOSEBRACKET);\\n                break;\\n            }\\n        }\\n        ExpressionLogical r;\\n        if (isCheckOrTriggerCondition) {\\n            r = new ExpressionLogical(OpTypes.IN, l, e);\\n        } else {\\n            r = new ExpressionLogical(OpTypes.EQUAL, l, e);\\n            r.setSubType(OpTypes.ANY_QUANTIFIED);\\n        }\\n        return r;\\n    }\\n    Expression XreadInValueList(int degree) {\\n        HsqlArrayList list = new HsqlArrayList();\\n        while (true) {\\n            Expression e = XreadValueExpression();\\n            if (e.getType() != OpTypes.ROW) {\\n                e = new Expression(OpTypes.ROW, new Expression[]{ e });\\n            }\\n            list.add(e);\\n            if (token.tokenType == Tokens.COMMA) {\\n                read();\\n                continue;\\n            }\\n            break;\\n        }\\n        Expression[] array = new Expression[list.size()];\\n        list.toArray(array);\\n        Expression e = new Expression(OpTypes.VALUELIST, array);\\n        for (int i = 0; i < array.length; i++) {\\n            if (array[i].getType() != OpTypes.ROW) {\\n                array[i] = new Expression(OpTypes.ROW,\\n                                          new Expression[]{ array[i] });\\n            }\\n            Expression[] args = array[i].nodes;\\n            if (args.length != degree) {\\n                                throw unexpectedToken();\\n            }\\n            for (int j = 0; j < degree; j++) {\\n                if (args[j].getType() == OpTypes.ROW) {\\n                                        throw unexpectedToken();\\n                }\\n            }\\n        }\\n        return e;\\n    }\\n    private ExpressionLogical XreadLikePredicateRightPart(Expression a) {\\n        read();\\n        Expression b      = XreadStringValueExpression();\\n        Expression escape = null;\\n        if (token.tokenString.equals(Tokens.T_ESCAPE)) {\\n            read();\\n            escape = XreadStringValueExpression();\\n        }\\n        return new ExpressionLike(a, b, escape,\\n                                  this.isCheckOrTriggerCondition);\\n    }\\n    private ExpressionLogical XreadMatchPredicateRightPart(Expression a) {\\n        boolean isUnique  = false;\\n        int     matchType = OpTypes.MATCH_SIMPLE;\\n        read();\\n        if (token.tokenType == Tokens.UNIQUE) {\\n            read();\\n            isUnique = true;\\n        }\\n        if (token.tokenType == Tokens.SIMPLE) {\\n            read();\\n            matchType = isUnique ? OpTypes.MATCH_UNIQUE_SIMPLE\\n                                 : OpTypes.MATCH_SIMPLE;\\n        } else if (token.tokenType == Tokens.PARTIAL) {\\n            read();\\n            matchType = isUnique ? OpTypes.MATCH_UNIQUE_PARTIAL\\n                                 : OpTypes.MATCH_PARTIAL;\\n        } else if (token.tokenType == Tokens.FULL) {\\n            read();\\n            matchType = isUnique ? OpTypes.MATCH_UNIQUE_FULL\\n                                 : OpTypes.MATCH_FULL;\\n        }\\n        int        mode = isUnique ? OpTypes.TABLE_SUBQUERY\\n                                   : OpTypes.IN;\\n        Expression s    = XreadTableSubquery(mode);\\n        return new ExpressionLogical(matchType, a, s);\\n    }\\n    private ExpressionLogical XreadOverlapsPredicateRightPart(Expression l) {\\n        if (l.getType() != OpTypes.ROW) {\\n            throw Error.error(ErrorCode.X_42564);\\n        }\\n        if (l.nodes.length != 2) {\\n            throw Error.error(ErrorCode.X_42564);\\n        }\\n        read();\\n        if (token.tokenType != Tokens.OPENBRACKET) {\\n            throw unexpectedToken();\\n        }\\n        Expression r = XreadRowValuePredicand();\\n        if (r.nodes.length != 2) {\\n            throw Error.error(ErrorCode.X_42564);\\n        }\\n        return new ExpressionLogical(OpTypes.OVERLAPS, l, r);\\n    }\\n    Expression XreadRowValueExpression() {\\n        Expression e = XreadExplicitRowValueConstructorOrNull();\\n        if (e != null) {\\n            return e;\\n        }\\n        return XreadRowValueSpecialCase();\\n    }\\n    Expression XreadTableRowValueConstructor() {\\n        Expression e = XreadExplicitRowValueConstructorOrNull();\\n        if (e != null) {\\n            return e;\\n        }\\n        return XreadRowValueSpecialCase();\\n    }\\n                    Expression XreadRowValuePredicand() {\\n        return XreadRowOrCommonValueExpression();\\n    }\\n    Expression XreadRowValueSpecialCase() {\\n        Expression e = XreadSimpleValueExpressionPrimary();\\n        if (e != null) {\\n            e = XreadArrayElementReference(e);\\n        }\\n        return e;\\n    }\\n            Expression XreadRowValueConstructor() {\\n        Expression e;\\n        e = XreadExplicitRowValueConstructorOrNull();\\n        if (e != null) {\\n            return e;\\n        }\\n        e = XreadRowOrCommonValueExpression();\\n        if (e != null) {\\n            return e;\\n        }\\n        return XreadBooleanValueExpression();\\n    }\\n            Expression XreadExplicitRowValueConstructorOrNull() {\\n        Expression e;\\n        switch (token.tokenType) {\\n            case Tokens.OPENBRACKET : {\\n                read();\\n                int position = getPosition();\\n                int brackets = readOpenBrackets();\\n                switch (token.tokenType) {\\n                    case Tokens.TABLE :\\n                    case Tokens.VALUES :\\n                    case Tokens.SELECT :\\n                        rewind(position);\\n                        SubQuery sq = XreadSubqueryBody(OpTypes.ROW_SUBQUERY);\\n                        readThis(Tokens.CLOSEBRACKET);\\n                        return new Expression(OpTypes.ROW_SUBQUERY, sq);\\n                    default :\\n                        rewind(position);\\n                        e = XreadRowElementList(true);\\n                        readThis(Tokens.CLOSEBRACKET);\\n                        return e;\\n                }\\n            }\\n            case Tokens.ROW : {\\n                read();\\n                readThis(Tokens.OPENBRACKET);\\n                e = XreadRowElementList(false);\\n                readThis(Tokens.CLOSEBRACKET);\\n                return e;\\n            }\\n        }\\n        return null;\\n    }\\n    Expression XreadRowElementList(boolean multiple) {\\n        Expression    e;\\n        HsqlArrayList list = new HsqlArrayList();\\n        while (true) {\\n            e = XreadValueExpression();\\n            list.add(e);\\n            if (token.tokenType == Tokens.COMMA) {\\n                read();\\n                continue;\\n            }\\n            if (multiple && list.size() == 1) {\\n                return e;\\n            }\\n            break;\\n        }\\n        Expression[] array = new Expression[list.size()];\\n        list.toArray(array);\\n        return new Expression(OpTypes.ROW, array);\\n    }\\n    Expression XreadCurrentCollationSpec() {\\n        throw Error.error(ErrorCode.X_0A000);\\n    }\\n    Expression XreadTableSubquery(int mode) {\\n        readThis(Tokens.OPENBRACKET);\\n        SubQuery sq = XreadSubqueryBody(mode);\\n        readThis(Tokens.CLOSEBRACKET);\\n        return new Expression(OpTypes.TABLE_SUBQUERY, sq);\\n    }\\n    Table XreadTableSubqueryOrNull(RangeVariable[] outerRanges) {\\n        boolean joinedTable = false;\\n        int     position;\\n        position = getPosition();\\n        readThis(Tokens.OPENBRACKET);\\n        readOpenBrackets();\\n        switch (token.tokenType) {\\n            case Tokens.TABLE :\\n            case Tokens.VALUES :\\n            case Tokens.SELECT :\\n            case Tokens.WITH :\\n                break;\\n            default :\\n                joinedTable = true;\\n        }\\n        rewind(position);\\n        if (joinedTable) {\\n            return null;\\n        } else {\\n            boolean hasOuter = outerRanges != null;\\n            readThis(Tokens.OPENBRACKET);\\n            SubQuery sq = XreadSubqueryBody(OpTypes.TABLE_SUBQUERY);\\n            HsqlList unresolved =\\n                sq.queryExpression.getUnresolvedExpressions();\\n            if (hasOuter && unresolved != null) {\\n                unresolved = Expression.resolveColumnSet(session, outerRanges,\\n                        outerRanges.length,\\n                        sq.queryExpression.getUnresolvedExpressions(), null);\\n            }\\n            ExpressionColumn.checkColumnsResolved(unresolved);\\n            sq.queryExpression.resolveTypes(session);\\n            sq.prepareTable(session);\\n            readThis(Tokens.CLOSEBRACKET);\\n            return sq.getTable();\\n        }\\n    }\\n    SubQuery XreadJoinedTableAsSubquery() {\\n        readThis(Tokens.OPENBRACKET);\\n        int position = getPosition();\\n        compileContext.subqueryDepth++;\\n        QuerySpecification querySpecification = XreadJoinedTableAsView();\\n        querySpecification.resolve(session);\\n        if (querySpecification.rangeVariables.length < 2) {\\n            throw unexpectedTokenRequire(Tokens.T_JOIN);\\n        }\\n        SubQuery sq = new SubQuery(database, compileContext.subqueryDepth,\\n                                   querySpecification, OpTypes.TABLE_SUBQUERY);\\n        sq.sql = getLastPart(position);\\n        readThis(Tokens.CLOSEBRACKET);\\n        sq.prepareTable(session);\\n        compileContext.subqueryDepth--;\\n        return sq;\\n    }\\n    QuerySpecification XreadJoinedTableAsView() {\\n        QuerySpecification select = new QuerySpecification(compileContext);\\n        Expression         e      = new ExpressionColumn(OpTypes.MULTICOLUMN);\\n        select.addSelectColumnExpression(e);\\n        XreadTableReference(select);\\n        return select;\\n    }\\n    SubQuery XreadTableNamedSubqueryBody(HsqlName name,\\n                                         HsqlName[] columnNames, int type) {\\n        switch (type) {\\n            case OpTypes.RECURSIVE_SUBQUERY : {\\n                SubQuery sq = XreadRecursiveSubqueryBody(name, columnNames);\\n                return sq;\\n            }\\n            case OpTypes.TABLE_SUBQUERY : {\\n                SubQuery sq = XreadSubqueryBody(type);\\n                ExpressionColumn.checkColumnsResolved(\\n                    sq.queryExpression.unresolvedExpressions);\\n                sq.queryExpression.resolveTypes(session);\\n                sq.prepareTable(session, name, columnNames);\\n                return sq;\\n            }\\n            default :\\n                throw super.unexpectedToken();\\n        }\\n    }\\n    SubQuery XreadRecursiveSubqueryBody(HsqlName name,\\n                                        HsqlName[] columnNames) {\\n        int position = getPosition();\\n        compileContext.subqueryDepth++;\\n        compileContext.subqueryDepth++;\\n        QueryExpression queryExpression = XreadSimpleTable();\\n        queryExpression.resolve(session);\\n        SubQuery sq = new SubQuery(database, compileContext.subqueryDepth,\\n                                   queryExpression, OpTypes.TABLE_SUBQUERY);\\n        compileContext.subqueryDepth--;\\n        sq.prepareTable(session, name, columnNames);\\n        compileContext.initSubqueryNames();\\n        compileContext.registerSubquery(name.name, sq);\\n        RangeVariable range = new RangeVariable(sq.getTable(),\\n            compileContext.getNextRangeVarIndex());\\n        RangeVariable[] ranges = new RangeVariable[]{ range };\\n        if (token.tokenType == Tokens.UNION) {\\n            int             unionType            = XreadUnionType();\\n            QueryExpression rightQueryExpression = XreadSimpleTable();\\n            queryExpression = new QueryExpression(compileContext,\\n                                                  queryExpression);\\n            rightQueryExpression.resolveReferences(session, ranges);\\n            queryExpression.addUnion(rightQueryExpression, unionType);\\n            queryExpression.resolve(session);\\n            queryExpression.createTable(session);\\n            sq = new SubQuery(database, compileContext.subqueryDepth,\\n                              queryExpression, sq);\\n            sq.prepareTable(session, name, columnNames);\\n        } else {\\n            throw unexpectedTokenRequire(Tokens.T_UNION);\\n        }\\n        sq.sql = getLastPart(position);\\n        compileContext.subqueryDepth--;\\n        return sq;\\n    }\\n    SubQuery XreadSubqueryBody(int type) {\\n        int position = getPosition();\\n        compileContext.subqueryDepth++;\\n        QueryExpression queryExpression = XreadQueryExpression();\\n        queryExpression.resolveReferences(session, RangeVariable.emptyArray);\\n        SubQuery sq = new SubQuery(database, compileContext.subqueryDepth,\\n                                   queryExpression, type);\\n        sq.sql = getLastPart(position);\\n        compileContext.subqueryDepth--;\\n        return sq;\\n    }\\n    SubQuery XreadViewSubquery(View view) {\\n        compileContext.subqueryDepth++;\\n        QueryExpression queryExpression;\\n        try {\\n            queryExpression = XreadQueryExpression();\\n        } catch (HsqlException e) {\\n            queryExpression = XreadJoinedTableAsView();\\n        }\\n        queryExpression.setView(view);\\n        queryExpression.resolve(session);\\n        SubQuery sq = new SubQuery(database, compileContext.subqueryDepth,\\n                                   queryExpression, view);\\n        compileContext.subqueryDepth--;\\n        return sq;\\n    }\\n    Expression XreadContextuallyTypedTable(int degree) {\\n        Expression   e       = readRow();\\n        Expression[] list    = e.nodes;\\n        boolean      isTable = false;\\n        if (degree == 1) {\\n            if (e.getType() == OpTypes.ROW) {\\n                e.opType = OpTypes.VALUELIST;\\n                for (int i = 0; i < list.length; i++) {\\n                    if (list[i].getType() != OpTypes.ROW) {\\n                        list[i] = new Expression(OpTypes.ROW,\\n                                                 new Expression[]{ list[i] });\\n                    } else if (list[i].nodes.length != degree) {\\n                        throw Error.error(ErrorCode.X_42564);\\n                    }\\n                }\\n                return e;\\n            } else {\\n                e = new Expression(OpTypes.ROW, new Expression[]{ e });\\n                e = new Expression(OpTypes.VALUELIST, new Expression[]{ e });\\n                return e;\\n            }\\n        }\\n        if (e.getType() != OpTypes.ROW) {\\n            throw Error.error(ErrorCode.X_42564);\\n        }\\n        for (int i = 0; i < list.length; i++) {\\n            if (list[i].getType() == OpTypes.ROW) {\\n                isTable = true;\\n                break;\\n            }\\n        }\\n        if (isTable) {\\n            e.opType = OpTypes.VALUELIST;\\n            for (int i = 0; i < list.length; i++) {\\n                if (list[i].getType() != OpTypes.ROW) {\\n                    throw Error.error(ErrorCode.X_42564);\\n                }\\n                Expression[] args = list[i].nodes;\\n                if (args.length != degree) {\\n                    throw Error.error(ErrorCode.X_42564);\\n                }\\n                for (int j = 0; j < degree; j++) {\\n                    if (args[j].getType() == OpTypes.ROW) {\\n                        throw Error.error(ErrorCode.X_42564);\\n                    }\\n                }\\n            }\\n        } else {\\n            if (list.length != degree) {\\n                throw Error.error(ErrorCode.X_42564);\\n            }\\n            e = new Expression(OpTypes.VALUELIST, new Expression[]{ e });\\n        }\\n        return e;\\n    }\\n    private Expression XreadInValueListConstructor(int degree) {\\n        int position = getPosition();\\n        compileContext.subqueryDepth++;\\n        Expression e = XreadInValueList(degree);\\n        SubQuery sq = new SubQuery(database, compileContext.subqueryDepth, e,\\n                                   OpTypes.IN);\\n        sq.sql = getLastPart(position);\\n        compileContext.subqueryDepth--;\\n        return e;\\n    }\\n    private SubQuery XreadRowValueExpressionList() {\\n        compileContext.subqueryDepth++;\\n        Expression e  = XreadRowValueExpressionListBody();\\n        SubQuery   sq = prepareSubquery(e);\\n        compileContext.subqueryDepth--;\\n        return sq;\\n    }\\n    private SubQuery prepareSubquery(Expression e) {\\n        HsqlList unresolved = e.resolveColumnReferences(session,\\n            RangeVariable.emptyArray, null);\\n        ExpressionColumn.checkColumnsResolved(unresolved);\\n        e.resolveTypes(session, null);\\n        e.prepareTable(session, null, e.nodes[0].nodes.length);\\n        SubQuery sq = new SubQuery(database, compileContext.subqueryDepth, e,\\n                                   OpTypes.VALUELIST);\\n        sq.prepareTable(session);\\n        return sq;\\n    }\\n    Expression XreadRowValueExpressionListBody() {\\n        Expression r = null;\\n        while (true) {\\n            int        brackets = readOpenBrackets();\\n            Expression e        = readRow();\\n            readCloseBrackets(brackets);\\n            if (r == null) {\\n                r = new Expression(OpTypes.ROW, new Expression[]{ e });\\n            } else {\\n                r.nodes = (Expression[]) ArrayUtil.resizeArray(r.nodes,\\n                        r.nodes.length + 1);\\n                r.nodes[r.nodes.length - 1] = e;\\n            }\\n            if (token.tokenType != Tokens.COMMA) {\\n                break;\\n            }\\n            read();\\n        }\\n        Expression[] list   = r.nodes;\\n        int          degree = 1;\\n        if (list[0].getType() == OpTypes.ROW) {\\n            degree = list[0].nodes.length;\\n        }\\n        r.opType = OpTypes.VALUELIST;\\n        for (int i = 0; i < list.length; i++) {\\n            if (list[i].getType() == OpTypes.ROW) {\\n                if (list[i].nodes.length != degree) {\\n                    throw Error.error(ErrorCode.X_42564);\\n                }\\n            } else {\\n                if (degree != 1) {\\n                    throw Error.error(ErrorCode.X_42564);\\n                }\\n                list[i] = new Expression(OpTypes.ROW,\\n                                         new Expression[]{ list[i] });\\n            }\\n        }\\n        return r;\\n    }\\n    Expression XreadTargetSpecification(RangeVariable[] rangeVars,\\n                                        LongDeque colIndexList) {\\n        ColumnSchema column = null;\\n        int          index  = -1;\\n        checkIsIdentifier();\\n        if (token.namePrePrePrefix != null) {\\n            checkValidCatalogName(token.namePrePrePrefix);\\n        }\\n        for (int i = 0; i < rangeVars.length; i++) {\\n            if (rangeVars[i] == null) {\\n                continue;\\n            }\\n            index = rangeVars[i].findColumn(token.tokenString);\\n            if (index > -1 && rangeVars[i].resolvesTableName(token.namePrefix)\\n                    && rangeVars[i].resolvesSchemaName(token.namePrePrefix)) {\\n                column = rangeVars[i].getColumn(index);\\n                read();\\n                break;\\n            }\\n        }\\n        if (column == null) {\\n            throw Error.error(ErrorCode.X_42501, token.tokenString);\\n        }\\n        colIndexList.add(index);\\n        if (token.tokenType == Tokens.LEFTBRACKET) {\\n            if (!column.getDataType().isArrayType()) {\\n                throw unexpectedToken();\\n            }\\n            read();\\n            Expression e = XreadNumericValueExpression();\\n            if (e == null) {\\n                throw Error.error(ErrorCode.X_42501, token.tokenString);\\n            }\\n            e = new ExpressionAccessor(column.getAccessor(), e);\\n            readThis(Tokens.RIGHTBRACKET);\\n            return e;\\n        }\\n        return column.getAccessor();\\n    }\\n    Expression XreadCollectionDerivedTable() {\\n        boolean ordinality = false;\\n        int     position   = getPosition();\\n        readThis(Tokens.UNNEST);\\n        readThis(Tokens.OPENBRACKET);\\n        compileContext.subqueryDepth++;\\n        Expression e = XreadValueExpression();\\n        compileContext.subqueryDepth--;\\n        readThis(Tokens.CLOSEBRACKET);\\n        if (token.tokenType == Tokens.WITH) {\\n            read();\\n            readThis(Tokens.ORDINALITY);\\n            ordinality = true;\\n        }\\n        e = new ExpressionTable(e, null, ordinality);\\n        SubQuery sq = new SubQuery(database, compileContext.subqueryDepth, e,\\n                                   OpTypes.TABLE_SUBQUERY);\\n        sq.createTable();\\n        sq.sql = getLastPart(position);\\n        return e;\\n    }\\n    Expression XreadTableFunctionDerivedTable() {\\n        int position = getPosition();\\n        readThis(Tokens.TABLE);\\n        readThis(Tokens.OPENBRACKET);\\n        compileContext.subqueryDepth++;\\n        Expression e = this.XreadValueExpression();\\n        if (e.getType() != OpTypes.FUNCTION\\n                && e.getType() != OpTypes.SQL_FUNCTION) {\\n            compileContext.subqueryDepth--;\\n            throw this.unexpectedToken(Tokens.T_TABLE);\\n        }\\n        readThis(Tokens.CLOSEBRACKET);\\n        e = new ExpressionTable(e, null, false);\\n        SubQuery sq = new SubQuery(database, compileContext.subqueryDepth, e,\\n                                   OpTypes.TABLE_SUBQUERY);\\n        sq.createTable();\\n        sq.sql = getLastPart(position);\\n        compileContext.subqueryDepth--;\\n        return e;\\n    }\\n    Expression XreadLateralDerivedTable() {\\n        readThis(Tokens.LATERAL);\\n        readThis(Tokens.OPENBRACKET);\\n        int position = getPosition();\\n        compileContext.subqueryDepth++;\\n        QueryExpression queryExpression = XreadQueryExpression();\\n        SubQuery sq = new SubQuery(database, compileContext.subqueryDepth,\\n                                   queryExpression, OpTypes.TABLE_SUBQUERY);\\n        sq.createTable();\\n        sq.sql = getLastPart(position);\\n        compileContext.subqueryDepth--;\\n        readThis(Tokens.CLOSEBRACKET);\\n        return new Expression(OpTypes.TABLE_SUBQUERY, sq);\\n    }\\n    Expression XreadArrayConstructor() {\\n        readThis(Tokens.OPENBRACKET);\\n        int position = getPosition();\\n        compileContext.subqueryDepth++;\\n        QueryExpression queryExpression = XreadQueryExpression();\\n        queryExpression.resolveReferences(session, RangeVariable.emptyArray);\\n        SubQuery sq = new SubQuery(database, compileContext.subqueryDepth,\\n                                   queryExpression, OpTypes.TABLE_SUBQUERY);\\n        sq.sql = getLastPart(position);\\n        compileContext.subqueryDepth--;\\n        readThis(Tokens.CLOSEBRACKET);\\n        return new Expression(OpTypes.ARRAY_SUBQUERY, sq);\\n    }\\n        SchemaObject readCollateClauseOrNull() {\\n        if (token.tokenType == Tokens.COLLATE) {\\n            read();\\n            SchemaObject collation =\\n                database.schemaManager.getSchemaObject(token.namePrefix,\\n                    token.tokenString, SchemaObject.COLLATION);\\n            return collation;\\n        }\\n        return null;\\n    }\\n    Expression XreadArrayElementReference(Expression e) {\\n        if (token.tokenType == Tokens.LEFTBRACKET) {\\n            read();\\n            Expression e1 = XreadNumericValueExpression();\\n            readThis(Tokens.RIGHTBRACKET);\\n            e = new ExpressionAccessor(e, e1);\\n        }\\n        return e;\\n    }\\n    Expression readRow() {\\n        Expression r = null;\\n        while (true) {\\n            Expression e = XreadValueExpressionWithContext();\\n            if (r == null) {\\n                r = e;\\n            } else if (r.getType() == OpTypes.ROW) {\\n                if (e.getType() == OpTypes.ROW\\n                        && r.nodes[0].getType() != OpTypes.ROW) {\\n                    r = new Expression(OpTypes.ROW, new Expression[] {\\n                        r, e\\n                    });\\n                } else {\\n                    r.nodes = (Expression[]) ArrayUtil.resizeArray(r.nodes,\\n                            r.nodes.length + 1);\\n                    r.nodes[r.nodes.length - 1] = e;\\n                }\\n            } else {\\n                r = new Expression(OpTypes.ROW, new Expression[] {\\n                    r, e\\n                });\\n            }\\n            if (token.tokenType != Tokens.COMMA) {\\n                break;\\n            }\\n            read();\\n        }\\n        return r;\\n    }\\n    Expression readCaseExpression() {\\n        Expression predicand = null;\\n        read();\\n        if (token.tokenType != Tokens.WHEN) {\\n            predicand = XreadRowValuePredicand();\\n        }\\n        return readCaseWhen(predicand);\\n    }\\n    private Expression readCaseWhen(final Expression l) {\\n        readThis(Tokens.WHEN);\\n        Expression condition = null;\\n        if (l == null) {\\n            condition = XreadBooleanValueExpression();\\n        } else {\\n            while (true) {\\n                Expression newCondition = XreadPredicateRightPart(l);\\n                if (l == newCondition) {\\n                    newCondition =\\n                        new ExpressionLogical(l, XreadRowValuePredicand());\\n                }\\n                if (condition == null) {\\n                    condition = newCondition;\\n                } else {\\n                    condition = new ExpressionLogical(OpTypes.OR, condition,\\n                                                      newCondition);\\n                }\\n                if (token.tokenType == Tokens.COMMA) {\\n                    read();\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n        readThis(Tokens.THEN);\\n        Expression current  = XreadValueExpression();\\n        Expression elseExpr = null;\\n        if (token.tokenType == Tokens.WHEN) {\\n            elseExpr = readCaseWhen(l);\\n        } else if (token.tokenType == Tokens.ELSE) {\\n            read();\\n            elseExpr = XreadValueExpression();\\n            readThis(Tokens.END);\\n            readIfThis(Tokens.CASE);\\n        } else {\\n            elseExpr = new ExpressionValue((Object) null, Type.SQL_ALL_TYPES);\\n            readThis(Tokens.END);\\n            readIfThis(Tokens.CASE);\\n        }\\n        Expression alternatives = new ExpressionOp(OpTypes.ALTERNATIVE,\\n            current, elseExpr);\\n        Expression casewhen = new ExpressionOp(OpTypes.CASEWHEN, condition,\\n                                               alternatives);\\n        return casewhen;\\n    }\\n    private Expression readCaseWhenExpression() {\\n        Expression l = null;\\n        read();\\n        readThis(Tokens.OPENBRACKET);\\n        l = XreadBooleanValueExpression();\\n        readThis(Tokens.COMMA);\\n        Expression thenelse = XreadValueExpression();\\n        readThis(Tokens.COMMA);\\n        thenelse = new ExpressionOp(OpTypes.ALTERNATIVE, thenelse,\\n                                    XreadValueExpression());\\n        l = new ExpressionOp(OpTypes.CASEWHEN, l, thenelse);\\n        readThis(Tokens.CLOSEBRACKET);\\n        return l;\\n    }\\n    private Expression readCastExpression() {\\n        boolean    isConvert = token.tokenType == Tokens.CONVERT;\\n        Expression e;\\n        Type       typeObject;\\n        read();\\n        readThis(Tokens.OPENBRACKET);\\n        if (isConvert) {\\n            if (database.sqlSyntaxMss) {\\n                typeObject = readTypeDefinition(false, true);\\n                readThis(Tokens.COMMA);\\n                e = this.XreadValueExpressionOrNull();\\n            } else {\\n                e = this.XreadValueExpressionOrNull();\\n                readThis(Tokens.COMMA);\\n                typeObject = Type.getTypeForJDBCConvertToken(token.tokenType);\\n                if (typeObject == null) {\\n                    typeObject = readTypeDefinition(false, true);\\n                } else {\\n                    read();\\n                }\\n            }\\n        } else {\\n            e = this.XreadValueExpressionOrNull();\\n            readThis(Tokens.AS);\\n            typeObject = readTypeDefinition(false, true);\\n        }\\n        if (e.isUnresolvedParam()) {\\n            e.setDataType(session, typeObject);\\n        } else {\\n            e = new ExpressionOp(e, typeObject);\\n        }\\n        readThis(Tokens.CLOSEBRACKET);\\n        return e;\\n    }\\n    private Expression readColumnOrFunctionExpression() {\\n        String  name           = token.tokenString;\\n        boolean isSimpleQuoted = isDelimitedSimpleName();\\n        String  prefix         = token.namePrefix;\\n        String  prePrefix      = token.namePrePrefix;\\n        String  prePrePrefix   = token.namePrePrePrefix;\\n        Token   recordedToken  = getRecordedToken();\\n        checkIsIdentifier();\\n        if (isUndelimitedSimpleName()) {\\n            FunctionSQL function =\\n                FunctionCustom.newCustomFunction(token.tokenString,\\n                                                 token.tokenType);\\n            if (function != null) {\\n                int pos = getPosition();\\n                try {\\n                    Expression e = readSQLFunction(function);\\n                    if (e != null) {\\n                        return e;\\n                    }\\n                } catch (HsqlException ex) {\\n                    ex.setLevel(compileContext.subqueryDepth);\\n                    if (lastError == null\\n                            || lastError.getLevel() < ex.getLevel()) {\\n                        lastError = ex;\\n                    }\\n                    rewind(pos);\\n                }\\n            } else if (isReservedKey()) {\\n                function = FunctionSQL.newSQLFunction(name, compileContext);\\n                if (function != null) {\\n                    Expression e = readSQLFunction(function);\\n                    if (e != null) {\\n                        return e;\\n                    }\\n                }\\n            }\\n        }\\n        read();\\n        if (token.tokenType != Tokens.OPENBRACKET) {\\n            checkValidCatalogName(prePrePrefix);\\n            Expression column = new ExpressionColumn(prePrefix, prefix, name);\\n            return column;\\n        }\\n        if (prePrePrefix != null) {\\n            throw Error.error(ErrorCode.X_42551, prePrePrefix);\\n        }\\n        checkValidCatalogName(prePrefix);\\n        prefix = session.getSchemaName(prefix);\\n        RoutineSchema routineSchema =\\n            (RoutineSchema) database.schemaManager.findSchemaObject(name,\\n                prefix, SchemaObject.FUNCTION);\\n        if (routineSchema == null && isSimpleQuoted) {\\n            HsqlName schema =\\n                database.schemaManager.getDefaultSchemaHsqlName();\\n            routineSchema =\\n                (RoutineSchema) database.schemaManager.findSchemaObject(name,\\n                    schema.name, SchemaObject.FUNCTION);\\n            if (routineSchema == null) {\\n                Routine.createRoutines(session, schema, name);\\n                routineSchema =\\n                    (RoutineSchema) database.schemaManager.findSchemaObject(\\n                        name, schema.name, SchemaObject.FUNCTION);\\n            }\\n        }\\n        if (routineSchema == null) {\\n            throw Error.error(ErrorCode.X_42501, name);\\n        }\\n        HsqlArrayList list = new HsqlArrayList();\\n        readThis(Tokens.OPENBRACKET);\\n        if (token.tokenType == Tokens.CLOSEBRACKET) {\\n            read();\\n        } else {\\n            while (true) {\\n                Expression e = XreadValueExpression();\\n                list.add(e);\\n                if (token.tokenType == Tokens.COMMA) {\\n                    read();\\n                } else {\\n                    readThis(Tokens.CLOSEBRACKET);\\n                    break;\\n                }\\n            }\\n        }\\n        FunctionSQLInvoked function  = new FunctionSQLInvoked(routineSchema);\\n        Expression[]       arguments = new Expression[list.size()];\\n        list.toArray(arguments);\\n        function.setArguments(arguments);\\n        compileContext.addFunctionCall(function);\\n        recordedToken.setExpression(routineSchema);\\n        return function;\\n    }\\n    Expression readCollection(int type) {\\n        read();\\n        if (token.tokenType == Tokens.OPENBRACKET) {\\n            return XreadArrayConstructor();\\n        } else {\\n            readThis(Tokens.LEFTBRACKET);\\n            HsqlArrayList list = new HsqlArrayList();\\n            for (int i = 0; ; i++) {\\n                if (token.tokenType == Tokens.RIGHTBRACKET) {\\n                    read();\\n                    break;\\n                }\\n                if (i > 0) {\\n                    readThis(Tokens.COMMA);\\n                }\\n                Expression e = XreadValueExpressionOrNull();\\n                list.add(e);\\n            }\\n            Expression[] array = new Expression[list.size()];\\n            list.toArray(array);\\n            return new Expression(OpTypes.ARRAY, array);\\n        }\\n    }\\n    private Expression readDecodeExpression() {\\n                read();\\n        readThis(Tokens.OPENBRACKET);\\n        Expression casewhen    = null;\\n        Expression alternative = null;\\n        Expression main        = XreadValueExpression();\\n        readThis(Tokens.COMMA);\\n        do {\\n            Expression v = XreadValueExpression();\\n            if (token.tokenType == Tokens.COMMA) {\\n                readThis(Tokens.COMMA);\\n            } else {\\n                if (alternative == null) {\\n                    throw unexpectedToken();\\n                }\\n                alternative.setRightNode(v);\\n                break;\\n            }\\n            Expression l = new ExpressionLogical(main, v);\\n            Expression r = XreadValueExpression();\\n            Expression a = new ExpressionOp(OpTypes.ALTERNATIVE, r, null);\\n            Expression c = new ExpressionOp(OpTypes.CASEWHEN, l, a);\\n            if (casewhen == null) {\\n                casewhen = c;\\n            } else {\\n                alternative.setRightNode(c);\\n            }\\n            alternative = a;\\n            if (token.tokenType == Tokens.COMMA) {\\n                readThis(Tokens.COMMA);\\n            } else {\\n                alternative.setRightNode(new ExpressionValue(null, null));;\\n                break;\\n            }\\n        } while (true);\\n        readThis(Tokens.CLOSEBRACKET);\\n        return casewhen;\\n    }\\n    private Expression readConcatExpression() {\\n        Expression root;\\n        Expression r;\\n                read();\\n        readThis(Tokens.OPENBRACKET);\\n        root = XreadValueExpression();\\n        readThis(Tokens.COMMA);\\n        do {\\n            r    = XreadValueExpression();\\n            root = new ExpressionArithmetic(OpTypes.CONCAT, root, r);\\n            if (token.tokenType == Tokens.COMMA) {\\n                readThis(Tokens.COMMA);\\n            } else if (token.tokenType == Tokens.CLOSEBRACKET) {\\n                readThis(Tokens.CLOSEBRACKET);\\n                break;\\n            }\\n        } while (true);\\n        return root;\\n    }\\n    private Expression readLeastExpression() {\\n                read();\\n        readThis(Tokens.OPENBRACKET);\\n        Expression casewhen = null;\\n        do {\\n            casewhen = readValue(casewhen, OpTypes.SMALLER);\\n            if (token.tokenType == Tokens.COMMA) {\\n                readThis(Tokens.COMMA);\\n            } else {\\n                break;\\n            }\\n        } while (true);\\n        readThis(Tokens.CLOSEBRACKET);\\n        return casewhen;\\n    }\\n    private Expression readGreatestExpression() {\\n                read();\\n        readThis(Tokens.OPENBRACKET);\\n        Expression casewhen = null;\\n        do {\\n            casewhen = readValue(casewhen, OpTypes.GREATER);\\n            if (token.tokenType == Tokens.COMMA) {\\n                readThis(Tokens.COMMA);\\n            } else {\\n                break;\\n            }\\n        } while (true);\\n        readThis(Tokens.CLOSEBRACKET);\\n        return casewhen;\\n    }\\n    private Expression readValue(Expression e, int opType) {\\n        Expression r = XreadValueExpression();\\n        if (e == null) {\\n            return r;\\n        }\\n        Expression l = new ExpressionLogical(opType, e, r);\\n        Expression a = new ExpressionOp(OpTypes.ALTERNATIVE, e, r);\\n        return new ExpressionOp(OpTypes.CASEWHEN, l, a);\\n    }\\n    private Expression readNullIfExpression() {\\n                read();\\n        readThis(Tokens.OPENBRACKET);\\n        Expression c = XreadValueExpression();\\n        readThis(Tokens.COMMA);\\n        Expression thenelse =\\n            new ExpressionOp(OpTypes.ALTERNATIVE,\\n                             new ExpressionValue((Object) null, (Type) null),\\n                             c);\\n        c = new ExpressionLogical(c, XreadValueExpression());\\n        c = new ExpressionOp(OpTypes.CASEWHEN, c, thenelse);\\n        readThis(Tokens.CLOSEBRACKET);\\n        return c;\\n    }\\n    private Expression readCoalesceExpression() {\\n        Expression c = null;\\n                read();\\n        readThis(Tokens.OPENBRACKET);\\n        Expression leaf = null;\\n        while (true) {\\n            Expression current = XreadValueExpression();\\n            if (leaf != null && token.tokenType == Tokens.CLOSEBRACKET) {\\n                readThis(Tokens.CLOSEBRACKET);\\n                leaf.setLeftNode(current);\\n                break;\\n            }\\n            Expression condition = new ExpressionLogical(OpTypes.IS_NULL,\\n                current);\\n            Expression alternatives = new ExpressionOp(OpTypes.ALTERNATIVE,\\n                new ExpressionValue((Object) null, (Type) null), current);\\n            Expression casewhen = new ExpressionOp(OpTypes.CASEWHEN_COALESCE,\\n                                                   condition, alternatives);\\n            if (c == null) {\\n                c = casewhen;\\n            } else {\\n                leaf.setLeftNode(casewhen);\\n            }\\n            leaf = alternatives;\\n            readThis(Tokens.COMMA);\\n        }\\n        return c;\\n    }\\n    Expression readSQLFunction(FunctionSQL function) {\\n        int position = getPosition();\\n        read();\\n        short[] parseList = function.parseList;\\n        if (parseList.length == 0) {\\n            return function;\\n        }\\n        HsqlArrayList exprList      = new HsqlArrayList();\\n        boolean       isOpenBracket = token.tokenType == Tokens.OPENBRACKET;\\n        try {\\n            readExpression(exprList, parseList, 0, parseList.length, false);\\n            lastError = null;\\n        } catch (HsqlException e) {\\n            if (!isOpenBracket) {\\n                rewind(position);\\n                return null;\\n            }\\n            if (function.parseListAlt == null) {\\n                throw e;\\n            }\\n            rewind(position);\\n            read();\\n            parseList = function.parseListAlt;\\n            exprList  = new HsqlArrayList();\\n            readExpression(exprList, parseList, 0, parseList.length, false);\\n            lastError = null;\\n        }\\n        Expression[] expr = new Expression[exprList.size()];\\n        exprList.toArray(expr);\\n        function.setArguments(expr);\\n        return function.getFunctionExpression();\\n    }\\n    void readExpression(HsqlArrayList exprList, short[] parseList, int start,\\n                        int count, boolean isOption) {\\n        for (int i = start; i < start + count; i++) {\\n            int exprType = parseList[i];\\n            switch (exprType) {\\n                case Tokens.QUESTION : {\\n                    Expression e = null;\\n                    e = XreadAllTypesCommonValueExpression(false);\\n                    exprList.add(e);\\n                    continue;\\n                }\\n                case Tokens.X_POS_INTEGER : {\\n                    Expression e     = null;\\n                    Integer    value = readIntegerObject();\\n                    if (value.intValue() < 0) {\\n                        throw Error.error(ErrorCode.X_42592);\\n                    }\\n                    e = new ExpressionValue(value, Type.SQL_INTEGER);\\n                    exprList.add(e);\\n                    continue;\\n                }\\n                case Tokens.X_OPTION : {\\n                    i++;\\n                    int expressionCount  = exprList.size();\\n                    int position         = getPosition();\\n                    int elementCount     = parseList[i++];\\n                    int initialExprIndex = exprList.size();\\n                    try {\\n                        readExpression(exprList, parseList, i, elementCount,\\n                                       true);\\n                    } catch (HsqlException ex) {\\n                        ex.setLevel(compileContext.subqueryDepth);\\n                        if (lastError == null\\n                                || lastError.getLevel() < ex.getLevel()) {\\n                            lastError = ex;\\n                        }\\n                        rewind(position);\\n                        exprList.setSize(expressionCount);\\n                        for (int j = i; j < i + elementCount; j++) {\\n                            if (parseList[j] == Tokens.QUESTION\\n                                    || parseList[j] == Tokens.X_KEYSET\\n                                    || parseList[j] == Tokens.X_POS_INTEGER) {\\n                                exprList.add(null);\\n                            }\\n                        }\\n                        i += elementCount - 1;\\n                        continue;\\n                    }\\n                    if (initialExprIndex == exprList.size()) {\\n                        exprList.add(null);\\n                    }\\n                    i += elementCount - 1;\\n                    continue;\\n                }\\n                case Tokens.X_REPEAT : {\\n                    i++;\\n                    int elementCount = parseList[i++];\\n                    int parseIndex   = i;\\n                    while (true) {\\n                        int initialExprIndex = exprList.size();\\n                        readExpression(exprList, parseList, parseIndex,\\n                                       elementCount, true);\\n                        if (exprList.size() == initialExprIndex) {\\n                            break;\\n                        }\\n                    }\\n                    i += elementCount - 1;\\n                    continue;\\n                }\\n                case Tokens.X_KEYSET : {\\n                    int        elementCount = parseList[++i];\\n                    Expression e            = null;\\n                    if (ArrayUtil.find(parseList, token.tokenType, i\\n                                       + 1, elementCount) == -1) {\\n                        if (!isOption) {\\n                            throw unexpectedToken();\\n                        }\\n                    } else {\\n                        e = new ExpressionValue(\\n                            ValuePool.getInt(token.tokenType),\\n                            Type.SQL_INTEGER);\\n                        read();\\n                    }\\n                    exprList.add(e);\\n                    i += elementCount;\\n                    continue;\\n                }\\n                case Tokens.OPENBRACKET :\\n                case Tokens.CLOSEBRACKET :\\n                case Tokens.COMMA :\\n                default :\\n                    if (token.tokenType != exprType) {\\n                        throw unexpectedToken();\\n                    }\\n                    read();\\n                    continue;\\n            }\\n        }\\n    }\\n    private Expression readSequenceExpressionOrNull(int opType) {\\n        int position = getPosition();\\n        read();\\n        if (token.tokenType != Tokens.VALUE) {\\n            rewind(position);\\n            return null;\\n        }\\n        readThis(Tokens.VALUE);\\n        readThis(Tokens.FOR);\\n        checkIsSchemaObjectName();\\n        String schema = session.getSchemaName(token.namePrefix);\\n        NumberSequence sequence =\\n            database.schemaManager.getSequence(token.tokenString, schema,\\n                                               true);\\n        Token recordedToken = getRecordedToken();\\n        read();\\n        Expression e = new ExpressionColumn(sequence, opType);\\n        recordedToken.setExpression(sequence);\\n        compileContext.addSequence(sequence);\\n        return e;\\n    }\\n    SimpleName readSimpleName() {\\n        checkIsSimpleName();\\n        SimpleName name = HsqlNameManager.getSimpleName(token.tokenString,\\n            isDelimitedIdentifier());\\n        read();\\n        return name;\\n    }\\n    HsqlName readNewSchemaName() {\\n        checkIsSchemaObjectName();\\n        checkValidCatalogName(token.namePrefix);\\n        SqlInvariants.checkSchemaNameNotSystem(token.tokenString);\\n        HsqlName name = database.nameManager.newHsqlName(token.tokenString,\\n            isDelimitedIdentifier(), SchemaObject.SCHEMA);\\n        read();\\n        return name;\\n    }\\n    HsqlName readNewSchemaObjectName(int type, boolean checkSchema) {\\n        checkIsSchemaObjectName();\\n        HsqlName hsqlName = database.nameManager.newHsqlName(token.tokenString,\\n            isDelimitedIdentifier(), type);\\n        if (token.namePrefix != null) {\\n            switch (type) {\\n                case SchemaObject.LABEL :\\n                case SchemaObject.VARIABLE :\\n                case SchemaObject.GRANTEE :\\n                case SchemaObject.CATALOG :\\n                    throw unexpectedToken();\\n                case SchemaObject.CURSOR : {\\n                    if (token.namePrePrefix == null\\n                            && Tokens.T_MODULE.equals(token.namePrefix)\\n                            && !token.isDelimitedPrefix) {}\\n                    else {\\n                        throw unexpectedTokenRequire(Tokens.T_MODULE);\\n                    }\\n                    break;\\n                }\\n                case SchemaObject.SCHEMA : {\\n                    checkValidCatalogName(token.namePrefix);\\n                    if (token.namePrePrefix != null) {\\n                        throw tooManyIdentifiers();\\n                    }\\n                    break;\\n                }\\n                case SchemaObject.SERVER :\\n                case SchemaObject.WRAPPER : {\\n                    checkValidCatalogName(token.namePrefix);\\n                    if (token.namePrePrefix != null) {\\n                        throw tooManyIdentifiers();\\n                    }\\n                    break;\\n                }\\n                case SchemaObject.COLUMN : {\\n                    if (token.namePrefix != null) {\\n                        throw tooManyIdentifiers();\\n                    }\\n                    break;\\n                }\\n                default : {\\n                    checkValidCatalogName(token.namePrePrefix);\\n                    HsqlName schemaName;\\n                    if (checkSchema) {\\n                        schemaName =\\n                            session.getSchemaHsqlName(token.namePrefix);\\n                    } else {\\n                        schemaName =\\n                            session.database.schemaManager.findSchemaHsqlName(\\n                                token.namePrefix);\\n                        if (schemaName == null) {\\n                            schemaName = database.nameManager.newHsqlName(\\n                                token.namePrefix, isDelimitedIdentifier(),\\n                                SchemaObject.SCHEMA);\\n                        }\\n                    }\\n                    hsqlName.setSchemaIfNull(schemaName);\\n                    break;\\n                }\\n            }\\n        }\\n        read();\\n        return hsqlName;\\n    }\\n    HsqlName readNewDependentSchemaObjectName(HsqlName parentName, int type) {\\n        HsqlName name = readNewSchemaObjectName(type, true);\\n        name.parent = parentName;\\n        name.setSchemaIfNull(parentName.schema);\\n        if (name.schema != null && parentName.schema != null\\n                && name.schema != parentName.schema) {\\n            throw Error.error(ErrorCode.X_42505, token.namePrefix);\\n        }\\n        return name;\\n    }\\n    HsqlName readSchemaName() {\\n        checkIsSchemaObjectName();\\n        checkValidCatalogName(token.namePrefix);\\n        HsqlName schema = session.getSchemaHsqlName(token.tokenString);\\n        read();\\n        return schema;\\n    }\\n    SchemaObject readSchemaObjectName(int type) {\\n        checkIsSchemaObjectName();\\n        checkValidCatalogName(token.namePrePrefix);\\n        String schema = session.getSchemaName(token.namePrefix);\\n        SchemaObject object =\\n            database.schemaManager.getSchemaObject(token.tokenString, schema,\\n                type);\\n        read();\\n        return object;\\n    }\\n    SchemaObject readSchemaObjectName(HsqlName schemaName, int type) {\\n        checkIsSchemaObjectName();\\n        SchemaObject object =\\n            database.schemaManager.getSchemaObject(token.tokenString,\\n                schemaName.name, type);\\n        if (token.namePrefix != null) {\\n            if (!token.namePrefix.equals(schemaName.name)) {\\n                                throw Error.error(ErrorCode.X_42505, token.namePrefix);\\n            }\\n            if (token.namePrePrefix != null) {\\n                if (!token.namePrePrefix.equals(\\n                        database.getCatalogName().name)) {\\n                                        throw Error.error(ErrorCode.X_42505, token.namePrefix);\\n                }\\n            }\\n        }\\n        read();\\n        return object;\\n    }\\n    Table readTableName() {\\n        checkIsIdentifier();\\n        if (token.namePrePrefix != null) {\\n            checkValidCatalogName(token.namePrePrefix);\\n        }\\n        Table table = database.schemaManager.getTable(session,\\n            token.tokenString, token.namePrefix);\\n        getRecordedToken().setExpression(table);\\n        read();\\n        return table;\\n    }\\n    ColumnSchema readSimpleColumnName(RangeVariable rangeVar) {\\n        ColumnSchema column = null;\\n        checkIsIdentifier();\\n        if (token.namePrefix != null) {\\n            throw tooManyIdentifiers();\\n        }\\n        int index = rangeVar.findColumn(token.tokenString);\\n        if (index > -1 && rangeVar.resolvesTableName(token.namePrefix)\\n                && rangeVar.resolvesSchemaName(token.namePrePrefix)) {\\n            column = rangeVar.getTable().getColumn(index);\\n            read();\\n            return column;\\n        }\\n        throw Error.error(ErrorCode.X_42501, token.tokenString);\\n    }\\n    ColumnSchema readSimpleColumnName(Table table) {\\n        checkIsIdentifier();\\n        if (token.namePrefix != null) {\\n            throw tooManyIdentifiers();\\n        }\\n        int index = table.findColumn(token.tokenString);\\n        if (index == -1) {\\n            throw Error.error(ErrorCode.X_42501, token.tokenString);\\n        }\\n        ColumnSchema column = table.getColumn(index);\\n        read();\\n        return column;\\n    }\\n    StatementQuery compileDeclareCursor(boolean isRoutine,\\n                                        RangeVariable[] outerRanges) {\\n        int sensitivity   = ResultConstants.SQL_ASENSITIVE;\\n        int scrollability = ResultConstants.SQL_NONSCROLLABLE;\\n        int holdability   = ResultConstants.SQL_NONHOLDABLE;\\n        int returnability = ResultConstants.SQL_WITHOUT_RETURN;\\n        int position      = super.getPosition();\\n        readThis(Tokens.DECLARE);\\n        SimpleName cursorName = readSimpleName();\\n        switch (token.tokenType) {\\n            case Tokens.SENSITIVE :\\n                read();\\n                sensitivity = ResultConstants.SQL_SENSITIVE;\\n                break;\\n            case Tokens.INSENSITIVE :\\n                read();\\n                sensitivity = ResultConstants.SQL_INSENSITIVE;\\n                break;\\n            case Tokens.ASENSITIVE :\\n                read();\\n                break;\\n        }\\n        if (token.tokenType == Tokens.NO) {\\n            readThis(Tokens.SCROLL);\\n        } else {\\n            if (token.tokenType == Tokens.SCROLL) {\\n                read();\\n                scrollability = ResultConstants.SQL_SCROLLABLE;\\n            }\\n        }\\n        if (token.tokenType != Tokens.CURSOR) {\\n            rewind(position);\\n            return null;\\n        }\\n        readThis(Tokens.CURSOR);\\n        for (int round = 0; round < 2; round++) {\\n            if (token.tokenType == Tokens.WITH) {\\n                read();\\n                if (round == 0 && token.tokenType == Tokens.HOLD) {\\n                    read();\\n                    holdability = ResultConstants.SQL_HOLDABLE;\\n                } else {\\n                    readThis(Tokens.RETURN);\\n                    round++;\\n                    returnability = ResultConstants.SQL_WITH_RETURN;\\n                }\\n            } else if (token.tokenType == Tokens.WITHOUT) {\\n                read();\\n                if (round == 0 && token.tokenType == Tokens.HOLD) {\\n                    read();\\n                } else {\\n                    readThis(Tokens.RETURN);\\n                    round++;\\n                }\\n            }\\n        }\\n        readThis(Tokens.FOR);\\n        int props = ResultProperties.getProperties(sensitivity,\\n            ResultConstants.SQL_UPDATABLE, scrollability, holdability,\\n            returnability);\\n        StatementQuery cs = compileCursorSpecification(props, isRoutine,\\n            outerRanges);\\n        cs.setCursorName(cursorName);\\n        return cs;\\n    }\\n    StatementQuery compileCursorSpecification(int props, boolean isRoutine,\\n            RangeVariable[] outerRanges) {\\n        OrderedHashSet  colNames        = null;\\n        QueryExpression queryExpression = XreadQueryExpression();\\n        if (token.tokenType == Tokens.FOR) {\\n            read();\\n            if (token.tokenType == Tokens.READ) {\\n                read();\\n                readThis(Tokens.ONLY);\\n            } else {\\n                readThis(Tokens.UPDATE);\\n                props = ResultProperties.addUpdatable(props, true);\\n                if (token.tokenType == Tokens.OF) {\\n                    readThis(Tokens.OF);\\n                    colNames = new OrderedHashSet();\\n                    readColumnNameList(colNames, null, false);\\n                }\\n            }\\n        }\\n        if (ResultProperties.isUpdatable(props)) {\\n            queryExpression.isUpdatable = true;\\n        }\\n        queryExpression.setReturningResult();\\n        queryExpression.resolve(session, outerRanges, null);\\n        StatementQuery cs = isRoutine\\n                            ? new StatementCursor(session, queryExpression,\\n                                compileContext)\\n                            : new StatementQuery(session, queryExpression,\\n                                compileContext);\\n        return cs;\\n    }\\n    StatementDMQL compileShortCursorSpecification(int props) {\\n        QueryExpression queryExpression = XreadQueryExpression();\\n        if (ResultProperties.isUpdatable(props)) {\\n            queryExpression.isUpdatable = true;\\n        }\\n        queryExpression.setReturningResult();\\n        queryExpression.resolve(session);\\n        StatementDMQL cs = new StatementQuery(session, queryExpression,\\n                                              compileContext);\\n        return cs;\\n    }\\n    int readCloseBrackets(int limit) {\\n        int count = 0;\\n        while (count < limit && token.tokenType == Tokens.CLOSEBRACKET) {\\n            read();\\n            count++;\\n        }\\n        return count;\\n    }\\n    int readOpenBrackets() {\\n        int count = 0;\\n        while (token.tokenType == Tokens.OPENBRACKET) {\\n            count++;\\n            read();\\n        }\\n        return count;\\n    }\\n    void checkValidCatalogName(String name) {\\n        if (name != null && !name.equals(database.getCatalogName().name)) {\\n            throw Error.error(ErrorCode.X_42501, name);\\n        }\\n    }\\n    void rewind(int position) {\\n        super.rewind(position);\\n        compileContext.rewind(position);\\n    }\\n    public static final class CompileContext {\\n        final Session    session;\\n        final ParserBase parser;\\n                private int           subqueryDepth;\\n        private HsqlArrayList namedSubqueries;\\n                private OrderedIntKeyHashMap parameters = new OrderedIntKeyHashMap();\\n        private HsqlArrayList        usedSequences  = new HsqlArrayList(true);\\n        private HsqlArrayList        usedRoutines   = new HsqlArrayList(true);\\n        private HsqlArrayList        rangeVariables = new HsqlArrayList(true);\\n        private HsqlArrayList        usedObjects    = new HsqlArrayList(true);\\n        Type                         currentDomain;\\n        boolean                      contextuallyTypedExpression;\\n        Routine                      callProcedure;\\n                private int rangeVarIndex = 0;\\n        public CompileContext(Session session, ParserBase parser) {\\n            this.session = session;\\n            this.parser  = parser;\\n            reset();\\n        }\\n        public void reset() {\\n            reset(1);\\n        }\\n        public void reset(int n) {\\n            rangeVarIndex = n;\\n            rangeVariables.clear();\\n            subqueryDepth = 0;\\n            parameters.clear();\\n            usedSequences.clear();\\n            usedRoutines.clear();\\n            callProcedure = null;\\n            usedObjects.clear();\\n                        currentDomain               = null;\\n            contextuallyTypedExpression = false;\\n        }\\n        public void rewind(int position) {\\n            for (int i = rangeVariables.size() - 1; i >= 0; i--) {\\n                RangeVariable range = (RangeVariable) rangeVariables.get(i);\\n                if (range.parsePosition > position) {\\n                    rangeVariables.remove(i);\\n                }\\n            }\\n            Iterator it = parameters.keySet().iterator();\\n            while (it.hasNext()) {\\n                int pos = it.nextInt();\\n                if (pos >= position) {\\n                    it.remove();\\n                }\\n            }\\n        }\\n        public void registerRangeVariable(RangeVariable range) {\\n            range.parsePosition = parser == null ? 0\\n                                                 : parser.getPosition();\\n            range.rangePosition = getNextRangeVarIndex();\\n            range.level         = subqueryDepth;\\n            rangeVariables.add(range);\\n        }\\n        public int getNextRangeVarIndex() {\\n            return rangeVarIndex++;\\n        }\\n        public int getRangeVarCount() {\\n            return rangeVarIndex;\\n        }\\n        public RangeVariable[] getRangeVariables() {\\n            RangeVariable[] array = new RangeVariable[rangeVariables.size()];\\n            rangeVariables.toArray(array);\\n            return array;\\n        }\\n        public NumberSequence[] getSequences() {\\n            if (usedSequences.size() == 0) {\\n                return NumberSequence.emptyArray;\\n            }\\n            NumberSequence[] array = new NumberSequence[usedSequences.size()];\\n            usedSequences.toArray(array);\\n            return array;\\n        }\\n        public Routine[] getRoutines() {\\n            if (callProcedure == null && usedRoutines.size() == 0) {\\n                return Routine.emptyArray;\\n            }\\n            OrderedHashSet set = new OrderedHashSet();\\n            for (int i = 0; i < usedRoutines.size(); i++) {\\n                FunctionSQLInvoked function =\\n                    (FunctionSQLInvoked) usedRoutines.get(i);\\n                set.add(function.routine);\\n            }\\n            if (callProcedure != null) {\\n                set.add(callProcedure);\\n            }\\n            Routine[] array = new Routine[set.size()];\\n            set.toArray(array);\\n            return array;\\n        }\\n        private void initSubqueryNames() {\\n            if (namedSubqueries == null) {\\n                namedSubqueries = new HsqlArrayList();\\n            }\\n            if (namedSubqueries.size() <= subqueryDepth) {\\n                namedSubqueries.setSize(subqueryDepth + 1);\\n            }\\n            HashMappedList set =\\n                (HashMappedList) namedSubqueries.get(subqueryDepth);\\n            if (set == null) {\\n                set = new HashMappedList();\\n                namedSubqueries.set(subqueryDepth, set);\\n            } else {\\n                set.clear();\\n            }\\n        }\\n        private void registerSubquery(String name, SubQuery subquery) {\\n            HashMappedList set =\\n                (HashMappedList) namedSubqueries.get(subqueryDepth);\\n            boolean added = set.add(name, subquery);\\n            if (!added) {\\n                throw Error.error(ErrorCode.X_42504);\\n            }\\n        }\\n        private SubQuery getNamedSubQuery(String name) {\\n            if (namedSubqueries == null) {\\n                return null;\\n            }\\n            for (int i = subqueryDepth; i >= 0; i--) {\\n                if (namedSubqueries.size() <= i) {\\n                    continue;\\n                }\\n                HashMappedList set = (HashMappedList) namedSubqueries.get(i);\\n                if (set == null) {\\n                    continue;\\n                }\\n                SubQuery sq = (SubQuery) set.get(name);\\n                if (sq != null) {\\n                    return sq;\\n                }\\n            }\\n            return null;\\n        }\\n        private void addParameter(Expression e, int position) {\\n            parameters.put(position, e);\\n        }\\n        private void addSchemaObject(SchemaObject object) {\\n            usedObjects.add(object);\\n        }\\n        private void addSequence(SchemaObject object) {\\n            usedSequences.add(object);\\n        }\\n        void addFunctionCall(FunctionSQLInvoked function) {\\n            usedRoutines.add(function);\\n        }\\n        void addProcedureCall(Routine procedure) {\\n            callProcedure = procedure;\\n        }\\n        ExpressionColumn[] getParameters() {\\n            if (parameters.size() == 0) {\\n                return ExpressionColumn.emptyArray;\\n            }\\n            ExpressionColumn[] result =\\n                new ExpressionColumn[parameters.size()];\\n            parameters.valuesToArray(result);\\n            parameters.clear();\\n            return result;\\n        }\\n        void clearParameters() {\\n            parameters.clear();\\n        }\\n        public OrderedHashSet getSchemaObjectNames() {\\n            OrderedHashSet set = new OrderedHashSet();\\n            for (int i = 0; i < usedSequences.size(); i++) {\\n                SchemaObject object = (SchemaObject) usedSequences.get(i);\\n                set.add(object.getName());\\n            }\\n            for (int i = 0; i < usedObjects.size(); i++) {\\n                SchemaObject object = (SchemaObject) usedObjects.get(i);\\n                set.add(object.getName());\\n            }\\n            for (int i = 0; i < rangeVariables.size(); i++) {\\n                RangeVariable range = (RangeVariable) rangeVariables.get(i);\\n                HsqlName      name  = range.rangeTable.getName();\\n                if (name.schema != SqlInvariants.SYSTEM_SCHEMA_HSQLNAME) {\\n                    set.add(range.rangeTable.getName());\\n                    set.addAll(range.getColumnNames());\\n                } else if (name.type == SchemaObject.TRANSITION) {\\n                    set.addAll(range.getColumnNames());\\n                }\\n            }\\n            Routine[] routines = getRoutines();\\n            for (int i = 0; i < routines.length; i++) {\\n                set.add(routines[i].getSpecificName());\\n            }\\n            return set;\\n        }\\n    }\\n}\""
        },
        {
            "content": "The code for `ParserDQL.java` reveals that it is primarily responsible for parsing SQL queries related to Data Query Language (DQL), such as `SELECT`, `FROM`, and query expressions involving joins, subqueries, sorting, grouping, and more. It heavily interacts with the database schema, tokens, expressions, and compilation contexts.\n\nGiven its purpose and complexity, we can infer that `ParserDQL.java` likely uses `Tokens.java` for recognizing and processing SQL keywords and symbols during the parsing of DQL statements.\n\nTo confirm this relationship and identify specific dependencies between `Tokens.java` and `ParserDQL.java`, we should retrieve the origin code of `Tokens.java`.\n\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_01ef0971982e48a58964dd",
                    "function": {
                        "arguments": "{\"entity\": \"Tokens.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package org.hsqldb;\\nimport org.hsqldb.lib.IntKeyHashMap;\\nimport org.hsqldb.lib.IntValueHashMap;\\nimport org.hsqldb.lib.OrderedIntHashSet;\\npublic class Tokens {\\n            static final String        T_ABS              = \\\"ABS\\\";\\n    public static final String T_ALL              = \\\"ALL\\\";\\n    static final String        T_ALLOCATE         = \\\"ALLOCATE\\\";\\n    public static final String T_ALTER            = \\\"ALTER\\\";\\n    static final String        T_AND              = \\\"AND\\\";\\n    public static final String T_ANY              = \\\"ANY\\\";\\n    static final String        T_ARE              = \\\"ARE\\\";\\n    public static final String T_ARRAY            = \\\"ARRAY\\\";\\n    public static final String T_ARRAY_AGG        = \\\"ARRAY_AGG\\\";\\n    public static final String T_AS               = \\\"AS\\\";\\n    static final String        T_ASENSITIVE       = \\\"ASENSITIVE\\\";\\n    static final String        T_ASYMMETRIC       = \\\"ASYMMETRIC\\\";\\n    static final String        T_AT               = \\\"AT\\\";\\n    static final String        T_ATOMIC           = \\\"ATOMIC\\\";\\n    public static final String T_AUTHORIZATION    = \\\"AUTHORIZATION\\\";\\n    static final String        T_AVG              = \\\"AVG\\\";\\n    static final String        T_BEGIN            = \\\"BEGIN\\\";\\n    static final String        T_BETWEEN          = \\\"BETWEEN\\\";\\n    public static final String T_BIGINT           = \\\"BIGINT\\\";\\n    public static final String T_BINARY           = \\\"BINARY\\\";\\n    static final String        T_BIT_LENGTH       = \\\"BIT_LENGTH\\\";\\n    public static final String T_BLOB             = \\\"BLOB\\\";\\n    public static final String T_BOOLEAN          = \\\"BOOLEAN\\\";\\n    static final String        T_BOTH             = \\\"BOTH\\\";\\n    static final String        T_BY               = \\\"BY\\\";\\n    public static final String T_CALL             = \\\"CALL\\\";\\n    static final String        T_CALLED           = \\\"CALLED\\\";\\n    static final String        T_CARDINALITY      = \\\"CARDINALITY\\\";\\n    public static final String T_CASCADED         = \\\"CASCADED\\\";\\n    static final String        T_CASE             = \\\"CASE\\\";\\n    static final String        T_CAST             = \\\"CAST\\\";\\n    static final String        T_CEIL             = \\\"CEIL\\\";\\n    static final String        T_CEILING          = \\\"CEILING\\\";\\n    public static final String T_CHAR             = \\\"CHAR\\\";\\n    static final String        T_CHAR_LENGTH      = \\\"CHAR_LENGTH\\\";\\n    public static final String T_CHARACTER        = \\\"CHARACTER\\\";\\n    static final String        T_CHARACTER_LENGTH = \\\"CHARACTER_LENGTH\\\";\\n    public static final String T_CHECK            = \\\"CHECK\\\";\\n    public static final String T_CLOB             = \\\"CLOB\\\";\\n    static final String        T_CLOSE            = \\\"CLOSE\\\";\\n    static final String        T_COALESCE         = \\\"COALESCE\\\";\\n    public static final String T_COLLATE          = \\\"COLLATE\\\";\\n    static final String        T_COLLECT          = \\\"COLLECT\\\";\\n    static final String        T_COLUMN           = \\\"COLUMN\\\";\\n    public static final String T_COMMIT           = \\\"COMMIT\\\";\\n    static final String        T_CONDITION        = \\\"CONDIITON\\\";\\n    public static final String T_CONNECT          = \\\"CONNECT\\\";\\n    public static final String T_CONSTRAINT       = \\\"CONSTRAINT\\\";\\n    public static final String T_CONVERT          = \\\"CONVERT\\\";\\n    static final String        T_CORR             = \\\"CORR\\\";\\n    static final String        T_CORRESPONDING    = \\\"CORRESPONDING\\\";\\n    static final String        T_COUNT            = \\\"COUNT\\\";\\n    static final String        T_COVAR_POP        = \\\"COVAR_POP\\\";\\n    static final String        T_COVAR_SAMP       = \\\"COVAR_SAMP\\\";\\n    public static final String T_CREATE           = \\\"CREATE\\\";\\n    static final String        T_CROSS            = \\\"CROSS\\\";\\n    static final String        T_CUBE             = \\\"CUBE\\\";\\n    static final String        T_CUME_DIST        = \\\"CUME_DIST\\\";\\n    static final String        T_CURRENT          = \\\"CURRENT\\\";\\n    static final String        T_CURRENT_CATALOG  = \\\"CURRENT_CATALOG\\\";\\n    static final String        T_CURRENT_DATE     = \\\"CURRENT_DATE\\\";\\n    static final String T_CURRENT_DEFAULT_TRANSFORM_GROUP =\\n        \\\"CURRENT_DEFAULT_TRANSFORM_GROUP\\\";\\n    static final String T_CURRENT_PATH      = \\\"CURRENT_PATH\\\";\\n    static final String T_CURRENT_ROLE      = \\\"CURRENT_ROLE\\\";\\n    static final String T_CURRENT_SCHEMA    = \\\"CURRENT_SCHEMA\\\";\\n    static final String T_CURRENT_TIME      = \\\"CURRENT_TIME\\\";\\n    static final String T_CURRENT_TIMESTAMP = \\\"CURRENT_TIMESTAMP\\\";\\n    static final String T_CURRENT_TRANSFORM_GROUP_FOR_TYPE =\\n        \\\"CURRENT_TRANSFORM_GROUP_FOR_TYPE\\\";\\n    static final String        T_CURRENT_USER      = \\\"CURRENT_USER\\\";\\n    static final String        T_CURSOR            = \\\"CURSOR\\\";\\n    static final String        T_CYCLE             = \\\"CYCLE\\\";\\n    public static final String T_DATE              = \\\"DATE\\\";\\n    public static final String T_DAY               = \\\"DAY\\\";\\n    static final String        T_DEALLOCATE        = \\\"DEALLOCATE\\\";\\n    public static final String T_DEC               = \\\"DEC\\\";\\n    public static final String T_DECIMAL           = \\\"DECIMAL\\\";\\n    static final String        T_DECLARE           = \\\"DECLARE\\\";\\n    public static final String T_DEFAULT           = \\\"DEFAULT\\\";\\n    public static final String T_DELETE            = \\\"DELETE\\\";\\n    static final String        T_DENSE_RANK        = \\\"DENSE_RANK\\\";\\n    static final String        T_DEREF             = \\\"DEREF\\\";\\n    static final String        T_DESCRIBE          = \\\"DESCRIBE\\\";\\n    static final String        T_DETERMINISTIC     = \\\"DETERMINISTIC\\\";\\n    static final String        T_DISCONNECT        = \\\"DISCONNECT\\\";\\n    static final String        T_DISTINCT          = \\\"DISTINCT\\\";\\n    public static final String T_DO                = \\\"DO\\\";\\n    public static final String T_DOUBLE            = \\\"DOUBLE\\\";\\n    static final String        T_DROP              = \\\"DROP\\\";\\n    static final String        T_DYNAMIC           = \\\"DYNAMIC\\\";\\n    static final String        T_EACH              = \\\"EACH\\\";\\n    static final String        T_ELEMENT           = \\\"ELEMENT\\\";\\n    static final String        T_ELSE              = \\\"ELSE\\\";\\n    static final String        T_ELSEIF            = \\\"ELSEIF\\\";\\n    static final String        T_END               = \\\"END\\\";\\n    static final String        T_END_EXEC          = \\\"END_EXEC\\\";\\n    static final String        T_ESCAPE            = \\\"ESCAPE\\\";\\n    static final String        T_EVERY             = \\\"EVERY\\\";\\n    static final String        T_EXCEPT            = \\\"EXCEPT\\\";\\n    static final String        T_EXEC              = \\\"EXEC\\\";\\n    public static final String T_EXECUTE           = \\\"EXECUTE\\\";\\n    static final String        T_EXISTS            = \\\"EXISTS\\\";\\n    static final String        T_EXP               = \\\"EXP\\\";\\n    public static final String T_EXTERNAL          = \\\"EXTERNAL\\\";\\n    static final String        T_EXTRACT           = \\\"EXTRACT\\\";\\n    public static final String T_FALSE             = \\\"FALSE\\\";\\n    static final String        T_FETCH             = \\\"FETCH\\\";\\n    static final String        T_FILTER            = \\\"FILTER\\\";\\n    static final String        T_FIRST_VALUE       = \\\"FIRST_VALUE\\\";\\n    public static final String T_FLOAT             = \\\"FLOAT\\\";\\n    static final String        T_FLOOR             = \\\"FLOOR\\\";\\n    public static final String T_FOR               = \\\"FOR\\\";\\n    public static final String T_FOREIGN           = \\\"FOREIGN\\\";\\n    static final String        T_FREE              = \\\"FREE\\\";\\n    public static final String T_FROM              = \\\"FROM\\\";\\n    static final String        T_FULL              = \\\"FULL\\\";\\n    public static final String T_FUNCTION          = \\\"FUNCTION\\\";\\n    static final String        T_FUSION            = \\\"FUSION\\\";\\n    public static final String T_GET               = \\\"GET\\\";\\n    static final String        T_GLOBAL            = \\\"GLOBAL\\\";\\n    public static final String T_GRANT             = \\\"GRANT\\\";\\n    static final String        T_GROUP             = \\\"GROUP\\\";\\n    static final String        T_GROUPING          = \\\"GROUPING\\\";\\n    static final String        T_HANDLER           = \\\"HANDLER\\\";\\n    static final String        T_HAVING            = \\\"HAVING\\\";\\n    static final String        T_HOLD              = \\\"HOLD\\\";\\n    public static final String T_HOUR              = \\\"HOUR\\\";\\n    static final String        T_IDENTITY          = \\\"IDENTITY\\\";\\n    static final String        T_IF                = \\\"IF\\\";\\n    static final String        T_IMPORT            = \\\"IMPORT\\\";\\n    static final String        T_IN                = \\\"IN\\\";\\n    static final String        T_INDICATOR         = \\\"INDICATOR\\\";\\n    static final String        T_INNER             = \\\"INNER\\\";\\n    static final String        T_INOUT             = \\\"INOUT\\\";\\n    static final String        T_INSENSITIVE       = \\\"INSENSITIVE\\\";\\n    public static final String T_INSERT            = \\\"INSERT\\\";\\n    public static final String T_INT               = \\\"INT\\\";\\n    public static final String T_INTEGER           = \\\"INTEGER\\\";\\n    static final String        T_INTERSECT         = \\\"INTERSECT\\\";\\n    static final String        T_INTERSECTION      = \\\"INTERSECTION\\\";\\n    public static final String T_INTERVAL          = \\\"INTERVAL\\\";\\n    static final String        T_INTO              = \\\"INTO\\\";\\n    static final String        T_ITERATE           = \\\"ITERATE\\\";\\n    public static final String T_IS                = \\\"IS\\\";\\n    static final String        T_JAR               = \\\"JAR\\\";                  static final String        T_JOIN              = \\\"JOIN\\\";\\n    static final String        T_LAG               = \\\"LAG\\\";\\n    public static final String T_LANGUAGE          = \\\"LANGUAGE\\\";\\n    static final String        T_LARGE             = \\\"LARGE\\\";\\n    static final String        T_LAST_VALUE        = \\\"LAST_VALUE\\\";\\n    static final String        T_LATERAL           = \\\"LATERAL\\\";\\n    static final String        T_LEAD              = \\\"LEAD\\\";\\n    static final String        T_LEADING           = \\\"LEADING\\\";\\n    static final String        T_LEAVE             = \\\"LEAVE\\\";\\n    static final String        T_LEFT              = \\\"LEFT\\\";\\n    static final String        T_LIKE              = \\\"LIKE\\\";\\n    static final String        T_LIKE_REGX         = \\\"LIKE_REGX\\\";\\n    static final String        T_LN                = \\\"LN\\\";\\n    public static final String T_LOCAL             = \\\"LOCAL\\\";\\n    static final String        T_LOCALTIME         = \\\"LOCALTIME\\\";\\n    static final String        T_LOCALTIMESTAMP    = \\\"LOCALTIMESTAMP\\\";\\n    public static final String T_LOOP              = \\\"LOOP\\\";\\n    static final String        T_LOWER             = \\\"LOWER\\\";\\n    static final String        T_MATCH             = \\\"MATCH\\\";\\n    static final String        T_MAX               = \\\"MAX\\\";\\n    static final String        T_MAX_CARDINALITY   = \\\"MAX_CARDINALITY\\\";\\n    static final String        T_MEMBER            = \\\"MEMBER\\\";\\n    static final String        T_MERGE             = \\\"MERGE\\\";\\n    static final String        T_METHOD            = \\\"METHOD\\\";\\n    static final String        T_MIN               = \\\"MIN\\\";\\n    public static final String T_MINUTE            = \\\"MINUTE\\\";\\n    static final String        T_MOD               = \\\"MOD\\\";\\n    static final String        T_MODIFIES          = \\\"MODIFIES\\\";\\n    static final String        T_MODULE            = \\\"MODULE\\\";\\n    public static final String T_MONTH             = \\\"MONTH\\\";\\n    public static final String T_MULTISET          = \\\"MULTISET\\\";\\n    static final String        T_NATIONAL          = \\\"NATIONAL\\\";\\n    static final String        T_NATURAL           = \\\"NATURAL\\\";\\n    static final String        T_NCHAR             = \\\"NCHAR\\\";\\n    static final String        T_NCLOB             = \\\"NCLOB\\\";\\n    static final String        T_NEW               = \\\"NEW\\\";\\n    public static final String T_NO                = \\\"NO\\\";\\n    public static final String T_NONE              = \\\"NONE\\\";\\n    static final String        T_NORMALIZE         = \\\"NORMALIZE\\\";\\n    static final String        T_NOT               = \\\"NOT\\\";\\n    static final String        T_NTH_VALUE         = \\\"NTH_VALUE\\\";\\n    static final String        T_NTILE             = \\\"NTILE\\\";\\n    public static final String T_NULL              = \\\"NULL\\\";\\n    public static final String T_NULLIF            = \\\"NULLIF\\\";\\n    public static final String T_NUMERIC           = \\\"NUMERIC\\\";\\n    static final String        T_OCCURRENCES_REGEX = \\\"OCCURRENCES_REGEX\\\";\\n    static final String        T_OCTET_LENGTH      = \\\"OCTET_LENGTH\\\";\\n    static final String        T_OF                = \\\"OF\\\";\\n    static final String        T_OFFSET            = \\\"OFFSET\\\";\\n    static final String        T_OLD               = \\\"OLD\\\";\\n    public static final String T_ON                = \\\"ON\\\";\\n    public static final String T_ONLY              = \\\"ONLY\\\";\\n    static final String        T_OPEN              = \\\"OPEN\\\";\\n    static final String        T_OR                = \\\"OR\\\";\\n    static final String        T_ORDER             = \\\"ORDER\\\";\\n    static final String        T_OUT               = \\\"OUT\\\";\\n    static final String        T_OUTER             = \\\"OUTER\\\";\\n    static final String        T_OVER              = \\\"OVER\\\";\\n    static final String        T_OVERLAPS          = \\\"OVERLAPS\\\";\\n    static final String        T_OVERLAY           = \\\"OVERLAY\\\";\\n    static final String        T_PARAMETER         = \\\"PARAMETER\\\";\\n    static final String        T_PARTITION         = \\\"PARTITION\\\";\\n    static final String        T_PERCENT_RANK      = \\\"PERCENT_RANK\\\";\\n    static final String        T_PERCENTILE_CONT   = \\\"PERCENTILE_CONT\\\";\\n    static final String        T_PERCENTILE_DISC   = \\\"PERCENTILE_DISC\\\";\\n    static final String        T_POSITION          = \\\"POSITION\\\";\\n    static final String        T_POSITION_REGEX    = \\\"POSITION_REGEX\\\";\\n    static final String        T_POWER             = \\\"POWER\\\";\\n    static final String        T_PRECISION         = \\\"PRECISION\\\";\\n    static final String        T_PREPARE           = \\\"PREPARE\\\";\\n    static final String        T_PRIMARY           = \\\"PRIMARY\\\";\\n    public static final String T_PROCEDURE         = \\\"PROCEDURE\\\";\\n    static final String        T_RANGE             = \\\"RANGE\\\";\\n    static final String        T_RANK              = \\\"RANK\\\";\\n    static final String        T_READS             = \\\"READS\\\";\\n    public static final String T_REAL              = \\\"REAL\\\";\\n    static final String        T_RECURSIVE         = \\\"RECURSIVE\\\";\\n    static final String        T_REF               = \\\"REF\\\";\\n    public static final String T_REFERENCES        = \\\"REFERENCES\\\";\\n    static final String        T_REFERENCING       = \\\"REFERENCING\\\";\\n    static final String        T_REGR_AVGX         = \\\"REGR_AVGX\\\";\\n    static final String        T_REGR_AVGY         = \\\"REGR_AVGY\\\";\\n    static final String        T_REGR_COUNT        = \\\"REGR_COUNT\\\";\\n    static final String        T_REGR_INTERCEPT    = \\\"REGR_INTERCEPT\\\";\\n    static final String        T_REGR_R2           = \\\"REGR_R2\\\";\\n    static final String        T_REGR_SLOPE        = \\\"REGR_SLOPE\\\";\\n    static final String        T_REGR_SXX          = \\\"REGR_SXX\\\";\\n    static final String        T_REGR_SXY          = \\\"REGR_SXY\\\";\\n    static final String        T_REGR_SYY          = \\\"REGR_SYY\\\";\\n    static final String        T_RELEASE           = \\\"RELEASE\\\";\\n    static final String        T_REPEAT            = \\\"REPEAT\\\";\\n    static final String        T_RESIGNAL          = \\\"RESIGNAL\\\";\\n    public static final String T_RESULT            = \\\"RESULT\\\";\\n    static final String        T_RETURN            = \\\"RETURN\\\";\\n    static final String        T_RETURNS           = \\\"RETURNS\\\";\\n    static final String        T_REVOKE            = \\\"REVOKE\\\";\\n    static final String        T_RIGHT             = \\\"RIGHT\\\";\\n    public static final String T_ROLLBACK          = \\\"ROLLBACK\\\";\\n    static final String        T_ROLLUP            = \\\"ROLLUP\\\";\\n    public static final String T_ROW               = \\\"ROW\\\";\\n    static final String        T_ROW_NUMBER        = \\\"ROW_NUMBER\\\";\\n    public static final String T_ROWS              = \\\"ROWS\\\";\\n    static final String        T_SAVEPOINT         = \\\"SAVEPOINT\\\";\\n    static final String        T_SCOPE             = \\\"SCOPE\\\";\\n    static final String        T_SCROLL            = \\\"SCROLL\\\";\\n    static final String        T_SEARCH            = \\\"SEARCH\\\";\\n    public static final String T_SECOND            = \\\"SECOND\\\";\\n    public static final String T_SELECT            = \\\"SELECT\\\";\\n    static final String        T_SENSITIVE         = \\\"SENSITIVE\\\";\\n    static final String        T_SESSION_USER      = \\\"SESSION_USER\\\";\\n    public static final String T_SET               = \\\"SET\\\";\\n    static final String        T_SIGNAL            = \\\"SIGNAL\\\";\\n    static final String        T_SIMILAR           = \\\"SIMILAR\\\";\\n    public static final String T_SMALLINT          = \\\"SMALLINT\\\";\\n    static final String        T_SOME              = \\\"SOME\\\";\\n    public static final String T_SPECIFIC          = \\\"SPECIFIC\\\";\\n    static final String        T_SPECIFICTYPE      = \\\"SPECIFICTYPE\\\";\\n    public static final String T_SQL               = \\\"SQL\\\";\\n    static final String        T_SQLEXCEPTION      = \\\"SQLEXCEPTION\\\";\\n    static final String        T_SQLSTATE          = \\\"SQLSTATE\\\";\\n    static final String        T_SQLWARNING        = \\\"SQLWARNING\\\";\\n    static final String        T_SQRT              = \\\"SQRT\\\";\\n    static final String        T_START             = \\\"START\\\";\\n    static final String        T_STATIC            = \\\"STATIC\\\";\\n    static final String        T_STDDEV_POP        = \\\"STDDEV_POP\\\";\\n    static final String        T_STDDEV_SAMP       = \\\"STDDEV_SAMP\\\";\\n    static final String        T_SUBMULTISET       = \\\"SUBMULTISET\\\";\\n    static final String        T_SUBSTRING         = \\\"SUBSTRING\\\";\\n    static final String        T_SUBSTRING_REGEX   = \\\"SUBSTRING_REGEX\\\";\\n    static final String        T_SUM               = \\\"SUM\\\";\\n    static final String        T_SYMMETRIC         = \\\"SYMMETRIC\\\";\\n    static final String        T_SYSTEM            = \\\"SYSTEM\\\";\\n    static final String        T_SYSTEM_USER       = \\\"SYSTEM_USER\\\";\\n    public static final String T_TABLE             = \\\"TABLE\\\";\\n    static final String        T_TABLESAMPLE       = \\\"TABLESAMPLE\\\";\\n    static final String        T_THEN              = \\\"THEN\\\";\\n    public static final String T_TIME              = \\\"TIME\\\";\\n    public static final String T_TIMESTAMP         = \\\"TIMESTAMP\\\";\\n    public static final String T_TIMEZONE_HOUR     = \\\"TIMEZONE_HOUR\\\";\\n    public static final String T_TIMEZONE_MINUTE   = \\\"TIMEZONE_MINUTE\\\";\\n    public static final String T_TO                = \\\"TO\\\";\\n    static final String        T_TRAILING          = \\\"TRAILING\\\";\\n    public static final String T_TRANSLATE         = \\\"TRANSLATE\\\";\\n    static final String        T_TRANSLATE_REGEX   = \\\"TRANSLATE_REGEX\\\";\\n    static final String        T_TRANSLATION       = \\\"TRANSLATION\\\";\\n    static final String        T_TREAT             = \\\"TREAT\\\";\\n    public static final String T_TRIGGER           = \\\"TRIGGER\\\";\\n    static final String        T_TRIM              = \\\"TRIM\\\";\\n    static final String        T_TRIM_ARRAY        = \\\"TRIM_ARRAY\\\";\\n    public static final String T_TRUE              = \\\"TRUE\\\";\\n    public static final String T_TRUNCATE          = \\\"TRUNCATE\\\";\\n    static final String        T_UESCAPE           = \\\"UESCAPE\\\";\\n    static final String        T_UNION             = \\\"UNION\\\";\\n    public static final String T_UNIQUE            = \\\"UNIQUE\\\";\\n    public static final String T_UNKNOWN           = \\\"UNKNOWN\\\";\\n    static final String        T_UNNEST            = \\\"UNNEST\\\";\\n    static final String        T_UNTIL             = \\\"UNTIL\\\";\\n    public static final String T_UPDATE            = \\\"UPDATE\\\";\\n    static final String        T_UPPER             = \\\"UPPER\\\";\\n    public static final String T_USER              = \\\"USER\\\";\\n    static final String        T_USING             = \\\"USING\\\";\\n    static final String        T_VALUE             = \\\"VALUE\\\";\\n    static final String        T_VALUES            = \\\"VALUES\\\";\\n    static final String        T_VAR_POP           = \\\"VAR_POP\\\";\\n    static final String        T_VAR_SAMP          = \\\"VAR_SAMP\\\";\\n    public static final String T_VARBINARY         = \\\"VARBINARY\\\";\\n    public static final String T_VARCHAR           = \\\"VARCHAR\\\";\\n    static final String        T_VARYING           = \\\"VARYING\\\";\\n    static final String        T_WHEN              = \\\"WHEN\\\";\\n    static final String        T_WHENEVER          = \\\"WHENEVER\\\";\\n    static final String        T_WHERE             = \\\"WHERE\\\";\\n    public static final String T_WHILE             = \\\"WHILE\\\";\\n    static final String        T_WIDTH_BUCKET      = \\\"WIDTH_BUCKET\\\";\\n    static final String        T_WINDOW            = \\\"WINDOW\\\";\\n    public static final String T_WITH              = \\\"WITH\\\";\\n    static final String        T_WITHIN            = \\\"WITHIN\\\";\\n    static final String        T_WITHOUT           = \\\"WITHOUT\\\";\\n    public static final String T_YEAR              = \\\"YEAR\\\";\\n        static final String        T_ASTERISK       = \\\"*\\\";\\n    public static final String T_COMMA          = \\\",\\\";\\n    static final String        T_CIRCUMFLEX     = \\\"^\\\";\\n    static final String        T_CLOSEBRACKET   = \\\")\\\";\\n    static final String        T_COLON          = \\\":\\\";\\n    static final String        T_CONCAT         = \\\"||\\\";\\n    public static final String T_DIVIDE         = \\\"/\\\";\\n    static final String        T_EQUALS         = \\\"=\\\";\\n    static final String        T_GREATER        = \\\">\\\";\\n    static final String        T_GREATER_EQUALS = \\\">=\\\";\\n    public static final String T_LEFTBRACKET    = \\\"[\\\";\\n    static final String        T_LESS           = \\\"<\\\";\\n    static final String        T_LESS_EQUALS    = \\\"<=\\\";\\n    static final String        T_PERCENT        = \\\"%\\\";\\n    static final String        T_PLUS           = \\\"+\\\";\\n    static final String        T_MINUS          = \\\"-\\\";\\n    static final String        T_NOT_EQUALS     = \\\"<>\\\";\\n    static final String        T_NOT_EQUALS_ALT = \\\"!=\\\";\\n    static final String        T_OPENBRACKET    = \\\"(\\\";\\n    static final String        T_QUESTION       = \\\"?\\\";\\n    public static final String T_RIGHTBRACKET   = \\\"]\\\";\\n    static final String        T_SEMICOLON      = \\\";\\\";\\n    static final String        T_DOUBLE_COLON   = \\\"::\\\";\\n        static final String        T_A                    = \\\"A\\\";\\n    static final String        T_ABSOLUTE             = \\\"ABSOLUTE\\\";\\n    static final String        T_ACTION               = \\\"ACTION\\\";\\n    static final String        T_ADA                  = \\\"ADA\\\";\\n    static final String        T_ADD                  = \\\"ADD\\\";\\n    static final String        T_ADMIN                = \\\"ADMIN\\\";\\n    static final String        T_AFTER                = \\\"AFTER\\\";\\n    static final String        T_ALWAYS               = \\\"ALWAYS\\\";\\n    static final String        T_ASC                  = \\\"ASC\\\";\\n    static final String        T_ASSERTION            = \\\"ASSERTION\\\";\\n    static final String        T_ASSIGNMENT           = \\\"ASSIGNMENT\\\";\\n    static final String        T_ATTRIBUTE            = \\\"ATTRIBUTE\\\";\\n    static final String        T_ATTRIBUTES           = \\\"ATTRIBUTES\\\";\\n    static final String        T_BEFORE               = \\\"BEFORE\\\";\\n    static final String        T_BERNOULLI            = \\\"BERNOULLI\\\";\\n    public static final String T_BIT                  = \\\"BIT\\\";\\n    static final String        T_BITLENGTH            = \\\"BITLENGTH\\\";\\n    static final String        T_BREADTH              = \\\"BREADTH\\\";\\n    static final String        T_C                    = \\\"C\\\";\\n    static final String        T_CASCADE              = \\\"CASCADE\\\";\\n    public static final String T_CATALOG              = \\\"CATALOG\\\";\\n    public static final String T_CATALOG_NAME         = \\\"CATALOG_NAME\\\";\\n    static final String        T_CHAIN                = \\\"CHAIN\\\";\\n    static final String T_CHARACTER_SET_CATALOG = \\\"CHARACTER_SET_CATALOG\\\";\\n    static final String        T_CHARACTER_SET_NAME   = \\\"CHARACTER_SET_NAME\\\";\\n    static final String        T_CHARACTER_SET_SCHEMA = \\\"CHARACTER_SET_SCHEMA\\\";\\n    static final String        T_CHARACTERISTICS      = \\\"CHARACTERISTICS\\\";\\n    static final String        T_CHARACTERS           = \\\"CHARACTERS\\\";\\n    static final String        T_CLASS_ORIGIN         = \\\"CLASS_ORIGIN\\\";\\n    static final String        T_COBOL                = \\\"COBOL\\\";\\n    public static final String T_COLLATION            = \\\"COLLATION\\\";\\n    static final String        T_COLLATION_CATALOG    = \\\"COLLATION_CATALOG\\\";\\n    static final String        T_COLLATION_NAME       = \\\"COLLATION_NAME\\\";\\n    static final String        T_COLLATION_SCHEMA     = \\\"COLLATION_SCHEMA\\\";\\n    static final String        T_COLUMN_NAME          = \\\"COLUMN_NAME\\\";\\n    static final String        T_COMMAND_FUNCTION     = \\\"COMMAND_FUNCTION\\\";\\n    static final String T_COMMAND_FUNCTION_CODE = \\\"COMMAND_FUNCTION_CODE\\\";\\n    public static final String T_COMMITTED            = \\\"COMMITTED\\\";\\n    static final String        T_COMPARABLE           = \\\"COMPARABLE\\\";        static final String        T_CONDITION_IDENTIFIER = \\\"CONDIITON_IDENTIFIER\\\";\\n    static final String        T_CONDITION_NUMBER     = \\\"CONDITION_NUMBER\\\";\\n    static final String        T_CONNECTION_NAME      = \\\"CONNECTION_NAME\\\";\\n    static final String        T_CONSTRAINT_CATALOG   = \\\"CONSTRAINT_CATALOG\\\";\\n    static final String        T_CONSTRAINT_NAME      = \\\"CONSTRAINT_NAME\\\";\\n    static final String        T_CONSTRAINT_SCHEMA    = \\\"CONSTRAINT_SCHEMA\\\";\\n    static final String        T_CONSTRAINTS          = \\\"CONSTRAINTS\\\";\\n    static final String        T_CONSTRUCTOR          = \\\"CONSTRUCTOR\\\";\\n    static final String        T_CONTAINS             = \\\"CONTAINS\\\";\\n    static final String        T_CONTINUE             = \\\"CONTINUE\\\";\\n    static final String        T_CURRENT_COLLATION    = \\\"CURRENT_COLLATION\\\";\\n    static final String        T_CURSOR_NAME          = \\\"CURSOR_NAME\\\";\\n    public static final String T_DATA                 = \\\"DATA\\\";\\n    static final String T_DATETIME_INTERVAL_CODE = \\\"DATETIME_INTERVAL_CODE\\\";\\n    static final String T_DATETIME_INTERVAL_PRECISION =\\n        \\\"DATETIME_INTERVAL_PRECISION\\\";\\n    public static final String T_DEFAULTS             = \\\"DEFAULTS\\\";\\n    static final String        T_DEFERRABLE           = \\\"DEFERRABLE\\\";\\n    static final String        T_DEFERRED             = \\\"DEFERRED\\\";\\n    static final String        T_DEFINED              = \\\"DEFINED\\\";\\n    static final String        T_DEFINER              = \\\"DEFINER\\\";\\n    static final String        T_DEGREE               = \\\"DEGREE\\\";\\n    static final String        T_DEPTH                = \\\"DEPTH\\\";\\n    static final String        T_DERIVED              = \\\"DERIVED\\\";\\n    static final String        T_DESC                 = \\\"DESC\\\";\\n    static final String        T_DESCRIPTOR           = \\\"DESCRIPTOR\\\";\\n    static final String        T_DIAGNOSTICS          = \\\"DIAGNOSTICS\\\";\\n    static final String        T_DISPATCH             = \\\"DISPATCH\\\";\\n    public static final String T_DOMAIN               = \\\"DOMAIN\\\";\\n    static final String        T_DYNAMIC_FUNCTION     = \\\"DYNAMIC_FUNCTION\\\";\\n    static final String T_DYNAMIC_FUNCTION_CODE = \\\"DYNAMIC_FUNCTION_CODE\\\";\\n    static final String        T_EXCEPTION            = \\\"EXCEPTION\\\";\\n    static final String        T_EXCLUDE              = \\\"EXCLUDE\\\";\\n    static final String        T_EXCLUDING            = \\\"EXCLUDING\\\";\\n    static final String        T_EXIT                 = \\\"EXIT\\\";\\n    static final String        T_FINAL                = \\\"FINAL\\\";\\n    static final String        T_FIRST                = \\\"FIRST\\\";\\n    static final String        T_FOLLOWING            = \\\"FOLLOWING\\\";\\n    static final String        T_FORTRAN              = \\\"FORTRAN\\\";\\n    static final String        T_FOUND                = \\\"FOUND\\\";\\n    public static final String T_G_FACTOR             = \\\"G\\\";\\n    static final String        T_GENERATED            = \\\"GENERATED\\\";\\n    static final String        T_GENERAL              = \\\"GENERAL\\\";\\n    static final String        T_GO                   = \\\"GO\\\";\\n    static final String        T_GOTO                 = \\\"GOTO\\\";\\n    static final String        T_GRANTED              = \\\"GRANTED\\\";\\n    static final String        T_HIERARCHY            = \\\"HIERARCHY\\\";\\n    static final String        T_IMPLEMENTATION       = \\\"IMPLEMENTATION\\\";\\n    static final String        T_INCLUDING            = \\\"INCLUDING\\\";\\n    public static final String T_INCREMENT            = \\\"INCREMENT\\\";\\n    static final String        T_INITIALLY            = \\\"INITIALLY\\\";\\n    static final String        T_INPUT                = \\\"INPUT\\\";\\n    static final String        T_INSTANCE             = \\\"INSTANCE\\\";\\n    static final String        T_INSTANTIABLE         = \\\"INSTANTIABLE\\\";\\n    static final String        T_INSTEAD              = \\\"INSTEAD\\\";\\n    static final String        T_INTERFACE            = \\\"INTERFACE\\\";         static final String        T_INVOKER              = \\\"INVOKER\\\";\\n    public static final String T_ISOLATION            = \\\"ISOLATION\\\";\\n    public static final String T_JAVA                 = \\\"JAVA\\\";              public static final String T_K_FACTOR             = \\\"K\\\";\\n    static final String        T_KEY                  = \\\"KEY\\\";\\n    static final String        T_KEY_MEMBER           = \\\"KEY_MEMBER\\\";\\n    static final String        T_KEY_TYPE             = \\\"KEY_TYPE\\\";\\n    static final String        T_LAST                 = \\\"LAST\\\";\\n    static final String        T_LENGTH               = \\\"LENGTH\\\";\\n    public static final String T_LEVEL                = \\\"LEVEL\\\";\\n    public static final String T_LIBRARY              = \\\"LIBRARY\\\";\\n    static final String        T_LOCATOR              = \\\"LOCATOR\\\";\\n    public static final String T_M_FACTOR             = \\\"M\\\";\\n    static final String        T_MAP                  = \\\"MAP\\\";\\n    static final String        T_MATCHED              = \\\"MATCHED\\\";\\n    static final String        T_MAXVALUE             = \\\"MAXVALUE\\\";\\n    static final String        T_MESSAGE_LENGTH       = \\\"MESSAGE_LENGTH\\\";\\n    static final String        T_MESSAGE_OCTET_LENGTH = \\\"MESSAGE_OCTET_LENGTH\\\";\\n    static final String        T_MESSAGE_TEXT         = \\\"MESSAGE_TEXT\\\";\\n    static final String        T_MINVALUE             = \\\"MINVALUE\\\";\\n    static final String        T_MORE                 = \\\"MORE\\\";\\n    static final String        T_MUMPS                = \\\"MUMPS\\\";\\n    public static final String T_NAME                 = \\\"NAME\\\";\\n    public static final String T_NAMES                = \\\"NAMES\\\";\\n    static final String        T_NESTING              = \\\"NESTING\\\";\\n    static final String        T_NEXT                 = \\\"NEXT\\\";\\n    static final String        T_NORMALIZED           = \\\"NORMALIZED\\\";\\n    static final String        T_NULLABLE             = \\\"NULLABLE\\\";\\n    public static final String T_NULLS                = \\\"NULLS\\\";\\n    static final String        T_NUMBER               = \\\"NUMBER\\\";\\n    public static final String T_OBJECT               = \\\"OBJECT\\\";\\n    static final String        T_OCTETS               = \\\"OCTETS\\\";\\n    static final String        T_OPTION               = \\\"OPTION\\\";\\n    static final String        T_OPTIONS              = \\\"OPTIONS\\\";\\n    static final String        T_ORDERING             = \\\"ORDERING\\\";\\n    static final String        T_ORDINALITY           = \\\"ORDINALITY\\\";\\n    static final String        T_OTHERS               = \\\"OTHERS\\\";\\n    public static final String T_OVERRIDING           = \\\"OVERRIDING\\\";\\n    public static final String T_P_FACTOR             = \\\"P\\\";\\n    static final String        T_PAD                  = \\\"PAD\\\";\\n    static final String        T_PARAMETER_MODE       = \\\"PARAMETER_MODE\\\";\\n    static final String        T_PARAMETER_NAME       = \\\"PARAMETER_NAME\\\";\\n    static final String T_PARAMETER_ORDINAL_POSITION =\\n        \\\"PARAMETER_ORDINAL_POSITION\\\";\\n    static final String T_PARAMETER_SPECIFIC_CATALOG =\\n        \\\"PARAMETER_SPECIFIC_CATALOG\\\";\\n    static final String T_PARAMETER_SPEC_NAME = \\\"PARAMETER_SPECIFIC_NAME\\\";\\n    static final String T_PARAMETER_SPEC_SCHEMA = \\\"PARAMETER_SPECIFIC_SCHEMA\\\";\\n    static final String        T_PARTIAL              = \\\"PARTIAL\\\";\\n    static final String        T_PASCAL               = \\\"PASCAL\\\";\\n    public static final String T_PATH                 = \\\"PATH\\\";\\n    static final String        T_PLACING              = \\\"PLACING\\\";\\n    static final String        T_PLI                  = \\\"PLI\\\";\\n    static final String        T_PRECEDING            = \\\"PRECEDING\\\";\\n    static final String        T_PRESERVE             = \\\"PRESERVE\\\";\\n    static final String        T_PRIOR                = \\\"PRIOR\\\";\\n    static final String        T_PRIVILEGES           = \\\"PRIVILEGES\\\";\\n    public static final String T_PUBLIC               = \\\"PUBLIC\\\";\\n    public static final String T_READ                 = \\\"READ\\\";\\n    static final String        T_RELATIVE             = \\\"RELATIVE\\\";\\n    static final String        T_REPEATABLE           = \\\"REPEATABLE\\\";\\n    static final String        T_RESTART              = \\\"RESTART\\\";\\n    static final String        T_RESET                = \\\"RESET\\\";\\n    static final String        T_RETURNED_CARDINALITY = \\\"RETURNED_CARDINALITY\\\";\\n    static final String        T_RETURNED_LENGTH      = \\\"RETURNED_LENGTH\\\";\\n    static final String T_RETURNED_OCTET_LENGTH = \\\"RETURNED_OCTET_LENGTH\\\";\\n    static final String        T_RETURNED_SQLSTATE    = \\\"RETURNED_SQLSTATE\\\";\\n    public static final String T_ROLE                 = \\\"ROLE\\\";\\n    public static final String T_ROUTINE              = \\\"ROUTINE\\\";\\n    static final String        T_ROUTINE_CATALOG      = \\\"ROUTINE_CATALOG\\\";\\n    static final String        T_ROUTINE_NAME         = \\\"ROUTINE_NAME\\\";\\n    static final String        T_ROUTINE_SCHEMA       = \\\"ROUTINE_SCHEMA\\\";\\n    static final String        T_ROW_COUNT            = \\\"ROW_COUNT\\\";\\n    public static final String T_SCALE                = \\\"SCALE\\\";\\n    public static final String T_SCHEMA               = \\\"SCHEMA\\\";\\n    static final String        T_SCHEMA_NAME          = \\\"SCHEMA_NAME\\\";\\n    static final String        T_SCOPE_CATALOG        = \\\"SCOPE_CATALOG\\\";\\n    static final String        T_SCOPE_NAME           = \\\"SCOPE_NAME\\\";\\n    static final String        T_SCOPE_SCHEMA         = \\\"SCOPE_SCHEMA\\\";\\n    static final String        T_SECTION              = \\\"SECTION\\\";\\n    static final String        T_SECURITY             = \\\"SECURITY\\\";\\n    static final String        T_SELF                 = \\\"SELF\\\";\\n    public static final String T_SEQUENCE             = \\\"SEQUENCE\\\";\\n    static final String        T_SERIAL               = \\\"SERIAL\\\";\\n    public static final String T_SERIALIZABLE         = \\\"SERIALIZABLE\\\";\\n    public static final String T_SERVER               = \\\"SERVER\\\";\\n    static final String        T_SERVER_NAME          = \\\"SERVER_NAME\\\";\\n    public static final String T_SESSION              = \\\"SESSION\\\";\\n    static final String        T_SETS                 = \\\"SETS\\\";\\n    static final String        T_SIMPLE               = \\\"SIMPLE\\\";\\n    public static final String T_SIZE                 = \\\"SIZE\\\";\\n    static final String        T_SOURCE               = \\\"SOURCE\\\";\\n    static final String        T_SPACE                = \\\"SPACE\\\";\\n    static final String        T_SPECIFIC_NAME        = \\\"SPECIFIC_NAME\\\";\\n    static final String        T_SQLDATA              = \\\"SQLDATA\\\";           static final String        T_STACKED              = \\\"STACKED\\\";\\n    static final String        T_STATE                = \\\"STATE\\\";\\n    static final String        T_STATEMENT            = \\\"STATEMENT\\\";\\n    static final String        T_STRUCTURE            = \\\"STRUCTURE\\\";\\n    static final String        T_STYLE                = \\\"STYLE\\\";\\n    static final String        T_SUBCLASS_ORIGIN      = \\\"SUBCLASS_ORIGIN\\\";\\n    public static final String T_T_FACTOR             = \\\"T\\\";\\n    static final String        T_TABLE_NAME           = \\\"TABLE_NAME\\\";\\n    static final String        T_TEMPORARY            = \\\"TEMPORARY\\\";\\n    static final String        T_TIES                 = \\\"TIES\\\";\\n    static final String        T_TOP_LEVEL_COUNT      = \\\"TOP_LEVEL_COUNT\\\";\\n    public static final String T_TRANSACTION          = \\\"TRANSACTION\\\";\\n    static final String        T_TRANSACT_COMMITTED = \\\"TRANSACTIONS_COMMITTED\\\";\\n    static final String T_TRANSACTION_ROLLED_BACK = \\\"TRANSACTIONS_ROLLED_BACK\\\";\\n    static final String        T_TRANSACT_ACTIVE      = \\\"TRANSACTION_ACTIVE\\\";\\n    static final String        T_TRANSFORM            = \\\"TRANSFORM\\\";\\n    static final String        T_TRANSFORMS           = \\\"TRANSFORMS\\\";\\n    static final String        T_TRIGGER_CATALOG      = \\\"TRIGGER_CATALOG\\\";\\n    static final String        T_TRIGGER_NAME         = \\\"TRIGGER_NAME\\\";\\n    static final String        T_TRIGGER_SCHEMA       = \\\"TRIGGER_SCHEMA\\\";\\n    public static final String T_TYPE                 = \\\"TYPE\\\";\\n    static final String        T_UNBOUNDED            = \\\"UNBOUNDED\\\";\\n    static final String        T_UNCOMMITTED          = \\\"UNCOMMITTED\\\";\\n    static final String        T_UNDER                = \\\"UNDER\\\";\\n    static final String        T_UNDO                 = \\\"UNDO\\\";\\n    static final String        T_UNNAMED              = \\\"UNNAMED\\\";\\n    public static final String T_USAGE                = \\\"USAGE\\\";\\n    static final String T_USER_DEFINED_TYPE_CATALOG =\\n        \\\"USER_DEFINED_TYPE_CATALOG\\\";\\n    static final String T_USER_DEFINED_TYPE_CODE = \\\"USER_DEFINED_TYPE_CODE\\\";\\n    static final String T_USER_DEFINED_TYPE_NAME = \\\"USER_DEFINED_TYPE_NAME\\\";\\n    static final String T_USER_DEFINED_TYPE_SCHEMA =\\n        \\\"USER_DEFINED_TYPE_SCHEMA\\\";\\n    static final String        T_VIEW    = \\\"VIEW\\\";\\n    static final String        T_WORK    = \\\"WORK\\\";\\n    public static final String T_WRAPPER = \\\"WRAPPER\\\";\\n    public static final String T_WRITE   = \\\"WRITE\\\";\\n    public static final String T_ZONE    = \\\"ZONE\\\";\\n        static final String        T_ALIAS                = \\\"ALIAS\\\";\\n    static final String        T_AGGREGATE            = \\\"AGGREGATE\\\";\\n    public static final String T_AUTHENTICATION       = \\\"AUTHENTICATION\\\";\\n    static final String        T_AUTO_INCREMENT       = \\\"AUTO_INCREMENT\\\";\\n    static final String        T_AUTOCOMMIT           = \\\"AUTOCOMMIT\\\";\\n    public static final String T_BACKUP               = \\\"BACKUP\\\";\\n    static final String        T_BINARY_DOUBLE        = \\\"BINARY_DOUBLE\\\";\\n    static final String        T_BINARY_FLOAT         = \\\"BINARY_FLOAT\\\";\\n    static final String        T_BODY                 = \\\"BODY\\\";\\n    static final String        T_BYTE                 = \\\"BYTE\\\";\\n    public static final String T_CACHE                = \\\"CACHE\\\";\\n    static final String        T_CACHED               = \\\"CACHED\\\";\\n    static final String        T_CASEWHEN             = \\\"CASEWHEN\\\";\\n    static final String        T_CHECKPOINT           = \\\"CHECKPOINT\\\";\\n    static final String        T_CLASS                = \\\"CLASS\\\";\\n    static final String        T_CLUSTERED            = \\\"CLUSTERED\\\";\\n    static final String        T_COMMENT              = \\\"COMMENT\\\";\\n    static final String        T_COMPACT              = \\\"COMPACT\\\";\\n    public static final String T_COMPRESSED           = \\\"COMPRESSED\\\";\\n    public static final String T_CONTROL              = \\\"CONTROL\\\";\\n    static final String        T_CURDATE              = \\\"CURDATE\\\";\\n    static final String        T_CURRVAL              = \\\"CURRVAL\\\";\\n    static final String        T_CURTIME              = \\\"CURTIME\\\";\\n    public static final String T_DATABASE             = \\\"DATABASE\\\";\\n    public static final String T_DATETIME             = \\\"DATETIME\\\";\\n    public static final String T_DEADLOCK             = \\\"DEADLOCK\\\";\\n    public static final String T_DEFRAG               = \\\"DEFRAG\\\";\\n    public static final String T_DELAY                = \\\"DELAY\\\";\\n    public static final String T_DIGEST               = \\\"DIGEST\\\";\\n    static final String        T_DUAL                 = \\\"DUAL\\\";\\n    static final String        T_EXPLAIN              = \\\"EXPLAIN\\\";\\n    public static final String T_EVENT                = \\\"EVENT\\\";\\n    static final String        T_FILE                 = \\\"FILE\\\";\\n    public static final String T_FILES                = \\\"FILES\\\";\\n    static final String        T_FOLD                 = \\\"FOLD\\\";\\n    static final String        T_FORMAT               = \\\"FORMAT\\\";\\n    static final String        T_GROUP_CONCAT         = \\\"GROUP_CONCAT\\\";\\n    static final String        T_HEADER               = \\\"HEADER\\\";\\n    static final String        T_IFNULL               = \\\"IFNULL\\\";\\n    static final String        T_IGNORECASE           = \\\"IGNORECASE\\\";\\n    static final String        T_IMMEDIATELY          = \\\"IMMEDIATELY\\\";\\n    public static final String T_INDEX                = \\\"INDEX\\\";\\n    public static final String T_INITIAL              = \\\"INITIAL\\\";\\n    public static final String T_INTEGRITY            = \\\"INTEGRITY\\\";\\n    static final String        T_IS_AUTOCOMMIT        = \\\"IS_AUTOCOMMIT\\\";\\n    static final String        T_IS_READONLY_DATABASE = \\\"IS_READONLY_DATABASE\\\";\\n    static final String T_IS_READONLY_DATABASE_FILES =\\n        \\\"IS_READONLY_DATABASE_FILES\\\";\\n    static final String        T_IS_READONLY_SESSION  = \\\"IS_READONLY_SESSION\\\";\\n    static final String        T_ISNULL               = \\\"ISNULL\\\";\\n    static final String        T_LASTVAL              = \\\"LASTVAL\\\";\\n    static final String        T_LIMIT                = \\\"LIMIT\\\";\\n    public static final String T_LOB                  = \\\"LOB\\\";\\n    public static final String T_LOCK                 = \\\"LOCK\\\";\\n    public static final String T_LOCKS                = \\\"LOCKS\\\";\\n    public static final String T_LONG                 = \\\"LONG\\\";\\n    public static final String T_LONGVAR              = \\\"LONGVAR\\\";\\n    public static final String T_LONGVARBINARY        = \\\"LONGVARBINARY\\\";\\n    public static final String T_LONGVARCHAR          = \\\"LONGVARCHAR\\\";\\n    static final String        T_MAXROWS              = \\\"MAXROWS\\\";\\n    static final String        T_MEDIAN               = \\\"MEDIAN\\\";\\n    public static final String T_MEMORY               = \\\"MEMORY\\\";\\n    public static final String T_MILLIS               = \\\"MILLIS\\\";\\n    static final String        T_MINUS_EXCEPT         = \\\"MINUS\\\";\\n    public static final String T_MSS                  = \\\"MSS\\\";\\n    public static final String T_MVCC                 = \\\"MVCC\\\";\\n    public static final String T_MVLOCKS              = \\\"MVLOCKS\\\";\\n    public static final String T_MYS                  = \\\"MYS\\\";\\n    public static final String T_NAN                  = \\\"NAN\\\";\\n    static final String        T_NEXTVAL              = \\\"NEXTVAL\\\";\\n    public static final String T_NIO                  = \\\"NIO\\\";\\n    static final String        T_NOWAIT               = \\\"NOWAIT\\\";\\n    public static final String T_NVARCHAR             = \\\"NVARCHAR\\\";\\n    static final String        T_NVL                  = \\\"NVL\\\";\\n    static final String        T_OCTETLENGTH          = \\\"OCTETLENGTH\\\";\\n    static final String        T_OFF                  = \\\"OFF\\\";\\n    public static final String T_OTHER                = \\\"OTHER\\\";\\n    public static final String T_ORA                  = \\\"ORA\\\";\\n    public static final String T_PASSWORD             = \\\"PASSWORD\\\";\\n    static final String        T_PLAN                 = \\\"PLAN\\\";\\n    public static final String T_PGS                  = \\\"PGS\\\";\\n    static final String        T_PROPERTY             = \\\"PROPERTY\\\";\\n    static final String        T_QUEUE                = \\\"QUEUE\\\";\\n    static final String        T_RAW                  = \\\"RAW\\\";\\n    static final String        T_READONLY             = \\\"READONLY\\\";\\n    static final String        T_REFERENTIAL          = \\\"REFERENTIAL\\\";\\n    static final String        T_RENAME               = \\\"RENAME\\\";\\n    static final String        T_RESTRICT             = \\\"RESTRICT\\\";\\n    static final String        T_ROWNUM               = \\\"ROWNUM\\\";\\n    static final String        T_SCRIPT               = \\\"SCRIPT\\\";\\n    static final String        T_SEPARATOR            = \\\"SEPARATOR\\\";\\n    static final String        T_BLOCKING             = \\\"BLOCKING\\\";\\n    static final String        T_SHUTDOWN             = \\\"SHUTDOWN\\\";\\n    static final String        T_SQL_TSI_DAY          = \\\"SQL_TSI_DAY\\\";\\n    static final String        T_SQL_TSI_FRAC_SECOND  = \\\"SQL_TSI_FRAC_SECOND\\\";\\n    static final String        T_SQL_TSI_MILLI_SECOND = \\\"SQL_TSI_MILLI_SECOND\\\";\\n    static final String        T_SQL_TSI_HOUR         = \\\"SQL_TSI_HOUR\\\";\\n    static final String        T_SQL_TSI_MINUTE       = \\\"SQL_TSI_MINUTE\\\";\\n    static final String        T_SQL_TSI_MONTH        = \\\"SQL_TSI_MONTH\\\";\\n    static final String        T_SQL_TSI_QUARTER      = \\\"SQL_TSI_QUARTER\\\";\\n    static final String        T_SQL_TSI_SECOND       = \\\"SQL_TSI_SECOND\\\";\\n    static final String        T_SQL_TSI_WEEK         = \\\"SQL_TSI_WEEK\\\";\\n    static final String        T_SQL_TSI_YEAR         = \\\"SQL_TSI_YEAR\\\";\\n    static final String        T_SQL_BIGINT           = \\\"SQL_BIGINT\\\";\\n    static final String        T_SQL_BINARY           = \\\"SQL_BINARY\\\";\\n    static final String        T_SQL_BIT              = \\\"SQL_BIT\\\";\\n    static final String        T_SQL_BLOB             = \\\"SQL_BLOB\\\";\\n    static final String        T_SQL_BOOLEAN          = \\\"SQL_BOOLEAN\\\";\\n    static final String        T_SQL_CHAR             = \\\"SQL_CHAR\\\";\\n    static final String        T_SQL_CLOB             = \\\"SQL_CLOB\\\";\\n    static final String        T_SQL_DATE             = \\\"SQL_DATE\\\";\\n    static final String        T_SQL_DECIMAL          = \\\"SQL_DECIMAL\\\";\\n    static final String        T_SQL_DATALINK         = \\\"SQL_DATALINK\\\";\\n    static final String        T_SQL_DOUBLE           = \\\"SQL_DOUBLE\\\";\\n    static final String        T_SQL_FLOAT            = \\\"SQL_FLOAT\\\";\\n    static final String        T_SQL_INTEGER          = \\\"SQL_INTEGER\\\";\\n    static final String        T_SQL_LONGVARBINARY    = \\\"SQL_LONGVARBINARY\\\";\\n    static final String        T_SQL_LONGNVARCHAR     = \\\"SQL_LONGNVARCHAR\\\";\\n    static final String        T_SQL_LONGVARCHAR      = \\\"SQL_LONGVARCHAR\\\";\\n    static final String        T_SQL_NCHAR            = \\\"SQL_NCHAR\\\";\\n    static final String        T_SQL_NCLOB            = \\\"SQL_NCLOB\\\";\\n    static final String        T_SQL_NUMERIC          = \\\"SQL_NUMERIC\\\";\\n    static final String        T_SQL_NVARCHAR         = \\\"SQL_NVARCHAR\\\";\\n    static final String        T_SQL_REAL             = \\\"SQL_REAL\\\";\\n    static final String        T_SQL_ROWID            = \\\"SQL_ROWID\\\";\\n    static final String        T_SQL_SQLXML           = \\\"SQL_SQLXML\\\";\\n    static final String        T_SQL_SMALLINT         = \\\"SQL_SMALLINT\\\";\\n    static final String        T_SQL_TIME             = \\\"SQL_TIME\\\";\\n    static final String        T_SQL_TIMESTAMP        = \\\"SQL_TIMESTAMP\\\";\\n    static final String        T_SQL_TINYINT          = \\\"SQL_TINYINT\\\";\\n    static final String        T_SQL_VARBINARY        = \\\"SQL_VARBINARY\\\";\\n    static final String        T_SQL_VARCHAR          = \\\"SQL_VARCHAR\\\";\\n    public static final String T_SYNTAX               = \\\"SYNTAX\\\";\\n    public static final String T_TDC                  = \\\"TDC\\\";\\n    public static final String T_TEMP                 = \\\"TEMP\\\";\\n    public static final String T_TEXT                 = \\\"TEXT\\\";\\n    static final String        T_TIMESTAMPADD         = \\\"TIMESTAMPADD\\\";\\n    static final String        T_TIMESTAMPDIFF        = \\\"TIMESTAMPDIFF\\\";\\n    public static final String T_TINYINT              = \\\"TINYINT\\\";\\n    static final String        T_TOP                  = \\\"TOP\\\";\\n    public static final String T_TTI                  = \\\"TTI\\\";\\n    public static final String T_TYPES                = \\\"TYPES\\\";\\n    public static final String T_VARCHAR_IGNORECASE   = \\\"VARCHAR_IGNORECASE\\\";\\n    public static final String T_VARCHAR2             = \\\"VARCHAR2\\\";\\n    public static final String T_UTF16                = \\\"UTF16\\\";\\n    static final String        T_WRITE_DELAY          = \\\"WRITE_DELAY\\\";\\n    public static final String T_YES                  = \\\"YES\\\";\\n        public static final String T_DAY_NAME     = \\\"DAY_NAME\\\";\\n    public static final String T_MONTH_NAME   = \\\"MONTH_NAME\\\";\\n    public static final String T_QUARTER      = \\\"QUARTER\\\";\\n    public static final String T_DAY_OF_WEEK  = \\\"DAY_OF_WEEK\\\";\\n    public static final String T_DAY_OF_MONTH = \\\"DAY_OF_MONTH\\\";\\n    public static final String T_DAY_OF_YEAR  = \\\"DAY_OF_YEAR\\\";\\n    public static final String T_WEEK_OF_YEAR = \\\"WEEK_OF_YEAR\\\";\\n    static final String        T_DAYNAME      = \\\"DAYNAME\\\";\\n    static final String        T_MONTHNAME    = \\\"MONTHNAME\\\";\\n    static final String        T_DAYOFMONTH   = \\\"DAYOFMONTH\\\";\\n    static final String        T_DAYOFWEEK    = \\\"DAYOFWEEK\\\";\\n    static final String        T_DAYOFYEAR    = \\\"DAYOFYEAR\\\";\\n    static final String        T_WEEK         = \\\"WEEK\\\";\\n        static final String        T_ACOS             = \\\"ACOS\\\";\\n    static final String        T_ACTION_ID        = \\\"ACTION_ID\\\";\\n    static final String        T_ARRAY_SORT       = \\\"ARRAY_SORT\\\";\\n    static final String        T_ASCII            = \\\"ASCII\\\";\\n    static final String        T_ASIN             = \\\"ASIN\\\";\\n    static final String        T_ATAN             = \\\"ATAN\\\";\\n    static final String        T_ATAN2            = \\\"ATAN2\\\";\\n    static final String        T_BITAND           = \\\"BITAND\\\";\\n    static final String        T_BITOR            = \\\"BITOR\\\";\\n    static final String        T_BITXOR           = \\\"BITXOR\\\";\\n    public static final String T_CONCAT_WORD      = \\\"CONCAT\\\";\\n    static final String        T_CHR              = \\\"CHR\\\";\\n    static final String        T_COS              = \\\"COS\\\";\\n    static final String        T_COT              = \\\"COT\\\";\\n    static final String        T_CRYPT_KEY        = \\\"CRYPT_KEY\\\";\\n    static final String        T_DATABASE_NAME    = \\\"DATABASE_NAME\\\";\\n    static final String        T_DATEADD          = \\\"DATEADD\\\";\\n    static final String        T_DATEDIFF         = \\\"DATEDIFF\\\";\\n    static final String        T_DECODE           = \\\"DECODE\\\";\\n    static final String        T_DEGREES          = \\\"DEGREES\\\";\\n    static final String        T_DIFFERENCE       = \\\"DIFFERENCE\\\";\\n    static final String        T_DMOD             = \\\"DMOD\\\";\\n    public static final String T_GC               = \\\"GC\\\";\\n    static final String        T_GREATEST         = \\\"GREATEST\\\";\\n    static final String        T_HEXTORAW         = \\\"HEXTORAW\\\";\\n    static final String        T_LCASE            = \\\"LCASE\\\";\\n    static final String        T_LEAST            = \\\"LEAST\\\";\\n    static final String        T_LOAD_FILE        = \\\"LOAD_FILE\\\";\\n    static final String        T_LOCATE           = \\\"LOCATE\\\";\\n    public static final String T_LOG              = \\\"LOG\\\";\\n    static final String        T_LOG10            = \\\"LOG10\\\";\\n    static final String        T_LPAD             = \\\"LPAD\\\";\\n    static final String        T_LTRIM            = \\\"LTRIM\\\";\\n    static final String        T_NOW              = \\\"NOW\\\";\\n    static final String        T_PI               = \\\"PI\\\";\\n    static final String        T_RADIANS          = \\\"RADIANS\\\";\\n    static final String        T_RAND             = \\\"RAND\\\";\\n    static final String        T_RAWTOHEX         = \\\"RAWTOHEX\\\";\\n    public static final String T_REGEXP_MATCHES   = \\\"REGEXP_MATCHES\\\";\\n    static final String        T_REPLACE          = \\\"REPLACE\\\";\\n    static final String        T_REVERSE          = \\\"REVERSE\\\";\\n    static final String        T_ROUND            = \\\"ROUND\\\";\\n    static final String        T_ROUNDMAGIC       = \\\"ROUNDMAGIC\\\";\\n    static final String        T_RPAD             = \\\"RPAD\\\";\\n    static final String        T_RTRIM            = \\\"RTRIM\\\";\\n    public static final String T_SECONDS_MIDNIGHT = \\\"SECONDS_SINCE_MIDNIGHT\\\";\\n    static final String        T_SIGN             = \\\"SIGN\\\";\\n    static final String        T_SIN              = \\\"SIN\\\";\\n    static final String        T_SOUNDEX          = \\\"SOUNDEX\\\";\\n    static final String        T_SUBSTR           = \\\"SUBSTR\\\";\\n    static final String        T_SYSDATE          = \\\"SYSDATE\\\";\\n    static final String        T_TAN              = \\\"TAN\\\";\\n    static final String        T_TO_CHAR          = \\\"TO_CHAR\\\";\\n    static final String        T_TO_DATE          = \\\"TO_DATE\\\";\\n    static final String        T_TO_TIMESTAMP     = \\\"TO_TIMESTAMP\\\";\\n    static final String        T_TRANSACTION_SIZE = \\\"TRANSACTION_SIZE\\\";\\n    static final String        T_TRANSACTION_ID   = \\\"TRANSACTION_ID\\\";\\n    static final String        T_TRUNC            = \\\"TRUNC\\\";\\n    static final String        T_TODAY            = \\\"TODAY\\\";\\n    static final String        T_UCASE            = \\\"UCASE\\\";\\n    static final String        T_UUID             = \\\"UUID\\\";\\n    static final String        T_UNIX_TIMESTAMP   = \\\"UNIX_TIMESTAMP\\\";\\n        static final String T_ISOLATION_LEVEL         = \\\"ISOLATION_LEVEL\\\";\\n    static final String T_SESSION_ISOLATION_LEVEL = \\\"SESSION_ISOLATION_LEVEL\\\";\\n    static final String T_DATABASE_ISOLATION_LEVEL =\\n        \\\"DATABASE_ISOLATION_LEVEL\\\";\\n    static final String T_TRANSACTION_CONTROL = \\\"TRANSACTION_CONTROL\\\";\\n    static final String T_TIMEZONE            = \\\"TIMEZONE\\\";\\n    static final String T_SESSION_TIMEZONE    = \\\"SESSION_TIMEZONE\\\";\\n    static final String T_DATABASE_TIMEZONE   = \\\"DATABASE_TIMEZONE\\\";\\n    static final String T_DATABASE_VERSION    = \\\"DATABASE_VERSION\\\";\\n    static final String T_SESSION_ID          = \\\"SESSION_ID\\\";\\n    static final String T_LOB_ID              = \\\"LOB_ID\\\";\\n    static final String T_SEQUENCE_ARRAY      = \\\"SEQUENCE_ARRAY\\\";\\n            public static final int ABS                              = 1;\\n    public static final int ALL                              = 2;\\n    public static final int ALLOCATE                         = 3;\\n    public static final int ALTER                            = 4;\\n    public static final int AND                              = 5;\\n    public static final int ANY                              = 6;\\n    public static final int ARE                              = 7;\\n    public static final int ARRAY                            = 8;\\n    public static final int ARRAY_AGG                        = 9;\\n    public static final int AS                               = 10;\\n    public static final int ASENSITIVE                       = 11;\\n    public static final int ASYMMETRIC                       = 12;\\n    public static final int AT                               = 13;\\n    public static final int ATOMIC                           = 14;\\n    public static final int AUTHORIZATION                    = 15;\\n    public static final int AVG                              = 16;\\n    public static final int BEGIN                            = 17;\\n    public static final int BETWEEN                          = 18;\\n    public static final int BIGINT                           = 19;\\n    public static final int BINARY                           = 20;\\n    public static final int BLOB                             = 21;\\n    public static final int BOOLEAN                          = 22;\\n    public static final int BOTH                             = 23;\\n    public static final int BY                               = 24;\\n    public static final int CALL                             = 25;\\n    public static final int CALLED                           = 26;\\n    public static final int CARDINALITY                      = 27;\\n    public static final int CASCADED                         = 28;\\n    public static final int CASE                             = 29;\\n    public static final int CAST                             = 30;\\n    public static final int CEIL                             = 31;\\n    public static final int CEILING                          = 32;\\n    public static final int CHAR                             = 33;\\n    public static final int CHAR_LENGTH                      = 34;\\n    public static final int CHARACTER                        = 35;\\n    public static final int CHARACTER_LENGTH                 = 36;\\n    public static final int CHECK                            = 37;\\n    public static final int CLOB                             = 38;\\n    public static final int CLOSE                            = 39;\\n    public static final int COALESCE                         = 40;\\n    public static final int COLLATE                          = 41;\\n    public static final int COLLECT                          = 42;\\n    public static final int COLUMN                           = 43;\\n    public static final int COMMIT                           = 44;\\n    public static final int COMPARABLE                       = 45;\\n    public static final int CONDITION                        = 46;\\n    public static final int CONNECT                          = 47;\\n    public static final int CONSTRAINT                       = 48;\\n    public static final int CONVERT                          = 49;\\n    public static final int CORR                             = 50;\\n    public static final int CORRESPONDING                    = 51;\\n    public static final int COUNT                            = 52;\\n    public static final int COVAR_POP                        = 53;\\n    public static final int COVAR_SAMP                       = 54;\\n    public static final int CREATE                           = 55;\\n    public static final int CROSS                            = 56;\\n    public static final int CUBE                             = 57;\\n    public static final int CUME_DIST                        = 58;\\n    public static final int CURRENT                          = 59;\\n    public static final int CURRENT_CATALOG                  = 60;\\n    public static final int CURRENT_DATE                     = 61;\\n    public static final int CURRENT_DEFAULT_TRANSFORM_GROUP  = 62;\\n    public static final int CURRENT_PATH                     = 63;\\n    public static final int CURRENT_ROLE                     = 64;\\n    public static final int CURRENT_SCHEMA                   = 65;\\n    public static final int CURRENT_TIME                     = 66;\\n    public static final int CURRENT_TIMESTAMP                = 67;\\n    public static final int CURRENT_TRANSFORM_GROUP_FOR_TYPE = 68;\\n    public static final int CURRENT_USER                     = 69;\\n    public static final int CURSOR                           = 70;\\n    public static final int CYCLE                            = 71;\\n    public static final int DATE                             = 72;\\n    public static final int DAY                              = 73;\\n    public static final int DEALLOCATE                       = 74;\\n    public static final int DEC                              = 75;\\n    public static final int DECIMAL                          = 76;\\n    public static final int DECLARE                          = 77;\\n    public static final int DEFAULT                          = 78;\\n    public static final int DELETE                           = 79;\\n    public static final int DENSE_RANK                       = 80;\\n    public static final int DEREF                            = 81;\\n    public static final int DESCRIBE                         = 82;\\n    public static final int DETERMINISTIC                    = 83;\\n    public static final int DISCONNECT                       = 84;\\n    public static final int DISTINCT                         = 85;\\n    public static final int DO                               = 86;\\n    public static final int DOUBLE                           = 87;\\n    public static final int DROP                             = 88;\\n    public static final int DYNAMIC                          = 89;\\n    public static final int EACH                             = 90;\\n    public static final int ELEMENT                          = 91;\\n    public static final int ELSE                             = 92;\\n    public static final int ELSEIF                           = 93;\\n    public static final int END                              = 94;\\n    public static final int END_EXEC                         = 95;\\n    public static final int ESCAPE                           = 96;\\n    public static final int EVERY                            = 97;\\n    public static final int EXCEPT                           = 98;\\n    public static final int EXEC                             = 99;\\n    public static final int EXECUTE                          = 100;\\n    public static final int EXISTS                           = 101;\\n    public static final int EXIT                             = 102;\\n    public static final int EXP                              = 103;\\n    public static final int EXTERNAL                         = 104;\\n    public static final int EXTRACT                          = 105;\\n    public static final int FALSE                            = 106;\\n    public static final int FETCH                            = 107;\\n    public static final int FILTER                           = 108;\\n    public static final int FIRST_VALUE                      = 109;\\n    public static final int FLOAT                            = 110;\\n    public static final int FLOOR                            = 111;\\n    public static final int FOR                              = 112;\\n    public static final int FOREIGN                          = 113;\\n    public static final int FREE                             = 114;\\n    public static final int FROM                             = 115;\\n    public static final int FULL                             = 116;\\n    public static final int FUNCTION                         = 117;\\n    public static final int FUSION                           = 118;\\n    public static final int GET                              = 119;\\n    public static final int GLOBAL                           = 120;\\n    public static final int GRANT                            = 121;\\n    public static final int GROUP                            = 122;\\n    public static final int GROUPING                         = 123;\\n    public static final int HANDLER                          = 124;\\n    public static final int HAVING                           = 125;\\n    public static final int HOLD                             = 126;\\n    public static final int HOUR                             = 127;\\n    public static final int IDENTITY                         = 128;\\n    public static final int IMPORT                           = 129;\\n    public static final int IN                               = 130;\\n    public static final int INDICATOR                        = 131;\\n    public static final int INNER                            = 132;\\n    public static final int INOUT                            = 133;\\n    public static final int INSENSITIVE                      = 134;\\n    public static final int INSERT                           = 135;\\n    public static final int INT                              = 136;\\n    public static final int INTEGER                          = 137;\\n    public static final int INTERSECT                        = 138;\\n    public static final int INTERSECTION                     = 139;\\n    public static final int INTERVAL                         = 140;\\n    public static final int INTO                             = 141;\\n    public static final int IS                               = 142;\\n    public static final int ITERATE                          = 143;\\n    public static final int JOIN                             = 144;\\n    public static final int LAG                              = 145;\\n    public static final int LANGUAGE                         = 146;\\n    public static final int LARGE                            = 147;\\n    public static final int LAST_VALUE                       = 148;\\n    public static final int LATERAL                          = 149;\\n    public static final int LEAD                             = 150;\\n    public static final int LEADING                          = 151;\\n    public static final int LEAVE                            = 152;\\n    public static final int LEFT                             = 153;\\n    public static final int LIKE                             = 154;\\n    public static final int LIKE_REGEX                       = 155;\\n    public static final int LN                               = 156;\\n    public static final int LOCAL                            = 157;\\n    public static final int LOCALTIME                        = 158;\\n    public static final int LOCALTIMESTAMP                   = 159;\\n    public static final int LOOP                             = 160;\\n    public static final int LOWER                            = 161;\\n    public static final int MATCH                            = 162;\\n    public static final int MAX                              = 163;\\n    public static final int MAX_CARDINALITY                  = 164;\\n    public static final int MEMBER                           = 165;\\n    public static final int MERGE                            = 166;\\n    public static final int METHOD                           = 167;\\n    public static final int MIN                              = 168;\\n    public static final int MINUTE                           = 169;\\n    public static final int MOD                              = 170;\\n    public static final int MODIFIES                         = 171;\\n    public static final int MODULE                           = 172;\\n    public static final int MONTH                            = 173;\\n    public static final int MULTISET                         = 174;\\n    public static final int NATIONAL                         = 175;\\n    public static final int NATURAL                          = 176;\\n    public static final int NCHAR                            = 177;\\n    public static final int NCLOB                            = 178;\\n    public static final int NEW                              = 179;\\n    public static final int NO                               = 180;\\n    public static final int NONE                             = 181;\\n    public static final int NORMALIZE                        = 182;\\n    public static final int NOT                              = 183;\\n    public static final int NTH_VALUE                        = 184;\\n    public static final int NTILE                            = 185;\\n    public static final int NULL                             = 186;\\n    public static final int NULLIF                           = 187;\\n    public static final int NUMERIC                          = 188;\\n    public static final int OCCURRENCES_REGEX                = 189;\\n    public static final int OCTET_LENGTH                     = 190;\\n    public static final int OF                               = 191;\\n    public static final int OFFSET                           = 192;\\n    public static final int OLD                              = 193;\\n    public static final int ON                               = 194;\\n    public static final int ONLY                             = 195;\\n    public static final int OPEN                             = 196;\\n    public static final int OR                               = 197;\\n    public static final int ORDER                            = 198;\\n    public static final int OUT                              = 199;\\n    public static final int OUTER                            = 200;\\n    public static final int OVER                             = 201;\\n    public static final int OVERLAPS                         = 202;\\n    public static final int OVERLAY                          = 203;\\n    public static final int PARAMETER                        = 204;\\n    public static final int PARTITION                        = 205;\\n    public static final int PERCENT_RANK                     = 206;\\n    public static final int PERCENTILE_CONT                  = 207;\\n    public static final int PERCENTILE_DISC                  = 208;\\n    public static final int POSITION                         = 209;\\n    public static final int POSITION_REGEX                   = 210;\\n    public static final int POWER                            = 211;\\n    public static final int PRECISION                        = 212;\\n    public static final int PREPARE                          = 213;\\n    public static final int PRIMARY                          = 214;\\n    public static final int PROCEDURE                        = 215;\\n    public static final int RANGE                            = 216;\\n    public static final int RANK                             = 217;\\n    public static final int READS                            = 218;\\n    public static final int REAL                             = 219;\\n    public static final int RECURSIVE                        = 220;\\n    public static final int REF                              = 221;\\n    public static final int REFERENCES                       = 222;\\n    public static final int REFERENCING                      = 223;\\n    public static final int REGR_AVGX                        = 224;\\n    public static final int REGR_AVGY                        = 225;\\n    public static final int REGR_COUNT                       = 226;\\n    public static final int REGR_INTERCEPT                   = 227;\\n    public static final int REGR_R2                          = 228;\\n    public static final int REGR_SLOPE                       = 229;\\n    public static final int REGR_SXX                         = 230;\\n    public static final int REGR_SXY                         = 231;\\n    public static final int REGR_SYY                         = 232;\\n    public static final int RELEASE                          = 233;\\n    public static final int REPEAT                           = 234;\\n    public static final int RESIGNAL                         = 235;\\n    public static final int RESULT                           = 236;\\n    public static final int RETURN                           = 237;\\n    public static final int RETURNS                          = 238;\\n    public static final int REVOKE                           = 239;\\n    public static final int RIGHT                            = 240;\\n    public static final int ROLLBACK                         = 241;\\n    public static final int ROLLUP                           = 242;\\n    public static final int ROW                              = 243;\\n    public static final int ROW_NUMBER                       = 244;\\n    public static final int ROWS                             = 245;\\n    public static final int SAVEPOINT                        = 246;\\n    public static final int SCOPE                            = 247;\\n    public static final int SCROLL                           = 248;\\n    public static final int SEARCH                           = 249;\\n    public static final int SECOND                           = 250;\\n    public static final int SELECT                           = 251;\\n    public static final int SENSITIVE                        = 252;\\n    public static final int SESSION_USER                     = 253;\\n    public static final int SET                              = 254;\\n    public static final int SIGNAL                           = 255;\\n    public static final int SIMILAR                          = 256;\\n    public static final int SMALLINT                         = 257;\\n    public static final int SOME                             = 258;\\n    public static final int SPECIFIC                         = 259;\\n    public static final int SPECIFICTYPE                     = 260;\\n    public static final int SQL                              = 261;\\n    public static final int SQLEXCEPTION                     = 262;\\n    public static final int SQLSTATE                         = 263;\\n    public static final int SQLWARNING                       = 264;\\n    public static final int SQRT                             = 265;\\n    public static final int STACKED                          = 266;\\n    public static final int START                            = 267;\\n    public static final int STATIC                           = 268;\\n    public static final int STDDEV_POP                       = 269;\\n    public static final int STDDEV_SAMP                      = 270;\\n    public static final int SUBMULTISET                      = 271;\\n    public static final int SUBSTRING                        = 272;\\n    public static final int SUBSTRING_REGEX                  = 273;\\n    public static final int SUM                              = 274;\\n    public static final int SYMMETRIC                        = 275;\\n    public static final int SYSTEM                           = 276;\\n    public static final int SYSTEM_USER                      = 277;\\n    public static final int TABLE                            = 278;\\n    public static final int TABLESAMPLE                      = 279;\\n    public static final int THEN                             = 280;\\n    public static final int TIME                             = 281;\\n    public static final int TIMESTAMP                        = 282;\\n    public static final int TIMEZONE_HOUR                    = 283;\\n    public static final int TIMEZONE_MINUTE                  = 284;\\n    public static final int TO                               = 285;\\n    public static final int TRAILING                         = 286;\\n    public static final int TRANSLATE                        = 287;\\n    public static final int TRANSLATE_REGEX                  = 288;\\n    public static final int TRANSLATION                      = 289;\\n    public static final int TREAT                            = 290;\\n    public static final int TRIGGER                          = 291;\\n    public static final int TRIM                             = 292;\\n    public static final int TRIM_ARRAY                       = 293;\\n    public static final int TRUE                             = 294;\\n    public static final int TRUNCATE                         = 295;\\n    public static final int UESCAPE                          = 296;\\n    public static final int UNDO                             = 297;\\n    public static final int UNION                            = 298;\\n    public static final int UNIQUE                           = 299;\\n    public static final int UNKNOWN                          = 300;\\n    public static final int UNNEST                           = 301;\\n    public static final int UNTIL                            = 302;\\n    public static final int UPDATE                           = 303;\\n    public static final int UPPER                            = 304;\\n    public static final int USER                             = 305;\\n    public static final int USING                            = 306;\\n    public static final int VALUE                            = 307;\\n    public static final int VALUES                           = 308;\\n    public static final int VAR_POP                          = 309;\\n    public static final int VAR_SAMP                         = 310;\\n    public static final int VARBINARY                        = 311;\\n    public static final int VARCHAR                          = 312;\\n    public static final int VARYING                          = 313;\\n    public static final int WHEN                             = 314;\\n    public static final int WHENEVER                         = 315;\\n    public static final int WHERE                            = 316;\\n    public static final int WIDTH_BUCKET                     = 317;\\n    public static final int WINDOW                           = 318;\\n    public static final int WITH                             = 319;\\n    public static final int WITHIN                           = 320;\\n    public static final int WITHOUT                          = 321;\\n    public static final int WHILE                            = 322;\\n    public static final int YEAR                             = 323;\\n            public static final int A                           = 330;\\n    public static final int ABSOLUTE                    = 331;\\n    public static final int ACTION                      = 332;\\n    public static final int ADA                         = 333;\\n    public static final int ADD                         = 334;\\n    public static final int ADMIN                       = 335;\\n    public static final int AFTER                       = 336;\\n    public static final int ALWAYS                      = 337;\\n    public static final int ASC                         = 338;\\n    public static final int ASSERTION                   = 339;\\n    public static final int ASSIGNMENT                  = 340;\\n    public static final int ATTRIBUTE                   = 341;\\n    public static final int ATTRIBUTES                  = 342;\\n    public static final int BEFORE                      = 343;\\n    public static final int BERNOULLI                   = 344;\\n    public static final int BREADTH                     = 345;\\n    public static final int C                           = 346;\\n    public static final int CASCADE                     = 347;\\n    public static final int CATALOG                     = 348;\\n    public static final int CATALOG_NAME                = 349;\\n    public static final int CHAIN                       = 350;\\n    public static final int CHARACTER_SET_CATALOG       = 351;\\n    public static final int CHARACTER_SET_NAME          = 352;\\n    public static final int CHARACTER_SET_SCHEMA        = 353;\\n    public static final int CHARACTERISTICS             = 354;\\n    public static final int CHARACTERS                  = 355;\\n    public static final int CLASS_ORIGIN                = 356;\\n    public static final int COBOL                       = 357;\\n    public static final int COLLATION                   = 358;\\n    public static final int COLLATION_CATALOG           = 359;\\n    public static final int COLLATION_NAME              = 360;\\n    public static final int COLLATION_SCHEMA            = 361;\\n    public static final int COLUMN_NAME                 = 362;\\n    public static final int COMMAND_FUNCTION            = 363;\\n    public static final int COMMAND_FUNCTION_CODE       = 364;\\n    public static final int COMMITTED                   = 365;\\n    public static final int CONDITION_IDENTIFIER        = 366;\\n    public static final int CONDITION_NUMBER            = 367;\\n    public static final int CONNECTION                  = 368;\\n    public static final int CONNECTION_NAME             = 369;\\n    public static final int CONSTRAINT_CATALOG          = 370;\\n    public static final int CONSTRAINT_NAME             = 371;\\n    public static final int CONSTRAINT_SCHEMA           = 372;\\n    public static final int CONSTRAINTS                 = 373;\\n    public static final int CONSTRUCTOR                 = 374;\\n    public static final int CONTAINS                    = 375;\\n    public static final int CONTINUE                    = 376;\\n    public static final int CURSOR_NAME                 = 377;\\n    public static final int DATA                        = 378;\\n    public static final int DATETIME_INTERVAL_CODE      = 379;\\n    public static final int DATETIME_INTERVAL_PRECISION = 380;\\n    public static final int DEFAULTS                    = 381;\\n    public static final int DEFERRABLE                  = 382;\\n    public static final int DEFERRED                    = 383;\\n    public static final int DEFINED                     = 384;\\n    public static final int DEFINER                     = 385;\\n    public static final int DEGREE                      = 386;\\n    public static final int DEPTH                       = 387;\\n    public static final int DERIVED                     = 388;\\n    public static final int DESC                        = 389;\\n    public static final int DESCRIPTOR                  = 390;\\n    public static final int DIAGNOSTICS                 = 391;\\n    public static final int DISPATCH                    = 392;\\n    public static final int DOMAIN                      = 393;\\n    public static final int DYNAMIC_FUNCTION            = 394;\\n    public static final int DYNAMIC_FUNCTION_CODE       = 395;\\n    public static final int EQUALS                      = 396;\\n    public static final int EXCEPTION                   = 397;\\n    public static final int EXCLUDE                     = 398;\\n    public static final int EXCLUDING                   = 399;\\n    public static final int FINAL                       = 400;\\n    public static final int FIRST                       = 401;\\n    public static final int FOLLOWING                   = 402;\\n    public static final int FORTRAN                     = 403;\\n    public static final int FOUND                       = 404;\\n    public static final int G                           = 405;\\n    public static final int GENERAL                     = 406;\\n    public static final int GENERATED                   = 407;\\n    public static final int GO                          = 408;\\n    public static final int GOTO                        = 409;\\n    public static final int GRANTED                     = 410;\\n    public static final int HIERARCHY                   = 411;\\n    public static final int IF                          = 412;\\n    public static final int IGNORE                      = 413;\\n    public static final int IMMEDIATE                   = 414;\\n    public static final int IMPLEMENTATION              = 415;\\n    public static final int INCLUDING                   = 416;\\n    public static final int INCREMENT                   = 417;\\n    public static final int INITIALLY                   = 418;\\n    public static final int INPUT                       = 419;\\n    public static final int INSTANCE                    = 420;\\n    public static final int INSTANTIABLE                = 421;\\n    public static final int INSTEAD                     = 422;\\n    public static final int INVOKER                     = 423;\\n    public static final int ISOLATION                   = 424;\\n    public static final int JAVA                        = 425;\\n    public static final int K                           = 426;\\n    public static final int KEY                         = 427;\\n    public static final int KEY_MEMBER                  = 428;\\n    public static final int KEY_TYPE                    = 429;\\n    public static final int LAST                        = 430;\\n    public static final int LENGTH                      = 431;\\n    public static final int LEVEL                       = 432;\\n    public static final int LIBRARY                     = 433;\\n    public static final int LOCATOR                     = 434;\\n    public static final int M                           = 435;\\n    public static final int MAP                         = 436;\\n    public static final int MATCHED                     = 437;\\n    public static final int MAXVALUE                    = 438;\\n    public static final int MESSAGE_LENGTH              = 439;\\n    public static final int MESSAGE_OCTET_LENGTH        = 440;\\n    public static final int MESSAGE_TEXT                = 441;\\n    public static final int MINVALUE                    = 442;\\n    public static final int MORE                        = 443;\\n    public static final int MUMPS                       = 444;\\n    public static final int NAME                        = 445;\\n    public static final int NAMES                       = 446;\\n    public static final int NESTING                     = 447;\\n    public static final int NEXT                        = 448;\\n    public static final int NORMALIZED                  = 449;\\n    public static final int NULLABLE                    = 450;\\n    public static final int NULLS                       = 451;\\n    public static final int NUMBER                      = 452;\\n    public static final int OBJECT                      = 453;\\n    public static final int OCTETS                      = 454;\\n    public static final int OPTION                      = 455;\\n    public static final int OPTIONS                     = 456;\\n    public static final int ORDERING                    = 457;\\n    public static final int ORDINALITY                  = 458;\\n    public static final int OTHERS                      = 459;\\n    public static final int OUTPUT                      = 460;\\n    public static final int OVERRIDING                  = 461;\\n    public static final int P                           = 462;\\n    public static final int PAD                         = 463;\\n    public static final int PARAMETER_MODE              = 464;\\n    public static final int PARAMETER_NAME              = 465;\\n    public static final int PARAMETER_ORDINAL_POSITION  = 466;\\n    public static final int PARAMETER_SPECIFIC_CATALOG  = 467;\\n    public static final int PARAMETER_SPECIFIC_NAME     = 468;\\n    public static final int PARAMETER_SPECIFIC_SCHEMA   = 469;\\n    public static final int PARTIAL                     = 470;\\n    public static final int PASCAL                      = 471;\\n    public static final int PATH                        = 472;\\n    public static final int PLACING                     = 473;\\n    public static final int PLI                         = 474;\\n    public static final int PRECEDING                   = 475;\\n    public static final int PRESERVE                    = 476;\\n    public static final int PRIOR                       = 477;\\n    public static final int PRIVILEGES                  = 478;\\n    public static final int PUBLIC                      = 479;\\n    public static final int READ                        = 480;\\n    public static final int RELATIVE                    = 481;\\n    public static final int REPEATABLE                  = 482;\\n    public static final int RESPECT                     = 483;\\n    public static final int RESTART                     = 484;\\n    public static final int RESTRICT                    = 485;\\n    public static final int RETURNED_CARDINALITY        = 486;\\n    public static final int RETURNED_LENGTH             = 487;\\n    public static final int RETURNED_OCTET_LENGTH       = 488;\\n    public static final int RETURNED_SQLSTATE           = 489;\\n    public static final int ROLE                        = 490;\\n    public static final int ROUTINE                     = 491;\\n    public static final int ROUTINE_CATALOG             = 492;\\n    public static final int ROUTINE_NAME                = 493;\\n    public static final int ROUTINE_SCHEMA              = 494;\\n    public static final int ROW_COUNT                   = 495;\\n    public static final int SCALE                       = 496;\\n    public static final int SCHEMA                      = 497;\\n    public static final int SCHEMA_NAME                 = 498;\\n    public static final int SCOPE_CATALOG               = 499;\\n    public static final int SCOPE_NAME                  = 500;\\n    public static final int SCOPE_SCHEMA                = 501;\\n    public static final int SECTION                     = 502;\\n    public static final int SECURITY                    = 503;\\n    public static final int SELF                        = 504;\\n    public static final int SEQUENCE                    = 505;\\n    public static final int SERIALIZABLE                = 506;\\n    public static final int SERVER_NAME                 = 507;\\n    public static final int SESSION                     = 508;\\n    public static final int SERVER                      = 509;\\n    public static final int SETS                        = 510;\\n    public static final int SIMPLE                      = 511;\\n    public static final int SIZE                        = 512;\\n    public static final int SOURCE                      = 513;\\n    public static final int SPACE                       = 514;\\n    public static final int SPECIFIC_NAME               = 515;\\n    public static final int STATE                       = 516;\\n    public static final int STATEMENT                   = 517;\\n    public static final int STRUCTURE                   = 518;\\n    public static final int STYLE                       = 519;\\n    public static final int SUBCLASS_ORIGIN             = 520;\\n    public static final int T                           = 521;\\n    public static final int TABLE_NAME                  = 522;\\n    public static final int TEMPORARY                   = 523;\\n    public static final int TIES                        = 524;\\n    public static final int TOP_LEVEL_COUNT             = 525;\\n    public static final int TRANSACTION                 = 526;\\n    public static final int TRANSACTION_ACTIVE          = 527;\\n    public static final int TRANSACTIONS_COMMITTED      = 528;\\n    public static final int TRANSACTIONS_ROLLED_BACK    = 529;\\n    public static final int TRANSFORM                   = 530;\\n    public static final int TRANSFORMS                  = 531;\\n    public static final int TRIGGER_CATALOG             = 532;\\n    public static final int TRIGGER_NAME                = 533;\\n    public static final int TRIGGER_SCHEMA              = 534;\\n    public static final int TYPE                        = 535;\\n    public static final int UNBOUNDED                   = 536;\\n    public static final int UNCOMMITTED                 = 537;\\n    public static final int UNDER                       = 538;\\n    public static final int UNNAMED                     = 539;\\n    public static final int USAGE                       = 540;\\n    public static final int USER_DEFINED_TYPE_CATALOG   = 541;\\n    public static final int USER_DEFINED_TYPE_CODE      = 542;\\n    public static final int USER_DEFINED_TYPE_NAME      = 543;\\n    public static final int USER_DEFINED_TYPE_SCHEMA    = 544;\\n    public static final int VIEW                        = 545;\\n    public static final int WORK                        = 546;\\n    public static final int WRITE                       = 547;\\n    public static final int WRAPPER                     = 548;\\n    public static final int ZONE                        = 549;\\n        static final int ALIAS          = 558;\\n    static final int AGGREGATE      = 559;\\n    static final int AUTOCOMMIT     = 560;\\n    static final int AUTHENTICATION = 561;\\n    static final int BACKUP         = 562;\\n    static final int BINARY_FLOAT   = 563;\\n    static final int BINARY_DOUBLE  = 564;\\n    static final int BIT            = 565;\\n    static final int BLOCKING       = 566;\\n    static final int BODY           = 567;\\n    static final int BYTE           = 568;\\n    static final int CACHE          = 569;\\n    static final int CACHED         = 570;\\n    static final int CASEWHEN       = 571;\\n    static final int CHECKPOINT     = 572;\\n    static final int CLASS          = 573;\\n    static final int CLUSTERED      = 574;\\n    static final int COMMENT        = 575;\\n    static final int COMPACT        = 576;\\n    static final int COMPRESSED     = 577;\\n    static final int CONTROL        = 578;\\n    static final int CURRVAL        = 579;\\n    static final int DATABASE       = 580;\\n    static final int DEADLOCK       = 581;\\n    static final int DEFRAG         = 582;\\n    static final int DELAY          = 583;\\n    static final int DIGEST         = 584;\\n    static final int EVENT          = 585;\\n    static final int EXPLAIN        = 586;\\n    static final int FILE           = 587;\\n    static final int FILES          = 588;\\n    static final int FORMAT         = 589;\\n    static final int GC             = 590;\\n    static final int HEADER         = 591;\\n    static final int IGNORECASE     = 592;\\n    static final int IMMEDIATELY    = 593;\\n    static final int INTEGRITY      = 594;\\n    static final int INDEX          = 595;\\n    static final int INITIAL        = 596;\\n    static final int LASTVAL        = 597;\\n    static final int LIMIT          = 598;\\n    static final int LOCK           = 599;\\n    static final int LOCKS          = 600;\\n    static final int LONG           = 601;\\n    static final int LONGVAR        = 602;\\n    static final int MAXROWS        = 603;\\n    static final int MEDIAN         = 604;\\n    static final int MEMORY         = 605;\\n    static final int MILLIS         = 606;\\n    static final int MINUS_EXCEPT   = 607;\\n    static final int NAN            = 608;\\n    static final int NEXTVAL        = 609;\\n    static final int OFF            = 610;\\n    static final int PASSWORD       = 611;\\n    static final int PLAN           = 612;\\n    static final int PROPERTY       = 613;\\n    static final int RAW            = 614;\\n    static final int READONLY       = 615;\\n    static final int REFERENTIAL    = 616;\\n    static final int RENAME         = 617;\\n    static final int RESET          = 618;\\n    static final int SCRIPT         = 619;\\n    static final int SEPARATOR      = 620;\\n    static final int SHUTDOWN       = 621;\\n    static final int SYNTAX         = 622;\\n    static final int TDC            = 623;\\n    static final int TEMP           = 624;\\n    static final int TEXT           = 625;\\n    static final int TTI            = 626;\\n    static final int TYPES          = 627;\\n    static final int VARCHAR2       = 628;\\n    static final int WRITE_DELAY    = 629;\\n        static final int        ACOS                       = 630;\\n    static final int        ACTION_ID                  = 631;\\n    static final int        ARRAY_SORT                 = 632;\\n    static final int        ASCII                      = 633;\\n    static final int        ASIN                       = 634;\\n    static final int        ATAN                       = 635;\\n    static final int        ATAN2                      = 636;\\n    static final int        BIT_LENGTH                 = 637;\\n    static final int        BITAND                     = 638;\\n    static final int        BITLENGTH                  = 639;\\n    static final int        BITOR                      = 640;\\n    static final int        BITXOR                     = 641;\\n    static final int        CHR                        = 642;\\n    static final int        CONCAT_WORD                = 643;\\n    static final int        COS                        = 644;\\n    static final int        COT                        = 645;\\n    static final int        CRYPT_KEY                  = 646;\\n    static final int        CURDATE                    = 647;\\n    static final int        CURTIME                    = 648;\\n    static final int        DATABASE_ISOLATION_LEVEL   = 649;\\n    static final int        DATABASE_NAME              = 650;\\n    static final int        DATABASE_TIMEZONE          = 651;\\n    static final int        DATABASE_VERSION           = 652;\\n    static final int        DATEADD                    = 653;\\n    static final int        DATEDIFF                   = 654;\\n    public static final int DAY_NAME                   = 655;\\n    public static final int DAY_OF_MONTH               = 656;\\n    public static final int DAY_OF_WEEK                = 657;\\n    public static final int DAY_OF_YEAR                = 658;\\n    static final int        DAYNAME                    = 659;\\n    static final int        DAYOFMONTH                 = 660;\\n    static final int        DAYOFWEEK                  = 661;\\n    static final int        DAYOFYEAR                  = 662;\\n    static final int        DECODE                     = 663;\\n    static final int        DEGREES                    = 664;\\n    static final int        DIFFERENCE                 = 665;\\n    static final int        DMOD                       = 666;\\n    static final int        HEXTORAW                   = 667;\\n    static final int        GREATEST                   = 668;\\n    static final int        GROUP_CONCAT               = 669;\\n    static final int        IFNULL                     = 670;\\n    static final int        IS_AUTOCOMMIT              = 671;\\n    static final int        IS_READONLY_DATABASE       = 672;\\n    static final int        IS_READONLY_DATABASE_FILES = 673;\\n    static final int        IS_READONLY_SESSION        = 674;\\n    static final int        ISOLATION_LEVEL            = 675;\\n    static final int        ISNULL                     = 676;\\n    static final int        LCASE                      = 677;\\n    static final int        LEAST                      = 678;\\n    static final int        LOAD_FILE                  = 679;\\n    static final int        LOCATE                     = 680;\\n    static final int        LOB                        = 681;\\n    static final int        LOG                        = 682;\\n    static final int        LOG10                      = 683;\\n    static final int        LPAD                       = 684;\\n    static final int        LTRIM                      = 685;\\n    static final int        LOB_ID                     = 686;\\n    public static final int MONTH_NAME                 = 687;\\n    static final int        MONTHNAME                  = 688;\\n    static final int        MVCC                       = 689;\\n    static final int        MVLOCKS                    = 690;\\n    static final int        NIO                        = 691;\\n    static final int        NOW                        = 692;\\n    static final int        OCTETLENGTH                = 693;\\n    static final int        PI                         = 694;\\n    public static final int QUARTER                    = 695;\\n    static final int        RADIANS                    = 696;\\n    static final int        RAND                       = 697;\\n    static final int        RAWTOHEX                   = 698;\\n    static final int        REGEXP_MATCHES             = 699;\\n    static final int        REPLACE                    = 700;\\n    static final int        REVERSE                    = 701;\\n    static final int        ROUND                      = 702;\\n    static final int        ROUNDMAGIC                 = 703;\\n    static final int        RTRIM                      = 704;\\n    static final int        RPAD                       = 705;\\n    public static final int SECONDS_MIDNIGHT           = 706;\\n    static final int        SEQUENCE_ARRAY             = 707;\\n    static final int        SESSION_ID                 = 708;\\n    static final int        SESSION_ISOLATION_LEVEL    = 709;\\n    static final int        SESSION_TIMEZONE           = 710;\\n    static final int        SIGN                       = 711;\\n    static final int        SIN                        = 712;\\n    static final int        SOUNDEX                    = 713;\\n    static final int        SPACE_WORD                 = 714;\\n    static final int        SUBSTR                     = 715;\\n    static final int        SYSDATE                    = 716;\\n    static final int        TAN                        = 717;\\n    static final int        TIMESTAMPADD               = 718;\\n    static final int        TIMESTAMPDIFF              = 719;\\n    static final int        TIMEZONE                   = 720;\\n    static final int        TO_CHAR                    = 721;\\n    static final int        TO_DATE                    = 722;\\n    static final int        TO_TIMESTAMP               = 723;\\n    static final int        TODAY                      = 724;\\n    static final int        TOP                        = 725;\\n    static final int        TRANSACTION_CONTROL        = 726;\\n    static final int        TRANSACTION_ID             = 727;\\n    static final int        TRANSACTION_SIZE           = 728;\\n    static final int        TRUNC                      = 729;\\n    static final int        UCASE                      = 730;\\n    static final int        UNIX_TIMESTAMP             = 731;\\n    static final int        UUID                       = 732;\\n    static final int        WEEK                       = 733;\\n    public static final int WEEK_OF_YEAR               = 734;\\n        static final int        ASTERISK         = 771;\\n    static final int        CLOSEBRACKET     = 772;\\n    static final int        COLON            = 773;\\n    static final int        COMMA            = 774;\\n    static final int        CONCAT           = 775;\\n    static final int        DIVIDE           = 776;\\n    static final int        DOUBLE_COLON_OP  = 777;\\n    static final int        DOUBLE_PERIOD_OP = 778;\\n    static final int        GREATER          = 779;\\n    static final int        GREATER_EQUALS   = 780;\\n    static final int        LEFTBRACKET      = 781;\\n    static final int        LESS             = 782;\\n    static final int        LESS_EQUALS      = 783;\\n    public static final int MINUS            = 784;\\n    static final int        NOT_EQUALS       = 785;\\n    static final int        OPENBRACKET      = 786;\\n    static final int        PLUS             = 787;\\n    static final int        QUESTION         = 788;\\n    static final int        RIGHT_ARROW_OP   = 789;\\n    static final int        RIGHTBRACKET     = 790;\\n    static final int        SEMICOLON        = 791;\\n        public static final int SQL_BIGINT        = 801;\\n    public static final int SQL_BINARY        = 802;\\n    public static final int SQL_BIT           = 803;\\n    public static final int SQL_BLOB          = 804;\\n    public static final int SQL_BOOLEAN       = 805;\\n    public static final int SQL_CHAR          = 806;\\n    public static final int SQL_CLOB          = 807;\\n    public static final int SQL_DATE          = 808;\\n    public static final int SQL_DECIMAL       = 809;\\n    public static final int SQL_DATALINK      = 810;\\n    public static final int SQL_DOUBLE        = 811;\\n    public static final int SQL_FLOAT         = 812;\\n    public static final int SQL_INTEGER       = 813;\\n    public static final int SQL_LONGVARBINARY = 814;\\n    public static final int SQL_LONGNVARCHAR  = 815;\\n    public static final int SQL_LONGVARCHAR   = 816;\\n    public static final int SQL_NCHAR         = 817;\\n    public static final int SQL_NCLOB         = 818;\\n    public static final int SQL_NUMERIC       = 819;\\n    public static final int SQL_NVARCHAR      = 820;\\n    public static final int SQL_REAL          = 821;\\n    public static final int SQL_ROWID         = 822;\\n    public static final int SQL_SQLXML        = 823;\\n    public static final int SQL_SMALLINT      = 824;\\n    public static final int SQL_TIME          = 825;\\n    public static final int SQL_TIMESTAMP     = 826;\\n    public static final int SQL_TINYINT       = 827;\\n    public static final int SQL_VARBINARY     = 828;\\n    public static final int SQL_VARCHAR       = 829;\\n        static final int SQL_TSI_FRAC_SECOND  = 831;\\n    static final int SQL_TSI_MILLI_SECOND = 832;\\n    static final int SQL_TSI_SECOND       = 833;\\n    static final int SQL_TSI_MINUTE       = 834;\\n    static final int SQL_TSI_HOUR         = 835;\\n    static final int SQL_TSI_DAY          = 836;\\n    static final int SQL_TSI_WEEK         = 837;\\n    static final int SQL_TSI_MONTH        = 838;\\n    static final int SQL_TSI_QUARTER      = 839;\\n    static final int SQL_TSI_YEAR         = 840;\\n        static final int X_KEYSET      = 841;\\n    static final int X_OPTION      = 842;\\n    static final int X_REPEAT      = 843;\\n    static final int X_POS_INTEGER = 844;\\n        public static final int X_VALUE                    = 845;\\n    public static final int X_IDENTIFIER               = 846;\\n    public static final int X_DELIMITED_IDENTIFIER     = 847;\\n    public static final int X_ENDPARSE                 = 848;\\n    public static final int X_STARTPARSE               = 849;\\n    public static final int X_REMARK                   = 850;\\n    public static final int X_NULL                     = 851;\\n    public static final int X_LOB_SIZE                 = 852;\\n    public static final int X_MALFORMED_STRING         = 853;\\n    public static final int X_MALFORMED_NUMERIC        = 854;\\n    public static final int X_MALFORMED_BIT_STRING     = 855;\\n    public static final int X_MALFORMED_BINARY_STRING  = 856;\\n    public static final int X_MALFORMED_UNICODE_STRING = 857;\\n    public static final int X_MALFORMED_COMMENT        = 858;\\n    public static final int X_MALFORMED_IDENTIFIER     = 859;\\n    public static final int X_MALFORMED_UNICODE_ESCAPE = 860;\\n        public static final int X_UNKNOWN_TOKEN = -1;\\n    private static final IntValueHashMap reservedKeys =\\n        new IntValueHashMap(351);\\n    static {\\n        reservedKeys.put(Tokens.T_ABS, ABS);\\n        reservedKeys.put(Tokens.T_AGGREGATE, AGGREGATE);\\n        reservedKeys.put(Tokens.T_ALL, ALL);\\n        reservedKeys.put(Tokens.T_ALLOCATE, ALLOCATE);\\n        reservedKeys.put(Tokens.T_ALTER, ALTER);\\n        reservedKeys.put(Tokens.T_AND, AND);\\n        reservedKeys.put(Tokens.T_ANY, ANY);\\n        reservedKeys.put(Tokens.T_ARE, ARE);\\n        reservedKeys.put(Tokens.T_ARRAY, ARRAY);\\n        reservedKeys.put(Tokens.T_ARRAY_AGG, ARRAY_AGG);\\n        reservedKeys.put(Tokens.T_AS, AS);\\n        reservedKeys.put(Tokens.T_ASENSITIVE, ASENSITIVE);\\n        reservedKeys.put(Tokens.T_ASYMMETRIC, ASYMMETRIC);\\n        reservedKeys.put(Tokens.T_AT, AT);\\n        reservedKeys.put(Tokens.T_ATOMIC, ATOMIC);\\n        reservedKeys.put(Tokens.T_AUTHORIZATION, AUTHORIZATION);\\n        reservedKeys.put(Tokens.T_AVG, AVG);\\n        reservedKeys.put(Tokens.T_BEGIN, BEGIN);\\n        reservedKeys.put(Tokens.T_BETWEEN, BETWEEN);\\n        reservedKeys.put(Tokens.T_BIGINT, BIGINT);\\n        reservedKeys.put(Tokens.T_BINARY, BINARY);\\n        reservedKeys.put(Tokens.T_BIT_LENGTH, BIT_LENGTH);\\n        reservedKeys.put(Tokens.T_BLOB, BLOB);\\n        reservedKeys.put(Tokens.T_BOOLEAN, BOOLEAN);\\n        reservedKeys.put(Tokens.T_BOTH, BOTH);\\n        reservedKeys.put(Tokens.T_BY, BY);\\n        reservedKeys.put(Tokens.T_CALL, CALL);\\n        reservedKeys.put(Tokens.T_CALLED, CALLED);\\n        reservedKeys.put(Tokens.T_CARDINALITY, CARDINALITY);\\n        reservedKeys.put(Tokens.T_CASCADED, CASCADED);\\n        reservedKeys.put(Tokens.T_CASE, CASE);\\n        reservedKeys.put(Tokens.T_CAST, CAST);\\n        reservedKeys.put(Tokens.T_CEIL, CEIL);\\n        reservedKeys.put(Tokens.T_CEILING, CEILING);\\n        reservedKeys.put(Tokens.T_CHAR, CHAR);\\n        reservedKeys.put(Tokens.T_CHAR_LENGTH, CHAR_LENGTH);\\n        reservedKeys.put(Tokens.T_CHARACTER, CHARACTER);\\n        reservedKeys.put(Tokens.T_CHARACTER_LENGTH, CHARACTER_LENGTH);\\n        reservedKeys.put(Tokens.T_CHECK, CHECK);\\n        reservedKeys.put(Tokens.T_CLOB, CLOB);\\n        reservedKeys.put(Tokens.T_CLOSE, CLOSE);\\n        reservedKeys.put(Tokens.T_COALESCE, COALESCE);\\n        reservedKeys.put(Tokens.T_COLLATE, COLLATE);\\n        reservedKeys.put(Tokens.T_COLLECT, COLLECT);\\n        reservedKeys.put(Tokens.T_COLUMN, COLUMN);\\n        reservedKeys.put(Tokens.T_COMMIT, COMMIT);\\n        reservedKeys.put(Tokens.T_COMPARABLE, COMPARABLE);\\n        reservedKeys.put(Tokens.T_CONDITION, CONDITION);\\n        reservedKeys.put(Tokens.T_CONNECT, CONNECT);\\n        reservedKeys.put(Tokens.T_CONSTRAINT, CONSTRAINT);\\n        reservedKeys.put(Tokens.T_CONVERT, CONVERT);\\n        reservedKeys.put(Tokens.T_CORR, CORR);\\n        reservedKeys.put(Tokens.T_CORRESPONDING, CORRESPONDING);\\n        reservedKeys.put(Tokens.T_COUNT, COUNT);\\n        reservedKeys.put(Tokens.T_COVAR_POP, COVAR_POP);\\n        reservedKeys.put(Tokens.T_COVAR_SAMP, COVAR_SAMP);\\n        reservedKeys.put(Tokens.T_CREATE, CREATE);\\n        reservedKeys.put(Tokens.T_CROSS, CROSS);\\n        reservedKeys.put(Tokens.T_CUBE, CUBE);\\n        reservedKeys.put(Tokens.T_CUME_DIST, CUME_DIST);\\n        reservedKeys.put(Tokens.T_CURRENT, CURRENT);\\n        reservedKeys.put(Tokens.T_CURRENT_CATALOG, CURRENT_CATALOG);\\n        reservedKeys.put(Tokens.T_CURRENT_DATE, CURRENT_DATE);\\n        reservedKeys.put(Tokens.T_CURRENT_DEFAULT_TRANSFORM_GROUP,\\n                         CURRENT_DEFAULT_TRANSFORM_GROUP);\\n        reservedKeys.put(Tokens.T_CURRENT_PATH, CURRENT_PATH);\\n        reservedKeys.put(Tokens.T_CURRENT_ROLE, CURRENT_ROLE);\\n        reservedKeys.put(Tokens.T_CURRENT_SCHEMA, CURRENT_SCHEMA);\\n        reservedKeys.put(Tokens.T_CURRENT_TIME, CURRENT_TIME);\\n        reservedKeys.put(Tokens.T_CURRENT_TIMESTAMP, CURRENT_TIMESTAMP);\\n        reservedKeys.put(Tokens.T_DO, DO);\\n        reservedKeys.put(Tokens.T_CURRENT_TRANSFORM_GROUP_FOR_TYPE,\\n                         CURRENT_TRANSFORM_GROUP_FOR_TYPE);\\n        reservedKeys.put(Tokens.T_CURRENT_USER, CURRENT_USER);\\n        reservedKeys.put(Tokens.T_CURSOR, CURSOR);\\n        reservedKeys.put(Tokens.T_CYCLE, CYCLE);\\n        reservedKeys.put(Tokens.T_DATE, DATE);\\n        reservedKeys.put(Tokens.T_DAY, DAY);\\n        reservedKeys.put(Tokens.T_DEALLOCATE, DEALLOCATE);\\n        reservedKeys.put(Tokens.T_DEC, DEC);\\n        reservedKeys.put(Tokens.T_DECIMAL, DECIMAL);\\n        reservedKeys.put(Tokens.T_DECLARE, DECLARE);\\n        reservedKeys.put(Tokens.T_DEFAULT, DEFAULT);\\n        reservedKeys.put(Tokens.T_DELETE, DELETE);\\n        reservedKeys.put(Tokens.T_DENSE_RANK, DENSE_RANK);\\n        reservedKeys.put(Tokens.T_DEREF, DEREF);\\n        reservedKeys.put(Tokens.T_DESCRIBE, DESCRIBE);\\n        reservedKeys.put(Tokens.T_DETERMINISTIC, DETERMINISTIC);\\n        reservedKeys.put(Tokens.T_DISCONNECT, DISCONNECT);\\n        reservedKeys.put(Tokens.T_DISTINCT, DISTINCT);\\n        reservedKeys.put(Tokens.T_DOUBLE, DOUBLE);\\n        reservedKeys.put(Tokens.T_DROP, DROP);\\n        reservedKeys.put(Tokens.T_DYNAMIC, DYNAMIC);\\n        reservedKeys.put(Tokens.T_EACH, EACH);\\n        reservedKeys.put(Tokens.T_ELEMENT, ELEMENT);\\n        reservedKeys.put(Tokens.T_ELSE, ELSE);\\n        reservedKeys.put(Tokens.T_ELSEIF, ELSEIF);\\n        reservedKeys.put(Tokens.T_END, END);\\n        reservedKeys.put(Tokens.T_END_EXEC, END_EXEC);\\n        reservedKeys.put(Tokens.T_ESCAPE, ESCAPE);\\n        reservedKeys.put(Tokens.T_EVERY, EVERY);\\n        reservedKeys.put(Tokens.T_EXCEPT, EXCEPT);\\n        reservedKeys.put(Tokens.T_EXEC, EXEC);\\n        reservedKeys.put(Tokens.T_EXECUTE, EXECUTE);\\n        reservedKeys.put(Tokens.T_EXISTS, EXISTS);\\n        reservedKeys.put(Tokens.T_EXIT, EXIT);\\n        reservedKeys.put(Tokens.T_EXP, EXP);\\n        reservedKeys.put(Tokens.T_EXTERNAL, EXTERNAL);\\n        reservedKeys.put(Tokens.T_EXTRACT, EXTRACT);\\n        reservedKeys.put(Tokens.T_FALSE, FALSE);\\n        reservedKeys.put(Tokens.T_FETCH, FETCH);\\n        reservedKeys.put(Tokens.T_FILTER, FILTER);\\n        reservedKeys.put(Tokens.T_FIRST_VALUE, FIRST_VALUE);\\n        reservedKeys.put(Tokens.T_FLOAT, FLOAT);\\n        reservedKeys.put(Tokens.T_FLOOR, FLOOR);\\n        reservedKeys.put(Tokens.T_FOR, FOR);\\n        reservedKeys.put(Tokens.T_FOREIGN, FOREIGN);\\n        reservedKeys.put(Tokens.T_FREE, FREE);\\n        reservedKeys.put(Tokens.T_FROM, FROM);\\n        reservedKeys.put(Tokens.T_FULL, FULL);\\n        reservedKeys.put(Tokens.T_FUNCTION, FUNCTION);\\n        reservedKeys.put(Tokens.T_FUSION, FUSION);\\n        reservedKeys.put(Tokens.T_GET, GET);\\n        reservedKeys.put(Tokens.T_GLOBAL, GLOBAL);\\n        reservedKeys.put(Tokens.T_GRANT, GRANT);\\n        reservedKeys.put(Tokens.T_GROUP, GROUP);\\n        reservedKeys.put(Tokens.T_GROUPING, GROUPING);\\n        reservedKeys.put(Tokens.T_HANDLER, HANDLER);\\n        reservedKeys.put(Tokens.T_HAVING, HAVING);\\n        reservedKeys.put(Tokens.T_HOLD, HOLD);\\n        reservedKeys.put(Tokens.T_HOUR, HOUR);\\n        reservedKeys.put(Tokens.T_IDENTITY, IDENTITY);\\n        reservedKeys.put(Tokens.T_IF, IF);\\n        reservedKeys.put(Tokens.T_IMPORT, IMPORT);\\n        reservedKeys.put(Tokens.T_IN, IN);\\n        reservedKeys.put(Tokens.T_INDICATOR, INDICATOR);\\n        reservedKeys.put(Tokens.T_INNER, INNER);\\n        reservedKeys.put(Tokens.T_INOUT, INOUT);\\n        reservedKeys.put(Tokens.T_INSENSITIVE, INSENSITIVE);\\n        reservedKeys.put(Tokens.T_INSERT, INSERT);\\n        reservedKeys.put(Tokens.T_INT, INT);\\n        reservedKeys.put(Tokens.T_INTEGER, INTEGER);\\n        reservedKeys.put(Tokens.T_INTERSECT, INTERSECT);\\n        reservedKeys.put(Tokens.T_INTERSECTION, INTERSECTION);\\n        reservedKeys.put(Tokens.T_INTERVAL, INTERVAL);\\n        reservedKeys.put(Tokens.T_INTO, INTO);\\n        reservedKeys.put(Tokens.T_IS, IS);\\n        reservedKeys.put(Tokens.T_ITERATE, ITERATE);\\n        reservedKeys.put(Tokens.T_JOIN, JOIN);\\n        reservedKeys.put(Tokens.T_LAG, LAG);\\n        reservedKeys.put(Tokens.T_LANGUAGE, LANGUAGE);\\n        reservedKeys.put(Tokens.T_LARGE, LARGE);\\n        reservedKeys.put(Tokens.T_LAST_VALUE, LAST_VALUE);\\n        reservedKeys.put(Tokens.T_LATERAL, LATERAL);\\n        reservedKeys.put(Tokens.T_LEAD, LEAD);\\n        reservedKeys.put(Tokens.T_LEADING, LEADING);\\n        reservedKeys.put(Tokens.T_LEAVE, LEAVE);\\n        reservedKeys.put(Tokens.T_LEFT, LEFT);\\n        reservedKeys.put(Tokens.T_LIKE, LIKE);\\n        reservedKeys.put(Tokens.T_LIKE_REGX, LIKE_REGEX);\\n        reservedKeys.put(Tokens.T_LN, LN);\\n        reservedKeys.put(Tokens.T_LOCAL, LOCAL);\\n        reservedKeys.put(Tokens.T_LOCALTIME, LOCALTIME);\\n        reservedKeys.put(Tokens.T_LOCALTIMESTAMP, LOCALTIMESTAMP);\\n        reservedKeys.put(Tokens.T_LOOP, LOOP);\\n        reservedKeys.put(Tokens.T_LOWER, LOWER);\\n        reservedKeys.put(Tokens.T_MATCH, MATCH);\\n        reservedKeys.put(Tokens.T_MAX, MAX);\\n        reservedKeys.put(Tokens.T_MAX_CARDINALITY, MAX_CARDINALITY);\\n        reservedKeys.put(Tokens.T_MEMBER, MEMBER);\\n        reservedKeys.put(Tokens.T_MERGE, MERGE);\\n        reservedKeys.put(Tokens.T_METHOD, METHOD);\\n        reservedKeys.put(Tokens.T_MIN, MIN);\\n        reservedKeys.put(Tokens.T_MINUTE, MINUTE);\\n        reservedKeys.put(Tokens.T_MOD, MOD);\\n        reservedKeys.put(Tokens.T_MODIFIES, MODIFIES);\\n        reservedKeys.put(Tokens.T_MODULE, MODULE);\\n        reservedKeys.put(Tokens.T_MONTH, MONTH);\\n        reservedKeys.put(Tokens.T_MULTISET, MULTISET);\\n        reservedKeys.put(Tokens.T_NATIONAL, NATIONAL);\\n        reservedKeys.put(Tokens.T_NATURAL, NATURAL);\\n        reservedKeys.put(Tokens.T_NCHAR, NCHAR);\\n        reservedKeys.put(Tokens.T_NCLOB, NCLOB);\\n        reservedKeys.put(Tokens.T_NEW, NEW);\\n        reservedKeys.put(Tokens.T_NO, NO);\\n        reservedKeys.put(Tokens.T_NONE, NONE);\\n        reservedKeys.put(Tokens.T_NORMALIZE, NORMALIZE);\\n        reservedKeys.put(Tokens.T_NOT, NOT);\\n        reservedKeys.put(Tokens.T_NTH_VALUE, NTH_VALUE);\\n        reservedKeys.put(Tokens.T_NTILE, NTILE);\\n        reservedKeys.put(Tokens.T_NULL, NULL);\\n        reservedKeys.put(Tokens.T_NULLIF, NULLIF);\\n        reservedKeys.put(Tokens.T_NUMERIC, NUMERIC);\\n        reservedKeys.put(Tokens.T_OCCURRENCES_REGEX, OCCURRENCES_REGEX);\\n        reservedKeys.put(Tokens.T_OCTET_LENGTH, OCTET_LENGTH);\\n        reservedKeys.put(Tokens.T_OF, OF);\\n        reservedKeys.put(Tokens.T_OFFSET, OFFSET);\\n        reservedKeys.put(Tokens.T_OLD, OLD);\\n        reservedKeys.put(Tokens.T_ON, ON);\\n        reservedKeys.put(Tokens.T_ONLY, ONLY);\\n        reservedKeys.put(Tokens.T_OPEN, OPEN);\\n        reservedKeys.put(Tokens.T_OR, OR);\\n        reservedKeys.put(Tokens.T_ORDER, ORDER);\\n        reservedKeys.put(Tokens.T_OUT, OUT);\\n        reservedKeys.put(Tokens.T_OUTER, OUTER);\\n        reservedKeys.put(Tokens.T_OVER, OVER);\\n        reservedKeys.put(Tokens.T_OVERLAPS, OVERLAPS);\\n        reservedKeys.put(Tokens.T_OVERLAY, OVERLAY);\\n        reservedKeys.put(Tokens.T_PARAMETER, PARAMETER);\\n        reservedKeys.put(Tokens.T_PARTITION, PARTITION);\\n        reservedKeys.put(Tokens.T_PERCENT_RANK, PERCENT_RANK);\\n        reservedKeys.put(Tokens.T_PERCENTILE_CONT, PERCENTILE_CONT);\\n        reservedKeys.put(Tokens.T_PERCENTILE_DISC, PERCENTILE_DISC);\\n        reservedKeys.put(Tokens.T_POSITION, POSITION);\\n        reservedKeys.put(Tokens.T_POSITION_REGEX, POSITION_REGEX);\\n        reservedKeys.put(Tokens.T_POWER, POWER);\\n        reservedKeys.put(Tokens.T_PRECISION, PRECISION);\\n        reservedKeys.put(Tokens.T_PREPARE, PREPARE);\\n        reservedKeys.put(Tokens.T_PRIMARY, PRIMARY);\\n        reservedKeys.put(Tokens.T_PROCEDURE, PROCEDURE);\\n        reservedKeys.put(Tokens.T_RANGE, RANGE);\\n        reservedKeys.put(Tokens.T_RANK, RANK);\\n        reservedKeys.put(Tokens.T_READS, READS);\\n        reservedKeys.put(Tokens.T_REAL, REAL);\\n        reservedKeys.put(Tokens.T_RECURSIVE, RECURSIVE);\\n        reservedKeys.put(Tokens.T_REF, REF);\\n        reservedKeys.put(Tokens.T_REFERENCES, REFERENCES);\\n        reservedKeys.put(Tokens.T_REFERENCING, REFERENCING);\\n        reservedKeys.put(Tokens.T_REGR_AVGX, REGR_AVGX);\\n        reservedKeys.put(Tokens.T_REGR_AVGY, REGR_AVGY);\\n        reservedKeys.put(Tokens.T_REGR_COUNT, REGR_COUNT);\\n        reservedKeys.put(Tokens.T_REGR_INTERCEPT, REGR_INTERCEPT);\\n        reservedKeys.put(Tokens.T_REGR_R2, REGR_R2);\\n        reservedKeys.put(Tokens.T_REGR_SLOPE, REGR_SLOPE);\\n        reservedKeys.put(Tokens.T_REGR_SXX, REGR_SXX);\\n        reservedKeys.put(Tokens.T_REGR_SXY, REGR_SXY);\\n        reservedKeys.put(Tokens.T_REGR_SYY, REGR_SYY);\\n        reservedKeys.put(Tokens.T_RELEASE, RELEASE);\\n        reservedKeys.put(Tokens.T_REPEAT, REPEAT);\\n        reservedKeys.put(Tokens.T_RESIGNAL, RESIGNAL);\\n        reservedKeys.put(Tokens.T_RETURN, RETURN);\\n        reservedKeys.put(Tokens.T_RETURNS, RETURNS);\\n        reservedKeys.put(Tokens.T_REVOKE, REVOKE);\\n        reservedKeys.put(Tokens.T_RIGHT, RIGHT);\\n        reservedKeys.put(Tokens.T_ROLLBACK, ROLLBACK);\\n        reservedKeys.put(Tokens.T_ROLLUP, ROLLUP);\\n        reservedKeys.put(Tokens.T_ROW, ROW);\\n        reservedKeys.put(Tokens.T_ROW_NUMBER, ROW_NUMBER);\\n        reservedKeys.put(Tokens.T_ROWS, ROWS);\\n        reservedKeys.put(Tokens.T_SAVEPOINT, SAVEPOINT);\\n        reservedKeys.put(Tokens.T_SCOPE, SCOPE);\\n        reservedKeys.put(Tokens.T_SCROLL, SCROLL);\\n        reservedKeys.put(Tokens.T_SEARCH, SEARCH);\\n        reservedKeys.put(Tokens.T_SECOND, SECOND);\\n        reservedKeys.put(Tokens.T_SELECT, SELECT);\\n        reservedKeys.put(Tokens.T_SENSITIVE, SENSITIVE);\\n        reservedKeys.put(Tokens.T_SESSION_USER, SESSION_USER);\\n        reservedKeys.put(Tokens.T_SET, SET);\\n        reservedKeys.put(Tokens.T_SIGNAL, SIGNAL);\\n        reservedKeys.put(Tokens.T_SIMILAR, SIMILAR);\\n        reservedKeys.put(Tokens.T_SMALLINT, SMALLINT);\\n        reservedKeys.put(Tokens.T_SOME, SOME);\\n        reservedKeys.put(Tokens.T_SPECIFIC, SPECIFIC);\\n        reservedKeys.put(Tokens.T_SPECIFICTYPE, SPECIFICTYPE);\\n        reservedKeys.put(Tokens.T_SQL, SQL);\\n        reservedKeys.put(Tokens.T_SQLEXCEPTION, SQLEXCEPTION);\\n        reservedKeys.put(Tokens.T_SQLSTATE, SQLSTATE);\\n        reservedKeys.put(Tokens.T_SQLWARNING, SQLWARNING);\\n        reservedKeys.put(Tokens.T_SQRT, SQRT);\\n        reservedKeys.put(Tokens.T_STACKED, STACKED);\\n        reservedKeys.put(Tokens.T_START, START);\\n        reservedKeys.put(Tokens.T_STATIC, STATIC);\\n        reservedKeys.put(Tokens.T_STDDEV_POP, STDDEV_POP);\\n        reservedKeys.put(Tokens.T_STDDEV_SAMP, STDDEV_SAMP);\\n        reservedKeys.put(Tokens.T_SUBMULTISET, SUBMULTISET);\\n        reservedKeys.put(Tokens.T_SUBSTRING, SUBSTRING);\\n        reservedKeys.put(Tokens.T_SUBSTRING_REGEX, SUBSTRING_REGEX);\\n        reservedKeys.put(Tokens.T_SUM, SUM);\\n        reservedKeys.put(Tokens.T_SYMMETRIC, SYMMETRIC);\\n        reservedKeys.put(Tokens.T_SYSTEM, SYSTEM);\\n        reservedKeys.put(Tokens.T_SYSTEM_USER, SYSTEM_USER);\\n        reservedKeys.put(Tokens.T_TABLE, TABLE);\\n        reservedKeys.put(Tokens.T_TABLESAMPLE, TABLESAMPLE);\\n        reservedKeys.put(Tokens.T_THEN, THEN);\\n        reservedKeys.put(Tokens.T_TIME, TIME);\\n        reservedKeys.put(Tokens.T_TIMESTAMP, TIMESTAMP);\\n        reservedKeys.put(Tokens.T_TIMEZONE_HOUR, TIMEZONE_HOUR);\\n        reservedKeys.put(Tokens.T_TIMEZONE_MINUTE, TIMEZONE_MINUTE);\\n        reservedKeys.put(Tokens.T_TO, TO);\\n        reservedKeys.put(Tokens.T_TRAILING, TRAILING);\\n        reservedKeys.put(Tokens.T_TRANSLATE, TRANSLATE);\\n        reservedKeys.put(Tokens.T_TRANSLATE_REGEX, TRANSLATE_REGEX);\\n        reservedKeys.put(Tokens.T_TRANSLATION, TRANSLATION);\\n        reservedKeys.put(Tokens.T_TREAT, TREAT);\\n        reservedKeys.put(Tokens.T_TRIGGER, TRIGGER);\\n        reservedKeys.put(Tokens.T_TRIM, TRIM);\\n        reservedKeys.put(Tokens.T_TRIM_ARRAY, TRIM_ARRAY);\\n        reservedKeys.put(Tokens.T_TRUE, TRUE);\\n        reservedKeys.put(Tokens.T_TRUNCATE, TRUNCATE);\\n        reservedKeys.put(Tokens.T_UESCAPE, UESCAPE);\\n        reservedKeys.put(Tokens.T_UNDO, UNDO);\\n        reservedKeys.put(Tokens.T_UNION, UNION);\\n        reservedKeys.put(Tokens.T_UNIQUE, UNIQUE);\\n        reservedKeys.put(Tokens.T_UNKNOWN, UNKNOWN);\\n        reservedKeys.put(Tokens.T_UNNEST, UNNEST);\\n        reservedKeys.put(Tokens.T_UNTIL, UNTIL);\\n        reservedKeys.put(Tokens.T_UPDATE, UPDATE);\\n        reservedKeys.put(Tokens.T_UPPER, UPPER);\\n        reservedKeys.put(Tokens.T_USER, USER);\\n        reservedKeys.put(Tokens.T_USING, USING);\\n        reservedKeys.put(Tokens.T_VALUE, VALUE);\\n        reservedKeys.put(Tokens.T_VALUES, VALUES);\\n        reservedKeys.put(Tokens.T_VAR_POP, VAR_POP);\\n        reservedKeys.put(Tokens.T_VAR_SAMP, VAR_SAMP);\\n        reservedKeys.put(Tokens.T_VARBINARY, VARBINARY);\\n        reservedKeys.put(Tokens.T_VARCHAR, VARCHAR);\\n        reservedKeys.put(Tokens.T_VARYING, VARYING);\\n        reservedKeys.put(Tokens.T_WHEN, WHEN);\\n        reservedKeys.put(Tokens.T_WHENEVER, WHENEVER);\\n        reservedKeys.put(Tokens.T_WHERE, WHERE);\\n        reservedKeys.put(Tokens.T_WIDTH_BUCKET, WIDTH_BUCKET);\\n        reservedKeys.put(Tokens.T_WINDOW, WINDOW);\\n        reservedKeys.put(Tokens.T_WITH, WITH);\\n        reservedKeys.put(Tokens.T_WITHIN, WITHIN);\\n        reservedKeys.put(Tokens.T_WITHOUT, WITHOUT);\\n        reservedKeys.put(Tokens.T_WHILE, WHILE);\\n        reservedKeys.put(Tokens.T_YEAR, YEAR);\\n    }\\n    private static final IntValueHashMap commandSet = new IntValueHashMap(299);\\n    static {\\n        commandSet.put(T_ACTION, ACTION);\\n        commandSet.put(T_ADD, ADD);\\n        commandSet.put(T_ADMIN, ADMIN);\\n        commandSet.put(T_AFTER, AFTER);\\n        commandSet.put(T_ALIAS, ALIAS);\\n        commandSet.put(T_ALWAYS, ALWAYS);\\n        commandSet.put(T_ASC, ASC);\\n        commandSet.put(T_AUTHENTICATION, AUTHENTICATION);\\n        commandSet.put(T_AUTOCOMMIT, AUTOCOMMIT);\\n        commandSet.put(T_BACKUP, BACKUP);\\n        commandSet.put(T_BEFORE, BEFORE);\\n        commandSet.put(T_BINARY_DOUBLE, BINARY_DOUBLE);\\n        commandSet.put(T_BINARY_FLOAT, BINARY_FLOAT);\\n        commandSet.put(T_BIT, BIT);\\n        commandSet.put(T_BYTE, BYTE);\\n        commandSet.put(T_BLOCKING, BLOCKING);\\n        commandSet.put(T_BODY, BODY);\\n        commandSet.put(T_CACHE, CACHE);\\n        commandSet.put(T_CACHED, CACHED);\\n        commandSet.put(T_CASCADE, CASCADE);\\n        commandSet.put(T_CATALOG, CATALOG);\\n        commandSet.put(T_CHARACTERISTICS, CHARACTERISTICS);\\n        commandSet.put(T_CHARACTERS, CHARACTERS);\\n        commandSet.put(T_CHECKPOINT, CHECKPOINT);\\n        commandSet.put(T_CRYPT_KEY, CRYPT_KEY);\\n        commandSet.put(T_CLASS, CLASS);\\n        commandSet.put(T_CLUSTERED, CLUSTERED);\\n        commandSet.put(T_COLLATE, COLLATE);\\n        commandSet.put(T_COLLATION, COLLATION);\\n        commandSet.put(T_COMMENT, COMMENT);\\n        commandSet.put(T_COMMITTED, COMMITTED);\\n        commandSet.put(T_COMPACT, COMPACT);\\n        commandSet.put(T_COMPRESSED, COMPRESSED);\\n        commandSet.put(T_CONDITION_IDENTIFIER, Tokens.CONDITION_IDENTIFIER);\\n        commandSet.put(T_CONTAINS, CONTAINS);\\n        commandSet.put(T_CONTINUE, CONTINUE);\\n        commandSet.put(T_CONTROL, CONTROL);\\n        commandSet.put(T_CURDATE, CURDATE);\\n        commandSet.put(T_CURRVAL, CURRVAL);\\n        commandSet.put(T_CURTIME, CURTIME);\\n        commandSet.put(T_DATA, DATA);\\n        commandSet.put(T_DATABASE, DATABASE);\\n        commandSet.put(T_DEADLOCK, DEADLOCK);\\n        commandSet.put(T_DEFAULTS, DEFAULTS);\\n        commandSet.put(T_DEFRAG, DEFRAG);\\n        commandSet.put(T_DELAY, DELAY);\\n        commandSet.put(T_DESC, DESC);\\n        commandSet.put(T_DIGEST, DIGEST);\\n        commandSet.put(T_DOMAIN, DOMAIN);\\n        commandSet.put(T_EVENT, EVENT);\\n        commandSet.put(T_EXCLUDING, EXCLUDING);\\n        commandSet.put(T_EXPLAIN, EXPLAIN);\\n        commandSet.put(T_FILE, FILE);\\n        commandSet.put(T_FILES, FILES);\\n        commandSet.put(T_FINAL, FINAL);\\n        commandSet.put(T_FIRST, FIRST);\\n        commandSet.put(T_FORMAT, FORMAT);\\n        commandSet.put(T_G_FACTOR, G);\\n        commandSet.put(T_GC, GC);\\n        commandSet.put(T_GENERATED, GENERATED);\\n        commandSet.put(T_GRANTED, GRANTED);\\n        commandSet.put(T_GROUP_CONCAT, GROUP_CONCAT);\\n        commandSet.put(T_HEADER, HEADER);\\n        commandSet.put(T_IF, Tokens.IF);\\n        commandSet.put(T_IGNORECASE, IGNORECASE);\\n        commandSet.put(T_IMMEDIATELY, IMMEDIATELY);\\n        commandSet.put(T_INCLUDING, INCLUDING);\\n        commandSet.put(T_INCREMENT, INCREMENT);\\n        commandSet.put(T_INDEX, INDEX);\\n        commandSet.put(T_INITIAL, INITIAL);\\n        commandSet.put(T_INPUT, INPUT);\\n        commandSet.put(T_INSTEAD, INSTEAD);\\n        commandSet.put(T_INTEGRITY, INTEGRITY);\\n        commandSet.put(T_IS_AUTOCOMMIT, IS_AUTOCOMMIT);\\n        commandSet.put(T_ISOLATION, ISOLATION);\\n        commandSet.put(T_IS_READONLY_DATABASE, IS_READONLY_DATABASE);\\n        commandSet.put(T_IS_READONLY_DATABASE_FILES,\\n                       IS_READONLY_DATABASE_FILES);\\n        commandSet.put(T_IS_READONLY_SESSION, IS_READONLY_SESSION);\\n        commandSet.put(T_JAVA, JAVA);\\n        commandSet.put(T_K_FACTOR, K);\\n        commandSet.put(T_KEY, KEY);\\n        commandSet.put(T_LAST, LAST);\\n        commandSet.put(T_LASTVAL, LASTVAL);\\n        commandSet.put(T_LENGTH, LENGTH);\\n        commandSet.put(T_LEVEL, LEVEL);\\n        commandSet.put(T_LIBRARY, LIBRARY);\\n        commandSet.put(T_LIMIT, LIMIT);\\n        commandSet.put(T_LOB, LOB);\\n        commandSet.put(T_LOCK, LOCK);\\n        commandSet.put(T_LOCKS, LOCKS);\\n        commandSet.put(T_LONG, LONG);\\n        commandSet.put(T_LONGVAR, LONGVAR);\\n        commandSet.put(T_M_FACTOR, M);\\n        commandSet.put(T_MATCHED, MATCHED);\\n        commandSet.put(T_MAXROWS, MAXROWS);\\n        commandSet.put(T_MAXVALUE, MAXVALUE);\\n        commandSet.put(T_MEDIAN, MEDIAN);\\n        commandSet.put(T_MEMORY, MEMORY);\\n        commandSet.put(T_MILLIS, MILLIS);\\n        commandSet.put(T_MINUS_EXCEPT, MINUS_EXCEPT);\\n        commandSet.put(T_MINVALUE, MINVALUE);\\n        commandSet.put(T_MVCC, MVCC);\\n        commandSet.put(T_MVLOCKS, MVLOCKS);\\n        commandSet.put(T_NAME, NAME);\\n        commandSet.put(T_NEXT, NEXT);\\n        commandSet.put(T_NEXTVAL, NEXTVAL);\\n        commandSet.put(T_NAN, NAN);\\n        commandSet.put(T_NIO, NIO);\\n        commandSet.put(T_NOW, NOW);\\n        commandSet.put(T_NULLS, NULLS);\\n        commandSet.put(T_NUMBER, NUMBER);\\n        commandSet.put(T_OCTETS, OCTETS);\\n        commandSet.put(T_OFF, OFF);\\n        commandSet.put(T_OPTION, OPTION);\\n        commandSet.put(T_ORDINALITY, ORDINALITY);\\n        commandSet.put(T_OVERRIDING, OVERRIDING);\\n        commandSet.put(T_P_FACTOR, P);\\n        commandSet.put(T_PARTIAL, PARTIAL);\\n        commandSet.put(T_PASSWORD, PASSWORD);\\n        commandSet.put(T_PLACING, PLACING);\\n        commandSet.put(T_PLAN, PLAN);\\n        commandSet.put(T_PRESERVE, PRESERVE);\\n        commandSet.put(T_PRIVILEGES, PRIVILEGES);\\n        commandSet.put(T_PROPERTY, PROPERTY);\\n        commandSet.put(T_RAW, RAW);\\n        commandSet.put(T_READ, READ);\\n        commandSet.put(T_READONLY, READONLY);\\n        commandSet.put(T_REFERENTIAL, REFERENTIAL);\\n        commandSet.put(T_RENAME, RENAME);\\n        commandSet.put(T_REPEATABLE, REPEATABLE);\\n        commandSet.put(T_RESET, RESET);\\n        commandSet.put(T_RESTART, RESTART);\\n        commandSet.put(T_RESTRICT, RESTRICT);\\n        commandSet.put(T_RESULT, RESULT);\\n        commandSet.put(T_ROLE, ROLE);\\n        commandSet.put(T_ROUTINE, ROUTINE);\\n        commandSet.put(T_SCALE, SCALE);\\n        commandSet.put(T_SCHEMA, SCHEMA);\\n        commandSet.put(T_SCRIPT, SCRIPT);\\n        commandSet.put(T_SEQUENCE, SEQUENCE);\\n        commandSet.put(T_SEPARATOR, SEPARATOR);\\n        commandSet.put(T_SERIALIZABLE, SERIALIZABLE);\\n        commandSet.put(T_SERVER, SERVER);\\n        commandSet.put(T_SESSION, SESSION);\\n        commandSet.put(T_SETS, SETS);\\n        commandSet.put(T_SHUTDOWN, SHUTDOWN);\\n        commandSet.put(T_SIMPLE, SIMPLE);\\n        commandSet.put(T_SIZE, SIZE);\\n        commandSet.put(T_SOURCE, SOURCE);\\n        commandSet.put(T_SQL_BIGINT, SQL_BIGINT);\\n        commandSet.put(T_SQL_BINARY, SQL_BINARY);\\n        commandSet.put(T_SQL_BIT, SQL_BIT);\\n        commandSet.put(T_SQL_BLOB, SQL_BLOB);\\n        commandSet.put(T_SQL_BOOLEAN, SQL_BOOLEAN);\\n        commandSet.put(T_SQL_CHAR, SQL_CHAR);\\n        commandSet.put(T_SQL_CLOB, SQL_CLOB);\\n        commandSet.put(T_SQL_DATALINK, SQL_DATALINK);\\n        commandSet.put(T_SQL_DATE, SQL_DATE);\\n        commandSet.put(T_SQL_DECIMAL, SQL_DECIMAL);\\n        commandSet.put(T_SQL_DOUBLE, SQL_DOUBLE);\\n        commandSet.put(T_SQL_FLOAT, SQL_FLOAT);\\n        commandSet.put(T_SQL_INTEGER, SQL_INTEGER);\\n        commandSet.put(T_SQL_LONGNVARCHAR, SQL_LONGNVARCHAR);\\n        commandSet.put(T_SQL_LONGVARBINARY, SQL_LONGVARBINARY);\\n        commandSet.put(T_SQL_LONGVARCHAR, SQL_LONGVARCHAR);\\n        commandSet.put(T_SQL_NCHAR, SQL_NCHAR);\\n        commandSet.put(T_SQL_NCLOB, SQL_NCLOB);\\n        commandSet.put(T_SQL_NUMERIC, SQL_NUMERIC);\\n        commandSet.put(T_SQL_NVARCHAR, SQL_NVARCHAR);\\n        commandSet.put(T_SQL_REAL, SQL_REAL);\\n        commandSet.put(T_SQL_ROWID, SQL_ROWID);\\n        commandSet.put(T_SQL_SMALLINT, SQL_SMALLINT);\\n        commandSet.put(T_SQL_SQLXML, SQL_SQLXML);\\n        commandSet.put(T_SQL_TIME, SQL_TIME);\\n        commandSet.put(T_SQL_TIMESTAMP, SQL_TIMESTAMP);\\n        commandSet.put(T_SQL_TINYINT, SQL_TINYINT);\\n        commandSet.put(T_SQL_VARBINARY, SQL_VARBINARY);\\n        commandSet.put(T_SQL_VARCHAR, SQL_VARCHAR);\\n        commandSet.put(T_SQL_TSI_DAY, SQL_TSI_DAY);\\n        commandSet.put(T_SQL_TSI_FRAC_SECOND, SQL_TSI_FRAC_SECOND);\\n        commandSet.put(T_SQL_TSI_MILLI_SECOND, SQL_TSI_MILLI_SECOND);\\n        commandSet.put(T_SQL_TSI_HOUR, SQL_TSI_HOUR);\\n        commandSet.put(T_SQL_TSI_MINUTE, SQL_TSI_MINUTE);\\n        commandSet.put(T_SQL_TSI_MONTH, SQL_TSI_MONTH);\\n        commandSet.put(T_SQL_TSI_QUARTER, SQL_TSI_QUARTER);\\n        commandSet.put(T_SQL_TSI_SECOND, SQL_TSI_SECOND);\\n        commandSet.put(T_SQL_TSI_WEEK, SQL_TSI_WEEK);\\n        commandSet.put(T_SQL_TSI_YEAR, SQL_TSI_YEAR);\\n        commandSet.put(T_STATEMENT, STATEMENT);\\n        commandSet.put(T_STYLE, STYLE);\\n        commandSet.put(T_SYNTAX, SYNTAX);\\n        commandSet.put(T_T_FACTOR, T);\\n        commandSet.put(T_TDC, TDC);\\n        commandSet.put(T_TEMP, TEMP);\\n        commandSet.put(T_TEMPORARY, TEMPORARY);\\n        commandSet.put(T_TEXT, TEXT);\\n        commandSet.put(T_TYPES, TYPES);\\n        commandSet.put(T_TIMESTAMPADD, TIMESTAMPADD);\\n        commandSet.put(T_TIMESTAMPDIFF, TIMESTAMPDIFF);\\n        commandSet.put(T_TOP, TOP);\\n        commandSet.put(T_TRANSACTION, TRANSACTION);\\n        commandSet.put(T_TTI, TTI);\\n        commandSet.put(T_TYPE, TYPE);\\n        commandSet.put(T_UNCOMMITTED, UNCOMMITTED);\\n        commandSet.put(T_USAGE, USAGE);\\n        commandSet.put(T_VIEW, VIEW);\\n        commandSet.put(T_VARCHAR2, VARCHAR2);\\n        commandSet.put(T_WORK, WORK);\\n        commandSet.put(T_WRAPPER, WRAPPER);\\n        commandSet.put(T_WRITE, WRITE);\\n        commandSet.put(T_WRITE_DELAY, WRITE_DELAY);\\n        commandSet.put(T_ZONE, ZONE);\\n                commandSet.put(T_ACOS, ACOS);\\n        commandSet.put(T_ACTION_ID, ACTION_ID);\\n        commandSet.put(T_ARRAY_SORT, ARRAY_SORT);\\n        commandSet.put(T_ASCII, ASCII);\\n        commandSet.put(T_ASIN, ASIN);\\n        commandSet.put(T_ATAN, ATAN);\\n        commandSet.put(T_ATAN2, ATAN2);\\n        commandSet.put(T_BITAND, BITAND);\\n        commandSet.put(T_BITLENGTH, BITLENGTH);\\n        commandSet.put(T_BITOR, BITOR);\\n        commandSet.put(T_BITXOR, BITXOR);\\n        commandSet.put(T_CASEWHEN, Tokens.CASEWHEN);\\n        commandSet.put(T_CONCAT_WORD, CONCAT_WORD);\\n        commandSet.put(T_CHR, CHR);\\n        commandSet.put(T_COS, COS);\\n        commandSet.put(T_COT, COT);\\n        commandSet.put(T_DATABASE_NAME, DATABASE_NAME);\\n        commandSet.put(T_DATEADD, DATEADD);\\n        commandSet.put(T_DATEDIFF, DATEDIFF);\\n        commandSet.put(T_DAY_NAME, DAY_NAME);\\n        commandSet.put(T_DAY_OF_MONTH, DAY_OF_MONTH);\\n        commandSet.put(T_DAY_OF_WEEK, DAY_OF_WEEK);\\n        commandSet.put(T_DAY_OF_YEAR, DAY_OF_YEAR);\\n        commandSet.put(T_DAYNAME, DAYNAME);\\n        commandSet.put(T_DAYOFMONTH, DAYOFMONTH);\\n        commandSet.put(T_DAYOFWEEK, DAYOFWEEK);\\n        commandSet.put(T_DAYOFYEAR, DAYOFYEAR);\\n        commandSet.put(T_DECODE, DECODE);\\n        commandSet.put(T_DEGREES, DEGREES);\\n        commandSet.put(T_DIFFERENCE, DIFFERENCE);\\n        commandSet.put(T_DMOD, DMOD);\\n        commandSet.put(T_GREATEST, GREATEST);\\n        commandSet.put(T_HEXTORAW, HEXTORAW);\\n        commandSet.put(T_IFNULL, Tokens.IFNULL);\\n        commandSet.put(T_ISNULL, Tokens.ISNULL);\\n        commandSet.put(T_LCASE, LCASE);\\n        commandSet.put(T_LEAST, LEAST);\\n        commandSet.put(T_LOAD_FILE, LOAD_FILE);\\n        commandSet.put(T_LOCATE, LOCATE);\\n        commandSet.put(T_LOG, LOG);\\n        commandSet.put(T_LOG10, LOG10);\\n        commandSet.put(T_LPAD, LPAD);\\n        commandSet.put(T_LTRIM, LTRIM);\\n        commandSet.put(T_MONTH_NAME, MONTH_NAME);\\n        commandSet.put(T_MONTHNAME, MONTHNAME);\\n        commandSet.put(T_NAMES, Tokens.NAMES);\\n        commandSet.put(T_NVL, Tokens.IFNULL);\\n        commandSet.put(T_OCTETLENGTH, OCTETLENGTH);\\n        commandSet.put(T_PI, PI);\\n        commandSet.put(T_QUARTER, QUARTER);\\n        commandSet.put(T_RADIANS, RADIANS);\\n        commandSet.put(T_RAND, RAND);\\n        commandSet.put(T_RAWTOHEX, RAWTOHEX);\\n        commandSet.put(T_REGEXP_MATCHES, REGEXP_MATCHES);\\n        commandSet.put(T_REPLACE, REPLACE);\\n        commandSet.put(T_REVERSE, REVERSE);\\n        commandSet.put(T_ROUND, ROUND);\\n        commandSet.put(T_ROUNDMAGIC, ROUNDMAGIC);\\n        commandSet.put(T_RPAD, RPAD);\\n        commandSet.put(T_RTRIM, RTRIM);\\n        commandSet.put(T_SECONDS_MIDNIGHT, SECONDS_MIDNIGHT);\\n        commandSet.put(T_SESSION_ID, SESSION_ID);\\n        commandSet.put(T_SIGN, SIGN);\\n        commandSet.put(T_SIN, SIN);\\n        commandSet.put(T_SOUNDEX, SOUNDEX);\\n        commandSet.put(T_SPACE, SPACE);\\n        commandSet.put(T_SUBSTR, SUBSTR);\\n        commandSet.put(T_SYSDATE, SYSDATE);\\n        commandSet.put(T_TAN, TAN);\\n        commandSet.put(T_TO_CHAR, TO_CHAR);\\n        commandSet.put(T_TO_DATE, TO_DATE);\\n        commandSet.put(T_TO_TIMESTAMP, TO_TIMESTAMP);\\n        commandSet.put(T_TODAY, TODAY);\\n        commandSet.put(T_TRUNC, TRUNC);\\n        commandSet.put(T_UCASE, UCASE);\\n        commandSet.put(T_TRANSACTION_ID, TRANSACTION_ID);\\n        commandSet.put(T_TRANSACTION_SIZE, TRANSACTION_SIZE);\\n        commandSet.put(T_UUID, UUID);\\n        commandSet.put(T_UNIX_TIMESTAMP, UNIX_TIMESTAMP);\\n        commandSet.put(T_WEEK, WEEK);\\n        commandSet.put(T_WEEK_OF_YEAR, WEEK_OF_YEAR);\\n                commandSet.put(T_ISOLATION_LEVEL, ISOLATION_LEVEL);\\n        commandSet.put(T_SESSION_ISOLATION_LEVEL, SESSION_ISOLATION_LEVEL);\\n        commandSet.put(T_DATABASE_ISOLATION_LEVEL, DATABASE_ISOLATION_LEVEL);\\n        commandSet.put(T_TRANSACTION_CONTROL, TRANSACTION_CONTROL);\\n        commandSet.put(T_TIMEZONE, TIMEZONE);\\n        commandSet.put(T_SESSION_TIMEZONE, SESSION_TIMEZONE);\\n        commandSet.put(T_DATABASE_TIMEZONE, DATABASE_TIMEZONE);\\n        commandSet.put(T_DATABASE_VERSION, DATABASE_VERSION);\\n        commandSet.put(T_LOB_ID, LOB_ID);\\n        commandSet.put(T_SEQUENCE_ARRAY, SEQUENCE_ARRAY);\\n                commandSet.put(T_ASTERISK, Tokens.ASTERISK);\\n        commandSet.put(T_CLOSEBRACKET, CLOSEBRACKET);\\n        commandSet.put(T_COLON, Tokens.COLON);\\n        commandSet.put(T_COMMA, Tokens.COMMA);\\n        commandSet.put(T_CONCAT, Tokens.CONCAT);\\n        commandSet.put(T_DIVIDE, Tokens.DIVIDE);\\n        commandSet.put(T_EQUALS, Tokens.EQUALS);\\n        commandSet.put(T_GREATER, Tokens.GREATER);\\n        commandSet.put(T_GREATER_EQUALS, Tokens.GREATER_EQUALS);\\n        commandSet.put(T_LEFTBRACKET, LEFTBRACKET);\\n        commandSet.put(T_LESS, Tokens.LESS);\\n        commandSet.put(T_LESS_EQUALS, Tokens.LESS_EQUALS);\\n        commandSet.put(T_MINUS, Tokens.MINUS);\\n        commandSet.put(T_NOT_EQUALS, Tokens.NOT_EQUALS);\\n        commandSet.put(T_NOT_EQUALS_ALT, Tokens.NOT_EQUALS);\\n        commandSet.put(T_OPENBRACKET, OPENBRACKET);\\n        commandSet.put(T_PLUS, Tokens.PLUS);\\n        commandSet.put(T_QUESTION, Tokens.QUESTION);\\n        commandSet.put(T_RIGHTBRACKET, RIGHTBRACKET);\\n        commandSet.put(T_SEMICOLON, SEMICOLON);\\n    }\\n    static int get(String token) {\\n        int type = reservedKeys.get(token, -1);\\n        if (type == -1) {\\n            return commandSet.get(token, -1);\\n        }\\n        return type;\\n    }\\n    public static boolean isCoreKeyword(int token) {\\n        return coreReservedWords.contains(token);\\n    }\\n    public static boolean isKeyword(String token) {\\n        return reservedKeys.containsKey(token);\\n    }\\n    public static int getKeywordID(String token, int defaultValue) {\\n        return reservedKeys.get(token, defaultValue);\\n    }\\n    public static int getNonKeywordID(String token, int defaultValue) {\\n        return commandSet.get(token, defaultValue);\\n    }\\n    public static String getKeyword(int token) {\\n        String key = (String) reservedKeys.getKey(token);\\n        if (key != null) {\\n            return key;\\n        }\\n        key = (String) commandSet.getKey(token);\\n        return key;\\n    }\\n    private static final OrderedIntHashSet coreReservedWords;\\n    static {\\n                        coreReservedWords = new OrderedIntHashSet(128);\\n        short[] keyword = {\\n            ADMIN, AS, AND, ALL, ANY, AT, AVG, BY, BETWEEN, BOTH, CALL, CASE,\\n            CAST, CORRESPONDING, CONVERT, COUNT, COALESCE, CREATE, CROSS,\\n            DISTINCT, DO, DROP, ELSE, END, EVERY, EXISTS, EXCEPT, FOR, FROM,\\n            FULL, GRANT, GROUP, HAVING, INTO, IS, IN, INTERSECT, JOIN, INNER,\\n            LEFT, LEADING, LIKE, MAX, MIN, NATURAL, NULLIF, NOT, ON, ORDER, OR,\\n            OUTER, PRIMARY, REFERENCES, RIGHT, SELECT, SET, SOME, STDDEV_POP,\\n            STDDEV_SAMP, SUM, TABLE, THEN, TO, TRAILING, TRIGGER, UNION,\\n            UNIQUE, USING, VALUES, VAR_POP, VAR_SAMP, WHEN, WHERE, WITH,\\n        };\\n        for (int i = 0; i < keyword.length; i++) {\\n            coreReservedWords.add(keyword[i]);\\n        }\\n    }\\n    public static final short[] SQL_INTERVAL_FIELD_CODES = new short[] {\\n        Tokens.YEAR, Tokens.MONTH, Tokens.DAY, Tokens.HOUR, Tokens.MINUTE,\\n        Tokens.SECOND\\n    };\\n    public static final String[] SQL_INTERVAL_FIELD_NAMES = new String[] {\\n        Tokens.T_YEAR, Tokens.T_MONTH, Tokens.T_DAY, Tokens.T_HOUR,\\n        Tokens.T_MINUTE, Tokens.T_SECOND\\n    };\\n    private static final IntKeyHashMap sqlTSILookup = new IntKeyHashMap(10);\\n    static {\\n        sqlTSILookup.put(SQL_TSI_DAY, T_SQL_TSI_DAY);\\n        sqlTSILookup.put(SQL_TSI_FRAC_SECOND, T_SQL_TSI_FRAC_SECOND);\\n        sqlTSILookup.put(SQL_TSI_MILLI_SECOND, T_SQL_TSI_MILLI_SECOND);\\n        sqlTSILookup.put(SQL_TSI_HOUR, T_SQL_TSI_HOUR);\\n        sqlTSILookup.put(SQL_TSI_MINUTE, T_SQL_TSI_MINUTE);\\n        sqlTSILookup.put(SQL_TSI_MONTH, T_SQL_TSI_MONTH);\\n        sqlTSILookup.put(SQL_TSI_QUARTER, T_SQL_TSI_QUARTER);\\n        sqlTSILookup.put(SQL_TSI_SECOND, T_SQL_TSI_SECOND);\\n        sqlTSILookup.put(SQL_TSI_WEEK, T_SQL_TSI_WEEK);\\n        sqlTSILookup.put(SQL_TSI_YEAR, T_SQL_TSI_YEAR);\\n    }\\n    public static String getSQLTSIString(int token) {\\n        return (String) sqlTSILookup.get(token);\\n    }\\n}\""
        },
        {
            "content": "The `Tokens.java` file serves as a central definition point for all SQL keywords, operators, and special symbols used in the HSQLDB system. It defines:\n\n1. **String constants** for SQL keywords like `\"SELECT\"`, `\"FROM\"`, `\"WHERE\"`, `\"JOIN\"`, etc.\n2. **Integer constants** representing token types, such as `SELECT`, `FROM`, `WHERE`, `JOIN`, etc.\n3. **Mapping logic** that converts string representations of tokens to their corresponding integer token types via methods like `get(String token)`.\n4. **Keyword and core keyword checks** (`isKeyword`, `isCoreKeyword`) to determine whether a given string or token is a reserved SQL keyword.\n\n---\n\n### Analysis of Relationship Between `Tokens.java` and `ParserDQL.java`\n\nFrom reviewing both files:\n- `ParserDQL.java` heavily relies on `Tokens.java` during SQL parsing operations.\n- For example, in `ParserDQL.java`, we see frequent calls like:\n  ```java\n  if (token.tokenType == Tokens.SELECT) { ... }\n  ```\n  This confirms that `ParserDQL` uses the token definitions from `Tokens.java` to recognize and process SQL DQL statements.\n\n- The method `readSimpleName()` and other identifier resolution functions in `ParserDQL` also rely on token recognition using values defined in `Tokens.java`.\n\n- In addition, `ParserDQL.java` uses `Tokens.get(tokenString)` to identify function names and custom SQL constructs during query parsing.\n\nThus, it's clear that **`ParserDQL.java` depends directly on `Tokens.java`**, and changes in `Tokens.java`\u2014especially involving token definitions or mappings\u2014could impact how `ParserDQL.java` parses queries.\n\n---\n\n### Next Steps\n\nTo confirm this dependency programmatically and ensure synchronization accuracy, let\u2019s now retrieve the **call graph** of `ParserDQL.java`. This will show which other entities are referenced by `ParserDQL.java`, and we can specifically check if `Tokens.java` appears among them.\n\n#### Action: Retrieve the call graph of `ParserDQL.java`\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_e30ee664eaf64288b1da02",
                    "function": {
                        "arguments": "{\"entity\": \"ParserDQL.java\"}",
                        "name": "get_call_graph"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_call_graph",
            "content": "[\"ArrayUtil\", \"LongDeque\", \"ErrorCode\", \"IntervalType\", \"ResultConstants\", \"BlobType\", \"OrderedHashSet\", \"Iterator\", \"Charset\", \"HsqlArrayList\", \"Type\", \"HashMappedList\", \"ValuePool\", \"OrderedIntKeyHashMap\", \"Collation\", \"ArrayType\", \"Types\", \"Error\", \"DTIType\", \"HsqlList\", \"NumberType\", \"ResultProperties\", \"ClobType\", \"BitMap\"]"
        },
        {
            "content": "The **call graph** of `ParserDQL.java` shows a variety of dependencies, including utility classes like `ArrayUtil`, `OrderedHashSet`, and core SQL-related constructs such as `Type`, `IntervalType`, `Error`, `ValuePool`, etc.\n\nHowever, notably missing from the list is a direct call to `Tokens.java`. This might seem contradictory to our earlier analysis where we clearly saw references to `Tokens.SELECT`, `Tokens.FROM`, etc., in the source code. There could be two possible explanations:\n\n1. **Call graph tooling limitation**: The tool may not detect static field references (like `Tokens.SELECT`) since they are constants and do not involve method calls.\n2. **Static access pattern**: Since `Tokens.java` provides constant definitions used across the parser, it's accessed statically and may not appear explicitly in the dynamic call graph.\n\n---\n\n### Conclusion: Confirming Dependency Between `Tokens.java` and `ParserDQL.java`\n\nDespite the absence in the call graph:\n- We have confirmed that `ParserDQL.java` uses token constants defined in `Tokens.java` directly in its parsing logic.\n- The co-change relationship also shows a very high confidence (`0.5227`) between `Tokens.java` and `ParserDQL.java`.\n\nTherefore, any changes in `Tokens.java`\u2014especially involving DQL-related tokens like `SELECT`, `FROM`, `WHERE`, etc.\u2014can directly impact how `ParserDQL.java` parses SQL queries.\n\n#### \u2705 Entities That Need Synchronization with `Tokens.java`:\nBased on our analysis so far:\n1. **ParserDQL.java** \u2014 High priority due to strong co-change and direct use of token constants.\n2. **ParserCommand.java** \u2014 Strong co-change relationship; likely involves command-related tokens.\n3. **Database.java** \u2014 Moderate coupling; possibly involved in global token or SQL configuration handling.\n4. **Logger.java**, **Session.java**, **HsqlDatabaseProperties.java** \u2014 Medium coupling; potential for shared SQL context or logging of token-based operations.\n\n---\n\n### Next Step\n\nTo further validate whether `ParserCommand.java` also uses `Tokens.java` similarly, let\u2019s retrieve its origin code and analyze its usage of token constants.\n\n#### Action: Retrieve the origin code of `ParserCommand.java`\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_1e77bdcd307248b98552bc",
                    "function": {
                        "arguments": "{\"entity\": \"ParserCommand.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package org.hsqldb;\\nimport org.hsqldb.HsqlNameManager.HsqlName;\\nimport org.hsqldb.error.Error;\\nimport org.hsqldb.error.ErrorCode;\\nimport org.hsqldb.lib.HsqlArrayList;\\nimport org.hsqldb.lib.HsqlList;\\nimport org.hsqldb.lib.OrderedHashSet;\\nimport org.hsqldb.persist.HsqlDatabaseProperties;\\nimport org.hsqldb.result.Result;\\nimport org.hsqldb.result.ResultProperties;\\nimport org.hsqldb.store.ValuePool;\\nimport org.hsqldb.types.Charset;\\nimport org.hsqldb.types.Type;\\nimport org.hsqldb.types.Types;\\npublic class ParserCommand extends ParserDDL {\\n    ParserCommand(Session session, Scanner t) {\\n        super(session, t);\\n    }\\n    Statement compileStatement(int props) {\\n        Statement cs = compilePart(props);\\n        if (token.tokenType == Tokens.X_ENDPARSE) {\\n            if (cs.getSchemaName() == null) {\\n                cs.setSchemaHsqlName(session.getCurrentSchemaHsqlName());\\n            }\\n            return cs;\\n        }\\n        throw unexpectedToken();\\n    }\\n    HsqlArrayList compileStatements(String sql, Result cmd) {\\n        HsqlArrayList list = new HsqlArrayList();\\n        Statement     cs   = null;\\n        reset(sql);\\n        while (true) {\\n            if (token.tokenType == Tokens.X_ENDPARSE) {\\n                break;\\n            }\\n            try {\\n                lastError = null;\\n                cs        = compilePart(cmd.getExecuteProperties());\\n            } catch (HsqlException e) {\\n                if (lastError != null && lastError.getLevel() > e.getLevel()) {\\n                    throw lastError;\\n                }\\n                throw e;\\n            }\\n            if (!cs.isExplain\\n                    && cs.getParametersMetaData().getColumnCount() > 0) {\\n                throw Error.error(ErrorCode.X_42575);\\n            }\\n            list.add(cs);\\n        }\\n        int returnType = cmd.getStatementType();\\n        if (returnType != StatementTypes.RETURN_ANY) {\\n            int group = cs.getGroup();\\n            if (group == StatementTypes.X_SQL_DATA) {\\n                if (returnType == StatementTypes.RETURN_COUNT) {\\n                    throw Error.error(ErrorCode.X_07503);\\n                }\\n            } else if (returnType == StatementTypes.RETURN_RESULT) {\\n                throw Error.error(ErrorCode.X_07504);\\n            }\\n        }\\n        return list;\\n    }\\n    private Statement compilePart(int props) {\\n        Statement cs;\\n        compileContext.reset();\\n        setParsePosition(getPosition());\\n        if (token.tokenType == Tokens.X_STARTPARSE) {\\n            read();\\n        }\\n        switch (token.tokenType) {\\n                        case Tokens.WITH :\\n            case Tokens.OPENBRACKET :\\n            case Tokens.SELECT :\\n            case Tokens.TABLE : {\\n                cs = compileCursorSpecification(props, false,\\n                                                RangeVariable.emptyArray);\\n                break;\\n            }\\n            case Tokens.VALUES : {\\n                cs = compileShortCursorSpecification(props);\\n                break;\\n            }\\n                        case Tokens.INSERT : {\\n                cs = compileInsertStatement(RangeVariable.emptyArray);\\n                break;\\n            }\\n            case Tokens.UPDATE : {\\n                cs = compileUpdateStatement(RangeVariable.emptyArray);\\n                break;\\n            }\\n            case Tokens.MERGE : {\\n                cs = compileMergeStatement(RangeVariable.emptyArray);\\n                break;\\n            }\\n            case Tokens.DELETE : {\\n                cs = compileDeleteStatement(RangeVariable.emptyArray);\\n                break;\\n            }\\n            case Tokens.TRUNCATE : {\\n                cs = compileDeleteStatement(RangeVariable.emptyArray);\\n                break;\\n            }\\n                        case Tokens.CALL : {\\n                cs = compileCallStatement(\\n                    session.sessionContext.sessionVariablesRange, false);\\n                break;\\n            }\\n                        case Tokens.SET :\\n                cs = compileSet();\\n                break;\\n            case Tokens.START :\\n                cs = compileStartTransaction();\\n                break;\\n            case Tokens.COMMIT :\\n                cs = compileCommit();\\n                break;\\n            case Tokens.ROLLBACK :\\n                cs = compileRollback();\\n                break;\\n            case Tokens.SAVEPOINT :\\n                cs = compileSavepoint();\\n                break;\\n            case Tokens.RELEASE :\\n                cs = compileReleaseSavepoint();\\n                break;\\n                        case Tokens.CREATE :\\n                cs = compileCreate();\\n                break;\\n            case Tokens.ALTER :\\n                cs = compileAlter();\\n                break;\\n            case Tokens.DROP :\\n                cs = compileDrop();\\n                break;\\n            case Tokens.GRANT :\\n            case Tokens.REVOKE :\\n                cs = compileGrantOrRevoke();\\n                break;\\n            case Tokens.COMMENT :\\n                cs = compileComment();\\n                break;\\n                        case Tokens.LOCK :\\n                cs = compileLock();\\n                break;\\n            case Tokens.CONNECT :\\n                cs = compileConnect();\\n                break;\\n            case Tokens.DISCONNECT :\\n                cs = compileDisconnect();\\n                break;\\n                        case Tokens.SCRIPT :\\n                cs = compileScript();\\n                break;\\n            case Tokens.SHUTDOWN :\\n                cs = compileShutdown();\\n                break;\\n            case Tokens.BACKUP :\\n                cs = compileBackup();\\n                break;\\n            case Tokens.CHECKPOINT :\\n                cs = compileCheckpoint();\\n                break;\\n            case Tokens.EXPLAIN :\\n                cs = compileExplainPlan();\\n                break;\\n            case Tokens.DECLARE :\\n                cs = compileDeclare();\\n                break;\\n            default :\\n                throw unexpectedToken();\\n        }\\n        if (cs.type != StatementTypes.SET_SESSION_AUTHORIZATION) {\\n            cs.setSQL(getLastPart());\\n        }\\n        if (token.tokenType == Tokens.SEMICOLON) {\\n            read();\\n        } else if (token.tokenType == Tokens.X_ENDPARSE) {}\\n        return cs;\\n    }\\n    private Statement compileDeclare() {\\n        Statement    cs;\\n        ColumnSchema variables[];\\n        cs = compileDeclareLocalTableOrNull();\\n        if (cs != null) {\\n            return cs;\\n        }\\n        variables = readLocalVariableDeclarationOrNull();\\n        if (variables != null) {\\n            Object[] args = new Object[]{ variables };\\n            cs = new StatementSession(StatementTypes.DECLARE_VARIABLE, args);\\n            return cs;\\n        }\\n        cs = compileDeclareCursor(false, null);\\n        return cs;\\n    }\\n    private Statement compileScript() {\\n        String name = null;\\n        read();\\n        if (token.tokenType == Tokens.X_VALUE) {\\n            name = readQuotedString();\\n        }\\n        HsqlName[] names =\\n            database.schemaManager.getCatalogAndBaseTableNames();\\n        Object[] args = new Object[]{ name };\\n        return new StatementCommand(StatementTypes.DATABASE_SCRIPT, args,\\n                                    null, names);\\n    }\\n    private Statement compileConnect() {\\n        String userName;\\n        String password = null;\\n        read();\\n        readThis(Tokens.USER);\\n        checkIsSimpleName();\\n        userName = token.tokenString;\\n        read();\\n        if (!session.isProcessingLog) {\\n            readThis(Tokens.PASSWORD);\\n            password = readPassword();\\n        }\\n        Expression[] args = new Expression[] {\\n            new ExpressionValue(userName, Type.SQL_VARCHAR),\\n            new ExpressionValue(password, Type.SQL_VARCHAR)\\n        };\\n        Statement cs =\\n            new StatementSession(StatementTypes.SET_SESSION_AUTHORIZATION,\\n                                 args);\\n        return cs;\\n    }\\n    private StatementCommand compileSetDefault() {\\n        read();\\n        switch (token.tokenType) {\\n            case Tokens.INITIAL : {\\n                read();\\n                readThis(Tokens.SCHEMA);\\n                HsqlName schema = database.schemaManager.getSchemaHsqlName(\\n                    token.tokenString);\\n                read();\\n                Object[] args = new Object[]{ schema };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_DEFAULT_INITIAL_SCHEMA, args);\\n            }\\n            case Tokens.RESULT : {\\n                read();\\n                readThis(Tokens.MEMORY);\\n                readThis(Tokens.ROWS);\\n                Integer  size = readIntegerObject();\\n                Object[] args = new Object[]{ size };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_RESULT_MEMORY_ROWS, args);\\n            }\\n            case Tokens.TABLE : {\\n                read();\\n                readThis(Tokens.TYPE);\\n                int type = TableBase.MEMORY_TABLE;\\n                switch (token.tokenType) {\\n                    case Tokens.MEMORY :\\n                        break;\\n                    case Tokens.CACHED :\\n                        type = TableBase.CACHED_TABLE;\\n                        break;\\n                    default :\\n                        throw unexpectedToken();\\n                }\\n                read();\\n                Object[] args = new Object[]{ ValuePool.getInt(type) };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_DEFAULT_TABLE_TYPE, args);\\n            }\\n            case Tokens.ISOLATION : {\\n                read();\\n                readThis(Tokens.LEVEL);\\n                int level;\\n                switch (token.tokenType) {\\n                    case Tokens.READ :\\n                        read();\\n                        readThis(Tokens.COMMITTED);\\n                        level = SessionInterface.TX_READ_COMMITTED;\\n                        break;\\n                    case Tokens.SERIALIZABLE :\\n                        read();\\n                        level = SessionInterface.TX_SERIALIZABLE;\\n                        break;\\n                    default :\\n                        throw unexpectedToken();\\n                }\\n                read();\\n                Object[] args = new Object[]{ ValuePool.getInt(level) };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_DEFAULT_ISOLATION_LEVEL, args);\\n            }\\n            default :\\n                throw unexpectedToken();\\n        }\\n    }\\n    private StatementCommand compileSetProperty() {\\n        read();\\n        String                 property;\\n        Object                 value;\\n        HsqlDatabaseProperties props = database.getProperties();\\n        checkIsSimpleName();\\n        checkIsDelimitedIdentifier();\\n        property = token.tokenString;\\n        boolean isboolean  = props.isBoolean(token.tokenString);\\n        boolean isintegral = props.isIntegral(token.tokenString);\\n        boolean isstring   = props.isString(token.tokenString);\\n        if (!(isboolean || isintegral || isstring)) {\\n            throw Error.error(ErrorCode.X_42555, property);\\n        }\\n        int typeCode = isboolean ? Types.SQL_BOOLEAN\\n                                 : isintegral ? Types.SQL_INTEGER\\n                                              : Types.SQL_CHAR;\\n        read();\\n        if (token.tokenType == Tokens.TRUE) {\\n            value = Boolean.TRUE;\\n            if (!isboolean) {\\n                throw Error.error(ErrorCode.X_42563, token.tokenString);\\n            }\\n        } else if (token.tokenType == Tokens.FALSE) {\\n            value = Boolean.FALSE;\\n            if (!isboolean) {\\n                throw Error.error(ErrorCode.X_42563, token.tokenString);\\n            }\\n        } else {\\n            checkIsValue();\\n            value = token.tokenValue;\\n            if (token.dataType.typeCode != typeCode) {\\n                throw Error.error(ErrorCode.X_42563, token.tokenString);\\n            }\\n        }\\n        read();\\n        Object[] args = new Object[] {\\n            property, value\\n        };\\n        return new StatementCommand(StatementTypes.SET_DATABASE_PROPERTY,\\n                                    args);\\n    }\\n    private Statement compileSet() {\\n        int position = super.getPosition();\\n        session.setScripting(false);\\n        read();\\n        switch (token.tokenType) {\\n            case Tokens.CATALOG : {\\n                read();\\n                Expression e = XreadValueSpecificationOrNull();\\n                if (e == null) {\\n                    HsqlName name = readSchemaName();\\n                    Object[] args = new Object[]{ name };\\n                    return new StatementSession(StatementTypes.SET_CATALOG,\\n                                                args);\\n                }\\n                if (!e.getDataType().isCharacterType()) {\\n                    throw Error.error(ErrorCode.X_0P000);\\n                }\\n                if (e.getType() != OpTypes.VALUE\\n                        && (e.getType() != OpTypes.SQL_FUNCTION\\n                            || !((FunctionSQL) e).isValueFunction())) {\\n                    throw Error.error(ErrorCode.X_0P000);\\n                }\\n                Expression[] args = new Expression[]{ e };\\n                return new StatementSession(StatementTypes.SET_CATALOG, args);\\n            }\\n            case Tokens.SCHEMA : {\\n                read();\\n                Expression e = XreadValueSpecificationOrNull();\\n                if (e == null) {\\n                    HsqlName name = readSchemaName();\\n                    Object[] args = new Object[]{ name };\\n                    return new StatementSession(StatementTypes.SET_SCHEMA,\\n                                                args);\\n                }\\n                if (!e.getDataType().isCharacterType()) {\\n                    throw Error.error(ErrorCode.X_0P000);\\n                }\\n                if (e.getType() != OpTypes.VALUE\\n                        && (e.getType() != OpTypes.SQL_FUNCTION\\n                            || !((FunctionSQL) e).isValueFunction())) {\\n                    throw Error.error(ErrorCode.X_0P000);\\n                }\\n                Expression[] args = new Expression[]{ e };\\n                return new StatementSession(StatementTypes.SET_SCHEMA, args);\\n            }\\n            case Tokens.NO : {\\n                read();\\n                readThis(Tokens.COLLATION);\\n                HsqlArrayList charsets = null;\\n                if (readIfThis(Tokens.FOR)) {\\n                    charsets = new HsqlArrayList();\\n                    while (true) {\\n                        SchemaObject charset =\\n                            readSchemaObjectName(SchemaObject.CHARSET);\\n                        charsets.add(charset);\\n                        if (token.tokenType == Tokens.COMMA) {\\n                            read();\\n                            continue;\\n                        }\\n                        break;\\n                    }\\n                }\\n                Object[] args = new Object[] {\\n                    null, Boolean.FALSE, charsets\\n                };\\n                return new StatementSession(StatementTypes.SET_COLLATION,\\n                                            args);\\n            }\\n            case Tokens.COLLATION : {\\n                read();\\n                Expression e = XreadValueSpecificationOrNull();\\n                if (e == null || !e.getDataType().isCharacterType()) {\\n                    throw Error.error(ErrorCode.X_2H000);\\n                }\\n                HsqlArrayList charsets = null;\\n                if (readIfThis(Tokens.FOR)) {\\n                    charsets = new HsqlArrayList();\\n                    while (true) {\\n                        SchemaObject charset =\\n                            readSchemaObjectName(SchemaObject.CHARSET);\\n                        charsets.add(charset);\\n                        if (token.tokenType == Tokens.COMMA) {\\n                            read();\\n                            continue;\\n                        }\\n                        break;\\n                    }\\n                }\\n                Object[] args = new Object[] {\\n                    e, Boolean.TRUE, charsets\\n                };\\n                return new StatementSession(StatementTypes.SET_COLLATION,\\n                                            args);\\n            }\\n            case Tokens.TIME : {\\n                read();\\n                return compileSetTimeZone();\\n            }\\n            case Tokens.ROLE : {\\n                read();\\n                return compileSetRole();\\n            }\\n            case Tokens.SESSION : {\\n                read();\\n                return compileSessionSettings();\\n            }\\n            case Tokens.TRANSACTION : {\\n                read();\\n                Object[] args = processTransactionCharacteristics();\\n                if (args[0] == null && args[1] == null) {\\n                    throw unexpectedToken();\\n                }\\n                return new StatementSession(StatementTypes.SET_TRANSACTION,\\n                                            args);\\n            }\\n            case Tokens.AUTOCOMMIT : {\\n                read();\\n                Boolean  mode = processTrueOrFalseObject();\\n                Object[] args = new Object[]{ mode };\\n                return new StatementSession(\\n                    StatementTypes.SET_SESSION_AUTOCOMMIT, args);\\n            }\\n                        case Tokens.READONLY : {\\n                read();\\n                Boolean  readonly = processTrueOrFalseObject();\\n                Object[] args     = new Object[]{ readonly };\\n                return new StatementSession(\\n                    StatementTypes.SET_SESSION_CHARACTERISTICS, args);\\n            }\\n            case Tokens.IGNORECASE : {\\n                read();\\n                Boolean  mode = processTrueOrFalseObject();\\n                Object[] args = new Object[]{ mode };\\n                return new StatementSession(\\n                    StatementTypes.SET_SESSION_SQL_IGNORECASE, args);\\n            }\\n            case Tokens.MAXROWS : {\\n                read();\\n                Integer  size = readIntegerObject();\\n                Object[] args = new Object[]{ size };\\n                return new StatementSession(\\n                    StatementTypes.SET_SESSION_RESULT_MAX_ROWS, args);\\n            }\\n                        case Tokens.DEFAULT : {\\n                read();\\n                readThis(Tokens.TABLE);\\n                readThis(Tokens.TYPE);\\n                int type = TableBase.MEMORY_TABLE;\\n                switch (token.tokenType) {\\n                    case Tokens.MEMORY :\\n                        break;\\n                    case Tokens.CACHED :\\n                        type = TableBase.CACHED_TABLE;\\n                        break;\\n                    default :\\n                        throw unexpectedToken();\\n                }\\n                read();\\n                Object[] args = new Object[]{ ValuePool.getInt(type) };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_DEFAULT_TABLE_TYPE, args);\\n            }\\n            case Tokens.TABLE : {\\n                read();\\n                Table    t    = readTableName();\\n                Object[] args = new Object[] {\\n                    t.getName(), null\\n                };\\n                switch (token.tokenType) {\\n                    default : {\\n                        throw unexpectedToken();\\n                    }\\n                    case Tokens.SOURCE :\\n                        read();\\n                        return compileTableSource(t);\\n                    case Tokens.READ : {\\n                        read();\\n                        boolean readonly = false;\\n                        if (token.tokenType == Tokens.WRITE) {\\n                            read();\\n                        } else {\\n                            readThis(Tokens.ONLY);\\n                            readonly = true;\\n                        }\\n                        args[1] = Boolean.valueOf(readonly);\\n                        return new StatementCommand(\\n                            StatementTypes.SET_TABLE_READONLY, args, null,\\n                            new HsqlName[]{ t.getName() });\\n                    }\\n                                        case Tokens.READONLY : {\\n                        read();\\n                        Boolean readonly = processTrueOrFalseObject();\\n                        args[1] = readonly;\\n                        return new StatementCommand(\\n                            StatementTypes.SET_TABLE_READONLY, args, null,\\n                            new HsqlName[]{ t.getName() });\\n                    }\\n                    case Tokens.INDEX : {\\n                        String value;\\n                        read();\\n                        checkIsValue();\\n                        value = token.tokenString;\\n                        read();\\n                        args[1] = value;\\n                        return new StatementCommand(\\n                            StatementTypes.SET_TABLE_INDEX, args, null,\\n                            new HsqlName[]{ t.getName() });\\n                    }\\n                    case Tokens.TYPE : {\\n                        read();\\n                        int newType;\\n                        if (token.tokenType == Tokens.CACHED) {\\n                            newType = TableBase.CACHED_TABLE;\\n                        } else if (token.tokenType == Tokens.MEMORY) {\\n                            newType = TableBase.MEMORY_TABLE;\\n                        } else {\\n                            throw super.unexpectedToken();\\n                        }\\n                        read();\\n                        args[1] = new Integer(newType);\\n                        return new StatementCommand(\\n                            StatementTypes.SET_TABLE_TYPE, args, null,\\n                            new HsqlName[]{ t.getName() });\\n                    }\\n                    case Tokens.CLUSTERED : {\\n                        read();\\n                        readThis(Tokens.ON);\\n                        OrderedHashSet set = new OrderedHashSet();\\n                        readThis(Tokens.OPENBRACKET);\\n                        readSimpleColumnNames(set, t);\\n                        readThis(Tokens.CLOSEBRACKET);\\n                        int[] colIndex = t.getColumnIndexes(set);\\n                        args[1] = colIndex;\\n                        return new StatementCommand(\\n                            StatementTypes.SET_TABLE_CLUSTERED, args, null,\\n                            new HsqlName[]{ t.getName() });\\n                    }\\n                }\\n            }\\n            case Tokens.WRITE_DELAY : {\\n                read();\\n                int delay = 0;\\n                if (token.tokenType == Tokens.TRUE) {\\n                    delay = database.getProperties().getDefaultWriteDelay();\\n                    read();\\n                } else if (token.tokenType == Tokens.FALSE) {\\n                    delay = 0;\\n                    read();\\n                } else {\\n                    delay = this.readInteger();\\n                    if (delay < 0) {\\n                        delay = 0;\\n                    }\\n                    if (token.tokenType == Tokens.MILLIS) {\\n                        read();\\n                    } else {\\n                        delay *= 1000;\\n                    }\\n                }\\n                Object[] args = new Object[]{ new Integer(delay) };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_FILES_WRITE_DELAY, args, null,\\n                    null);\\n            }\\n            case Tokens.PASSWORD : {\\n                String password;\\n                read();\\n                password = readPassword();\\n                Object[] args = new Object[] {\\n                    null, password\\n                };\\n                return new StatementCommand(StatementTypes.SET_USER_PASSWORD,\\n                                            args);\\n            }\\n            case Tokens.INITIAL : {\\n                read();\\n                readThis(Tokens.SCHEMA);\\n                HsqlName schema;\\n                if (token.tokenType == Tokens.DEFAULT) {\\n                    schema = null;\\n                } else {\\n                    schema = database.schemaManager.getSchemaHsqlName(\\n                        token.tokenString);\\n                }\\n                read();\\n                Object[] args = new Object[] {\\n                    null, schema\\n                };\\n                return new StatementCommand(\\n                    StatementTypes.SET_USER_INITIAL_SCHEMA, args);\\n            }\\n            case Tokens.FILES : {\\n                return compileSetFilesProperty();\\n            }\\n            case Tokens.DATABASE : {\\n                return compileSetDatabaseProperty();\\n            }\\n            case Tokens.PROPERTY : {\\n                return compileSetProperty();\\n            }\\n            default : {\\n                rewind(position);\\n                return compileSetStatement(\\n                    session.sessionContext.sessionVariablesRange);\\n            }\\n        }\\n    }\\n    StatementCommand compileSetDatabaseProperty() {\\n        read();\\n        String name;\\n        checkDatabaseUpdateAuthorisation();\\n        switch (token.tokenType) {\\n            case Tokens.AUTHENTICATION : {\\n                read();\\n                readThis(Tokens.FUNCTION);\\n                Routine  routine = readCreateDatabaseAuthenticationFunction();\\n                Object[] args    = new Object[]{ routine };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_AUTHENTICATION, args, null,\\n                    null);\\n            }\\n            case Tokens.COLLATION : {\\n                read();\\n                checkIsSimpleName();\\n                name = token.tokenString;\\n                read();\\n                Object[] args = new Object[]{ name };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_SQL_COLLATION, args, null,\\n                    null);\\n            }\\n            case Tokens.DEFAULT : {\\n                return compileSetDefault();\\n            }\\n            case Tokens.EVENT : {\\n                read();\\n                readThis(Tokens.LOG);\\n                readThis(Tokens.LEVEL);\\n                Integer  value = readIntegerObject();\\n                Object[] args  = new Object[]{ value };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_FILES_EVENT_LOG, args, null,\\n                    null);\\n            }\\n            case Tokens.GC : {\\n                read();\\n                Integer  size = readIntegerObject();\\n                Object[] args = new Object[]{ size };\\n                return new StatementCommand(StatementTypes.SET_DATABASE_GC,\\n                                            args, null, null);\\n            }\\n            case Tokens.PASSWORD : {\\n                read();\\n                readThis(Tokens.CHECK);\\n                readThis(Tokens.FUNCTION);\\n                Routine  routine = readCreatePasswordCheckFunction();\\n                Object[] args    = new Object[]{ routine };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_PASSWORD_CHECK, args, null,\\n                    null);\\n            }\\n            case Tokens.REFERENTIAL : {\\n                read();\\n                readThis(Tokens.INTEGRITY);\\n                boolean  mode = processTrueOrFalse();\\n                Object[] args = new Object[]{ Boolean.valueOf(mode) };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_SQL_REFERENTIAL_INTEGRITY,\\n                    args, null, null);\\n            }\\n            case Tokens.SQL : {\\n                read();\\n                int     type     = StatementTypes.SET_DATABASE_SQL;\\n                Boolean flag     = null;\\n                String  property = null;\\n                switch (token.tokenType) {\\n                    case Tokens.NAMES :\\n                        read();\\n                        property = HsqlDatabaseProperties.sql_enforce_names;\\n                        flag     = processTrueOrFalseObject();\\n                        break;\\n                    case Tokens.REFERENCES :\\n                        read();\\n                        flag     = processTrueOrFalseObject();\\n                        property = HsqlDatabaseProperties.sql_enforce_refs;\\n                        break;\\n                    case Tokens.SIZE :\\n                        read();\\n                        flag     = processTrueOrFalseObject();\\n                        property = HsqlDatabaseProperties.sql_enforce_size;\\n                        break;\\n                    case Tokens.TYPES :\\n                        read();\\n                        flag     = processTrueOrFalseObject();\\n                        property = HsqlDatabaseProperties.sql_enforce_types;\\n                        break;\\n                    case Tokens.TDC :\\n                        read();\\n                        if (readIfThis(Tokens.DELETE)) {\\n                            property = HsqlDatabaseProperties.sql_enforce_tdcd;\\n                        } else {\\n                            readThis(Tokens.UPDATE);\\n                            property = HsqlDatabaseProperties.sql_enforce_tdcu;\\n                        }\\n                        flag = processTrueOrFalseObject();\\n                        break;\\n                    case Tokens.TRANSLATE :\\n                        read();\\n                        readThis(Tokens.TTI);\\n                        readThis(Tokens.TYPES);\\n                        flag = processTrueOrFalseObject();\\n                        property =\\n                            HsqlDatabaseProperties.jdbc_translate_tti_types;\\n                        break;\\n                    case Tokens.CONCAT_WORD :\\n                        read();\\n                        readThis(Tokens.NULLS);\\n                        flag     = processTrueOrFalseObject();\\n                        property = HsqlDatabaseProperties.sql_concat_nulls;\\n                        break;\\n                    case Tokens.UNIQUE :\\n                        read();\\n                        readThis(Tokens.NULLS);\\n                        flag     = processTrueOrFalseObject();\\n                        property = HsqlDatabaseProperties.sql_unique_nulls;\\n                        break;\\n                    case Tokens.CONVERT :\\n                        read();\\n                        readThis(Tokens.TRUNCATE);\\n                        flag     = processTrueOrFalseObject();\\n                        property = HsqlDatabaseProperties.sql_convert_trunc;\\n                        break;\\n                    case Tokens.DOUBLE :\\n                        read();\\n                        readThis(Tokens.NAN);\\n                        flag     = processTrueOrFalseObject();\\n                        property = HsqlDatabaseProperties.sql_double_nan;\\n                        break;\\n                    case Tokens.LONGVAR :\\n                        read();\\n                        readThis(Tokens.IS);\\n                        readThis(Tokens.LOB);\\n                        flag     = processTrueOrFalseObject();\\n                        property = HsqlDatabaseProperties.sql_longvar_is_lob;\\n                        break;\\n                    case Tokens.SYNTAX :\\n                        read();\\n                        if (token.tokenString.equals(Tokens.T_ORA)) {\\n                            read();\\n                            property = HsqlDatabaseProperties.sql_syntax_ora;\\n                        } else if (token.tokenString.equals(Tokens.T_MSS)) {\\n                            read();\\n                            property = HsqlDatabaseProperties.sql_syntax_mss;\\n                        } else if (token.tokenString.equals(Tokens.T_MYS)) {\\n                            read();\\n                            property = HsqlDatabaseProperties.sql_syntax_mys;\\n                        } else if (token.tokenString.equals(Tokens.T_PGS)) {\\n                            read();\\n                            property = HsqlDatabaseProperties.sql_syntax_pgs;\\n                        } else {\\n                            throw unexpectedToken();\\n                        }\\n                        flag = processTrueOrFalseObject();\\n                        break;\\n                    default :\\n                        throw unexpectedToken();\\n                }\\n                Object[] args = new Object[] {\\n                    property, flag\\n                };\\n                return new StatementCommand(type, args, null, null);\\n            }\\n            case Tokens.TEXT : {\\n                read();\\n                readThis(Tokens.TABLE);\\n                readThis(Tokens.DEFAULTS);\\n                String   source = readQuotedString();\\n                Object[] args   = new Object[]{ source };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_TEXT_SOURCE, args, null, null);\\n            }\\n            case Tokens.TRANSACTION : {\\n                read();\\n                if (readIfThis(Tokens.ROLLBACK)) {\\n                    readThis(Tokens.ON);\\n                    readThis(Tokens.DEADLOCK);\\n                    Boolean mode = processTrueOrFalseObject();\\n                    StatementCommand cs = new StatementCommand(\\n                        StatementTypes.SET_DATABASE_TRANSACTION_DEADLOCK,\\n                        new Object[]{ mode }, null, null);\\n                    return cs;\\n                }\\n                readThis(Tokens.CONTROL);\\n                int mode = TransactionManager.LOCKS;\\n                switch (token.tokenType) {\\n                    case Tokens.MVCC :\\n                        read();\\n                        mode = TransactionManager.MVCC;\\n                        break;\\n                    case Tokens.MVLOCKS :\\n                        read();\\n                        mode = TransactionManager.MVLOCKS;\\n                        break;\\n                    case Tokens.LOCKS :\\n                        read();\\n                        mode = TransactionManager.LOCKS;\\n                        break;\\n                }\\n                HsqlName[] names =\\n                    database.schemaManager.getCatalogAndBaseTableNames();\\n                Object[] args = new Object[]{ ValuePool.getInt(mode) };\\n                StatementCommand cs = new StatementCommand(\\n                    StatementTypes.SET_DATABASE_TRANSACTION_CONTROL, args,\\n                    null, names);\\n                return cs;\\n            }\\n            case Tokens.UNIQUE : {\\n                read();\\n                readThis(Tokens.NAME);\\n                isUndelimitedSimpleName();\\n                name = token.tokenString;\\n                read();\\n                if (name.length() != 16) {\\n                    throw Error.error(ErrorCode.X_42555);\\n                }\\n                if (!Charset.isInSet(name, Charset.unquotedIdentifier)\\n                        || !Charset.startsWith(name,\\n                                               Charset.uppercaseLetters)) {\\n                    throw Error.error(ErrorCode.X_42501);\\n                }\\n                Object[] args = new Object[]{ name };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_UNIQUE_NAME, args, null, null);\\n            }\\n            default : {\\n                throw unexpectedToken();\\n            }\\n        }\\n    }\\n    StatementCommand compileSetFilesProperty() {\\n        read();\\n        String  name;\\n        int     type  = 0;\\n        Boolean flag  = null;\\n        Integer value = null;\\n        checkDatabaseUpdateAuthorisation();\\n        switch (token.tokenType) {\\n            case Tokens.LOCK : {\\n                read();\\n                flag = processTrueOrFalseObject();\\n                type = StatementTypes.SET_DATABASE_FILES_LOCK;\\n                break;\\n            }\\n            case Tokens.CACHE : {\\n                read();\\n                if (readIfThis(Tokens.SIZE)) {\\n                    value = readIntegerObject();\\n                    type  = StatementTypes.SET_DATABASE_FILES_CACHE_SIZE;\\n                } else {\\n                    readThis(Tokens.ROWS);\\n                    value = readIntegerObject();\\n                    type  = StatementTypes.SET_DATABASE_FILES_CACHE_ROWS;\\n                }\\n                break;\\n            }\\n            case Tokens.SCALE : {\\n                read();\\n                value = readIntegerObject();\\n                type  = StatementTypes.SET_DATABASE_FILES_SCALE;\\n                break;\\n            }\\n            case Tokens.LOB : {\\n                read();\\n                readThis(Tokens.SCALE);\\n                value = readIntegerObject();\\n                type  = StatementTypes.SET_DATABASE_FILES_LOBS_SCALE;\\n                break;\\n            }\\n            case Tokens.DEFRAG : {\\n                read();\\n                type  = StatementTypes.SET_DATABASE_FILES_DEFRAG;\\n                value = readIntegerObject();\\n                break;\\n            }\\n            case Tokens.NIO : {\\n                read();\\n                if (readIfThis(Tokens.SIZE)) {\\n                    value = readIntegerObject();\\n                } else {\\n                    flag = processTrueOrFalseObject();\\n                }\\n                type = StatementTypes.SET_DATABASE_FILES_NIO;\\n                break;\\n            }\\n            case Tokens.BACKUP : {\\n                read();\\n                type = StatementTypes.SET_DATABASE_FILES_BACKUP_INCREMENT;\\n                readThis(Tokens.INCREMENT);\\n                flag = processTrueOrFalseObject();\\n                break;\\n            }\\n            case Tokens.LOG : {\\n                read();\\n                if (readIfThis(Tokens.SIZE)) {\\n                    type  = StatementTypes.SET_DATABASE_FILES_LOG_SIZE;\\n                    value = readIntegerObject();\\n                } else {\\n                    type = StatementTypes.SET_DATABASE_FILES_LOG;\\n                    flag = processTrueOrFalseObject();\\n                }\\n                break;\\n            }\\n            case Tokens.TEMP : {\\n                read();\\n                readThis(Tokens.PATH);\\n                type  = StatementTypes.SET_DATABASE_FILES_TEMP_PATH;\\n                value = readIntegerObject();\\n                break;\\n            }\\n            case Tokens.WRITE : {\\n                read();\\n                readThis(Tokens.DELAY);\\n                type = StatementTypes.SET_DATABASE_FILES_WRITE_DELAY;\\n                int delay = 0;\\n                if (token.tokenType == Tokens.TRUE) {\\n                    delay = database.getProperties().getDefaultWriteDelay();\\n                    read();\\n                } else if (token.tokenType == Tokens.FALSE) {\\n                    delay = 0;\\n                    read();\\n                } else {\\n                    delay = this.readInteger();\\n                    if (delay < 0) {\\n                        delay = 0;\\n                    }\\n                    if (token.tokenType == Tokens.MILLIS) {\\n                        read();\\n                    } else {\\n                        delay *= 1000;\\n                    }\\n                }\\n                value = new Integer(delay);\\n                break;\\n            }\\n            case Tokens.SCRIPT : {\\n                read();\\n                readThis(Tokens.FORMAT);\\n                if (token.tokenType == Tokens.TEXT) {\\n                    read();\\n                    value = new Integer(0);\\n                } else {\\n                    readThis(Tokens.COMPRESSED);\\n                    value = new Integer(3);\\n                }\\n                type = StatementTypes.SET_DATABASE_FILES_SCRIPT_FORMAT;\\n                break;\\n            }\\n            default :\\n                throw unexpectedToken();\\n        }\\n        Object[] args = new Object[]{ flag == null ? (Object) value\\n                                                   : (Object) flag };\\n        return new StatementCommand(\\n            type, args, null, database.schemaManager.getCatalogNameArray());\\n    }\\n    Object[] processTransactionCharacteristics() {\\n        int      level    = 0;\\n        boolean  readonly = false;\\n        Object[] args     = new Object[2];\\n        outerloop:\\n        while (true) {\\n            switch (token.tokenType) {\\n                case Tokens.READ : {\\n                    if (args[0] != null) {\\n                        throw unexpectedToken();\\n                    }\\n                    read();\\n                    if (token.tokenType == Tokens.ONLY) {\\n                        read();\\n                        readonly = true;\\n                    } else {\\n                        readThis(Tokens.WRITE);\\n                        readonly = false;\\n                    }\\n                    args[0] = Boolean.valueOf(readonly);\\n                    break;\\n                }\\n                case Tokens.ISOLATION : {\\n                    if (args[1] != null) {\\n                        throw unexpectedToken();\\n                    }\\n                    read();\\n                    readThis(Tokens.LEVEL);\\n                    switch (token.tokenType) {\\n                        case Tokens.SERIALIZABLE :\\n                            read();\\n                            level = SessionInterface.TX_SERIALIZABLE;\\n                            break;\\n                        case Tokens.READ :\\n                            read();\\n                            if (token.tokenType == Tokens.COMMITTED) {\\n                                read();\\n                                level = SessionInterface.TX_READ_COMMITTED;\\n                            } else if (token.tokenType == Tokens.UNCOMMITTED) {\\n                                read();\\n                                level = SessionInterface.TX_READ_UNCOMMITTED;\\n                            } else {\\n                                throw unexpectedToken();\\n                            }\\n                            break;\\n                        case Tokens.REPEATABLE :\\n                            read();\\n                            readThis(Tokens.READ);\\n                            level = SessionInterface.TX_REPEATABLE_READ;\\n                            break;\\n                        default :\\n                            throw unexpectedToken();\\n                    }\\n                    args[1] = new Integer(level);\\n                    break;\\n                }\\n                case Tokens.COMMA : {\\n                    if (args[0] == null && args[1] == null) {\\n                        throw unexpectedToken();\\n                    }\\n                    read();\\n                    break;\\n                }\\n                default : {\\n                    break outerloop;\\n                }\\n            }\\n        }\\n        if (!readonly && level == 1) {\\n            throw unexpectedToken(Tokens.T_WRITE);\\n        }\\n        return args;\\n    }\\n    private Statement compileCommit() {\\n        boolean chain = false;\\n        read();\\n        readIfThis(Tokens.WORK);\\n        if (token.tokenType == Tokens.AND) {\\n            read();\\n            if (token.tokenType == Tokens.NO) {\\n                read();\\n            } else {\\n                chain = true;\\n            }\\n            readThis(Tokens.CHAIN);\\n        }\\n        String    sql  = getLastPart();\\n        Object[]  args = new Object[]{ Boolean.valueOf(chain) };\\n        Statement cs = new StatementSession(StatementTypes.COMMIT_WORK, args);\\n        return cs;\\n    }\\n    private Statement compileStartTransaction() {\\n        read();\\n        readThis(Tokens.TRANSACTION);\\n        Object[] args = processTransactionCharacteristics();\\n        Statement cs = new StatementSession(StatementTypes.START_TRANSACTION,\\n                                            args);\\n        return cs;\\n    }\\n    private Statement compileLock() {\\n        read();\\n        readThis(Tokens.TABLE);\\n        OrderedHashSet readSet  = new OrderedHashSet();\\n        OrderedHashSet writeSet = new OrderedHashSet();\\n        outerloop:\\n        while (true) {\\n            Table table = readTableName();\\n            switch (token.tokenType) {\\n                case Tokens.READ :\\n                    read();\\n                    readSet.add(table.getName());\\n                    break;\\n                case Tokens.WRITE :\\n                    read();\\n                    writeSet.add(table.getName());\\n                    break;\\n                default :\\n                    throw unexpectedToken();\\n            }\\n            if (token.tokenType == Tokens.COMMA) {\\n                read();\\n                continue;\\n            }\\n            break outerloop;\\n        }\\n        HsqlName[] writeTableNames = new HsqlName[writeSet.size()];\\n        writeSet.toArray(writeTableNames);\\n        readSet.removeAll(writeTableNames);\\n        HsqlName[] readTableNames = new HsqlName[readSet.size()];\\n        readSet.toArray(readTableNames);\\n        Statement cs =\\n            new StatementSession(StatementTypes.TRANSACTION_LOCK_TABLE,\\n                                 readTableNames, writeTableNames);\\n        return cs;\\n    }\\n    private Statement compileRollback() {\\n        boolean chain     = false;\\n        String  savepoint = null;\\n        read();\\n        if (token.tokenType == Tokens.TO) {\\n            read();\\n            readThis(Tokens.SAVEPOINT);\\n            checkIsSimpleName();\\n            savepoint = token.tokenString;\\n            read();\\n            String   sql  = getLastPart();\\n            Object[] args = new Object[]{ savepoint };\\n            Statement cs =\\n                new StatementSession(StatementTypes.ROLLBACK_SAVEPOINT, args);\\n            return cs;\\n        } else {\\n            if (token.tokenType == Tokens.WORK) {\\n                read();\\n            }\\n            if (token.tokenType == Tokens.AND) {\\n                read();\\n                if (token.tokenType == Tokens.NO) {\\n                    read();\\n                } else {\\n                    chain = true;\\n                }\\n                readThis(Tokens.CHAIN);\\n            }\\n        }\\n        String   sql  = getLastPart();\\n        Object[] args = new Object[]{ Boolean.valueOf(chain) };\\n        Statement cs = new StatementSession(StatementTypes.ROLLBACK_WORK,\\n                                            args);\\n        return cs;\\n    }\\n    private Statement compileSavepoint() {\\n        String name;\\n        read();\\n        checkIsSimpleName();\\n        name = token.tokenString;\\n        read();\\n        String   sql  = getLastPart();\\n        Object[] args = new Object[]{ name };\\n        return new StatementSession(StatementTypes.SAVEPOINT, args);\\n    }\\n    private Statement compileReleaseSavepoint() {\\n        read();\\n        readThis(Tokens.SAVEPOINT);\\n        String name = token.tokenString;\\n        read();\\n        String   sql  = getLastPart();\\n        Object[] args = new Object[]{ name };\\n        return new StatementSession(StatementTypes.RELEASE_SAVEPOINT, args);\\n    }\\n    private Statement compileSessionSettings() {\\n        switch (token.tokenType) {\\n            case Tokens.CHARACTERISTICS : {\\n                read();\\n                readThis(Tokens.AS);\\n                readThis(Tokens.TRANSACTION);\\n                Object[] args = processTransactionCharacteristics();\\n                return new StatementSession(\\n                    StatementTypes.SET_SESSION_CHARACTERISTICS, args);\\n            }\\n            case Tokens.AUTHORIZATION : {\\n                read();\\n                Expression e = XreadValueSpecificationOrNull();\\n                if (e == null) {\\n                    throw Error.error(ErrorCode.X_42584);\\n                }\\n                e.resolveTypes(session, null);\\n                if (e.isUnresolvedParam()) {\\n                    e.dataType = Type.SQL_VARCHAR;\\n                }\\n                if (e.dataType == null || !e.dataType.isCharacterType()) {\\n                    throw Error.error(ErrorCode.X_42563);\\n                }\\n                Expression[] args = new Expression[] {\\n                    e, null\\n                };\\n                return new StatementSession(\\n                    StatementTypes.SET_SESSION_AUTHORIZATION, args);\\n            }\\n            case Tokens.RESULT : {\\n                read();\\n                readThis(Tokens.MEMORY);\\n                readThis(Tokens.ROWS);\\n                Integer  size = readIntegerObject();\\n                Object[] args = new Object[]{ size };\\n                return new StatementSession(\\n                    StatementTypes.SET_SESSION_RESULT_MEMORY_ROWS, args);\\n            }\\n            default :\\n                throw unexpectedToken();\\n        }\\n    }\\n    private Statement compileSetRole() {\\n        Expression e;\\n        if (token.tokenType == Tokens.NONE) {\\n            read();\\n            e = new ExpressionValue(null, Type.SQL_VARCHAR);\\n        } else {\\n            e = XreadValueSpecificationOrNull();\\n            if (e == null) {\\n                throw Error.error(ErrorCode.X_2A000);\\n            }\\n            if (!e.getDataType().isCharacterType()) {\\n                throw Error.error(ErrorCode.X_0P000);\\n            }\\n            if (e.getType() != OpTypes.VALUE\\n                    && (e.getType() != OpTypes.SQL_FUNCTION\\n                        || !((FunctionSQL) e).isValueFunction())) {\\n                throw Error.error(ErrorCode.X_0P000);\\n            }\\n        }\\n        String sql = getLastPart();\\n        return new StatementSession(StatementTypes.SET_ROLE,\\n                                    new Expression[]{ e });\\n    }\\n    private Statement compileSetTimeZone() {\\n        Expression e;\\n        readThis(Tokens.ZONE);\\n        if (token.tokenType == Tokens.LOCAL) {\\n            read();\\n            e = new ExpressionValue(null, Type.SQL_INTERVAL_HOUR_TO_MINUTE);\\n        } else {\\n            e = XreadIntervalValueExpression();\\n            HsqlList unresolved = e.resolveColumnReferences(session,\\n                RangeVariable.emptyArray, null);\\n            ExpressionColumn.checkColumnsResolved(unresolved);\\n            e.resolveTypes(session, null);\\n            if (e.dataType == null) {\\n                throw Error.error(ErrorCode.X_42563);\\n            }\\n            if (e.dataType.typeCode != Types.SQL_INTERVAL_HOUR_TO_MINUTE) {\\n                throw Error.error(ErrorCode.X_42563);\\n            }\\n        }\\n        String sql = getLastPart();\\n        return new StatementSession(StatementTypes.SET_TIME_ZONE,\\n                                    new Expression[]{ e });\\n    }\\n    private Statement compileShutdown() {\\n        int closemode;\\n        session.checkAdmin();\\n        closemode = Database.CLOSEMODE_NORMAL;\\n        read();\\n        switch (token.tokenType) {\\n            case Tokens.IMMEDIATELY :\\n                closemode = Database.CLOSEMODE_IMMEDIATELY;\\n                read();\\n                break;\\n            case Tokens.COMPACT :\\n                closemode = Database.CLOSEMODE_COMPACT;\\n                read();\\n                break;\\n            case Tokens.SCRIPT :\\n                closemode = Database.CLOSEMODE_SCRIPT;\\n                read();\\n                break;\\n                    }\\n        if (token.tokenType == Tokens.SEMICOLON) {\\n            read();\\n        }\\n        if (token.tokenType != Tokens.X_ENDPARSE) {\\n            throw unexpectedToken();\\n        }\\n        String   sql  = getLastPart();\\n        Object[] args = new Object[]{ new Integer(closemode) };\\n        Statement cs = new StatementCommand(StatementTypes.DATABASE_SHUTDOWN,\\n                                            args, null, null);\\n        return cs;\\n    }\\n    private Statement compileBackup() {\\n        read();\\n        readThis(Tokens.DATABASE);\\n        readThis(Tokens.TO);\\n        String  path         = readQuotedString();\\n        Boolean blockingMode = null;            Boolean scriptMode   = null;            Boolean compression  = null;    \\n        outerLoop:\\n        while (true) {\\n            switch (token.tokenType) {\\n                case Tokens.BLOCKING :\\n                    if (blockingMode != null) {\\n                        throw unexpectedToken();\\n                    }\\n                    blockingMode = Boolean.TRUE;\\n                    read();\\n                    break;\\n                case Tokens.SCRIPT :\\n                    if (scriptMode != null) {\\n                        throw unexpectedToken();\\n                    }\\n                    scriptMode = Boolean.TRUE;\\n                    read();\\n                    break;\\n                case Tokens.COMPRESSED :\\n                    if (compression != null) {\\n                        throw unexpectedToken();\\n                    }\\n                    compression = Boolean.TRUE;\\n                    read();\\n                    break;\\n                case Tokens.NOT :\\n                    read();\\n                    if (token.tokenType == Tokens.COMPRESSED) {\\n                        if (compression != null) {\\n                            throw unexpectedToken();\\n                        }\\n                        compression = Boolean.FALSE;\\n                        read();\\n                    } else if (token.tokenType == Tokens.BLOCKING) {\\n                        blockingMode = Boolean.FALSE;\\n                        read();\\n                    } else {\\n                        throw unexpectedToken();\\n                    }\\n                    break;\\n                default :\\n                    break outerLoop;\\n            }\\n        }\\n        if (scriptMode != null) {\\n            throw unsupportedFeature(\\\"SCRIPT\\\");\\n        }\\n        scriptMode = Boolean.FALSE;\\n        if (blockingMode == null) {\\n            throw unexpectedTokenRequire(\\\"BLOCKING\\\");\\n        }\\n        if (compression == null) {\\n            compression = Boolean.TRUE;\\n        }\\n        HsqlName[] names =\\n            database.schemaManager.getCatalogAndBaseTableNames();\\n        Object[] args = new Object[] {\\n            path, blockingMode, scriptMode, compression,\\n        };\\n        Statement cs = new StatementCommand(StatementTypes.DATABASE_BACKUP,\\n                                            args, null, names);\\n        return cs;\\n    }\\n    private Statement compileCheckpoint() {\\n        boolean defrag = false;\\n        read();\\n        if (token.tokenType == Tokens.DEFRAG) {\\n            defrag = true;\\n            read();\\n        } else if (token.tokenType == Tokens.SEMICOLON) {\\n            read();\\n                    }\\n        if (token.tokenType != Tokens.X_ENDPARSE) {\\n            throw unexpectedToken();\\n        }\\n        HsqlName[] names =\\n            database.schemaManager.getCatalogAndBaseTableNames();\\n        Object[] args = new Object[]{ Boolean.valueOf(defrag) };\\n        Statement cs = new StatementCommand(StatementTypes.DATABASE_CHECKPOINT,\\n                                            args, null, names);\\n        return cs;\\n    }\\n    public static Statement getAutoCheckpointStatement(Database database) {\\n        HsqlName[] names =\\n            database.schemaManager.getCatalogAndBaseTableNames();\\n        Object[] args = new Object[]{ Boolean.FALSE };\\n        Statement cs = new StatementCommand(StatementTypes.DATABASE_CHECKPOINT,\\n                                            args, null, names);\\n        cs.setCompileTimestamp(database.txManager.getGlobalChangeTimestamp());\\n        cs.setSQL(Tokens.T_CHECKPOINT);\\n        return cs;\\n    }\\n    private Statement compileDisconnect() {\\n        read();\\n        String sql = Tokens.T_DISCONNECT;\\n        Statement cs = new StatementSession(StatementTypes.DISCONNECT,\\n                                            (Object[]) null);\\n        return cs;\\n    }\\n    private Statement compileExplainPlan() {\\n        Statement cs;\\n        read();\\n        readThis(Tokens.PLAN);\\n        readThis(Tokens.FOR);\\n        cs = compilePart(ResultProperties.defaultPropsValue);\\n        cs.setDescribe();\\n        return cs;\\n    }\\n    private Statement compileTableSource(Table t) {\\n        boolean  isSourceHeader = false;\\n        boolean  isDesc         = false;\\n        String   source;\\n        Object[] args = new Object[5];\\n        args[0] = t.getName();\\n        if (!t.isText()) {\\n            Exception e = Error.error(ErrorCode.X_S0522);\\n        }\\n                if (token.tokenType == Tokens.ON) {\\n            read();\\n            String sql = getLastPart();\\n            args[1] = Boolean.TRUE;\\n            return new StatementCommand(StatementTypes.SET_TABLE_SOURCE, args,\\n                                        null, new HsqlName[]{ t.getName() });\\n        } else if (token.tokenType == Tokens.OFF) {\\n            read();\\n            String sql = getLastPart();\\n            args[1] = Boolean.FALSE;\\n            return new StatementCommand(StatementTypes.SET_TABLE_SOURCE, args,\\n                                        null, new HsqlName[]{ t.getName() });\\n        } else if (token.tokenType == Tokens.HEADER) {\\n            read();\\n            isSourceHeader = true;\\n        }\\n        if (token.tokenType == Tokens.X_DELIMITED_IDENTIFIER) {\\n            source = token.tokenString;\\n            read();\\n        } else {\\n            source = readQuotedString();\\n        }\\n        if (!isSourceHeader && token.tokenType == Tokens.DESC) {\\n            isDesc = true;\\n            read();\\n        }\\n        String sql = getLastPart();\\n        args[2] = source;\\n        args[3] = Boolean.valueOf(isDesc);\\n        args[4] = Boolean.valueOf(isSourceHeader);\\n        int type = isSourceHeader ? StatementTypes.SET_TABLE_SOURCE_HEADER\\n                                  : StatementTypes.SET_TABLE_SOURCE;\\n        return new StatementCommand(type, args, null,\\n                                    new HsqlName[]{ t.getName() });\\n    }\\n}\""
        },
        {
            "content": "The code in `ParserCommand.java` confirms that it extends `ParserDDL`, which itself is part of the SQL parsing infrastructure. The class processes various types of SQL commands such as `SET`, `COMMIT`, `ROLLBACK`, `LOCK`, and others.\n\n### Key Observations:\n1. **Usage of Tokens**:\n   - There are several places where token constants like `Tokens.SET`, `Tokens.COMMIT`, `Tokens.ROLLBACK`, etc., are used.\n   - Example:\n     ```java\n     case Tokens.SET:\n         return compileSet();\n     ```\n\n2. **Command Handling Logic**:\n   - `ParserCommand` uses tokens to identify command types during parsing, suggesting a strong dependency on `Tokens.java`.\n\n3. **Consistency with Co-Change Relationship**:\n   - The high co-change confidence (0.477) between `Tokens.java` and `ParserCommand.java` aligns with the actual usage observed in the source code.\n\n---\n\n### Final Determination: Entities That Need Synchronization\n\nBased on our analysis of co-change relationships, call graphs, and direct source code inspection, we can confidently list the entities that should be synchronized when `Tokens.java` changes:\n\n#### \u2705 High Priority for Synchronization:\n1. **ParserDQL.java**  \n   - Strongest co-change relationship (confidence: 0.5227).\n   - Direct use of token constants (`SELECT`, `FROM`, `WHERE`, etc.) in parsing logic.\n\n2. **ParserCommand.java**  \n   - Second-highest co-change confidence (0.477).\n   - Uses many token definitions related to session commands (`SET`, `COMMIT`, `ROLLBACK`).\n\n3. **ParserDDL.java**  \n   - Part of the DDL parsing chain used by both `ParserDQL` and `ParserCommand`.\n   - Also shows a significant co-change confidence (0.3636).\n\n#### \u2705 Medium Priority for Synchronization:\n4. **Database.java**  \n   - Co-change support count = 17, confidence = 0.386.\n   - Likely involved in global token handling or SQL configuration.\n\n5. **Logger.java**, **Session.java**, **HsqlDatabaseProperties.java**  \n   - Moderate coupling; may handle logging, session state, or SQL dialect settings involving tokens.\n\n#### \u2705 Additional Entities Worth Reviewing:\n6. **StatementCommand.java**, **StatementDML.java**, **FunctionCustom.java**, **Expression.java**, **Table.java**, **Constraint.java**, **SchemaManager.java**, **ParserBase.java**, **StatementTypes.java**, **StatementSchema.java**, **StatementSession.java**, **SessionManager.java**, **UserManager.java**, **JDBCConnection.java**, **Log.java**, **ErrorCode.java**, **ScriptReaderText.java**, **ScriptWriterText.java**, **StringConverter.java**, **SortAndSlice.java**, **ExpressionColumn.java**, **Grantee.java**, **Routine.java**, **FunctionSQLInvoked.java**, **QuerySpecification.java**, **ParserRoutine.java**, **HsqlNameManager.java**, **CharacterType.java**, **NumberType.java**, **DateTimeType.java**, **ArrayType.java**, **ClobType.java**, **BlobType.java**\n\nThese additional entities appear in the co-change list with varying degrees of confidence and may warrant further inspection if changes in `Tokens.java` affect specific SQL constructs they rely on.\n\n---\n\n### Final Recommendation\n\nWhen modifying `Tokens.java`, you should **synchronize changes** with at least the following key files due to their high coupling and semantic similarity:\n\n- **ParserDQL.java**\n- **ParserCommand.java**\n- **ParserDDL.java**\n- **Database.java**\n- **Session.java**\n- **HsqlDatabaseProperties.java**\n\nThis ensures consistency in how SQL tokens are parsed and interpreted across the system.\n\nWould you like me to analyze one more entity (e.g., `ParserDDL.java`) to confirm its token usage?",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        },
        {
            "role": "user",
            "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
        },
        {
            "content": "Title: Diagnosis of starting entity `Tokens.java`  \nChange set: [ParserDQL.java, ParserCommand.java, Database.java, FunctionCustom.java, Logger.java, ParserDDL.java, StatementCommand.java, HsqlDatabaseProperties.java, Session.java, Routine.java, QuerySpecification.java, ExpressionColumn.java, Table.java, SchemaManager.java, StatementDML.java, UserManager.java, ParserBase.java, JDBCDriver.java, DataFileCache.java, StatementSchema.java, Expression.java, OpTypes.java, StatementTypes.java, CharacterType.java, NumberType.java, DateTimeType.java, ArrayType.java, ClobType.java, BlobType.java, Type.java, Types.java, ExpressionOp.java, SubQuery.java, ExpressionAggregate.java, ExpressionTable.java, Collation.java, StringUtil.java, StringConverter.java, SortAndSlice.java, ExpressionArrayAggregate.java, User.java, RangeVariableResolver.java, ScriptRunner.java, ScriptReaderText.java, ScriptWriterText.java, HsqlNameManager.java, Scanner.java, ErrorCode.java, LobManager.java, TransactionManagerMVCC.java]  \n\nDetails:  \n1. **ParserDQL.java**: Uses numerous token constants for parsing SQL queries (`SELECT`, `FROM`, etc.), and has a co-change confidence of 0.5227.  \n2. **ParserCommand.java**: Directly uses tokens like `SET`, `COMMIT`, `ROLLBACK`; co-change confidence = 0.4773.  \n3. **Database.java**: Manages global SQL settings and properties that may depend on token values; support count = 17, confidence = 0.386.  \n4. **FunctionCustom.java**: Handles custom function parsing which may involve token resolution; support count = 17, confidence = 0.386.  \n5. **Logger.java**: Likely logs SQL statements or errors using tokens; support count = 14, confidence = 0.318.  \n6. **ParserDDL.java**: Parses DDL commands involving tokens like `CREATE`, `ALTER`, `DROP`; support count = 16, confidence = 0.3636.  \n7. **StatementCommand.java**: Processes command-related SQL constructs; co-change relationship is significant.  \n8. **HsqlDatabaseProperties.java**: Manages database-level properties, some of which are tied to SQL syntax or token behavior.  \n9. **Session.java**: Handles session-specific SQL execution context, possibly relying on token definitions.  \n10. **Routine.java**: Involves stored routine parsing which often depends on SQL token definitions.  \n11. **QuerySpecification.java**: Used in query parsing and likely interacts with token-based expressions.  \n12. **ExpressionColumn.java**: Token usage occurs during column expression parsing.  \n13. **Table.java**: May use tokens in schema or constraint handling logic.  \n14. **SchemaManager.java**: Handles SQL schema objects and uses token-based identifiers.  \n15. **StatementDML.java**: Manages DML operations such as `INSERT`, `UPDATE`, `DELETE`.  \n16. **UserManager.java**: May handle authorization or user-defined SQL roles using tokens.  \n17. **ParserBase.java**: Base parser class\u2014likely contains shared token-handling logic.  \n18. **JDBCDriver.java**: JDBC interface layer that maps SQL tokens into Java types.  \n19. **DataFileCache.java**: Possibly involved in logging or scripting where token strings appear.  \n20. **StatementSchema.java**: Parses schema-related statements that include tokens.  \n21. **Expression.java**: Core class for representing parsed SQL expressions\u2014uses many token constants.  \n22. **OpTypes.java**: Defines operator types used alongside tokens for parsing and evaluation.  \n23. **StatementTypes.java**: Maps statement types using tokens\u2014strong semantic coupling.  \n24. **CharacterType.java**: Involved in character encoding/token mapping logic.  \n25. **NumberType.java**: Handles numeric literals, which are often tied to token definitions.  \n26. **DateTimeType.java**: Date/time SQL parsing involves specific token recognition.  \n27. **ArrayType.java**: Array-related SQL syntax requires token parsing.  \n28. **ClobType.java**, **BlobType.java**: LOB types have associated SQL syntax and token keywords.  \n29. **Type.java**, **Types.java**: Central to type parsing, which is tightly coupled with token usage.  \n30. **ExpressionOp.java**: Contains operators that map directly to token types.  \n31. **SubQuery.java**: Subquery parsing involves token-based clause detection.  \n32. **ExpressionAggregate.java**: Aggregation functions rely on token constants like `SUM`, `AVG`.  \n33. **ExpressionTable.java**: Used for table subquery processing and references tokens.  \n34. **Collation.java**: Parsing collation clauses involves token constants like `COLLATE`.  \n35. **StringUtil.java**: May be used for string manipulation related to token names.  \n36. **StringConverter.java**: Converts between SQL and Java types\u2014uses token-based directives.  \n37. **SortAndSlice.java**: Involves `ORDER BY`, `LIMIT`, and other token-based constructs.  \n38. **ExpressionArrayAggregate.java**: Related to array aggregation syntax involving tokens.  \n39. **User.java**: Authorization logic may parse SQL privilege tokens.  \n40. **RangeVariableResolver.java**: Resolves variable references during parsing\u2014token interaction likely.  \n41. **ScriptRunner.java**, **ScriptReaderText.java**, **ScriptWriterText.java**: Handle SQL scripts and therefore use token definitions.  \n42. **HsqlNameManager.java**: Name resolution may interact with token constants.  \n43. **Scanner.java**: Token scanner core component\u2014direct dependency expected.  \n44. **ErrorCode.java**: Error messages may reference tokens explicitly.  \n45. **LobManager.java**: LOB-related SQL syntax involves token parsing.  \n46. **TransactionManagerMVCC.java**: Transaction control may use SQL token constants.",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        }
    ],
    "interaction_records": {
        "step_histories": [
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4"
                ],
                "response_message": "m5"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6"
                ],
                "response_message": "m7"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8"
                ],
                "response_message": "m9"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10"
                ],
                "response_message": "m11"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12"
                ],
                "response_message": "m13"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14"
                ],
                "response_message": "m15"
            }
        ],
        "mid_to_message": {
            "m1": {
                "role": "system",
                "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
            },
            "m2": {
                "role": "user",
                "content": "The project you need to analyze is `hsqldb`, a well-known Java open source project. The starting entity you need to deal with is Tokens.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
            },
            "m3": {
                "content": "",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_289f38fc58e14d3498a725",
                        "function": {
                            "arguments": "{\"entity\": \"Tokens.java\"}",
                            "name": "get_co_change_relationship"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m4": {
                "name": "get_co_change_relationship",
                "role": "tool",
                "content": "[[\"Log\", \"5\", \"0.11363636363636363\"], [\"ErrorCode\", \"3\", \"0.06818181818181818\"], [\"Session\", \"10\", \"0.22727272727272727\"], [\"Constraint\", \"3\", \"0.06818181818181818\"], [\"Table\", \"5\", \"0.11363636363636363\"], [\"HsqlDatabaseProperties\", \"10\", \"0.22727272727272727\"], [\"UserManager\", \"4\", \"0.09090909090909091\"], [\"ParserDDL\", \"16\", \"0.36363636363636365\"], [\"SessionManager\", \"1\", \"0.022727272727272728\"], [\"StatementDML\", \"3\", \"0.06818181818181818\"], [\"ParserCommand\", \"21\", \"0.4772727272727273\"], [\"CharacterType\", \"4\", \"0.09090909090909091\"], [\"SchemaManager\", \"6\", \"0.13636363636363635\"], [\"Database\", \"17\", \"0.38636363636363635\"], [\"Logger\", \"14\", \"0.3181818181818182\"], [\"ParserDML\", \"4\", \"0.09090909090909091\"], [\"NumberType\", \"3\", \"0.06818181818181818\"], [\"Grantee\", \"1\", \"0.022727272727272728\"], [\"Statement\", \"1\", \"0.022727272727272728\"], [\"ParserDQL\", \"23\", \"0.5227272727272727\"], [\"StatementCompound\", \"2\", \"0.045454545454545456\"], [\"StatementHandler\", \"1\", \"0.022727272727272728\"], [\"DatabaseInformationFull\", \"3\", \"0.06818181818181818\"], [\"JDBCConnection\", \"3\", \"0.06818181818181818\"], [\"Scanner\", \"4\", \"0.09090909090909091\"], [\"DateTimeType\", \"4\", \"0.09090909090909091\"], [\"DatabaseManager\", \"2\", \"0.045454545454545456\"], [\"IntervalType\", \"2\", \"0.045454545454545456\"], [\"DataFileCache\", \"9\", \"0.20454545454545456\"], [\"FunctionCustom\", \"17\", \"0.38636363636363635\"], [\"TestStoredProcedure\", \"2\", \"0.045454545454545456\"], [\"TransferHelper\", \"1\", \"0.022727272727272728\"], [\"TransferDb\", \"1\", \"0.022727272727272728\"], [\"TransferTable\", \"1\", \"0.022727272727272728\"], [\"Servlet\", \"1\", \"0.022727272727272728\"], [\"OpTypes\", \"6\", \"0.13636363636363635\"], [\"Routine\", \"6\", \"0.13636363636363635\"], [\"FunctionSQLInvoked\", \"2\", \"0.045454545454545456\"], [\"Expression\", \"3\", \"0.06818181818181818\"], [\"QuerySpecification\", \"7\", \"0.1590909090909091\"], [\"ExpressionColumn\", \"6\", \"0.13636363636363635\"], [\"SetFunction\", \"2\", \"0.045454545454545456\"], [\"ExpressionAggregate\", \"1\", \"0.022727272727272728\"], [\"ParserRoutine\", \"5\", \"0.11363636363636363\"], [\"RoutineSchema\", \"2\", \"0.045454545454545456\"], [\"HsqlName\", \"1\", \"0.022727272727272728\"], [\"DITableInfo\", \"1\", \"0.022727272727272728\"], [\"StatementSchema\", \"7\", \"0.1590909090909091\"], [\"ExpressionOp\", \"6\", \"0.13636363636363635\"], [\"DatabaseInformation\", \"1\", \"0.022727272727272728\"], [\"StatementTypes\", \"8\", \"0.18181818181818182\"], [\"DatabaseURL\", \"2\", \"0.045454545454545456\"], [\"FunctionSQL\", \"4\", \"0.09090909090909091\"], [\"StatementProcedure\", \"1\", \"0.022727272727272728\"], [\"JDBCDriver\", \"1\", \"0.022727272727272728\"], [\"ClobType\", \"1\", \"0.022727272727272728\"], [\"JDBCClobClient\", \"1\", \"0.022727272727272728\"], [\"JDBCBlobClient\", \"1\", \"0.022727272727272728\"], [\"BlobType\", \"1\", \"0.022727272727272728\"], [\"ArrayType\", \"2\", \"0.045454545454545456\"], [\"SubQuery\", \"1\", \"0.022727272727272728\"], [\"StatementCommand\", \"17\", \"0.38636363636363635\"], [\"ExpressionTable\", \"2\", \"0.045454545454545456\"], [\"RowSetNavigatorDataChange\", \"2\", \"0.045454545454545456\"], [\"JDBCResultSetMetaData\", \"2\", \"0.045454545454545456\"], [\"JDBCParameterMetaData\", \"1\", \"0.022727272727272728\"], [\"DatabaseInformationMain\", \"2\", \"0.045454545454545456\"], [\"StatementResultUpdate\", \"1\", \"0.022727272727272728\"], [\"SchemaObjectSet\", \"1\", \"0.022727272727272728\"], [\"ScriptWriterText\", \"2\", \"0.045454545454545456\"], [\"ScriptRunner\", \"1\", \"0.022727272727272728\"], [\"ScriptReaderText\", \"3\", \"0.06818181818181818\"], [\"StringConverter\", \"2\", \"0.045454545454545456\"], [\"RangeVariableResolver\", \"2\", \"0.045454545454545456\"], [\"Collation\", \"1\", \"0.022727272727272728\"], [\"StringUtil\", \"1\", \"0.022727272727272728\"], [\"SortAndSlice\", \"2\", \"0.045454545454545456\"], [\"ExpressionArrayAggregate\", \"2\", \"0.045454545454545456\"], [\"User\", \"2\", \"0.045454545454545456\"], [\"DataFileDefrag\", \"2\", \"0.045454545454545456\"], [\"RowStoreAVL\", \"2\", \"0.045454545454545456\"], [\"RangeVariable\", \"1\", \"0.022727272727272728\"], [\"IndexAVL\", \"1\", \"0.022727272727272728\"], [\"PersistentStore\", \"2\", \"0.045454545454545456\"], [\"ScaledRAFileNIO\", \"2\", \"0.045454545454545456\"], [\"RowAVLDiskData\", \"1\", \"0.022727272727272728\"], [\"RowStoreAVLDiskData\", \"1\", \"0.022727272727272728\"], [\"ScaledRAFileHybrid\", \"1\", \"0.022727272727272728\"], [\"ScaledRAFile\", \"1\", \"0.022727272727272728\"], [\"IndexRowIterator\", \"1\", \"0.022727272727272728\"], [\"RowStoreAVLDisk\", \"1\", \"0.022727272727272728\"], [\"RowStoreAVLHybridExtended\", \"1\", \"0.022727272727272728\"], [\"NumberSequence\", \"1\", \"0.022727272727272728\"], [\"Type\", \"1\", \"0.022727272727272728\"], [\"ExpressionArithmetic\", \"1\", \"0.022727272727272728\"], [\"DataFileCacheSession\", \"2\", \"0.045454545454545456\"], [\"RowSetNavigatorData\", \"1\", \"0.022727272727272728\"], [\"TriggerDefSQL\", \"1\", \"0.022727272727272728\"], [\"QueryExpression\", \"1\", \"0.022727272727272728\"], [\"SessionContext\", \"2\", \"0.045454545454545456\"], [\"StatementSession\", \"1\", \"0.022727272727272728\"], [\"JDBCPreparedStatement\", \"1\", \"0.022727272727272728\"], [\"ScriptWriterBase\", \"1\", \"0.022727272727272728\"], [\"TestTypeConversion\", \"1\", \"0.022727272727272728\"], [\"SimpleLog\", \"1\", \"0.022727272727272728\"], [\"OrderedLongKeyHashMap\", \"1\", \"0.022727272727272728\"], [\"HsqlProperties\", \"1\", \"0.022727272727272728\"], [\"Server\", \"2\", \"0.045454545454545456\"], [\"WebServer\", \"1\", \"0.022727272727272728\"], [\"ServerProperties\", \"1\", \"0.022727272727272728\"], [\"ServerConfiguration\", \"1\", \"0.022727272727272728\"], [\"HsqlServerFactory\", \"1\", \"0.022727272727272728\"], [\"ServerConstants\", \"1\", \"0.022727272727272728\"], [\"DataFileBlockManager\", \"2\", \"0.045454545454545456\"], [\"ArrayUtil\", \"1\", \"0.022727272727272728\"], [\"StatementSchemaDefinition\", \"2\", \"0.045454545454545456\"], [\"TextCache\", \"1\", \"0.022727272727272728\"], [\"TransactionManagerMVCC\", \"1\", \"0.022727272727272728\"], [\"RowAction\", \"1\", \"0.022727272727272728\"], [\"RowOutputTextLog\", \"1\", \"0.022727272727272728\"], [\"DatabaseFilenameFilter\", \"1\", \"0.022727272727272728\"], [\"ExpressionOrderBy\", \"1\", \"0.022727272727272728\"], [\"RangeVariableConditions\", \"1\", \"0.022727272727272728\"], [\"Token\", \"1\", \"0.022727272727272728\"], [\"ParserBase\", \"3\", \"0.06818181818181818\"], [\"TableBase\", \"1\", \"0.022727272727272728\"], [\"ExpressionColumnAccessor\", \"1\", \"0.022727272727272728\"], [\"StatementCursor\", \"1\", \"0.022727272727272728\"], [\"BitMap\", \"1\", \"0.022727272727272728\"], [\"TableSpaceManagerText\", \"1\", \"0.022727272727272728\"], [\"TableSpaceManager\", \"1\", \"0.022727272727272728\"], [\"TableSpaceManagerSession\", \"1\", \"0.022727272727272728\"], [\"HashSet\", \"1\", \"0.022727272727272728\"], [\"Row\", \"1\", \"0.022727272727272728\"], [\"Schema\", \"2\", \"0.045454545454545456\"], [\"HsqlDateTime\", \"1\", \"0.022727272727272728\"], [\"SimpleStore\", \"1\", \"0.022727272727272728\"], [\"ScriptReaderBase\", \"1\", \"0.022727272727272728\"], [\"RowSetNavigatorClient\", \"1\", \"0.022727272727272728\"], [\"StatementInsert\", \"1\", \"0.022727272727272728\"], [\"TestScript\", \"1\", \"0.022727272727272728\"], [\"RowSetNavigatorDataChangeMemory\", \"1\", \"0.022727272727272728\"], [\"NodeAVLDisk\", \"1\", \"0.022727272727272728\"], [\"LobManager\", \"1\", \"0.022727272727272728\"], [\"ParserTable\", \"1\", \"0.022727272727272728\"], [\"ReferenceObject\", \"1\", \"0.022727272727272728\"], [\"View\", \"2\", \"0.045454545454545456\"], [\"TableDerived\", \"1\", \"0.022727272727272728\"], [\"RowInputTextLog\", \"1\", \"0.022727272727272728\"]]"
            },
            "m5": {
                "content": "The co-change relationship analysis reveals that several entities frequently change together with `Tokens.java`. The higher the confidence value, the stronger the relationship between the changes of that entity and `Tokens.java`.\n\n### Key Observations from Co-Change Relationships:\n1. **ParserDQL.java (Confidence: 0.5227)**  \n   - This has the highest confidence score, indicating a very strong co-change relationship with `Tokens.java`. Likely, `Tokens.java` is heavily used in parsing query-related logic.\n\n2. **ParserCommand.java (Confidence: 0.4773)**  \n   - Strong relationship as well; this indicates significant interaction between `Tokens.java` and command parsing logic.\n\n3. **Database.java (0.386), FunctionCustom.java (0.386), StatementCommand.java (0.386)**  \n   - These also show relatively high confidence values, suggesting they are tightly coupled with `Tokens.java`.\n\n4. **ParserDDL.java, Logger.java, HsqlDatabaseProperties.java, ParserRoutine.java** etc.  \n   - Moderate coupling relationships based on their confidence scores.\n\n---\n\n### Next Steps for Analysis:\n\nTo determine which entities need synchronization with `Tokens.java`, we should further analyze these top candidates to identify actual dependencies. Let's begin by analyzing **ParserDQL.java**, which has the strongest co-change relationship.\n\n#### Action: Retrieve the origin code of `ParserDQL.java` to understand how it interacts with `Tokens.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_793a6ad980904c8285889b",
                        "function": {
                            "arguments": "{\"entity\": \"ParserDQL.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m6": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package org.hsqldb;\\nimport org.hsqldb.HsqlNameManager.HsqlName;\\nimport org.hsqldb.HsqlNameManager.SimpleName;\\nimport org.hsqldb.error.Error;\\nimport org.hsqldb.error.ErrorCode;\\nimport org.hsqldb.lib.ArrayUtil;\\nimport org.hsqldb.lib.HashMappedList;\\nimport org.hsqldb.lib.HsqlArrayList;\\nimport org.hsqldb.lib.HsqlList;\\nimport org.hsqldb.lib.Iterator;\\nimport org.hsqldb.lib.LongDeque;\\nimport org.hsqldb.lib.OrderedHashSet;\\nimport org.hsqldb.lib.OrderedIntKeyHashMap;\\nimport org.hsqldb.result.ResultConstants;\\nimport org.hsqldb.result.ResultProperties;\\nimport org.hsqldb.store.BitMap;\\nimport org.hsqldb.store.ValuePool;\\nimport org.hsqldb.types.ArrayType;\\nimport org.hsqldb.types.BlobType;\\nimport org.hsqldb.types.Charset;\\nimport org.hsqldb.types.ClobType;\\nimport org.hsqldb.types.Collation;\\nimport org.hsqldb.types.DTIType;\\nimport org.hsqldb.types.IntervalType;\\nimport org.hsqldb.types.NumberType;\\nimport org.hsqldb.types.Type;\\nimport org.hsqldb.types.Types;\\npublic class ParserDQL extends ParserBase {\\n    protected Database             database;\\n    protected Session              session;\\n    protected final CompileContext compileContext;\\n    HsqlException                  lastError;\\n    ParserDQL(Session session, Scanner t) {\\n        super(t);\\n        this.session   = session;\\n        database       = session.getDatabase();\\n        compileContext = new CompileContext(session, this);\\n    }\\n    void reset(String sql) {\\n        super.reset(sql);\\n        compileContext.reset();\\n        lastError = null;\\n    }\\n    void checkIsSchemaObjectName() {\\n        if (database.sqlEnforceNames) {\\n            checkIsNonReservedIdentifier();\\n        } else {\\n            checkIsNonCoreReservedIdentifier();\\n        }\\n    }\\n    Type readTypeDefinition(boolean allowCollation, boolean includeUserTypes) {\\n        int     typeNumber     = Integer.MIN_VALUE;\\n        boolean hasLength      = false;\\n        boolean hasScale       = false;\\n        boolean isCharacter    = false;\\n        boolean readByteOrChar = false;\\n        checkIsIdentifier();\\n        if (token.namePrefix == null) {\\n            typeNumber = Type.getTypeNr(token.tokenString);\\n        }\\n        if (typeNumber == Integer.MIN_VALUE) {\\n            if (includeUserTypes) {\\n                checkIsSchemaObjectName();\\n                String schemaName = session.getSchemaName(token.namePrefix);\\n                Type type =\\n                    database.schemaManager.getDomainOrUDT(token.tokenString,\\n                        schemaName, false);\\n                if (type != null) {\\n                    getRecordedToken().setExpression(type);\\n                    compileContext.addSchemaObject(type);\\n                    read();\\n                    return type;\\n                }\\n            }\\n            if (token.namePrefix != null) {\\n                throw Error.error(ErrorCode.X_42509, token.tokenString);\\n            }\\n            if (database.sqlSyntaxOra) {\\n                switch (token.tokenType) {\\n                    case Tokens.BINARY_DOUBLE :\\n                    case Tokens.BINARY_FLOAT :\\n                        read();\\n                        return Type.SQL_DOUBLE;\\n                    case Tokens.LONG :\\n                        read();\\n                        if (token.tokenType == Tokens.RAW) {\\n                            read();\\n                            return Type.getType(Types.SQL_VARBINARY, null,\\n                                                null,\\n                                                BlobType.defaultBlobSize, 0);\\n                        } else {\\n                            return Type.getType(Types.SQL_VARCHAR, null, null,\\n                                                ClobType.defaultClobSize, 0);\\n                        }\\n                    case Tokens.NUMBER :\\n                        read();\\n                        if (token.tokenType == Tokens.OPENBRACKET) {\\n                            read();\\n                            int precision = readInteger();\\n                            int scale     = 0;\\n                            if (token.tokenType == Tokens.COMMA) {\\n                                read();\\n                                scale = readInteger();\\n                            }\\n                            readThis(Tokens.CLOSEBRACKET);\\n                            return Type.getType(Types.SQL_DECIMAL, null, null,\\n                                                precision, scale);\\n                        } else {\\n                            return Type.SQL_DECIMAL_DEFAULT;\\n                        }\\n                    case Tokens.RAW :\\n                        typeNumber = Types.VARBINARY;\\n                        break;\\n                    case Tokens.VARCHAR2 :\\n                        typeNumber     = Types.VARCHAR;\\n                        readByteOrChar = true;\\n                        break;\\n                }\\n            }\\n            if (database.sqlSyntaxMys || database.sqlSyntaxPgs) {\\n                switch (token.tokenType) {\\n                    case Tokens.TEXT :\\n                        typeNumber     = Types.LONGVARCHAR;\\n                        readByteOrChar = true;\\n                        break;\\n                }\\n            }\\n            if (typeNumber == Integer.MIN_VALUE) {\\n                throw Error.error(ErrorCode.X_42509, token.tokenString);\\n            }\\n        }\\n        read();\\n        switch (typeNumber) {\\n            case Types.SQL_CHAR :\\n                if (token.tokenType == Tokens.VARYING) {\\n                    read();\\n                    typeNumber = Types.SQL_VARCHAR;\\n                } else if (token.tokenType == Tokens.LARGE) {\\n                    readThis(Tokens.OBJECT);\\n                    read();\\n                    typeNumber = Types.SQL_CLOB;\\n                }\\n                break;\\n            case Types.SQL_DOUBLE :\\n                if (token.tokenType == Tokens.PRECISION) {\\n                    read();\\n                }\\n                break;\\n            case Types.SQL_BINARY :\\n                if (token.tokenType == Tokens.VARYING) {\\n                    read();\\n                    typeNumber = Types.SQL_VARBINARY;\\n                } else if (token.tokenType == Tokens.LARGE) {\\n                    readThis(Tokens.OBJECT);\\n                    read();\\n                    typeNumber = Types.SQL_BLOB;\\n                }\\n                break;\\n            case Types.SQL_BIT :\\n                if (token.tokenType == Tokens.VARYING) {\\n                    read();\\n                    typeNumber = Types.SQL_BIT_VARYING;\\n                }\\n                break;\\n            case Types.SQL_INTERVAL :\\n                return readIntervalType(false);\\n            default :\\n        }\\n        long length = typeNumber == Types.SQL_TIMESTAMP\\n                      ? DTIType.defaultTimestampFractionPrecision\\n                      : 0;\\n        int scale = 0;\\n        if (Types.requiresPrecision(typeNumber)\\n                && token.tokenType != Tokens.OPENBRACKET\\n                && database.sqlEnforceSize && !session.isProcessingScript) {\\n            throw Error.error(ErrorCode.X_42599,\\n                              Type.getDefaultType(typeNumber).getNameString());\\n        }\\n        if (Types.acceptsPrecision(typeNumber)) {\\n            if (token.tokenType == Tokens.OPENBRACKET) {\\n                int multiplier = 1;\\n                read();\\n                switch (token.tokenType) {\\n                    case Tokens.X_VALUE :\\n                        if (token.dataType.typeCode != Types.SQL_INTEGER\\n                                && token.dataType.typeCode\\n                                   != Types.SQL_BIGINT) {\\n                            throw unexpectedToken();\\n                        }\\n                        break;\\n                    case Tokens.X_LOB_SIZE :\\n                        if (typeNumber == Types.SQL_BLOB\\n                                || typeNumber == Types.SQL_CLOB) {\\n                            switch (token.lobMultiplierType) {\\n                                case Tokens.K :\\n                                    multiplier = 1024;\\n                                    break;\\n                                case Tokens.M :\\n                                    multiplier = 1024 * 1024;\\n                                    break;\\n                                case Tokens.G :\\n                                    multiplier = 1024 * 1024 * 1024;\\n                                    break;\\n                                case Tokens.P :\\n                                case Tokens.T :\\n                                default :\\n                                    throw unexpectedToken();\\n                            }\\n                            break;\\n                        } else {\\n                            throw unexpectedToken(token.getFullString());\\n                        }\\n                    default :\\n                        throw unexpectedToken();\\n                }\\n                hasLength = true;\\n                length    = ((Number) token.tokenValue).longValue();\\n                if (length < 0\\n                        || (length == 0\\n                            && !Types.acceptsZeroPrecision(typeNumber))) {\\n                    throw Error.error(ErrorCode.X_42592);\\n                }\\n                length *= multiplier;\\n                read();\\n                if (typeNumber == Types.SQL_CHAR\\n                        || typeNumber == Types.SQL_VARCHAR\\n                        || typeNumber == Types.SQL_CLOB) {\\n                    if (token.tokenType == Tokens.CHARACTERS) {\\n                        read();\\n                    } else if (token.tokenType == Tokens.OCTETS) {\\n                        read();\\n                        length /= 2;\\n                    }\\n                }\\n                if (Types.acceptsScaleCreateParam(typeNumber)\\n                        && token.tokenType == Tokens.COMMA) {\\n                    read();\\n                    scale = readInteger();\\n                    if (scale < 0) {\\n                        throw Error.error(ErrorCode.X_42592);\\n                    }\\n                    hasScale = true;\\n                }\\n                readThis(Tokens.CLOSEBRACKET);\\n            } else if (typeNumber == Types.SQL_BIT) {\\n                length = 1;\\n            } else if (typeNumber == Types.SQL_BLOB\\n                       || typeNumber == Types.SQL_CLOB) {\\n                length = BlobType.defaultBlobSize;\\n            } else if (database.sqlEnforceSize) {\\n                                if (typeNumber == Types.SQL_CHAR\\n                        || typeNumber == Types.SQL_BINARY) {\\n                    length = 1;\\n                }\\n            }\\n            if (typeNumber == Types.SQL_TIMESTAMP\\n                    || typeNumber == Types.SQL_TIME) {\\n                if (length > DTIType.maxFractionPrecision) {\\n                    throw Error.error(ErrorCode.X_42592);\\n                }\\n                scale  = (int) length;\\n                length = 0;\\n                if (token.tokenType == Tokens.WITH) {\\n                    read();\\n                    readThis(Tokens.TIME);\\n                    readThis(Tokens.ZONE);\\n                    if (typeNumber == Types.SQL_TIMESTAMP) {\\n                        typeNumber = Types.SQL_TIMESTAMP_WITH_TIME_ZONE;\\n                    } else {\\n                        typeNumber = Types.SQL_TIME_WITH_TIME_ZONE;\\n                    }\\n                } else if (token.tokenType == Tokens.WITHOUT) {\\n                    read();\\n                    readThis(Tokens.TIME);\\n                    readThis(Tokens.ZONE);\\n                }\\n            }\\n        }\\n        switch (typeNumber) {\\n            case Types.LONGVARCHAR : {\\n                if (database.sqlLongvarIsLob) {\\n                    typeNumber = Types.SQL_CLOB;\\n                } else {\\n                    typeNumber = Types.SQL_VARCHAR;\\n                }\\n                if (!hasLength) {\\n                    length = ClobType.defaultClobSize;\\n                }\\n                break;\\n            }\\n            case Types.LONGVARBINARY : {\\n                if (database.sqlLongvarIsLob) {\\n                    typeNumber = Types.SQL_BLOB;\\n                } else {\\n                    typeNumber = Types.SQL_VARBINARY;\\n                }\\n                if (!hasLength) {\\n                    length = BlobType.defaultBlobSize;\\n                }\\n                break;\\n            }\\n            case Types.SQL_CLOB :\\n            case Types.VARCHAR_IGNORECASE :\\n            case Types.SQL_CHAR :\\n                isCharacter = true;\\n                break;\\n            case Types.SQL_VARCHAR :\\n                isCharacter = true;\\n                if (!hasLength) {\\n                    length = 32 * 1024;\\n                }\\n                break;\\n            case Types.SQL_BINARY :\\n                break;\\n            case Types.SQL_VARBINARY :\\n                if (!hasLength) {\\n                    length = 32 * 1024;\\n                }\\n                break;\\n            case Types.SQL_DECIMAL :\\n            case Types.SQL_NUMERIC :\\n                if (!hasLength && !hasScale && !database.sqlEnforceSize) {\\n                    length = NumberType.defaultNumericPrecision;\\n                    scale  = NumberType.defaultNumericScale;\\n                }\\n                break;\\n        }\\n        if (session.ignoreCase && typeNumber == Types.SQL_VARCHAR) {\\n            typeNumber = Types.VARCHAR_IGNORECASE;\\n        }\\n        if (readByteOrChar) {\\n            if (!readIfThis(Tokens.CHAR)) {\\n                readIfThis(Tokens.BYTE);\\n            }\\n        }\\n        Collation collation = database.collation;\\n        Charset   charset   = null;\\n        if (isCharacter) {\\n            if (token.tokenType == Tokens.CHARACTER) {\\n                read();\\n                readThis(Tokens.SET);\\n                checkIsSchemaObjectName();\\n                String schemaName = session.getSchemaName(token.namePrefix);\\n                charset = (Charset) database.schemaManager.getSchemaObject(\\n                    token.tokenString, schemaName, SchemaObject.CHARSET);\\n                read();\\n            }\\n            if (token.tokenType == Tokens.COLLATE) {\\n                read();\\n                checkIsSimpleName();\\n                try {\\n                    collation = Collation.getCollation(token.tokenString);\\n                } catch (HsqlException e) {\\n                    collation =\\n                        (Collation) database.schemaManager.getSchemaObject(\\n                            token.tokenString, null, SchemaObject.COLLATION);\\n                }\\n                read();\\n            }\\n        }\\n        Type typeObject = Type.getType(typeNumber, charset, collation, length,\\n                                       scale);\\n        if (token.tokenType == Tokens.ARRAY) {\\n            if (typeObject.isLobType()) {\\n                throw unexpectedToken();\\n            }\\n            read();\\n            int maxCardinality = ArrayType.defaultArrayCardinality;\\n            if (token.tokenType == Tokens.LEFTBRACKET) {\\n                read();\\n                maxCardinality = readInteger();\\n                if (scale < 0) {\\n                    throw Error.error(ErrorCode.X_42592);\\n                }\\n                readThis(Tokens.RIGHTBRACKET);\\n            }\\n            typeObject = new ArrayType(typeObject, maxCardinality);\\n        }\\n        return typeObject;\\n    }\\n    void readSimpleColumnNames(OrderedHashSet columns,\\n                               RangeVariable rangeVar) {\\n        while (true) {\\n            ColumnSchema col = readSimpleColumnName(rangeVar);\\n            if (!columns.add(col.getName().name)) {\\n                throw Error.error(ErrorCode.X_42579, col.getName().name);\\n            }\\n            if (readIfThis(Tokens.COMMA)) {\\n                continue;\\n            }\\n            if (token.tokenType == Tokens.CLOSEBRACKET) {\\n                break;\\n            }\\n            throw unexpectedToken();\\n        }\\n    }\\n    void readTargetSpecificationList(OrderedHashSet targets,\\n                                     RangeVariable[] rangeVars,\\n                                     LongDeque colIndexList) {\\n        while (true) {\\n            Expression target = XreadTargetSpecification(rangeVars,\\n                colIndexList);\\n            if (!targets.add(target)) {\\n                ColumnSchema col = target.getColumn();\\n                throw Error.error(ErrorCode.X_42579, col.getName().name);\\n            }\\n            if (readIfThis(Tokens.COMMA)) {\\n                continue;\\n            }\\n            if (token.tokenType == Tokens.CLOSEBRACKET) {\\n                break;\\n            }\\n            if (token.tokenType == Tokens.FROM) {\\n                break;\\n            }\\n            throw unexpectedToken();\\n        }\\n    }\\n    int[] readColumnList(Table table, boolean ascOrDesc) {\\n        OrderedHashSet set = readColumnNames(ascOrDesc);\\n        return table.getColumnIndexes(set);\\n    }\\n    void readSimpleColumnNames(OrderedHashSet columns, Table table) {\\n        while (true) {\\n            ColumnSchema col = readSimpleColumnName(table);\\n            if (!columns.add(col.getName().name)) {\\n                throw Error.error(ErrorCode.X_42577, col.getName().name);\\n            }\\n            if (readIfThis(Tokens.COMMA)) {\\n                continue;\\n            }\\n            if (token.tokenType == Tokens.CLOSEBRACKET) {\\n                break;\\n            }\\n            throw unexpectedToken();\\n        }\\n    }\\n    HsqlName[] readColumnNames(HsqlName tableName) {\\n        BitMap         quotedFlags = new BitMap(32);\\n        OrderedHashSet set         = readColumnNames(quotedFlags, false);\\n        HsqlName[]     colList     = new HsqlName[set.size()];\\n        for (int i = 0; i < colList.length; i++) {\\n            String  name   = (String) set.get(i);\\n            boolean quoted = quotedFlags.isSet(i);\\n            colList[i] = database.nameManager.newHsqlName(tableName.schema,\\n                    name, quoted, SchemaObject.COLUMN, tableName);\\n        }\\n        return colList;\\n    }\\n    OrderedHashSet readColumnNames(boolean readAscDesc) {\\n        return readColumnNames(null, readAscDesc);\\n    }\\n    OrderedHashSet readColumnNames(BitMap quotedFlags, boolean readAscDesc) {\\n        readThis(Tokens.OPENBRACKET);\\n        OrderedHashSet set = new OrderedHashSet();\\n        readColumnNameList(set, quotedFlags, readAscDesc);\\n        readThis(Tokens.CLOSEBRACKET);\\n        return set;\\n    }\\n    void readColumnNameList(OrderedHashSet set, BitMap quotedFlags,\\n                            boolean readAscDesc) {\\n        int i = 0;\\n        while (true) {\\n            if (session.isProcessingScript) {\\n                                if (!isSimpleName()) {\\n                    token.isDelimitedIdentifier = true;\\n                }\\n            } else {\\n                checkIsSimpleName();\\n            }\\n            if (!set.add(token.tokenString)) {\\n                throw Error.error(ErrorCode.X_42577, token.tokenString);\\n            }\\n            if (quotedFlags != null && isDelimitedIdentifier()) {\\n                quotedFlags.set(i);\\n            }\\n            read();\\n            i++;\\n            if (readAscDesc) {\\n                if (token.tokenType == Tokens.ASC\\n                        || token.tokenType == Tokens.DESC) {\\n                    read();\\n                }\\n            }\\n            if (readIfThis(Tokens.COMMA)) {\\n                continue;\\n            }\\n            break;\\n        }\\n    }\\n    SimpleName[] readColumnNameList(OrderedHashSet set) {\\n        BitMap columnNameQuoted = new BitMap(32);\\n        readThis(Tokens.OPENBRACKET);\\n        readColumnNameList(set, columnNameQuoted, false);\\n        readThis(Tokens.CLOSEBRACKET);\\n        SimpleName[] columnNameList = new SimpleName[set.size()];\\n        for (int i = 0; i < set.size(); i++) {\\n            SimpleName name =\\n                HsqlNameManager.getSimpleName((String) set.get(i),\\n                                              columnNameQuoted.isSet(i));\\n            columnNameList[i] = name;\\n        }\\n        return columnNameList;\\n    }\\n    int XreadUnionType() {\\n        int unionType = QueryExpression.NOUNION;\\n        switch (token.tokenType) {\\n            case Tokens.UNION :\\n                read();\\n                unionType = QueryExpression.UNION;\\n                if (token.tokenType == Tokens.ALL) {\\n                    unionType = QueryExpression.UNION_ALL;\\n                    read();\\n                } else if (token.tokenType == Tokens.DISTINCT) {\\n                    read();\\n                }\\n                break;\\n            case Tokens.INTERSECT :\\n                read();\\n                unionType = QueryExpression.INTERSECT;\\n                if (token.tokenType == Tokens.ALL) {\\n                    unionType = QueryExpression.INTERSECT_ALL;\\n                    read();\\n                } else if (token.tokenType == Tokens.DISTINCT) {\\n                    read();\\n                }\\n                break;\\n            case Tokens.EXCEPT :\\n            case Tokens.MINUS_EXCEPT :\\n                read();\\n                unionType = QueryExpression.EXCEPT;\\n                if (token.tokenType == Tokens.ALL) {\\n                    unionType = QueryExpression.EXCEPT_ALL;\\n                    read();\\n                } else if (token.tokenType == Tokens.DISTINCT) {\\n                    read();\\n                }\\n                break;\\n            default :\\n                break;\\n        }\\n        return unionType;\\n    }\\n    void XreadUnionCorrespondingClause(QueryExpression queryExpression) {\\n        if (token.tokenType == Tokens.CORRESPONDING) {\\n            read();\\n            queryExpression.setUnionCorresoponding();\\n            if (token.tokenType == Tokens.BY) {\\n                read();\\n                OrderedHashSet names = readColumnNames(false);\\n                queryExpression.setUnionCorrespondingColumns(names);\\n            }\\n        }\\n    }\\n    QueryExpression XreadQueryExpression() {\\n        if (token.tokenType == Tokens.WITH) {\\n            read();\\n            boolean recursive = readIfThis(Tokens.RECURSIVE);\\n            compileContext.initSubqueryNames();\\n            while (true) {\\n                checkIsSimpleName();\\n                HsqlName[] nameList = null;\\n                HsqlName queryName =\\n                    database.nameManager.newHsqlName(token.tokenString,\\n                                                     isDelimitedIdentifier(),\\n                                                     SchemaObject.SUBQUERY);\\n                queryName.schema = SqlInvariants.SYSTEM_SUBQUERY_HSQLNAME;\\n                read();\\n                if (token.tokenType == Tokens.OPENBRACKET) {\\n                    nameList = readColumnNames(queryName);\\n                } else if (recursive) {\\n                    super.unexpectedTokenRequire(Tokens.T_OPENBRACKET);\\n                }\\n                readThis(Tokens.AS);\\n                readThis(Tokens.OPENBRACKET);\\n                SubQuery subQuery;\\n                subQuery =\\n                    XreadTableNamedSubqueryBody(queryName, nameList,\\n                                                recursive\\n                                                ? OpTypes.RECURSIVE_SUBQUERY\\n                                                : OpTypes.TABLE_SUBQUERY);\\n                readThis(Tokens.CLOSEBRACKET);\\n                if (token.tokenType == Tokens.CYCLE) {\\n                    throw super.unsupportedFeature();\\n                }\\n                if (recursive && token.tokenType == Tokens.CYCLE) {\\n                    Table    table           = subQuery.getTable();\\n                    int[]    cycleColumnList = readColumnList(table, false);\\n                    HsqlName name;\\n                    readThis(Tokens.SET);\\n                    checkIsSimpleName();\\n                    name = database.nameManager.newColumnHsqlName(\\n                        table.getName(), token.tokenString,\\n                        token.isDelimitedIdentifier);\\n                    ColumnSchema cycleMarkColumn = new ColumnSchema(name,\\n                        null, true, false, null);\\n                    if (table.getColumnIndex(name.name) != -1) {\\n                        throw Error.error(ErrorCode.X_42578,\\n                                          token.tokenString);\\n                    }\\n                    read();\\n                    readThis(Tokens.TO);\\n                    String cycleMarkValue = readQuotedString();\\n                    if (cycleMarkValue.length() != 1) {\\n                        throw unexpectedToken(cycleMarkValue);\\n                    }\\n                    readThis(Tokens.DEFAULT);\\n                    String noncycleMarkValue = readQuotedString();\\n                    if (noncycleMarkValue.length() != 1) {\\n                        throw unexpectedToken(noncycleMarkValue);\\n                    }\\n                    if (cycleMarkValue.equals(noncycleMarkValue)) {\\n                        throw unexpectedToken(cycleMarkValue);\\n                    }\\n                    readThis(Tokens.USING);\\n                    checkIsSimpleName();\\n                    checkIsSimpleName();\\n                    name = database.nameManager.newColumnHsqlName(\\n                        table.getName(), token.tokenString,\\n                        token.isDelimitedIdentifier);\\n                    if (table.getColumnIndex(name.name) != -1) {\\n                        throw Error.error(ErrorCode.X_42578,\\n                                          token.tokenString);\\n                    }\\n                    read();\\n                    ColumnSchema pathColumn = new ColumnSchema(name, null,\\n                        true, false, null);\\n                }\\n                compileContext.registerSubquery(queryName.name, subQuery);\\n                if (token.tokenType == Tokens.COMMA) {\\n                    read();\\n                    continue;\\n                }\\n                break;\\n            }\\n        }\\n        QueryExpression queryExpression = XreadQueryExpressionBody();\\n        SortAndSlice    sortAndSlice    = XreadOrderByExpression();\\n        if (queryExpression.sortAndSlice == null) {\\n            queryExpression.addSortAndSlice(sortAndSlice);\\n        } else {\\n            if (queryExpression.sortAndSlice.hasLimit()) {\\n                if (sortAndSlice.hasLimit()) {\\n                    throw Error.error(ErrorCode.X_42549);\\n                }\\n                for (int i = 0; i < sortAndSlice.exprList.size(); i++) {\\n                    Expression e = (Expression) sortAndSlice.exprList.get(i);\\n                    queryExpression.sortAndSlice.addOrderExpression(e);\\n                }\\n            } else {\\n                queryExpression.addSortAndSlice(sortAndSlice);\\n            }\\n        }\\n        return queryExpression;\\n    }\\n    QueryExpression XreadQueryExpressionBody() {\\n        QueryExpression queryExpression = XreadQueryTerm();\\n        while (true) {\\n            switch (token.tokenType) {\\n                case Tokens.UNION :\\n                case Tokens.EXCEPT :\\n                case Tokens.MINUS_EXCEPT : {\\n                    queryExpression = XreadSetOperation(queryExpression);\\n                    break;\\n                }\\n                default : {\\n                    return queryExpression;\\n                }\\n            }\\n        }\\n    }\\n    QueryExpression XreadQueryTerm() {\\n        QueryExpression queryExpression = XreadQueryPrimary();\\n        while (true) {\\n            if (token.tokenType == Tokens.INTERSECT) {\\n                queryExpression = XreadSetOperation(queryExpression);\\n            } else {\\n                return queryExpression;\\n            }\\n        }\\n    }\\n    private QueryExpression XreadSetOperation(\\n            QueryExpression queryExpression) {\\n        queryExpression = new QueryExpression(compileContext, queryExpression);\\n        int unionType = XreadUnionType();\\n        XreadUnionCorrespondingClause(queryExpression);\\n        QueryExpression rightQueryExpression = XreadQueryTerm();\\n        queryExpression.addUnion(rightQueryExpression, unionType);\\n        return queryExpression;\\n    }\\n    QueryExpression XreadQueryPrimary() {\\n        switch (token.tokenType) {\\n            case Tokens.TABLE :\\n            case Tokens.VALUES :\\n            case Tokens.SELECT : {\\n                QuerySpecification select = XreadSimpleTable();\\n                return select;\\n            }\\n            case Tokens.OPENBRACKET : {\\n                read();\\n                QueryExpression queryExpression = XreadQueryExpressionBody();\\n                SortAndSlice    sortAndSlice    = XreadOrderByExpression();\\n                readThis(Tokens.CLOSEBRACKET);\\n                if (queryExpression.sortAndSlice == null) {\\n                    queryExpression.addSortAndSlice(sortAndSlice);\\n                } else {\\n                    if (queryExpression.sortAndSlice.hasLimit()) {\\n                        if (sortAndSlice.hasLimit()) {\\n                            throw Error.error(ErrorCode.X_42549);\\n                        }\\n                        for (int i = 0; i < sortAndSlice.exprList.size();\\n                                i++) {\\n                            Expression e =\\n                                (Expression) sortAndSlice.exprList.get(i);\\n                            queryExpression.sortAndSlice.addOrderExpression(e);\\n                        }\\n                    } else {\\n                        queryExpression.addSortAndSlice(sortAndSlice);\\n                    }\\n                }\\n                return queryExpression;\\n            }\\n            default : {\\n                throw unexpectedToken();\\n            }\\n        }\\n    }\\n    QuerySpecification XreadSimpleTable() {\\n        QuerySpecification select;\\n        switch (token.tokenType) {\\n            case Tokens.TABLE : {\\n                read();\\n                Table table = readTableName();\\n                if (table.isView()) {\\n                    table = ((View) table).getSubqueryTable();\\n                }\\n                select = new QuerySpecification(session, table,\\n                                                compileContext, false);\\n                break;\\n            }\\n            case Tokens.VALUES : {\\n                read();\\n                SubQuery sq = XreadRowValueExpressionList();\\n                select = new QuerySpecification(session, sq.getTable(),\\n                                                compileContext, true);\\n                break;\\n            }\\n            case Tokens.SELECT : {\\n                select = XreadQuerySpecification();\\n                break;\\n            }\\n            default : {\\n                throw unexpectedToken();\\n            }\\n        }\\n        return select;\\n    }\\n    QuerySpecification XreadQuerySpecification() {\\n        QuerySpecification select = XreadSelect();\\n        if (!select.isValueList) {\\n            XreadTableExpression(select);\\n        }\\n        return select;\\n    }\\n    void XreadTableExpression(QuerySpecification select) {\\n        XreadFromClause(select);\\n        readWhereGroupHaving(select);\\n    }\\n    QuerySpecification XreadSelect() {\\n        QuerySpecification select = new QuerySpecification(compileContext);\\n        readThis(Tokens.SELECT);\\n        if (token.tokenType == Tokens.TOP || token.tokenType == Tokens.LIMIT) {\\n            SortAndSlice sortAndSlice = XreadTopOrLimit();\\n            if (sortAndSlice != null) {\\n                select.addSortAndSlice(sortAndSlice);\\n            }\\n        }\\n        if (token.tokenType == Tokens.DISTINCT) {\\n            select.isDistinctSelect = true;\\n            read();\\n        } else if (token.tokenType == Tokens.ALL) {\\n            read();\\n        }\\n        while (true) {\\n            Expression e = XreadValueExpression();\\n            if (token.tokenType == Tokens.AS) {\\n                read();\\n                checkIsNonCoreReservedIdentifier();\\n            }\\n            if (isNonCoreReservedIdentifier()) {\\n                e.setAlias(HsqlNameManager.getSimpleName(token.tokenString,\\n                        isDelimitedIdentifier()));\\n                read();\\n            }\\n            select.addSelectColumnExpression(e);\\n            if (token.tokenType == Tokens.FROM) {\\n                break;\\n            }\\n            if (token.tokenType == Tokens.INTO) {\\n                break;\\n            }\\n            if (readIfThis(Tokens.COMMA)) {\\n                continue;\\n            }\\n            if (token.tokenType == Tokens.CLOSEBRACKET\\n                    || token.tokenType == Tokens.X_ENDPARSE) {\\n                if (database.sqlSyntaxMss || database.sqlSyntaxMys\\n                        || database.sqlSyntaxPgs) {\\n                    Expression[] exprList =\\n                        new Expression[select.exprColumnList.size()];\\n                    select.exprColumnList.toArray(exprList);\\n                    Expression valueList = new Expression(OpTypes.VALUELIST,\\n                                                          exprList);\\n                    for (int i = 0; i < valueList.nodes.length; i++) {\\n                        if (valueList.nodes[i].opType != OpTypes.ROW) {\\n                            valueList.nodes[i] =\\n                                new Expression(OpTypes.ROW,\\n                                               new Expression[]{\\n                                                   valueList.nodes[i] });\\n                        }\\n                    }\\n                    compileContext.subqueryDepth++;\\n                    SubQuery sq = prepareSubquery(valueList);\\n                    select = new QuerySpecification(session, sq.getTable(),\\n                                                    compileContext, true);\\n                    compileContext.subqueryDepth--;\\n                    return select;\\n                }\\n            }\\n            throw unexpectedToken();\\n        }\\n        return select;\\n    }\\n    void XreadFromClause(QuerySpecification select) {\\n        readThis(Tokens.FROM);\\n        while (true) {\\n            XreadTableReference(select);\\n            if (readIfThis(Tokens.COMMA)) {\\n                continue;\\n            }\\n            break;\\n        }\\n    }\\n    void XreadTableReference(QuerySpecification select) {\\n        boolean       natural = false;\\n        RangeVariable range   = readTableOrSubquery(null);\\n        select.addRangeVariable(range);\\n        while (true) {\\n            int     type;\\n            boolean left  = false;\\n            boolean right = false;\\n            boolean end   = false;\\n            type = token.tokenType;\\n            switch (token.tokenType) {\\n                case Tokens.INNER :\\n                    read();\\n                    readThis(Tokens.JOIN);\\n                    break;\\n                case Tokens.CROSS :\\n                    if (natural) {\\n                        throw unexpectedToken();\\n                    }\\n                    read();\\n                    readThis(Tokens.JOIN);\\n                    break;\\n                case Tokens.UNION :\\n                    if (natural) {\\n                        throw unexpectedToken();\\n                    }\\n                    int position = getPosition();\\n                    read();\\n                    if (token.tokenType == Tokens.JOIN) {\\n                        read();\\n                        break;\\n                    } else {\\n                        rewind(position);\\n                        end = true;\\n                        break;\\n                    }\\n                case Tokens.NATURAL :\\n                    if (natural) {\\n                        throw unexpectedToken();\\n                    }\\n                    read();\\n                    natural = true;\\n                    continue;\\n                case Tokens.LEFT :\\n                    read();\\n                    readIfThis(Tokens.OUTER);\\n                    readThis(Tokens.JOIN);\\n                    left = true;\\n                    break;\\n                case Tokens.RIGHT :\\n                    read();\\n                    readIfThis(Tokens.OUTER);\\n                    readThis(Tokens.JOIN);\\n                    right = true;\\n                    break;\\n                case Tokens.FULL :\\n                    read();\\n                    readIfThis(Tokens.OUTER);\\n                    readThis(Tokens.JOIN);\\n                    left  = true;\\n                    right = true;\\n                    break;\\n                case Tokens.JOIN :\\n                    read();\\n                    type = Tokens.INNER;\\n                    break;\\n                case Tokens.COMMA :\\n                    if (natural) {\\n                        throw unexpectedToken();\\n                    }\\n                    read();\\n                    type = Tokens.COMMA;\\n                    break;\\n                default :\\n                    if (natural) {\\n                        throw unexpectedToken();\\n                    }\\n                    end = true;\\n                    break;\\n            }\\n            if (end) {\\n                break;\\n            }\\n            range = readTableOrSubquery(null);\\n            Expression condition = null;\\n            switch (type) {\\n                case Tokens.COMMA :\\n                    range.isBoundary = true;\\n                    select.addRangeVariable(range);\\n                    break;\\n                case Tokens.CROSS :\\n                    select.addRangeVariable(range);\\n                    break;\\n                case Tokens.UNION :\\n                    select.addRangeVariable(range);\\n                    condition = Expression.EXPR_FALSE;\\n                    range.setJoinType(true, true);\\n                    break;\\n                case Tokens.LEFT :\\n                case Tokens.RIGHT :\\n                case Tokens.INNER :\\n                case Tokens.FULL : {\\n                    if (natural) {\\n                        OrderedHashSet columns =\\n                            range.getUniqueColumnNameSet();\\n                        condition = select.getEquiJoinExpressions(columns,\\n                                range, false);\\n                        select.addRangeVariable(range);\\n                    } else if (token.tokenType == Tokens.USING) {\\n                        read();\\n                        OrderedHashSet columns = new OrderedHashSet();\\n                        readThis(Tokens.OPENBRACKET);\\n                        readSimpleColumnNames(columns, range);\\n                        readThis(Tokens.CLOSEBRACKET);\\n                        condition = select.getEquiJoinExpressions(columns,\\n                                range, true);\\n                        select.addRangeVariable(range);\\n                    } else if (token.tokenType == Tokens.ON) {\\n                        read();\\n                        condition = XreadBooleanValueExpression();\\n                        select.addRangeVariable(range);\\n                    } else {\\n                        throw unexpectedToken();\\n                    }\\n                    range.setJoinType(left, right);\\n                    break;\\n                }\\n            }\\n            range.addJoinCondition(condition);\\n            natural = false;\\n        }\\n    }\\n    Expression getRowExpression(OrderedHashSet columnNames) {\\n        Expression[] elements = new Expression[columnNames.size()];\\n        for (int i = 0; i < elements.length; i++) {\\n            String name = (String) columnNames.get(i);\\n            elements[i] = new ExpressionColumn(null, null, name);\\n        }\\n        return new Expression(OpTypes.ROW, elements);\\n    }\\n    void readWhereGroupHaving(QuerySpecification select) {\\n                if (token.tokenType == Tokens.WHERE) {\\n            read();\\n            Expression e = XreadBooleanValueExpression();\\n            select.addQueryCondition(e);\\n        }\\n                if (token.tokenType == Tokens.GROUP) {\\n            read();\\n            readThis(Tokens.BY);\\n            while (true) {\\n                Expression e = XreadValueExpression();\\n                select.addGroupByColumnExpression(e);\\n                if (token.tokenType == Tokens.COMMA) {\\n                    read();\\n                    continue;\\n                }\\n                break;\\n            }\\n        }\\n                if (token.tokenType == Tokens.HAVING) {\\n            read();\\n            Expression e = XreadBooleanValueExpression();\\n            select.addHavingExpression(e);\\n        }\\n    }\\n    SortAndSlice XreadOrderByExpression() {\\n        SortAndSlice sortAndSlice = null;\\n        if (token.tokenType == Tokens.ORDER) {\\n            read();\\n            readThis(Tokens.BY);\\n            sortAndSlice = XreadOrderBy();\\n        }\\n        if (token.tokenType == Tokens.LIMIT || token.tokenType == Tokens.FETCH\\n                || token.tokenType == Tokens.OFFSET) {\\n            if (sortAndSlice == null) {\\n                sortAndSlice = new SortAndSlice();\\n            }\\n            XreadLimit(sortAndSlice);\\n        }\\n        return sortAndSlice == null ? SortAndSlice.noSort\\n                                    : sortAndSlice;\\n    }\\n    private SortAndSlice XreadTopOrLimit() {\\n        Expression e1 = null;\\n        Expression e2 = null;\\n        if (token.tokenType == Tokens.LIMIT) {\\n            int position = getPosition();\\n            read();\\n            e1 = XreadSimpleValueSpecificationOrNull();\\n            if (e1 == null) {\\n                rewind(position);\\n                return null;\\n            }\\n            e2 = XreadSimpleValueSpecificationOrNull();\\n            if (e2 == null) {\\n                throw Error.error(ErrorCode.X_42563,\\n                                  ErrorCode.M_INVALID_LIMIT);\\n            }\\n        } else if (token.tokenType == Tokens.TOP) {\\n            int position = getPosition();\\n            read();\\n            e2 = XreadSimpleValueSpecificationOrNull();\\n            if (e2 == null) {\\n                rewind(position);\\n                return null;\\n            }\\n            e1 = new ExpressionValue(ValuePool.INTEGER_0, Type.SQL_INTEGER);\\n        }\\n        boolean valid = true;\\n        if (e1.isUnresolvedParam()) {\\n            e1.setDataType(session, Type.SQL_INTEGER);\\n        } else {\\n            valid = (e1.getDataType().typeCode == Types.SQL_INTEGER\\n                     && ((Integer) e1.getValue(null)).intValue() >= 0);\\n        }\\n        if (e2.isUnresolvedParam()) {\\n            e2.setDataType(session, Type.SQL_INTEGER);\\n        } else {\\n            valid &= (e2.getDataType().typeCode == Types.SQL_INTEGER\\n                      && ((Integer) e2.getValue(null)).intValue() >= 0);\\n        }\\n        if (valid) {\\n            SortAndSlice sortAndSlice = new SortAndSlice();\\n            sortAndSlice.addLimitCondition(new ExpressionOp(OpTypes.LIMIT, e1,\\n                    e2));\\n            return sortAndSlice;\\n        }\\n        throw Error.error(ErrorCode.X_42563, ErrorCode.M_INVALID_LIMIT);\\n    }\\n    private void XreadLimit(SortAndSlice sortAndSlice) {\\n        Expression e1 = null;\\n        Expression e2 = null;\\n        if (token.tokenType == Tokens.OFFSET) {\\n            read();\\n            e1 = XreadSimpleValueSpecificationOrNull();\\n            if (e1 == null) {\\n                throw Error.error(ErrorCode.X_42563,\\n                                  ErrorCode.M_INVALID_LIMIT);\\n            }\\n            if (token.tokenType == Tokens.ROW\\n                    || token.tokenType == Tokens.ROWS) {\\n                read();\\n            }\\n        }\\n        if (token.tokenType == Tokens.LIMIT) {\\n            read();\\n            e2 = XreadSimpleValueSpecificationOrNull();\\n            if (e2 == null) {\\n                throw Error.error(ErrorCode.X_42563,\\n                                  ErrorCode.M_INVALID_LIMIT);\\n            }\\n            if (e1 == null && token.tokenType == Tokens.OFFSET) {\\n                read();\\n                e1 = XreadSimpleValueSpecificationOrNull();\\n            }\\n        } else if (token.tokenType == Tokens.FETCH) {\\n            read();\\n            if (token.tokenType == Tokens.FIRST\\n                    || token.tokenType == Tokens.NEXT) {\\n                read();\\n            }\\n            e2 = XreadSimpleValueSpecificationOrNull();\\n            if (e2 == null) {\\n                e2 = new ExpressionValue(ValuePool.INTEGER_1,\\n                                         Type.SQL_INTEGER);\\n            }\\n            if (token.tokenType == Tokens.ROW\\n                    || token.tokenType == Tokens.ROWS) {\\n                read();\\n            }\\n            readThis(Tokens.ONLY);\\n            sortAndSlice.setStrictLimit();\\n        }\\n        if (e1 == null) {\\n            e1 = new ExpressionValue(ValuePool.INTEGER_0, Type.SQL_INTEGER);\\n        }\\n        boolean valid = true;\\n        if (e1.isUnresolvedParam()) {\\n            e1.setDataType(session, Type.SQL_INTEGER);\\n        }\\n        if (e2 != null) {\\n            if (e2.isUnresolvedParam()) {\\n                e2.setDataType(session, Type.SQL_INTEGER);\\n            }\\n        }\\n        if (valid) {\\n            sortAndSlice.addLimitCondition(new ExpressionOp(OpTypes.LIMIT, e1,\\n                    e2));\\n            return;\\n        }\\n        throw Error.error(ErrorCode.X_42563, ErrorCode.M_INVALID_LIMIT);\\n    }\\n    private SortAndSlice XreadOrderBy() {\\n        SortAndSlice sortAndSlice = new SortAndSlice();\\n        while (true) {\\n            Expression        e = XreadValueExpression();\\n            ExpressionOrderBy o = new ExpressionOrderBy(e);\\n            if (token.tokenType == Tokens.DESC) {\\n                o.setDescending();\\n                read();\\n            } else if (token.tokenType == Tokens.ASC) {\\n                read();\\n            }\\n            if (token.tokenType == Tokens.NULLS) {\\n                read();\\n                if (token.tokenType == Tokens.FIRST) {\\n                    read();\\n                } else if (token.tokenType == Tokens.LAST) {\\n                    read();\\n                    o.setNullsLast();\\n                } else {\\n                    throw unexpectedToken();\\n                }\\n            }\\n            sortAndSlice.addOrderExpression(o);\\n            if (token.tokenType == Tokens.COMMA) {\\n                read();\\n                continue;\\n            }\\n            break;\\n        }\\n        return sortAndSlice;\\n    }\\n    protected RangeVariable readSimpleRangeVariable(int operation) {\\n        Table      table = readTableName();\\n        SimpleName alias = null;\\n        if (operation != StatementTypes.TRUNCATE) {\\n            if (token.tokenType == Tokens.AS) {\\n                read();\\n                checkIsNonCoreReservedIdentifier();\\n            }\\n            if (isNonCoreReservedIdentifier()) {\\n                alias = HsqlNameManager.getSimpleName(token.tokenString,\\n                                                      isDelimitedIdentifier());\\n                read();\\n            }\\n        }\\n        if (table.isView) {\\n            switch (operation) {\\n                case StatementTypes.MERGE :\\n                    if (table.isTriggerUpdatable()\\n                            && table.isTriggerDeletable()) {\\n                        break;\\n                    }\\n                    if (table.isUpdatable() && table.isInsertable()) {\\n                        break;\\n                    }\\n                    throw Error.error(ErrorCode.X_42545);\\n                case StatementTypes.UPDATE_WHERE :\\n                    if (table.isTriggerUpdatable()) {\\n                        break;\\n                    }\\n                    if (table.isUpdatable()) {\\n                        break;\\n                    }\\n                    throw Error.error(ErrorCode.X_42545);\\n                case StatementTypes.DELETE_WHERE :\\n                    if (table.isTriggerDeletable()) {\\n                        break;\\n                    }\\n                    if (table.isUpdatable()) {\\n                        break;\\n                    }\\n                    throw Error.error(ErrorCode.X_42545);\\n            }\\n            table = ((View) table).getSubqueryTable();\\n        }\\n        RangeVariable range = new RangeVariable(table, alias, null, null,\\n            compileContext);\\n        return range;\\n    }\\n    protected Table readNamedSubqueryOrNull() {\\n        if (!isSimpleName()) {\\n            return null;\\n        }\\n        SubQuery sq = compileContext.getNamedSubQuery(token.tokenString);\\n        if (sq == null) {\\n            return null;\\n        }\\n        read();\\n        return sq.getTable();\\n    }\\n    protected RangeVariable readTableOrSubquery(RangeVariable[] outerRanges) {\\n        Table          table          = null;\\n        SimpleName     alias          = null;\\n        SimpleName[]   columnNameList = null;\\n        OrderedHashSet columnList     = null;\\n        boolean        joinedTable    = false;\\n        switch (token.tokenType) {\\n            case Tokens.OPENBRACKET : {\\n                table = XreadTableSubqueryOrNull(outerRanges);\\n                if (table == null) {\\n                    SubQuery sq = XreadJoinedTableAsSubquery();\\n                    table       = sq.getTable();\\n                    joinedTable = true;\\n                }\\n                break;\\n            }\\n            case Tokens.UNNEST : {\\n                Expression e = XreadCollectionDerivedTable();\\n                table = e.getTable();\\n                break;\\n            }\\n            case Tokens.LATERAL : {\\n                Expression e = XreadLateralDerivedTable();\\n                table = e.getTable();\\n                break;\\n            }\\n            case Tokens.TABLE : {\\n                Expression e = XreadTableFunctionDerivedTable();\\n                table = e.getTable();\\n                break;\\n            }\\n            default : {\\n                table = readNamedSubqueryOrNull();\\n                if (table == null) {\\n                    table = readTableName();\\n                }\\n                if (table.isView()) {\\n                    table = ((View) table).getSubqueryTable();\\n                }\\n            }\\n        }\\n        boolean hasAs = false;\\n        if (token.tokenType == Tokens.AS) {\\n            read();\\n            checkIsNonCoreReservedIdentifier();\\n            hasAs = true;\\n        }\\n        if (isNonCoreReservedIdentifier()) {\\n            boolean limit = token.tokenType == Tokens.LIMIT\\n                            || token.tokenType == Tokens.OFFSET\\n                            || token.tokenType == Tokens.FETCH;\\n            boolean minus    = token.tokenType == Tokens.MINUS_EXCEPT;\\n            int     position = getPosition();\\n            alias = HsqlNameManager.getSimpleName(token.tokenString,\\n                                                  isDelimitedIdentifier());\\n            read();\\n            if (token.tokenType == Tokens.OPENBRACKET) {\\n                columnList     = new OrderedHashSet();\\n                columnNameList = readColumnNameList(columnList);\\n            } else if (!hasAs && limit) {\\n                if (token.tokenType == Tokens.COLON\\n                        || token.tokenType == Tokens.QUESTION\\n                        || token.tokenType == Tokens.X_VALUE) {\\n                    alias = null;\\n                    rewind(position);\\n                }\\n            } else if (!hasAs && minus) {\\n                rewind(position);\\n            }\\n        }\\n        RangeVariable range;\\n        if (joinedTable) {\\n            range = new RangeVariableJoined(table, alias, columnList,\\n                                            columnNameList, compileContext);\\n        } else {\\n            range = new RangeVariable(table, alias, columnList,\\n                                      columnNameList, compileContext);\\n        }\\n        return range;\\n    }\\n    private Expression readAggregate() {\\n        int        tokenT = token.tokenType;\\n        Expression e;\\n        read();\\n        readThis(Tokens.OPENBRACKET);\\n        e = readAggregateExpression(tokenT);\\n        readThis(Tokens.CLOSEBRACKET);\\n        readFilterClause(e);\\n        return e;\\n    }\\n    private void readFilterClause(Expression e) {\\n        int position = getPosition();\\n        if (token.tokenType == Tokens.FILTER) {\\n            read();\\n            if (token.tokenType != Tokens.OPENBRACKET) {\\n                rewind(position);\\n                return;\\n            }\\n            readThis(Tokens.OPENBRACKET);\\n            readThis(Tokens.WHERE);\\n            Expression condition = XreadBooleanValueExpression();\\n            e.setCondition(condition);\\n            readThis(Tokens.CLOSEBRACKET);\\n        }\\n    }\\n    private Expression readAggregateExpression(int tokenT) {\\n        int          type      = ParserDQL.getExpressionType(tokenT);\\n        boolean      distinct  = false;\\n        boolean      all       = false;\\n        SortAndSlice sort      = null;\\n        String       separator = null;\\n        if (token.tokenType == Tokens.DISTINCT) {\\n            distinct = true;\\n            read();\\n        } else if (token.tokenType == Tokens.ALL) {\\n            all = true;\\n            read();\\n        }\\n        Expression e = XreadValueExpression();\\n        switch (type) {\\n            case OpTypes.COUNT :\\n                if (e.getType() == OpTypes.MULTICOLUMN) {\\n                    if (((ExpressionColumn) e).tableName != null) {\\n                        throw unexpectedToken();\\n                    }\\n                    if (all || distinct) {\\n                        throw unexpectedToken();\\n                    }\\n                    e.opType = OpTypes.ASTERISK;\\n                    break;\\n                } else {\\n                    break;\\n                }\\n            case OpTypes.STDDEV_POP :\\n            case OpTypes.STDDEV_SAMP :\\n            case OpTypes.VAR_POP :\\n            case OpTypes.VAR_SAMP :\\n                if (all || distinct) {\\n                    throw Error.error(ErrorCode.X_42582, all ? Tokens.T_ALL\\n                                                             : Tokens\\n                                                             .T_DISTINCT);\\n                }\\n                break;\\n            case OpTypes.ARRAY_AGG :\\n            case OpTypes.GROUP_CONCAT : {\\n                if (token.tokenType == Tokens.ORDER) {\\n                    read();\\n                    readThis(Tokens.BY);\\n                    sort = XreadOrderBy();\\n                }\\n                if (type == OpTypes.GROUP_CONCAT) {\\n                    if (token.tokenType == Tokens.SEPARATOR) {\\n                        read();\\n                        super.checkIsValue(Types.SQL_CHAR);\\n                        separator = (String) token.tokenValue;\\n                        read();\\n                    }\\n                }\\n                return new ExpressionArrayAggregate(type, distinct, e, sort,\\n                                                    separator);\\n            }\\n            case OpTypes.MEDIAN : {\\n                return new ExpressionArrayAggregate(type, distinct, e, sort,\\n                                                    separator);\\n            }\\n            default :\\n                if (e.getType() == OpTypes.ASTERISK) {\\n                    throw unexpectedToken();\\n                }\\n        }\\n        Expression aggregateExp = new ExpressionAggregate(type, distinct, e);\\n        return aggregateExp;\\n    }\\n            Expression XreadValueSpecificationOrNull() {\\n        Expression e     = null;\\n        boolean    minus = false;\\n        switch (token.tokenType) {\\n            case Tokens.PLUS :\\n                read();\\n                break;\\n            case Tokens.MINUS :\\n                read();\\n                minus = true;\\n                break;\\n        }\\n        e = XreadUnsignedValueSpecificationOrNull();\\n        if (e == null) {\\n            return null;\\n        }\\n        if (minus) {\\n            e = new ExpressionArithmetic(OpTypes.NEGATE, e);\\n        }\\n        return e;\\n    }\\n            Expression XreadUnsignedValueSpecificationOrNull() {\\n        Expression e;\\n        switch (token.tokenType) {\\n            case Tokens.TRUE :\\n                read();\\n                return Expression.EXPR_TRUE;\\n            case Tokens.FALSE :\\n                read();\\n                return Expression.EXPR_FALSE;\\n            case Tokens.DEFAULT :\\n                if (compileContext.contextuallyTypedExpression) {\\n                    read();\\n                    e = new ExpressionColumn(OpTypes.DEFAULT);\\n                    return e;\\n                }\\n                break;\\n            case Tokens.NULL :\\n                e = new ExpressionValue(null, null);\\n                read();\\n                return e;\\n            case Tokens.X_VALUE :\\n                e = new ExpressionValue(token.tokenValue, token.dataType);\\n                read();\\n                return e;\\n            case Tokens.X_DELIMITED_IDENTIFIER :\\n            case Tokens.X_IDENTIFIER :\\n                if (!token.isHostParameter) {\\n                    return null;\\n                }\\n                return null;\\n            case Tokens.COLON :\\n                read();\\n                if (token.tokenType == Tokens.X_DELIMITED_IDENTIFIER\\n                        || token.tokenType == Tokens.X_IDENTIFIER) {}\\n                else {\\n                    throw unexpectedToken(Tokens.T_COLON);\\n                }\\n                        case Tokens.QUESTION :\\n                e = new ExpressionColumn(OpTypes.DYNAMIC_PARAM);\\n                compileContext.addParameter(e, getPosition());\\n                read();\\n                return e;\\n            case Tokens.COLLATION :\\n                return XreadCurrentCollationSpec();\\n            case Tokens.VALUE :\\n            case Tokens.CURRENT_CATALOG :\\n            case Tokens.CURRENT_DEFAULT_TRANSFORM_GROUP :\\n            case Tokens.CURRENT_PATH :\\n            case Tokens.CURRENT_ROLE :\\n            case Tokens.CURRENT_SCHEMA :\\n            case Tokens.CURRENT_TRANSFORM_GROUP_FOR_TYPE :\\n            case Tokens.CURRENT_USER :\\n            case Tokens.SESSION_USER :\\n            case Tokens.SYSTEM_USER :\\n            case Tokens.USER :\\n                FunctionSQL function =\\n                    FunctionSQL.newSQLFunction(token.tokenString,\\n                                               compileContext);\\n                if (function == null) {\\n                    return null;\\n                }\\n                return readSQLFunction(function);\\n                    }\\n        return null;\\n    }\\n        Expression XreadSimpleValueSpecificationOrNull() {\\n        Expression e;\\n        switch (token.tokenType) {\\n            case Tokens.X_VALUE :\\n                e = new ExpressionValue(token.tokenValue, token.dataType);\\n                read();\\n                return e;\\n            case Tokens.COLON :\\n                read();\\n                if (token.tokenType == Tokens.X_DELIMITED_IDENTIFIER\\n                        || token.tokenType == Tokens.X_IDENTIFIER) {}\\n                else {\\n                    throw unexpectedToken(Tokens.T_COLON);\\n                }\\n                        case Tokens.QUESTION :\\n                e = new ExpressionColumn(OpTypes.DYNAMIC_PARAM);\\n                compileContext.addParameter(e, getPosition());\\n                read();\\n                return e;\\n            case Tokens.X_IDENTIFIER :\\n            case Tokens.X_DELIMITED_IDENTIFIER :\\n                checkValidCatalogName(token.namePrePrePrefix);\\n                e = new ExpressionColumn(token.namePrePrefix,\\n                                         token.namePrefix, token.tokenString);\\n                read();\\n                return e;\\n            default :\\n                return null;\\n        }\\n    }\\n                Expression XreadAllTypesValueExpressionPrimary(boolean boole) {\\n        Expression e = null;\\n        switch (token.tokenType) {\\n            case Tokens.EXISTS :\\n            case Tokens.UNIQUE :\\n                if (boole) {\\n                    return XreadPredicate();\\n                }\\n                break;\\n            case Tokens.ROW :\\n                if (boole) {\\n                    break;\\n                }\\n                read();\\n                readThis(Tokens.OPENBRACKET);\\n                e = XreadRowElementList(true);\\n                readThis(Tokens.CLOSEBRACKET);\\n                break;\\n            default :\\n                e = XreadSimpleValueExpressionPrimary();\\n                if (e != null) {\\n                    e = XreadArrayElementReference(e);\\n                }\\n        }\\n        if (e == null && token.tokenType == Tokens.OPENBRACKET) {\\n            read();\\n            e = XreadRowElementList(true);\\n            readThis(Tokens.CLOSEBRACKET);\\n        }\\n        if (boole && e != null) {\\n            e = XreadPredicateRightPart(e);\\n        }\\n        return e;\\n    }\\n                Expression XreadValueExpressionPrimary() {\\n        Expression e;\\n        e = XreadSimpleValueExpressionPrimary();\\n        if (e != null) {\\n            e = XreadArrayElementReference(e);\\n            return e;\\n        }\\n        if (token.tokenType == Tokens.OPENBRACKET) {\\n            read();\\n            e = XreadValueExpression();\\n            readThis(Tokens.CLOSEBRACKET);\\n        } else {\\n            return null;\\n        }\\n        return e;\\n    }\\n                Expression XreadSimpleValueExpressionPrimary() {\\n        Expression e;\\n        e = XreadUnsignedValueSpecificationOrNull();\\n        if (e != null) {\\n            return e;\\n        }\\n        int position = getPosition();\\n        switch (token.tokenType) {\\n            case Tokens.OPENBRACKET :\\n                read();\\n                int subqueryPosition = getPosition();\\n                int brackets         = readOpenBrackets();\\n                switch (token.tokenType) {\\n                    case Tokens.TABLE :\\n                    case Tokens.VALUES :\\n                    case Tokens.SELECT :\\n                        SubQuery sq = null;\\n                        rewind(subqueryPosition);\\n                        try {\\n                            sq = XreadSubqueryBody(OpTypes.SCALAR_SUBQUERY);\\n                            readThis(Tokens.CLOSEBRACKET);\\n                        } catch (HsqlException ex) {\\n                            ex.setLevel(compileContext.subqueryDepth);\\n                            if (lastError == null\\n                                    || lastError.getLevel() < ex.getLevel()) {\\n                                lastError = ex;\\n                            }\\n                            rewind(position);\\n                            return null;\\n                        }\\n                        if (sq.queryExpression.isSingleColumn()) {\\n                            e = new Expression(OpTypes.SCALAR_SUBQUERY, sq);\\n                        } else {\\n                            e = new Expression(OpTypes.ROW_SUBQUERY, sq);\\n                        }\\n                        if (readCloseBrackets(brackets) != brackets) {\\n                            throw unexpectedToken();\\n                        }\\n                        return e;\\n                    default :\\n                        rewind(position);\\n                        return null;\\n                }\\n            case Tokens.ASTERISK :\\n                e = new ExpressionColumn(token.namePrePrefix,\\n                                         token.namePrefix);\\n                getRecordedToken().setExpression(e);\\n                read();\\n                return e;\\n            case Tokens.LEAST :\\n                return readLeastExpression();\\n            case Tokens.GREATEST :\\n                return readGreatestExpression();\\n            case Tokens.DECODE :\\n                return readDecodeExpression();\\n            case Tokens.CONCAT_WORD :\\n                return readConcatExpression();\\n            case Tokens.CASEWHEN :\\n                return readCaseWhenExpression();\\n            case Tokens.CASE :\\n                return readCaseExpression();\\n            case Tokens.NULLIF :\\n                return readNullIfExpression();\\n            case Tokens.COALESCE :\\n            case Tokens.IFNULL :\\n            case Tokens.ISNULL :\\n                return readCoalesceExpression();\\n            case Tokens.CAST :\\n            case Tokens.CONVERT :\\n                return readCastExpression();\\n            case Tokens.DATE :\\n            case Tokens.TIME :\\n            case Tokens.TIMESTAMP :\\n            case Tokens.INTERVAL :\\n                e = readDateTimeIntervalLiteral();\\n                if (e != null) {\\n                    return e;\\n                }\\n                break;\\n            case Tokens.ARRAY :\\n                return readCollection(OpTypes.ARRAY);\\n            case Tokens.ANY :\\n            case Tokens.SOME :\\n            case Tokens.EVERY :\\n            case Tokens.COUNT :\\n            case Tokens.MAX :\\n            case Tokens.MIN :\\n            case Tokens.SUM :\\n            case Tokens.AVG :\\n            case Tokens.STDDEV_POP :\\n            case Tokens.STDDEV_SAMP :\\n            case Tokens.VAR_POP :\\n            case Tokens.VAR_SAMP :\\n            case Tokens.GROUP_CONCAT :\\n            case Tokens.ARRAY_AGG :\\n            case Tokens.MEDIAN :\\n                return readAggregate();\\n            case Tokens.NEXT : {\\n                e = readSequenceExpressionOrNull(OpTypes.SEQUENCE);\\n                if (e != null) {\\n                    return e;\\n                }\\n                break;\\n            }\\n            case Tokens.CURRENT : {\\n                e = readSequenceExpressionOrNull(OpTypes.SEQUENCE_CURRENT);\\n                if (e != null) {\\n                    return e;\\n                }\\n                break;\\n            }\\n            case Tokens.CURRVAL : {\\n                if (database.sqlSyntaxPgs) {\\n                    read();\\n                    readThis(Tokens.OPENBRACKET);\\n                    String  spec    = readQuotedString();\\n                    Scanner scanner = session.getScanner();\\n                    scanner.reset(spec);\\n                    scanner.scanNext();\\n                    String schemaName =\\n                        session.getSchemaName(scanner.token.namePrefix);\\n                    NumberSequence sequence =\\n                        database.schemaManager.getSequence(\\n                            scanner.token.tokenString, schemaName, true);\\n                    e = new ExpressionColumn(sequence,\\n                                             OpTypes.SEQUENCE_CURRENT);\\n                    readThis(Tokens.CLOSEBRACKET);\\n                    return e;\\n                }\\n                break;\\n            }\\n            case Tokens.LASTVAL : {\\n                if (database.sqlSyntaxPgs) {\\n                    read();\\n                    readThis(Tokens.OPENBRACKET);\\n                    readThis(Tokens.CLOSEBRACKET);\\n                    return FunctionCustom.newCustomFunction(Tokens.T_IDENTITY,\\n                            Tokens.IDENTITY);\\n                }\\n                break;\\n            }\\n            case Tokens.NEXTVAL : {\\n                if (database.sqlSyntaxPgs) {\\n                    read();\\n                    readThis(Tokens.OPENBRACKET);\\n                    String  spec    = readQuotedString();\\n                    Scanner scanner = session.getScanner();\\n                    scanner.reset(spec);\\n                    scanner.scanNext();\\n                    String schemaName =\\n                        session.getSchemaName(scanner.token.namePrefix);\\n                    NumberSequence sequence =\\n                        database.schemaManager.getSequence(\\n                            scanner.token.tokenString, schemaName, true);\\n                    e = new ExpressionColumn(sequence, OpTypes.SEQUENCE);\\n                    readThis(Tokens.CLOSEBRACKET);\\n                    return e;\\n                }\\n                break;\\n            }\\n            case Tokens.LEFT :\\n            case Tokens.RIGHT :\\n                                break;\\n            case Tokens.TABLE : {\\n                read();\\n                readThis(Tokens.OPENBRACKET);\\n                SubQuery sq = XreadSubqueryBody(OpTypes.TABLE_SUBQUERY);\\n                readThis(Tokens.CLOSEBRACKET);\\n                return new Expression(OpTypes.TABLE_SUBQUERY, sq);\\n            }\\n            default :\\n                if (isCoreReservedKey()) {\\n                    throw unexpectedToken();\\n                }\\n        }\\n        e = readColumnOrFunctionExpression();\\n        if (e.isAggregate()) {\\n            readFilterClause(e);\\n        }\\n        return e;\\n    }\\n            Expression XreadAllTypesPrimary(boolean boole) {\\n        Expression e = null;\\n        switch (token.tokenType) {\\n            case Tokens.SUBSTRING :\\n            case Tokens.SUBSTRING_REGEX :\\n            case Tokens.LOWER :\\n            case Tokens.UPPER :\\n            case Tokens.TRANSLATE_REGEX :\\n            case Tokens.TRIM :\\n            case Tokens.OVERLAY :\\n            case Tokens.NORMALIZE :\\n                        case Tokens.POSITION :\\n            case Tokens.OCCURRENCES_REGEX :\\n            case Tokens.POSITION_REGEX :\\n            case Tokens.EXTRACT :\\n            case Tokens.CHAR_LENGTH :\\n            case Tokens.CHARACTER_LENGTH :\\n            case Tokens.OCTET_LENGTH :\\n            case Tokens.CARDINALITY :\\n            case Tokens.ABS :\\n            case Tokens.MOD :\\n            case Tokens.LN :\\n            case Tokens.EXP :\\n            case Tokens.POWER :\\n            case Tokens.SQRT :\\n            case Tokens.FLOOR :\\n            case Tokens.CEILING :\\n            case Tokens.CEIL :\\n            case Tokens.WIDTH_BUCKET :\\n                FunctionSQL function =\\n                    FunctionSQL.newSQLFunction(token.tokenString,\\n                                               compileContext);\\n                if (function == null) {\\n                    throw unsupportedFeature();\\n                }\\n                e = readSQLFunction(function);\\n                if (e != null) {\\n                    break;\\n                }\\n            default :\\n                e = XreadAllTypesValueExpressionPrimary(boole);\\n        }\\n        e = XreadModifier(e);\\n        return e;\\n    }\\n    Expression XreadModifier(Expression e) {\\n        switch (token.tokenType) {\\n            case Tokens.AT : {\\n                read();\\n                Expression e1 = null;\\n                if (token.tokenType == Tokens.LOCAL) {\\n                    read();\\n                } else {\\n                    readThis(Tokens.TIME);\\n                    readThis(Tokens.ZONE);\\n                    e1 = XreadValueExpressionPrimary();\\n                    switch (token.tokenType) {\\n                        case Tokens.YEAR :\\n                        case Tokens.MONTH :\\n                        case Tokens.DAY :\\n                        case Tokens.HOUR :\\n                        case Tokens.MINUTE :\\n                        case Tokens.SECOND : {\\n                            IntervalType type = readIntervalType(false);\\n                            if (e1.getType() == OpTypes.SUBTRACT) {\\n                                e1.dataType = type;\\n                            } else {\\n                                e1 = new ExpressionOp(e1, type);\\n                            }\\n                        }\\n                    }\\n                }\\n                e = new ExpressionOp(OpTypes.ZONE_MODIFIER, e, e1);\\n                break;\\n            }\\n            case Tokens.YEAR :\\n            case Tokens.MONTH :\\n            case Tokens.DAY :\\n            case Tokens.HOUR :\\n            case Tokens.MINUTE :\\n            case Tokens.SECOND : {\\n                IntervalType type = readIntervalType(true);\\n                if (e.getType() == OpTypes.SUBTRACT) {\\n                    e.dataType = type;\\n                } else {\\n                    e = new ExpressionOp(e, type);\\n                }\\n                break;\\n            }\\n            case Tokens.COLLATE : {\\n                read();\\n                if (token.namePrefix == null) {\\n                    Collation collation;\\n                    try {\\n                        collation = Collation.getCollation(token.tokenString);\\n                    } catch (HsqlException ex) {\\n                        collation =\\n                            (Collation) database.schemaManager.getSchemaObject(\\n                                session.getSchemaName(token.namePrefix),\\n                                token.tokenString, SchemaObject.COLLATION);\\n                    }\\n                    e.setCollation(collation);\\n                    read();\\n                }\\n            }\\n        }\\n        return e;\\n    }\\n    Expression XreadValueExpressionWithContext() {\\n        Expression e;\\n        compileContext.contextuallyTypedExpression = true;\\n        e = XreadValueExpressionOrNull();\\n        compileContext.contextuallyTypedExpression = false;\\n        return e;\\n    }\\n    Expression XreadValueExpressionOrNull() {\\n        Expression e = XreadAllTypesCommonValueExpression(true);\\n        if (e == null) {\\n            return null;\\n        }\\n        return e;\\n    }\\n    Expression XreadValueExpression() {\\n        Expression e = XreadAllTypesCommonValueExpression(true);\\n        if (token.tokenType == Tokens.LEFTBRACKET) {\\n            read();\\n            Expression e1 = XreadNumericValueExpression();\\n            readThis(Tokens.RIGHTBRACKET);\\n            e = new ExpressionAccessor(e, e1);\\n        }\\n        return e;\\n    }\\n        Expression XreadRowOrCommonValueExpression() {\\n        return XreadAllTypesCommonValueExpression(false);\\n    }\\n            Expression XreadAllTypesCommonValueExpression(boolean boole) {\\n        Expression e    = XreadAllTypesTerm(boole);\\n        int        type = 0;\\n        boolean    end  = false;\\n        while (true) {\\n            switch (token.tokenType) {\\n                case Tokens.PLUS :\\n                    type  = OpTypes.ADD;\\n                    boole = false;\\n                    break;\\n                case Tokens.MINUS :\\n                    type  = OpTypes.SUBTRACT;\\n                    boole = false;\\n                    break;\\n                case Tokens.CONCAT :\\n                    type  = OpTypes.CONCAT;\\n                    boole = false;\\n                    break;\\n                case Tokens.OR :\\n                    if (boole) {\\n                        type = OpTypes.OR;\\n                        break;\\n                    }\\n                                default :\\n                    end = true;\\n                    break;\\n            }\\n            if (end) {\\n                break;\\n            }\\n            read();\\n            Expression a = e;\\n            e = XreadAllTypesTerm(boole);\\n            e = boole ? (Expression) new ExpressionLogical(type, a, e)\\n                      : new ExpressionArithmetic(type, a, e);\\n        }\\n        return e;\\n    }\\n    Expression XreadAllTypesTerm(boolean boole) {\\n        Expression e    = XreadAllTypesFactor(boole);\\n        int        type = 0;\\n        boolean    end  = false;\\n        while (true) {\\n            switch (token.tokenType) {\\n                case Tokens.ASTERISK :\\n                    type  = OpTypes.MULTIPLY;\\n                    boole = false;\\n                    break;\\n                case Tokens.DIVIDE :\\n                    type  = OpTypes.DIVIDE;\\n                    boole = false;\\n                    break;\\n                case Tokens.AND :\\n                    if (boole) {\\n                        type = OpTypes.AND;\\n                        break;\\n                    }\\n                                default :\\n                    end = true;\\n                    break;\\n            }\\n            if (end) {\\n                break;\\n            }\\n            read();\\n            Expression a = e;\\n            e = XreadAllTypesFactor(boole);\\n            if (e == null) {\\n                throw unexpectedToken();\\n            }\\n            e = boole ? (Expression) new ExpressionLogical(type, a, e)\\n                      : new ExpressionArithmetic(type, a, e);\\n        }\\n        return e;\\n    }\\n    Expression XreadAllTypesFactor(boolean boole) {\\n        Expression e;\\n        boolean    minus   = false;\\n        boolean    not     = false;\\n        boolean    unknown = false;\\n        switch (token.tokenType) {\\n            case Tokens.PLUS :\\n                read();\\n                boole = false;\\n                break;\\n            case Tokens.MINUS :\\n                read();\\n                boole = false;\\n                minus = true;\\n                break;\\n            case Tokens.NOT :\\n                if (boole) {\\n                    read();\\n                    not = true;\\n                }\\n                break;\\n        }\\n        e = XreadAllTypesPrimary(boole);\\n        if (boole && token.tokenType == Tokens.IS) {\\n            read();\\n            if (token.tokenType == Tokens.NOT) {\\n                read();\\n                not = !not;\\n            }\\n            if (token.tokenType == Tokens.TRUE) {\\n                read();\\n            } else if (token.tokenType == Tokens.FALSE) {\\n                read();\\n                not = !not;\\n            } else if (token.tokenType == Tokens.UNKNOWN) {\\n                read();\\n                unknown = true;\\n            } else {\\n                throw unexpectedToken();\\n            }\\n        }\\n        if (unknown) {\\n            e = new ExpressionLogical(OpTypes.IS_NULL, e);\\n        } else if (minus) {\\n            e = new ExpressionArithmetic(OpTypes.NEGATE, e);\\n        } else if (not) {\\n            e = new ExpressionLogical(OpTypes.NOT, e);\\n        }\\n        return e;\\n    }\\n    Expression XreadStringValueExpression() {\\n        return XreadCharacterValueExpression();\\n    }\\n    Expression XreadCharacterValueExpression() {\\n        Expression   e         = XreadCharacterPrimary();\\n        SchemaObject collation = readCollateClauseOrNull();\\n        while (token.tokenType == Tokens.CONCAT) {\\n            read();\\n            Expression a = e;\\n            e         = XreadCharacterPrimary();\\n            collation = readCollateClauseOrNull();\\n            e         = new ExpressionArithmetic(OpTypes.CONCAT, a, e);\\n        }\\n        return e;\\n    }\\n    Expression XreadCharacterPrimary() {\\n        switch (token.tokenType) {\\n            case Tokens.SUBSTRING :\\n            case Tokens.LOWER :\\n            case Tokens.UPPER :\\n            case Tokens.TRIM :\\n            case Tokens.OVERLAY :\\n                FunctionSQL function =\\n                    FunctionSQL.newSQLFunction(token.tokenString,\\n                                               compileContext);\\n                Expression e = readSQLFunction(function);\\n                if (e != null) {\\n                    return e;\\n                }\\n            default :\\n        }\\n        return XreadValueExpressionPrimary();\\n    }\\n    Expression XreadNumericPrimary() {\\n        switch (token.tokenType) {\\n            case Tokens.POSITION :\\n            case Tokens.EXTRACT :\\n            case Tokens.CHAR_LENGTH :\\n            case Tokens.CHARACTER_LENGTH :\\n            case Tokens.OCTET_LENGTH :\\n            case Tokens.CARDINALITY :\\n            case Tokens.ABS :\\n            case Tokens.MOD :\\n            case Tokens.LN :\\n            case Tokens.EXP :\\n            case Tokens.POWER :\\n            case Tokens.SQRT :\\n            case Tokens.FLOOR :\\n            case Tokens.CEILING :\\n            case Tokens.CEIL :\\n                FunctionSQL function =\\n                    FunctionSQL.newSQLFunction(token.tokenString,\\n                                               compileContext);\\n                if (function == null) {\\n                    throw super.unexpectedToken();\\n                }\\n                Expression e = readSQLFunction(function);\\n                if (e != null) {\\n                    return e;\\n                }\\n            default :\\n        }\\n        return XreadValueExpressionPrimary();\\n    }\\n    Expression XreadNumericValueExpression() {\\n        Expression e = XreadTerm();\\n        while (true) {\\n            int type;\\n            if (token.tokenType == Tokens.PLUS) {\\n                type = OpTypes.ADD;\\n            } else if (token.tokenType == Tokens.MINUS) {\\n                type = OpTypes.SUBTRACT;\\n            } else {\\n                break;\\n            }\\n            read();\\n            Expression a = e;\\n            e = XreadTerm();\\n            e = new ExpressionArithmetic(type, a, e);\\n        }\\n        return e;\\n    }\\n    Expression XreadTerm() {\\n        Expression e = XreadFactor();\\n        int        type;\\n        while (true) {\\n            if (token.tokenType == Tokens.ASTERISK) {\\n                type = OpTypes.MULTIPLY;\\n            } else if (token.tokenType == Tokens.DIVIDE) {\\n                type = OpTypes.DIVIDE;\\n            } else {\\n                break;\\n            }\\n            read();\\n            Expression a = e;\\n            e = XreadFactor();\\n            if (e == null) {\\n                throw unexpectedToken();\\n            }\\n            e = new ExpressionArithmetic(type, a, e);\\n        }\\n        return e;\\n    }\\n    Expression XreadFactor() {\\n        Expression e;\\n        boolean    minus = false;\\n        if (token.tokenType == Tokens.PLUS) {\\n            read();\\n        } else if (token.tokenType == Tokens.MINUS) {\\n            read();\\n            minus = true;\\n        }\\n        e = XreadNumericPrimary();\\n        if (e == null) {\\n            return null;\\n        }\\n        if (minus) {\\n            e = new ExpressionArithmetic(OpTypes.NEGATE, e);\\n        }\\n        return e;\\n    }\\n    Expression XreadDatetimeValueExpression() {\\n        Expression e = XreadDateTimeIntervalTerm();\\n        while (true) {\\n            int type;\\n            if (token.tokenType == Tokens.PLUS) {\\n                type = OpTypes.ADD;\\n            } else if (token.tokenType == Tokens.MINUS) {\\n                type = OpTypes.SUBTRACT;\\n            } else {\\n                break;\\n            }\\n            read();\\n            Expression a = e;\\n            e = XreadDateTimeIntervalTerm();\\n            e = new ExpressionArithmetic(type, a, e);\\n        }\\n        return e;\\n    }\\n    Expression XreadIntervalValueExpression() {\\n        Expression e = XreadDateTimeIntervalTerm();\\n        while (true) {\\n            int type;\\n            if (token.tokenType == Tokens.PLUS) {\\n                type = OpTypes.ADD;\\n            } else if (token.tokenType == Tokens.MINUS) {\\n                type = OpTypes.SUBTRACT;\\n            } else {\\n                break;\\n            }\\n            read();\\n            Expression a = e;\\n            e = XreadDateTimeIntervalTerm();\\n            e = new ExpressionArithmetic(type, a, e);\\n        }\\n        return e;\\n    }\\n    Expression XreadDateTimeIntervalTerm() {\\n        switch (token.tokenType) {\\n            case Tokens.CURRENT_DATE :\\n            case Tokens.CURRENT_TIME :\\n            case Tokens.CURRENT_TIMESTAMP :\\n            case Tokens.LOCALTIME :\\n            case Tokens.LOCALTIMESTAMP :\\n                        case Tokens.ABS :\\n                FunctionSQL function =\\n                    FunctionSQL.newSQLFunction(token.tokenString,\\n                                               compileContext);\\n                if (function == null) {\\n                    throw super.unexpectedToken();\\n                }\\n                return readSQLFunction(function);\\n            default :\\n        }\\n        return XreadValueExpressionPrimary();\\n    }\\n        Expression XreadDateTimeValueFunctionOrNull() {\\n        FunctionSQL function = null;\\n        switch (token.tokenType) {\\n            case Tokens.CURRENT_DATE :\\n            case Tokens.CURRENT_TIME :\\n            case Tokens.CURRENT_TIMESTAMP :\\n            case Tokens.LOCALTIME :\\n            case Tokens.LOCALTIMESTAMP :\\n                function = FunctionSQL.newSQLFunction(token.tokenString,\\n                                                      compileContext);\\n                break;\\n            case Tokens.NOW :\\n            case Tokens.TODAY :\\n            case Tokens.SYSDATE :\\n                function = FunctionCustom.newCustomFunction(token.tokenString,\\n                        token.tokenType);\\n                break;\\n            default :\\n                return null;\\n        }\\n        if (function == null) {\\n            throw super.unexpectedToken();\\n        }\\n        return readSQLFunction(function);\\n    }\\n    Expression XreadBooleanValueExpression() {\\n        try {\\n            Expression e = XreadBooleanTermOrNull();\\n            if (e == null) {\\n                throw Error.error(ErrorCode.X_42568);\\n            }\\n            while (true) {\\n                int type;\\n                if (token.tokenType == Tokens.OR) {\\n                    type = OpTypes.OR;\\n                } else {\\n                    break;\\n                }\\n                read();\\n                Expression a = e;\\n                e = XreadBooleanTermOrNull();\\n                if (e == null) {\\n                    throw Error.error(ErrorCode.X_42568);\\n                }\\n                e = new ExpressionLogical(type, a, e);\\n            }\\n            if (e == null) {\\n                throw Error.error(ErrorCode.X_42568);\\n            }\\n            return e;\\n        } catch (HsqlException ex) {\\n            ex.setLevel(compileContext.subqueryDepth);\\n            if (lastError != null && lastError.getLevel() >= ex.getLevel()) {\\n                ex        = lastError;\\n                lastError = null;\\n            }\\n            throw ex;\\n        }\\n    }\\n    Expression XreadBooleanTermOrNull() {\\n        Expression e = XreadBooleanFactorOrNull();\\n        if (e == null) {\\n            return null;\\n        }\\n        int type;\\n        while (true) {\\n            if (token.tokenType == Tokens.AND) {\\n                type = OpTypes.AND;\\n            } else {\\n                break;\\n            }\\n            read();\\n            Expression a = e;\\n            e = XreadBooleanFactorOrNull();\\n            if (e == null) {\\n                throw unexpectedToken();\\n            }\\n            e = new ExpressionLogical(type, a, e);\\n        }\\n        return e;\\n    }\\n    Expression XreadBooleanFactorOrNull() {\\n        Expression e;\\n        boolean    not     = false;\\n        boolean    unknown = false;\\n        if (token.tokenType == Tokens.NOT) {\\n            read();\\n            not = true;\\n        }\\n        e = XreadBooleanPrimaryOrNull();\\n        if (e == null) {\\n            return null;\\n        }\\n        if (token.tokenType == Tokens.IS) {\\n            read();\\n            if (token.tokenType == Tokens.NOT) {\\n                read();\\n                not = !not;\\n            }\\n            if (token.tokenType == Tokens.TRUE) {\\n                read();\\n            } else if (token.tokenType == Tokens.FALSE) {\\n                not = !not;\\n                read();\\n            } else if (token.tokenType == Tokens.UNKNOWN) {\\n                unknown = true;\\n                read();\\n            } else {\\n                throw unexpectedToken();\\n            }\\n        }\\n        if (unknown) {\\n            e = new ExpressionLogical(OpTypes.IS_NULL, e);\\n        }\\n        if (not) {\\n            e = new ExpressionLogical(OpTypes.NOT, e);\\n        }\\n        return e;\\n    }\\n        Expression XreadBooleanPrimaryOrNull() {\\n        Expression e = null;\\n        int        position;\\n        switch (token.tokenType) {\\n            case Tokens.EXISTS :\\n            case Tokens.UNIQUE :\\n                return XreadPredicate();\\n            case Tokens.ROW :\\n                read();\\n                readThis(Tokens.OPENBRACKET);\\n                e = XreadRowElementList(true);\\n                readThis(Tokens.CLOSEBRACKET);\\n                break;\\n            default :\\n                position = getPosition();\\n                try {\\n                    e = XreadAllTypesCommonValueExpression(false);\\n                } catch (HsqlException ex) {\\n                    ex.setLevel(compileContext.subqueryDepth);\\n                    if (lastError == null\\n                            || lastError.getLevel() < ex.getLevel()) {\\n                        lastError = ex;\\n                    }\\n                    rewind(position);\\n                }\\n        }\\n        if (e == null && token.tokenType == Tokens.OPENBRACKET) {\\n            read();\\n            position = getPosition();\\n            try {\\n                e = XreadRowElementList(true);\\n                readThis(Tokens.CLOSEBRACKET);\\n            } catch (HsqlException ex) {\\n                ex.setLevel(compileContext.subqueryDepth);\\n                if (lastError == null\\n                        || lastError.getLevel() < ex.getLevel()) {\\n                    lastError = ex;\\n                }\\n                rewind(position);\\n                e = XreadBooleanValueExpression();\\n                readThis(Tokens.CLOSEBRACKET);\\n            }\\n        }\\n        if (e != null) {\\n            e = XreadPredicateRightPart(e);\\n        }\\n        return e;\\n    }\\n        Expression XreadBooleanPredicand() {\\n        Expression e;\\n        if (token.tokenType == Tokens.OPENBRACKET) {\\n            read();\\n            e = XreadBooleanValueExpression();\\n            readThis(Tokens.CLOSEBRACKET);\\n            return e;\\n        } else {\\n            e = XreadSimpleValueExpressionPrimary();\\n            if (e != null) {\\n                e = XreadArrayElementReference(e);\\n            }\\n            return e;\\n        }\\n    }\\n    Expression XreadPredicate() {\\n        switch (token.tokenType) {\\n            case Tokens.EXISTS : {\\n                read();\\n                Expression s = XreadTableSubquery(OpTypes.EXISTS);\\n                return new ExpressionLogical(OpTypes.EXISTS, s);\\n            }\\n            case Tokens.UNIQUE : {\\n                read();\\n                Expression s = XreadTableSubquery(OpTypes.UNIQUE);\\n                return new ExpressionLogical(OpTypes.UNIQUE, s);\\n            }\\n            default : {\\n                Expression a = XreadRowValuePredicand();\\n                return XreadPredicateRightPart(a);\\n            }\\n        }\\n    }\\n    Expression XreadPredicateRightPart(final Expression l) {\\n        boolean           hasNot = false;\\n        ExpressionLogical e      = null;\\n        Expression        r;\\n        if (token.tokenType == Tokens.NOT) {\\n            read();\\n            hasNot = true;\\n        }\\n        switch (token.tokenType) {\\n            case Tokens.IS : {\\n                if (hasNot) {\\n                    throw unexpectedToken();\\n                }\\n                read();\\n                if (token.tokenType == Tokens.NOT) {\\n                    hasNot = true;\\n                    read();\\n                }\\n                if (token.tokenType == Tokens.DISTINCT) {\\n                    read();\\n                    readThis(Tokens.FROM);\\n                    r      = XreadRowValuePredicand();\\n                    e      = new ExpressionLogical(OpTypes.NOT_DISTINCT, l, r);\\n                    hasNot = !hasNot;\\n                    break;\\n                }\\n                if (token.tokenType == Tokens.NULL\\n                        || token.tokenType == Tokens.UNKNOWN) {\\n                    read();\\n                    e = new ExpressionLogical(OpTypes.IS_NULL, l);\\n                    break;\\n                }\\n                throw unexpectedToken();\\n            }\\n            case Tokens.LIKE : {\\n                e                = XreadLikePredicateRightPart(l);\\n                e.noOptimisation = isCheckOrTriggerCondition;\\n                break;\\n            }\\n            case Tokens.BETWEEN : {\\n                e = XreadBetweenPredicateRightPart(l);\\n                break;\\n            }\\n            case Tokens.IN : {\\n                e                = XreadInPredicateRightPart(l);\\n                e.noOptimisation = isCheckOrTriggerCondition;\\n                break;\\n            }\\n            case Tokens.OVERLAPS : {\\n                if (hasNot) {\\n                    throw unexpectedToken();\\n                }\\n                e = XreadOverlapsPredicateRightPart(l);\\n                break;\\n            }\\n            case Tokens.EQUALS :\\n            case Tokens.GREATER_EQUALS :\\n            case Tokens.GREATER :\\n            case Tokens.LESS :\\n            case Tokens.LESS_EQUALS :\\n            case Tokens.NOT_EQUALS : {\\n                if (hasNot) {\\n                    throw unexpectedToken();\\n                }\\n                int type = getExpressionType(token.tokenType);\\n                read();\\n                switch (token.tokenType) {\\n                    case Tokens.ANY :\\n                    case Tokens.SOME :\\n                    case Tokens.ALL :\\n                        e = XreadQuantifiedComparisonRightPart(type, l);\\n                        break;\\n                    default : {\\n                        Expression row = XreadRowValuePredicand();\\n                        e = new ExpressionLogical(type, l, row);\\n                        break;\\n                    }\\n                }\\n                break;\\n            }\\n            case Tokens.MATCH : {\\n                e = XreadMatchPredicateRightPart(l);\\n                break;\\n            }\\n            default : {\\n                if (hasNot) {\\n                    throw unexpectedToken();\\n                }\\n                return l;\\n            }\\n        }\\n        if (hasNot) {\\n            e = new ExpressionLogical(OpTypes.NOT, e);\\n        }\\n        return e;\\n    }\\n    private ExpressionLogical XreadBetweenPredicateRightPart(\\n            final Expression a) {\\n        boolean symmetric = false;\\n        read();\\n        if (token.tokenType == Tokens.ASYMMETRIC) {\\n            read();\\n        } else if (token.tokenType == Tokens.SYMMETRIC) {\\n            symmetric = true;\\n            read();\\n        }\\n        Expression left = XreadRowValuePredicand();\\n        readThis(Tokens.AND);\\n        Expression right = XreadRowValuePredicand();\\n        Expression l = new ExpressionLogical(OpTypes.GREATER_EQUAL, a, left);\\n        Expression r = new ExpressionLogical(OpTypes.SMALLER_EQUAL, a, right);\\n        ExpressionLogical leftToRight = new ExpressionLogical(OpTypes.AND, l,\\n            r);\\n        if (symmetric) {\\n            l = new ExpressionLogical(OpTypes.SMALLER_EQUAL, a, left);\\n            r = new ExpressionLogical(OpTypes.GREATER_EQUAL, a, right);\\n            Expression rightToLeft = new ExpressionLogical(OpTypes.AND, l, r);\\n            return new ExpressionLogical(OpTypes.OR, leftToRight, rightToLeft);\\n        } else {\\n            return leftToRight;\\n        }\\n    }\\n    private ExpressionLogical XreadQuantifiedComparisonRightPart(int exprType,\\n            Expression l) {\\n        int        tokenT      = token.tokenType;\\n        int        exprSubType = 0;\\n        Expression e;\\n        switch (token.tokenType) {\\n            case Tokens.ANY :\\n            case Tokens.SOME :\\n                exprSubType = OpTypes.ANY_QUANTIFIED;\\n                break;\\n            case Tokens.ALL :\\n                exprSubType = OpTypes.ALL_QUANTIFIED;\\n                break;\\n            default :\\n                throw Error.runtimeError(ErrorCode.U_S0500, \\\"ParserDQL\\\");\\n        }\\n        read();\\n        readThis(Tokens.OPENBRACKET);\\n        int position = getPosition();\\n        readOpenBrackets();\\n        switch (token.tokenType) {\\n            case Tokens.TABLE :\\n            case Tokens.VALUES :\\n            case Tokens.SELECT :\\n                rewind(position);\\n                SubQuery sq = XreadSubqueryBody(OpTypes.IN);\\n                e = new Expression(OpTypes.TABLE_SUBQUERY, sq);\\n                readThis(Tokens.CLOSEBRACKET);\\n                break;\\n            default :\\n                rewind(position);\\n                e = readAggregateExpression(tokenT);\\n                readThis(Tokens.CLOSEBRACKET);\\n                readFilterClause(e);\\n        }\\n        ExpressionLogical r = new ExpressionLogical(exprType, l, e);\\n        r.setSubType(exprSubType);\\n        return r;\\n    }\\n    private ExpressionLogical XreadInPredicateRightPart(Expression l) {\\n        int        degree = l.getDegree();\\n        Expression e      = null;\\n        read();\\n        readThis(Tokens.OPENBRACKET);\\n        int position = getPosition();\\n        int brackets = readOpenBrackets();\\n        switch (token.tokenType) {\\n            case Tokens.UNNEST :\\n                e = XreadCollectionDerivedTable();\\n                e.getTable().getSubQuery().setUniqueRows();\\n                readThis(Tokens.CLOSEBRACKET);\\n                this.readCloseBrackets(brackets);\\n                break;\\n            case Tokens.TABLE :\\n            case Tokens.VALUES :\\n            case Tokens.SELECT : {\\n                rewind(position);\\n                SubQuery sq = XreadSubqueryBody(OpTypes.IN);\\n                e = new Expression(OpTypes.TABLE_SUBQUERY, sq);\\n                readThis(Tokens.CLOSEBRACKET);\\n                break;\\n            }\\n            default : {\\n                rewind(position);\\n                e = XreadInValueListConstructor(degree);\\n                readThis(Tokens.CLOSEBRACKET);\\n                break;\\n            }\\n        }\\n        ExpressionLogical r;\\n        if (isCheckOrTriggerCondition) {\\n            r = new ExpressionLogical(OpTypes.IN, l, e);\\n        } else {\\n            r = new ExpressionLogical(OpTypes.EQUAL, l, e);\\n            r.setSubType(OpTypes.ANY_QUANTIFIED);\\n        }\\n        return r;\\n    }\\n    Expression XreadInValueList(int degree) {\\n        HsqlArrayList list = new HsqlArrayList();\\n        while (true) {\\n            Expression e = XreadValueExpression();\\n            if (e.getType() != OpTypes.ROW) {\\n                e = new Expression(OpTypes.ROW, new Expression[]{ e });\\n            }\\n            list.add(e);\\n            if (token.tokenType == Tokens.COMMA) {\\n                read();\\n                continue;\\n            }\\n            break;\\n        }\\n        Expression[] array = new Expression[list.size()];\\n        list.toArray(array);\\n        Expression e = new Expression(OpTypes.VALUELIST, array);\\n        for (int i = 0; i < array.length; i++) {\\n            if (array[i].getType() != OpTypes.ROW) {\\n                array[i] = new Expression(OpTypes.ROW,\\n                                          new Expression[]{ array[i] });\\n            }\\n            Expression[] args = array[i].nodes;\\n            if (args.length != degree) {\\n                                throw unexpectedToken();\\n            }\\n            for (int j = 0; j < degree; j++) {\\n                if (args[j].getType() == OpTypes.ROW) {\\n                                        throw unexpectedToken();\\n                }\\n            }\\n        }\\n        return e;\\n    }\\n    private ExpressionLogical XreadLikePredicateRightPart(Expression a) {\\n        read();\\n        Expression b      = XreadStringValueExpression();\\n        Expression escape = null;\\n        if (token.tokenString.equals(Tokens.T_ESCAPE)) {\\n            read();\\n            escape = XreadStringValueExpression();\\n        }\\n        return new ExpressionLike(a, b, escape,\\n                                  this.isCheckOrTriggerCondition);\\n    }\\n    private ExpressionLogical XreadMatchPredicateRightPart(Expression a) {\\n        boolean isUnique  = false;\\n        int     matchType = OpTypes.MATCH_SIMPLE;\\n        read();\\n        if (token.tokenType == Tokens.UNIQUE) {\\n            read();\\n            isUnique = true;\\n        }\\n        if (token.tokenType == Tokens.SIMPLE) {\\n            read();\\n            matchType = isUnique ? OpTypes.MATCH_UNIQUE_SIMPLE\\n                                 : OpTypes.MATCH_SIMPLE;\\n        } else if (token.tokenType == Tokens.PARTIAL) {\\n            read();\\n            matchType = isUnique ? OpTypes.MATCH_UNIQUE_PARTIAL\\n                                 : OpTypes.MATCH_PARTIAL;\\n        } else if (token.tokenType == Tokens.FULL) {\\n            read();\\n            matchType = isUnique ? OpTypes.MATCH_UNIQUE_FULL\\n                                 : OpTypes.MATCH_FULL;\\n        }\\n        int        mode = isUnique ? OpTypes.TABLE_SUBQUERY\\n                                   : OpTypes.IN;\\n        Expression s    = XreadTableSubquery(mode);\\n        return new ExpressionLogical(matchType, a, s);\\n    }\\n    private ExpressionLogical XreadOverlapsPredicateRightPart(Expression l) {\\n        if (l.getType() != OpTypes.ROW) {\\n            throw Error.error(ErrorCode.X_42564);\\n        }\\n        if (l.nodes.length != 2) {\\n            throw Error.error(ErrorCode.X_42564);\\n        }\\n        read();\\n        if (token.tokenType != Tokens.OPENBRACKET) {\\n            throw unexpectedToken();\\n        }\\n        Expression r = XreadRowValuePredicand();\\n        if (r.nodes.length != 2) {\\n            throw Error.error(ErrorCode.X_42564);\\n        }\\n        return new ExpressionLogical(OpTypes.OVERLAPS, l, r);\\n    }\\n    Expression XreadRowValueExpression() {\\n        Expression e = XreadExplicitRowValueConstructorOrNull();\\n        if (e != null) {\\n            return e;\\n        }\\n        return XreadRowValueSpecialCase();\\n    }\\n    Expression XreadTableRowValueConstructor() {\\n        Expression e = XreadExplicitRowValueConstructorOrNull();\\n        if (e != null) {\\n            return e;\\n        }\\n        return XreadRowValueSpecialCase();\\n    }\\n                    Expression XreadRowValuePredicand() {\\n        return XreadRowOrCommonValueExpression();\\n    }\\n    Expression XreadRowValueSpecialCase() {\\n        Expression e = XreadSimpleValueExpressionPrimary();\\n        if (e != null) {\\n            e = XreadArrayElementReference(e);\\n        }\\n        return e;\\n    }\\n            Expression XreadRowValueConstructor() {\\n        Expression e;\\n        e = XreadExplicitRowValueConstructorOrNull();\\n        if (e != null) {\\n            return e;\\n        }\\n        e = XreadRowOrCommonValueExpression();\\n        if (e != null) {\\n            return e;\\n        }\\n        return XreadBooleanValueExpression();\\n    }\\n            Expression XreadExplicitRowValueConstructorOrNull() {\\n        Expression e;\\n        switch (token.tokenType) {\\n            case Tokens.OPENBRACKET : {\\n                read();\\n                int position = getPosition();\\n                int brackets = readOpenBrackets();\\n                switch (token.tokenType) {\\n                    case Tokens.TABLE :\\n                    case Tokens.VALUES :\\n                    case Tokens.SELECT :\\n                        rewind(position);\\n                        SubQuery sq = XreadSubqueryBody(OpTypes.ROW_SUBQUERY);\\n                        readThis(Tokens.CLOSEBRACKET);\\n                        return new Expression(OpTypes.ROW_SUBQUERY, sq);\\n                    default :\\n                        rewind(position);\\n                        e = XreadRowElementList(true);\\n                        readThis(Tokens.CLOSEBRACKET);\\n                        return e;\\n                }\\n            }\\n            case Tokens.ROW : {\\n                read();\\n                readThis(Tokens.OPENBRACKET);\\n                e = XreadRowElementList(false);\\n                readThis(Tokens.CLOSEBRACKET);\\n                return e;\\n            }\\n        }\\n        return null;\\n    }\\n    Expression XreadRowElementList(boolean multiple) {\\n        Expression    e;\\n        HsqlArrayList list = new HsqlArrayList();\\n        while (true) {\\n            e = XreadValueExpression();\\n            list.add(e);\\n            if (token.tokenType == Tokens.COMMA) {\\n                read();\\n                continue;\\n            }\\n            if (multiple && list.size() == 1) {\\n                return e;\\n            }\\n            break;\\n        }\\n        Expression[] array = new Expression[list.size()];\\n        list.toArray(array);\\n        return new Expression(OpTypes.ROW, array);\\n    }\\n    Expression XreadCurrentCollationSpec() {\\n        throw Error.error(ErrorCode.X_0A000);\\n    }\\n    Expression XreadTableSubquery(int mode) {\\n        readThis(Tokens.OPENBRACKET);\\n        SubQuery sq = XreadSubqueryBody(mode);\\n        readThis(Tokens.CLOSEBRACKET);\\n        return new Expression(OpTypes.TABLE_SUBQUERY, sq);\\n    }\\n    Table XreadTableSubqueryOrNull(RangeVariable[] outerRanges) {\\n        boolean joinedTable = false;\\n        int     position;\\n        position = getPosition();\\n        readThis(Tokens.OPENBRACKET);\\n        readOpenBrackets();\\n        switch (token.tokenType) {\\n            case Tokens.TABLE :\\n            case Tokens.VALUES :\\n            case Tokens.SELECT :\\n            case Tokens.WITH :\\n                break;\\n            default :\\n                joinedTable = true;\\n        }\\n        rewind(position);\\n        if (joinedTable) {\\n            return null;\\n        } else {\\n            boolean hasOuter = outerRanges != null;\\n            readThis(Tokens.OPENBRACKET);\\n            SubQuery sq = XreadSubqueryBody(OpTypes.TABLE_SUBQUERY);\\n            HsqlList unresolved =\\n                sq.queryExpression.getUnresolvedExpressions();\\n            if (hasOuter && unresolved != null) {\\n                unresolved = Expression.resolveColumnSet(session, outerRanges,\\n                        outerRanges.length,\\n                        sq.queryExpression.getUnresolvedExpressions(), null);\\n            }\\n            ExpressionColumn.checkColumnsResolved(unresolved);\\n            sq.queryExpression.resolveTypes(session);\\n            sq.prepareTable(session);\\n            readThis(Tokens.CLOSEBRACKET);\\n            return sq.getTable();\\n        }\\n    }\\n    SubQuery XreadJoinedTableAsSubquery() {\\n        readThis(Tokens.OPENBRACKET);\\n        int position = getPosition();\\n        compileContext.subqueryDepth++;\\n        QuerySpecification querySpecification = XreadJoinedTableAsView();\\n        querySpecification.resolve(session);\\n        if (querySpecification.rangeVariables.length < 2) {\\n            throw unexpectedTokenRequire(Tokens.T_JOIN);\\n        }\\n        SubQuery sq = new SubQuery(database, compileContext.subqueryDepth,\\n                                   querySpecification, OpTypes.TABLE_SUBQUERY);\\n        sq.sql = getLastPart(position);\\n        readThis(Tokens.CLOSEBRACKET);\\n        sq.prepareTable(session);\\n        compileContext.subqueryDepth--;\\n        return sq;\\n    }\\n    QuerySpecification XreadJoinedTableAsView() {\\n        QuerySpecification select = new QuerySpecification(compileContext);\\n        Expression         e      = new ExpressionColumn(OpTypes.MULTICOLUMN);\\n        select.addSelectColumnExpression(e);\\n        XreadTableReference(select);\\n        return select;\\n    }\\n    SubQuery XreadTableNamedSubqueryBody(HsqlName name,\\n                                         HsqlName[] columnNames, int type) {\\n        switch (type) {\\n            case OpTypes.RECURSIVE_SUBQUERY : {\\n                SubQuery sq = XreadRecursiveSubqueryBody(name, columnNames);\\n                return sq;\\n            }\\n            case OpTypes.TABLE_SUBQUERY : {\\n                SubQuery sq = XreadSubqueryBody(type);\\n                ExpressionColumn.checkColumnsResolved(\\n                    sq.queryExpression.unresolvedExpressions);\\n                sq.queryExpression.resolveTypes(session);\\n                sq.prepareTable(session, name, columnNames);\\n                return sq;\\n            }\\n            default :\\n                throw super.unexpectedToken();\\n        }\\n    }\\n    SubQuery XreadRecursiveSubqueryBody(HsqlName name,\\n                                        HsqlName[] columnNames) {\\n        int position = getPosition();\\n        compileContext.subqueryDepth++;\\n        compileContext.subqueryDepth++;\\n        QueryExpression queryExpression = XreadSimpleTable();\\n        queryExpression.resolve(session);\\n        SubQuery sq = new SubQuery(database, compileContext.subqueryDepth,\\n                                   queryExpression, OpTypes.TABLE_SUBQUERY);\\n        compileContext.subqueryDepth--;\\n        sq.prepareTable(session, name, columnNames);\\n        compileContext.initSubqueryNames();\\n        compileContext.registerSubquery(name.name, sq);\\n        RangeVariable range = new RangeVariable(sq.getTable(),\\n            compileContext.getNextRangeVarIndex());\\n        RangeVariable[] ranges = new RangeVariable[]{ range };\\n        if (token.tokenType == Tokens.UNION) {\\n            int             unionType            = XreadUnionType();\\n            QueryExpression rightQueryExpression = XreadSimpleTable();\\n            queryExpression = new QueryExpression(compileContext,\\n                                                  queryExpression);\\n            rightQueryExpression.resolveReferences(session, ranges);\\n            queryExpression.addUnion(rightQueryExpression, unionType);\\n            queryExpression.resolve(session);\\n            queryExpression.createTable(session);\\n            sq = new SubQuery(database, compileContext.subqueryDepth,\\n                              queryExpression, sq);\\n            sq.prepareTable(session, name, columnNames);\\n        } else {\\n            throw unexpectedTokenRequire(Tokens.T_UNION);\\n        }\\n        sq.sql = getLastPart(position);\\n        compileContext.subqueryDepth--;\\n        return sq;\\n    }\\n    SubQuery XreadSubqueryBody(int type) {\\n        int position = getPosition();\\n        compileContext.subqueryDepth++;\\n        QueryExpression queryExpression = XreadQueryExpression();\\n        queryExpression.resolveReferences(session, RangeVariable.emptyArray);\\n        SubQuery sq = new SubQuery(database, compileContext.subqueryDepth,\\n                                   queryExpression, type);\\n        sq.sql = getLastPart(position);\\n        compileContext.subqueryDepth--;\\n        return sq;\\n    }\\n    SubQuery XreadViewSubquery(View view) {\\n        compileContext.subqueryDepth++;\\n        QueryExpression queryExpression;\\n        try {\\n            queryExpression = XreadQueryExpression();\\n        } catch (HsqlException e) {\\n            queryExpression = XreadJoinedTableAsView();\\n        }\\n        queryExpression.setView(view);\\n        queryExpression.resolve(session);\\n        SubQuery sq = new SubQuery(database, compileContext.subqueryDepth,\\n                                   queryExpression, view);\\n        compileContext.subqueryDepth--;\\n        return sq;\\n    }\\n    Expression XreadContextuallyTypedTable(int degree) {\\n        Expression   e       = readRow();\\n        Expression[] list    = e.nodes;\\n        boolean      isTable = false;\\n        if (degree == 1) {\\n            if (e.getType() == OpTypes.ROW) {\\n                e.opType = OpTypes.VALUELIST;\\n                for (int i = 0; i < list.length; i++) {\\n                    if (list[i].getType() != OpTypes.ROW) {\\n                        list[i] = new Expression(OpTypes.ROW,\\n                                                 new Expression[]{ list[i] });\\n                    } else if (list[i].nodes.length != degree) {\\n                        throw Error.error(ErrorCode.X_42564);\\n                    }\\n                }\\n                return e;\\n            } else {\\n                e = new Expression(OpTypes.ROW, new Expression[]{ e });\\n                e = new Expression(OpTypes.VALUELIST, new Expression[]{ e });\\n                return e;\\n            }\\n        }\\n        if (e.getType() != OpTypes.ROW) {\\n            throw Error.error(ErrorCode.X_42564);\\n        }\\n        for (int i = 0; i < list.length; i++) {\\n            if (list[i].getType() == OpTypes.ROW) {\\n                isTable = true;\\n                break;\\n            }\\n        }\\n        if (isTable) {\\n            e.opType = OpTypes.VALUELIST;\\n            for (int i = 0; i < list.length; i++) {\\n                if (list[i].getType() != OpTypes.ROW) {\\n                    throw Error.error(ErrorCode.X_42564);\\n                }\\n                Expression[] args = list[i].nodes;\\n                if (args.length != degree) {\\n                    throw Error.error(ErrorCode.X_42564);\\n                }\\n                for (int j = 0; j < degree; j++) {\\n                    if (args[j].getType() == OpTypes.ROW) {\\n                        throw Error.error(ErrorCode.X_42564);\\n                    }\\n                }\\n            }\\n        } else {\\n            if (list.length != degree) {\\n                throw Error.error(ErrorCode.X_42564);\\n            }\\n            e = new Expression(OpTypes.VALUELIST, new Expression[]{ e });\\n        }\\n        return e;\\n    }\\n    private Expression XreadInValueListConstructor(int degree) {\\n        int position = getPosition();\\n        compileContext.subqueryDepth++;\\n        Expression e = XreadInValueList(degree);\\n        SubQuery sq = new SubQuery(database, compileContext.subqueryDepth, e,\\n                                   OpTypes.IN);\\n        sq.sql = getLastPart(position);\\n        compileContext.subqueryDepth--;\\n        return e;\\n    }\\n    private SubQuery XreadRowValueExpressionList() {\\n        compileContext.subqueryDepth++;\\n        Expression e  = XreadRowValueExpressionListBody();\\n        SubQuery   sq = prepareSubquery(e);\\n        compileContext.subqueryDepth--;\\n        return sq;\\n    }\\n    private SubQuery prepareSubquery(Expression e) {\\n        HsqlList unresolved = e.resolveColumnReferences(session,\\n            RangeVariable.emptyArray, null);\\n        ExpressionColumn.checkColumnsResolved(unresolved);\\n        e.resolveTypes(session, null);\\n        e.prepareTable(session, null, e.nodes[0].nodes.length);\\n        SubQuery sq = new SubQuery(database, compileContext.subqueryDepth, e,\\n                                   OpTypes.VALUELIST);\\n        sq.prepareTable(session);\\n        return sq;\\n    }\\n    Expression XreadRowValueExpressionListBody() {\\n        Expression r = null;\\n        while (true) {\\n            int        brackets = readOpenBrackets();\\n            Expression e        = readRow();\\n            readCloseBrackets(brackets);\\n            if (r == null) {\\n                r = new Expression(OpTypes.ROW, new Expression[]{ e });\\n            } else {\\n                r.nodes = (Expression[]) ArrayUtil.resizeArray(r.nodes,\\n                        r.nodes.length + 1);\\n                r.nodes[r.nodes.length - 1] = e;\\n            }\\n            if (token.tokenType != Tokens.COMMA) {\\n                break;\\n            }\\n            read();\\n        }\\n        Expression[] list   = r.nodes;\\n        int          degree = 1;\\n        if (list[0].getType() == OpTypes.ROW) {\\n            degree = list[0].nodes.length;\\n        }\\n        r.opType = OpTypes.VALUELIST;\\n        for (int i = 0; i < list.length; i++) {\\n            if (list[i].getType() == OpTypes.ROW) {\\n                if (list[i].nodes.length != degree) {\\n                    throw Error.error(ErrorCode.X_42564);\\n                }\\n            } else {\\n                if (degree != 1) {\\n                    throw Error.error(ErrorCode.X_42564);\\n                }\\n                list[i] = new Expression(OpTypes.ROW,\\n                                         new Expression[]{ list[i] });\\n            }\\n        }\\n        return r;\\n    }\\n    Expression XreadTargetSpecification(RangeVariable[] rangeVars,\\n                                        LongDeque colIndexList) {\\n        ColumnSchema column = null;\\n        int          index  = -1;\\n        checkIsIdentifier();\\n        if (token.namePrePrePrefix != null) {\\n            checkValidCatalogName(token.namePrePrePrefix);\\n        }\\n        for (int i = 0; i < rangeVars.length; i++) {\\n            if (rangeVars[i] == null) {\\n                continue;\\n            }\\n            index = rangeVars[i].findColumn(token.tokenString);\\n            if (index > -1 && rangeVars[i].resolvesTableName(token.namePrefix)\\n                    && rangeVars[i].resolvesSchemaName(token.namePrePrefix)) {\\n                column = rangeVars[i].getColumn(index);\\n                read();\\n                break;\\n            }\\n        }\\n        if (column == null) {\\n            throw Error.error(ErrorCode.X_42501, token.tokenString);\\n        }\\n        colIndexList.add(index);\\n        if (token.tokenType == Tokens.LEFTBRACKET) {\\n            if (!column.getDataType().isArrayType()) {\\n                throw unexpectedToken();\\n            }\\n            read();\\n            Expression e = XreadNumericValueExpression();\\n            if (e == null) {\\n                throw Error.error(ErrorCode.X_42501, token.tokenString);\\n            }\\n            e = new ExpressionAccessor(column.getAccessor(), e);\\n            readThis(Tokens.RIGHTBRACKET);\\n            return e;\\n        }\\n        return column.getAccessor();\\n    }\\n    Expression XreadCollectionDerivedTable() {\\n        boolean ordinality = false;\\n        int     position   = getPosition();\\n        readThis(Tokens.UNNEST);\\n        readThis(Tokens.OPENBRACKET);\\n        compileContext.subqueryDepth++;\\n        Expression e = XreadValueExpression();\\n        compileContext.subqueryDepth--;\\n        readThis(Tokens.CLOSEBRACKET);\\n        if (token.tokenType == Tokens.WITH) {\\n            read();\\n            readThis(Tokens.ORDINALITY);\\n            ordinality = true;\\n        }\\n        e = new ExpressionTable(e, null, ordinality);\\n        SubQuery sq = new SubQuery(database, compileContext.subqueryDepth, e,\\n                                   OpTypes.TABLE_SUBQUERY);\\n        sq.createTable();\\n        sq.sql = getLastPart(position);\\n        return e;\\n    }\\n    Expression XreadTableFunctionDerivedTable() {\\n        int position = getPosition();\\n        readThis(Tokens.TABLE);\\n        readThis(Tokens.OPENBRACKET);\\n        compileContext.subqueryDepth++;\\n        Expression e = this.XreadValueExpression();\\n        if (e.getType() != OpTypes.FUNCTION\\n                && e.getType() != OpTypes.SQL_FUNCTION) {\\n            compileContext.subqueryDepth--;\\n            throw this.unexpectedToken(Tokens.T_TABLE);\\n        }\\n        readThis(Tokens.CLOSEBRACKET);\\n        e = new ExpressionTable(e, null, false);\\n        SubQuery sq = new SubQuery(database, compileContext.subqueryDepth, e,\\n                                   OpTypes.TABLE_SUBQUERY);\\n        sq.createTable();\\n        sq.sql = getLastPart(position);\\n        compileContext.subqueryDepth--;\\n        return e;\\n    }\\n    Expression XreadLateralDerivedTable() {\\n        readThis(Tokens.LATERAL);\\n        readThis(Tokens.OPENBRACKET);\\n        int position = getPosition();\\n        compileContext.subqueryDepth++;\\n        QueryExpression queryExpression = XreadQueryExpression();\\n        SubQuery sq = new SubQuery(database, compileContext.subqueryDepth,\\n                                   queryExpression, OpTypes.TABLE_SUBQUERY);\\n        sq.createTable();\\n        sq.sql = getLastPart(position);\\n        compileContext.subqueryDepth--;\\n        readThis(Tokens.CLOSEBRACKET);\\n        return new Expression(OpTypes.TABLE_SUBQUERY, sq);\\n    }\\n    Expression XreadArrayConstructor() {\\n        readThis(Tokens.OPENBRACKET);\\n        int position = getPosition();\\n        compileContext.subqueryDepth++;\\n        QueryExpression queryExpression = XreadQueryExpression();\\n        queryExpression.resolveReferences(session, RangeVariable.emptyArray);\\n        SubQuery sq = new SubQuery(database, compileContext.subqueryDepth,\\n                                   queryExpression, OpTypes.TABLE_SUBQUERY);\\n        sq.sql = getLastPart(position);\\n        compileContext.subqueryDepth--;\\n        readThis(Tokens.CLOSEBRACKET);\\n        return new Expression(OpTypes.ARRAY_SUBQUERY, sq);\\n    }\\n        SchemaObject readCollateClauseOrNull() {\\n        if (token.tokenType == Tokens.COLLATE) {\\n            read();\\n            SchemaObject collation =\\n                database.schemaManager.getSchemaObject(token.namePrefix,\\n                    token.tokenString, SchemaObject.COLLATION);\\n            return collation;\\n        }\\n        return null;\\n    }\\n    Expression XreadArrayElementReference(Expression e) {\\n        if (token.tokenType == Tokens.LEFTBRACKET) {\\n            read();\\n            Expression e1 = XreadNumericValueExpression();\\n            readThis(Tokens.RIGHTBRACKET);\\n            e = new ExpressionAccessor(e, e1);\\n        }\\n        return e;\\n    }\\n    Expression readRow() {\\n        Expression r = null;\\n        while (true) {\\n            Expression e = XreadValueExpressionWithContext();\\n            if (r == null) {\\n                r = e;\\n            } else if (r.getType() == OpTypes.ROW) {\\n                if (e.getType() == OpTypes.ROW\\n                        && r.nodes[0].getType() != OpTypes.ROW) {\\n                    r = new Expression(OpTypes.ROW, new Expression[] {\\n                        r, e\\n                    });\\n                } else {\\n                    r.nodes = (Expression[]) ArrayUtil.resizeArray(r.nodes,\\n                            r.nodes.length + 1);\\n                    r.nodes[r.nodes.length - 1] = e;\\n                }\\n            } else {\\n                r = new Expression(OpTypes.ROW, new Expression[] {\\n                    r, e\\n                });\\n            }\\n            if (token.tokenType != Tokens.COMMA) {\\n                break;\\n            }\\n            read();\\n        }\\n        return r;\\n    }\\n    Expression readCaseExpression() {\\n        Expression predicand = null;\\n        read();\\n        if (token.tokenType != Tokens.WHEN) {\\n            predicand = XreadRowValuePredicand();\\n        }\\n        return readCaseWhen(predicand);\\n    }\\n    private Expression readCaseWhen(final Expression l) {\\n        readThis(Tokens.WHEN);\\n        Expression condition = null;\\n        if (l == null) {\\n            condition = XreadBooleanValueExpression();\\n        } else {\\n            while (true) {\\n                Expression newCondition = XreadPredicateRightPart(l);\\n                if (l == newCondition) {\\n                    newCondition =\\n                        new ExpressionLogical(l, XreadRowValuePredicand());\\n                }\\n                if (condition == null) {\\n                    condition = newCondition;\\n                } else {\\n                    condition = new ExpressionLogical(OpTypes.OR, condition,\\n                                                      newCondition);\\n                }\\n                if (token.tokenType == Tokens.COMMA) {\\n                    read();\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n        readThis(Tokens.THEN);\\n        Expression current  = XreadValueExpression();\\n        Expression elseExpr = null;\\n        if (token.tokenType == Tokens.WHEN) {\\n            elseExpr = readCaseWhen(l);\\n        } else if (token.tokenType == Tokens.ELSE) {\\n            read();\\n            elseExpr = XreadValueExpression();\\n            readThis(Tokens.END);\\n            readIfThis(Tokens.CASE);\\n        } else {\\n            elseExpr = new ExpressionValue((Object) null, Type.SQL_ALL_TYPES);\\n            readThis(Tokens.END);\\n            readIfThis(Tokens.CASE);\\n        }\\n        Expression alternatives = new ExpressionOp(OpTypes.ALTERNATIVE,\\n            current, elseExpr);\\n        Expression casewhen = new ExpressionOp(OpTypes.CASEWHEN, condition,\\n                                               alternatives);\\n        return casewhen;\\n    }\\n    private Expression readCaseWhenExpression() {\\n        Expression l = null;\\n        read();\\n        readThis(Tokens.OPENBRACKET);\\n        l = XreadBooleanValueExpression();\\n        readThis(Tokens.COMMA);\\n        Expression thenelse = XreadValueExpression();\\n        readThis(Tokens.COMMA);\\n        thenelse = new ExpressionOp(OpTypes.ALTERNATIVE, thenelse,\\n                                    XreadValueExpression());\\n        l = new ExpressionOp(OpTypes.CASEWHEN, l, thenelse);\\n        readThis(Tokens.CLOSEBRACKET);\\n        return l;\\n    }\\n    private Expression readCastExpression() {\\n        boolean    isConvert = token.tokenType == Tokens.CONVERT;\\n        Expression e;\\n        Type       typeObject;\\n        read();\\n        readThis(Tokens.OPENBRACKET);\\n        if (isConvert) {\\n            if (database.sqlSyntaxMss) {\\n                typeObject = readTypeDefinition(false, true);\\n                readThis(Tokens.COMMA);\\n                e = this.XreadValueExpressionOrNull();\\n            } else {\\n                e = this.XreadValueExpressionOrNull();\\n                readThis(Tokens.COMMA);\\n                typeObject = Type.getTypeForJDBCConvertToken(token.tokenType);\\n                if (typeObject == null) {\\n                    typeObject = readTypeDefinition(false, true);\\n                } else {\\n                    read();\\n                }\\n            }\\n        } else {\\n            e = this.XreadValueExpressionOrNull();\\n            readThis(Tokens.AS);\\n            typeObject = readTypeDefinition(false, true);\\n        }\\n        if (e.isUnresolvedParam()) {\\n            e.setDataType(session, typeObject);\\n        } else {\\n            e = new ExpressionOp(e, typeObject);\\n        }\\n        readThis(Tokens.CLOSEBRACKET);\\n        return e;\\n    }\\n    private Expression readColumnOrFunctionExpression() {\\n        String  name           = token.tokenString;\\n        boolean isSimpleQuoted = isDelimitedSimpleName();\\n        String  prefix         = token.namePrefix;\\n        String  prePrefix      = token.namePrePrefix;\\n        String  prePrePrefix   = token.namePrePrePrefix;\\n        Token   recordedToken  = getRecordedToken();\\n        checkIsIdentifier();\\n        if (isUndelimitedSimpleName()) {\\n            FunctionSQL function =\\n                FunctionCustom.newCustomFunction(token.tokenString,\\n                                                 token.tokenType);\\n            if (function != null) {\\n                int pos = getPosition();\\n                try {\\n                    Expression e = readSQLFunction(function);\\n                    if (e != null) {\\n                        return e;\\n                    }\\n                } catch (HsqlException ex) {\\n                    ex.setLevel(compileContext.subqueryDepth);\\n                    if (lastError == null\\n                            || lastError.getLevel() < ex.getLevel()) {\\n                        lastError = ex;\\n                    }\\n                    rewind(pos);\\n                }\\n            } else if (isReservedKey()) {\\n                function = FunctionSQL.newSQLFunction(name, compileContext);\\n                if (function != null) {\\n                    Expression e = readSQLFunction(function);\\n                    if (e != null) {\\n                        return e;\\n                    }\\n                }\\n            }\\n        }\\n        read();\\n        if (token.tokenType != Tokens.OPENBRACKET) {\\n            checkValidCatalogName(prePrePrefix);\\n            Expression column = new ExpressionColumn(prePrefix, prefix, name);\\n            return column;\\n        }\\n        if (prePrePrefix != null) {\\n            throw Error.error(ErrorCode.X_42551, prePrePrefix);\\n        }\\n        checkValidCatalogName(prePrefix);\\n        prefix = session.getSchemaName(prefix);\\n        RoutineSchema routineSchema =\\n            (RoutineSchema) database.schemaManager.findSchemaObject(name,\\n                prefix, SchemaObject.FUNCTION);\\n        if (routineSchema == null && isSimpleQuoted) {\\n            HsqlName schema =\\n                database.schemaManager.getDefaultSchemaHsqlName();\\n            routineSchema =\\n                (RoutineSchema) database.schemaManager.findSchemaObject(name,\\n                    schema.name, SchemaObject.FUNCTION);\\n            if (routineSchema == null) {\\n                Routine.createRoutines(session, schema, name);\\n                routineSchema =\\n                    (RoutineSchema) database.schemaManager.findSchemaObject(\\n                        name, schema.name, SchemaObject.FUNCTION);\\n            }\\n        }\\n        if (routineSchema == null) {\\n            throw Error.error(ErrorCode.X_42501, name);\\n        }\\n        HsqlArrayList list = new HsqlArrayList();\\n        readThis(Tokens.OPENBRACKET);\\n        if (token.tokenType == Tokens.CLOSEBRACKET) {\\n            read();\\n        } else {\\n            while (true) {\\n                Expression e = XreadValueExpression();\\n                list.add(e);\\n                if (token.tokenType == Tokens.COMMA) {\\n                    read();\\n                } else {\\n                    readThis(Tokens.CLOSEBRACKET);\\n                    break;\\n                }\\n            }\\n        }\\n        FunctionSQLInvoked function  = new FunctionSQLInvoked(routineSchema);\\n        Expression[]       arguments = new Expression[list.size()];\\n        list.toArray(arguments);\\n        function.setArguments(arguments);\\n        compileContext.addFunctionCall(function);\\n        recordedToken.setExpression(routineSchema);\\n        return function;\\n    }\\n    Expression readCollection(int type) {\\n        read();\\n        if (token.tokenType == Tokens.OPENBRACKET) {\\n            return XreadArrayConstructor();\\n        } else {\\n            readThis(Tokens.LEFTBRACKET);\\n            HsqlArrayList list = new HsqlArrayList();\\n            for (int i = 0; ; i++) {\\n                if (token.tokenType == Tokens.RIGHTBRACKET) {\\n                    read();\\n                    break;\\n                }\\n                if (i > 0) {\\n                    readThis(Tokens.COMMA);\\n                }\\n                Expression e = XreadValueExpressionOrNull();\\n                list.add(e);\\n            }\\n            Expression[] array = new Expression[list.size()];\\n            list.toArray(array);\\n            return new Expression(OpTypes.ARRAY, array);\\n        }\\n    }\\n    private Expression readDecodeExpression() {\\n                read();\\n        readThis(Tokens.OPENBRACKET);\\n        Expression casewhen    = null;\\n        Expression alternative = null;\\n        Expression main        = XreadValueExpression();\\n        readThis(Tokens.COMMA);\\n        do {\\n            Expression v = XreadValueExpression();\\n            if (token.tokenType == Tokens.COMMA) {\\n                readThis(Tokens.COMMA);\\n            } else {\\n                if (alternative == null) {\\n                    throw unexpectedToken();\\n                }\\n                alternative.setRightNode(v);\\n                break;\\n            }\\n            Expression l = new ExpressionLogical(main, v);\\n            Expression r = XreadValueExpression();\\n            Expression a = new ExpressionOp(OpTypes.ALTERNATIVE, r, null);\\n            Expression c = new ExpressionOp(OpTypes.CASEWHEN, l, a);\\n            if (casewhen == null) {\\n                casewhen = c;\\n            } else {\\n                alternative.setRightNode(c);\\n            }\\n            alternative = a;\\n            if (token.tokenType == Tokens.COMMA) {\\n                readThis(Tokens.COMMA);\\n            } else {\\n                alternative.setRightNode(new ExpressionValue(null, null));;\\n                break;\\n            }\\n        } while (true);\\n        readThis(Tokens.CLOSEBRACKET);\\n        return casewhen;\\n    }\\n    private Expression readConcatExpression() {\\n        Expression root;\\n        Expression r;\\n                read();\\n        readThis(Tokens.OPENBRACKET);\\n        root = XreadValueExpression();\\n        readThis(Tokens.COMMA);\\n        do {\\n            r    = XreadValueExpression();\\n            root = new ExpressionArithmetic(OpTypes.CONCAT, root, r);\\n            if (token.tokenType == Tokens.COMMA) {\\n                readThis(Tokens.COMMA);\\n            } else if (token.tokenType == Tokens.CLOSEBRACKET) {\\n                readThis(Tokens.CLOSEBRACKET);\\n                break;\\n            }\\n        } while (true);\\n        return root;\\n    }\\n    private Expression readLeastExpression() {\\n                read();\\n        readThis(Tokens.OPENBRACKET);\\n        Expression casewhen = null;\\n        do {\\n            casewhen = readValue(casewhen, OpTypes.SMALLER);\\n            if (token.tokenType == Tokens.COMMA) {\\n                readThis(Tokens.COMMA);\\n            } else {\\n                break;\\n            }\\n        } while (true);\\n        readThis(Tokens.CLOSEBRACKET);\\n        return casewhen;\\n    }\\n    private Expression readGreatestExpression() {\\n                read();\\n        readThis(Tokens.OPENBRACKET);\\n        Expression casewhen = null;\\n        do {\\n            casewhen = readValue(casewhen, OpTypes.GREATER);\\n            if (token.tokenType == Tokens.COMMA) {\\n                readThis(Tokens.COMMA);\\n            } else {\\n                break;\\n            }\\n        } while (true);\\n        readThis(Tokens.CLOSEBRACKET);\\n        return casewhen;\\n    }\\n    private Expression readValue(Expression e, int opType) {\\n        Expression r = XreadValueExpression();\\n        if (e == null) {\\n            return r;\\n        }\\n        Expression l = new ExpressionLogical(opType, e, r);\\n        Expression a = new ExpressionOp(OpTypes.ALTERNATIVE, e, r);\\n        return new ExpressionOp(OpTypes.CASEWHEN, l, a);\\n    }\\n    private Expression readNullIfExpression() {\\n                read();\\n        readThis(Tokens.OPENBRACKET);\\n        Expression c = XreadValueExpression();\\n        readThis(Tokens.COMMA);\\n        Expression thenelse =\\n            new ExpressionOp(OpTypes.ALTERNATIVE,\\n                             new ExpressionValue((Object) null, (Type) null),\\n                             c);\\n        c = new ExpressionLogical(c, XreadValueExpression());\\n        c = new ExpressionOp(OpTypes.CASEWHEN, c, thenelse);\\n        readThis(Tokens.CLOSEBRACKET);\\n        return c;\\n    }\\n    private Expression readCoalesceExpression() {\\n        Expression c = null;\\n                read();\\n        readThis(Tokens.OPENBRACKET);\\n        Expression leaf = null;\\n        while (true) {\\n            Expression current = XreadValueExpression();\\n            if (leaf != null && token.tokenType == Tokens.CLOSEBRACKET) {\\n                readThis(Tokens.CLOSEBRACKET);\\n                leaf.setLeftNode(current);\\n                break;\\n            }\\n            Expression condition = new ExpressionLogical(OpTypes.IS_NULL,\\n                current);\\n            Expression alternatives = new ExpressionOp(OpTypes.ALTERNATIVE,\\n                new ExpressionValue((Object) null, (Type) null), current);\\n            Expression casewhen = new ExpressionOp(OpTypes.CASEWHEN_COALESCE,\\n                                                   condition, alternatives);\\n            if (c == null) {\\n                c = casewhen;\\n            } else {\\n                leaf.setLeftNode(casewhen);\\n            }\\n            leaf = alternatives;\\n            readThis(Tokens.COMMA);\\n        }\\n        return c;\\n    }\\n    Expression readSQLFunction(FunctionSQL function) {\\n        int position = getPosition();\\n        read();\\n        short[] parseList = function.parseList;\\n        if (parseList.length == 0) {\\n            return function;\\n        }\\n        HsqlArrayList exprList      = new HsqlArrayList();\\n        boolean       isOpenBracket = token.tokenType == Tokens.OPENBRACKET;\\n        try {\\n            readExpression(exprList, parseList, 0, parseList.length, false);\\n            lastError = null;\\n        } catch (HsqlException e) {\\n            if (!isOpenBracket) {\\n                rewind(position);\\n                return null;\\n            }\\n            if (function.parseListAlt == null) {\\n                throw e;\\n            }\\n            rewind(position);\\n            read();\\n            parseList = function.parseListAlt;\\n            exprList  = new HsqlArrayList();\\n            readExpression(exprList, parseList, 0, parseList.length, false);\\n            lastError = null;\\n        }\\n        Expression[] expr = new Expression[exprList.size()];\\n        exprList.toArray(expr);\\n        function.setArguments(expr);\\n        return function.getFunctionExpression();\\n    }\\n    void readExpression(HsqlArrayList exprList, short[] parseList, int start,\\n                        int count, boolean isOption) {\\n        for (int i = start; i < start + count; i++) {\\n            int exprType = parseList[i];\\n            switch (exprType) {\\n                case Tokens.QUESTION : {\\n                    Expression e = null;\\n                    e = XreadAllTypesCommonValueExpression(false);\\n                    exprList.add(e);\\n                    continue;\\n                }\\n                case Tokens.X_POS_INTEGER : {\\n                    Expression e     = null;\\n                    Integer    value = readIntegerObject();\\n                    if (value.intValue() < 0) {\\n                        throw Error.error(ErrorCode.X_42592);\\n                    }\\n                    e = new ExpressionValue(value, Type.SQL_INTEGER);\\n                    exprList.add(e);\\n                    continue;\\n                }\\n                case Tokens.X_OPTION : {\\n                    i++;\\n                    int expressionCount  = exprList.size();\\n                    int position         = getPosition();\\n                    int elementCount     = parseList[i++];\\n                    int initialExprIndex = exprList.size();\\n                    try {\\n                        readExpression(exprList, parseList, i, elementCount,\\n                                       true);\\n                    } catch (HsqlException ex) {\\n                        ex.setLevel(compileContext.subqueryDepth);\\n                        if (lastError == null\\n                                || lastError.getLevel() < ex.getLevel()) {\\n                            lastError = ex;\\n                        }\\n                        rewind(position);\\n                        exprList.setSize(expressionCount);\\n                        for (int j = i; j < i + elementCount; j++) {\\n                            if (parseList[j] == Tokens.QUESTION\\n                                    || parseList[j] == Tokens.X_KEYSET\\n                                    || parseList[j] == Tokens.X_POS_INTEGER) {\\n                                exprList.add(null);\\n                            }\\n                        }\\n                        i += elementCount - 1;\\n                        continue;\\n                    }\\n                    if (initialExprIndex == exprList.size()) {\\n                        exprList.add(null);\\n                    }\\n                    i += elementCount - 1;\\n                    continue;\\n                }\\n                case Tokens.X_REPEAT : {\\n                    i++;\\n                    int elementCount = parseList[i++];\\n                    int parseIndex   = i;\\n                    while (true) {\\n                        int initialExprIndex = exprList.size();\\n                        readExpression(exprList, parseList, parseIndex,\\n                                       elementCount, true);\\n                        if (exprList.size() == initialExprIndex) {\\n                            break;\\n                        }\\n                    }\\n                    i += elementCount - 1;\\n                    continue;\\n                }\\n                case Tokens.X_KEYSET : {\\n                    int        elementCount = parseList[++i];\\n                    Expression e            = null;\\n                    if (ArrayUtil.find(parseList, token.tokenType, i\\n                                       + 1, elementCount) == -1) {\\n                        if (!isOption) {\\n                            throw unexpectedToken();\\n                        }\\n                    } else {\\n                        e = new ExpressionValue(\\n                            ValuePool.getInt(token.tokenType),\\n                            Type.SQL_INTEGER);\\n                        read();\\n                    }\\n                    exprList.add(e);\\n                    i += elementCount;\\n                    continue;\\n                }\\n                case Tokens.OPENBRACKET :\\n                case Tokens.CLOSEBRACKET :\\n                case Tokens.COMMA :\\n                default :\\n                    if (token.tokenType != exprType) {\\n                        throw unexpectedToken();\\n                    }\\n                    read();\\n                    continue;\\n            }\\n        }\\n    }\\n    private Expression readSequenceExpressionOrNull(int opType) {\\n        int position = getPosition();\\n        read();\\n        if (token.tokenType != Tokens.VALUE) {\\n            rewind(position);\\n            return null;\\n        }\\n        readThis(Tokens.VALUE);\\n        readThis(Tokens.FOR);\\n        checkIsSchemaObjectName();\\n        String schema = session.getSchemaName(token.namePrefix);\\n        NumberSequence sequence =\\n            database.schemaManager.getSequence(token.tokenString, schema,\\n                                               true);\\n        Token recordedToken = getRecordedToken();\\n        read();\\n        Expression e = new ExpressionColumn(sequence, opType);\\n        recordedToken.setExpression(sequence);\\n        compileContext.addSequence(sequence);\\n        return e;\\n    }\\n    SimpleName readSimpleName() {\\n        checkIsSimpleName();\\n        SimpleName name = HsqlNameManager.getSimpleName(token.tokenString,\\n            isDelimitedIdentifier());\\n        read();\\n        return name;\\n    }\\n    HsqlName readNewSchemaName() {\\n        checkIsSchemaObjectName();\\n        checkValidCatalogName(token.namePrefix);\\n        SqlInvariants.checkSchemaNameNotSystem(token.tokenString);\\n        HsqlName name = database.nameManager.newHsqlName(token.tokenString,\\n            isDelimitedIdentifier(), SchemaObject.SCHEMA);\\n        read();\\n        return name;\\n    }\\n    HsqlName readNewSchemaObjectName(int type, boolean checkSchema) {\\n        checkIsSchemaObjectName();\\n        HsqlName hsqlName = database.nameManager.newHsqlName(token.tokenString,\\n            isDelimitedIdentifier(), type);\\n        if (token.namePrefix != null) {\\n            switch (type) {\\n                case SchemaObject.LABEL :\\n                case SchemaObject.VARIABLE :\\n                case SchemaObject.GRANTEE :\\n                case SchemaObject.CATALOG :\\n                    throw unexpectedToken();\\n                case SchemaObject.CURSOR : {\\n                    if (token.namePrePrefix == null\\n                            && Tokens.T_MODULE.equals(token.namePrefix)\\n                            && !token.isDelimitedPrefix) {}\\n                    else {\\n                        throw unexpectedTokenRequire(Tokens.T_MODULE);\\n                    }\\n                    break;\\n                }\\n                case SchemaObject.SCHEMA : {\\n                    checkValidCatalogName(token.namePrefix);\\n                    if (token.namePrePrefix != null) {\\n                        throw tooManyIdentifiers();\\n                    }\\n                    break;\\n                }\\n                case SchemaObject.SERVER :\\n                case SchemaObject.WRAPPER : {\\n                    checkValidCatalogName(token.namePrefix);\\n                    if (token.namePrePrefix != null) {\\n                        throw tooManyIdentifiers();\\n                    }\\n                    break;\\n                }\\n                case SchemaObject.COLUMN : {\\n                    if (token.namePrefix != null) {\\n                        throw tooManyIdentifiers();\\n                    }\\n                    break;\\n                }\\n                default : {\\n                    checkValidCatalogName(token.namePrePrefix);\\n                    HsqlName schemaName;\\n                    if (checkSchema) {\\n                        schemaName =\\n                            session.getSchemaHsqlName(token.namePrefix);\\n                    } else {\\n                        schemaName =\\n                            session.database.schemaManager.findSchemaHsqlName(\\n                                token.namePrefix);\\n                        if (schemaName == null) {\\n                            schemaName = database.nameManager.newHsqlName(\\n                                token.namePrefix, isDelimitedIdentifier(),\\n                                SchemaObject.SCHEMA);\\n                        }\\n                    }\\n                    hsqlName.setSchemaIfNull(schemaName);\\n                    break;\\n                }\\n            }\\n        }\\n        read();\\n        return hsqlName;\\n    }\\n    HsqlName readNewDependentSchemaObjectName(HsqlName parentName, int type) {\\n        HsqlName name = readNewSchemaObjectName(type, true);\\n        name.parent = parentName;\\n        name.setSchemaIfNull(parentName.schema);\\n        if (name.schema != null && parentName.schema != null\\n                && name.schema != parentName.schema) {\\n            throw Error.error(ErrorCode.X_42505, token.namePrefix);\\n        }\\n        return name;\\n    }\\n    HsqlName readSchemaName() {\\n        checkIsSchemaObjectName();\\n        checkValidCatalogName(token.namePrefix);\\n        HsqlName schema = session.getSchemaHsqlName(token.tokenString);\\n        read();\\n        return schema;\\n    }\\n    SchemaObject readSchemaObjectName(int type) {\\n        checkIsSchemaObjectName();\\n        checkValidCatalogName(token.namePrePrefix);\\n        String schema = session.getSchemaName(token.namePrefix);\\n        SchemaObject object =\\n            database.schemaManager.getSchemaObject(token.tokenString, schema,\\n                type);\\n        read();\\n        return object;\\n    }\\n    SchemaObject readSchemaObjectName(HsqlName schemaName, int type) {\\n        checkIsSchemaObjectName();\\n        SchemaObject object =\\n            database.schemaManager.getSchemaObject(token.tokenString,\\n                schemaName.name, type);\\n        if (token.namePrefix != null) {\\n            if (!token.namePrefix.equals(schemaName.name)) {\\n                                throw Error.error(ErrorCode.X_42505, token.namePrefix);\\n            }\\n            if (token.namePrePrefix != null) {\\n                if (!token.namePrePrefix.equals(\\n                        database.getCatalogName().name)) {\\n                                        throw Error.error(ErrorCode.X_42505, token.namePrefix);\\n                }\\n            }\\n        }\\n        read();\\n        return object;\\n    }\\n    Table readTableName() {\\n        checkIsIdentifier();\\n        if (token.namePrePrefix != null) {\\n            checkValidCatalogName(token.namePrePrefix);\\n        }\\n        Table table = database.schemaManager.getTable(session,\\n            token.tokenString, token.namePrefix);\\n        getRecordedToken().setExpression(table);\\n        read();\\n        return table;\\n    }\\n    ColumnSchema readSimpleColumnName(RangeVariable rangeVar) {\\n        ColumnSchema column = null;\\n        checkIsIdentifier();\\n        if (token.namePrefix != null) {\\n            throw tooManyIdentifiers();\\n        }\\n        int index = rangeVar.findColumn(token.tokenString);\\n        if (index > -1 && rangeVar.resolvesTableName(token.namePrefix)\\n                && rangeVar.resolvesSchemaName(token.namePrePrefix)) {\\n            column = rangeVar.getTable().getColumn(index);\\n            read();\\n            return column;\\n        }\\n        throw Error.error(ErrorCode.X_42501, token.tokenString);\\n    }\\n    ColumnSchema readSimpleColumnName(Table table) {\\n        checkIsIdentifier();\\n        if (token.namePrefix != null) {\\n            throw tooManyIdentifiers();\\n        }\\n        int index = table.findColumn(token.tokenString);\\n        if (index == -1) {\\n            throw Error.error(ErrorCode.X_42501, token.tokenString);\\n        }\\n        ColumnSchema column = table.getColumn(index);\\n        read();\\n        return column;\\n    }\\n    StatementQuery compileDeclareCursor(boolean isRoutine,\\n                                        RangeVariable[] outerRanges) {\\n        int sensitivity   = ResultConstants.SQL_ASENSITIVE;\\n        int scrollability = ResultConstants.SQL_NONSCROLLABLE;\\n        int holdability   = ResultConstants.SQL_NONHOLDABLE;\\n        int returnability = ResultConstants.SQL_WITHOUT_RETURN;\\n        int position      = super.getPosition();\\n        readThis(Tokens.DECLARE);\\n        SimpleName cursorName = readSimpleName();\\n        switch (token.tokenType) {\\n            case Tokens.SENSITIVE :\\n                read();\\n                sensitivity = ResultConstants.SQL_SENSITIVE;\\n                break;\\n            case Tokens.INSENSITIVE :\\n                read();\\n                sensitivity = ResultConstants.SQL_INSENSITIVE;\\n                break;\\n            case Tokens.ASENSITIVE :\\n                read();\\n                break;\\n        }\\n        if (token.tokenType == Tokens.NO) {\\n            readThis(Tokens.SCROLL);\\n        } else {\\n            if (token.tokenType == Tokens.SCROLL) {\\n                read();\\n                scrollability = ResultConstants.SQL_SCROLLABLE;\\n            }\\n        }\\n        if (token.tokenType != Tokens.CURSOR) {\\n            rewind(position);\\n            return null;\\n        }\\n        readThis(Tokens.CURSOR);\\n        for (int round = 0; round < 2; round++) {\\n            if (token.tokenType == Tokens.WITH) {\\n                read();\\n                if (round == 0 && token.tokenType == Tokens.HOLD) {\\n                    read();\\n                    holdability = ResultConstants.SQL_HOLDABLE;\\n                } else {\\n                    readThis(Tokens.RETURN);\\n                    round++;\\n                    returnability = ResultConstants.SQL_WITH_RETURN;\\n                }\\n            } else if (token.tokenType == Tokens.WITHOUT) {\\n                read();\\n                if (round == 0 && token.tokenType == Tokens.HOLD) {\\n                    read();\\n                } else {\\n                    readThis(Tokens.RETURN);\\n                    round++;\\n                }\\n            }\\n        }\\n        readThis(Tokens.FOR);\\n        int props = ResultProperties.getProperties(sensitivity,\\n            ResultConstants.SQL_UPDATABLE, scrollability, holdability,\\n            returnability);\\n        StatementQuery cs = compileCursorSpecification(props, isRoutine,\\n            outerRanges);\\n        cs.setCursorName(cursorName);\\n        return cs;\\n    }\\n    StatementQuery compileCursorSpecification(int props, boolean isRoutine,\\n            RangeVariable[] outerRanges) {\\n        OrderedHashSet  colNames        = null;\\n        QueryExpression queryExpression = XreadQueryExpression();\\n        if (token.tokenType == Tokens.FOR) {\\n            read();\\n            if (token.tokenType == Tokens.READ) {\\n                read();\\n                readThis(Tokens.ONLY);\\n            } else {\\n                readThis(Tokens.UPDATE);\\n                props = ResultProperties.addUpdatable(props, true);\\n                if (token.tokenType == Tokens.OF) {\\n                    readThis(Tokens.OF);\\n                    colNames = new OrderedHashSet();\\n                    readColumnNameList(colNames, null, false);\\n                }\\n            }\\n        }\\n        if (ResultProperties.isUpdatable(props)) {\\n            queryExpression.isUpdatable = true;\\n        }\\n        queryExpression.setReturningResult();\\n        queryExpression.resolve(session, outerRanges, null);\\n        StatementQuery cs = isRoutine\\n                            ? new StatementCursor(session, queryExpression,\\n                                compileContext)\\n                            : new StatementQuery(session, queryExpression,\\n                                compileContext);\\n        return cs;\\n    }\\n    StatementDMQL compileShortCursorSpecification(int props) {\\n        QueryExpression queryExpression = XreadQueryExpression();\\n        if (ResultProperties.isUpdatable(props)) {\\n            queryExpression.isUpdatable = true;\\n        }\\n        queryExpression.setReturningResult();\\n        queryExpression.resolve(session);\\n        StatementDMQL cs = new StatementQuery(session, queryExpression,\\n                                              compileContext);\\n        return cs;\\n    }\\n    int readCloseBrackets(int limit) {\\n        int count = 0;\\n        while (count < limit && token.tokenType == Tokens.CLOSEBRACKET) {\\n            read();\\n            count++;\\n        }\\n        return count;\\n    }\\n    int readOpenBrackets() {\\n        int count = 0;\\n        while (token.tokenType == Tokens.OPENBRACKET) {\\n            count++;\\n            read();\\n        }\\n        return count;\\n    }\\n    void checkValidCatalogName(String name) {\\n        if (name != null && !name.equals(database.getCatalogName().name)) {\\n            throw Error.error(ErrorCode.X_42501, name);\\n        }\\n    }\\n    void rewind(int position) {\\n        super.rewind(position);\\n        compileContext.rewind(position);\\n    }\\n    public static final class CompileContext {\\n        final Session    session;\\n        final ParserBase parser;\\n                private int           subqueryDepth;\\n        private HsqlArrayList namedSubqueries;\\n                private OrderedIntKeyHashMap parameters = new OrderedIntKeyHashMap();\\n        private HsqlArrayList        usedSequences  = new HsqlArrayList(true);\\n        private HsqlArrayList        usedRoutines   = new HsqlArrayList(true);\\n        private HsqlArrayList        rangeVariables = new HsqlArrayList(true);\\n        private HsqlArrayList        usedObjects    = new HsqlArrayList(true);\\n        Type                         currentDomain;\\n        boolean                      contextuallyTypedExpression;\\n        Routine                      callProcedure;\\n                private int rangeVarIndex = 0;\\n        public CompileContext(Session session, ParserBase parser) {\\n            this.session = session;\\n            this.parser  = parser;\\n            reset();\\n        }\\n        public void reset() {\\n            reset(1);\\n        }\\n        public void reset(int n) {\\n            rangeVarIndex = n;\\n            rangeVariables.clear();\\n            subqueryDepth = 0;\\n            parameters.clear();\\n            usedSequences.clear();\\n            usedRoutines.clear();\\n            callProcedure = null;\\n            usedObjects.clear();\\n                        currentDomain               = null;\\n            contextuallyTypedExpression = false;\\n        }\\n        public void rewind(int position) {\\n            for (int i = rangeVariables.size() - 1; i >= 0; i--) {\\n                RangeVariable range = (RangeVariable) rangeVariables.get(i);\\n                if (range.parsePosition > position) {\\n                    rangeVariables.remove(i);\\n                }\\n            }\\n            Iterator it = parameters.keySet().iterator();\\n            while (it.hasNext()) {\\n                int pos = it.nextInt();\\n                if (pos >= position) {\\n                    it.remove();\\n                }\\n            }\\n        }\\n        public void registerRangeVariable(RangeVariable range) {\\n            range.parsePosition = parser == null ? 0\\n                                                 : parser.getPosition();\\n            range.rangePosition = getNextRangeVarIndex();\\n            range.level         = subqueryDepth;\\n            rangeVariables.add(range);\\n        }\\n        public int getNextRangeVarIndex() {\\n            return rangeVarIndex++;\\n        }\\n        public int getRangeVarCount() {\\n            return rangeVarIndex;\\n        }\\n        public RangeVariable[] getRangeVariables() {\\n            RangeVariable[] array = new RangeVariable[rangeVariables.size()];\\n            rangeVariables.toArray(array);\\n            return array;\\n        }\\n        public NumberSequence[] getSequences() {\\n            if (usedSequences.size() == 0) {\\n                return NumberSequence.emptyArray;\\n            }\\n            NumberSequence[] array = new NumberSequence[usedSequences.size()];\\n            usedSequences.toArray(array);\\n            return array;\\n        }\\n        public Routine[] getRoutines() {\\n            if (callProcedure == null && usedRoutines.size() == 0) {\\n                return Routine.emptyArray;\\n            }\\n            OrderedHashSet set = new OrderedHashSet();\\n            for (int i = 0; i < usedRoutines.size(); i++) {\\n                FunctionSQLInvoked function =\\n                    (FunctionSQLInvoked) usedRoutines.get(i);\\n                set.add(function.routine);\\n            }\\n            if (callProcedure != null) {\\n                set.add(callProcedure);\\n            }\\n            Routine[] array = new Routine[set.size()];\\n            set.toArray(array);\\n            return array;\\n        }\\n        private void initSubqueryNames() {\\n            if (namedSubqueries == null) {\\n                namedSubqueries = new HsqlArrayList();\\n            }\\n            if (namedSubqueries.size() <= subqueryDepth) {\\n                namedSubqueries.setSize(subqueryDepth + 1);\\n            }\\n            HashMappedList set =\\n                (HashMappedList) namedSubqueries.get(subqueryDepth);\\n            if (set == null) {\\n                set = new HashMappedList();\\n                namedSubqueries.set(subqueryDepth, set);\\n            } else {\\n                set.clear();\\n            }\\n        }\\n        private void registerSubquery(String name, SubQuery subquery) {\\n            HashMappedList set =\\n                (HashMappedList) namedSubqueries.get(subqueryDepth);\\n            boolean added = set.add(name, subquery);\\n            if (!added) {\\n                throw Error.error(ErrorCode.X_42504);\\n            }\\n        }\\n        private SubQuery getNamedSubQuery(String name) {\\n            if (namedSubqueries == null) {\\n                return null;\\n            }\\n            for (int i = subqueryDepth; i >= 0; i--) {\\n                if (namedSubqueries.size() <= i) {\\n                    continue;\\n                }\\n                HashMappedList set = (HashMappedList) namedSubqueries.get(i);\\n                if (set == null) {\\n                    continue;\\n                }\\n                SubQuery sq = (SubQuery) set.get(name);\\n                if (sq != null) {\\n                    return sq;\\n                }\\n            }\\n            return null;\\n        }\\n        private void addParameter(Expression e, int position) {\\n            parameters.put(position, e);\\n        }\\n        private void addSchemaObject(SchemaObject object) {\\n            usedObjects.add(object);\\n        }\\n        private void addSequence(SchemaObject object) {\\n            usedSequences.add(object);\\n        }\\n        void addFunctionCall(FunctionSQLInvoked function) {\\n            usedRoutines.add(function);\\n        }\\n        void addProcedureCall(Routine procedure) {\\n            callProcedure = procedure;\\n        }\\n        ExpressionColumn[] getParameters() {\\n            if (parameters.size() == 0) {\\n                return ExpressionColumn.emptyArray;\\n            }\\n            ExpressionColumn[] result =\\n                new ExpressionColumn[parameters.size()];\\n            parameters.valuesToArray(result);\\n            parameters.clear();\\n            return result;\\n        }\\n        void clearParameters() {\\n            parameters.clear();\\n        }\\n        public OrderedHashSet getSchemaObjectNames() {\\n            OrderedHashSet set = new OrderedHashSet();\\n            for (int i = 0; i < usedSequences.size(); i++) {\\n                SchemaObject object = (SchemaObject) usedSequences.get(i);\\n                set.add(object.getName());\\n            }\\n            for (int i = 0; i < usedObjects.size(); i++) {\\n                SchemaObject object = (SchemaObject) usedObjects.get(i);\\n                set.add(object.getName());\\n            }\\n            for (int i = 0; i < rangeVariables.size(); i++) {\\n                RangeVariable range = (RangeVariable) rangeVariables.get(i);\\n                HsqlName      name  = range.rangeTable.getName();\\n                if (name.schema != SqlInvariants.SYSTEM_SCHEMA_HSQLNAME) {\\n                    set.add(range.rangeTable.getName());\\n                    set.addAll(range.getColumnNames());\\n                } else if (name.type == SchemaObject.TRANSITION) {\\n                    set.addAll(range.getColumnNames());\\n                }\\n            }\\n            Routine[] routines = getRoutines();\\n            for (int i = 0; i < routines.length; i++) {\\n                set.add(routines[i].getSpecificName());\\n            }\\n            return set;\\n        }\\n    }\\n}\""
            },
            "m7": {
                "content": "The code for `ParserDQL.java` reveals that it is primarily responsible for parsing SQL queries related to Data Query Language (DQL), such as `SELECT`, `FROM`, and query expressions involving joins, subqueries, sorting, grouping, and more. It heavily interacts with the database schema, tokens, expressions, and compilation contexts.\n\nGiven its purpose and complexity, we can infer that `ParserDQL.java` likely uses `Tokens.java` for recognizing and processing SQL keywords and symbols during the parsing of DQL statements.\n\nTo confirm this relationship and identify specific dependencies between `Tokens.java` and `ParserDQL.java`, we should retrieve the origin code of `Tokens.java`.\n\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_01ef0971982e48a58964dd",
                        "function": {
                            "arguments": "{\"entity\": \"Tokens.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m8": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package org.hsqldb;\\nimport org.hsqldb.lib.IntKeyHashMap;\\nimport org.hsqldb.lib.IntValueHashMap;\\nimport org.hsqldb.lib.OrderedIntHashSet;\\npublic class Tokens {\\n            static final String        T_ABS              = \\\"ABS\\\";\\n    public static final String T_ALL              = \\\"ALL\\\";\\n    static final String        T_ALLOCATE         = \\\"ALLOCATE\\\";\\n    public static final String T_ALTER            = \\\"ALTER\\\";\\n    static final String        T_AND              = \\\"AND\\\";\\n    public static final String T_ANY              = \\\"ANY\\\";\\n    static final String        T_ARE              = \\\"ARE\\\";\\n    public static final String T_ARRAY            = \\\"ARRAY\\\";\\n    public static final String T_ARRAY_AGG        = \\\"ARRAY_AGG\\\";\\n    public static final String T_AS               = \\\"AS\\\";\\n    static final String        T_ASENSITIVE       = \\\"ASENSITIVE\\\";\\n    static final String        T_ASYMMETRIC       = \\\"ASYMMETRIC\\\";\\n    static final String        T_AT               = \\\"AT\\\";\\n    static final String        T_ATOMIC           = \\\"ATOMIC\\\";\\n    public static final String T_AUTHORIZATION    = \\\"AUTHORIZATION\\\";\\n    static final String        T_AVG              = \\\"AVG\\\";\\n    static final String        T_BEGIN            = \\\"BEGIN\\\";\\n    static final String        T_BETWEEN          = \\\"BETWEEN\\\";\\n    public static final String T_BIGINT           = \\\"BIGINT\\\";\\n    public static final String T_BINARY           = \\\"BINARY\\\";\\n    static final String        T_BIT_LENGTH       = \\\"BIT_LENGTH\\\";\\n    public static final String T_BLOB             = \\\"BLOB\\\";\\n    public static final String T_BOOLEAN          = \\\"BOOLEAN\\\";\\n    static final String        T_BOTH             = \\\"BOTH\\\";\\n    static final String        T_BY               = \\\"BY\\\";\\n    public static final String T_CALL             = \\\"CALL\\\";\\n    static final String        T_CALLED           = \\\"CALLED\\\";\\n    static final String        T_CARDINALITY      = \\\"CARDINALITY\\\";\\n    public static final String T_CASCADED         = \\\"CASCADED\\\";\\n    static final String        T_CASE             = \\\"CASE\\\";\\n    static final String        T_CAST             = \\\"CAST\\\";\\n    static final String        T_CEIL             = \\\"CEIL\\\";\\n    static final String        T_CEILING          = \\\"CEILING\\\";\\n    public static final String T_CHAR             = \\\"CHAR\\\";\\n    static final String        T_CHAR_LENGTH      = \\\"CHAR_LENGTH\\\";\\n    public static final String T_CHARACTER        = \\\"CHARACTER\\\";\\n    static final String        T_CHARACTER_LENGTH = \\\"CHARACTER_LENGTH\\\";\\n    public static final String T_CHECK            = \\\"CHECK\\\";\\n    public static final String T_CLOB             = \\\"CLOB\\\";\\n    static final String        T_CLOSE            = \\\"CLOSE\\\";\\n    static final String        T_COALESCE         = \\\"COALESCE\\\";\\n    public static final String T_COLLATE          = \\\"COLLATE\\\";\\n    static final String        T_COLLECT          = \\\"COLLECT\\\";\\n    static final String        T_COLUMN           = \\\"COLUMN\\\";\\n    public static final String T_COMMIT           = \\\"COMMIT\\\";\\n    static final String        T_CONDITION        = \\\"CONDIITON\\\";\\n    public static final String T_CONNECT          = \\\"CONNECT\\\";\\n    public static final String T_CONSTRAINT       = \\\"CONSTRAINT\\\";\\n    public static final String T_CONVERT          = \\\"CONVERT\\\";\\n    static final String        T_CORR             = \\\"CORR\\\";\\n    static final String        T_CORRESPONDING    = \\\"CORRESPONDING\\\";\\n    static final String        T_COUNT            = \\\"COUNT\\\";\\n    static final String        T_COVAR_POP        = \\\"COVAR_POP\\\";\\n    static final String        T_COVAR_SAMP       = \\\"COVAR_SAMP\\\";\\n    public static final String T_CREATE           = \\\"CREATE\\\";\\n    static final String        T_CROSS            = \\\"CROSS\\\";\\n    static final String        T_CUBE             = \\\"CUBE\\\";\\n    static final String        T_CUME_DIST        = \\\"CUME_DIST\\\";\\n    static final String        T_CURRENT          = \\\"CURRENT\\\";\\n    static final String        T_CURRENT_CATALOG  = \\\"CURRENT_CATALOG\\\";\\n    static final String        T_CURRENT_DATE     = \\\"CURRENT_DATE\\\";\\n    static final String T_CURRENT_DEFAULT_TRANSFORM_GROUP =\\n        \\\"CURRENT_DEFAULT_TRANSFORM_GROUP\\\";\\n    static final String T_CURRENT_PATH      = \\\"CURRENT_PATH\\\";\\n    static final String T_CURRENT_ROLE      = \\\"CURRENT_ROLE\\\";\\n    static final String T_CURRENT_SCHEMA    = \\\"CURRENT_SCHEMA\\\";\\n    static final String T_CURRENT_TIME      = \\\"CURRENT_TIME\\\";\\n    static final String T_CURRENT_TIMESTAMP = \\\"CURRENT_TIMESTAMP\\\";\\n    static final String T_CURRENT_TRANSFORM_GROUP_FOR_TYPE =\\n        \\\"CURRENT_TRANSFORM_GROUP_FOR_TYPE\\\";\\n    static final String        T_CURRENT_USER      = \\\"CURRENT_USER\\\";\\n    static final String        T_CURSOR            = \\\"CURSOR\\\";\\n    static final String        T_CYCLE             = \\\"CYCLE\\\";\\n    public static final String T_DATE              = \\\"DATE\\\";\\n    public static final String T_DAY               = \\\"DAY\\\";\\n    static final String        T_DEALLOCATE        = \\\"DEALLOCATE\\\";\\n    public static final String T_DEC               = \\\"DEC\\\";\\n    public static final String T_DECIMAL           = \\\"DECIMAL\\\";\\n    static final String        T_DECLARE           = \\\"DECLARE\\\";\\n    public static final String T_DEFAULT           = \\\"DEFAULT\\\";\\n    public static final String T_DELETE            = \\\"DELETE\\\";\\n    static final String        T_DENSE_RANK        = \\\"DENSE_RANK\\\";\\n    static final String        T_DEREF             = \\\"DEREF\\\";\\n    static final String        T_DESCRIBE          = \\\"DESCRIBE\\\";\\n    static final String        T_DETERMINISTIC     = \\\"DETERMINISTIC\\\";\\n    static final String        T_DISCONNECT        = \\\"DISCONNECT\\\";\\n    static final String        T_DISTINCT          = \\\"DISTINCT\\\";\\n    public static final String T_DO                = \\\"DO\\\";\\n    public static final String T_DOUBLE            = \\\"DOUBLE\\\";\\n    static final String        T_DROP              = \\\"DROP\\\";\\n    static final String        T_DYNAMIC           = \\\"DYNAMIC\\\";\\n    static final String        T_EACH              = \\\"EACH\\\";\\n    static final String        T_ELEMENT           = \\\"ELEMENT\\\";\\n    static final String        T_ELSE              = \\\"ELSE\\\";\\n    static final String        T_ELSEIF            = \\\"ELSEIF\\\";\\n    static final String        T_END               = \\\"END\\\";\\n    static final String        T_END_EXEC          = \\\"END_EXEC\\\";\\n    static final String        T_ESCAPE            = \\\"ESCAPE\\\";\\n    static final String        T_EVERY             = \\\"EVERY\\\";\\n    static final String        T_EXCEPT            = \\\"EXCEPT\\\";\\n    static final String        T_EXEC              = \\\"EXEC\\\";\\n    public static final String T_EXECUTE           = \\\"EXECUTE\\\";\\n    static final String        T_EXISTS            = \\\"EXISTS\\\";\\n    static final String        T_EXP               = \\\"EXP\\\";\\n    public static final String T_EXTERNAL          = \\\"EXTERNAL\\\";\\n    static final String        T_EXTRACT           = \\\"EXTRACT\\\";\\n    public static final String T_FALSE             = \\\"FALSE\\\";\\n    static final String        T_FETCH             = \\\"FETCH\\\";\\n    static final String        T_FILTER            = \\\"FILTER\\\";\\n    static final String        T_FIRST_VALUE       = \\\"FIRST_VALUE\\\";\\n    public static final String T_FLOAT             = \\\"FLOAT\\\";\\n    static final String        T_FLOOR             = \\\"FLOOR\\\";\\n    public static final String T_FOR               = \\\"FOR\\\";\\n    public static final String T_FOREIGN           = \\\"FOREIGN\\\";\\n    static final String        T_FREE              = \\\"FREE\\\";\\n    public static final String T_FROM              = \\\"FROM\\\";\\n    static final String        T_FULL              = \\\"FULL\\\";\\n    public static final String T_FUNCTION          = \\\"FUNCTION\\\";\\n    static final String        T_FUSION            = \\\"FUSION\\\";\\n    public static final String T_GET               = \\\"GET\\\";\\n    static final String        T_GLOBAL            = \\\"GLOBAL\\\";\\n    public static final String T_GRANT             = \\\"GRANT\\\";\\n    static final String        T_GROUP             = \\\"GROUP\\\";\\n    static final String        T_GROUPING          = \\\"GROUPING\\\";\\n    static final String        T_HANDLER           = \\\"HANDLER\\\";\\n    static final String        T_HAVING            = \\\"HAVING\\\";\\n    static final String        T_HOLD              = \\\"HOLD\\\";\\n    public static final String T_HOUR              = \\\"HOUR\\\";\\n    static final String        T_IDENTITY          = \\\"IDENTITY\\\";\\n    static final String        T_IF                = \\\"IF\\\";\\n    static final String        T_IMPORT            = \\\"IMPORT\\\";\\n    static final String        T_IN                = \\\"IN\\\";\\n    static final String        T_INDICATOR         = \\\"INDICATOR\\\";\\n    static final String        T_INNER             = \\\"INNER\\\";\\n    static final String        T_INOUT             = \\\"INOUT\\\";\\n    static final String        T_INSENSITIVE       = \\\"INSENSITIVE\\\";\\n    public static final String T_INSERT            = \\\"INSERT\\\";\\n    public static final String T_INT               = \\\"INT\\\";\\n    public static final String T_INTEGER           = \\\"INTEGER\\\";\\n    static final String        T_INTERSECT         = \\\"INTERSECT\\\";\\n    static final String        T_INTERSECTION      = \\\"INTERSECTION\\\";\\n    public static final String T_INTERVAL          = \\\"INTERVAL\\\";\\n    static final String        T_INTO              = \\\"INTO\\\";\\n    static final String        T_ITERATE           = \\\"ITERATE\\\";\\n    public static final String T_IS                = \\\"IS\\\";\\n    static final String        T_JAR               = \\\"JAR\\\";                  static final String        T_JOIN              = \\\"JOIN\\\";\\n    static final String        T_LAG               = \\\"LAG\\\";\\n    public static final String T_LANGUAGE          = \\\"LANGUAGE\\\";\\n    static final String        T_LARGE             = \\\"LARGE\\\";\\n    static final String        T_LAST_VALUE        = \\\"LAST_VALUE\\\";\\n    static final String        T_LATERAL           = \\\"LATERAL\\\";\\n    static final String        T_LEAD              = \\\"LEAD\\\";\\n    static final String        T_LEADING           = \\\"LEADING\\\";\\n    static final String        T_LEAVE             = \\\"LEAVE\\\";\\n    static final String        T_LEFT              = \\\"LEFT\\\";\\n    static final String        T_LIKE              = \\\"LIKE\\\";\\n    static final String        T_LIKE_REGX         = \\\"LIKE_REGX\\\";\\n    static final String        T_LN                = \\\"LN\\\";\\n    public static final String T_LOCAL             = \\\"LOCAL\\\";\\n    static final String        T_LOCALTIME         = \\\"LOCALTIME\\\";\\n    static final String        T_LOCALTIMESTAMP    = \\\"LOCALTIMESTAMP\\\";\\n    public static final String T_LOOP              = \\\"LOOP\\\";\\n    static final String        T_LOWER             = \\\"LOWER\\\";\\n    static final String        T_MATCH             = \\\"MATCH\\\";\\n    static final String        T_MAX               = \\\"MAX\\\";\\n    static final String        T_MAX_CARDINALITY   = \\\"MAX_CARDINALITY\\\";\\n    static final String        T_MEMBER            = \\\"MEMBER\\\";\\n    static final String        T_MERGE             = \\\"MERGE\\\";\\n    static final String        T_METHOD            = \\\"METHOD\\\";\\n    static final String        T_MIN               = \\\"MIN\\\";\\n    public static final String T_MINUTE            = \\\"MINUTE\\\";\\n    static final String        T_MOD               = \\\"MOD\\\";\\n    static final String        T_MODIFIES          = \\\"MODIFIES\\\";\\n    static final String        T_MODULE            = \\\"MODULE\\\";\\n    public static final String T_MONTH             = \\\"MONTH\\\";\\n    public static final String T_MULTISET          = \\\"MULTISET\\\";\\n    static final String        T_NATIONAL          = \\\"NATIONAL\\\";\\n    static final String        T_NATURAL           = \\\"NATURAL\\\";\\n    static final String        T_NCHAR             = \\\"NCHAR\\\";\\n    static final String        T_NCLOB             = \\\"NCLOB\\\";\\n    static final String        T_NEW               = \\\"NEW\\\";\\n    public static final String T_NO                = \\\"NO\\\";\\n    public static final String T_NONE              = \\\"NONE\\\";\\n    static final String        T_NORMALIZE         = \\\"NORMALIZE\\\";\\n    static final String        T_NOT               = \\\"NOT\\\";\\n    static final String        T_NTH_VALUE         = \\\"NTH_VALUE\\\";\\n    static final String        T_NTILE             = \\\"NTILE\\\";\\n    public static final String T_NULL              = \\\"NULL\\\";\\n    public static final String T_NULLIF            = \\\"NULLIF\\\";\\n    public static final String T_NUMERIC           = \\\"NUMERIC\\\";\\n    static final String        T_OCCURRENCES_REGEX = \\\"OCCURRENCES_REGEX\\\";\\n    static final String        T_OCTET_LENGTH      = \\\"OCTET_LENGTH\\\";\\n    static final String        T_OF                = \\\"OF\\\";\\n    static final String        T_OFFSET            = \\\"OFFSET\\\";\\n    static final String        T_OLD               = \\\"OLD\\\";\\n    public static final String T_ON                = \\\"ON\\\";\\n    public static final String T_ONLY              = \\\"ONLY\\\";\\n    static final String        T_OPEN              = \\\"OPEN\\\";\\n    static final String        T_OR                = \\\"OR\\\";\\n    static final String        T_ORDER             = \\\"ORDER\\\";\\n    static final String        T_OUT               = \\\"OUT\\\";\\n    static final String        T_OUTER             = \\\"OUTER\\\";\\n    static final String        T_OVER              = \\\"OVER\\\";\\n    static final String        T_OVERLAPS          = \\\"OVERLAPS\\\";\\n    static final String        T_OVERLAY           = \\\"OVERLAY\\\";\\n    static final String        T_PARAMETER         = \\\"PARAMETER\\\";\\n    static final String        T_PARTITION         = \\\"PARTITION\\\";\\n    static final String        T_PERCENT_RANK      = \\\"PERCENT_RANK\\\";\\n    static final String        T_PERCENTILE_CONT   = \\\"PERCENTILE_CONT\\\";\\n    static final String        T_PERCENTILE_DISC   = \\\"PERCENTILE_DISC\\\";\\n    static final String        T_POSITION          = \\\"POSITION\\\";\\n    static final String        T_POSITION_REGEX    = \\\"POSITION_REGEX\\\";\\n    static final String        T_POWER             = \\\"POWER\\\";\\n    static final String        T_PRECISION         = \\\"PRECISION\\\";\\n    static final String        T_PREPARE           = \\\"PREPARE\\\";\\n    static final String        T_PRIMARY           = \\\"PRIMARY\\\";\\n    public static final String T_PROCEDURE         = \\\"PROCEDURE\\\";\\n    static final String        T_RANGE             = \\\"RANGE\\\";\\n    static final String        T_RANK              = \\\"RANK\\\";\\n    static final String        T_READS             = \\\"READS\\\";\\n    public static final String T_REAL              = \\\"REAL\\\";\\n    static final String        T_RECURSIVE         = \\\"RECURSIVE\\\";\\n    static final String        T_REF               = \\\"REF\\\";\\n    public static final String T_REFERENCES        = \\\"REFERENCES\\\";\\n    static final String        T_REFERENCING       = \\\"REFERENCING\\\";\\n    static final String        T_REGR_AVGX         = \\\"REGR_AVGX\\\";\\n    static final String        T_REGR_AVGY         = \\\"REGR_AVGY\\\";\\n    static final String        T_REGR_COUNT        = \\\"REGR_COUNT\\\";\\n    static final String        T_REGR_INTERCEPT    = \\\"REGR_INTERCEPT\\\";\\n    static final String        T_REGR_R2           = \\\"REGR_R2\\\";\\n    static final String        T_REGR_SLOPE        = \\\"REGR_SLOPE\\\";\\n    static final String        T_REGR_SXX          = \\\"REGR_SXX\\\";\\n    static final String        T_REGR_SXY          = \\\"REGR_SXY\\\";\\n    static final String        T_REGR_SYY          = \\\"REGR_SYY\\\";\\n    static final String        T_RELEASE           = \\\"RELEASE\\\";\\n    static final String        T_REPEAT            = \\\"REPEAT\\\";\\n    static final String        T_RESIGNAL          = \\\"RESIGNAL\\\";\\n    public static final String T_RESULT            = \\\"RESULT\\\";\\n    static final String        T_RETURN            = \\\"RETURN\\\";\\n    static final String        T_RETURNS           = \\\"RETURNS\\\";\\n    static final String        T_REVOKE            = \\\"REVOKE\\\";\\n    static final String        T_RIGHT             = \\\"RIGHT\\\";\\n    public static final String T_ROLLBACK          = \\\"ROLLBACK\\\";\\n    static final String        T_ROLLUP            = \\\"ROLLUP\\\";\\n    public static final String T_ROW               = \\\"ROW\\\";\\n    static final String        T_ROW_NUMBER        = \\\"ROW_NUMBER\\\";\\n    public static final String T_ROWS              = \\\"ROWS\\\";\\n    static final String        T_SAVEPOINT         = \\\"SAVEPOINT\\\";\\n    static final String        T_SCOPE             = \\\"SCOPE\\\";\\n    static final String        T_SCROLL            = \\\"SCROLL\\\";\\n    static final String        T_SEARCH            = \\\"SEARCH\\\";\\n    public static final String T_SECOND            = \\\"SECOND\\\";\\n    public static final String T_SELECT            = \\\"SELECT\\\";\\n    static final String        T_SENSITIVE         = \\\"SENSITIVE\\\";\\n    static final String        T_SESSION_USER      = \\\"SESSION_USER\\\";\\n    public static final String T_SET               = \\\"SET\\\";\\n    static final String        T_SIGNAL            = \\\"SIGNAL\\\";\\n    static final String        T_SIMILAR           = \\\"SIMILAR\\\";\\n    public static final String T_SMALLINT          = \\\"SMALLINT\\\";\\n    static final String        T_SOME              = \\\"SOME\\\";\\n    public static final String T_SPECIFIC          = \\\"SPECIFIC\\\";\\n    static final String        T_SPECIFICTYPE      = \\\"SPECIFICTYPE\\\";\\n    public static final String T_SQL               = \\\"SQL\\\";\\n    static final String        T_SQLEXCEPTION      = \\\"SQLEXCEPTION\\\";\\n    static final String        T_SQLSTATE          = \\\"SQLSTATE\\\";\\n    static final String        T_SQLWARNING        = \\\"SQLWARNING\\\";\\n    static final String        T_SQRT              = \\\"SQRT\\\";\\n    static final String        T_START             = \\\"START\\\";\\n    static final String        T_STATIC            = \\\"STATIC\\\";\\n    static final String        T_STDDEV_POP        = \\\"STDDEV_POP\\\";\\n    static final String        T_STDDEV_SAMP       = \\\"STDDEV_SAMP\\\";\\n    static final String        T_SUBMULTISET       = \\\"SUBMULTISET\\\";\\n    static final String        T_SUBSTRING         = \\\"SUBSTRING\\\";\\n    static final String        T_SUBSTRING_REGEX   = \\\"SUBSTRING_REGEX\\\";\\n    static final String        T_SUM               = \\\"SUM\\\";\\n    static final String        T_SYMMETRIC         = \\\"SYMMETRIC\\\";\\n    static final String        T_SYSTEM            = \\\"SYSTEM\\\";\\n    static final String        T_SYSTEM_USER       = \\\"SYSTEM_USER\\\";\\n    public static final String T_TABLE             = \\\"TABLE\\\";\\n    static final String        T_TABLESAMPLE       = \\\"TABLESAMPLE\\\";\\n    static final String        T_THEN              = \\\"THEN\\\";\\n    public static final String T_TIME              = \\\"TIME\\\";\\n    public static final String T_TIMESTAMP         = \\\"TIMESTAMP\\\";\\n    public static final String T_TIMEZONE_HOUR     = \\\"TIMEZONE_HOUR\\\";\\n    public static final String T_TIMEZONE_MINUTE   = \\\"TIMEZONE_MINUTE\\\";\\n    public static final String T_TO                = \\\"TO\\\";\\n    static final String        T_TRAILING          = \\\"TRAILING\\\";\\n    public static final String T_TRANSLATE         = \\\"TRANSLATE\\\";\\n    static final String        T_TRANSLATE_REGEX   = \\\"TRANSLATE_REGEX\\\";\\n    static final String        T_TRANSLATION       = \\\"TRANSLATION\\\";\\n    static final String        T_TREAT             = \\\"TREAT\\\";\\n    public static final String T_TRIGGER           = \\\"TRIGGER\\\";\\n    static final String        T_TRIM              = \\\"TRIM\\\";\\n    static final String        T_TRIM_ARRAY        = \\\"TRIM_ARRAY\\\";\\n    public static final String T_TRUE              = \\\"TRUE\\\";\\n    public static final String T_TRUNCATE          = \\\"TRUNCATE\\\";\\n    static final String        T_UESCAPE           = \\\"UESCAPE\\\";\\n    static final String        T_UNION             = \\\"UNION\\\";\\n    public static final String T_UNIQUE            = \\\"UNIQUE\\\";\\n    public static final String T_UNKNOWN           = \\\"UNKNOWN\\\";\\n    static final String        T_UNNEST            = \\\"UNNEST\\\";\\n    static final String        T_UNTIL             = \\\"UNTIL\\\";\\n    public static final String T_UPDATE            = \\\"UPDATE\\\";\\n    static final String        T_UPPER             = \\\"UPPER\\\";\\n    public static final String T_USER              = \\\"USER\\\";\\n    static final String        T_USING             = \\\"USING\\\";\\n    static final String        T_VALUE             = \\\"VALUE\\\";\\n    static final String        T_VALUES            = \\\"VALUES\\\";\\n    static final String        T_VAR_POP           = \\\"VAR_POP\\\";\\n    static final String        T_VAR_SAMP          = \\\"VAR_SAMP\\\";\\n    public static final String T_VARBINARY         = \\\"VARBINARY\\\";\\n    public static final String T_VARCHAR           = \\\"VARCHAR\\\";\\n    static final String        T_VARYING           = \\\"VARYING\\\";\\n    static final String        T_WHEN              = \\\"WHEN\\\";\\n    static final String        T_WHENEVER          = \\\"WHENEVER\\\";\\n    static final String        T_WHERE             = \\\"WHERE\\\";\\n    public static final String T_WHILE             = \\\"WHILE\\\";\\n    static final String        T_WIDTH_BUCKET      = \\\"WIDTH_BUCKET\\\";\\n    static final String        T_WINDOW            = \\\"WINDOW\\\";\\n    public static final String T_WITH              = \\\"WITH\\\";\\n    static final String        T_WITHIN            = \\\"WITHIN\\\";\\n    static final String        T_WITHOUT           = \\\"WITHOUT\\\";\\n    public static final String T_YEAR              = \\\"YEAR\\\";\\n        static final String        T_ASTERISK       = \\\"*\\\";\\n    public static final String T_COMMA          = \\\",\\\";\\n    static final String        T_CIRCUMFLEX     = \\\"^\\\";\\n    static final String        T_CLOSEBRACKET   = \\\")\\\";\\n    static final String        T_COLON          = \\\":\\\";\\n    static final String        T_CONCAT         = \\\"||\\\";\\n    public static final String T_DIVIDE         = \\\"/\\\";\\n    static final String        T_EQUALS         = \\\"=\\\";\\n    static final String        T_GREATER        = \\\">\\\";\\n    static final String        T_GREATER_EQUALS = \\\">=\\\";\\n    public static final String T_LEFTBRACKET    = \\\"[\\\";\\n    static final String        T_LESS           = \\\"<\\\";\\n    static final String        T_LESS_EQUALS    = \\\"<=\\\";\\n    static final String        T_PERCENT        = \\\"%\\\";\\n    static final String        T_PLUS           = \\\"+\\\";\\n    static final String        T_MINUS          = \\\"-\\\";\\n    static final String        T_NOT_EQUALS     = \\\"<>\\\";\\n    static final String        T_NOT_EQUALS_ALT = \\\"!=\\\";\\n    static final String        T_OPENBRACKET    = \\\"(\\\";\\n    static final String        T_QUESTION       = \\\"?\\\";\\n    public static final String T_RIGHTBRACKET   = \\\"]\\\";\\n    static final String        T_SEMICOLON      = \\\";\\\";\\n    static final String        T_DOUBLE_COLON   = \\\"::\\\";\\n        static final String        T_A                    = \\\"A\\\";\\n    static final String        T_ABSOLUTE             = \\\"ABSOLUTE\\\";\\n    static final String        T_ACTION               = \\\"ACTION\\\";\\n    static final String        T_ADA                  = \\\"ADA\\\";\\n    static final String        T_ADD                  = \\\"ADD\\\";\\n    static final String        T_ADMIN                = \\\"ADMIN\\\";\\n    static final String        T_AFTER                = \\\"AFTER\\\";\\n    static final String        T_ALWAYS               = \\\"ALWAYS\\\";\\n    static final String        T_ASC                  = \\\"ASC\\\";\\n    static final String        T_ASSERTION            = \\\"ASSERTION\\\";\\n    static final String        T_ASSIGNMENT           = \\\"ASSIGNMENT\\\";\\n    static final String        T_ATTRIBUTE            = \\\"ATTRIBUTE\\\";\\n    static final String        T_ATTRIBUTES           = \\\"ATTRIBUTES\\\";\\n    static final String        T_BEFORE               = \\\"BEFORE\\\";\\n    static final String        T_BERNOULLI            = \\\"BERNOULLI\\\";\\n    public static final String T_BIT                  = \\\"BIT\\\";\\n    static final String        T_BITLENGTH            = \\\"BITLENGTH\\\";\\n    static final String        T_BREADTH              = \\\"BREADTH\\\";\\n    static final String        T_C                    = \\\"C\\\";\\n    static final String        T_CASCADE              = \\\"CASCADE\\\";\\n    public static final String T_CATALOG              = \\\"CATALOG\\\";\\n    public static final String T_CATALOG_NAME         = \\\"CATALOG_NAME\\\";\\n    static final String        T_CHAIN                = \\\"CHAIN\\\";\\n    static final String T_CHARACTER_SET_CATALOG = \\\"CHARACTER_SET_CATALOG\\\";\\n    static final String        T_CHARACTER_SET_NAME   = \\\"CHARACTER_SET_NAME\\\";\\n    static final String        T_CHARACTER_SET_SCHEMA = \\\"CHARACTER_SET_SCHEMA\\\";\\n    static final String        T_CHARACTERISTICS      = \\\"CHARACTERISTICS\\\";\\n    static final String        T_CHARACTERS           = \\\"CHARACTERS\\\";\\n    static final String        T_CLASS_ORIGIN         = \\\"CLASS_ORIGIN\\\";\\n    static final String        T_COBOL                = \\\"COBOL\\\";\\n    public static final String T_COLLATION            = \\\"COLLATION\\\";\\n    static final String        T_COLLATION_CATALOG    = \\\"COLLATION_CATALOG\\\";\\n    static final String        T_COLLATION_NAME       = \\\"COLLATION_NAME\\\";\\n    static final String        T_COLLATION_SCHEMA     = \\\"COLLATION_SCHEMA\\\";\\n    static final String        T_COLUMN_NAME          = \\\"COLUMN_NAME\\\";\\n    static final String        T_COMMAND_FUNCTION     = \\\"COMMAND_FUNCTION\\\";\\n    static final String T_COMMAND_FUNCTION_CODE = \\\"COMMAND_FUNCTION_CODE\\\";\\n    public static final String T_COMMITTED            = \\\"COMMITTED\\\";\\n    static final String        T_COMPARABLE           = \\\"COMPARABLE\\\";        static final String        T_CONDITION_IDENTIFIER = \\\"CONDIITON_IDENTIFIER\\\";\\n    static final String        T_CONDITION_NUMBER     = \\\"CONDITION_NUMBER\\\";\\n    static final String        T_CONNECTION_NAME      = \\\"CONNECTION_NAME\\\";\\n    static final String        T_CONSTRAINT_CATALOG   = \\\"CONSTRAINT_CATALOG\\\";\\n    static final String        T_CONSTRAINT_NAME      = \\\"CONSTRAINT_NAME\\\";\\n    static final String        T_CONSTRAINT_SCHEMA    = \\\"CONSTRAINT_SCHEMA\\\";\\n    static final String        T_CONSTRAINTS          = \\\"CONSTRAINTS\\\";\\n    static final String        T_CONSTRUCTOR          = \\\"CONSTRUCTOR\\\";\\n    static final String        T_CONTAINS             = \\\"CONTAINS\\\";\\n    static final String        T_CONTINUE             = \\\"CONTINUE\\\";\\n    static final String        T_CURRENT_COLLATION    = \\\"CURRENT_COLLATION\\\";\\n    static final String        T_CURSOR_NAME          = \\\"CURSOR_NAME\\\";\\n    public static final String T_DATA                 = \\\"DATA\\\";\\n    static final String T_DATETIME_INTERVAL_CODE = \\\"DATETIME_INTERVAL_CODE\\\";\\n    static final String T_DATETIME_INTERVAL_PRECISION =\\n        \\\"DATETIME_INTERVAL_PRECISION\\\";\\n    public static final String T_DEFAULTS             = \\\"DEFAULTS\\\";\\n    static final String        T_DEFERRABLE           = \\\"DEFERRABLE\\\";\\n    static final String        T_DEFERRED             = \\\"DEFERRED\\\";\\n    static final String        T_DEFINED              = \\\"DEFINED\\\";\\n    static final String        T_DEFINER              = \\\"DEFINER\\\";\\n    static final String        T_DEGREE               = \\\"DEGREE\\\";\\n    static final String        T_DEPTH                = \\\"DEPTH\\\";\\n    static final String        T_DERIVED              = \\\"DERIVED\\\";\\n    static final String        T_DESC                 = \\\"DESC\\\";\\n    static final String        T_DESCRIPTOR           = \\\"DESCRIPTOR\\\";\\n    static final String        T_DIAGNOSTICS          = \\\"DIAGNOSTICS\\\";\\n    static final String        T_DISPATCH             = \\\"DISPATCH\\\";\\n    public static final String T_DOMAIN               = \\\"DOMAIN\\\";\\n    static final String        T_DYNAMIC_FUNCTION     = \\\"DYNAMIC_FUNCTION\\\";\\n    static final String T_DYNAMIC_FUNCTION_CODE = \\\"DYNAMIC_FUNCTION_CODE\\\";\\n    static final String        T_EXCEPTION            = \\\"EXCEPTION\\\";\\n    static final String        T_EXCLUDE              = \\\"EXCLUDE\\\";\\n    static final String        T_EXCLUDING            = \\\"EXCLUDING\\\";\\n    static final String        T_EXIT                 = \\\"EXIT\\\";\\n    static final String        T_FINAL                = \\\"FINAL\\\";\\n    static final String        T_FIRST                = \\\"FIRST\\\";\\n    static final String        T_FOLLOWING            = \\\"FOLLOWING\\\";\\n    static final String        T_FORTRAN              = \\\"FORTRAN\\\";\\n    static final String        T_FOUND                = \\\"FOUND\\\";\\n    public static final String T_G_FACTOR             = \\\"G\\\";\\n    static final String        T_GENERATED            = \\\"GENERATED\\\";\\n    static final String        T_GENERAL              = \\\"GENERAL\\\";\\n    static final String        T_GO                   = \\\"GO\\\";\\n    static final String        T_GOTO                 = \\\"GOTO\\\";\\n    static final String        T_GRANTED              = \\\"GRANTED\\\";\\n    static final String        T_HIERARCHY            = \\\"HIERARCHY\\\";\\n    static final String        T_IMPLEMENTATION       = \\\"IMPLEMENTATION\\\";\\n    static final String        T_INCLUDING            = \\\"INCLUDING\\\";\\n    public static final String T_INCREMENT            = \\\"INCREMENT\\\";\\n    static final String        T_INITIALLY            = \\\"INITIALLY\\\";\\n    static final String        T_INPUT                = \\\"INPUT\\\";\\n    static final String        T_INSTANCE             = \\\"INSTANCE\\\";\\n    static final String        T_INSTANTIABLE         = \\\"INSTANTIABLE\\\";\\n    static final String        T_INSTEAD              = \\\"INSTEAD\\\";\\n    static final String        T_INTERFACE            = \\\"INTERFACE\\\";         static final String        T_INVOKER              = \\\"INVOKER\\\";\\n    public static final String T_ISOLATION            = \\\"ISOLATION\\\";\\n    public static final String T_JAVA                 = \\\"JAVA\\\";              public static final String T_K_FACTOR             = \\\"K\\\";\\n    static final String        T_KEY                  = \\\"KEY\\\";\\n    static final String        T_KEY_MEMBER           = \\\"KEY_MEMBER\\\";\\n    static final String        T_KEY_TYPE             = \\\"KEY_TYPE\\\";\\n    static final String        T_LAST                 = \\\"LAST\\\";\\n    static final String        T_LENGTH               = \\\"LENGTH\\\";\\n    public static final String T_LEVEL                = \\\"LEVEL\\\";\\n    public static final String T_LIBRARY              = \\\"LIBRARY\\\";\\n    static final String        T_LOCATOR              = \\\"LOCATOR\\\";\\n    public static final String T_M_FACTOR             = \\\"M\\\";\\n    static final String        T_MAP                  = \\\"MAP\\\";\\n    static final String        T_MATCHED              = \\\"MATCHED\\\";\\n    static final String        T_MAXVALUE             = \\\"MAXVALUE\\\";\\n    static final String        T_MESSAGE_LENGTH       = \\\"MESSAGE_LENGTH\\\";\\n    static final String        T_MESSAGE_OCTET_LENGTH = \\\"MESSAGE_OCTET_LENGTH\\\";\\n    static final String        T_MESSAGE_TEXT         = \\\"MESSAGE_TEXT\\\";\\n    static final String        T_MINVALUE             = \\\"MINVALUE\\\";\\n    static final String        T_MORE                 = \\\"MORE\\\";\\n    static final String        T_MUMPS                = \\\"MUMPS\\\";\\n    public static final String T_NAME                 = \\\"NAME\\\";\\n    public static final String T_NAMES                = \\\"NAMES\\\";\\n    static final String        T_NESTING              = \\\"NESTING\\\";\\n    static final String        T_NEXT                 = \\\"NEXT\\\";\\n    static final String        T_NORMALIZED           = \\\"NORMALIZED\\\";\\n    static final String        T_NULLABLE             = \\\"NULLABLE\\\";\\n    public static final String T_NULLS                = \\\"NULLS\\\";\\n    static final String        T_NUMBER               = \\\"NUMBER\\\";\\n    public static final String T_OBJECT               = \\\"OBJECT\\\";\\n    static final String        T_OCTETS               = \\\"OCTETS\\\";\\n    static final String        T_OPTION               = \\\"OPTION\\\";\\n    static final String        T_OPTIONS              = \\\"OPTIONS\\\";\\n    static final String        T_ORDERING             = \\\"ORDERING\\\";\\n    static final String        T_ORDINALITY           = \\\"ORDINALITY\\\";\\n    static final String        T_OTHERS               = \\\"OTHERS\\\";\\n    public static final String T_OVERRIDING           = \\\"OVERRIDING\\\";\\n    public static final String T_P_FACTOR             = \\\"P\\\";\\n    static final String        T_PAD                  = \\\"PAD\\\";\\n    static final String        T_PARAMETER_MODE       = \\\"PARAMETER_MODE\\\";\\n    static final String        T_PARAMETER_NAME       = \\\"PARAMETER_NAME\\\";\\n    static final String T_PARAMETER_ORDINAL_POSITION =\\n        \\\"PARAMETER_ORDINAL_POSITION\\\";\\n    static final String T_PARAMETER_SPECIFIC_CATALOG =\\n        \\\"PARAMETER_SPECIFIC_CATALOG\\\";\\n    static final String T_PARAMETER_SPEC_NAME = \\\"PARAMETER_SPECIFIC_NAME\\\";\\n    static final String T_PARAMETER_SPEC_SCHEMA = \\\"PARAMETER_SPECIFIC_SCHEMA\\\";\\n    static final String        T_PARTIAL              = \\\"PARTIAL\\\";\\n    static final String        T_PASCAL               = \\\"PASCAL\\\";\\n    public static final String T_PATH                 = \\\"PATH\\\";\\n    static final String        T_PLACING              = \\\"PLACING\\\";\\n    static final String        T_PLI                  = \\\"PLI\\\";\\n    static final String        T_PRECEDING            = \\\"PRECEDING\\\";\\n    static final String        T_PRESERVE             = \\\"PRESERVE\\\";\\n    static final String        T_PRIOR                = \\\"PRIOR\\\";\\n    static final String        T_PRIVILEGES           = \\\"PRIVILEGES\\\";\\n    public static final String T_PUBLIC               = \\\"PUBLIC\\\";\\n    public static final String T_READ                 = \\\"READ\\\";\\n    static final String        T_RELATIVE             = \\\"RELATIVE\\\";\\n    static final String        T_REPEATABLE           = \\\"REPEATABLE\\\";\\n    static final String        T_RESTART              = \\\"RESTART\\\";\\n    static final String        T_RESET                = \\\"RESET\\\";\\n    static final String        T_RETURNED_CARDINALITY = \\\"RETURNED_CARDINALITY\\\";\\n    static final String        T_RETURNED_LENGTH      = \\\"RETURNED_LENGTH\\\";\\n    static final String T_RETURNED_OCTET_LENGTH = \\\"RETURNED_OCTET_LENGTH\\\";\\n    static final String        T_RETURNED_SQLSTATE    = \\\"RETURNED_SQLSTATE\\\";\\n    public static final String T_ROLE                 = \\\"ROLE\\\";\\n    public static final String T_ROUTINE              = \\\"ROUTINE\\\";\\n    static final String        T_ROUTINE_CATALOG      = \\\"ROUTINE_CATALOG\\\";\\n    static final String        T_ROUTINE_NAME         = \\\"ROUTINE_NAME\\\";\\n    static final String        T_ROUTINE_SCHEMA       = \\\"ROUTINE_SCHEMA\\\";\\n    static final String        T_ROW_COUNT            = \\\"ROW_COUNT\\\";\\n    public static final String T_SCALE                = \\\"SCALE\\\";\\n    public static final String T_SCHEMA               = \\\"SCHEMA\\\";\\n    static final String        T_SCHEMA_NAME          = \\\"SCHEMA_NAME\\\";\\n    static final String        T_SCOPE_CATALOG        = \\\"SCOPE_CATALOG\\\";\\n    static final String        T_SCOPE_NAME           = \\\"SCOPE_NAME\\\";\\n    static final String        T_SCOPE_SCHEMA         = \\\"SCOPE_SCHEMA\\\";\\n    static final String        T_SECTION              = \\\"SECTION\\\";\\n    static final String        T_SECURITY             = \\\"SECURITY\\\";\\n    static final String        T_SELF                 = \\\"SELF\\\";\\n    public static final String T_SEQUENCE             = \\\"SEQUENCE\\\";\\n    static final String        T_SERIAL               = \\\"SERIAL\\\";\\n    public static final String T_SERIALIZABLE         = \\\"SERIALIZABLE\\\";\\n    public static final String T_SERVER               = \\\"SERVER\\\";\\n    static final String        T_SERVER_NAME          = \\\"SERVER_NAME\\\";\\n    public static final String T_SESSION              = \\\"SESSION\\\";\\n    static final String        T_SETS                 = \\\"SETS\\\";\\n    static final String        T_SIMPLE               = \\\"SIMPLE\\\";\\n    public static final String T_SIZE                 = \\\"SIZE\\\";\\n    static final String        T_SOURCE               = \\\"SOURCE\\\";\\n    static final String        T_SPACE                = \\\"SPACE\\\";\\n    static final String        T_SPECIFIC_NAME        = \\\"SPECIFIC_NAME\\\";\\n    static final String        T_SQLDATA              = \\\"SQLDATA\\\";           static final String        T_STACKED              = \\\"STACKED\\\";\\n    static final String        T_STATE                = \\\"STATE\\\";\\n    static final String        T_STATEMENT            = \\\"STATEMENT\\\";\\n    static final String        T_STRUCTURE            = \\\"STRUCTURE\\\";\\n    static final String        T_STYLE                = \\\"STYLE\\\";\\n    static final String        T_SUBCLASS_ORIGIN      = \\\"SUBCLASS_ORIGIN\\\";\\n    public static final String T_T_FACTOR             = \\\"T\\\";\\n    static final String        T_TABLE_NAME           = \\\"TABLE_NAME\\\";\\n    static final String        T_TEMPORARY            = \\\"TEMPORARY\\\";\\n    static final String        T_TIES                 = \\\"TIES\\\";\\n    static final String        T_TOP_LEVEL_COUNT      = \\\"TOP_LEVEL_COUNT\\\";\\n    public static final String T_TRANSACTION          = \\\"TRANSACTION\\\";\\n    static final String        T_TRANSACT_COMMITTED = \\\"TRANSACTIONS_COMMITTED\\\";\\n    static final String T_TRANSACTION_ROLLED_BACK = \\\"TRANSACTIONS_ROLLED_BACK\\\";\\n    static final String        T_TRANSACT_ACTIVE      = \\\"TRANSACTION_ACTIVE\\\";\\n    static final String        T_TRANSFORM            = \\\"TRANSFORM\\\";\\n    static final String        T_TRANSFORMS           = \\\"TRANSFORMS\\\";\\n    static final String        T_TRIGGER_CATALOG      = \\\"TRIGGER_CATALOG\\\";\\n    static final String        T_TRIGGER_NAME         = \\\"TRIGGER_NAME\\\";\\n    static final String        T_TRIGGER_SCHEMA       = \\\"TRIGGER_SCHEMA\\\";\\n    public static final String T_TYPE                 = \\\"TYPE\\\";\\n    static final String        T_UNBOUNDED            = \\\"UNBOUNDED\\\";\\n    static final String        T_UNCOMMITTED          = \\\"UNCOMMITTED\\\";\\n    static final String        T_UNDER                = \\\"UNDER\\\";\\n    static final String        T_UNDO                 = \\\"UNDO\\\";\\n    static final String        T_UNNAMED              = \\\"UNNAMED\\\";\\n    public static final String T_USAGE                = \\\"USAGE\\\";\\n    static final String T_USER_DEFINED_TYPE_CATALOG =\\n        \\\"USER_DEFINED_TYPE_CATALOG\\\";\\n    static final String T_USER_DEFINED_TYPE_CODE = \\\"USER_DEFINED_TYPE_CODE\\\";\\n    static final String T_USER_DEFINED_TYPE_NAME = \\\"USER_DEFINED_TYPE_NAME\\\";\\n    static final String T_USER_DEFINED_TYPE_SCHEMA =\\n        \\\"USER_DEFINED_TYPE_SCHEMA\\\";\\n    static final String        T_VIEW    = \\\"VIEW\\\";\\n    static final String        T_WORK    = \\\"WORK\\\";\\n    public static final String T_WRAPPER = \\\"WRAPPER\\\";\\n    public static final String T_WRITE   = \\\"WRITE\\\";\\n    public static final String T_ZONE    = \\\"ZONE\\\";\\n        static final String        T_ALIAS                = \\\"ALIAS\\\";\\n    static final String        T_AGGREGATE            = \\\"AGGREGATE\\\";\\n    public static final String T_AUTHENTICATION       = \\\"AUTHENTICATION\\\";\\n    static final String        T_AUTO_INCREMENT       = \\\"AUTO_INCREMENT\\\";\\n    static final String        T_AUTOCOMMIT           = \\\"AUTOCOMMIT\\\";\\n    public static final String T_BACKUP               = \\\"BACKUP\\\";\\n    static final String        T_BINARY_DOUBLE        = \\\"BINARY_DOUBLE\\\";\\n    static final String        T_BINARY_FLOAT         = \\\"BINARY_FLOAT\\\";\\n    static final String        T_BODY                 = \\\"BODY\\\";\\n    static final String        T_BYTE                 = \\\"BYTE\\\";\\n    public static final String T_CACHE                = \\\"CACHE\\\";\\n    static final String        T_CACHED               = \\\"CACHED\\\";\\n    static final String        T_CASEWHEN             = \\\"CASEWHEN\\\";\\n    static final String        T_CHECKPOINT           = \\\"CHECKPOINT\\\";\\n    static final String        T_CLASS                = \\\"CLASS\\\";\\n    static final String        T_CLUSTERED            = \\\"CLUSTERED\\\";\\n    static final String        T_COMMENT              = \\\"COMMENT\\\";\\n    static final String        T_COMPACT              = \\\"COMPACT\\\";\\n    public static final String T_COMPRESSED           = \\\"COMPRESSED\\\";\\n    public static final String T_CONTROL              = \\\"CONTROL\\\";\\n    static final String        T_CURDATE              = \\\"CURDATE\\\";\\n    static final String        T_CURRVAL              = \\\"CURRVAL\\\";\\n    static final String        T_CURTIME              = \\\"CURTIME\\\";\\n    public static final String T_DATABASE             = \\\"DATABASE\\\";\\n    public static final String T_DATETIME             = \\\"DATETIME\\\";\\n    public static final String T_DEADLOCK             = \\\"DEADLOCK\\\";\\n    public static final String T_DEFRAG               = \\\"DEFRAG\\\";\\n    public static final String T_DELAY                = \\\"DELAY\\\";\\n    public static final String T_DIGEST               = \\\"DIGEST\\\";\\n    static final String        T_DUAL                 = \\\"DUAL\\\";\\n    static final String        T_EXPLAIN              = \\\"EXPLAIN\\\";\\n    public static final String T_EVENT                = \\\"EVENT\\\";\\n    static final String        T_FILE                 = \\\"FILE\\\";\\n    public static final String T_FILES                = \\\"FILES\\\";\\n    static final String        T_FOLD                 = \\\"FOLD\\\";\\n    static final String        T_FORMAT               = \\\"FORMAT\\\";\\n    static final String        T_GROUP_CONCAT         = \\\"GROUP_CONCAT\\\";\\n    static final String        T_HEADER               = \\\"HEADER\\\";\\n    static final String        T_IFNULL               = \\\"IFNULL\\\";\\n    static final String        T_IGNORECASE           = \\\"IGNORECASE\\\";\\n    static final String        T_IMMEDIATELY          = \\\"IMMEDIATELY\\\";\\n    public static final String T_INDEX                = \\\"INDEX\\\";\\n    public static final String T_INITIAL              = \\\"INITIAL\\\";\\n    public static final String T_INTEGRITY            = \\\"INTEGRITY\\\";\\n    static final String        T_IS_AUTOCOMMIT        = \\\"IS_AUTOCOMMIT\\\";\\n    static final String        T_IS_READONLY_DATABASE = \\\"IS_READONLY_DATABASE\\\";\\n    static final String T_IS_READONLY_DATABASE_FILES =\\n        \\\"IS_READONLY_DATABASE_FILES\\\";\\n    static final String        T_IS_READONLY_SESSION  = \\\"IS_READONLY_SESSION\\\";\\n    static final String        T_ISNULL               = \\\"ISNULL\\\";\\n    static final String        T_LASTVAL              = \\\"LASTVAL\\\";\\n    static final String        T_LIMIT                = \\\"LIMIT\\\";\\n    public static final String T_LOB                  = \\\"LOB\\\";\\n    public static final String T_LOCK                 = \\\"LOCK\\\";\\n    public static final String T_LOCKS                = \\\"LOCKS\\\";\\n    public static final String T_LONG                 = \\\"LONG\\\";\\n    public static final String T_LONGVAR              = \\\"LONGVAR\\\";\\n    public static final String T_LONGVARBINARY        = \\\"LONGVARBINARY\\\";\\n    public static final String T_LONGVARCHAR          = \\\"LONGVARCHAR\\\";\\n    static final String        T_MAXROWS              = \\\"MAXROWS\\\";\\n    static final String        T_MEDIAN               = \\\"MEDIAN\\\";\\n    public static final String T_MEMORY               = \\\"MEMORY\\\";\\n    public static final String T_MILLIS               = \\\"MILLIS\\\";\\n    static final String        T_MINUS_EXCEPT         = \\\"MINUS\\\";\\n    public static final String T_MSS                  = \\\"MSS\\\";\\n    public static final String T_MVCC                 = \\\"MVCC\\\";\\n    public static final String T_MVLOCKS              = \\\"MVLOCKS\\\";\\n    public static final String T_MYS                  = \\\"MYS\\\";\\n    public static final String T_NAN                  = \\\"NAN\\\";\\n    static final String        T_NEXTVAL              = \\\"NEXTVAL\\\";\\n    public static final String T_NIO                  = \\\"NIO\\\";\\n    static final String        T_NOWAIT               = \\\"NOWAIT\\\";\\n    public static final String T_NVARCHAR             = \\\"NVARCHAR\\\";\\n    static final String        T_NVL                  = \\\"NVL\\\";\\n    static final String        T_OCTETLENGTH          = \\\"OCTETLENGTH\\\";\\n    static final String        T_OFF                  = \\\"OFF\\\";\\n    public static final String T_OTHER                = \\\"OTHER\\\";\\n    public static final String T_ORA                  = \\\"ORA\\\";\\n    public static final String T_PASSWORD             = \\\"PASSWORD\\\";\\n    static final String        T_PLAN                 = \\\"PLAN\\\";\\n    public static final String T_PGS                  = \\\"PGS\\\";\\n    static final String        T_PROPERTY             = \\\"PROPERTY\\\";\\n    static final String        T_QUEUE                = \\\"QUEUE\\\";\\n    static final String        T_RAW                  = \\\"RAW\\\";\\n    static final String        T_READONLY             = \\\"READONLY\\\";\\n    static final String        T_REFERENTIAL          = \\\"REFERENTIAL\\\";\\n    static final String        T_RENAME               = \\\"RENAME\\\";\\n    static final String        T_RESTRICT             = \\\"RESTRICT\\\";\\n    static final String        T_ROWNUM               = \\\"ROWNUM\\\";\\n    static final String        T_SCRIPT               = \\\"SCRIPT\\\";\\n    static final String        T_SEPARATOR            = \\\"SEPARATOR\\\";\\n    static final String        T_BLOCKING             = \\\"BLOCKING\\\";\\n    static final String        T_SHUTDOWN             = \\\"SHUTDOWN\\\";\\n    static final String        T_SQL_TSI_DAY          = \\\"SQL_TSI_DAY\\\";\\n    static final String        T_SQL_TSI_FRAC_SECOND  = \\\"SQL_TSI_FRAC_SECOND\\\";\\n    static final String        T_SQL_TSI_MILLI_SECOND = \\\"SQL_TSI_MILLI_SECOND\\\";\\n    static final String        T_SQL_TSI_HOUR         = \\\"SQL_TSI_HOUR\\\";\\n    static final String        T_SQL_TSI_MINUTE       = \\\"SQL_TSI_MINUTE\\\";\\n    static final String        T_SQL_TSI_MONTH        = \\\"SQL_TSI_MONTH\\\";\\n    static final String        T_SQL_TSI_QUARTER      = \\\"SQL_TSI_QUARTER\\\";\\n    static final String        T_SQL_TSI_SECOND       = \\\"SQL_TSI_SECOND\\\";\\n    static final String        T_SQL_TSI_WEEK         = \\\"SQL_TSI_WEEK\\\";\\n    static final String        T_SQL_TSI_YEAR         = \\\"SQL_TSI_YEAR\\\";\\n    static final String        T_SQL_BIGINT           = \\\"SQL_BIGINT\\\";\\n    static final String        T_SQL_BINARY           = \\\"SQL_BINARY\\\";\\n    static final String        T_SQL_BIT              = \\\"SQL_BIT\\\";\\n    static final String        T_SQL_BLOB             = \\\"SQL_BLOB\\\";\\n    static final String        T_SQL_BOOLEAN          = \\\"SQL_BOOLEAN\\\";\\n    static final String        T_SQL_CHAR             = \\\"SQL_CHAR\\\";\\n    static final String        T_SQL_CLOB             = \\\"SQL_CLOB\\\";\\n    static final String        T_SQL_DATE             = \\\"SQL_DATE\\\";\\n    static final String        T_SQL_DECIMAL          = \\\"SQL_DECIMAL\\\";\\n    static final String        T_SQL_DATALINK         = \\\"SQL_DATALINK\\\";\\n    static final String        T_SQL_DOUBLE           = \\\"SQL_DOUBLE\\\";\\n    static final String        T_SQL_FLOAT            = \\\"SQL_FLOAT\\\";\\n    static final String        T_SQL_INTEGER          = \\\"SQL_INTEGER\\\";\\n    static final String        T_SQL_LONGVARBINARY    = \\\"SQL_LONGVARBINARY\\\";\\n    static final String        T_SQL_LONGNVARCHAR     = \\\"SQL_LONGNVARCHAR\\\";\\n    static final String        T_SQL_LONGVARCHAR      = \\\"SQL_LONGVARCHAR\\\";\\n    static final String        T_SQL_NCHAR            = \\\"SQL_NCHAR\\\";\\n    static final String        T_SQL_NCLOB            = \\\"SQL_NCLOB\\\";\\n    static final String        T_SQL_NUMERIC          = \\\"SQL_NUMERIC\\\";\\n    static final String        T_SQL_NVARCHAR         = \\\"SQL_NVARCHAR\\\";\\n    static final String        T_SQL_REAL             = \\\"SQL_REAL\\\";\\n    static final String        T_SQL_ROWID            = \\\"SQL_ROWID\\\";\\n    static final String        T_SQL_SQLXML           = \\\"SQL_SQLXML\\\";\\n    static final String        T_SQL_SMALLINT         = \\\"SQL_SMALLINT\\\";\\n    static final String        T_SQL_TIME             = \\\"SQL_TIME\\\";\\n    static final String        T_SQL_TIMESTAMP        = \\\"SQL_TIMESTAMP\\\";\\n    static final String        T_SQL_TINYINT          = \\\"SQL_TINYINT\\\";\\n    static final String        T_SQL_VARBINARY        = \\\"SQL_VARBINARY\\\";\\n    static final String        T_SQL_VARCHAR          = \\\"SQL_VARCHAR\\\";\\n    public static final String T_SYNTAX               = \\\"SYNTAX\\\";\\n    public static final String T_TDC                  = \\\"TDC\\\";\\n    public static final String T_TEMP                 = \\\"TEMP\\\";\\n    public static final String T_TEXT                 = \\\"TEXT\\\";\\n    static final String        T_TIMESTAMPADD         = \\\"TIMESTAMPADD\\\";\\n    static final String        T_TIMESTAMPDIFF        = \\\"TIMESTAMPDIFF\\\";\\n    public static final String T_TINYINT              = \\\"TINYINT\\\";\\n    static final String        T_TOP                  = \\\"TOP\\\";\\n    public static final String T_TTI                  = \\\"TTI\\\";\\n    public static final String T_TYPES                = \\\"TYPES\\\";\\n    public static final String T_VARCHAR_IGNORECASE   = \\\"VARCHAR_IGNORECASE\\\";\\n    public static final String T_VARCHAR2             = \\\"VARCHAR2\\\";\\n    public static final String T_UTF16                = \\\"UTF16\\\";\\n    static final String        T_WRITE_DELAY          = \\\"WRITE_DELAY\\\";\\n    public static final String T_YES                  = \\\"YES\\\";\\n        public static final String T_DAY_NAME     = \\\"DAY_NAME\\\";\\n    public static final String T_MONTH_NAME   = \\\"MONTH_NAME\\\";\\n    public static final String T_QUARTER      = \\\"QUARTER\\\";\\n    public static final String T_DAY_OF_WEEK  = \\\"DAY_OF_WEEK\\\";\\n    public static final String T_DAY_OF_MONTH = \\\"DAY_OF_MONTH\\\";\\n    public static final String T_DAY_OF_YEAR  = \\\"DAY_OF_YEAR\\\";\\n    public static final String T_WEEK_OF_YEAR = \\\"WEEK_OF_YEAR\\\";\\n    static final String        T_DAYNAME      = \\\"DAYNAME\\\";\\n    static final String        T_MONTHNAME    = \\\"MONTHNAME\\\";\\n    static final String        T_DAYOFMONTH   = \\\"DAYOFMONTH\\\";\\n    static final String        T_DAYOFWEEK    = \\\"DAYOFWEEK\\\";\\n    static final String        T_DAYOFYEAR    = \\\"DAYOFYEAR\\\";\\n    static final String        T_WEEK         = \\\"WEEK\\\";\\n        static final String        T_ACOS             = \\\"ACOS\\\";\\n    static final String        T_ACTION_ID        = \\\"ACTION_ID\\\";\\n    static final String        T_ARRAY_SORT       = \\\"ARRAY_SORT\\\";\\n    static final String        T_ASCII            = \\\"ASCII\\\";\\n    static final String        T_ASIN             = \\\"ASIN\\\";\\n    static final String        T_ATAN             = \\\"ATAN\\\";\\n    static final String        T_ATAN2            = \\\"ATAN2\\\";\\n    static final String        T_BITAND           = \\\"BITAND\\\";\\n    static final String        T_BITOR            = \\\"BITOR\\\";\\n    static final String        T_BITXOR           = \\\"BITXOR\\\";\\n    public static final String T_CONCAT_WORD      = \\\"CONCAT\\\";\\n    static final String        T_CHR              = \\\"CHR\\\";\\n    static final String        T_COS              = \\\"COS\\\";\\n    static final String        T_COT              = \\\"COT\\\";\\n    static final String        T_CRYPT_KEY        = \\\"CRYPT_KEY\\\";\\n    static final String        T_DATABASE_NAME    = \\\"DATABASE_NAME\\\";\\n    static final String        T_DATEADD          = \\\"DATEADD\\\";\\n    static final String        T_DATEDIFF         = \\\"DATEDIFF\\\";\\n    static final String        T_DECODE           = \\\"DECODE\\\";\\n    static final String        T_DEGREES          = \\\"DEGREES\\\";\\n    static final String        T_DIFFERENCE       = \\\"DIFFERENCE\\\";\\n    static final String        T_DMOD             = \\\"DMOD\\\";\\n    public static final String T_GC               = \\\"GC\\\";\\n    static final String        T_GREATEST         = \\\"GREATEST\\\";\\n    static final String        T_HEXTORAW         = \\\"HEXTORAW\\\";\\n    static final String        T_LCASE            = \\\"LCASE\\\";\\n    static final String        T_LEAST            = \\\"LEAST\\\";\\n    static final String        T_LOAD_FILE        = \\\"LOAD_FILE\\\";\\n    static final String        T_LOCATE           = \\\"LOCATE\\\";\\n    public static final String T_LOG              = \\\"LOG\\\";\\n    static final String        T_LOG10            = \\\"LOG10\\\";\\n    static final String        T_LPAD             = \\\"LPAD\\\";\\n    static final String        T_LTRIM            = \\\"LTRIM\\\";\\n    static final String        T_NOW              = \\\"NOW\\\";\\n    static final String        T_PI               = \\\"PI\\\";\\n    static final String        T_RADIANS          = \\\"RADIANS\\\";\\n    static final String        T_RAND             = \\\"RAND\\\";\\n    static final String        T_RAWTOHEX         = \\\"RAWTOHEX\\\";\\n    public static final String T_REGEXP_MATCHES   = \\\"REGEXP_MATCHES\\\";\\n    static final String        T_REPLACE          = \\\"REPLACE\\\";\\n    static final String        T_REVERSE          = \\\"REVERSE\\\";\\n    static final String        T_ROUND            = \\\"ROUND\\\";\\n    static final String        T_ROUNDMAGIC       = \\\"ROUNDMAGIC\\\";\\n    static final String        T_RPAD             = \\\"RPAD\\\";\\n    static final String        T_RTRIM            = \\\"RTRIM\\\";\\n    public static final String T_SECONDS_MIDNIGHT = \\\"SECONDS_SINCE_MIDNIGHT\\\";\\n    static final String        T_SIGN             = \\\"SIGN\\\";\\n    static final String        T_SIN              = \\\"SIN\\\";\\n    static final String        T_SOUNDEX          = \\\"SOUNDEX\\\";\\n    static final String        T_SUBSTR           = \\\"SUBSTR\\\";\\n    static final String        T_SYSDATE          = \\\"SYSDATE\\\";\\n    static final String        T_TAN              = \\\"TAN\\\";\\n    static final String        T_TO_CHAR          = \\\"TO_CHAR\\\";\\n    static final String        T_TO_DATE          = \\\"TO_DATE\\\";\\n    static final String        T_TO_TIMESTAMP     = \\\"TO_TIMESTAMP\\\";\\n    static final String        T_TRANSACTION_SIZE = \\\"TRANSACTION_SIZE\\\";\\n    static final String        T_TRANSACTION_ID   = \\\"TRANSACTION_ID\\\";\\n    static final String        T_TRUNC            = \\\"TRUNC\\\";\\n    static final String        T_TODAY            = \\\"TODAY\\\";\\n    static final String        T_UCASE            = \\\"UCASE\\\";\\n    static final String        T_UUID             = \\\"UUID\\\";\\n    static final String        T_UNIX_TIMESTAMP   = \\\"UNIX_TIMESTAMP\\\";\\n        static final String T_ISOLATION_LEVEL         = \\\"ISOLATION_LEVEL\\\";\\n    static final String T_SESSION_ISOLATION_LEVEL = \\\"SESSION_ISOLATION_LEVEL\\\";\\n    static final String T_DATABASE_ISOLATION_LEVEL =\\n        \\\"DATABASE_ISOLATION_LEVEL\\\";\\n    static final String T_TRANSACTION_CONTROL = \\\"TRANSACTION_CONTROL\\\";\\n    static final String T_TIMEZONE            = \\\"TIMEZONE\\\";\\n    static final String T_SESSION_TIMEZONE    = \\\"SESSION_TIMEZONE\\\";\\n    static final String T_DATABASE_TIMEZONE   = \\\"DATABASE_TIMEZONE\\\";\\n    static final String T_DATABASE_VERSION    = \\\"DATABASE_VERSION\\\";\\n    static final String T_SESSION_ID          = \\\"SESSION_ID\\\";\\n    static final String T_LOB_ID              = \\\"LOB_ID\\\";\\n    static final String T_SEQUENCE_ARRAY      = \\\"SEQUENCE_ARRAY\\\";\\n            public static final int ABS                              = 1;\\n    public static final int ALL                              = 2;\\n    public static final int ALLOCATE                         = 3;\\n    public static final int ALTER                            = 4;\\n    public static final int AND                              = 5;\\n    public static final int ANY                              = 6;\\n    public static final int ARE                              = 7;\\n    public static final int ARRAY                            = 8;\\n    public static final int ARRAY_AGG                        = 9;\\n    public static final int AS                               = 10;\\n    public static final int ASENSITIVE                       = 11;\\n    public static final int ASYMMETRIC                       = 12;\\n    public static final int AT                               = 13;\\n    public static final int ATOMIC                           = 14;\\n    public static final int AUTHORIZATION                    = 15;\\n    public static final int AVG                              = 16;\\n    public static final int BEGIN                            = 17;\\n    public static final int BETWEEN                          = 18;\\n    public static final int BIGINT                           = 19;\\n    public static final int BINARY                           = 20;\\n    public static final int BLOB                             = 21;\\n    public static final int BOOLEAN                          = 22;\\n    public static final int BOTH                             = 23;\\n    public static final int BY                               = 24;\\n    public static final int CALL                             = 25;\\n    public static final int CALLED                           = 26;\\n    public static final int CARDINALITY                      = 27;\\n    public static final int CASCADED                         = 28;\\n    public static final int CASE                             = 29;\\n    public static final int CAST                             = 30;\\n    public static final int CEIL                             = 31;\\n    public static final int CEILING                          = 32;\\n    public static final int CHAR                             = 33;\\n    public static final int CHAR_LENGTH                      = 34;\\n    public static final int CHARACTER                        = 35;\\n    public static final int CHARACTER_LENGTH                 = 36;\\n    public static final int CHECK                            = 37;\\n    public static final int CLOB                             = 38;\\n    public static final int CLOSE                            = 39;\\n    public static final int COALESCE                         = 40;\\n    public static final int COLLATE                          = 41;\\n    public static final int COLLECT                          = 42;\\n    public static final int COLUMN                           = 43;\\n    public static final int COMMIT                           = 44;\\n    public static final int COMPARABLE                       = 45;\\n    public static final int CONDITION                        = 46;\\n    public static final int CONNECT                          = 47;\\n    public static final int CONSTRAINT                       = 48;\\n    public static final int CONVERT                          = 49;\\n    public static final int CORR                             = 50;\\n    public static final int CORRESPONDING                    = 51;\\n    public static final int COUNT                            = 52;\\n    public static final int COVAR_POP                        = 53;\\n    public static final int COVAR_SAMP                       = 54;\\n    public static final int CREATE                           = 55;\\n    public static final int CROSS                            = 56;\\n    public static final int CUBE                             = 57;\\n    public static final int CUME_DIST                        = 58;\\n    public static final int CURRENT                          = 59;\\n    public static final int CURRENT_CATALOG                  = 60;\\n    public static final int CURRENT_DATE                     = 61;\\n    public static final int CURRENT_DEFAULT_TRANSFORM_GROUP  = 62;\\n    public static final int CURRENT_PATH                     = 63;\\n    public static final int CURRENT_ROLE                     = 64;\\n    public static final int CURRENT_SCHEMA                   = 65;\\n    public static final int CURRENT_TIME                     = 66;\\n    public static final int CURRENT_TIMESTAMP                = 67;\\n    public static final int CURRENT_TRANSFORM_GROUP_FOR_TYPE = 68;\\n    public static final int CURRENT_USER                     = 69;\\n    public static final int CURSOR                           = 70;\\n    public static final int CYCLE                            = 71;\\n    public static final int DATE                             = 72;\\n    public static final int DAY                              = 73;\\n    public static final int DEALLOCATE                       = 74;\\n    public static final int DEC                              = 75;\\n    public static final int DECIMAL                          = 76;\\n    public static final int DECLARE                          = 77;\\n    public static final int DEFAULT                          = 78;\\n    public static final int DELETE                           = 79;\\n    public static final int DENSE_RANK                       = 80;\\n    public static final int DEREF                            = 81;\\n    public static final int DESCRIBE                         = 82;\\n    public static final int DETERMINISTIC                    = 83;\\n    public static final int DISCONNECT                       = 84;\\n    public static final int DISTINCT                         = 85;\\n    public static final int DO                               = 86;\\n    public static final int DOUBLE                           = 87;\\n    public static final int DROP                             = 88;\\n    public static final int DYNAMIC                          = 89;\\n    public static final int EACH                             = 90;\\n    public static final int ELEMENT                          = 91;\\n    public static final int ELSE                             = 92;\\n    public static final int ELSEIF                           = 93;\\n    public static final int END                              = 94;\\n    public static final int END_EXEC                         = 95;\\n    public static final int ESCAPE                           = 96;\\n    public static final int EVERY                            = 97;\\n    public static final int EXCEPT                           = 98;\\n    public static final int EXEC                             = 99;\\n    public static final int EXECUTE                          = 100;\\n    public static final int EXISTS                           = 101;\\n    public static final int EXIT                             = 102;\\n    public static final int EXP                              = 103;\\n    public static final int EXTERNAL                         = 104;\\n    public static final int EXTRACT                          = 105;\\n    public static final int FALSE                            = 106;\\n    public static final int FETCH                            = 107;\\n    public static final int FILTER                           = 108;\\n    public static final int FIRST_VALUE                      = 109;\\n    public static final int FLOAT                            = 110;\\n    public static final int FLOOR                            = 111;\\n    public static final int FOR                              = 112;\\n    public static final int FOREIGN                          = 113;\\n    public static final int FREE                             = 114;\\n    public static final int FROM                             = 115;\\n    public static final int FULL                             = 116;\\n    public static final int FUNCTION                         = 117;\\n    public static final int FUSION                           = 118;\\n    public static final int GET                              = 119;\\n    public static final int GLOBAL                           = 120;\\n    public static final int GRANT                            = 121;\\n    public static final int GROUP                            = 122;\\n    public static final int GROUPING                         = 123;\\n    public static final int HANDLER                          = 124;\\n    public static final int HAVING                           = 125;\\n    public static final int HOLD                             = 126;\\n    public static final int HOUR                             = 127;\\n    public static final int IDENTITY                         = 128;\\n    public static final int IMPORT                           = 129;\\n    public static final int IN                               = 130;\\n    public static final int INDICATOR                        = 131;\\n    public static final int INNER                            = 132;\\n    public static final int INOUT                            = 133;\\n    public static final int INSENSITIVE                      = 134;\\n    public static final int INSERT                           = 135;\\n    public static final int INT                              = 136;\\n    public static final int INTEGER                          = 137;\\n    public static final int INTERSECT                        = 138;\\n    public static final int INTERSECTION                     = 139;\\n    public static final int INTERVAL                         = 140;\\n    public static final int INTO                             = 141;\\n    public static final int IS                               = 142;\\n    public static final int ITERATE                          = 143;\\n    public static final int JOIN                             = 144;\\n    public static final int LAG                              = 145;\\n    public static final int LANGUAGE                         = 146;\\n    public static final int LARGE                            = 147;\\n    public static final int LAST_VALUE                       = 148;\\n    public static final int LATERAL                          = 149;\\n    public static final int LEAD                             = 150;\\n    public static final int LEADING                          = 151;\\n    public static final int LEAVE                            = 152;\\n    public static final int LEFT                             = 153;\\n    public static final int LIKE                             = 154;\\n    public static final int LIKE_REGEX                       = 155;\\n    public static final int LN                               = 156;\\n    public static final int LOCAL                            = 157;\\n    public static final int LOCALTIME                        = 158;\\n    public static final int LOCALTIMESTAMP                   = 159;\\n    public static final int LOOP                             = 160;\\n    public static final int LOWER                            = 161;\\n    public static final int MATCH                            = 162;\\n    public static final int MAX                              = 163;\\n    public static final int MAX_CARDINALITY                  = 164;\\n    public static final int MEMBER                           = 165;\\n    public static final int MERGE                            = 166;\\n    public static final int METHOD                           = 167;\\n    public static final int MIN                              = 168;\\n    public static final int MINUTE                           = 169;\\n    public static final int MOD                              = 170;\\n    public static final int MODIFIES                         = 171;\\n    public static final int MODULE                           = 172;\\n    public static final int MONTH                            = 173;\\n    public static final int MULTISET                         = 174;\\n    public static final int NATIONAL                         = 175;\\n    public static final int NATURAL                          = 176;\\n    public static final int NCHAR                            = 177;\\n    public static final int NCLOB                            = 178;\\n    public static final int NEW                              = 179;\\n    public static final int NO                               = 180;\\n    public static final int NONE                             = 181;\\n    public static final int NORMALIZE                        = 182;\\n    public static final int NOT                              = 183;\\n    public static final int NTH_VALUE                        = 184;\\n    public static final int NTILE                            = 185;\\n    public static final int NULL                             = 186;\\n    public static final int NULLIF                           = 187;\\n    public static final int NUMERIC                          = 188;\\n    public static final int OCCURRENCES_REGEX                = 189;\\n    public static final int OCTET_LENGTH                     = 190;\\n    public static final int OF                               = 191;\\n    public static final int OFFSET                           = 192;\\n    public static final int OLD                              = 193;\\n    public static final int ON                               = 194;\\n    public static final int ONLY                             = 195;\\n    public static final int OPEN                             = 196;\\n    public static final int OR                               = 197;\\n    public static final int ORDER                            = 198;\\n    public static final int OUT                              = 199;\\n    public static final int OUTER                            = 200;\\n    public static final int OVER                             = 201;\\n    public static final int OVERLAPS                         = 202;\\n    public static final int OVERLAY                          = 203;\\n    public static final int PARAMETER                        = 204;\\n    public static final int PARTITION                        = 205;\\n    public static final int PERCENT_RANK                     = 206;\\n    public static final int PERCENTILE_CONT                  = 207;\\n    public static final int PERCENTILE_DISC                  = 208;\\n    public static final int POSITION                         = 209;\\n    public static final int POSITION_REGEX                   = 210;\\n    public static final int POWER                            = 211;\\n    public static final int PRECISION                        = 212;\\n    public static final int PREPARE                          = 213;\\n    public static final int PRIMARY                          = 214;\\n    public static final int PROCEDURE                        = 215;\\n    public static final int RANGE                            = 216;\\n    public static final int RANK                             = 217;\\n    public static final int READS                            = 218;\\n    public static final int REAL                             = 219;\\n    public static final int RECURSIVE                        = 220;\\n    public static final int REF                              = 221;\\n    public static final int REFERENCES                       = 222;\\n    public static final int REFERENCING                      = 223;\\n    public static final int REGR_AVGX                        = 224;\\n    public static final int REGR_AVGY                        = 225;\\n    public static final int REGR_COUNT                       = 226;\\n    public static final int REGR_INTERCEPT                   = 227;\\n    public static final int REGR_R2                          = 228;\\n    public static final int REGR_SLOPE                       = 229;\\n    public static final int REGR_SXX                         = 230;\\n    public static final int REGR_SXY                         = 231;\\n    public static final int REGR_SYY                         = 232;\\n    public static final int RELEASE                          = 233;\\n    public static final int REPEAT                           = 234;\\n    public static final int RESIGNAL                         = 235;\\n    public static final int RESULT                           = 236;\\n    public static final int RETURN                           = 237;\\n    public static final int RETURNS                          = 238;\\n    public static final int REVOKE                           = 239;\\n    public static final int RIGHT                            = 240;\\n    public static final int ROLLBACK                         = 241;\\n    public static final int ROLLUP                           = 242;\\n    public static final int ROW                              = 243;\\n    public static final int ROW_NUMBER                       = 244;\\n    public static final int ROWS                             = 245;\\n    public static final int SAVEPOINT                        = 246;\\n    public static final int SCOPE                            = 247;\\n    public static final int SCROLL                           = 248;\\n    public static final int SEARCH                           = 249;\\n    public static final int SECOND                           = 250;\\n    public static final int SELECT                           = 251;\\n    public static final int SENSITIVE                        = 252;\\n    public static final int SESSION_USER                     = 253;\\n    public static final int SET                              = 254;\\n    public static final int SIGNAL                           = 255;\\n    public static final int SIMILAR                          = 256;\\n    public static final int SMALLINT                         = 257;\\n    public static final int SOME                             = 258;\\n    public static final int SPECIFIC                         = 259;\\n    public static final int SPECIFICTYPE                     = 260;\\n    public static final int SQL                              = 261;\\n    public static final int SQLEXCEPTION                     = 262;\\n    public static final int SQLSTATE                         = 263;\\n    public static final int SQLWARNING                       = 264;\\n    public static final int SQRT                             = 265;\\n    public static final int STACKED                          = 266;\\n    public static final int START                            = 267;\\n    public static final int STATIC                           = 268;\\n    public static final int STDDEV_POP                       = 269;\\n    public static final int STDDEV_SAMP                      = 270;\\n    public static final int SUBMULTISET                      = 271;\\n    public static final int SUBSTRING                        = 272;\\n    public static final int SUBSTRING_REGEX                  = 273;\\n    public static final int SUM                              = 274;\\n    public static final int SYMMETRIC                        = 275;\\n    public static final int SYSTEM                           = 276;\\n    public static final int SYSTEM_USER                      = 277;\\n    public static final int TABLE                            = 278;\\n    public static final int TABLESAMPLE                      = 279;\\n    public static final int THEN                             = 280;\\n    public static final int TIME                             = 281;\\n    public static final int TIMESTAMP                        = 282;\\n    public static final int TIMEZONE_HOUR                    = 283;\\n    public static final int TIMEZONE_MINUTE                  = 284;\\n    public static final int TO                               = 285;\\n    public static final int TRAILING                         = 286;\\n    public static final int TRANSLATE                        = 287;\\n    public static final int TRANSLATE_REGEX                  = 288;\\n    public static final int TRANSLATION                      = 289;\\n    public static final int TREAT                            = 290;\\n    public static final int TRIGGER                          = 291;\\n    public static final int TRIM                             = 292;\\n    public static final int TRIM_ARRAY                       = 293;\\n    public static final int TRUE                             = 294;\\n    public static final int TRUNCATE                         = 295;\\n    public static final int UESCAPE                          = 296;\\n    public static final int UNDO                             = 297;\\n    public static final int UNION                            = 298;\\n    public static final int UNIQUE                           = 299;\\n    public static final int UNKNOWN                          = 300;\\n    public static final int UNNEST                           = 301;\\n    public static final int UNTIL                            = 302;\\n    public static final int UPDATE                           = 303;\\n    public static final int UPPER                            = 304;\\n    public static final int USER                             = 305;\\n    public static final int USING                            = 306;\\n    public static final int VALUE                            = 307;\\n    public static final int VALUES                           = 308;\\n    public static final int VAR_POP                          = 309;\\n    public static final int VAR_SAMP                         = 310;\\n    public static final int VARBINARY                        = 311;\\n    public static final int VARCHAR                          = 312;\\n    public static final int VARYING                          = 313;\\n    public static final int WHEN                             = 314;\\n    public static final int WHENEVER                         = 315;\\n    public static final int WHERE                            = 316;\\n    public static final int WIDTH_BUCKET                     = 317;\\n    public static final int WINDOW                           = 318;\\n    public static final int WITH                             = 319;\\n    public static final int WITHIN                           = 320;\\n    public static final int WITHOUT                          = 321;\\n    public static final int WHILE                            = 322;\\n    public static final int YEAR                             = 323;\\n            public static final int A                           = 330;\\n    public static final int ABSOLUTE                    = 331;\\n    public static final int ACTION                      = 332;\\n    public static final int ADA                         = 333;\\n    public static final int ADD                         = 334;\\n    public static final int ADMIN                       = 335;\\n    public static final int AFTER                       = 336;\\n    public static final int ALWAYS                      = 337;\\n    public static final int ASC                         = 338;\\n    public static final int ASSERTION                   = 339;\\n    public static final int ASSIGNMENT                  = 340;\\n    public static final int ATTRIBUTE                   = 341;\\n    public static final int ATTRIBUTES                  = 342;\\n    public static final int BEFORE                      = 343;\\n    public static final int BERNOULLI                   = 344;\\n    public static final int BREADTH                     = 345;\\n    public static final int C                           = 346;\\n    public static final int CASCADE                     = 347;\\n    public static final int CATALOG                     = 348;\\n    public static final int CATALOG_NAME                = 349;\\n    public static final int CHAIN                       = 350;\\n    public static final int CHARACTER_SET_CATALOG       = 351;\\n    public static final int CHARACTER_SET_NAME          = 352;\\n    public static final int CHARACTER_SET_SCHEMA        = 353;\\n    public static final int CHARACTERISTICS             = 354;\\n    public static final int CHARACTERS                  = 355;\\n    public static final int CLASS_ORIGIN                = 356;\\n    public static final int COBOL                       = 357;\\n    public static final int COLLATION                   = 358;\\n    public static final int COLLATION_CATALOG           = 359;\\n    public static final int COLLATION_NAME              = 360;\\n    public static final int COLLATION_SCHEMA            = 361;\\n    public static final int COLUMN_NAME                 = 362;\\n    public static final int COMMAND_FUNCTION            = 363;\\n    public static final int COMMAND_FUNCTION_CODE       = 364;\\n    public static final int COMMITTED                   = 365;\\n    public static final int CONDITION_IDENTIFIER        = 366;\\n    public static final int CONDITION_NUMBER            = 367;\\n    public static final int CONNECTION                  = 368;\\n    public static final int CONNECTION_NAME             = 369;\\n    public static final int CONSTRAINT_CATALOG          = 370;\\n    public static final int CONSTRAINT_NAME             = 371;\\n    public static final int CONSTRAINT_SCHEMA           = 372;\\n    public static final int CONSTRAINTS                 = 373;\\n    public static final int CONSTRUCTOR                 = 374;\\n    public static final int CONTAINS                    = 375;\\n    public static final int CONTINUE                    = 376;\\n    public static final int CURSOR_NAME                 = 377;\\n    public static final int DATA                        = 378;\\n    public static final int DATETIME_INTERVAL_CODE      = 379;\\n    public static final int DATETIME_INTERVAL_PRECISION = 380;\\n    public static final int DEFAULTS                    = 381;\\n    public static final int DEFERRABLE                  = 382;\\n    public static final int DEFERRED                    = 383;\\n    public static final int DEFINED                     = 384;\\n    public static final int DEFINER                     = 385;\\n    public static final int DEGREE                      = 386;\\n    public static final int DEPTH                       = 387;\\n    public static final int DERIVED                     = 388;\\n    public static final int DESC                        = 389;\\n    public static final int DESCRIPTOR                  = 390;\\n    public static final int DIAGNOSTICS                 = 391;\\n    public static final int DISPATCH                    = 392;\\n    public static final int DOMAIN                      = 393;\\n    public static final int DYNAMIC_FUNCTION            = 394;\\n    public static final int DYNAMIC_FUNCTION_CODE       = 395;\\n    public static final int EQUALS                      = 396;\\n    public static final int EXCEPTION                   = 397;\\n    public static final int EXCLUDE                     = 398;\\n    public static final int EXCLUDING                   = 399;\\n    public static final int FINAL                       = 400;\\n    public static final int FIRST                       = 401;\\n    public static final int FOLLOWING                   = 402;\\n    public static final int FORTRAN                     = 403;\\n    public static final int FOUND                       = 404;\\n    public static final int G                           = 405;\\n    public static final int GENERAL                     = 406;\\n    public static final int GENERATED                   = 407;\\n    public static final int GO                          = 408;\\n    public static final int GOTO                        = 409;\\n    public static final int GRANTED                     = 410;\\n    public static final int HIERARCHY                   = 411;\\n    public static final int IF                          = 412;\\n    public static final int IGNORE                      = 413;\\n    public static final int IMMEDIATE                   = 414;\\n    public static final int IMPLEMENTATION              = 415;\\n    public static final int INCLUDING                   = 416;\\n    public static final int INCREMENT                   = 417;\\n    public static final int INITIALLY                   = 418;\\n    public static final int INPUT                       = 419;\\n    public static final int INSTANCE                    = 420;\\n    public static final int INSTANTIABLE                = 421;\\n    public static final int INSTEAD                     = 422;\\n    public static final int INVOKER                     = 423;\\n    public static final int ISOLATION                   = 424;\\n    public static final int JAVA                        = 425;\\n    public static final int K                           = 426;\\n    public static final int KEY                         = 427;\\n    public static final int KEY_MEMBER                  = 428;\\n    public static final int KEY_TYPE                    = 429;\\n    public static final int LAST                        = 430;\\n    public static final int LENGTH                      = 431;\\n    public static final int LEVEL                       = 432;\\n    public static final int LIBRARY                     = 433;\\n    public static final int LOCATOR                     = 434;\\n    public static final int M                           = 435;\\n    public static final int MAP                         = 436;\\n    public static final int MATCHED                     = 437;\\n    public static final int MAXVALUE                    = 438;\\n    public static final int MESSAGE_LENGTH              = 439;\\n    public static final int MESSAGE_OCTET_LENGTH        = 440;\\n    public static final int MESSAGE_TEXT                = 441;\\n    public static final int MINVALUE                    = 442;\\n    public static final int MORE                        = 443;\\n    public static final int MUMPS                       = 444;\\n    public static final int NAME                        = 445;\\n    public static final int NAMES                       = 446;\\n    public static final int NESTING                     = 447;\\n    public static final int NEXT                        = 448;\\n    public static final int NORMALIZED                  = 449;\\n    public static final int NULLABLE                    = 450;\\n    public static final int NULLS                       = 451;\\n    public static final int NUMBER                      = 452;\\n    public static final int OBJECT                      = 453;\\n    public static final int OCTETS                      = 454;\\n    public static final int OPTION                      = 455;\\n    public static final int OPTIONS                     = 456;\\n    public static final int ORDERING                    = 457;\\n    public static final int ORDINALITY                  = 458;\\n    public static final int OTHERS                      = 459;\\n    public static final int OUTPUT                      = 460;\\n    public static final int OVERRIDING                  = 461;\\n    public static final int P                           = 462;\\n    public static final int PAD                         = 463;\\n    public static final int PARAMETER_MODE              = 464;\\n    public static final int PARAMETER_NAME              = 465;\\n    public static final int PARAMETER_ORDINAL_POSITION  = 466;\\n    public static final int PARAMETER_SPECIFIC_CATALOG  = 467;\\n    public static final int PARAMETER_SPECIFIC_NAME     = 468;\\n    public static final int PARAMETER_SPECIFIC_SCHEMA   = 469;\\n    public static final int PARTIAL                     = 470;\\n    public static final int PASCAL                      = 471;\\n    public static final int PATH                        = 472;\\n    public static final int PLACING                     = 473;\\n    public static final int PLI                         = 474;\\n    public static final int PRECEDING                   = 475;\\n    public static final int PRESERVE                    = 476;\\n    public static final int PRIOR                       = 477;\\n    public static final int PRIVILEGES                  = 478;\\n    public static final int PUBLIC                      = 479;\\n    public static final int READ                        = 480;\\n    public static final int RELATIVE                    = 481;\\n    public static final int REPEATABLE                  = 482;\\n    public static final int RESPECT                     = 483;\\n    public static final int RESTART                     = 484;\\n    public static final int RESTRICT                    = 485;\\n    public static final int RETURNED_CARDINALITY        = 486;\\n    public static final int RETURNED_LENGTH             = 487;\\n    public static final int RETURNED_OCTET_LENGTH       = 488;\\n    public static final int RETURNED_SQLSTATE           = 489;\\n    public static final int ROLE                        = 490;\\n    public static final int ROUTINE                     = 491;\\n    public static final int ROUTINE_CATALOG             = 492;\\n    public static final int ROUTINE_NAME                = 493;\\n    public static final int ROUTINE_SCHEMA              = 494;\\n    public static final int ROW_COUNT                   = 495;\\n    public static final int SCALE                       = 496;\\n    public static final int SCHEMA                      = 497;\\n    public static final int SCHEMA_NAME                 = 498;\\n    public static final int SCOPE_CATALOG               = 499;\\n    public static final int SCOPE_NAME                  = 500;\\n    public static final int SCOPE_SCHEMA                = 501;\\n    public static final int SECTION                     = 502;\\n    public static final int SECURITY                    = 503;\\n    public static final int SELF                        = 504;\\n    public static final int SEQUENCE                    = 505;\\n    public static final int SERIALIZABLE                = 506;\\n    public static final int SERVER_NAME                 = 507;\\n    public static final int SESSION                     = 508;\\n    public static final int SERVER                      = 509;\\n    public static final int SETS                        = 510;\\n    public static final int SIMPLE                      = 511;\\n    public static final int SIZE                        = 512;\\n    public static final int SOURCE                      = 513;\\n    public static final int SPACE                       = 514;\\n    public static final int SPECIFIC_NAME               = 515;\\n    public static final int STATE                       = 516;\\n    public static final int STATEMENT                   = 517;\\n    public static final int STRUCTURE                   = 518;\\n    public static final int STYLE                       = 519;\\n    public static final int SUBCLASS_ORIGIN             = 520;\\n    public static final int T                           = 521;\\n    public static final int TABLE_NAME                  = 522;\\n    public static final int TEMPORARY                   = 523;\\n    public static final int TIES                        = 524;\\n    public static final int TOP_LEVEL_COUNT             = 525;\\n    public static final int TRANSACTION                 = 526;\\n    public static final int TRANSACTION_ACTIVE          = 527;\\n    public static final int TRANSACTIONS_COMMITTED      = 528;\\n    public static final int TRANSACTIONS_ROLLED_BACK    = 529;\\n    public static final int TRANSFORM                   = 530;\\n    public static final int TRANSFORMS                  = 531;\\n    public static final int TRIGGER_CATALOG             = 532;\\n    public static final int TRIGGER_NAME                = 533;\\n    public static final int TRIGGER_SCHEMA              = 534;\\n    public static final int TYPE                        = 535;\\n    public static final int UNBOUNDED                   = 536;\\n    public static final int UNCOMMITTED                 = 537;\\n    public static final int UNDER                       = 538;\\n    public static final int UNNAMED                     = 539;\\n    public static final int USAGE                       = 540;\\n    public static final int USER_DEFINED_TYPE_CATALOG   = 541;\\n    public static final int USER_DEFINED_TYPE_CODE      = 542;\\n    public static final int USER_DEFINED_TYPE_NAME      = 543;\\n    public static final int USER_DEFINED_TYPE_SCHEMA    = 544;\\n    public static final int VIEW                        = 545;\\n    public static final int WORK                        = 546;\\n    public static final int WRITE                       = 547;\\n    public static final int WRAPPER                     = 548;\\n    public static final int ZONE                        = 549;\\n        static final int ALIAS          = 558;\\n    static final int AGGREGATE      = 559;\\n    static final int AUTOCOMMIT     = 560;\\n    static final int AUTHENTICATION = 561;\\n    static final int BACKUP         = 562;\\n    static final int BINARY_FLOAT   = 563;\\n    static final int BINARY_DOUBLE  = 564;\\n    static final int BIT            = 565;\\n    static final int BLOCKING       = 566;\\n    static final int BODY           = 567;\\n    static final int BYTE           = 568;\\n    static final int CACHE          = 569;\\n    static final int CACHED         = 570;\\n    static final int CASEWHEN       = 571;\\n    static final int CHECKPOINT     = 572;\\n    static final int CLASS          = 573;\\n    static final int CLUSTERED      = 574;\\n    static final int COMMENT        = 575;\\n    static final int COMPACT        = 576;\\n    static final int COMPRESSED     = 577;\\n    static final int CONTROL        = 578;\\n    static final int CURRVAL        = 579;\\n    static final int DATABASE       = 580;\\n    static final int DEADLOCK       = 581;\\n    static final int DEFRAG         = 582;\\n    static final int DELAY          = 583;\\n    static final int DIGEST         = 584;\\n    static final int EVENT          = 585;\\n    static final int EXPLAIN        = 586;\\n    static final int FILE           = 587;\\n    static final int FILES          = 588;\\n    static final int FORMAT         = 589;\\n    static final int GC             = 590;\\n    static final int HEADER         = 591;\\n    static final int IGNORECASE     = 592;\\n    static final int IMMEDIATELY    = 593;\\n    static final int INTEGRITY      = 594;\\n    static final int INDEX          = 595;\\n    static final int INITIAL        = 596;\\n    static final int LASTVAL        = 597;\\n    static final int LIMIT          = 598;\\n    static final int LOCK           = 599;\\n    static final int LOCKS          = 600;\\n    static final int LONG           = 601;\\n    static final int LONGVAR        = 602;\\n    static final int MAXROWS        = 603;\\n    static final int MEDIAN         = 604;\\n    static final int MEMORY         = 605;\\n    static final int MILLIS         = 606;\\n    static final int MINUS_EXCEPT   = 607;\\n    static final int NAN            = 608;\\n    static final int NEXTVAL        = 609;\\n    static final int OFF            = 610;\\n    static final int PASSWORD       = 611;\\n    static final int PLAN           = 612;\\n    static final int PROPERTY       = 613;\\n    static final int RAW            = 614;\\n    static final int READONLY       = 615;\\n    static final int REFERENTIAL    = 616;\\n    static final int RENAME         = 617;\\n    static final int RESET          = 618;\\n    static final int SCRIPT         = 619;\\n    static final int SEPARATOR      = 620;\\n    static final int SHUTDOWN       = 621;\\n    static final int SYNTAX         = 622;\\n    static final int TDC            = 623;\\n    static final int TEMP           = 624;\\n    static final int TEXT           = 625;\\n    static final int TTI            = 626;\\n    static final int TYPES          = 627;\\n    static final int VARCHAR2       = 628;\\n    static final int WRITE_DELAY    = 629;\\n        static final int        ACOS                       = 630;\\n    static final int        ACTION_ID                  = 631;\\n    static final int        ARRAY_SORT                 = 632;\\n    static final int        ASCII                      = 633;\\n    static final int        ASIN                       = 634;\\n    static final int        ATAN                       = 635;\\n    static final int        ATAN2                      = 636;\\n    static final int        BIT_LENGTH                 = 637;\\n    static final int        BITAND                     = 638;\\n    static final int        BITLENGTH                  = 639;\\n    static final int        BITOR                      = 640;\\n    static final int        BITXOR                     = 641;\\n    static final int        CHR                        = 642;\\n    static final int        CONCAT_WORD                = 643;\\n    static final int        COS                        = 644;\\n    static final int        COT                        = 645;\\n    static final int        CRYPT_KEY                  = 646;\\n    static final int        CURDATE                    = 647;\\n    static final int        CURTIME                    = 648;\\n    static final int        DATABASE_ISOLATION_LEVEL   = 649;\\n    static final int        DATABASE_NAME              = 650;\\n    static final int        DATABASE_TIMEZONE          = 651;\\n    static final int        DATABASE_VERSION           = 652;\\n    static final int        DATEADD                    = 653;\\n    static final int        DATEDIFF                   = 654;\\n    public static final int DAY_NAME                   = 655;\\n    public static final int DAY_OF_MONTH               = 656;\\n    public static final int DAY_OF_WEEK                = 657;\\n    public static final int DAY_OF_YEAR                = 658;\\n    static final int        DAYNAME                    = 659;\\n    static final int        DAYOFMONTH                 = 660;\\n    static final int        DAYOFWEEK                  = 661;\\n    static final int        DAYOFYEAR                  = 662;\\n    static final int        DECODE                     = 663;\\n    static final int        DEGREES                    = 664;\\n    static final int        DIFFERENCE                 = 665;\\n    static final int        DMOD                       = 666;\\n    static final int        HEXTORAW                   = 667;\\n    static final int        GREATEST                   = 668;\\n    static final int        GROUP_CONCAT               = 669;\\n    static final int        IFNULL                     = 670;\\n    static final int        IS_AUTOCOMMIT              = 671;\\n    static final int        IS_READONLY_DATABASE       = 672;\\n    static final int        IS_READONLY_DATABASE_FILES = 673;\\n    static final int        IS_READONLY_SESSION        = 674;\\n    static final int        ISOLATION_LEVEL            = 675;\\n    static final int        ISNULL                     = 676;\\n    static final int        LCASE                      = 677;\\n    static final int        LEAST                      = 678;\\n    static final int        LOAD_FILE                  = 679;\\n    static final int        LOCATE                     = 680;\\n    static final int        LOB                        = 681;\\n    static final int        LOG                        = 682;\\n    static final int        LOG10                      = 683;\\n    static final int        LPAD                       = 684;\\n    static final int        LTRIM                      = 685;\\n    static final int        LOB_ID                     = 686;\\n    public static final int MONTH_NAME                 = 687;\\n    static final int        MONTHNAME                  = 688;\\n    static final int        MVCC                       = 689;\\n    static final int        MVLOCKS                    = 690;\\n    static final int        NIO                        = 691;\\n    static final int        NOW                        = 692;\\n    static final int        OCTETLENGTH                = 693;\\n    static final int        PI                         = 694;\\n    public static final int QUARTER                    = 695;\\n    static final int        RADIANS                    = 696;\\n    static final int        RAND                       = 697;\\n    static final int        RAWTOHEX                   = 698;\\n    static final int        REGEXP_MATCHES             = 699;\\n    static final int        REPLACE                    = 700;\\n    static final int        REVERSE                    = 701;\\n    static final int        ROUND                      = 702;\\n    static final int        ROUNDMAGIC                 = 703;\\n    static final int        RTRIM                      = 704;\\n    static final int        RPAD                       = 705;\\n    public static final int SECONDS_MIDNIGHT           = 706;\\n    static final int        SEQUENCE_ARRAY             = 707;\\n    static final int        SESSION_ID                 = 708;\\n    static final int        SESSION_ISOLATION_LEVEL    = 709;\\n    static final int        SESSION_TIMEZONE           = 710;\\n    static final int        SIGN                       = 711;\\n    static final int        SIN                        = 712;\\n    static final int        SOUNDEX                    = 713;\\n    static final int        SPACE_WORD                 = 714;\\n    static final int        SUBSTR                     = 715;\\n    static final int        SYSDATE                    = 716;\\n    static final int        TAN                        = 717;\\n    static final int        TIMESTAMPADD               = 718;\\n    static final int        TIMESTAMPDIFF              = 719;\\n    static final int        TIMEZONE                   = 720;\\n    static final int        TO_CHAR                    = 721;\\n    static final int        TO_DATE                    = 722;\\n    static final int        TO_TIMESTAMP               = 723;\\n    static final int        TODAY                      = 724;\\n    static final int        TOP                        = 725;\\n    static final int        TRANSACTION_CONTROL        = 726;\\n    static final int        TRANSACTION_ID             = 727;\\n    static final int        TRANSACTION_SIZE           = 728;\\n    static final int        TRUNC                      = 729;\\n    static final int        UCASE                      = 730;\\n    static final int        UNIX_TIMESTAMP             = 731;\\n    static final int        UUID                       = 732;\\n    static final int        WEEK                       = 733;\\n    public static final int WEEK_OF_YEAR               = 734;\\n        static final int        ASTERISK         = 771;\\n    static final int        CLOSEBRACKET     = 772;\\n    static final int        COLON            = 773;\\n    static final int        COMMA            = 774;\\n    static final int        CONCAT           = 775;\\n    static final int        DIVIDE           = 776;\\n    static final int        DOUBLE_COLON_OP  = 777;\\n    static final int        DOUBLE_PERIOD_OP = 778;\\n    static final int        GREATER          = 779;\\n    static final int        GREATER_EQUALS   = 780;\\n    static final int        LEFTBRACKET      = 781;\\n    static final int        LESS             = 782;\\n    static final int        LESS_EQUALS      = 783;\\n    public static final int MINUS            = 784;\\n    static final int        NOT_EQUALS       = 785;\\n    static final int        OPENBRACKET      = 786;\\n    static final int        PLUS             = 787;\\n    static final int        QUESTION         = 788;\\n    static final int        RIGHT_ARROW_OP   = 789;\\n    static final int        RIGHTBRACKET     = 790;\\n    static final int        SEMICOLON        = 791;\\n        public static final int SQL_BIGINT        = 801;\\n    public static final int SQL_BINARY        = 802;\\n    public static final int SQL_BIT           = 803;\\n    public static final int SQL_BLOB          = 804;\\n    public static final int SQL_BOOLEAN       = 805;\\n    public static final int SQL_CHAR          = 806;\\n    public static final int SQL_CLOB          = 807;\\n    public static final int SQL_DATE          = 808;\\n    public static final int SQL_DECIMAL       = 809;\\n    public static final int SQL_DATALINK      = 810;\\n    public static final int SQL_DOUBLE        = 811;\\n    public static final int SQL_FLOAT         = 812;\\n    public static final int SQL_INTEGER       = 813;\\n    public static final int SQL_LONGVARBINARY = 814;\\n    public static final int SQL_LONGNVARCHAR  = 815;\\n    public static final int SQL_LONGVARCHAR   = 816;\\n    public static final int SQL_NCHAR         = 817;\\n    public static final int SQL_NCLOB         = 818;\\n    public static final int SQL_NUMERIC       = 819;\\n    public static final int SQL_NVARCHAR      = 820;\\n    public static final int SQL_REAL          = 821;\\n    public static final int SQL_ROWID         = 822;\\n    public static final int SQL_SQLXML        = 823;\\n    public static final int SQL_SMALLINT      = 824;\\n    public static final int SQL_TIME          = 825;\\n    public static final int SQL_TIMESTAMP     = 826;\\n    public static final int SQL_TINYINT       = 827;\\n    public static final int SQL_VARBINARY     = 828;\\n    public static final int SQL_VARCHAR       = 829;\\n        static final int SQL_TSI_FRAC_SECOND  = 831;\\n    static final int SQL_TSI_MILLI_SECOND = 832;\\n    static final int SQL_TSI_SECOND       = 833;\\n    static final int SQL_TSI_MINUTE       = 834;\\n    static final int SQL_TSI_HOUR         = 835;\\n    static final int SQL_TSI_DAY          = 836;\\n    static final int SQL_TSI_WEEK         = 837;\\n    static final int SQL_TSI_MONTH        = 838;\\n    static final int SQL_TSI_QUARTER      = 839;\\n    static final int SQL_TSI_YEAR         = 840;\\n        static final int X_KEYSET      = 841;\\n    static final int X_OPTION      = 842;\\n    static final int X_REPEAT      = 843;\\n    static final int X_POS_INTEGER = 844;\\n        public static final int X_VALUE                    = 845;\\n    public static final int X_IDENTIFIER               = 846;\\n    public static final int X_DELIMITED_IDENTIFIER     = 847;\\n    public static final int X_ENDPARSE                 = 848;\\n    public static final int X_STARTPARSE               = 849;\\n    public static final int X_REMARK                   = 850;\\n    public static final int X_NULL                     = 851;\\n    public static final int X_LOB_SIZE                 = 852;\\n    public static final int X_MALFORMED_STRING         = 853;\\n    public static final int X_MALFORMED_NUMERIC        = 854;\\n    public static final int X_MALFORMED_BIT_STRING     = 855;\\n    public static final int X_MALFORMED_BINARY_STRING  = 856;\\n    public static final int X_MALFORMED_UNICODE_STRING = 857;\\n    public static final int X_MALFORMED_COMMENT        = 858;\\n    public static final int X_MALFORMED_IDENTIFIER     = 859;\\n    public static final int X_MALFORMED_UNICODE_ESCAPE = 860;\\n        public static final int X_UNKNOWN_TOKEN = -1;\\n    private static final IntValueHashMap reservedKeys =\\n        new IntValueHashMap(351);\\n    static {\\n        reservedKeys.put(Tokens.T_ABS, ABS);\\n        reservedKeys.put(Tokens.T_AGGREGATE, AGGREGATE);\\n        reservedKeys.put(Tokens.T_ALL, ALL);\\n        reservedKeys.put(Tokens.T_ALLOCATE, ALLOCATE);\\n        reservedKeys.put(Tokens.T_ALTER, ALTER);\\n        reservedKeys.put(Tokens.T_AND, AND);\\n        reservedKeys.put(Tokens.T_ANY, ANY);\\n        reservedKeys.put(Tokens.T_ARE, ARE);\\n        reservedKeys.put(Tokens.T_ARRAY, ARRAY);\\n        reservedKeys.put(Tokens.T_ARRAY_AGG, ARRAY_AGG);\\n        reservedKeys.put(Tokens.T_AS, AS);\\n        reservedKeys.put(Tokens.T_ASENSITIVE, ASENSITIVE);\\n        reservedKeys.put(Tokens.T_ASYMMETRIC, ASYMMETRIC);\\n        reservedKeys.put(Tokens.T_AT, AT);\\n        reservedKeys.put(Tokens.T_ATOMIC, ATOMIC);\\n        reservedKeys.put(Tokens.T_AUTHORIZATION, AUTHORIZATION);\\n        reservedKeys.put(Tokens.T_AVG, AVG);\\n        reservedKeys.put(Tokens.T_BEGIN, BEGIN);\\n        reservedKeys.put(Tokens.T_BETWEEN, BETWEEN);\\n        reservedKeys.put(Tokens.T_BIGINT, BIGINT);\\n        reservedKeys.put(Tokens.T_BINARY, BINARY);\\n        reservedKeys.put(Tokens.T_BIT_LENGTH, BIT_LENGTH);\\n        reservedKeys.put(Tokens.T_BLOB, BLOB);\\n        reservedKeys.put(Tokens.T_BOOLEAN, BOOLEAN);\\n        reservedKeys.put(Tokens.T_BOTH, BOTH);\\n        reservedKeys.put(Tokens.T_BY, BY);\\n        reservedKeys.put(Tokens.T_CALL, CALL);\\n        reservedKeys.put(Tokens.T_CALLED, CALLED);\\n        reservedKeys.put(Tokens.T_CARDINALITY, CARDINALITY);\\n        reservedKeys.put(Tokens.T_CASCADED, CASCADED);\\n        reservedKeys.put(Tokens.T_CASE, CASE);\\n        reservedKeys.put(Tokens.T_CAST, CAST);\\n        reservedKeys.put(Tokens.T_CEIL, CEIL);\\n        reservedKeys.put(Tokens.T_CEILING, CEILING);\\n        reservedKeys.put(Tokens.T_CHAR, CHAR);\\n        reservedKeys.put(Tokens.T_CHAR_LENGTH, CHAR_LENGTH);\\n        reservedKeys.put(Tokens.T_CHARACTER, CHARACTER);\\n        reservedKeys.put(Tokens.T_CHARACTER_LENGTH, CHARACTER_LENGTH);\\n        reservedKeys.put(Tokens.T_CHECK, CHECK);\\n        reservedKeys.put(Tokens.T_CLOB, CLOB);\\n        reservedKeys.put(Tokens.T_CLOSE, CLOSE);\\n        reservedKeys.put(Tokens.T_COALESCE, COALESCE);\\n        reservedKeys.put(Tokens.T_COLLATE, COLLATE);\\n        reservedKeys.put(Tokens.T_COLLECT, COLLECT);\\n        reservedKeys.put(Tokens.T_COLUMN, COLUMN);\\n        reservedKeys.put(Tokens.T_COMMIT, COMMIT);\\n        reservedKeys.put(Tokens.T_COMPARABLE, COMPARABLE);\\n        reservedKeys.put(Tokens.T_CONDITION, CONDITION);\\n        reservedKeys.put(Tokens.T_CONNECT, CONNECT);\\n        reservedKeys.put(Tokens.T_CONSTRAINT, CONSTRAINT);\\n        reservedKeys.put(Tokens.T_CONVERT, CONVERT);\\n        reservedKeys.put(Tokens.T_CORR, CORR);\\n        reservedKeys.put(Tokens.T_CORRESPONDING, CORRESPONDING);\\n        reservedKeys.put(Tokens.T_COUNT, COUNT);\\n        reservedKeys.put(Tokens.T_COVAR_POP, COVAR_POP);\\n        reservedKeys.put(Tokens.T_COVAR_SAMP, COVAR_SAMP);\\n        reservedKeys.put(Tokens.T_CREATE, CREATE);\\n        reservedKeys.put(Tokens.T_CROSS, CROSS);\\n        reservedKeys.put(Tokens.T_CUBE, CUBE);\\n        reservedKeys.put(Tokens.T_CUME_DIST, CUME_DIST);\\n        reservedKeys.put(Tokens.T_CURRENT, CURRENT);\\n        reservedKeys.put(Tokens.T_CURRENT_CATALOG, CURRENT_CATALOG);\\n        reservedKeys.put(Tokens.T_CURRENT_DATE, CURRENT_DATE);\\n        reservedKeys.put(Tokens.T_CURRENT_DEFAULT_TRANSFORM_GROUP,\\n                         CURRENT_DEFAULT_TRANSFORM_GROUP);\\n        reservedKeys.put(Tokens.T_CURRENT_PATH, CURRENT_PATH);\\n        reservedKeys.put(Tokens.T_CURRENT_ROLE, CURRENT_ROLE);\\n        reservedKeys.put(Tokens.T_CURRENT_SCHEMA, CURRENT_SCHEMA);\\n        reservedKeys.put(Tokens.T_CURRENT_TIME, CURRENT_TIME);\\n        reservedKeys.put(Tokens.T_CURRENT_TIMESTAMP, CURRENT_TIMESTAMP);\\n        reservedKeys.put(Tokens.T_DO, DO);\\n        reservedKeys.put(Tokens.T_CURRENT_TRANSFORM_GROUP_FOR_TYPE,\\n                         CURRENT_TRANSFORM_GROUP_FOR_TYPE);\\n        reservedKeys.put(Tokens.T_CURRENT_USER, CURRENT_USER);\\n        reservedKeys.put(Tokens.T_CURSOR, CURSOR);\\n        reservedKeys.put(Tokens.T_CYCLE, CYCLE);\\n        reservedKeys.put(Tokens.T_DATE, DATE);\\n        reservedKeys.put(Tokens.T_DAY, DAY);\\n        reservedKeys.put(Tokens.T_DEALLOCATE, DEALLOCATE);\\n        reservedKeys.put(Tokens.T_DEC, DEC);\\n        reservedKeys.put(Tokens.T_DECIMAL, DECIMAL);\\n        reservedKeys.put(Tokens.T_DECLARE, DECLARE);\\n        reservedKeys.put(Tokens.T_DEFAULT, DEFAULT);\\n        reservedKeys.put(Tokens.T_DELETE, DELETE);\\n        reservedKeys.put(Tokens.T_DENSE_RANK, DENSE_RANK);\\n        reservedKeys.put(Tokens.T_DEREF, DEREF);\\n        reservedKeys.put(Tokens.T_DESCRIBE, DESCRIBE);\\n        reservedKeys.put(Tokens.T_DETERMINISTIC, DETERMINISTIC);\\n        reservedKeys.put(Tokens.T_DISCONNECT, DISCONNECT);\\n        reservedKeys.put(Tokens.T_DISTINCT, DISTINCT);\\n        reservedKeys.put(Tokens.T_DOUBLE, DOUBLE);\\n        reservedKeys.put(Tokens.T_DROP, DROP);\\n        reservedKeys.put(Tokens.T_DYNAMIC, DYNAMIC);\\n        reservedKeys.put(Tokens.T_EACH, EACH);\\n        reservedKeys.put(Tokens.T_ELEMENT, ELEMENT);\\n        reservedKeys.put(Tokens.T_ELSE, ELSE);\\n        reservedKeys.put(Tokens.T_ELSEIF, ELSEIF);\\n        reservedKeys.put(Tokens.T_END, END);\\n        reservedKeys.put(Tokens.T_END_EXEC, END_EXEC);\\n        reservedKeys.put(Tokens.T_ESCAPE, ESCAPE);\\n        reservedKeys.put(Tokens.T_EVERY, EVERY);\\n        reservedKeys.put(Tokens.T_EXCEPT, EXCEPT);\\n        reservedKeys.put(Tokens.T_EXEC, EXEC);\\n        reservedKeys.put(Tokens.T_EXECUTE, EXECUTE);\\n        reservedKeys.put(Tokens.T_EXISTS, EXISTS);\\n        reservedKeys.put(Tokens.T_EXIT, EXIT);\\n        reservedKeys.put(Tokens.T_EXP, EXP);\\n        reservedKeys.put(Tokens.T_EXTERNAL, EXTERNAL);\\n        reservedKeys.put(Tokens.T_EXTRACT, EXTRACT);\\n        reservedKeys.put(Tokens.T_FALSE, FALSE);\\n        reservedKeys.put(Tokens.T_FETCH, FETCH);\\n        reservedKeys.put(Tokens.T_FILTER, FILTER);\\n        reservedKeys.put(Tokens.T_FIRST_VALUE, FIRST_VALUE);\\n        reservedKeys.put(Tokens.T_FLOAT, FLOAT);\\n        reservedKeys.put(Tokens.T_FLOOR, FLOOR);\\n        reservedKeys.put(Tokens.T_FOR, FOR);\\n        reservedKeys.put(Tokens.T_FOREIGN, FOREIGN);\\n        reservedKeys.put(Tokens.T_FREE, FREE);\\n        reservedKeys.put(Tokens.T_FROM, FROM);\\n        reservedKeys.put(Tokens.T_FULL, FULL);\\n        reservedKeys.put(Tokens.T_FUNCTION, FUNCTION);\\n        reservedKeys.put(Tokens.T_FUSION, FUSION);\\n        reservedKeys.put(Tokens.T_GET, GET);\\n        reservedKeys.put(Tokens.T_GLOBAL, GLOBAL);\\n        reservedKeys.put(Tokens.T_GRANT, GRANT);\\n        reservedKeys.put(Tokens.T_GROUP, GROUP);\\n        reservedKeys.put(Tokens.T_GROUPING, GROUPING);\\n        reservedKeys.put(Tokens.T_HANDLER, HANDLER);\\n        reservedKeys.put(Tokens.T_HAVING, HAVING);\\n        reservedKeys.put(Tokens.T_HOLD, HOLD);\\n        reservedKeys.put(Tokens.T_HOUR, HOUR);\\n        reservedKeys.put(Tokens.T_IDENTITY, IDENTITY);\\n        reservedKeys.put(Tokens.T_IF, IF);\\n        reservedKeys.put(Tokens.T_IMPORT, IMPORT);\\n        reservedKeys.put(Tokens.T_IN, IN);\\n        reservedKeys.put(Tokens.T_INDICATOR, INDICATOR);\\n        reservedKeys.put(Tokens.T_INNER, INNER);\\n        reservedKeys.put(Tokens.T_INOUT, INOUT);\\n        reservedKeys.put(Tokens.T_INSENSITIVE, INSENSITIVE);\\n        reservedKeys.put(Tokens.T_INSERT, INSERT);\\n        reservedKeys.put(Tokens.T_INT, INT);\\n        reservedKeys.put(Tokens.T_INTEGER, INTEGER);\\n        reservedKeys.put(Tokens.T_INTERSECT, INTERSECT);\\n        reservedKeys.put(Tokens.T_INTERSECTION, INTERSECTION);\\n        reservedKeys.put(Tokens.T_INTERVAL, INTERVAL);\\n        reservedKeys.put(Tokens.T_INTO, INTO);\\n        reservedKeys.put(Tokens.T_IS, IS);\\n        reservedKeys.put(Tokens.T_ITERATE, ITERATE);\\n        reservedKeys.put(Tokens.T_JOIN, JOIN);\\n        reservedKeys.put(Tokens.T_LAG, LAG);\\n        reservedKeys.put(Tokens.T_LANGUAGE, LANGUAGE);\\n        reservedKeys.put(Tokens.T_LARGE, LARGE);\\n        reservedKeys.put(Tokens.T_LAST_VALUE, LAST_VALUE);\\n        reservedKeys.put(Tokens.T_LATERAL, LATERAL);\\n        reservedKeys.put(Tokens.T_LEAD, LEAD);\\n        reservedKeys.put(Tokens.T_LEADING, LEADING);\\n        reservedKeys.put(Tokens.T_LEAVE, LEAVE);\\n        reservedKeys.put(Tokens.T_LEFT, LEFT);\\n        reservedKeys.put(Tokens.T_LIKE, LIKE);\\n        reservedKeys.put(Tokens.T_LIKE_REGX, LIKE_REGEX);\\n        reservedKeys.put(Tokens.T_LN, LN);\\n        reservedKeys.put(Tokens.T_LOCAL, LOCAL);\\n        reservedKeys.put(Tokens.T_LOCALTIME, LOCALTIME);\\n        reservedKeys.put(Tokens.T_LOCALTIMESTAMP, LOCALTIMESTAMP);\\n        reservedKeys.put(Tokens.T_LOOP, LOOP);\\n        reservedKeys.put(Tokens.T_LOWER, LOWER);\\n        reservedKeys.put(Tokens.T_MATCH, MATCH);\\n        reservedKeys.put(Tokens.T_MAX, MAX);\\n        reservedKeys.put(Tokens.T_MAX_CARDINALITY, MAX_CARDINALITY);\\n        reservedKeys.put(Tokens.T_MEMBER, MEMBER);\\n        reservedKeys.put(Tokens.T_MERGE, MERGE);\\n        reservedKeys.put(Tokens.T_METHOD, METHOD);\\n        reservedKeys.put(Tokens.T_MIN, MIN);\\n        reservedKeys.put(Tokens.T_MINUTE, MINUTE);\\n        reservedKeys.put(Tokens.T_MOD, MOD);\\n        reservedKeys.put(Tokens.T_MODIFIES, MODIFIES);\\n        reservedKeys.put(Tokens.T_MODULE, MODULE);\\n        reservedKeys.put(Tokens.T_MONTH, MONTH);\\n        reservedKeys.put(Tokens.T_MULTISET, MULTISET);\\n        reservedKeys.put(Tokens.T_NATIONAL, NATIONAL);\\n        reservedKeys.put(Tokens.T_NATURAL, NATURAL);\\n        reservedKeys.put(Tokens.T_NCHAR, NCHAR);\\n        reservedKeys.put(Tokens.T_NCLOB, NCLOB);\\n        reservedKeys.put(Tokens.T_NEW, NEW);\\n        reservedKeys.put(Tokens.T_NO, NO);\\n        reservedKeys.put(Tokens.T_NONE, NONE);\\n        reservedKeys.put(Tokens.T_NORMALIZE, NORMALIZE);\\n        reservedKeys.put(Tokens.T_NOT, NOT);\\n        reservedKeys.put(Tokens.T_NTH_VALUE, NTH_VALUE);\\n        reservedKeys.put(Tokens.T_NTILE, NTILE);\\n        reservedKeys.put(Tokens.T_NULL, NULL);\\n        reservedKeys.put(Tokens.T_NULLIF, NULLIF);\\n        reservedKeys.put(Tokens.T_NUMERIC, NUMERIC);\\n        reservedKeys.put(Tokens.T_OCCURRENCES_REGEX, OCCURRENCES_REGEX);\\n        reservedKeys.put(Tokens.T_OCTET_LENGTH, OCTET_LENGTH);\\n        reservedKeys.put(Tokens.T_OF, OF);\\n        reservedKeys.put(Tokens.T_OFFSET, OFFSET);\\n        reservedKeys.put(Tokens.T_OLD, OLD);\\n        reservedKeys.put(Tokens.T_ON, ON);\\n        reservedKeys.put(Tokens.T_ONLY, ONLY);\\n        reservedKeys.put(Tokens.T_OPEN, OPEN);\\n        reservedKeys.put(Tokens.T_OR, OR);\\n        reservedKeys.put(Tokens.T_ORDER, ORDER);\\n        reservedKeys.put(Tokens.T_OUT, OUT);\\n        reservedKeys.put(Tokens.T_OUTER, OUTER);\\n        reservedKeys.put(Tokens.T_OVER, OVER);\\n        reservedKeys.put(Tokens.T_OVERLAPS, OVERLAPS);\\n        reservedKeys.put(Tokens.T_OVERLAY, OVERLAY);\\n        reservedKeys.put(Tokens.T_PARAMETER, PARAMETER);\\n        reservedKeys.put(Tokens.T_PARTITION, PARTITION);\\n        reservedKeys.put(Tokens.T_PERCENT_RANK, PERCENT_RANK);\\n        reservedKeys.put(Tokens.T_PERCENTILE_CONT, PERCENTILE_CONT);\\n        reservedKeys.put(Tokens.T_PERCENTILE_DISC, PERCENTILE_DISC);\\n        reservedKeys.put(Tokens.T_POSITION, POSITION);\\n        reservedKeys.put(Tokens.T_POSITION_REGEX, POSITION_REGEX);\\n        reservedKeys.put(Tokens.T_POWER, POWER);\\n        reservedKeys.put(Tokens.T_PRECISION, PRECISION);\\n        reservedKeys.put(Tokens.T_PREPARE, PREPARE);\\n        reservedKeys.put(Tokens.T_PRIMARY, PRIMARY);\\n        reservedKeys.put(Tokens.T_PROCEDURE, PROCEDURE);\\n        reservedKeys.put(Tokens.T_RANGE, RANGE);\\n        reservedKeys.put(Tokens.T_RANK, RANK);\\n        reservedKeys.put(Tokens.T_READS, READS);\\n        reservedKeys.put(Tokens.T_REAL, REAL);\\n        reservedKeys.put(Tokens.T_RECURSIVE, RECURSIVE);\\n        reservedKeys.put(Tokens.T_REF, REF);\\n        reservedKeys.put(Tokens.T_REFERENCES, REFERENCES);\\n        reservedKeys.put(Tokens.T_REFERENCING, REFERENCING);\\n        reservedKeys.put(Tokens.T_REGR_AVGX, REGR_AVGX);\\n        reservedKeys.put(Tokens.T_REGR_AVGY, REGR_AVGY);\\n        reservedKeys.put(Tokens.T_REGR_COUNT, REGR_COUNT);\\n        reservedKeys.put(Tokens.T_REGR_INTERCEPT, REGR_INTERCEPT);\\n        reservedKeys.put(Tokens.T_REGR_R2, REGR_R2);\\n        reservedKeys.put(Tokens.T_REGR_SLOPE, REGR_SLOPE);\\n        reservedKeys.put(Tokens.T_REGR_SXX, REGR_SXX);\\n        reservedKeys.put(Tokens.T_REGR_SXY, REGR_SXY);\\n        reservedKeys.put(Tokens.T_REGR_SYY, REGR_SYY);\\n        reservedKeys.put(Tokens.T_RELEASE, RELEASE);\\n        reservedKeys.put(Tokens.T_REPEAT, REPEAT);\\n        reservedKeys.put(Tokens.T_RESIGNAL, RESIGNAL);\\n        reservedKeys.put(Tokens.T_RETURN, RETURN);\\n        reservedKeys.put(Tokens.T_RETURNS, RETURNS);\\n        reservedKeys.put(Tokens.T_REVOKE, REVOKE);\\n        reservedKeys.put(Tokens.T_RIGHT, RIGHT);\\n        reservedKeys.put(Tokens.T_ROLLBACK, ROLLBACK);\\n        reservedKeys.put(Tokens.T_ROLLUP, ROLLUP);\\n        reservedKeys.put(Tokens.T_ROW, ROW);\\n        reservedKeys.put(Tokens.T_ROW_NUMBER, ROW_NUMBER);\\n        reservedKeys.put(Tokens.T_ROWS, ROWS);\\n        reservedKeys.put(Tokens.T_SAVEPOINT, SAVEPOINT);\\n        reservedKeys.put(Tokens.T_SCOPE, SCOPE);\\n        reservedKeys.put(Tokens.T_SCROLL, SCROLL);\\n        reservedKeys.put(Tokens.T_SEARCH, SEARCH);\\n        reservedKeys.put(Tokens.T_SECOND, SECOND);\\n        reservedKeys.put(Tokens.T_SELECT, SELECT);\\n        reservedKeys.put(Tokens.T_SENSITIVE, SENSITIVE);\\n        reservedKeys.put(Tokens.T_SESSION_USER, SESSION_USER);\\n        reservedKeys.put(Tokens.T_SET, SET);\\n        reservedKeys.put(Tokens.T_SIGNAL, SIGNAL);\\n        reservedKeys.put(Tokens.T_SIMILAR, SIMILAR);\\n        reservedKeys.put(Tokens.T_SMALLINT, SMALLINT);\\n        reservedKeys.put(Tokens.T_SOME, SOME);\\n        reservedKeys.put(Tokens.T_SPECIFIC, SPECIFIC);\\n        reservedKeys.put(Tokens.T_SPECIFICTYPE, SPECIFICTYPE);\\n        reservedKeys.put(Tokens.T_SQL, SQL);\\n        reservedKeys.put(Tokens.T_SQLEXCEPTION, SQLEXCEPTION);\\n        reservedKeys.put(Tokens.T_SQLSTATE, SQLSTATE);\\n        reservedKeys.put(Tokens.T_SQLWARNING, SQLWARNING);\\n        reservedKeys.put(Tokens.T_SQRT, SQRT);\\n        reservedKeys.put(Tokens.T_STACKED, STACKED);\\n        reservedKeys.put(Tokens.T_START, START);\\n        reservedKeys.put(Tokens.T_STATIC, STATIC);\\n        reservedKeys.put(Tokens.T_STDDEV_POP, STDDEV_POP);\\n        reservedKeys.put(Tokens.T_STDDEV_SAMP, STDDEV_SAMP);\\n        reservedKeys.put(Tokens.T_SUBMULTISET, SUBMULTISET);\\n        reservedKeys.put(Tokens.T_SUBSTRING, SUBSTRING);\\n        reservedKeys.put(Tokens.T_SUBSTRING_REGEX, SUBSTRING_REGEX);\\n        reservedKeys.put(Tokens.T_SUM, SUM);\\n        reservedKeys.put(Tokens.T_SYMMETRIC, SYMMETRIC);\\n        reservedKeys.put(Tokens.T_SYSTEM, SYSTEM);\\n        reservedKeys.put(Tokens.T_SYSTEM_USER, SYSTEM_USER);\\n        reservedKeys.put(Tokens.T_TABLE, TABLE);\\n        reservedKeys.put(Tokens.T_TABLESAMPLE, TABLESAMPLE);\\n        reservedKeys.put(Tokens.T_THEN, THEN);\\n        reservedKeys.put(Tokens.T_TIME, TIME);\\n        reservedKeys.put(Tokens.T_TIMESTAMP, TIMESTAMP);\\n        reservedKeys.put(Tokens.T_TIMEZONE_HOUR, TIMEZONE_HOUR);\\n        reservedKeys.put(Tokens.T_TIMEZONE_MINUTE, TIMEZONE_MINUTE);\\n        reservedKeys.put(Tokens.T_TO, TO);\\n        reservedKeys.put(Tokens.T_TRAILING, TRAILING);\\n        reservedKeys.put(Tokens.T_TRANSLATE, TRANSLATE);\\n        reservedKeys.put(Tokens.T_TRANSLATE_REGEX, TRANSLATE_REGEX);\\n        reservedKeys.put(Tokens.T_TRANSLATION, TRANSLATION);\\n        reservedKeys.put(Tokens.T_TREAT, TREAT);\\n        reservedKeys.put(Tokens.T_TRIGGER, TRIGGER);\\n        reservedKeys.put(Tokens.T_TRIM, TRIM);\\n        reservedKeys.put(Tokens.T_TRIM_ARRAY, TRIM_ARRAY);\\n        reservedKeys.put(Tokens.T_TRUE, TRUE);\\n        reservedKeys.put(Tokens.T_TRUNCATE, TRUNCATE);\\n        reservedKeys.put(Tokens.T_UESCAPE, UESCAPE);\\n        reservedKeys.put(Tokens.T_UNDO, UNDO);\\n        reservedKeys.put(Tokens.T_UNION, UNION);\\n        reservedKeys.put(Tokens.T_UNIQUE, UNIQUE);\\n        reservedKeys.put(Tokens.T_UNKNOWN, UNKNOWN);\\n        reservedKeys.put(Tokens.T_UNNEST, UNNEST);\\n        reservedKeys.put(Tokens.T_UNTIL, UNTIL);\\n        reservedKeys.put(Tokens.T_UPDATE, UPDATE);\\n        reservedKeys.put(Tokens.T_UPPER, UPPER);\\n        reservedKeys.put(Tokens.T_USER, USER);\\n        reservedKeys.put(Tokens.T_USING, USING);\\n        reservedKeys.put(Tokens.T_VALUE, VALUE);\\n        reservedKeys.put(Tokens.T_VALUES, VALUES);\\n        reservedKeys.put(Tokens.T_VAR_POP, VAR_POP);\\n        reservedKeys.put(Tokens.T_VAR_SAMP, VAR_SAMP);\\n        reservedKeys.put(Tokens.T_VARBINARY, VARBINARY);\\n        reservedKeys.put(Tokens.T_VARCHAR, VARCHAR);\\n        reservedKeys.put(Tokens.T_VARYING, VARYING);\\n        reservedKeys.put(Tokens.T_WHEN, WHEN);\\n        reservedKeys.put(Tokens.T_WHENEVER, WHENEVER);\\n        reservedKeys.put(Tokens.T_WHERE, WHERE);\\n        reservedKeys.put(Tokens.T_WIDTH_BUCKET, WIDTH_BUCKET);\\n        reservedKeys.put(Tokens.T_WINDOW, WINDOW);\\n        reservedKeys.put(Tokens.T_WITH, WITH);\\n        reservedKeys.put(Tokens.T_WITHIN, WITHIN);\\n        reservedKeys.put(Tokens.T_WITHOUT, WITHOUT);\\n        reservedKeys.put(Tokens.T_WHILE, WHILE);\\n        reservedKeys.put(Tokens.T_YEAR, YEAR);\\n    }\\n    private static final IntValueHashMap commandSet = new IntValueHashMap(299);\\n    static {\\n        commandSet.put(T_ACTION, ACTION);\\n        commandSet.put(T_ADD, ADD);\\n        commandSet.put(T_ADMIN, ADMIN);\\n        commandSet.put(T_AFTER, AFTER);\\n        commandSet.put(T_ALIAS, ALIAS);\\n        commandSet.put(T_ALWAYS, ALWAYS);\\n        commandSet.put(T_ASC, ASC);\\n        commandSet.put(T_AUTHENTICATION, AUTHENTICATION);\\n        commandSet.put(T_AUTOCOMMIT, AUTOCOMMIT);\\n        commandSet.put(T_BACKUP, BACKUP);\\n        commandSet.put(T_BEFORE, BEFORE);\\n        commandSet.put(T_BINARY_DOUBLE, BINARY_DOUBLE);\\n        commandSet.put(T_BINARY_FLOAT, BINARY_FLOAT);\\n        commandSet.put(T_BIT, BIT);\\n        commandSet.put(T_BYTE, BYTE);\\n        commandSet.put(T_BLOCKING, BLOCKING);\\n        commandSet.put(T_BODY, BODY);\\n        commandSet.put(T_CACHE, CACHE);\\n        commandSet.put(T_CACHED, CACHED);\\n        commandSet.put(T_CASCADE, CASCADE);\\n        commandSet.put(T_CATALOG, CATALOG);\\n        commandSet.put(T_CHARACTERISTICS, CHARACTERISTICS);\\n        commandSet.put(T_CHARACTERS, CHARACTERS);\\n        commandSet.put(T_CHECKPOINT, CHECKPOINT);\\n        commandSet.put(T_CRYPT_KEY, CRYPT_KEY);\\n        commandSet.put(T_CLASS, CLASS);\\n        commandSet.put(T_CLUSTERED, CLUSTERED);\\n        commandSet.put(T_COLLATE, COLLATE);\\n        commandSet.put(T_COLLATION, COLLATION);\\n        commandSet.put(T_COMMENT, COMMENT);\\n        commandSet.put(T_COMMITTED, COMMITTED);\\n        commandSet.put(T_COMPACT, COMPACT);\\n        commandSet.put(T_COMPRESSED, COMPRESSED);\\n        commandSet.put(T_CONDITION_IDENTIFIER, Tokens.CONDITION_IDENTIFIER);\\n        commandSet.put(T_CONTAINS, CONTAINS);\\n        commandSet.put(T_CONTINUE, CONTINUE);\\n        commandSet.put(T_CONTROL, CONTROL);\\n        commandSet.put(T_CURDATE, CURDATE);\\n        commandSet.put(T_CURRVAL, CURRVAL);\\n        commandSet.put(T_CURTIME, CURTIME);\\n        commandSet.put(T_DATA, DATA);\\n        commandSet.put(T_DATABASE, DATABASE);\\n        commandSet.put(T_DEADLOCK, DEADLOCK);\\n        commandSet.put(T_DEFAULTS, DEFAULTS);\\n        commandSet.put(T_DEFRAG, DEFRAG);\\n        commandSet.put(T_DELAY, DELAY);\\n        commandSet.put(T_DESC, DESC);\\n        commandSet.put(T_DIGEST, DIGEST);\\n        commandSet.put(T_DOMAIN, DOMAIN);\\n        commandSet.put(T_EVENT, EVENT);\\n        commandSet.put(T_EXCLUDING, EXCLUDING);\\n        commandSet.put(T_EXPLAIN, EXPLAIN);\\n        commandSet.put(T_FILE, FILE);\\n        commandSet.put(T_FILES, FILES);\\n        commandSet.put(T_FINAL, FINAL);\\n        commandSet.put(T_FIRST, FIRST);\\n        commandSet.put(T_FORMAT, FORMAT);\\n        commandSet.put(T_G_FACTOR, G);\\n        commandSet.put(T_GC, GC);\\n        commandSet.put(T_GENERATED, GENERATED);\\n        commandSet.put(T_GRANTED, GRANTED);\\n        commandSet.put(T_GROUP_CONCAT, GROUP_CONCAT);\\n        commandSet.put(T_HEADER, HEADER);\\n        commandSet.put(T_IF, Tokens.IF);\\n        commandSet.put(T_IGNORECASE, IGNORECASE);\\n        commandSet.put(T_IMMEDIATELY, IMMEDIATELY);\\n        commandSet.put(T_INCLUDING, INCLUDING);\\n        commandSet.put(T_INCREMENT, INCREMENT);\\n        commandSet.put(T_INDEX, INDEX);\\n        commandSet.put(T_INITIAL, INITIAL);\\n        commandSet.put(T_INPUT, INPUT);\\n        commandSet.put(T_INSTEAD, INSTEAD);\\n        commandSet.put(T_INTEGRITY, INTEGRITY);\\n        commandSet.put(T_IS_AUTOCOMMIT, IS_AUTOCOMMIT);\\n        commandSet.put(T_ISOLATION, ISOLATION);\\n        commandSet.put(T_IS_READONLY_DATABASE, IS_READONLY_DATABASE);\\n        commandSet.put(T_IS_READONLY_DATABASE_FILES,\\n                       IS_READONLY_DATABASE_FILES);\\n        commandSet.put(T_IS_READONLY_SESSION, IS_READONLY_SESSION);\\n        commandSet.put(T_JAVA, JAVA);\\n        commandSet.put(T_K_FACTOR, K);\\n        commandSet.put(T_KEY, KEY);\\n        commandSet.put(T_LAST, LAST);\\n        commandSet.put(T_LASTVAL, LASTVAL);\\n        commandSet.put(T_LENGTH, LENGTH);\\n        commandSet.put(T_LEVEL, LEVEL);\\n        commandSet.put(T_LIBRARY, LIBRARY);\\n        commandSet.put(T_LIMIT, LIMIT);\\n        commandSet.put(T_LOB, LOB);\\n        commandSet.put(T_LOCK, LOCK);\\n        commandSet.put(T_LOCKS, LOCKS);\\n        commandSet.put(T_LONG, LONG);\\n        commandSet.put(T_LONGVAR, LONGVAR);\\n        commandSet.put(T_M_FACTOR, M);\\n        commandSet.put(T_MATCHED, MATCHED);\\n        commandSet.put(T_MAXROWS, MAXROWS);\\n        commandSet.put(T_MAXVALUE, MAXVALUE);\\n        commandSet.put(T_MEDIAN, MEDIAN);\\n        commandSet.put(T_MEMORY, MEMORY);\\n        commandSet.put(T_MILLIS, MILLIS);\\n        commandSet.put(T_MINUS_EXCEPT, MINUS_EXCEPT);\\n        commandSet.put(T_MINVALUE, MINVALUE);\\n        commandSet.put(T_MVCC, MVCC);\\n        commandSet.put(T_MVLOCKS, MVLOCKS);\\n        commandSet.put(T_NAME, NAME);\\n        commandSet.put(T_NEXT, NEXT);\\n        commandSet.put(T_NEXTVAL, NEXTVAL);\\n        commandSet.put(T_NAN, NAN);\\n        commandSet.put(T_NIO, NIO);\\n        commandSet.put(T_NOW, NOW);\\n        commandSet.put(T_NULLS, NULLS);\\n        commandSet.put(T_NUMBER, NUMBER);\\n        commandSet.put(T_OCTETS, OCTETS);\\n        commandSet.put(T_OFF, OFF);\\n        commandSet.put(T_OPTION, OPTION);\\n        commandSet.put(T_ORDINALITY, ORDINALITY);\\n        commandSet.put(T_OVERRIDING, OVERRIDING);\\n        commandSet.put(T_P_FACTOR, P);\\n        commandSet.put(T_PARTIAL, PARTIAL);\\n        commandSet.put(T_PASSWORD, PASSWORD);\\n        commandSet.put(T_PLACING, PLACING);\\n        commandSet.put(T_PLAN, PLAN);\\n        commandSet.put(T_PRESERVE, PRESERVE);\\n        commandSet.put(T_PRIVILEGES, PRIVILEGES);\\n        commandSet.put(T_PROPERTY, PROPERTY);\\n        commandSet.put(T_RAW, RAW);\\n        commandSet.put(T_READ, READ);\\n        commandSet.put(T_READONLY, READONLY);\\n        commandSet.put(T_REFERENTIAL, REFERENTIAL);\\n        commandSet.put(T_RENAME, RENAME);\\n        commandSet.put(T_REPEATABLE, REPEATABLE);\\n        commandSet.put(T_RESET, RESET);\\n        commandSet.put(T_RESTART, RESTART);\\n        commandSet.put(T_RESTRICT, RESTRICT);\\n        commandSet.put(T_RESULT, RESULT);\\n        commandSet.put(T_ROLE, ROLE);\\n        commandSet.put(T_ROUTINE, ROUTINE);\\n        commandSet.put(T_SCALE, SCALE);\\n        commandSet.put(T_SCHEMA, SCHEMA);\\n        commandSet.put(T_SCRIPT, SCRIPT);\\n        commandSet.put(T_SEQUENCE, SEQUENCE);\\n        commandSet.put(T_SEPARATOR, SEPARATOR);\\n        commandSet.put(T_SERIALIZABLE, SERIALIZABLE);\\n        commandSet.put(T_SERVER, SERVER);\\n        commandSet.put(T_SESSION, SESSION);\\n        commandSet.put(T_SETS, SETS);\\n        commandSet.put(T_SHUTDOWN, SHUTDOWN);\\n        commandSet.put(T_SIMPLE, SIMPLE);\\n        commandSet.put(T_SIZE, SIZE);\\n        commandSet.put(T_SOURCE, SOURCE);\\n        commandSet.put(T_SQL_BIGINT, SQL_BIGINT);\\n        commandSet.put(T_SQL_BINARY, SQL_BINARY);\\n        commandSet.put(T_SQL_BIT, SQL_BIT);\\n        commandSet.put(T_SQL_BLOB, SQL_BLOB);\\n        commandSet.put(T_SQL_BOOLEAN, SQL_BOOLEAN);\\n        commandSet.put(T_SQL_CHAR, SQL_CHAR);\\n        commandSet.put(T_SQL_CLOB, SQL_CLOB);\\n        commandSet.put(T_SQL_DATALINK, SQL_DATALINK);\\n        commandSet.put(T_SQL_DATE, SQL_DATE);\\n        commandSet.put(T_SQL_DECIMAL, SQL_DECIMAL);\\n        commandSet.put(T_SQL_DOUBLE, SQL_DOUBLE);\\n        commandSet.put(T_SQL_FLOAT, SQL_FLOAT);\\n        commandSet.put(T_SQL_INTEGER, SQL_INTEGER);\\n        commandSet.put(T_SQL_LONGNVARCHAR, SQL_LONGNVARCHAR);\\n        commandSet.put(T_SQL_LONGVARBINARY, SQL_LONGVARBINARY);\\n        commandSet.put(T_SQL_LONGVARCHAR, SQL_LONGVARCHAR);\\n        commandSet.put(T_SQL_NCHAR, SQL_NCHAR);\\n        commandSet.put(T_SQL_NCLOB, SQL_NCLOB);\\n        commandSet.put(T_SQL_NUMERIC, SQL_NUMERIC);\\n        commandSet.put(T_SQL_NVARCHAR, SQL_NVARCHAR);\\n        commandSet.put(T_SQL_REAL, SQL_REAL);\\n        commandSet.put(T_SQL_ROWID, SQL_ROWID);\\n        commandSet.put(T_SQL_SMALLINT, SQL_SMALLINT);\\n        commandSet.put(T_SQL_SQLXML, SQL_SQLXML);\\n        commandSet.put(T_SQL_TIME, SQL_TIME);\\n        commandSet.put(T_SQL_TIMESTAMP, SQL_TIMESTAMP);\\n        commandSet.put(T_SQL_TINYINT, SQL_TINYINT);\\n        commandSet.put(T_SQL_VARBINARY, SQL_VARBINARY);\\n        commandSet.put(T_SQL_VARCHAR, SQL_VARCHAR);\\n        commandSet.put(T_SQL_TSI_DAY, SQL_TSI_DAY);\\n        commandSet.put(T_SQL_TSI_FRAC_SECOND, SQL_TSI_FRAC_SECOND);\\n        commandSet.put(T_SQL_TSI_MILLI_SECOND, SQL_TSI_MILLI_SECOND);\\n        commandSet.put(T_SQL_TSI_HOUR, SQL_TSI_HOUR);\\n        commandSet.put(T_SQL_TSI_MINUTE, SQL_TSI_MINUTE);\\n        commandSet.put(T_SQL_TSI_MONTH, SQL_TSI_MONTH);\\n        commandSet.put(T_SQL_TSI_QUARTER, SQL_TSI_QUARTER);\\n        commandSet.put(T_SQL_TSI_SECOND, SQL_TSI_SECOND);\\n        commandSet.put(T_SQL_TSI_WEEK, SQL_TSI_WEEK);\\n        commandSet.put(T_SQL_TSI_YEAR, SQL_TSI_YEAR);\\n        commandSet.put(T_STATEMENT, STATEMENT);\\n        commandSet.put(T_STYLE, STYLE);\\n        commandSet.put(T_SYNTAX, SYNTAX);\\n        commandSet.put(T_T_FACTOR, T);\\n        commandSet.put(T_TDC, TDC);\\n        commandSet.put(T_TEMP, TEMP);\\n        commandSet.put(T_TEMPORARY, TEMPORARY);\\n        commandSet.put(T_TEXT, TEXT);\\n        commandSet.put(T_TYPES, TYPES);\\n        commandSet.put(T_TIMESTAMPADD, TIMESTAMPADD);\\n        commandSet.put(T_TIMESTAMPDIFF, TIMESTAMPDIFF);\\n        commandSet.put(T_TOP, TOP);\\n        commandSet.put(T_TRANSACTION, TRANSACTION);\\n        commandSet.put(T_TTI, TTI);\\n        commandSet.put(T_TYPE, TYPE);\\n        commandSet.put(T_UNCOMMITTED, UNCOMMITTED);\\n        commandSet.put(T_USAGE, USAGE);\\n        commandSet.put(T_VIEW, VIEW);\\n        commandSet.put(T_VARCHAR2, VARCHAR2);\\n        commandSet.put(T_WORK, WORK);\\n        commandSet.put(T_WRAPPER, WRAPPER);\\n        commandSet.put(T_WRITE, WRITE);\\n        commandSet.put(T_WRITE_DELAY, WRITE_DELAY);\\n        commandSet.put(T_ZONE, ZONE);\\n                commandSet.put(T_ACOS, ACOS);\\n        commandSet.put(T_ACTION_ID, ACTION_ID);\\n        commandSet.put(T_ARRAY_SORT, ARRAY_SORT);\\n        commandSet.put(T_ASCII, ASCII);\\n        commandSet.put(T_ASIN, ASIN);\\n        commandSet.put(T_ATAN, ATAN);\\n        commandSet.put(T_ATAN2, ATAN2);\\n        commandSet.put(T_BITAND, BITAND);\\n        commandSet.put(T_BITLENGTH, BITLENGTH);\\n        commandSet.put(T_BITOR, BITOR);\\n        commandSet.put(T_BITXOR, BITXOR);\\n        commandSet.put(T_CASEWHEN, Tokens.CASEWHEN);\\n        commandSet.put(T_CONCAT_WORD, CONCAT_WORD);\\n        commandSet.put(T_CHR, CHR);\\n        commandSet.put(T_COS, COS);\\n        commandSet.put(T_COT, COT);\\n        commandSet.put(T_DATABASE_NAME, DATABASE_NAME);\\n        commandSet.put(T_DATEADD, DATEADD);\\n        commandSet.put(T_DATEDIFF, DATEDIFF);\\n        commandSet.put(T_DAY_NAME, DAY_NAME);\\n        commandSet.put(T_DAY_OF_MONTH, DAY_OF_MONTH);\\n        commandSet.put(T_DAY_OF_WEEK, DAY_OF_WEEK);\\n        commandSet.put(T_DAY_OF_YEAR, DAY_OF_YEAR);\\n        commandSet.put(T_DAYNAME, DAYNAME);\\n        commandSet.put(T_DAYOFMONTH, DAYOFMONTH);\\n        commandSet.put(T_DAYOFWEEK, DAYOFWEEK);\\n        commandSet.put(T_DAYOFYEAR, DAYOFYEAR);\\n        commandSet.put(T_DECODE, DECODE);\\n        commandSet.put(T_DEGREES, DEGREES);\\n        commandSet.put(T_DIFFERENCE, DIFFERENCE);\\n        commandSet.put(T_DMOD, DMOD);\\n        commandSet.put(T_GREATEST, GREATEST);\\n        commandSet.put(T_HEXTORAW, HEXTORAW);\\n        commandSet.put(T_IFNULL, Tokens.IFNULL);\\n        commandSet.put(T_ISNULL, Tokens.ISNULL);\\n        commandSet.put(T_LCASE, LCASE);\\n        commandSet.put(T_LEAST, LEAST);\\n        commandSet.put(T_LOAD_FILE, LOAD_FILE);\\n        commandSet.put(T_LOCATE, LOCATE);\\n        commandSet.put(T_LOG, LOG);\\n        commandSet.put(T_LOG10, LOG10);\\n        commandSet.put(T_LPAD, LPAD);\\n        commandSet.put(T_LTRIM, LTRIM);\\n        commandSet.put(T_MONTH_NAME, MONTH_NAME);\\n        commandSet.put(T_MONTHNAME, MONTHNAME);\\n        commandSet.put(T_NAMES, Tokens.NAMES);\\n        commandSet.put(T_NVL, Tokens.IFNULL);\\n        commandSet.put(T_OCTETLENGTH, OCTETLENGTH);\\n        commandSet.put(T_PI, PI);\\n        commandSet.put(T_QUARTER, QUARTER);\\n        commandSet.put(T_RADIANS, RADIANS);\\n        commandSet.put(T_RAND, RAND);\\n        commandSet.put(T_RAWTOHEX, RAWTOHEX);\\n        commandSet.put(T_REGEXP_MATCHES, REGEXP_MATCHES);\\n        commandSet.put(T_REPLACE, REPLACE);\\n        commandSet.put(T_REVERSE, REVERSE);\\n        commandSet.put(T_ROUND, ROUND);\\n        commandSet.put(T_ROUNDMAGIC, ROUNDMAGIC);\\n        commandSet.put(T_RPAD, RPAD);\\n        commandSet.put(T_RTRIM, RTRIM);\\n        commandSet.put(T_SECONDS_MIDNIGHT, SECONDS_MIDNIGHT);\\n        commandSet.put(T_SESSION_ID, SESSION_ID);\\n        commandSet.put(T_SIGN, SIGN);\\n        commandSet.put(T_SIN, SIN);\\n        commandSet.put(T_SOUNDEX, SOUNDEX);\\n        commandSet.put(T_SPACE, SPACE);\\n        commandSet.put(T_SUBSTR, SUBSTR);\\n        commandSet.put(T_SYSDATE, SYSDATE);\\n        commandSet.put(T_TAN, TAN);\\n        commandSet.put(T_TO_CHAR, TO_CHAR);\\n        commandSet.put(T_TO_DATE, TO_DATE);\\n        commandSet.put(T_TO_TIMESTAMP, TO_TIMESTAMP);\\n        commandSet.put(T_TODAY, TODAY);\\n        commandSet.put(T_TRUNC, TRUNC);\\n        commandSet.put(T_UCASE, UCASE);\\n        commandSet.put(T_TRANSACTION_ID, TRANSACTION_ID);\\n        commandSet.put(T_TRANSACTION_SIZE, TRANSACTION_SIZE);\\n        commandSet.put(T_UUID, UUID);\\n        commandSet.put(T_UNIX_TIMESTAMP, UNIX_TIMESTAMP);\\n        commandSet.put(T_WEEK, WEEK);\\n        commandSet.put(T_WEEK_OF_YEAR, WEEK_OF_YEAR);\\n                commandSet.put(T_ISOLATION_LEVEL, ISOLATION_LEVEL);\\n        commandSet.put(T_SESSION_ISOLATION_LEVEL, SESSION_ISOLATION_LEVEL);\\n        commandSet.put(T_DATABASE_ISOLATION_LEVEL, DATABASE_ISOLATION_LEVEL);\\n        commandSet.put(T_TRANSACTION_CONTROL, TRANSACTION_CONTROL);\\n        commandSet.put(T_TIMEZONE, TIMEZONE);\\n        commandSet.put(T_SESSION_TIMEZONE, SESSION_TIMEZONE);\\n        commandSet.put(T_DATABASE_TIMEZONE, DATABASE_TIMEZONE);\\n        commandSet.put(T_DATABASE_VERSION, DATABASE_VERSION);\\n        commandSet.put(T_LOB_ID, LOB_ID);\\n        commandSet.put(T_SEQUENCE_ARRAY, SEQUENCE_ARRAY);\\n                commandSet.put(T_ASTERISK, Tokens.ASTERISK);\\n        commandSet.put(T_CLOSEBRACKET, CLOSEBRACKET);\\n        commandSet.put(T_COLON, Tokens.COLON);\\n        commandSet.put(T_COMMA, Tokens.COMMA);\\n        commandSet.put(T_CONCAT, Tokens.CONCAT);\\n        commandSet.put(T_DIVIDE, Tokens.DIVIDE);\\n        commandSet.put(T_EQUALS, Tokens.EQUALS);\\n        commandSet.put(T_GREATER, Tokens.GREATER);\\n        commandSet.put(T_GREATER_EQUALS, Tokens.GREATER_EQUALS);\\n        commandSet.put(T_LEFTBRACKET, LEFTBRACKET);\\n        commandSet.put(T_LESS, Tokens.LESS);\\n        commandSet.put(T_LESS_EQUALS, Tokens.LESS_EQUALS);\\n        commandSet.put(T_MINUS, Tokens.MINUS);\\n        commandSet.put(T_NOT_EQUALS, Tokens.NOT_EQUALS);\\n        commandSet.put(T_NOT_EQUALS_ALT, Tokens.NOT_EQUALS);\\n        commandSet.put(T_OPENBRACKET, OPENBRACKET);\\n        commandSet.put(T_PLUS, Tokens.PLUS);\\n        commandSet.put(T_QUESTION, Tokens.QUESTION);\\n        commandSet.put(T_RIGHTBRACKET, RIGHTBRACKET);\\n        commandSet.put(T_SEMICOLON, SEMICOLON);\\n    }\\n    static int get(String token) {\\n        int type = reservedKeys.get(token, -1);\\n        if (type == -1) {\\n            return commandSet.get(token, -1);\\n        }\\n        return type;\\n    }\\n    public static boolean isCoreKeyword(int token) {\\n        return coreReservedWords.contains(token);\\n    }\\n    public static boolean isKeyword(String token) {\\n        return reservedKeys.containsKey(token);\\n    }\\n    public static int getKeywordID(String token, int defaultValue) {\\n        return reservedKeys.get(token, defaultValue);\\n    }\\n    public static int getNonKeywordID(String token, int defaultValue) {\\n        return commandSet.get(token, defaultValue);\\n    }\\n    public static String getKeyword(int token) {\\n        String key = (String) reservedKeys.getKey(token);\\n        if (key != null) {\\n            return key;\\n        }\\n        key = (String) commandSet.getKey(token);\\n        return key;\\n    }\\n    private static final OrderedIntHashSet coreReservedWords;\\n    static {\\n                        coreReservedWords = new OrderedIntHashSet(128);\\n        short[] keyword = {\\n            ADMIN, AS, AND, ALL, ANY, AT, AVG, BY, BETWEEN, BOTH, CALL, CASE,\\n            CAST, CORRESPONDING, CONVERT, COUNT, COALESCE, CREATE, CROSS,\\n            DISTINCT, DO, DROP, ELSE, END, EVERY, EXISTS, EXCEPT, FOR, FROM,\\n            FULL, GRANT, GROUP, HAVING, INTO, IS, IN, INTERSECT, JOIN, INNER,\\n            LEFT, LEADING, LIKE, MAX, MIN, NATURAL, NULLIF, NOT, ON, ORDER, OR,\\n            OUTER, PRIMARY, REFERENCES, RIGHT, SELECT, SET, SOME, STDDEV_POP,\\n            STDDEV_SAMP, SUM, TABLE, THEN, TO, TRAILING, TRIGGER, UNION,\\n            UNIQUE, USING, VALUES, VAR_POP, VAR_SAMP, WHEN, WHERE, WITH,\\n        };\\n        for (int i = 0; i < keyword.length; i++) {\\n            coreReservedWords.add(keyword[i]);\\n        }\\n    }\\n    public static final short[] SQL_INTERVAL_FIELD_CODES = new short[] {\\n        Tokens.YEAR, Tokens.MONTH, Tokens.DAY, Tokens.HOUR, Tokens.MINUTE,\\n        Tokens.SECOND\\n    };\\n    public static final String[] SQL_INTERVAL_FIELD_NAMES = new String[] {\\n        Tokens.T_YEAR, Tokens.T_MONTH, Tokens.T_DAY, Tokens.T_HOUR,\\n        Tokens.T_MINUTE, Tokens.T_SECOND\\n    };\\n    private static final IntKeyHashMap sqlTSILookup = new IntKeyHashMap(10);\\n    static {\\n        sqlTSILookup.put(SQL_TSI_DAY, T_SQL_TSI_DAY);\\n        sqlTSILookup.put(SQL_TSI_FRAC_SECOND, T_SQL_TSI_FRAC_SECOND);\\n        sqlTSILookup.put(SQL_TSI_MILLI_SECOND, T_SQL_TSI_MILLI_SECOND);\\n        sqlTSILookup.put(SQL_TSI_HOUR, T_SQL_TSI_HOUR);\\n        sqlTSILookup.put(SQL_TSI_MINUTE, T_SQL_TSI_MINUTE);\\n        sqlTSILookup.put(SQL_TSI_MONTH, T_SQL_TSI_MONTH);\\n        sqlTSILookup.put(SQL_TSI_QUARTER, T_SQL_TSI_QUARTER);\\n        sqlTSILookup.put(SQL_TSI_SECOND, T_SQL_TSI_SECOND);\\n        sqlTSILookup.put(SQL_TSI_WEEK, T_SQL_TSI_WEEK);\\n        sqlTSILookup.put(SQL_TSI_YEAR, T_SQL_TSI_YEAR);\\n    }\\n    public static String getSQLTSIString(int token) {\\n        return (String) sqlTSILookup.get(token);\\n    }\\n}\""
            },
            "m9": {
                "content": "The `Tokens.java` file serves as a central definition point for all SQL keywords, operators, and special symbols used in the HSQLDB system. It defines:\n\n1. **String constants** for SQL keywords like `\"SELECT\"`, `\"FROM\"`, `\"WHERE\"`, `\"JOIN\"`, etc.\n2. **Integer constants** representing token types, such as `SELECT`, `FROM`, `WHERE`, `JOIN`, etc.\n3. **Mapping logic** that converts string representations of tokens to their corresponding integer token types via methods like `get(String token)`.\n4. **Keyword and core keyword checks** (`isKeyword`, `isCoreKeyword`) to determine whether a given string or token is a reserved SQL keyword.\n\n---\n\n### Analysis of Relationship Between `Tokens.java` and `ParserDQL.java`\n\nFrom reviewing both files:\n- `ParserDQL.java` heavily relies on `Tokens.java` during SQL parsing operations.\n- For example, in `ParserDQL.java`, we see frequent calls like:\n  ```java\n  if (token.tokenType == Tokens.SELECT) { ... }\n  ```\n  This confirms that `ParserDQL` uses the token definitions from `Tokens.java` to recognize and process SQL DQL statements.\n\n- The method `readSimpleName()` and other identifier resolution functions in `ParserDQL` also rely on token recognition using values defined in `Tokens.java`.\n\n- In addition, `ParserDQL.java` uses `Tokens.get(tokenString)` to identify function names and custom SQL constructs during query parsing.\n\nThus, it's clear that **`ParserDQL.java` depends directly on `Tokens.java`**, and changes in `Tokens.java`\u2014especially involving token definitions or mappings\u2014could impact how `ParserDQL.java` parses queries.\n\n---\n\n### Next Steps\n\nTo confirm this dependency programmatically and ensure synchronization accuracy, let\u2019s now retrieve the **call graph** of `ParserDQL.java`. This will show which other entities are referenced by `ParserDQL.java`, and we can specifically check if `Tokens.java` appears among them.\n\n#### Action: Retrieve the call graph of `ParserDQL.java`\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_e30ee664eaf64288b1da02",
                        "function": {
                            "arguments": "{\"entity\": \"ParserDQL.java\"}",
                            "name": "get_call_graph"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m10": {
                "role": "tool",
                "name": "get_call_graph",
                "content": "[\"ArrayUtil\", \"LongDeque\", \"ErrorCode\", \"IntervalType\", \"ResultConstants\", \"BlobType\", \"OrderedHashSet\", \"Iterator\", \"Charset\", \"HsqlArrayList\", \"Type\", \"HashMappedList\", \"ValuePool\", \"OrderedIntKeyHashMap\", \"Collation\", \"ArrayType\", \"Types\", \"Error\", \"DTIType\", \"HsqlList\", \"NumberType\", \"ResultProperties\", \"ClobType\", \"BitMap\"]"
            },
            "m11": {
                "content": "The **call graph** of `ParserDQL.java` shows a variety of dependencies, including utility classes like `ArrayUtil`, `OrderedHashSet`, and core SQL-related constructs such as `Type`, `IntervalType`, `Error`, `ValuePool`, etc.\n\nHowever, notably missing from the list is a direct call to `Tokens.java`. This might seem contradictory to our earlier analysis where we clearly saw references to `Tokens.SELECT`, `Tokens.FROM`, etc., in the source code. There could be two possible explanations:\n\n1. **Call graph tooling limitation**: The tool may not detect static field references (like `Tokens.SELECT`) since they are constants and do not involve method calls.\n2. **Static access pattern**: Since `Tokens.java` provides constant definitions used across the parser, it's accessed statically and may not appear explicitly in the dynamic call graph.\n\n---\n\n### Conclusion: Confirming Dependency Between `Tokens.java` and `ParserDQL.java`\n\nDespite the absence in the call graph:\n- We have confirmed that `ParserDQL.java` uses token constants defined in `Tokens.java` directly in its parsing logic.\n- The co-change relationship also shows a very high confidence (`0.5227`) between `Tokens.java` and `ParserDQL.java`.\n\nTherefore, any changes in `Tokens.java`\u2014especially involving DQL-related tokens like `SELECT`, `FROM`, `WHERE`, etc.\u2014can directly impact how `ParserDQL.java` parses SQL queries.\n\n#### \u2705 Entities That Need Synchronization with `Tokens.java`:\nBased on our analysis so far:\n1. **ParserDQL.java** \u2014 High priority due to strong co-change and direct use of token constants.\n2. **ParserCommand.java** \u2014 Strong co-change relationship; likely involves command-related tokens.\n3. **Database.java** \u2014 Moderate coupling; possibly involved in global token or SQL configuration handling.\n4. **Logger.java**, **Session.java**, **HsqlDatabaseProperties.java** \u2014 Medium coupling; potential for shared SQL context or logging of token-based operations.\n\n---\n\n### Next Step\n\nTo further validate whether `ParserCommand.java` also uses `Tokens.java` similarly, let\u2019s retrieve its origin code and analyze its usage of token constants.\n\n#### Action: Retrieve the origin code of `ParserCommand.java`\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_1e77bdcd307248b98552bc",
                        "function": {
                            "arguments": "{\"entity\": \"ParserCommand.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m12": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package org.hsqldb;\\nimport org.hsqldb.HsqlNameManager.HsqlName;\\nimport org.hsqldb.error.Error;\\nimport org.hsqldb.error.ErrorCode;\\nimport org.hsqldb.lib.HsqlArrayList;\\nimport org.hsqldb.lib.HsqlList;\\nimport org.hsqldb.lib.OrderedHashSet;\\nimport org.hsqldb.persist.HsqlDatabaseProperties;\\nimport org.hsqldb.result.Result;\\nimport org.hsqldb.result.ResultProperties;\\nimport org.hsqldb.store.ValuePool;\\nimport org.hsqldb.types.Charset;\\nimport org.hsqldb.types.Type;\\nimport org.hsqldb.types.Types;\\npublic class ParserCommand extends ParserDDL {\\n    ParserCommand(Session session, Scanner t) {\\n        super(session, t);\\n    }\\n    Statement compileStatement(int props) {\\n        Statement cs = compilePart(props);\\n        if (token.tokenType == Tokens.X_ENDPARSE) {\\n            if (cs.getSchemaName() == null) {\\n                cs.setSchemaHsqlName(session.getCurrentSchemaHsqlName());\\n            }\\n            return cs;\\n        }\\n        throw unexpectedToken();\\n    }\\n    HsqlArrayList compileStatements(String sql, Result cmd) {\\n        HsqlArrayList list = new HsqlArrayList();\\n        Statement     cs   = null;\\n        reset(sql);\\n        while (true) {\\n            if (token.tokenType == Tokens.X_ENDPARSE) {\\n                break;\\n            }\\n            try {\\n                lastError = null;\\n                cs        = compilePart(cmd.getExecuteProperties());\\n            } catch (HsqlException e) {\\n                if (lastError != null && lastError.getLevel() > e.getLevel()) {\\n                    throw lastError;\\n                }\\n                throw e;\\n            }\\n            if (!cs.isExplain\\n                    && cs.getParametersMetaData().getColumnCount() > 0) {\\n                throw Error.error(ErrorCode.X_42575);\\n            }\\n            list.add(cs);\\n        }\\n        int returnType = cmd.getStatementType();\\n        if (returnType != StatementTypes.RETURN_ANY) {\\n            int group = cs.getGroup();\\n            if (group == StatementTypes.X_SQL_DATA) {\\n                if (returnType == StatementTypes.RETURN_COUNT) {\\n                    throw Error.error(ErrorCode.X_07503);\\n                }\\n            } else if (returnType == StatementTypes.RETURN_RESULT) {\\n                throw Error.error(ErrorCode.X_07504);\\n            }\\n        }\\n        return list;\\n    }\\n    private Statement compilePart(int props) {\\n        Statement cs;\\n        compileContext.reset();\\n        setParsePosition(getPosition());\\n        if (token.tokenType == Tokens.X_STARTPARSE) {\\n            read();\\n        }\\n        switch (token.tokenType) {\\n                        case Tokens.WITH :\\n            case Tokens.OPENBRACKET :\\n            case Tokens.SELECT :\\n            case Tokens.TABLE : {\\n                cs = compileCursorSpecification(props, false,\\n                                                RangeVariable.emptyArray);\\n                break;\\n            }\\n            case Tokens.VALUES : {\\n                cs = compileShortCursorSpecification(props);\\n                break;\\n            }\\n                        case Tokens.INSERT : {\\n                cs = compileInsertStatement(RangeVariable.emptyArray);\\n                break;\\n            }\\n            case Tokens.UPDATE : {\\n                cs = compileUpdateStatement(RangeVariable.emptyArray);\\n                break;\\n            }\\n            case Tokens.MERGE : {\\n                cs = compileMergeStatement(RangeVariable.emptyArray);\\n                break;\\n            }\\n            case Tokens.DELETE : {\\n                cs = compileDeleteStatement(RangeVariable.emptyArray);\\n                break;\\n            }\\n            case Tokens.TRUNCATE : {\\n                cs = compileDeleteStatement(RangeVariable.emptyArray);\\n                break;\\n            }\\n                        case Tokens.CALL : {\\n                cs = compileCallStatement(\\n                    session.sessionContext.sessionVariablesRange, false);\\n                break;\\n            }\\n                        case Tokens.SET :\\n                cs = compileSet();\\n                break;\\n            case Tokens.START :\\n                cs = compileStartTransaction();\\n                break;\\n            case Tokens.COMMIT :\\n                cs = compileCommit();\\n                break;\\n            case Tokens.ROLLBACK :\\n                cs = compileRollback();\\n                break;\\n            case Tokens.SAVEPOINT :\\n                cs = compileSavepoint();\\n                break;\\n            case Tokens.RELEASE :\\n                cs = compileReleaseSavepoint();\\n                break;\\n                        case Tokens.CREATE :\\n                cs = compileCreate();\\n                break;\\n            case Tokens.ALTER :\\n                cs = compileAlter();\\n                break;\\n            case Tokens.DROP :\\n                cs = compileDrop();\\n                break;\\n            case Tokens.GRANT :\\n            case Tokens.REVOKE :\\n                cs = compileGrantOrRevoke();\\n                break;\\n            case Tokens.COMMENT :\\n                cs = compileComment();\\n                break;\\n                        case Tokens.LOCK :\\n                cs = compileLock();\\n                break;\\n            case Tokens.CONNECT :\\n                cs = compileConnect();\\n                break;\\n            case Tokens.DISCONNECT :\\n                cs = compileDisconnect();\\n                break;\\n                        case Tokens.SCRIPT :\\n                cs = compileScript();\\n                break;\\n            case Tokens.SHUTDOWN :\\n                cs = compileShutdown();\\n                break;\\n            case Tokens.BACKUP :\\n                cs = compileBackup();\\n                break;\\n            case Tokens.CHECKPOINT :\\n                cs = compileCheckpoint();\\n                break;\\n            case Tokens.EXPLAIN :\\n                cs = compileExplainPlan();\\n                break;\\n            case Tokens.DECLARE :\\n                cs = compileDeclare();\\n                break;\\n            default :\\n                throw unexpectedToken();\\n        }\\n        if (cs.type != StatementTypes.SET_SESSION_AUTHORIZATION) {\\n            cs.setSQL(getLastPart());\\n        }\\n        if (token.tokenType == Tokens.SEMICOLON) {\\n            read();\\n        } else if (token.tokenType == Tokens.X_ENDPARSE) {}\\n        return cs;\\n    }\\n    private Statement compileDeclare() {\\n        Statement    cs;\\n        ColumnSchema variables[];\\n        cs = compileDeclareLocalTableOrNull();\\n        if (cs != null) {\\n            return cs;\\n        }\\n        variables = readLocalVariableDeclarationOrNull();\\n        if (variables != null) {\\n            Object[] args = new Object[]{ variables };\\n            cs = new StatementSession(StatementTypes.DECLARE_VARIABLE, args);\\n            return cs;\\n        }\\n        cs = compileDeclareCursor(false, null);\\n        return cs;\\n    }\\n    private Statement compileScript() {\\n        String name = null;\\n        read();\\n        if (token.tokenType == Tokens.X_VALUE) {\\n            name = readQuotedString();\\n        }\\n        HsqlName[] names =\\n            database.schemaManager.getCatalogAndBaseTableNames();\\n        Object[] args = new Object[]{ name };\\n        return new StatementCommand(StatementTypes.DATABASE_SCRIPT, args,\\n                                    null, names);\\n    }\\n    private Statement compileConnect() {\\n        String userName;\\n        String password = null;\\n        read();\\n        readThis(Tokens.USER);\\n        checkIsSimpleName();\\n        userName = token.tokenString;\\n        read();\\n        if (!session.isProcessingLog) {\\n            readThis(Tokens.PASSWORD);\\n            password = readPassword();\\n        }\\n        Expression[] args = new Expression[] {\\n            new ExpressionValue(userName, Type.SQL_VARCHAR),\\n            new ExpressionValue(password, Type.SQL_VARCHAR)\\n        };\\n        Statement cs =\\n            new StatementSession(StatementTypes.SET_SESSION_AUTHORIZATION,\\n                                 args);\\n        return cs;\\n    }\\n    private StatementCommand compileSetDefault() {\\n        read();\\n        switch (token.tokenType) {\\n            case Tokens.INITIAL : {\\n                read();\\n                readThis(Tokens.SCHEMA);\\n                HsqlName schema = database.schemaManager.getSchemaHsqlName(\\n                    token.tokenString);\\n                read();\\n                Object[] args = new Object[]{ schema };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_DEFAULT_INITIAL_SCHEMA, args);\\n            }\\n            case Tokens.RESULT : {\\n                read();\\n                readThis(Tokens.MEMORY);\\n                readThis(Tokens.ROWS);\\n                Integer  size = readIntegerObject();\\n                Object[] args = new Object[]{ size };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_RESULT_MEMORY_ROWS, args);\\n            }\\n            case Tokens.TABLE : {\\n                read();\\n                readThis(Tokens.TYPE);\\n                int type = TableBase.MEMORY_TABLE;\\n                switch (token.tokenType) {\\n                    case Tokens.MEMORY :\\n                        break;\\n                    case Tokens.CACHED :\\n                        type = TableBase.CACHED_TABLE;\\n                        break;\\n                    default :\\n                        throw unexpectedToken();\\n                }\\n                read();\\n                Object[] args = new Object[]{ ValuePool.getInt(type) };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_DEFAULT_TABLE_TYPE, args);\\n            }\\n            case Tokens.ISOLATION : {\\n                read();\\n                readThis(Tokens.LEVEL);\\n                int level;\\n                switch (token.tokenType) {\\n                    case Tokens.READ :\\n                        read();\\n                        readThis(Tokens.COMMITTED);\\n                        level = SessionInterface.TX_READ_COMMITTED;\\n                        break;\\n                    case Tokens.SERIALIZABLE :\\n                        read();\\n                        level = SessionInterface.TX_SERIALIZABLE;\\n                        break;\\n                    default :\\n                        throw unexpectedToken();\\n                }\\n                read();\\n                Object[] args = new Object[]{ ValuePool.getInt(level) };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_DEFAULT_ISOLATION_LEVEL, args);\\n            }\\n            default :\\n                throw unexpectedToken();\\n        }\\n    }\\n    private StatementCommand compileSetProperty() {\\n        read();\\n        String                 property;\\n        Object                 value;\\n        HsqlDatabaseProperties props = database.getProperties();\\n        checkIsSimpleName();\\n        checkIsDelimitedIdentifier();\\n        property = token.tokenString;\\n        boolean isboolean  = props.isBoolean(token.tokenString);\\n        boolean isintegral = props.isIntegral(token.tokenString);\\n        boolean isstring   = props.isString(token.tokenString);\\n        if (!(isboolean || isintegral || isstring)) {\\n            throw Error.error(ErrorCode.X_42555, property);\\n        }\\n        int typeCode = isboolean ? Types.SQL_BOOLEAN\\n                                 : isintegral ? Types.SQL_INTEGER\\n                                              : Types.SQL_CHAR;\\n        read();\\n        if (token.tokenType == Tokens.TRUE) {\\n            value = Boolean.TRUE;\\n            if (!isboolean) {\\n                throw Error.error(ErrorCode.X_42563, token.tokenString);\\n            }\\n        } else if (token.tokenType == Tokens.FALSE) {\\n            value = Boolean.FALSE;\\n            if (!isboolean) {\\n                throw Error.error(ErrorCode.X_42563, token.tokenString);\\n            }\\n        } else {\\n            checkIsValue();\\n            value = token.tokenValue;\\n            if (token.dataType.typeCode != typeCode) {\\n                throw Error.error(ErrorCode.X_42563, token.tokenString);\\n            }\\n        }\\n        read();\\n        Object[] args = new Object[] {\\n            property, value\\n        };\\n        return new StatementCommand(StatementTypes.SET_DATABASE_PROPERTY,\\n                                    args);\\n    }\\n    private Statement compileSet() {\\n        int position = super.getPosition();\\n        session.setScripting(false);\\n        read();\\n        switch (token.tokenType) {\\n            case Tokens.CATALOG : {\\n                read();\\n                Expression e = XreadValueSpecificationOrNull();\\n                if (e == null) {\\n                    HsqlName name = readSchemaName();\\n                    Object[] args = new Object[]{ name };\\n                    return new StatementSession(StatementTypes.SET_CATALOG,\\n                                                args);\\n                }\\n                if (!e.getDataType().isCharacterType()) {\\n                    throw Error.error(ErrorCode.X_0P000);\\n                }\\n                if (e.getType() != OpTypes.VALUE\\n                        && (e.getType() != OpTypes.SQL_FUNCTION\\n                            || !((FunctionSQL) e).isValueFunction())) {\\n                    throw Error.error(ErrorCode.X_0P000);\\n                }\\n                Expression[] args = new Expression[]{ e };\\n                return new StatementSession(StatementTypes.SET_CATALOG, args);\\n            }\\n            case Tokens.SCHEMA : {\\n                read();\\n                Expression e = XreadValueSpecificationOrNull();\\n                if (e == null) {\\n                    HsqlName name = readSchemaName();\\n                    Object[] args = new Object[]{ name };\\n                    return new StatementSession(StatementTypes.SET_SCHEMA,\\n                                                args);\\n                }\\n                if (!e.getDataType().isCharacterType()) {\\n                    throw Error.error(ErrorCode.X_0P000);\\n                }\\n                if (e.getType() != OpTypes.VALUE\\n                        && (e.getType() != OpTypes.SQL_FUNCTION\\n                            || !((FunctionSQL) e).isValueFunction())) {\\n                    throw Error.error(ErrorCode.X_0P000);\\n                }\\n                Expression[] args = new Expression[]{ e };\\n                return new StatementSession(StatementTypes.SET_SCHEMA, args);\\n            }\\n            case Tokens.NO : {\\n                read();\\n                readThis(Tokens.COLLATION);\\n                HsqlArrayList charsets = null;\\n                if (readIfThis(Tokens.FOR)) {\\n                    charsets = new HsqlArrayList();\\n                    while (true) {\\n                        SchemaObject charset =\\n                            readSchemaObjectName(SchemaObject.CHARSET);\\n                        charsets.add(charset);\\n                        if (token.tokenType == Tokens.COMMA) {\\n                            read();\\n                            continue;\\n                        }\\n                        break;\\n                    }\\n                }\\n                Object[] args = new Object[] {\\n                    null, Boolean.FALSE, charsets\\n                };\\n                return new StatementSession(StatementTypes.SET_COLLATION,\\n                                            args);\\n            }\\n            case Tokens.COLLATION : {\\n                read();\\n                Expression e = XreadValueSpecificationOrNull();\\n                if (e == null || !e.getDataType().isCharacterType()) {\\n                    throw Error.error(ErrorCode.X_2H000);\\n                }\\n                HsqlArrayList charsets = null;\\n                if (readIfThis(Tokens.FOR)) {\\n                    charsets = new HsqlArrayList();\\n                    while (true) {\\n                        SchemaObject charset =\\n                            readSchemaObjectName(SchemaObject.CHARSET);\\n                        charsets.add(charset);\\n                        if (token.tokenType == Tokens.COMMA) {\\n                            read();\\n                            continue;\\n                        }\\n                        break;\\n                    }\\n                }\\n                Object[] args = new Object[] {\\n                    e, Boolean.TRUE, charsets\\n                };\\n                return new StatementSession(StatementTypes.SET_COLLATION,\\n                                            args);\\n            }\\n            case Tokens.TIME : {\\n                read();\\n                return compileSetTimeZone();\\n            }\\n            case Tokens.ROLE : {\\n                read();\\n                return compileSetRole();\\n            }\\n            case Tokens.SESSION : {\\n                read();\\n                return compileSessionSettings();\\n            }\\n            case Tokens.TRANSACTION : {\\n                read();\\n                Object[] args = processTransactionCharacteristics();\\n                if (args[0] == null && args[1] == null) {\\n                    throw unexpectedToken();\\n                }\\n                return new StatementSession(StatementTypes.SET_TRANSACTION,\\n                                            args);\\n            }\\n            case Tokens.AUTOCOMMIT : {\\n                read();\\n                Boolean  mode = processTrueOrFalseObject();\\n                Object[] args = new Object[]{ mode };\\n                return new StatementSession(\\n                    StatementTypes.SET_SESSION_AUTOCOMMIT, args);\\n            }\\n                        case Tokens.READONLY : {\\n                read();\\n                Boolean  readonly = processTrueOrFalseObject();\\n                Object[] args     = new Object[]{ readonly };\\n                return new StatementSession(\\n                    StatementTypes.SET_SESSION_CHARACTERISTICS, args);\\n            }\\n            case Tokens.IGNORECASE : {\\n                read();\\n                Boolean  mode = processTrueOrFalseObject();\\n                Object[] args = new Object[]{ mode };\\n                return new StatementSession(\\n                    StatementTypes.SET_SESSION_SQL_IGNORECASE, args);\\n            }\\n            case Tokens.MAXROWS : {\\n                read();\\n                Integer  size = readIntegerObject();\\n                Object[] args = new Object[]{ size };\\n                return new StatementSession(\\n                    StatementTypes.SET_SESSION_RESULT_MAX_ROWS, args);\\n            }\\n                        case Tokens.DEFAULT : {\\n                read();\\n                readThis(Tokens.TABLE);\\n                readThis(Tokens.TYPE);\\n                int type = TableBase.MEMORY_TABLE;\\n                switch (token.tokenType) {\\n                    case Tokens.MEMORY :\\n                        break;\\n                    case Tokens.CACHED :\\n                        type = TableBase.CACHED_TABLE;\\n                        break;\\n                    default :\\n                        throw unexpectedToken();\\n                }\\n                read();\\n                Object[] args = new Object[]{ ValuePool.getInt(type) };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_DEFAULT_TABLE_TYPE, args);\\n            }\\n            case Tokens.TABLE : {\\n                read();\\n                Table    t    = readTableName();\\n                Object[] args = new Object[] {\\n                    t.getName(), null\\n                };\\n                switch (token.tokenType) {\\n                    default : {\\n                        throw unexpectedToken();\\n                    }\\n                    case Tokens.SOURCE :\\n                        read();\\n                        return compileTableSource(t);\\n                    case Tokens.READ : {\\n                        read();\\n                        boolean readonly = false;\\n                        if (token.tokenType == Tokens.WRITE) {\\n                            read();\\n                        } else {\\n                            readThis(Tokens.ONLY);\\n                            readonly = true;\\n                        }\\n                        args[1] = Boolean.valueOf(readonly);\\n                        return new StatementCommand(\\n                            StatementTypes.SET_TABLE_READONLY, args, null,\\n                            new HsqlName[]{ t.getName() });\\n                    }\\n                                        case Tokens.READONLY : {\\n                        read();\\n                        Boolean readonly = processTrueOrFalseObject();\\n                        args[1] = readonly;\\n                        return new StatementCommand(\\n                            StatementTypes.SET_TABLE_READONLY, args, null,\\n                            new HsqlName[]{ t.getName() });\\n                    }\\n                    case Tokens.INDEX : {\\n                        String value;\\n                        read();\\n                        checkIsValue();\\n                        value = token.tokenString;\\n                        read();\\n                        args[1] = value;\\n                        return new StatementCommand(\\n                            StatementTypes.SET_TABLE_INDEX, args, null,\\n                            new HsqlName[]{ t.getName() });\\n                    }\\n                    case Tokens.TYPE : {\\n                        read();\\n                        int newType;\\n                        if (token.tokenType == Tokens.CACHED) {\\n                            newType = TableBase.CACHED_TABLE;\\n                        } else if (token.tokenType == Tokens.MEMORY) {\\n                            newType = TableBase.MEMORY_TABLE;\\n                        } else {\\n                            throw super.unexpectedToken();\\n                        }\\n                        read();\\n                        args[1] = new Integer(newType);\\n                        return new StatementCommand(\\n                            StatementTypes.SET_TABLE_TYPE, args, null,\\n                            new HsqlName[]{ t.getName() });\\n                    }\\n                    case Tokens.CLUSTERED : {\\n                        read();\\n                        readThis(Tokens.ON);\\n                        OrderedHashSet set = new OrderedHashSet();\\n                        readThis(Tokens.OPENBRACKET);\\n                        readSimpleColumnNames(set, t);\\n                        readThis(Tokens.CLOSEBRACKET);\\n                        int[] colIndex = t.getColumnIndexes(set);\\n                        args[1] = colIndex;\\n                        return new StatementCommand(\\n                            StatementTypes.SET_TABLE_CLUSTERED, args, null,\\n                            new HsqlName[]{ t.getName() });\\n                    }\\n                }\\n            }\\n            case Tokens.WRITE_DELAY : {\\n                read();\\n                int delay = 0;\\n                if (token.tokenType == Tokens.TRUE) {\\n                    delay = database.getProperties().getDefaultWriteDelay();\\n                    read();\\n                } else if (token.tokenType == Tokens.FALSE) {\\n                    delay = 0;\\n                    read();\\n                } else {\\n                    delay = this.readInteger();\\n                    if (delay < 0) {\\n                        delay = 0;\\n                    }\\n                    if (token.tokenType == Tokens.MILLIS) {\\n                        read();\\n                    } else {\\n                        delay *= 1000;\\n                    }\\n                }\\n                Object[] args = new Object[]{ new Integer(delay) };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_FILES_WRITE_DELAY, args, null,\\n                    null);\\n            }\\n            case Tokens.PASSWORD : {\\n                String password;\\n                read();\\n                password = readPassword();\\n                Object[] args = new Object[] {\\n                    null, password\\n                };\\n                return new StatementCommand(StatementTypes.SET_USER_PASSWORD,\\n                                            args);\\n            }\\n            case Tokens.INITIAL : {\\n                read();\\n                readThis(Tokens.SCHEMA);\\n                HsqlName schema;\\n                if (token.tokenType == Tokens.DEFAULT) {\\n                    schema = null;\\n                } else {\\n                    schema = database.schemaManager.getSchemaHsqlName(\\n                        token.tokenString);\\n                }\\n                read();\\n                Object[] args = new Object[] {\\n                    null, schema\\n                };\\n                return new StatementCommand(\\n                    StatementTypes.SET_USER_INITIAL_SCHEMA, args);\\n            }\\n            case Tokens.FILES : {\\n                return compileSetFilesProperty();\\n            }\\n            case Tokens.DATABASE : {\\n                return compileSetDatabaseProperty();\\n            }\\n            case Tokens.PROPERTY : {\\n                return compileSetProperty();\\n            }\\n            default : {\\n                rewind(position);\\n                return compileSetStatement(\\n                    session.sessionContext.sessionVariablesRange);\\n            }\\n        }\\n    }\\n    StatementCommand compileSetDatabaseProperty() {\\n        read();\\n        String name;\\n        checkDatabaseUpdateAuthorisation();\\n        switch (token.tokenType) {\\n            case Tokens.AUTHENTICATION : {\\n                read();\\n                readThis(Tokens.FUNCTION);\\n                Routine  routine = readCreateDatabaseAuthenticationFunction();\\n                Object[] args    = new Object[]{ routine };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_AUTHENTICATION, args, null,\\n                    null);\\n            }\\n            case Tokens.COLLATION : {\\n                read();\\n                checkIsSimpleName();\\n                name = token.tokenString;\\n                read();\\n                Object[] args = new Object[]{ name };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_SQL_COLLATION, args, null,\\n                    null);\\n            }\\n            case Tokens.DEFAULT : {\\n                return compileSetDefault();\\n            }\\n            case Tokens.EVENT : {\\n                read();\\n                readThis(Tokens.LOG);\\n                readThis(Tokens.LEVEL);\\n                Integer  value = readIntegerObject();\\n                Object[] args  = new Object[]{ value };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_FILES_EVENT_LOG, args, null,\\n                    null);\\n            }\\n            case Tokens.GC : {\\n                read();\\n                Integer  size = readIntegerObject();\\n                Object[] args = new Object[]{ size };\\n                return new StatementCommand(StatementTypes.SET_DATABASE_GC,\\n                                            args, null, null);\\n            }\\n            case Tokens.PASSWORD : {\\n                read();\\n                readThis(Tokens.CHECK);\\n                readThis(Tokens.FUNCTION);\\n                Routine  routine = readCreatePasswordCheckFunction();\\n                Object[] args    = new Object[]{ routine };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_PASSWORD_CHECK, args, null,\\n                    null);\\n            }\\n            case Tokens.REFERENTIAL : {\\n                read();\\n                readThis(Tokens.INTEGRITY);\\n                boolean  mode = processTrueOrFalse();\\n                Object[] args = new Object[]{ Boolean.valueOf(mode) };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_SQL_REFERENTIAL_INTEGRITY,\\n                    args, null, null);\\n            }\\n            case Tokens.SQL : {\\n                read();\\n                int     type     = StatementTypes.SET_DATABASE_SQL;\\n                Boolean flag     = null;\\n                String  property = null;\\n                switch (token.tokenType) {\\n                    case Tokens.NAMES :\\n                        read();\\n                        property = HsqlDatabaseProperties.sql_enforce_names;\\n                        flag     = processTrueOrFalseObject();\\n                        break;\\n                    case Tokens.REFERENCES :\\n                        read();\\n                        flag     = processTrueOrFalseObject();\\n                        property = HsqlDatabaseProperties.sql_enforce_refs;\\n                        break;\\n                    case Tokens.SIZE :\\n                        read();\\n                        flag     = processTrueOrFalseObject();\\n                        property = HsqlDatabaseProperties.sql_enforce_size;\\n                        break;\\n                    case Tokens.TYPES :\\n                        read();\\n                        flag     = processTrueOrFalseObject();\\n                        property = HsqlDatabaseProperties.sql_enforce_types;\\n                        break;\\n                    case Tokens.TDC :\\n                        read();\\n                        if (readIfThis(Tokens.DELETE)) {\\n                            property = HsqlDatabaseProperties.sql_enforce_tdcd;\\n                        } else {\\n                            readThis(Tokens.UPDATE);\\n                            property = HsqlDatabaseProperties.sql_enforce_tdcu;\\n                        }\\n                        flag = processTrueOrFalseObject();\\n                        break;\\n                    case Tokens.TRANSLATE :\\n                        read();\\n                        readThis(Tokens.TTI);\\n                        readThis(Tokens.TYPES);\\n                        flag = processTrueOrFalseObject();\\n                        property =\\n                            HsqlDatabaseProperties.jdbc_translate_tti_types;\\n                        break;\\n                    case Tokens.CONCAT_WORD :\\n                        read();\\n                        readThis(Tokens.NULLS);\\n                        flag     = processTrueOrFalseObject();\\n                        property = HsqlDatabaseProperties.sql_concat_nulls;\\n                        break;\\n                    case Tokens.UNIQUE :\\n                        read();\\n                        readThis(Tokens.NULLS);\\n                        flag     = processTrueOrFalseObject();\\n                        property = HsqlDatabaseProperties.sql_unique_nulls;\\n                        break;\\n                    case Tokens.CONVERT :\\n                        read();\\n                        readThis(Tokens.TRUNCATE);\\n                        flag     = processTrueOrFalseObject();\\n                        property = HsqlDatabaseProperties.sql_convert_trunc;\\n                        break;\\n                    case Tokens.DOUBLE :\\n                        read();\\n                        readThis(Tokens.NAN);\\n                        flag     = processTrueOrFalseObject();\\n                        property = HsqlDatabaseProperties.sql_double_nan;\\n                        break;\\n                    case Tokens.LONGVAR :\\n                        read();\\n                        readThis(Tokens.IS);\\n                        readThis(Tokens.LOB);\\n                        flag     = processTrueOrFalseObject();\\n                        property = HsqlDatabaseProperties.sql_longvar_is_lob;\\n                        break;\\n                    case Tokens.SYNTAX :\\n                        read();\\n                        if (token.tokenString.equals(Tokens.T_ORA)) {\\n                            read();\\n                            property = HsqlDatabaseProperties.sql_syntax_ora;\\n                        } else if (token.tokenString.equals(Tokens.T_MSS)) {\\n                            read();\\n                            property = HsqlDatabaseProperties.sql_syntax_mss;\\n                        } else if (token.tokenString.equals(Tokens.T_MYS)) {\\n                            read();\\n                            property = HsqlDatabaseProperties.sql_syntax_mys;\\n                        } else if (token.tokenString.equals(Tokens.T_PGS)) {\\n                            read();\\n                            property = HsqlDatabaseProperties.sql_syntax_pgs;\\n                        } else {\\n                            throw unexpectedToken();\\n                        }\\n                        flag = processTrueOrFalseObject();\\n                        break;\\n                    default :\\n                        throw unexpectedToken();\\n                }\\n                Object[] args = new Object[] {\\n                    property, flag\\n                };\\n                return new StatementCommand(type, args, null, null);\\n            }\\n            case Tokens.TEXT : {\\n                read();\\n                readThis(Tokens.TABLE);\\n                readThis(Tokens.DEFAULTS);\\n                String   source = readQuotedString();\\n                Object[] args   = new Object[]{ source };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_TEXT_SOURCE, args, null, null);\\n            }\\n            case Tokens.TRANSACTION : {\\n                read();\\n                if (readIfThis(Tokens.ROLLBACK)) {\\n                    readThis(Tokens.ON);\\n                    readThis(Tokens.DEADLOCK);\\n                    Boolean mode = processTrueOrFalseObject();\\n                    StatementCommand cs = new StatementCommand(\\n                        StatementTypes.SET_DATABASE_TRANSACTION_DEADLOCK,\\n                        new Object[]{ mode }, null, null);\\n                    return cs;\\n                }\\n                readThis(Tokens.CONTROL);\\n                int mode = TransactionManager.LOCKS;\\n                switch (token.tokenType) {\\n                    case Tokens.MVCC :\\n                        read();\\n                        mode = TransactionManager.MVCC;\\n                        break;\\n                    case Tokens.MVLOCKS :\\n                        read();\\n                        mode = TransactionManager.MVLOCKS;\\n                        break;\\n                    case Tokens.LOCKS :\\n                        read();\\n                        mode = TransactionManager.LOCKS;\\n                        break;\\n                }\\n                HsqlName[] names =\\n                    database.schemaManager.getCatalogAndBaseTableNames();\\n                Object[] args = new Object[]{ ValuePool.getInt(mode) };\\n                StatementCommand cs = new StatementCommand(\\n                    StatementTypes.SET_DATABASE_TRANSACTION_CONTROL, args,\\n                    null, names);\\n                return cs;\\n            }\\n            case Tokens.UNIQUE : {\\n                read();\\n                readThis(Tokens.NAME);\\n                isUndelimitedSimpleName();\\n                name = token.tokenString;\\n                read();\\n                if (name.length() != 16) {\\n                    throw Error.error(ErrorCode.X_42555);\\n                }\\n                if (!Charset.isInSet(name, Charset.unquotedIdentifier)\\n                        || !Charset.startsWith(name,\\n                                               Charset.uppercaseLetters)) {\\n                    throw Error.error(ErrorCode.X_42501);\\n                }\\n                Object[] args = new Object[]{ name };\\n                return new StatementCommand(\\n                    StatementTypes.SET_DATABASE_UNIQUE_NAME, args, null, null);\\n            }\\n            default : {\\n                throw unexpectedToken();\\n            }\\n        }\\n    }\\n    StatementCommand compileSetFilesProperty() {\\n        read();\\n        String  name;\\n        int     type  = 0;\\n        Boolean flag  = null;\\n        Integer value = null;\\n        checkDatabaseUpdateAuthorisation();\\n        switch (token.tokenType) {\\n            case Tokens.LOCK : {\\n                read();\\n                flag = processTrueOrFalseObject();\\n                type = StatementTypes.SET_DATABASE_FILES_LOCK;\\n                break;\\n            }\\n            case Tokens.CACHE : {\\n                read();\\n                if (readIfThis(Tokens.SIZE)) {\\n                    value = readIntegerObject();\\n                    type  = StatementTypes.SET_DATABASE_FILES_CACHE_SIZE;\\n                } else {\\n                    readThis(Tokens.ROWS);\\n                    value = readIntegerObject();\\n                    type  = StatementTypes.SET_DATABASE_FILES_CACHE_ROWS;\\n                }\\n                break;\\n            }\\n            case Tokens.SCALE : {\\n                read();\\n                value = readIntegerObject();\\n                type  = StatementTypes.SET_DATABASE_FILES_SCALE;\\n                break;\\n            }\\n            case Tokens.LOB : {\\n                read();\\n                readThis(Tokens.SCALE);\\n                value = readIntegerObject();\\n                type  = StatementTypes.SET_DATABASE_FILES_LOBS_SCALE;\\n                break;\\n            }\\n            case Tokens.DEFRAG : {\\n                read();\\n                type  = StatementTypes.SET_DATABASE_FILES_DEFRAG;\\n                value = readIntegerObject();\\n                break;\\n            }\\n            case Tokens.NIO : {\\n                read();\\n                if (readIfThis(Tokens.SIZE)) {\\n                    value = readIntegerObject();\\n                } else {\\n                    flag = processTrueOrFalseObject();\\n                }\\n                type = StatementTypes.SET_DATABASE_FILES_NIO;\\n                break;\\n            }\\n            case Tokens.BACKUP : {\\n                read();\\n                type = StatementTypes.SET_DATABASE_FILES_BACKUP_INCREMENT;\\n                readThis(Tokens.INCREMENT);\\n                flag = processTrueOrFalseObject();\\n                break;\\n            }\\n            case Tokens.LOG : {\\n                read();\\n                if (readIfThis(Tokens.SIZE)) {\\n                    type  = StatementTypes.SET_DATABASE_FILES_LOG_SIZE;\\n                    value = readIntegerObject();\\n                } else {\\n                    type = StatementTypes.SET_DATABASE_FILES_LOG;\\n                    flag = processTrueOrFalseObject();\\n                }\\n                break;\\n            }\\n            case Tokens.TEMP : {\\n                read();\\n                readThis(Tokens.PATH);\\n                type  = StatementTypes.SET_DATABASE_FILES_TEMP_PATH;\\n                value = readIntegerObject();\\n                break;\\n            }\\n            case Tokens.WRITE : {\\n                read();\\n                readThis(Tokens.DELAY);\\n                type = StatementTypes.SET_DATABASE_FILES_WRITE_DELAY;\\n                int delay = 0;\\n                if (token.tokenType == Tokens.TRUE) {\\n                    delay = database.getProperties().getDefaultWriteDelay();\\n                    read();\\n                } else if (token.tokenType == Tokens.FALSE) {\\n                    delay = 0;\\n                    read();\\n                } else {\\n                    delay = this.readInteger();\\n                    if (delay < 0) {\\n                        delay = 0;\\n                    }\\n                    if (token.tokenType == Tokens.MILLIS) {\\n                        read();\\n                    } else {\\n                        delay *= 1000;\\n                    }\\n                }\\n                value = new Integer(delay);\\n                break;\\n            }\\n            case Tokens.SCRIPT : {\\n                read();\\n                readThis(Tokens.FORMAT);\\n                if (token.tokenType == Tokens.TEXT) {\\n                    read();\\n                    value = new Integer(0);\\n                } else {\\n                    readThis(Tokens.COMPRESSED);\\n                    value = new Integer(3);\\n                }\\n                type = StatementTypes.SET_DATABASE_FILES_SCRIPT_FORMAT;\\n                break;\\n            }\\n            default :\\n                throw unexpectedToken();\\n        }\\n        Object[] args = new Object[]{ flag == null ? (Object) value\\n                                                   : (Object) flag };\\n        return new StatementCommand(\\n            type, args, null, database.schemaManager.getCatalogNameArray());\\n    }\\n    Object[] processTransactionCharacteristics() {\\n        int      level    = 0;\\n        boolean  readonly = false;\\n        Object[] args     = new Object[2];\\n        outerloop:\\n        while (true) {\\n            switch (token.tokenType) {\\n                case Tokens.READ : {\\n                    if (args[0] != null) {\\n                        throw unexpectedToken();\\n                    }\\n                    read();\\n                    if (token.tokenType == Tokens.ONLY) {\\n                        read();\\n                        readonly = true;\\n                    } else {\\n                        readThis(Tokens.WRITE);\\n                        readonly = false;\\n                    }\\n                    args[0] = Boolean.valueOf(readonly);\\n                    break;\\n                }\\n                case Tokens.ISOLATION : {\\n                    if (args[1] != null) {\\n                        throw unexpectedToken();\\n                    }\\n                    read();\\n                    readThis(Tokens.LEVEL);\\n                    switch (token.tokenType) {\\n                        case Tokens.SERIALIZABLE :\\n                            read();\\n                            level = SessionInterface.TX_SERIALIZABLE;\\n                            break;\\n                        case Tokens.READ :\\n                            read();\\n                            if (token.tokenType == Tokens.COMMITTED) {\\n                                read();\\n                                level = SessionInterface.TX_READ_COMMITTED;\\n                            } else if (token.tokenType == Tokens.UNCOMMITTED) {\\n                                read();\\n                                level = SessionInterface.TX_READ_UNCOMMITTED;\\n                            } else {\\n                                throw unexpectedToken();\\n                            }\\n                            break;\\n                        case Tokens.REPEATABLE :\\n                            read();\\n                            readThis(Tokens.READ);\\n                            level = SessionInterface.TX_REPEATABLE_READ;\\n                            break;\\n                        default :\\n                            throw unexpectedToken();\\n                    }\\n                    args[1] = new Integer(level);\\n                    break;\\n                }\\n                case Tokens.COMMA : {\\n                    if (args[0] == null && args[1] == null) {\\n                        throw unexpectedToken();\\n                    }\\n                    read();\\n                    break;\\n                }\\n                default : {\\n                    break outerloop;\\n                }\\n            }\\n        }\\n        if (!readonly && level == 1) {\\n            throw unexpectedToken(Tokens.T_WRITE);\\n        }\\n        return args;\\n    }\\n    private Statement compileCommit() {\\n        boolean chain = false;\\n        read();\\n        readIfThis(Tokens.WORK);\\n        if (token.tokenType == Tokens.AND) {\\n            read();\\n            if (token.tokenType == Tokens.NO) {\\n                read();\\n            } else {\\n                chain = true;\\n            }\\n            readThis(Tokens.CHAIN);\\n        }\\n        String    sql  = getLastPart();\\n        Object[]  args = new Object[]{ Boolean.valueOf(chain) };\\n        Statement cs = new StatementSession(StatementTypes.COMMIT_WORK, args);\\n        return cs;\\n    }\\n    private Statement compileStartTransaction() {\\n        read();\\n        readThis(Tokens.TRANSACTION);\\n        Object[] args = processTransactionCharacteristics();\\n        Statement cs = new StatementSession(StatementTypes.START_TRANSACTION,\\n                                            args);\\n        return cs;\\n    }\\n    private Statement compileLock() {\\n        read();\\n        readThis(Tokens.TABLE);\\n        OrderedHashSet readSet  = new OrderedHashSet();\\n        OrderedHashSet writeSet = new OrderedHashSet();\\n        outerloop:\\n        while (true) {\\n            Table table = readTableName();\\n            switch (token.tokenType) {\\n                case Tokens.READ :\\n                    read();\\n                    readSet.add(table.getName());\\n                    break;\\n                case Tokens.WRITE :\\n                    read();\\n                    writeSet.add(table.getName());\\n                    break;\\n                default :\\n                    throw unexpectedToken();\\n            }\\n            if (token.tokenType == Tokens.COMMA) {\\n                read();\\n                continue;\\n            }\\n            break outerloop;\\n        }\\n        HsqlName[] writeTableNames = new HsqlName[writeSet.size()];\\n        writeSet.toArray(writeTableNames);\\n        readSet.removeAll(writeTableNames);\\n        HsqlName[] readTableNames = new HsqlName[readSet.size()];\\n        readSet.toArray(readTableNames);\\n        Statement cs =\\n            new StatementSession(StatementTypes.TRANSACTION_LOCK_TABLE,\\n                                 readTableNames, writeTableNames);\\n        return cs;\\n    }\\n    private Statement compileRollback() {\\n        boolean chain     = false;\\n        String  savepoint = null;\\n        read();\\n        if (token.tokenType == Tokens.TO) {\\n            read();\\n            readThis(Tokens.SAVEPOINT);\\n            checkIsSimpleName();\\n            savepoint = token.tokenString;\\n            read();\\n            String   sql  = getLastPart();\\n            Object[] args = new Object[]{ savepoint };\\n            Statement cs =\\n                new StatementSession(StatementTypes.ROLLBACK_SAVEPOINT, args);\\n            return cs;\\n        } else {\\n            if (token.tokenType == Tokens.WORK) {\\n                read();\\n            }\\n            if (token.tokenType == Tokens.AND) {\\n                read();\\n                if (token.tokenType == Tokens.NO) {\\n                    read();\\n                } else {\\n                    chain = true;\\n                }\\n                readThis(Tokens.CHAIN);\\n            }\\n        }\\n        String   sql  = getLastPart();\\n        Object[] args = new Object[]{ Boolean.valueOf(chain) };\\n        Statement cs = new StatementSession(StatementTypes.ROLLBACK_WORK,\\n                                            args);\\n        return cs;\\n    }\\n    private Statement compileSavepoint() {\\n        String name;\\n        read();\\n        checkIsSimpleName();\\n        name = token.tokenString;\\n        read();\\n        String   sql  = getLastPart();\\n        Object[] args = new Object[]{ name };\\n        return new StatementSession(StatementTypes.SAVEPOINT, args);\\n    }\\n    private Statement compileReleaseSavepoint() {\\n        read();\\n        readThis(Tokens.SAVEPOINT);\\n        String name = token.tokenString;\\n        read();\\n        String   sql  = getLastPart();\\n        Object[] args = new Object[]{ name };\\n        return new StatementSession(StatementTypes.RELEASE_SAVEPOINT, args);\\n    }\\n    private Statement compileSessionSettings() {\\n        switch (token.tokenType) {\\n            case Tokens.CHARACTERISTICS : {\\n                read();\\n                readThis(Tokens.AS);\\n                readThis(Tokens.TRANSACTION);\\n                Object[] args = processTransactionCharacteristics();\\n                return new StatementSession(\\n                    StatementTypes.SET_SESSION_CHARACTERISTICS, args);\\n            }\\n            case Tokens.AUTHORIZATION : {\\n                read();\\n                Expression e = XreadValueSpecificationOrNull();\\n                if (e == null) {\\n                    throw Error.error(ErrorCode.X_42584);\\n                }\\n                e.resolveTypes(session, null);\\n                if (e.isUnresolvedParam()) {\\n                    e.dataType = Type.SQL_VARCHAR;\\n                }\\n                if (e.dataType == null || !e.dataType.isCharacterType()) {\\n                    throw Error.error(ErrorCode.X_42563);\\n                }\\n                Expression[] args = new Expression[] {\\n                    e, null\\n                };\\n                return new StatementSession(\\n                    StatementTypes.SET_SESSION_AUTHORIZATION, args);\\n            }\\n            case Tokens.RESULT : {\\n                read();\\n                readThis(Tokens.MEMORY);\\n                readThis(Tokens.ROWS);\\n                Integer  size = readIntegerObject();\\n                Object[] args = new Object[]{ size };\\n                return new StatementSession(\\n                    StatementTypes.SET_SESSION_RESULT_MEMORY_ROWS, args);\\n            }\\n            default :\\n                throw unexpectedToken();\\n        }\\n    }\\n    private Statement compileSetRole() {\\n        Expression e;\\n        if (token.tokenType == Tokens.NONE) {\\n            read();\\n            e = new ExpressionValue(null, Type.SQL_VARCHAR);\\n        } else {\\n            e = XreadValueSpecificationOrNull();\\n            if (e == null) {\\n                throw Error.error(ErrorCode.X_2A000);\\n            }\\n            if (!e.getDataType().isCharacterType()) {\\n                throw Error.error(ErrorCode.X_0P000);\\n            }\\n            if (e.getType() != OpTypes.VALUE\\n                    && (e.getType() != OpTypes.SQL_FUNCTION\\n                        || !((FunctionSQL) e).isValueFunction())) {\\n                throw Error.error(ErrorCode.X_0P000);\\n            }\\n        }\\n        String sql = getLastPart();\\n        return new StatementSession(StatementTypes.SET_ROLE,\\n                                    new Expression[]{ e });\\n    }\\n    private Statement compileSetTimeZone() {\\n        Expression e;\\n        readThis(Tokens.ZONE);\\n        if (token.tokenType == Tokens.LOCAL) {\\n            read();\\n            e = new ExpressionValue(null, Type.SQL_INTERVAL_HOUR_TO_MINUTE);\\n        } else {\\n            e = XreadIntervalValueExpression();\\n            HsqlList unresolved = e.resolveColumnReferences(session,\\n                RangeVariable.emptyArray, null);\\n            ExpressionColumn.checkColumnsResolved(unresolved);\\n            e.resolveTypes(session, null);\\n            if (e.dataType == null) {\\n                throw Error.error(ErrorCode.X_42563);\\n            }\\n            if (e.dataType.typeCode != Types.SQL_INTERVAL_HOUR_TO_MINUTE) {\\n                throw Error.error(ErrorCode.X_42563);\\n            }\\n        }\\n        String sql = getLastPart();\\n        return new StatementSession(StatementTypes.SET_TIME_ZONE,\\n                                    new Expression[]{ e });\\n    }\\n    private Statement compileShutdown() {\\n        int closemode;\\n        session.checkAdmin();\\n        closemode = Database.CLOSEMODE_NORMAL;\\n        read();\\n        switch (token.tokenType) {\\n            case Tokens.IMMEDIATELY :\\n                closemode = Database.CLOSEMODE_IMMEDIATELY;\\n                read();\\n                break;\\n            case Tokens.COMPACT :\\n                closemode = Database.CLOSEMODE_COMPACT;\\n                read();\\n                break;\\n            case Tokens.SCRIPT :\\n                closemode = Database.CLOSEMODE_SCRIPT;\\n                read();\\n                break;\\n                    }\\n        if (token.tokenType == Tokens.SEMICOLON) {\\n            read();\\n        }\\n        if (token.tokenType != Tokens.X_ENDPARSE) {\\n            throw unexpectedToken();\\n        }\\n        String   sql  = getLastPart();\\n        Object[] args = new Object[]{ new Integer(closemode) };\\n        Statement cs = new StatementCommand(StatementTypes.DATABASE_SHUTDOWN,\\n                                            args, null, null);\\n        return cs;\\n    }\\n    private Statement compileBackup() {\\n        read();\\n        readThis(Tokens.DATABASE);\\n        readThis(Tokens.TO);\\n        String  path         = readQuotedString();\\n        Boolean blockingMode = null;            Boolean scriptMode   = null;            Boolean compression  = null;    \\n        outerLoop:\\n        while (true) {\\n            switch (token.tokenType) {\\n                case Tokens.BLOCKING :\\n                    if (blockingMode != null) {\\n                        throw unexpectedToken();\\n                    }\\n                    blockingMode = Boolean.TRUE;\\n                    read();\\n                    break;\\n                case Tokens.SCRIPT :\\n                    if (scriptMode != null) {\\n                        throw unexpectedToken();\\n                    }\\n                    scriptMode = Boolean.TRUE;\\n                    read();\\n                    break;\\n                case Tokens.COMPRESSED :\\n                    if (compression != null) {\\n                        throw unexpectedToken();\\n                    }\\n                    compression = Boolean.TRUE;\\n                    read();\\n                    break;\\n                case Tokens.NOT :\\n                    read();\\n                    if (token.tokenType == Tokens.COMPRESSED) {\\n                        if (compression != null) {\\n                            throw unexpectedToken();\\n                        }\\n                        compression = Boolean.FALSE;\\n                        read();\\n                    } else if (token.tokenType == Tokens.BLOCKING) {\\n                        blockingMode = Boolean.FALSE;\\n                        read();\\n                    } else {\\n                        throw unexpectedToken();\\n                    }\\n                    break;\\n                default :\\n                    break outerLoop;\\n            }\\n        }\\n        if (scriptMode != null) {\\n            throw unsupportedFeature(\\\"SCRIPT\\\");\\n        }\\n        scriptMode = Boolean.FALSE;\\n        if (blockingMode == null) {\\n            throw unexpectedTokenRequire(\\\"BLOCKING\\\");\\n        }\\n        if (compression == null) {\\n            compression = Boolean.TRUE;\\n        }\\n        HsqlName[] names =\\n            database.schemaManager.getCatalogAndBaseTableNames();\\n        Object[] args = new Object[] {\\n            path, blockingMode, scriptMode, compression,\\n        };\\n        Statement cs = new StatementCommand(StatementTypes.DATABASE_BACKUP,\\n                                            args, null, names);\\n        return cs;\\n    }\\n    private Statement compileCheckpoint() {\\n        boolean defrag = false;\\n        read();\\n        if (token.tokenType == Tokens.DEFRAG) {\\n            defrag = true;\\n            read();\\n        } else if (token.tokenType == Tokens.SEMICOLON) {\\n            read();\\n                    }\\n        if (token.tokenType != Tokens.X_ENDPARSE) {\\n            throw unexpectedToken();\\n        }\\n        HsqlName[] names =\\n            database.schemaManager.getCatalogAndBaseTableNames();\\n        Object[] args = new Object[]{ Boolean.valueOf(defrag) };\\n        Statement cs = new StatementCommand(StatementTypes.DATABASE_CHECKPOINT,\\n                                            args, null, names);\\n        return cs;\\n    }\\n    public static Statement getAutoCheckpointStatement(Database database) {\\n        HsqlName[] names =\\n            database.schemaManager.getCatalogAndBaseTableNames();\\n        Object[] args = new Object[]{ Boolean.FALSE };\\n        Statement cs = new StatementCommand(StatementTypes.DATABASE_CHECKPOINT,\\n                                            args, null, names);\\n        cs.setCompileTimestamp(database.txManager.getGlobalChangeTimestamp());\\n        cs.setSQL(Tokens.T_CHECKPOINT);\\n        return cs;\\n    }\\n    private Statement compileDisconnect() {\\n        read();\\n        String sql = Tokens.T_DISCONNECT;\\n        Statement cs = new StatementSession(StatementTypes.DISCONNECT,\\n                                            (Object[]) null);\\n        return cs;\\n    }\\n    private Statement compileExplainPlan() {\\n        Statement cs;\\n        read();\\n        readThis(Tokens.PLAN);\\n        readThis(Tokens.FOR);\\n        cs = compilePart(ResultProperties.defaultPropsValue);\\n        cs.setDescribe();\\n        return cs;\\n    }\\n    private Statement compileTableSource(Table t) {\\n        boolean  isSourceHeader = false;\\n        boolean  isDesc         = false;\\n        String   source;\\n        Object[] args = new Object[5];\\n        args[0] = t.getName();\\n        if (!t.isText()) {\\n            Exception e = Error.error(ErrorCode.X_S0522);\\n        }\\n                if (token.tokenType == Tokens.ON) {\\n            read();\\n            String sql = getLastPart();\\n            args[1] = Boolean.TRUE;\\n            return new StatementCommand(StatementTypes.SET_TABLE_SOURCE, args,\\n                                        null, new HsqlName[]{ t.getName() });\\n        } else if (token.tokenType == Tokens.OFF) {\\n            read();\\n            String sql = getLastPart();\\n            args[1] = Boolean.FALSE;\\n            return new StatementCommand(StatementTypes.SET_TABLE_SOURCE, args,\\n                                        null, new HsqlName[]{ t.getName() });\\n        } else if (token.tokenType == Tokens.HEADER) {\\n            read();\\n            isSourceHeader = true;\\n        }\\n        if (token.tokenType == Tokens.X_DELIMITED_IDENTIFIER) {\\n            source = token.tokenString;\\n            read();\\n        } else {\\n            source = readQuotedString();\\n        }\\n        if (!isSourceHeader && token.tokenType == Tokens.DESC) {\\n            isDesc = true;\\n            read();\\n        }\\n        String sql = getLastPart();\\n        args[2] = source;\\n        args[3] = Boolean.valueOf(isDesc);\\n        args[4] = Boolean.valueOf(isSourceHeader);\\n        int type = isSourceHeader ? StatementTypes.SET_TABLE_SOURCE_HEADER\\n                                  : StatementTypes.SET_TABLE_SOURCE;\\n        return new StatementCommand(type, args, null,\\n                                    new HsqlName[]{ t.getName() });\\n    }\\n}\""
            },
            "m13": {
                "content": "The code in `ParserCommand.java` confirms that it extends `ParserDDL`, which itself is part of the SQL parsing infrastructure. The class processes various types of SQL commands such as `SET`, `COMMIT`, `ROLLBACK`, `LOCK`, and others.\n\n### Key Observations:\n1. **Usage of Tokens**:\n   - There are several places where token constants like `Tokens.SET`, `Tokens.COMMIT`, `Tokens.ROLLBACK`, etc., are used.\n   - Example:\n     ```java\n     case Tokens.SET:\n         return compileSet();\n     ```\n\n2. **Command Handling Logic**:\n   - `ParserCommand` uses tokens to identify command types during parsing, suggesting a strong dependency on `Tokens.java`.\n\n3. **Consistency with Co-Change Relationship**:\n   - The high co-change confidence (0.477) between `Tokens.java` and `ParserCommand.java` aligns with the actual usage observed in the source code.\n\n---\n\n### Final Determination: Entities That Need Synchronization\n\nBased on our analysis of co-change relationships, call graphs, and direct source code inspection, we can confidently list the entities that should be synchronized when `Tokens.java` changes:\n\n#### \u2705 High Priority for Synchronization:\n1. **ParserDQL.java**  \n   - Strongest co-change relationship (confidence: 0.5227).\n   - Direct use of token constants (`SELECT`, `FROM`, `WHERE`, etc.) in parsing logic.\n\n2. **ParserCommand.java**  \n   - Second-highest co-change confidence (0.477).\n   - Uses many token definitions related to session commands (`SET`, `COMMIT`, `ROLLBACK`).\n\n3. **ParserDDL.java**  \n   - Part of the DDL parsing chain used by both `ParserDQL` and `ParserCommand`.\n   - Also shows a significant co-change confidence (0.3636).\n\n#### \u2705 Medium Priority for Synchronization:\n4. **Database.java**  \n   - Co-change support count = 17, confidence = 0.386.\n   - Likely involved in global token handling or SQL configuration.\n\n5. **Logger.java**, **Session.java**, **HsqlDatabaseProperties.java**  \n   - Moderate coupling; may handle logging, session state, or SQL dialect settings involving tokens.\n\n#### \u2705 Additional Entities Worth Reviewing:\n6. **StatementCommand.java**, **StatementDML.java**, **FunctionCustom.java**, **Expression.java**, **Table.java**, **Constraint.java**, **SchemaManager.java**, **ParserBase.java**, **StatementTypes.java**, **StatementSchema.java**, **StatementSession.java**, **SessionManager.java**, **UserManager.java**, **JDBCConnection.java**, **Log.java**, **ErrorCode.java**, **ScriptReaderText.java**, **ScriptWriterText.java**, **StringConverter.java**, **SortAndSlice.java**, **ExpressionColumn.java**, **Grantee.java**, **Routine.java**, **FunctionSQLInvoked.java**, **QuerySpecification.java**, **ParserRoutine.java**, **HsqlNameManager.java**, **CharacterType.java**, **NumberType.java**, **DateTimeType.java**, **ArrayType.java**, **ClobType.java**, **BlobType.java**\n\nThese additional entities appear in the co-change list with varying degrees of confidence and may warrant further inspection if changes in `Tokens.java` affect specific SQL constructs they rely on.\n\n---\n\n### Final Recommendation\n\nWhen modifying `Tokens.java`, you should **synchronize changes** with at least the following key files due to their high coupling and semantic similarity:\n\n- **ParserDQL.java**\n- **ParserCommand.java**\n- **ParserDDL.java**\n- **Database.java**\n- **Session.java**\n- **HsqlDatabaseProperties.java**\n\nThis ensures consistency in how SQL tokens are parsed and interpreted across the system.\n\nWould you like me to analyze one more entity (e.g., `ParserDDL.java`) to confirm its token usage?",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            },
            "m14": {
                "role": "user",
                "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
            },
            "m15": {
                "content": "Title: Diagnosis of starting entity `Tokens.java`  \nChange set: [ParserDQL.java, ParserCommand.java, Database.java, FunctionCustom.java, Logger.java, ParserDDL.java, StatementCommand.java, HsqlDatabaseProperties.java, Session.java, Routine.java, QuerySpecification.java, ExpressionColumn.java, Table.java, SchemaManager.java, StatementDML.java, UserManager.java, ParserBase.java, JDBCDriver.java, DataFileCache.java, StatementSchema.java, Expression.java, OpTypes.java, StatementTypes.java, CharacterType.java, NumberType.java, DateTimeType.java, ArrayType.java, ClobType.java, BlobType.java, Type.java, Types.java, ExpressionOp.java, SubQuery.java, ExpressionAggregate.java, ExpressionTable.java, Collation.java, StringUtil.java, StringConverter.java, SortAndSlice.java, ExpressionArrayAggregate.java, User.java, RangeVariableResolver.java, ScriptRunner.java, ScriptReaderText.java, ScriptWriterText.java, HsqlNameManager.java, Scanner.java, ErrorCode.java, LobManager.java, TransactionManagerMVCC.java]  \n\nDetails:  \n1. **ParserDQL.java**: Uses numerous token constants for parsing SQL queries (`SELECT`, `FROM`, etc.), and has a co-change confidence of 0.5227.  \n2. **ParserCommand.java**: Directly uses tokens like `SET`, `COMMIT`, `ROLLBACK`; co-change confidence = 0.4773.  \n3. **Database.java**: Manages global SQL settings and properties that may depend on token values; support count = 17, confidence = 0.386.  \n4. **FunctionCustom.java**: Handles custom function parsing which may involve token resolution; support count = 17, confidence = 0.386.  \n5. **Logger.java**: Likely logs SQL statements or errors using tokens; support count = 14, confidence = 0.318.  \n6. **ParserDDL.java**: Parses DDL commands involving tokens like `CREATE`, `ALTER`, `DROP`; support count = 16, confidence = 0.3636.  \n7. **StatementCommand.java**: Processes command-related SQL constructs; co-change relationship is significant.  \n8. **HsqlDatabaseProperties.java**: Manages database-level properties, some of which are tied to SQL syntax or token behavior.  \n9. **Session.java**: Handles session-specific SQL execution context, possibly relying on token definitions.  \n10. **Routine.java**: Involves stored routine parsing which often depends on SQL token definitions.  \n11. **QuerySpecification.java**: Used in query parsing and likely interacts with token-based expressions.  \n12. **ExpressionColumn.java**: Token usage occurs during column expression parsing.  \n13. **Table.java**: May use tokens in schema or constraint handling logic.  \n14. **SchemaManager.java**: Handles SQL schema objects and uses token-based identifiers.  \n15. **StatementDML.java**: Manages DML operations such as `INSERT`, `UPDATE`, `DELETE`.  \n16. **UserManager.java**: May handle authorization or user-defined SQL roles using tokens.  \n17. **ParserBase.java**: Base parser class\u2014likely contains shared token-handling logic.  \n18. **JDBCDriver.java**: JDBC interface layer that maps SQL tokens into Java types.  \n19. **DataFileCache.java**: Possibly involved in logging or scripting where token strings appear.  \n20. **StatementSchema.java**: Parses schema-related statements that include tokens.  \n21. **Expression.java**: Core class for representing parsed SQL expressions\u2014uses many token constants.  \n22. **OpTypes.java**: Defines operator types used alongside tokens for parsing and evaluation.  \n23. **StatementTypes.java**: Maps statement types using tokens\u2014strong semantic coupling.  \n24. **CharacterType.java**: Involved in character encoding/token mapping logic.  \n25. **NumberType.java**: Handles numeric literals, which are often tied to token definitions.  \n26. **DateTimeType.java**: Date/time SQL parsing involves specific token recognition.  \n27. **ArrayType.java**: Array-related SQL syntax requires token parsing.  \n28. **ClobType.java**, **BlobType.java**: LOB types have associated SQL syntax and token keywords.  \n29. **Type.java**, **Types.java**: Central to type parsing, which is tightly coupled with token usage.  \n30. **ExpressionOp.java**: Contains operators that map directly to token types.  \n31. **SubQuery.java**: Subquery parsing involves token-based clause detection.  \n32. **ExpressionAggregate.java**: Aggregation functions rely on token constants like `SUM`, `AVG`.  \n33. **ExpressionTable.java**: Used for table subquery processing and references tokens.  \n34. **Collation.java**: Parsing collation clauses involves token constants like `COLLATE`.  \n35. **StringUtil.java**: May be used for string manipulation related to token names.  \n36. **StringConverter.java**: Converts between SQL and Java types\u2014uses token-based directives.  \n37. **SortAndSlice.java**: Involves `ORDER BY`, `LIMIT`, and other token-based constructs.  \n38. **ExpressionArrayAggregate.java**: Related to array aggregation syntax involving tokens.  \n39. **User.java**: Authorization logic may parse SQL privilege tokens.  \n40. **RangeVariableResolver.java**: Resolves variable references during parsing\u2014token interaction likely.  \n41. **ScriptRunner.java**, **ScriptReaderText.java**, **ScriptWriterText.java**: Handle SQL scripts and therefore use token definitions.  \n42. **HsqlNameManager.java**: Name resolution may interact with token constants.  \n43. **Scanner.java**: Token scanner core component\u2014direct dependency expected.  \n44. **ErrorCode.java**: Error messages may reference tokens explicitly.  \n45. **LobManager.java**: LOB-related SQL syntax involves token parsing.  \n46. **TransactionManagerMVCC.java**: Transaction control may use SQL token constants.",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            }
        }
    }
}