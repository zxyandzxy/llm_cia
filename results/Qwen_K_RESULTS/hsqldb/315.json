{
    "time": 1749473180.6447535,
    "messages": [
        {
            "role": "system",
            "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
        },
        {
            "role": "user",
            "content": "The project you need to analyze is `hsqldb`, a well-known Java open source project. The starting entity you need to deal with is SqlFile.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
        },
        {
            "content": "",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_b6a2246d6c8045fba7477b",
                    "function": {
                        "arguments": "{\"entity\": \"SqlFile.java\"}",
                        "name": "get_co_change_relationship"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "name": "get_co_change_relationship",
            "role": "tool",
            "content": "[[\"RCData\", \"6\", \"0.16666666666666666\"], [\"AppendableException\", \"4\", \"0.1111111111111111\"], [\"SqlToolSprayer\", \"7\", \"0.19444444444444445\"], [\"BooleanBucket\", \"2\", \"0.05555555555555555\"], [\"SqlToolException\", \"2\", \"0.05555555555555555\"], [\"BadCmdline\", \"2\", \"0.05555555555555555\"], [\"ContinueException\", \"1\", \"0.027777777777777776\"], [\"BreakException\", \"1\", \"0.027777777777777776\"], [\"QuitNow\", \"1\", \"0.027777777777777776\"], [\"SqlToolError\", \"4\", \"0.1111111111111111\"], [\"ScriptWriterText\", \"1\", \"0.027777777777777776\"], [\"SqlTool\", \"26\", \"0.7222222222222222\"], [\"CSVWriter\", \"1\", \"0.027777777777777776\"], [\"MainInvoker\", \"1\", \"0.027777777777777776\"], [\"RowError\", \"3\", \"0.08333333333333333\"], [\"BadSpecial\", \"2\", \"0.05555555555555555\"], [\"BadSubst\", \"1\", \"0.027777777777777776\"], [\"ValidatingResourceBundle\", \"6\", \"0.16666666666666666\"], [\"RefCapablePropertyResourceBundle\", \"9\", \"0.25\"], [\"SqltoolRB\", \"13\", \"0.3611111111111111\"], [\"DatabaseManagerSwing\", \"1\", \"0.027777777777777776\"], [\"SqlFileScanner\", \"4\", \"0.1111111111111111\"], [\"DatabaseManager\", \"1\", \"0.027777777777777776\"], [\"SharedFields\", \"2\", \"0.05555555555555555\"], [\"SimpleLog\", \"1\", \"0.027777777777777776\"], [\"PrivateException\", \"1\", \"0.027777777777777776\"], [\"RB\", \"1\", \"0.027777777777777776\"], [\"TokenList\", \"2\", \"0.05555555555555555\"], [\"TarGenerator\", \"1\", \"0.027777777777777776\"], [\"TarHeaderFields\", \"1\", \"0.027777777777777776\"], [\"PIFData\", \"3\", \"0.08333333333333333\"], [\"TarFileOutputStream\", \"1\", \"0.027777777777777776\"], [\"TarFileInputStream\", \"1\", \"0.027777777777777776\"], [\"TarEntrySupplicant\", \"1\", \"0.027777777777777776\"], [\"DbBackup\", \"2\", \"0.05555555555555555\"], [\"TarReader\", \"1\", \"0.027777777777777776\"], [\"Token\", \"3\", \"0.08333333333333333\"], [\"TokenSource\", \"1\", \"0.027777777777777776\"], [\"Calculator\", \"1\", \"0.027777777777777776\"], [\"Atom\", \"1\", \"0.027777777777777776\"], [\"FrameworkLogger\", \"1\", \"0.027777777777777776\"], [\"AuthUtils\", \"1\", \"0.027777777777777776\"], [\"AuthBeanMultiplexer\", \"1\", \"0.027777777777777776\"], [\"ToolLogger\", \"1\", \"0.027777777777777776\"]]"
        },
        {
            "content": "The co-change relationships for `SqlFile.java` have been retrieved, and the results indicate various entities that are frequently modified together with `SqlFile.java`. The most significant co-changed entity is `SqlTool.java` with a high confidence of 0.72.\n\nTo proceed with the CIA task, we should investigate further how these co-changed entities are related to `SqlFile.java`. To understand the ripple effects, it's important to explore:\n\n1. **Call Graph**: Understand which entities are directly called or referenced by `SqlFile.java`.\n2. **Coupling Dependencies**: Analyze dependencies between `SqlFile.java` and the top co-changed entities (e.g., `SqlTool.java`, `SqltoolRB.java`, etc.) to determine if there are strong ties.\n3. **Conceptual Coupling**: Check semantic similarities between `SqlFile.java` and highly co-changed files to identify potential indirect impacts.\n\nLet us first examine the **call graph** of `SqlFile.java` to find out what entities it directly interacts with. \n\nI will now call the `get_call_graph` function on `SqlFile.java`. \n\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_52cc4191a5f54e8aa77c7e",
                    "function": {
                        "arguments": "{\"entity\": \"SqlFile.java\"}",
                        "name": "get_call_graph"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_call_graph",
            "content": "[]"
        },
        {
            "content": "The call graph for `SqlFile.java` is empty, which suggests that either:\n\n1. `SqlFile.java` does not directly invoke or reference any other entities in the current context.\n2. The parsing mechanism might have failed to extract the call information correctly.\n\nGiven this result, we need to further inspect the source code of `SqlFile.java` to understand its structure and identify potential interactions manually. This will help us determine if there are any implicit dependencies or reasons why certain files (like `SqlTool.java`) appear to be strongly co-changed with `SqlFile.java`.\n\nNext, I will retrieve the origin code of `SqlFile.java` for analysis:\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_6ef95cf41289419d92a27a",
                    "function": {
                        "arguments": "{\"entity\": \"SqlFile.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package org.hsqldb.util;\\nimport java.io.BufferedReader;\\nimport java.io.ByteArrayOutputStream;\\nimport java.io.File;\\nimport java.io.FileInputStream;\\nimport java.io.FileNotFoundException;\\nimport java.io.FileOutputStream;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nimport java.io.InputStreamReader;\\nimport java.io.OutputStreamWriter;\\nimport java.io.PrintStream;\\nimport java.io.PrintWriter;\\nimport java.io.UnsupportedEncodingException;\\nimport java.sql.Connection;\\nimport java.sql.DatabaseMetaData;\\nimport java.sql.PreparedStatement;\\nimport java.sql.ResultSet;\\nimport java.sql.ResultSetMetaData;\\nimport java.sql.SQLException;\\nimport java.sql.Statement;\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.Iterator;\\nimport java.util.List;\\nimport java.util.Set;\\nimport java.util.HashSet;\\nimport java.util.Map;\\nimport java.util.SortedMap;\\nimport java.util.TreeMap;\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\nimport java.util.regex.PatternSyntaxException;\\npublic class SqlFile {\\n    private static final int DEFAULT_HISTORY_SIZE = 40;\\n    private File             file;\\n    private boolean          interactive;\\n    private String           primaryPrompt    = \\\"sql> \\\";\\n    private String           rawPrompt      = null;\\n    private String           contPrompt       = \\\"  +> \\\";\\n    private Connection       curConn          = null;\\n    private boolean          htmlMode         = false;\\n    private Map              userVars;     private List             history          = null;\\n    private int              rawMode          = RAW_FALSE;\\n    private String           nullRepToken     = null;\\n    private String           dsvTargetFile    = null;\\n    private String           dsvTargetTable   = null;\\n    private String           dsvConstCols     = null;\\n    private String           dsvRejectFile    = null;\\n    private String           dsvRejectReport  = null;\\n    public static String     LS = System.getProperty(\\\"line.separator\\\");\\n    private int              maxHistoryLength = 1;\\n    private SqltoolRB        rb               = null;\\n    private static final int RAW_FALSE = 0;     private static final int RAW_EMPTY = 1;     private static final int RAW_DATA  = 2; \\n    private static Pattern   specialPattern   =\\n            Pattern.compile(\\\"\\\\\\\\s*\\\\\\\\\\\\\\\\(\\\\\\\\S+)(?:\\\\\\\\s+(.*\\\\\\\\S))?\\\\\\\\s*\\\");\\n    private static Pattern   plPattern   =\\n            Pattern.compile(\\\"\\\\\\\\s*\\\\\\\\*\\\\\\\\s*(.*\\\\\\\\S)?\\\\\\\\s*\\\");\\n    private static Pattern   foreachPattern   =\\n            Pattern.compile(\\\"\\\\\\\\s*\\\\\\\\*\\\\\\\\s*foreach\\\\\\\\s+(\\\\\\\\S+)\\\\\\\\s*\\\\\\\\(([^)]*)\\\\\\\\)\\\\\\\\s*\\\");\\n    private static Pattern   ifwhilePattern   =\\n            Pattern.compile(\\\"\\\\\\\\s*\\\\\\\\*\\\\\\\\s*\\\\\\\\S+\\\\\\\\s*\\\\\\\\(([^)]*)\\\\\\\\)\\\\\\\\s*\\\");\\n    private static Pattern   varsetPattern   =\\n            Pattern.compile(\\\"\\\\\\\\s*\\\\\\\\*\\\\\\\\s*(\\\\\\\\S+)\\\\\\\\s*([=_~])\\\\\\\\s*(?:(.*\\\\\\\\S)\\\\\\\\s*)?\\\");\\n    private static Pattern   substitutionPattern   =\\n            Pattern.compile(\\\"\\\\\\\\s*s(\\\\\\\\S)(.+?)\\\\\\\\1(.*?)\\\\\\\\1(.+)?\\\\\\\\s*\\\");\\n                private static Pattern wincmdPattern = null;\\n    static {\\n        if (System.getProperty(\\\"os.name\\\").startsWith(\\\"Windows\\\")) {\\n            wincmdPattern = Pattern.compile(\\\"([^\\\\\\\"]+)?(\\\\\\\"[^\\\\\\\"]*\\\\\\\")?\\\");\\n        }\\n    }\\n    private void updateUserSettings() {\\n        dsvSkipPrefix = SqlFile.convertEscapes(\\n                (String) userVars.get(\\\"*DSV_SKIP_PREFIX\\\"));\\n        if (dsvSkipPrefix == null) {\\n            dsvSkipPrefix = DEFAULT_SKIP_PREFIX;\\n        }\\n        dsvSkipCols = (String) userVars.get(\\\"*DSV_SKIP_COLS\\\");\\n        dsvColDelim =\\n            SqlFile.convertEscapes((String) userVars.get(\\\"*DSV_COL_DELIM\\\"));\\n        if (dsvColDelim == null) {\\n            dsvColDelim =\\n                SqlFile.convertEscapes((String) userVars.get(\\\"*CSV_COL_DELIM\\\"));\\n        }\\n        if (dsvColDelim == null) {\\n            dsvColDelim = DEFAULT_COL_DELIM;\\n        }\\n        dsvRowDelim =\\n            SqlFile.convertEscapes((String) userVars.get(\\\"*DSV_ROW_DELIM\\\"));\\n        if (dsvRowDelim == null) {\\n            dsvRowDelim =\\n                SqlFile.convertEscapes((String) userVars.get(\\\"*CSV_ROW_DELIM\\\"));\\n        }\\n        if (dsvRowDelim == null) {\\n            dsvRowDelim = DEFAULT_ROW_DELIM;\\n        }\\n        dsvTargetFile = (String) userVars.get(\\\"*DSV_TARGET_FILE\\\");\\n        if (dsvTargetFile == null) {\\n            dsvTargetFile = (String) userVars.get(\\\"*CSV_FILEPATH\\\");\\n        }\\n        dsvTargetTable = (String) userVars.get(\\\"*DSV_TARGET_TABLE\\\");\\n        if (dsvTargetTable == null) {\\n            dsvTargetTable = (String) userVars.get(\\\"*CSV_TABLENAME\\\");\\n                    }\\n        dsvConstCols = (String) userVars.get(\\\"*DSV_CONST_COLS\\\");\\n        dsvRejectFile = (String) userVars.get(\\\"*DSV_REJECT_FILE\\\");\\n        dsvRejectReport = (String) userVars.get(\\\"*DSV_REJECT_REPORT\\\");\\n        nullRepToken = (String) userVars.get(\\\"*NULL_REP_TOKEN\\\");\\n        if (nullRepToken == null) {\\n            nullRepToken = (String) userVars.get(\\\"*CSV_NULL_REP\\\");\\n        }\\n        if (nullRepToken == null) {\\n            nullRepToken = DEFAULT_NULL_REP;\\n        }\\n    }\\n    private static class BooleanBucket {\\n        BooleanBucket() {}\\n        private boolean bPriv = false;\\n        public void set(boolean bIn) {\\n            bPriv = bIn;\\n        }\\n        public boolean get() {\\n            return bPriv;\\n        }\\n    }\\n    BooleanBucket possiblyUncommitteds = new BooleanBucket();\\n    private static final String DIVIDER =\\n        \\\"-----------------------------------------------------------------\\\"\\n        + \\\"-----------------------------------------------------------------\\\";\\n        private static final String SPACES =\\n        \\\"                                                                 \\\"\\n        + \\\"                                                                 \\\";\\n        private static String revnum = null;\\n    static {\\n        revnum = \\\"$Revision: 315 $\\\".substring(\\\"$Revision: \\\".length(),\\n                \\\"$Revision: 315 $\\\".length() - 2);\\n    }\\n    private String DSV_OPTIONS_TEXT = null;\\n    private String D_OPTIONS_TEXT = null;\\n    private String RAW_LEADIN_MSG = null;\\n    public SqlFile(File inFile, boolean inInteractive, Map inVars)\\n            throws IOException {\\n                        try {\\n            rb = new SqltoolRB();\\n            rb.validate();\\n            rb.setMissingPosValueBehavior(\\n                    ValidatingResourceBundle.NOOP_BEHAVIOR);\\n            rb.setMissingPropertyBehavior(\\n                    ValidatingResourceBundle.NOOP_BEHAVIOR);\\n        } catch (RuntimeException re) {\\n            System.err.println(\\\"Failed to initialize resource bundle\\\");\\n            throw re;\\n        }\\n        rawPrompt = rb.getString(SqltoolRB.RAWMODE_PROMPT) + \\\"> \\\";\\n        DSV_OPTIONS_TEXT = rb.getString(SqltoolRB.DSV_OPTIONS);\\n        D_OPTIONS_TEXT = rb.getString(SqltoolRB.D_OPTIONS);\\n        RAW_LEADIN_MSG = rb.getString(SqltoolRB.RAW_LEADIN);\\n        DSV_X_SYNTAX_MSG = rb.getString(SqltoolRB.DSV_X_SYNTAX);\\n        DSV_M_SYNTAX_MSG = rb.getString(SqltoolRB.DSV_M_SYNTAX);\\n        nobufferYetString = rb.getString(SqltoolRB.NOBUFFER_YET);\\n        file        = inFile;\\n        interactive = inInteractive;\\n        userVars    = inVars;\\n        if (userVars == null) {\\n            userVars = new HashMap();\\n        }\\n        updateUserSettings();\\n        if (file != null &&!file.canRead()) {\\n            throw new IOException(rb.getString(SqltoolRB.SQLFILE_READFAIL,\\n                    new String[] {file.toString()} ));\\n        }\\n        if (interactive) {\\n            history = new ArrayList();\\n            String histLenString = System.getProperty(\\\"sqltool.historyLength\\\");\\n            if (histLenString != null) try {\\n                maxHistoryLength = Integer.parseInt(histLenString);\\n            } catch (Exception e) {\\n            } else {\\n                maxHistoryLength = DEFAULT_HISTORY_SIZE;\\n            }\\n        }\\n    }\\n    public SqlFile(boolean inInteractive, Map inVars) throws IOException {\\n        this(null, inInteractive, inVars);\\n    }\\n    public void execute(Connection conn,\\n                        Boolean coeOverride)\\n                        throws SqlToolError, SQLException {\\n        execute(conn, System.out, System.err, coeOverride);\\n    }\\n    public void execute(Connection conn,\\n                        boolean coeOverride)\\n                        throws SqlToolError, SQLException {\\n        execute(conn, System.out, System.err, new Boolean(coeOverride));\\n    }\\n        public boolean      recursed     = false;\\n    private String      lastSqlStatement   = null;\\n    private int         curLinenum   = -1;\\n    private PrintStream psStd        = null;\\n    private PrintStream psErr        = null;\\n    private PrintWriter pwQuery      = null;\\n    private PrintWriter pwDsv        = null;\\n    StringBuffer        immCmdSB     = new StringBuffer();\\n    private boolean             continueOnError = false;\\n    private static final String DEFAULT_CHARSET = null;\\n        private BufferedReader      br              = null;\\n    private String              charset         = null;\\n    private String              buffer          = null;\\n    private boolean             withholdPrompt  = false;\\n    public synchronized void execute(Connection conn, PrintStream stdIn,\\n                                     PrintStream errIn,\\n                                     Boolean coeOverride)\\n                                     throws SqlToolError,\\n                                         SQLException {\\n        psStd      = stdIn;\\n        psErr      = errIn;\\n        curConn    = conn;\\n        curLinenum = -1;\\n        String  inputLine;\\n        String  trimmedInput;\\n        String  deTerminated;\\n        boolean inComment = false;            int     postCommentIndex;\\n        boolean rollbackUncoms = true;\\n        continueOnError = (coeOverride == null) ? interactive\\n                                                : coeOverride.booleanValue();\\n        if (userVars.size() > 0) {\\n            plMode = true;\\n        }\\n        String specifiedCharSet = System.getProperty(\\\"sqlfile.charset\\\");\\n        charset = ((specifiedCharSet == null) ? DEFAULT_CHARSET\\n                                              : specifiedCharSet);\\n        try {\\n            br = new BufferedReader((charset == null)\\n                    ?  (new InputStreamReader((file == null)\\n                            ? System.in : (new FileInputStream(file))))\\n                    :  (new InputStreamReader(((file == null)\\n                            ? System.in : (new FileInputStream(file))),\\n                                    charset)));\\n                                    curLinenum = 0;\\n            if (interactive) {\\n                stdprintln(\\n                        rb.getString(SqltoolRB.SQLFILE_BANNER,\\n                        new String[] {revnum}));\\n            }\\n            while (true) {\\n                if (withholdPrompt) {\\n                    withholdPrompt = false;\\n                } else if (interactive) {\\n                    psStd.print((immCmdSB.length() > 0 || rawMode == RAW_DATA)\\n                            ? contPrompt : ((rawMode == RAW_FALSE)\\n                                    ? primaryPrompt : rawPrompt));\\n                }\\n                inputLine = br.readLine();\\n                if (inputLine == null) {\\n                    if (interactive) {\\n                        psStd.println();\\n                    }\\n                    break;\\n                }\\n                curLinenum++;\\n                if (inComment) {\\n                    postCommentIndex = inputLine.indexOf(\\\"*/\\\") + 2;\\n                    if (postCommentIndex > 1) {\\n                                                inputLine = inputLine.substring(postCommentIndex);\\n                                                                                                immCmdSB.setLength(0);\\n                        inComment = false;\\n                    } else {\\n                                                continue;\\n                    }\\n                }\\n                trimmedInput = inputLine.trim();\\n                try {\\n                    if (rawMode != RAW_FALSE) {\\n                        boolean rawExecute = inputLine.equals(\\\".;\\\");\\n                        if (rawExecute || inputLine.equals(\\\":.\\\")) {\\n                            if (rawMode == RAW_EMPTY) {\\n                                rawMode = RAW_FALSE;\\n                                throw new SqlToolError(\\n                                        rb.getString(SqltoolRB.RAW_EMPTY));\\n                            }\\n                            rawMode = RAW_FALSE;\\n                            setBuf(immCmdSB.toString());\\n                            immCmdSB.setLength(0);\\n                            if (rawExecute) {\\n                                historize();\\n                                processSQL();\\n                            } else if (interactive) {\\n                                stdprintln(rb.getString(\\n                                            SqltoolRB.RAW_MOVEDTOBUFFER));\\n                            }\\n                        } else {\\n                            if (rawMode == RAW_DATA) {\\n                                immCmdSB.append('\\\\n');\\n                            }\\n                            rawMode = RAW_DATA;\\n                            if (inputLine.length() > 0) {\\n                                immCmdSB.append(inputLine);\\n                            }\\n                        }\\n                        continue;\\n                    }\\n                    if (immCmdSB.length() == 0) {\\n                                            if (trimmedInput.startsWith(\\\"\\\", 2)\\n                                               + 2;\\n                            if (postCommentIndex > 1) {\\n                                                                                                inputLine = inputLine.substring(\\n                                    postCommentIndex + inputLine.length()\\n                                    - trimmedInput.length());\\n                                trimmedInput = inputLine.trim();\\n                            } else {\\n                                                                immCmdSB.append(\\\"COMMENT\\\");\\n                                inComment = true;\\n                                continue;\\n                            }\\n                        }\\n                        if (trimmedInput.length() == 0) {\\n                                                                                    continue;\\n                        }\\n                        if ((trimmedInput.charAt(0) == '*'\\n                                && (trimmedInput.length() < 2\\n                                    || trimmedInput.charAt(1) != '{'))\\n                                || trimmedInput.charAt(0) == '\\\\\\\\') {\\n                            setBuf(trimmedInput);\\n                            processFromBuffer();\\n                            continue;\\n                        }\\n                        if (trimmedInput.charAt(0) == ':' && interactive) {\\n                            processBuffHist(trimmedInput.substring(1));\\n                            continue;\\n                        }\\n                        String ucased = trimmedInput.toUpperCase();\\n                        if (ucased.startsWith(\\\"DECLARE\\\")\\n                                || ucased.startsWith(\\\"BEGIN\\\")) {\\n                            rawMode = RAW_EMPTY;\\n                            immCmdSB.append(inputLine);\\n                            if (interactive) {\\n                                stdprintln(RAW_LEADIN_MSG);\\n                            }\\n                            continue;\\n                        }\\n                    }\\n                    if (trimmedInput.length() == 0 && interactive &&!inComment) {\\n                                                                        setBuf(immCmdSB.toString());\\n                        immCmdSB.setLength(0);\\n                        stdprintln(rb.getString(SqltoolRB.INPUT_MOVEDTOBUFFER));\\n                        continue;\\n                    }\\n                    deTerminated = SqlFile.deTerminated(inputLine);\\n                                        if (!trimmedInput.equals(\\\";\\\")) {\\n                        if (immCmdSB.length() > 0) {\\n                            immCmdSB.append('\\\\n');\\n                        }\\n                        immCmdSB.append((deTerminated == null) ? inputLine\\n                                                                   : deTerminated);\\n                    }\\n                    if (deTerminated == null) {\\n                        continue;\\n                    }\\n                    if (immCmdSB.toString().trim().length() == 0) {\\n                        immCmdSB.setLength(0);\\n                        throw new SqlToolError(rb.getString(\\n                                    SqltoolRB.SQLSTATEMENT_EMPTY));\\n                                                                                                                                            }\\n                    setBuf(immCmdSB.toString());\\n                    immCmdSB.setLength(0);\\n                    historize();\\n                    processSQL();\\n                } catch (BadSpecial bs) {\\n                                        errprintln(rb.getString(SqltoolRB.ERRORAT_WITHECHO,\\n                            new String[] {\\n                                ((file == null) ? \\\"stdin\\\" : file.toString()),\\n                                Integer.toString(curLinenum),\\n                                inputLine,\\n                                bs.getMessage(),\\n                            }\\n                    ));\\n                    Throwable cause = bs.getCause();\\n                    if (cause != null) {\\n                        errprintln(rb.getString(SqltoolRB.CAUSEREPORT,\\n                                new String[] {cause.toString()}));\\n                    }\\n                    if (!continueOnError) {\\n                        throw new SqlToolError(bs);\\n                    }\\n                } catch (SQLException se) {\\n                    errprintln(\\\"SQL \\\" + rb.getString(\\n                            ((lastSqlStatement == null) ? SqltoolRB.ERRORAT\\n                                    : SqltoolRB.ERRORAT_WITHECHO),\\n                            ((lastSqlStatement == null) ? (\\n                                new String[] {\\n                                    ((file == null) ? \\\"stdin\\\" : file.toString()),\\n                                    Integer.toString(curLinenum),\\n                                    se.getMessage(),\\n                                }\\n                            ) : (\\n                                new String[] {\\n                                    ((file == null) ? \\\"stdin\\\" : file.toString()),\\n                                    Integer.toString(curLinenum),\\n                                    lastSqlStatement,\\n                                    se.getMessage(),\\n                                }\\n                            ))\\n                    ));\\n                    if (!continueOnError) {\\n                        throw se;\\n                    }\\n                } catch (BreakException be) {\\n                    String msg = be.getMessage();\\n                    if (recursed) {\\n                        rollbackUncoms = false;\\n                                                                                                                    } else if (msg == null || msg.equals(\\\"file\\\")) {\\n                        break;\\n                    } else {\\n                        errprintln(rb.getString(SqltoolRB.BREAK_UNSATISFIED,\\n                                new String[] { msg }));\\n                    }\\n                    if (recursed ||!continueOnError) {\\n                        throw be;\\n                    }\\n                } catch (ContinueException ce) {\\n                    String msg = ce.getMessage();\\n                    if (recursed) {\\n                        rollbackUncoms = false;\\n                    } else {\\n                        errprintln((msg == null)\\n                                ?  rb.getString(SqltoolRB.CONTINUE_UNSATISFIED)\\n                                : rb.getString(\\n                                        SqltoolRB.CONTINUE_UNSATISFIED_TYPED,\\n                                                new String[] {msg}\\n                                ));\\n                    }\\n                    if (recursed ||!continueOnError) {\\n                        throw ce;\\n                    }\\n                } catch (QuitNow qn) {\\n                    throw qn;\\n                } catch (SqlToolError ste) {\\n                    errprint(rb.getString(SqltoolRB.ERRORAT_WITHECHO,\\n                            new String[] {\\n                                ((file == null) ? \\\"stdin\\\" : file.toString()),\\n                                Integer.toString(curLinenum),\\n                                inputLine,\\n                                ((ste.getMessage() == null)\\n                                        ? \\\"\\\" : ste.getMessage())\\n                            }\\n                    ));\\n                    if (ste.getMessage() != null) errprintln(\\\"\\\");\\n                    Throwable cause = ste.getCause();\\n                    if (cause != null) {\\n                        errprintln(rb.getString(SqltoolRB.CAUSEREPORT,\\n                                new String[] {cause.toString()}));\\n                    }\\n                    if (!continueOnError) {\\n                        throw ste;\\n                    }\\n                }\\n                immCmdSB.setLength(0);\\n            }\\n            if (inComment || immCmdSB.length() != 0) {\\n                errprintln(rb.getString(SqltoolRB.INPUT_UNTERMINATED,\\n                        new String[] {immCmdSB.toString()}));\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.INPUT_UNTERMINATED,\\n                        new String[] {immCmdSB.toString()}));\\n            }\\n            rollbackUncoms = false;\\n                    } catch (IOException ioe) {\\n            throw new SqlToolError(rb.getString(\\n                    SqltoolRB.PRIMARYINPUT_ACCESSFAIL), ioe);\\n        } catch (QuitNow qn) {\\n            if (recursed) {\\n                throw qn;\\n                                            }\\n            rollbackUncoms = (qn.getMessage() != null);\\n            if (rollbackUncoms) {\\n                errprintln(rb.getString(SqltoolRB.ABORTING, new String[] {\\n                        qn.getMessage()}));\\n                throw new SqlToolError(qn.getMessage());\\n            }\\n            return;\\n        } finally {\\n            closeQueryOutputStream();\\n            if (fetchingVar != null) {\\n                errprintln(rb.getString(SqltoolRB.PLVAR_SET_INCOMPLETE,\\n                        new String[] {fetchingVar}));\\n                rollbackUncoms = true;\\n            }\\n            if (br != null) try {\\n                br.close();\\n            } catch (IOException ioe) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.INPUTREADER_CLOSEFAIL), ioe);\\n            }\\n            if (rollbackUncoms && possiblyUncommitteds.get()) {\\n                errprintln(rb.getString(SqltoolRB.ROLLINGBACK));\\n                curConn.rollback();\\n                possiblyUncommitteds.set(false);\\n            }\\n        }\\n    }\\n    private static String deTerminated(String inString) {\\n        int index = inString.lastIndexOf(';');\\n        if (index < 0) {\\n            return null;\\n        }\\n        for (int i = index + 1; i < inString.length(); i++) {\\n            if (!Character.isWhitespace(inString.charAt(i))) {\\n                return null;\\n            }\\n        }\\n        return inString.substring(0, index);\\n    }\\n    static private class BadSpecial extends AppendableException {\\n        static final long serialVersionUID = 7162440064026570590L;\\n        BadSpecial(String s) {\\n            super(s);\\n            if (s == null)\\n                throw new RuntimeException(\\n                        \\\"Must construct BadSpecials with non-null message\\\");\\n        }\\n        BadSpecial(String s, Throwable t) {\\n            super(s, t);\\n            if (s == null)\\n                throw new RuntimeException(\\n                        \\\"Must construct BadSpecials with non-null message\\\");\\n        }\\n    }\\n    private class QuitNow extends SqlToolError {\\n        static final long serialVersionUID = 1811094258670900488L;\\n        public QuitNow(String s) {\\n            super(s);\\n        }\\n        public QuitNow() {\\n            super();\\n        }\\n    }\\n    private class BreakException extends SqlToolError {\\n        static final long serialVersionUID = 351150072817675994L;\\n        public BreakException() {\\n            super();\\n        }\\n        public BreakException(String s) {\\n            super(s);\\n        }\\n    }\\n    private class ContinueException extends SqlToolError {\\n        static final long serialVersionUID = 5064604160827106014L;\\n        public ContinueException() {\\n            super();\\n        }\\n        public ContinueException(String s) {\\n            super(s);\\n        }\\n    }\\n    private class BadSubst extends Exception {\\n        static final long serialVersionUID = 7325933736897253269L;\\n        BadSubst(String s) {\\n            super(s);\\n        }\\n    }\\n    private class RowError extends AppendableException {\\n        static final long serialVersionUID = 754346434606022750L;\\n        RowError(String s) {\\n            super(s);\\n        }\\n        RowError(Throwable t) {\\n            this(null, t);\\n        }\\n        RowError(String s, Throwable t) {\\n            super(s, t);\\n        }\\n    }\\n    public void processFromBuffer()\\n            throws BadSpecial, SQLException, SqlToolError {\\n        historize();\\n        if (buffer.charAt(0) == '*' && (buffer.length() < 2\\n                || buffer.charAt(1) != '{')) {\\n                                    processPL(buffer);\\n            return;\\n        }\\n        if (buffer.charAt(0) == '\\\\\\\\') {\\n            processSpecial(buffer);\\n            return;\\n        }\\n        processSQL();\\n    }\\n    private void processBuffHist(String inString)\\n    throws BadSpecial, SQLException, SqlToolError {\\n        if (inString.length() < 1) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.SPECIAL_UNSPECIFIED));\\n        }\\n        char commandChar = inString.charAt(0);\\n        String other       = inString.substring(1);\\n        if (other.trim().length() == 0) {\\n            other = null;\\n        }\\n        switch (commandChar) {\\n            case ';' :\\n                enforce1charBH(other, ';');\\n                if (buffer == null) throw new BadSpecial(\\n                        rb.getString(SqltoolRB.NOBUFFER_YET));\\n                stdprintln(rb.getString(SqltoolRB.BUFFER_EXECUTING,\\n                        new String[] {buffer}));\\n                processFromBuffer();\\n                return;\\n            case 'a' :\\n                if (buffer == null) throw new BadSpecial(\\n                        rb.getString(SqltoolRB.NOBUFFER_YET));\\n                immCmdSB.append(buffer);\\n                if (other != null) {\\n                    String deTerminated = SqlFile.deTerminated(other);\\n                    if (!other.equals(\\\";\\\")) {\\n                        immCmdSB.append(((deTerminated == null)\\n                                ? other : deTerminated));\\n                    }\\n                    if (deTerminated != null) {\\n                        setBuf(immCmdSB.toString());\\n                        immCmdSB.setLength(0);\\n                        stdprintln(rb.getString(SqltoolRB.BUFFER_EXECUTING,\\n                                new String[] {buffer}));\\n                        processFromBuffer();\\n                        return;\\n                    }\\n                }\\n                withholdPrompt = true;\\n                stdprint(immCmdSB.toString());\\n                return;\\n            case 'l' :\\n            case 'b' :\\n                enforce1charBH(other, 'l');\\n                if (buffer == null) {\\n                    stdprintln(nobufferYetString);\\n                } else {\\n                    stdprintln(rb.getString(SqltoolRB.EDITBUFFER_CONTENTS,\\n                            new String[] {buffer}));\\n                }\\n                return;\\n            case 'h' :\\n                enforce1charBH(other, 'h');\\n                showHistory();\\n                return;\\n            case '-' :\\n            case '0' :\\n            case '1' :\\n            case '2' :\\n            case '3' :\\n            case '4' :\\n            case '5' :\\n            case '6' :\\n            case '7' :\\n            case '8' :\\n            case '9' :\\n                boolean executeMode =\\n                    inString.charAt(inString.length() - 1) == ';';\\n                String numStr = inString.substring(0,\\n                        inString.length() + (executeMode ? -1 : 0));\\n                try {\\n                    setBuf(commandFromHistory(Integer.parseInt(numStr)));\\n                } catch (NumberFormatException nfe) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.COMMANDNUM_MALFORMAT,\\n                            new String[] {numStr} ),\\n                    nfe);\\n                }\\n                if (executeMode) {\\n                    stdprintln(rb.getString(SqltoolRB.BUFFER_EXECUTING,\\n                            new String[] {buffer}));\\n                    processFromBuffer();\\n                } else {\\n                    stdprintln(rb.getString(SqltoolRB.BUFFER_RESTORED,\\n                            new String[] {buffer}));\\n                }\\n                return;\\n            case 'w' :\\n                if (other == null) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.DESTFILE_DEMAND));\\n                }\\n                if (buffer == null || buffer.length() == 0) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.BUFFER_EMPTY));\\n                }\\n                PrintWriter pw = null;\\n                try {\\n                    pw = new PrintWriter((charset == null)\\n                            ?  (new OutputStreamWriter(\\n                                    new FileOutputStream(other.trim(), true)))\\n                            :  (new OutputStreamWriter(\\n                                    new FileOutputStream(other.trim(), true),\\n                                            charset))\\n                                                                                                        );\\n                    pw.println(buffer);\\n                                                                                pw.flush();\\n                } catch (Exception e) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.FILE_APPENDFAIL,\\n                            new String[] {other.trim()}), e);\\n                } finally {\\n                    if (pw != null) pw.close();\\n                }\\n                return;\\n            case 's' :\\n                boolean modeExecute = false;\\n                boolean modeGlobal = false;\\n                try {\\n                    if (other == null || other.length() < 3) {\\n                        throw new BadSubst(rb.getString(\\n                                SqltoolRB.SUBSTITUTION_MALFORMAT));\\n                    }\\n                    Matcher m = substitutionPattern.matcher(inString);\\n                    if (buffer == null) {\\n                        stdprintln(nobufferYetString);\\n                        return;\\n                    }\\n                    if (!m.matches()) {\\n                        throw new BadSubst(rb.getString(\\n                                SqltoolRB.SUBSTITUTION_MALFORMAT));\\n                    }\\n                                        if (m.groupCount() < 3 || m.groupCount() > 4) {\\n                                                throw new RuntimeException(\\n                                \\\"Matched substitution pattern, but \\\"\\n                                + \\\"captured \\\" + m.groupCount() + \\\" groups\\\");\\n                    }\\n                    String optionGroup = (\\n                            (m.groupCount() > 3 && m.group(4) != null)\\n                            ? (new String(m.group(4))) : null);\\n                    if (optionGroup != null) {\\n                        if (optionGroup.indexOf(';') > -1) {\\n                            modeExecute = true;\\n                            optionGroup = optionGroup.replaceFirst(\\\";\\\", \\\"\\\");\\n                        }\\n                        if (optionGroup.indexOf('g') > -1) {\\n                            modeGlobal = true;\\n                            optionGroup = optionGroup.replaceFirst(\\\"g\\\", \\\"\\\");\\n                        }\\n                    }\\n                    Matcher bufferMatcher = Pattern.compile(\\\"(?s\\\"\\n                            + ((optionGroup == null) ? \\\"\\\" : optionGroup)\\n                            + ')' + m.group(2)).matcher(buffer);\\n                    String newBuffer = (modeGlobal\\n                            ? bufferMatcher.replaceAll(m.group(3))\\n                            : bufferMatcher.replaceFirst(m.group(3)));\\n                    if (newBuffer.equals(buffer)) {\\n                        stdprintln(rb.getString(\\n                                SqltoolRB.SUBSTITUTION_NOMATCH));\\n                        return;\\n                    }\\n                    setBuf(newBuffer);\\n                    stdprintln(rb.getString((modeExecute\\n                            ? SqltoolRB.BUFFER_EXECUTING\\n                            : SqltoolRB.EDITBUFFER_CONTENTS),\\n                                    new String[] {buffer})\\n                    );\\n                } catch (PatternSyntaxException pse) {\\n                    throw new BadSpecial(\\n                            rb.getString(SqltoolRB.SUBSTITUTION_SYNTAX), pse);\\n                } catch (BadSubst badswitch) {\\n                    throw new BadSpecial(\\n                            rb.getString(SqltoolRB.SUBSTITUTION_SYNTAX));\\n                }\\n                if (modeExecute) {\\n                    immCmdSB.setLength(0);\\n                    processFromBuffer();\\n                }\\n                return;\\n            case '?' :\\n                stdprintln(rb.getString(SqltoolRB.BUFFER_HELP));\\n                return;\\n        }\\n        throw new BadSpecial(rb.getString(SqltoolRB.BUFFER_UNKNOWN,\\n                new String[] { Character.toString(commandChar) }));\\n    }\\n    private boolean doPrepare   = false;\\n    private String  prepareVar  = null;\\n    private String  dsvColDelim = null;\\n    private String  dsvSkipPrefix = null;\\n    private String  dsvRowDelim = null;\\n    private String  dsvSkipCols = null;\\n    private String  DSV_X_SYNTAX_MSG = null;\\n    private String  DSV_M_SYNTAX_MSG = null;\\n    private String  nobufferYetString = null;\\n    private void enforce1charSpecial(String token, char command)\\n            throws BadSpecial {\\n        if (token.length() != 1) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.SPECIAL_EXTRACHARS,\\n                    new String[] { Character.toString(command),\\n                            token.substring(1) }));\\n        }\\n    }\\n    private void enforce1charBH(String token, char command)\\n            throws BadSpecial {\\n        if (token != null) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.BUFFER_EXTRACHARS,\\n                    new String[] { Character.toString(command), token }));\\n        }\\n    }\\n    private void processSpecial(String inString)\\n    throws BadSpecial, QuitNow, SQLException, SqlToolError {\\n        Matcher m = specialPattern.matcher(\\n                plMode ? dereference(inString, false) : inString);\\n        if (!m.matches()) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.SPECIAL_MALFORMAT));\\n                                }\\n        if (m.groupCount() < 1 || m.groupCount() > 2) {\\n                        throw new RuntimeException(\\n                    \\\"Pattern matched, yet captured \\\" + m.groupCount()\\n                    + \\\" groups\\\");\\n        }\\n        String arg1 = m.group(1);\\n        String other = ((m.groupCount() > 1) ? m.group(2) : null);\\n        switch (arg1.charAt(0)) {\\n            case 'q' :\\n                enforce1charSpecial(arg1, 'q');\\n                if (other != null) {\\n                    throw new QuitNow(other);\\n                }\\n                throw new QuitNow();\\n            case 'H' :\\n                enforce1charSpecial(arg1, 'H');\\n                htmlMode = !htmlMode;\\n                stdprintln(rb.getString(SqltoolRB.HTML_MODE, new String[] {\\n                        Boolean.toString(htmlMode)}));\\n                return;\\n            case 'm' :\\n                if (arg1.equals(\\\"m?\\\") ||\\n                        (arg1.equals(\\\"m\\\") && other != null\\n                                 && other.equals(\\\"?\\\"))) {\\n                    stdprintln(DSV_OPTIONS_TEXT + LS + DSV_M_SYNTAX_MSG);\\n                    return;\\n                }\\n                if (arg1.length() != 1 || other == null) {\\n                    throw new BadSpecial(DSV_M_SYNTAX_MSG);\\n                }\\n                boolean noComments = other.charAt(other.length() - 1) == '*';\\n                String skipPrefix = null;\\n                if (noComments) {\\n                    other = other.substring(0, other.length()-1).trim();\\n                    if (other.length() < 1) {\\n                        throw new BadSpecial(DSV_M_SYNTAX_MSG);\\n                    }\\n                } else {\\n                    skipPrefix = dsvSkipPrefix;\\n                }\\n                int colonIndex = other.indexOf(\\\" :\\\");\\n                if (colonIndex > -1 && colonIndex < other.length() - 2) {\\n                    skipPrefix = other.substring(colonIndex + 2);\\n                    other = other.substring(0, colonIndex).trim();\\n                }\\n                importDsv(other, skipPrefix);\\n                return;\\n            case 'x' :\\n                if (arg1.equals(\\\"x?\\\") ||\\n                        (arg1.equals(\\\"x\\\") && other != null\\n                                 && other.equals(\\\"?\\\"))) {\\n                    stdprintln(DSV_OPTIONS_TEXT + LS + DSV_X_SYNTAX_MSG);\\n                    return;\\n                }\\n                try {\\n                    if (arg1.length() != 1 || other == null) {\\n                        throw new BadSpecial(DSV_X_SYNTAX_MSG);\\n                    }\\n                    String tableName = ((other.indexOf(' ') > 0) ? null\\n                                                                 : other);\\n                    if (dsvTargetFile == null && tableName == null) {\\n                        throw new BadSpecial(rb.getString(\\n                                    SqltoolRB.DSV_TARGETFILE_DEMAND));\\n                    }\\n                    File dsvFile = new File((dsvTargetFile == null)\\n                                            ? (tableName + \\\".dsv\\\")\\n                                            : dsvTargetFile);\\n                    pwDsv = new PrintWriter((charset == null)\\n                       ? (new OutputStreamWriter(new FileOutputStream(dsvFile)))\\n                       : (new OutputStreamWriter(new FileOutputStream(dsvFile),\\n                               charset)));\\n                    ResultSet rs = curConn.createStatement().executeQuery(\\n                            (tableName == null) ? other\\n                                                : (\\\"SELECT * FROM \\\"\\n                                                   + tableName));\\n                    List colList = new ArrayList();\\n                    int[] incCols = null;\\n                    if (dsvSkipCols != null) {\\n                        Set ucSkipCols = new HashSet();\\n                        String[] skipCols = dsvSkipCols.split(\\\"\\\\\\\\s*\\\\\\\\Q\\\"\\n                                + dsvColDelim + \\\"\\\\\\\\E\\\\\\\\s*\\\");\\n                        for (int i = 0; i < skipCols.length; i++) {\\n                            ucSkipCols.add(skipCols[i].toUpperCase());\\n                        }\\n                        ResultSetMetaData rsmd = rs.getMetaData();\\n                        for (int i = 1; i <= rsmd.getColumnCount(); i++) {\\n                            if (!ucSkipCols.remove(rsmd.getColumnName(i))) {\\n                                colList.add(new Integer(i));\\n                            }\\n                        }\\n                        if (colList.size() < 1) {\\n                            throw new BadSpecial(rb.getString(\\n                                    SqltoolRB.DSV_NOCOLSLEFT,\\n                                    new String[] {dsvSkipCols}));\\n                        }\\n                        if (ucSkipCols.size() > 0) {\\n                            throw new BadSpecial(rb.getString(\\n                                    SqltoolRB.DSV_SKIPCOLS_MISSING,\\n                                        new String[] {ucSkipCols.toString()}));\\n                        }\\n                        incCols = new int[colList.size()];\\n                        for (int i = 0; i < incCols.length; i++) {\\n                            incCols[i] = ((Integer) colList.get(i)).intValue();\\n                        }\\n                    }\\n                    displayResultSet(null, rs, incCols, null);\\n                    pwDsv.flush();\\n                    stdprintln(rb.getString(SqltoolRB.FILE_WROTECHARS,\\n                            new String[] {\\n                                Long.toString(dsvFile.length()),\\n                                dsvFile.toString(),\\n                            }\\n                    ));\\n                } catch (FileNotFoundException e) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.FILE_WRITEFAIL,\\n                            new String[] {other}), e);\\n                } catch (UnsupportedEncodingException e) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.FILE_WRITEFAIL,\\n                            new String[] {other}), e);\\n                } finally {\\n                                        if (pwDsv != null) {\\n                        pwDsv.close();\\n                    }\\n                    pwDsv       = null;\\n                }\\n                return;\\n            case 'd' :\\n                if (arg1.equals(\\\"d?\\\") ||\\n                        (arg1.equals(\\\"d\\\") && other != null\\n                                 && other.equals(\\\"?\\\"))) {\\n                    stdprintln(D_OPTIONS_TEXT);\\n                    return;\\n                }\\n                if (arg1.length() == 2) {\\n                    listTables(arg1.charAt(1), other);\\n                    return;\\n                }\\n                if (arg1.length() == 1 && other != null) try {\\n                    int space = other.indexOf(' ');\\n                    if (space < 0) {\\n                        describe(other, null);\\n                    } else {\\n                        describe(other.substring(0, space),\\n                                 other.substring(space + 1).trim());\\n                    }\\n                    return;\\n                } catch (SQLException se) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.METADATA_FETCH_FAIL), se);\\n                }\\n                throw new BadSpecial(rb.getString(SqltoolRB.SPECIAL_D_LIKE));\\n            case 'o' :\\n                enforce1charSpecial(arg1, 'o');\\n                if (other == null) {\\n                    if (pwQuery == null) {\\n                        throw new BadSpecial(rb.getString(\\n                                SqltoolRB.OUTPUTFILE_NONETOCLOSE));\\n                    }\\n                    closeQueryOutputStream();\\n                    return;\\n                }\\n                if (pwQuery != null) {\\n                    stdprintln(rb.getString(SqltoolRB.OUTPUTFILE_REOPENING));\\n                    closeQueryOutputStream();\\n                }\\n                try {\\n                    pwQuery = new PrintWriter((charset == null)\\n                            ? (new OutputStreamWriter(\\n                                    new FileOutputStream(other, true)))\\n                            : (new OutputStreamWriter(\\n                                    new FileOutputStream(other, true), charset))\\n                    );\\n                    pwQuery.println((htmlMode\\n                            ? (\\\"<HTML>\\\" + LS + \\\"<!--\\\")\\n                            : \\\"#\\\") + \\\" \\\" + (new java.util.Date()) + \\\".  \\\"\\n                                    + rb.getString(SqltoolRB.OUTPUTFILE_HEADER,\\n                                            new String[] {getClass().getName()})\\n                                    + (htmlMode ? (\\\" -->\\\" + LS + LS + \\\"<BODY>\\\")\\n                                                : LS));\\n                    pwQuery.flush();\\n                } catch (Exception e) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.FILE_WRITEFAIL,\\n                            new String[] {other}), e);\\n                }\\n                return;\\n            case 'i' :\\n                enforce1charSpecial(arg1, 'i');\\n                if (other == null) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.SQLFILE_NAME_DEMAND));\\n                }\\n                try {\\n                    SqlFile sf = new SqlFile(new File(other), false, userVars);\\n                    sf.recursed = true;\\n                                        sf.possiblyUncommitteds = possiblyUncommitteds;\\n                    sf.plMode               = plMode;\\n                    sf.execute(curConn, continueOnError);\\n                } catch (ContinueException ce) {\\n                    throw ce;\\n                } catch (BreakException be) {\\n                    String beMessage = be.getMessage();\\n                                        if (beMessage != null &&!beMessage.equals(\\\"file\\\")) {\\n                        throw be;\\n                    }\\n                } catch (QuitNow qn) {\\n                    throw qn;\\n                } catch (Exception e) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.SQLFILE_EXECUTE_FAIL,\\n                            new String[] {other}), e);\\n                }\\n                return;\\n            case 'p' :\\n                enforce1charSpecial(arg1, 'p');\\n                if (other == null) {\\n                    stdprintln(true);\\n                } else {\\n                    stdprintln(other, true);\\n                }\\n                return;\\n            case 'a' :\\n                enforce1charSpecial(arg1, 'a');\\n                if (other != null) {\\n                    curConn.setAutoCommit(\\n                        Boolean.valueOf(other).booleanValue());\\n                }\\n                stdprintln(rb.getString(SqltoolRB.A_SETTING, new String[] {\\n                        Boolean.toString(curConn.getAutoCommit())}));\\n                return;\\n            case '=' :\\n                enforce1charSpecial(arg1, '=');\\n                curConn.commit();\\n                possiblyUncommitteds.set(false);\\n                stdprintln(rb.getString(SqltoolRB.COMMITTED));\\n                return;\\n            case 'b' :\\n                if (arg1.length() == 1) {\\n                    if (other != null) {\\n                        throw new BadSpecial(rb.getString(\\n                                SqltoolRB.SPECIAL_B_MALFORMAT));\\n                    }\\n                    fetchBinary = true;\\n                    return;\\n                }\\n                if (arg1.charAt(1) == 'p') {\\n                    if (other != null) {\\n                        throw new BadSpecial(rb.getString(\\n                                SqltoolRB.SPECIAL_B_MALFORMAT));\\n                    }\\n                    doPrepare = true;\\n                    return;\\n                }\\n                if ((arg1.charAt(1) != 'd' && arg1.charAt(1) != 'l')\\n                        || other == null) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.SPECIAL_B_MALFORMAT));\\n                }\\n                File file = new File(other);\\n                try {\\n                    if (arg1.charAt(1) == 'd') {\\n                        dump(file);\\n                    } else {\\n                        binBuffer = SqlFile.loadBinary(file);\\n                        stdprintln(rb.getString(\\n                                SqltoolRB.BINARY_LOADEDBYTESINTO,\\n                                new String[] {\\n                                    Integer.toString(binBuffer.length)\\n                                }));\\n                    }\\n                } catch (BadSpecial bs) {\\n                    throw bs;\\n                } catch (IOException ioe) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.BINARY_FILEFAIL,\\n                            new String[] {other}), ioe);\\n                }\\n                return;\\n            case '*' :\\n            case 'c' :\\n                enforce1charSpecial(arg1, '=');\\n                if (other != null) {\\n                                        continueOnError = Boolean.valueOf(other).booleanValue();\\n                }\\n                stdprintln(rb.getString(SqltoolRB.C_SETTING, new String[] {\\n                        Boolean.toString(continueOnError)}));\\n                return;\\n            case '?' :\\n                stdprintln(rb.getString(SqltoolRB.SPECIAL_HELP));\\n                return;\\n            case '!' :\\n                                                                                InputStream stream;\\n                byte[]      ba         = new byte[1024];\\n                String      extCommand = ((arg1.length() == 1)\\n                        ? \\\"\\\" : arg1.substring(1))\\n                    + ((arg1.length() > 1 && other != null)\\n                       ? \\\" \\\" : \\\"\\\") + ((other == null) ? \\\"\\\" : other);\\n                if (extCommand.trim().length() < 1)\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.BANG_INCOMPLETE));\\n                try {\\n                    Runtime runtime = Runtime.getRuntime();\\n                    Process proc = ((wincmdPattern == null)\\n                            ? runtime.exec(extCommand)\\n                            : runtime.exec(genWinArgs(extCommand))\\n                    );\\n                    proc.getOutputStream().close();\\n                    int i;\\n                    stream = proc.getInputStream();\\n                    while ((i = stream.read(ba)) > 0) {\\n                        stdprint(new String(ba, 0, i));\\n                    }\\n                    stream.close();\\n                    stream = proc.getErrorStream();\\n                    while ((i = stream.read(ba)) > 0) {\\n                        errprint(new String(ba, 0, i));\\n                    }\\n                    stream.close();\\n                    if (proc.waitFor() != 0) {\\n                        throw new BadSpecial(rb.getString(\\n                                SqltoolRB.BANG_COMMAND_FAIL,\\n                                new String[] {extCommand}));\\n                    }\\n                } catch (BadSpecial bs) {\\n                    throw bs;\\n                } catch (Exception e) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.BANG_COMMAND_FAIL,\\n                            new String[] {extCommand}), e);\\n                }\\n                return;\\n            case '.' :\\n                enforce1charSpecial(arg1, '.');\\n                rawMode = RAW_EMPTY;\\n                if (interactive) {\\n                    stdprintln(RAW_LEADIN_MSG);\\n                }\\n                return;\\n        }\\n        throw new BadSpecial(rb.getString(SqltoolRB.SPECIAL_UNKNOWN,\\n                new String[] { Character.toString(arg1.charAt(0)) }));\\n    }\\n    private static final char[] nonVarChars = {\\n        ' ', '\\\\t', '=', '}', '\\\\n', '\\\\r'\\n    };\\n    static int pastName(String inString, int startIndex) {\\n        String workString = inString.substring(startIndex);\\n        int    e          = inString.length();            int    nonVarIndex;\\n        for (int i = 0; i < nonVarChars.length; i++) {\\n            nonVarIndex = workString.indexOf(nonVarChars[i]);\\n            if (nonVarIndex > -1 && nonVarIndex < e) {\\n                e = nonVarIndex;\\n            }\\n        }\\n        return startIndex + e;\\n    }\\n    private String dereference(String inString,\\n                               boolean permitAlias) throws SqlToolError {\\n        String       varName, varValue;\\n        StringBuffer expandBuffer = new StringBuffer(inString);\\n        int          b, e;            int iterations;\\n        if (permitAlias && inString.trim().charAt(0) == '/') {\\n            int slashIndex = inString.indexOf('/');\\n            e = SqlFile.pastName(inString.substring(slashIndex + 1), 0);\\n                        if (e < 1) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.PLALIAS_MALFORMAT));\\n            }\\n            varName  = inString.substring(slashIndex + 1, slashIndex + 1 + e);\\n            varValue = (String) userVars.get(varName);\\n            if (varValue == null) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.PLVAR_UNDEFINED, new String[] {varName}));\\n            }\\n            expandBuffer.replace(slashIndex, slashIndex + 1 + e,\\n                                 (String) userVars.get(varName));\\n        }\\n        String s;\\n        boolean permitUnset;\\n        iterations = 0;\\n        while (true) {\\n            s = expandBuffer.toString();\\n            b = s.indexOf(\\\"${\\\");\\n            if (b < 0) {\\n                                break;\\n            }\\n            e = s.indexOf('}', b + 2);\\n            if (e == b + 2) {\\n                throw new SqlToolError(rb.getString(SqltoolRB.SYSPROP_EMPTY));\\n            }\\n            if (e < 0) {\\n                throw new SqlToolError(rb.getString(\\n                            SqltoolRB.SYSPROP_UNTERMINATED));\\n            }\\n            permitUnset = (s.charAt(b + 2) == ':');\\n            varName = s.substring(b + (permitUnset ? 3 : 2), e);\\n            if (iterations++ > 10000)\\n                throw new SqlToolError(rb.getString(SqltoolRB.VAR_INFINITE,\\n                        new String[] {varName}));\\n            varValue = System.getProperty(varName);\\n            if (varValue == null) {\\n                if (permitUnset) {\\n                    varValue = \\\"\\\";\\n                } else {\\n                    throw new SqlToolError(rb.getString(\\n                            SqltoolRB.SYSPROP_UNDEFINED,\\n                                    new String[] {varName}));\\n                }\\n            }\\n            expandBuffer.replace(b, e + 1, varValue);\\n        }\\n        iterations = 0;\\n        while (true) {\\n            s = expandBuffer.toString();\\n            b = s.indexOf(\\\"*{\\\");\\n            if (b < 0) {\\n                                break;\\n            }\\n            e = s.indexOf('}', b + 2);\\n            if (e == b + 2) {\\n                throw new SqlToolError(rb.getString(SqltoolRB.PLVAR_NAMEEMPTY));\\n            }\\n            if (e < 0) {\\n                throw new SqlToolError(rb.getString(\\n                            SqltoolRB.PLVAR_UNTERMINATED));\\n            }\\n            permitUnset = (s.charAt(b + 2) == ':');\\n            varName = s.substring(b + (permitUnset ? 3 : 2), e);\\n            if (iterations++ > 10000)\\n                throw new SqlToolError(rb.getString(SqltoolRB.VAR_INFINITE,\\n                        new String[] {varName}));\\n            varValue = (String) userVars.get(varName);\\n            if (varValue == null) {\\n                if (permitUnset) {\\n                    varValue = \\\"\\\";\\n                } else {\\n                    throw new SqlToolError(rb.getString(\\n                            SqltoolRB.PLVAR_UNDEFINED, new String[] {varName}));\\n                }\\n            }\\n            expandBuffer.replace(b, e + 1, varValue);\\n        }\\n        return expandBuffer.toString();\\n    }\\n    public boolean plMode = false;\\n        private String  fetchingVar = null;\\n    private boolean silentFetch = false;\\n    private boolean fetchBinary = false;\\n    private void processPL(String inString) throws BadSpecial, SqlToolError {\\n        Matcher m = plPattern.matcher(dereference(inString, false));\\n        if (!m.matches()) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.PL_MALFORMAT));\\n                                }\\n        if (m.groupCount() < 1 || m.group(1) == null) {\\n            plMode = true;\\n            stdprintln(rb.getString(SqltoolRB.PL_EXPANSIONMODE,\\n                   new String[] {\\\"on\\\"}));\\n            return;\\n        }\\n        String[] tokens = m.group(1).split(\\\"\\\\\\\\s+\\\");\\n        if (tokens[0].charAt(0) == '?') {\\n            stdprintln(rb.getString(SqltoolRB.PL_HELP));\\n            return;\\n        }\\n                plMode = true;\\n        if (tokens[0].equals(\\\"end\\\")) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.END_NOBLOCK));\\n        }\\n        if (tokens[0].equals(\\\"continue\\\")) {\\n            if (tokens.length > 1) {\\n                if (tokens.length == 2 &&\\n                        (tokens[1].equals(\\\"foreach\\\") ||\\n                         tokens[1].equals(\\\"while\\\"))) {\\n                    throw new ContinueException(tokens[1]);\\n                }\\n                throw new BadSpecial(rb.getString(SqltoolRB.CONTINUE_SYNTAX));\\n            }\\n            throw new ContinueException();\\n        }\\n        if (tokens[0].equals(\\\"break\\\")) {\\n            if (tokens.length > 1) {\\n                if (tokens.length == 2 &&\\n                        (tokens[1].equals(\\\"foreach\\\") ||\\n                         tokens[1].equals(\\\"if\\\") ||\\n                         tokens[1].equals(\\\"while\\\") ||\\n                         tokens[1].equals(\\\"file\\\"))) {\\n                    throw new BreakException(tokens[1]);\\n                }\\n                throw new BadSpecial(rb.getString(SqltoolRB.BREAK_SYNTAX));\\n            }\\n            throw new BreakException();\\n        }\\n        if (tokens[0].equals(\\\"list\\\") || tokens[0].equals(\\\"listvalues\\\")\\n                || tokens[0].equals(\\\"listsysprops\\\")) {\\n            boolean sysProps =tokens[0].equals(\\\"listsysprops\\\");\\n            String  s;\\n            boolean doValues = (tokens[0].equals(\\\"listvalues\\\") || sysProps);\\n            if (tokens.length == 1) {\\n                stdprint(formatNicely(\\n                        (sysProps ? System.getProperties() : userVars),\\n                        doValues));\\n            } else {\\n                if (doValues) {\\n                    stdprintln(rb.getString(SqltoolRB.PL_LIST_PARENS));\\n                } else {\\n                    stdprintln(rb.getString(SqltoolRB.PL_LIST_LENGTHS));\\n                }\\n                for (int i = 1; i < tokens.length; i++) {\\n                    s = (String) (sysProps ? System.getProperties() : userVars).\\n                            get(tokens[i]);\\n                    if (s == null) continue;\\n                    stdprintln(\\\"    \\\" + tokens[i] + \\\": \\\"\\n                               + (doValues ? (\\\"(\\\" + s + ')')\\n                                           : Integer.toString(s.length())));\\n                }\\n            }\\n            return;\\n        }\\n        if (tokens[0].equals(\\\"dump\\\") || tokens[0].equals(\\\"load\\\")) {\\n            if (tokens.length != 3) {\\n                throw new BadSpecial(rb.getString(\\n                        SqltoolRB.DUMPLOAD_MALFORMAT));\\n            }\\n            String varName = tokens[1];\\n            if (varName.indexOf(':') > -1) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.PLVAR_NOCOLON));\\n            }\\n            File   file    = new File(tokens[2]);\\n            try {\\n                if (tokens[0].equals(\\\"dump\\\")) {\\n                    dump(varName, file);\\n                } else {\\n                    load(varName, file, charset);\\n                }\\n            } catch (IOException ioe) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.DUMPLOAD_FAIL,\\n                        new String[] { varName, file.toString() }), ioe);\\n            }\\n            return;\\n        }\\n        if (tokens[0].equals(\\\"prepare\\\")) {\\n            if (tokens.length != 2) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.PREPARE_MALFORMAT));\\n            }\\n            if (userVars.get(tokens[1]) == null) {\\n                throw new BadSpecial(rb.getString(\\n                    SqltoolRB.PLVAR_UNDEFINED, new String[] {tokens[1]}));\\n            }\\n            prepareVar = tokens[1];\\n            doPrepare  = true;\\n            return;\\n        }\\n        if (tokens[0].equals(\\\"foreach\\\")) {\\n            Matcher foreachM= foreachPattern.matcher(\\n                    dereference(inString, false));\\n            if (!foreachM.matches()) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.FOREACH_MALFORMAT));\\n            }\\n            if (foreachM.groupCount() != 2) {\\n                throw new RuntimeException(\\n                        \\\"foreach pattern matched, but captured \\\"\\n                        + foreachM.groupCount() + \\\" groups\\\");\\n            }\\n            String varName   = foreachM.group(1);\\n            if (varName.indexOf(':') > -1) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.PLVAR_NOCOLON));\\n            }\\n            String[] values = foreachM.group(2).split(\\\"\\\\\\\\s+\\\");\\n            File   tmpFile = null;\\n            String varVal;\\n            try {\\n                tmpFile = plBlockFile(\\\"foreach\\\");\\n            } catch (IOException ioe) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.PL_TEMPFILE_FAIL),\\n                    ioe);\\n            }\\n            String origval = (String) userVars.get(varName);\\n            try {\\n                SqlFile sf;\\n                for (int i = 0; i < values.length; i++) {\\n                    try {\\n                        varVal = values[i];\\n                        userVars.put(varName, varVal);\\n                        updateUserSettings();\\n                        sf          = new SqlFile(tmpFile, false, userVars);\\n                        sf.plMode   = true;\\n                        sf.recursed = true;\\n                                                sf.possiblyUncommitteds = possiblyUncommitteds;\\n                        sf.execute(curConn, continueOnError);\\n                    } catch (ContinueException ce) {\\n                        String ceMessage = ce.getMessage();\\n                        if (ceMessage != null\\n                                &&!ceMessage.equals(\\\"foreach\\\")) {\\n                            throw ce;\\n                        }\\n                    }\\n                }\\n            } catch (BreakException be) {\\n                String beMessage = be.getMessage();\\n                                if (beMessage != null &&!beMessage.equals(\\\"foreach\\\")) {\\n                    throw be;\\n                }\\n            } catch (QuitNow qn) {\\n                throw qn;\\n            } catch (Exception e) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.PL_BLOCK_FAIL), e);\\n            }\\n            if (origval == null) {\\n                userVars.remove(varName);\\n                updateUserSettings();\\n            } else {\\n                userVars.put(varName, origval);\\n            }\\n            if (tmpFile != null &&!tmpFile.delete()) {\\n                throw new BadSpecial(rb.getString(\\n                        SqltoolRB.TEMPFILE_REMOVAL_FAIL,\\n                                new String[] {tmpFile.toString()} ));\\n            }\\n            return;\\n        }\\n        if (tokens[0].equals(\\\"if\\\") || tokens[0].equals(\\\"while\\\")) {\\n            Matcher ifwhileM= ifwhilePattern.matcher(\\n                    dereference(inString, false));\\n            if (!ifwhileM.matches()) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.IFWHILE_MALFORMAT));\\n            }\\n            if (ifwhileM.groupCount() != 1) {\\n                throw new RuntimeException(\\n                        \\\"if/while pattern matched, but captured \\\"\\n                        + ifwhileM.groupCount() + \\\" groups\\\");\\n            }\\n            String[] values =\\n                    ifwhileM.group(1).replaceAll(\\\"!([a-zA-Z0-9*])\\\", \\\"! $1\\\").\\n                            replaceAll(\\\"([a-zA-Z0-9*])!\\\", \\\"$1 !\\\").split(\\\"\\\\\\\\s+\\\");\\n            File tmpFile = null;\\n            if (tokens[0].equals(\\\"if\\\")) {\\n                try {\\n                    tmpFile = plBlockFile(\\\"if\\\");\\n                } catch (IOException ioe) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.PL_BLOCK_FAIL),\\n                            ioe);\\n                }\\n                try {\\n                    if (eval(values)) {\\n                        SqlFile sf = new SqlFile(tmpFile, false, userVars);\\n                        sf.plMode   = true;\\n                        sf.recursed = true;\\n                                                sf.possiblyUncommitteds = possiblyUncommitteds;\\n                        sf.execute(curConn, continueOnError);\\n                    }\\n                } catch (BreakException be) {\\n                    String beMessage = be.getMessage();\\n                                        if (beMessage == null ||!beMessage.equals(\\\"if\\\")) {\\n                        throw be;\\n                    }\\n                } catch (ContinueException ce) {\\n                    throw ce;\\n                } catch (QuitNow qn) {\\n                    throw qn;\\n                } catch (BadSpecial bs) {\\n                    bs.appendMessage(rb.getString(SqltoolRB.IF_MALFORMAT));\\n                    throw bs;\\n                } catch (Exception e) {\\n                    throw new BadSpecial(\\n                        rb.getString(SqltoolRB.PL_BLOCK_FAIL), e);\\n                }\\n            } else if (tokens[0].equals(\\\"while\\\")) {\\n                try {\\n                    tmpFile = plBlockFile(\\\"while\\\");\\n                } catch (IOException ioe) {\\n                    throw new BadSpecial(\\n                        rb.getString(SqltoolRB.PL_TEMPFILE_FAIL), ioe);\\n                }\\n                try {\\n                    SqlFile sf;\\n                    while (eval(values)) {\\n                        try {\\n                            sf          = new SqlFile(tmpFile, false, userVars);\\n                            sf.recursed = true;\\n                                                        sf.possiblyUncommitteds = possiblyUncommitteds;\\n                            sf.plMode               = true;\\n                            sf.execute(curConn, continueOnError);\\n                        } catch (ContinueException ce) {\\n                            String ceMessage = ce.getMessage();\\n                            if (ceMessage != null &&!ceMessage.equals(\\\"while\\\")) {\\n                                throw ce;\\n                            }\\n                        }\\n                    }\\n                } catch (BreakException be) {\\n                    String beMessage = be.getMessage();\\n                                        if (beMessage != null &&!beMessage.equals(\\\"while\\\")) {\\n                        throw be;\\n                    }\\n                } catch (QuitNow qn) {\\n                    throw qn;\\n                } catch (BadSpecial bs) {\\n                    bs.appendMessage(rb.getString(SqltoolRB.WHILE_MALFORMAT));\\n                    throw bs;\\n                } catch (Exception e) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.PL_BLOCK_FAIL),\\n                            e);\\n                }\\n            } else {\\n                                throw new RuntimeException(rb.getString(SqltoolRB.PL_UNKNOWN,\\n                        new String[] {tokens[0]}));\\n            }\\n            if (tmpFile != null &&!tmpFile.delete()) {\\n                throw new BadSpecial(rb.getString(\\n                        SqltoolRB.TEMPFILE_REMOVAL_FAIL, new String[] {\\n                                tmpFile.toString()}));\\n            }\\n            return;\\n        }\\n        m = varsetPattern.matcher(dereference(inString, false));\\n        if (!m.matches()) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.PL_UNKNOWN,\\n                    new String[] {tokens[0]}));\\n        }\\n        if (m.groupCount() < 2 || m.groupCount() > 3) {\\n                        throw new RuntimeException(\\\"varset pattern matched but captured \\\"\\n                    + m.groupCount() + \\\" groups\\\");\\n        }\\n        String varName  = m.group(1);\\n        if (varName.indexOf(':') > -1) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.PLVAR_NOCOLON));\\n        }\\n        switch (m.group(2).charAt(0)) {\\n            case '_' :\\n                silentFetch = true;\\n            case '~' :\\n                if (m.groupCount() > 2 && m.group(3) != null) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.PLVAR_TILDEDASH_NOMOREARGS, new String[] {\\n                                m.group(3)}));\\n                }\\n                userVars.remove(varName);\\n                updateUserSettings();\\n                fetchingVar = varName;\\n                return;\\n            case '=' :\\n                if (fetchingVar != null && fetchingVar.equals(varName)) {\\n                    fetchingVar = null;\\n                }\\n                if (m.groupCount() > 2 && m.group(3) != null) {\\n                    userVars.put(varName, m.group(3));\\n                } else {\\n                    userVars.remove(varName);\\n                }\\n                updateUserSettings();\\n                return;\\n        }\\n        throw new BadSpecial(rb.getString(SqltoolRB.PL_UNKNOWN,\\n                new String[] {tokens[0]}));\\n            }\\n    private File plBlockFile(String seeking) throws IOException, SqlToolError {\\n        String          s;\\n                                int    nestlevel = 1;\\n        String curPlCommand;\\n        if (seeking == null\\n                || ((!seeking.equals(\\\"foreach\\\")) && (!seeking.equals(\\\"if\\\"))\\n                    && (!seeking.equals(\\\"while\\\")))) {\\n            throw new RuntimeException(\\n                \\\"Assertion failed.  Unsupported PL block type:  \\\" + seeking);\\n        }\\n        File tmpFile = File.createTempFile(\\\"sqltool-\\\", \\\".sql\\\");\\n        PrintWriter pw = new PrintWriter((charset == null)\\n                ?  (new OutputStreamWriter(new FileOutputStream(tmpFile)))\\n                :  (new OutputStreamWriter(new FileOutputStream(tmpFile),\\n                        charset)));\\n        try {\\n        pw.println(\\\"\\\");\\n        pw.println();\\n        Matcher m;\\n        while (true) {\\n            s = br.readLine();\\n            if (s == null) {\\n                s = rb.getString(SqltoolRB.PL_BLOCK_UNTERMINATED,\\n                        new String[] {seeking});\\n                errprintln(s);\\n                throw new SqlToolError(s);\\n            }\\n            curLinenum++;\\n            m = plPattern.matcher(s);\\n            if (m.matches() && m.groupCount() > 0 && m.group(1) != null) {\\n                String[] tokens = m.group(1).split(\\\"\\\\\\\\s+\\\");\\n                curPlCommand = tokens[0];\\n                                if (curPlCommand.equals(seeking)) {\\n                    nestlevel++;\\n                } else if (curPlCommand.equals(\\\"end\\\")) {\\n                    if (tokens.length < 2) {\\n                        s = rb.getString(SqltoolRB.END_SYNTAX,\\n                                new String[] {\\\"1\\\"});\\n                        errprintln(s);\\n                        throw new SqlToolError(s);\\n                    }\\n                    String inType = tokens[1];\\n                    if (inType.equals(seeking)) {\\n                        nestlevel--;\\n                        if (nestlevel < 1) {\\n                            break;\\n                        }\\n                    }\\n                    if ((!inType.equals(\\\"foreach\\\")) && (!inType.equals(\\\"if\\\"))\\n                            && (!inType.equals(\\\"while\\\"))) {\\n                        s = rb.getString(SqltoolRB.END_SYNTAX,\\n                                new String[] {\\\"2\\\"});\\n                        errprintln(s);\\n                        throw new SqlToolError(s);\\n                    }\\n                }\\n            }\\n            pw.println(s);\\n        }\\n        pw.flush();\\n        } finally {\\n            pw.close();\\n        }\\n        return tmpFile;\\n    }\\n    private void stdprintln() {\\n        stdprintln(false);\\n    }\\n    private void stdprint(String s) {\\n        stdprint(s, false);\\n    }\\n    private void stdprintln(String s) {\\n        stdprintln(s, false);\\n    }\\n    private void stdprintln(boolean queryOutput) {\\n        if (htmlMode) {\\n            psStd.println(\\\"<BR>\\\");\\n        } else {\\n            psStd.println();\\n        }\\n        if (queryOutput && pwQuery != null) {\\n            if (htmlMode) {\\n                pwQuery.println(\\\"<BR>\\\");\\n            } else {\\n                pwQuery.println();\\n            }\\n            pwQuery.flush();\\n        }\\n    }\\n    private void errprint(String s) {\\n        psErr.print(htmlMode\\n                    ? (\\\"<DIV style='color:white; background: red; \\\"\\n                       + \\\"font-weight: bold'>\\\" + s + \\\"</DIV>\\\")\\n                    : s);\\n    }\\n    private void errprintln(String s) {\\n        psErr.println(htmlMode\\n                      ? (\\\"<DIV style='color:white; background: red; \\\"\\n                         + \\\"font-weight: bold'>\\\" + s + \\\"</DIV>\\\")\\n                      : s);\\n    }\\n    private void stdprint(String s, boolean queryOutput) {\\n        psStd.print(htmlMode ? (\\\"<P>\\\" + s + \\\"</P>\\\")\\n                             : s);\\n        if (queryOutput && pwQuery != null) {\\n            pwQuery.print(htmlMode ? (\\\"<P>\\\" + s + \\\"</P>\\\")\\n                                   : s);\\n            pwQuery.flush();\\n        }\\n    }\\n    private void stdprintln(String s, boolean queryOutput) {\\n        psStd.println(htmlMode ? (\\\"<P>\\\" + s + \\\"</P>\\\")\\n                               : s);\\n        if (queryOutput && pwQuery != null) {\\n            pwQuery.println(htmlMode ? (\\\"<P>\\\" + s + \\\"</P>\\\")\\n                                     : s);\\n            pwQuery.flush();\\n        }\\n    }\\n                private static final String DEFAULT_NULL_REP = \\\"[null]\\\";\\n    private static final String DEFAULT_ROW_DELIM = LS;\\n    private static final String DEFAULT_COL_DELIM = \\\"|\\\";\\n    private static final String DEFAULT_SKIP_PREFIX = \\\"#\\\";\\n    private static final int    DEFAULT_ELEMENT   = 0,\\n                                HSQLDB_ELEMENT    = 1,\\n                                ORACLE_ELEMENT    = 2\\n    ;\\n        private static final int[] listMDSchemaCols = { 1 };\\n    private static final int[] listMDIndexCols  = {\\n        2, 6, 3, 9, 4, 10, 11\\n    };\\n    private static final int[][] listMDTableCols = {\\n        {\\n            2, 3\\n        },            {\\n            2, 3\\n        },            {\\n            2, 3\\n        },        };\\n    private static final String[] oracleSysSchemas = {\\n        \\\"SYS\\\", \\\"SYSTEM\\\", \\\"OUTLN\\\", \\\"DBSNMP\\\", \\\"OUTLN\\\", \\\"MDSYS\\\", \\\"ORDSYS\\\",\\n        \\\"ORDPLUGINS\\\", \\\"CTXSYS\\\", \\\"DSSYS\\\", \\\"PERFSTAT\\\", \\\"WKPROXY\\\", \\\"WKSYS\\\",\\n        \\\"WMSYS\\\", \\\"XDB\\\", \\\"ANONYMOUS\\\", \\\"ODM\\\", \\\"ODM_MTR\\\", \\\"OLAPSYS\\\", \\\"TRACESVR\\\",\\n        \\\"REPADMIN\\\"\\n    };\\n    private void listTables(char c, String inFilter) throws BadSpecial,\\n            SqlToolError {\\n        String   schema  = null;\\n        int[]    listSet = null;\\n        String[] types   = null;\\n        String[] additionalSchemas = null;\\n        Statement statement = null;\\n        ResultSet rs        = null;\\n        String    narrower  = \\\"\\\";\\n        String filter = inFilter;\\n        try {\\n            DatabaseMetaData md            = curConn.getMetaData();\\n            String           dbProductName = md.getDatabaseProductName();\\n            types = new String[1];\\n            switch (c) {\\n                case '*' :\\n                    types = null;\\n                    break;\\n                case 'S' :\\n                    if (dbProductName.indexOf(\\\"Oracle\\\") > -1) {\\n                        errprintln(rb.getString(SqltoolRB.VENDOR_ORACLE_DS));\\n                        types[0]          = \\\"TABLE\\\";\\n                        schema            = \\\"SYS\\\";\\n                        additionalSchemas = oracleSysSchemas;\\n                    } else {\\n                        types[0] = \\\"SYSTEM TABLE\\\";\\n                    }\\n                    break;\\n                case 's' :\\n                    if (dbProductName.indexOf(\\\"HSQL\\\") > -1) {\\n                                                                                                if (filter != null\\n                                && filter.charAt(filter.length() - 1)\\n                                   == '.') {\\n                            narrower =\\n                                \\\"\\\\nWHERE sequence_schema = '\\\"\\n                                + filter.substring(0, filter.length() - 1)\\n                                + \\\"'\\\";\\n                            filter = null;\\n                        }\\n                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT sequence_schema, sequence_name FROM \\\"\\n                            + \\\"information_schema.system_sequences\\\"\\n                            + narrower);\\n                    } else {\\n                        types[0] = \\\"SEQUENCE\\\";\\n                    }\\n                    break;\\n                case 'r' :\\n                    if (dbProductName.indexOf(\\\"HSQL\\\") > -1) {\\n                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT authorization_name FROM \\\"\\n                            + \\\"information_schema.system_authorizations\\\\n\\\"\\n                            + \\\"WHERE authorization_type = 'ROLE'\\\\n\\\"\\n                            + \\\"ORDER BY authorization_name\\\");\\n                    } else if (dbProductName.indexOf(\\n                            \\\"Adaptive Server Enterprise\\\") > -1) {\\n                                                                                                                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT name FROM syssrvroles ORDER BY name\\\");\\n                    } else if (dbProductName.indexOf(\\n                            \\\"Apache Derby\\\") > -1) {\\n                        throw new BadSpecial(\\n                            rb.getString(SqltoolRB.VENDOR_DERBY_DR));\\n                    } else {\\n                        throw new BadSpecial(\\n                            rb.getString(SqltoolRB.VENDOR_NOSUP_D,\\n                                    new String[] {\\\"r\\\"}));\\n                    }\\n                    break;\\n                case 'u' :\\n                    if (dbProductName.indexOf(\\\"HSQL\\\") > -1) {\\n                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT user, admin FROM \\\"\\n                            + \\\"information_schema.system_users\\\\n\\\"\\n                            + \\\"ORDER BY user\\\");\\n                    } else if (dbProductName.indexOf(\\\"Oracle\\\") > -1) {\\n                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT username, created FROM all_users \\\"\\n                            + \\\"ORDER BY username\\\");\\n                    } else if (dbProductName.indexOf(\\\"PostgreSQL\\\") > -1) {\\n                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT usename, usesuper FROM pg_catalog.pg_user \\\"\\n                            + \\\"ORDER BY usename\\\");\\n                    } else if (dbProductName.indexOf(\\n                            \\\"Adaptive Server Enterprise\\\") > -1) {\\n                                                                                                                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT name, accdate, fullname FROM syslogins \\\"\\n                            + \\\"ORDER BY name\\\");\\n                    } else if (dbProductName.indexOf(\\n                            \\\"Apache Derby\\\") > -1) {\\n                        throw new BadSpecial(\\n                            rb.getString(SqltoolRB.VENDOR_DERBY_DU));\\n                    } else {\\n                        throw new BadSpecial(\\n                            rb.getString(SqltoolRB.VENDOR_NOSUP_D,\\n                                    new String[] {\\\"u\\\"}));\\n                    }\\n                    break;\\n                case 'a' :\\n                    if (dbProductName.indexOf(\\\"HSQL\\\") > -1) {\\n                                                                        if (filter != null\\n                                && filter.charAt(filter.length() - 1)\\n                                   == '.') {\\n                            narrower =\\n                                \\\"\\\\nWHERE alias_schem = '\\\"\\n                                + filter.substring(0, filter.length() - 1)\\n                                + \\\"'\\\";\\n                            filter = null;\\n                        }\\n                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT alias_schem, alias FROM \\\"\\n                            + \\\"information_schema.system_aliases\\\" + narrower);\\n                    } else {\\n                        types[0] = \\\"ALIAS\\\";\\n                    }\\n                    break;\\n                case 't' :\\n                    excludeSysSchemas = (dbProductName.indexOf(\\\"Oracle\\\")\\n                                         > -1);\\n                    types[0] = \\\"TABLE\\\";\\n                    break;\\n                case 'v' :\\n                    types[0] = \\\"VIEW\\\";\\n                    break;\\n                case 'n' :\\n                    rs = md.getSchemas();\\n                    if (rs == null) {\\n                        throw new BadSpecial(\\n                            \\\"Failed to get metadata from database\\\");\\n                    }\\n                    displayResultSet(null, rs, listMDSchemaCols, filter);\\n                    return;\\n                case 'i' :\\n                    String table = null;\\n                    if (filter != null) {\\n                        int dotat = filter.indexOf('.');\\n                        schema = ((dotat > 0) ? filter.substring(0, dotat)\\n                                              : null);\\n                        if (dotat < filter.length() - 1) {\\n                                                        table = ((dotat > 0) ? filter.substring(dotat + 1)\\n                                                 : filter);\\n                        }\\n                        filter = null;\\n                    }\\n                                                                                                    rs = md.getIndexInfo(null, schema, table, false, true);\\n                    if (rs == null) {\\n                        throw new BadSpecial(\\n                            \\\"Failed to get metadata from database\\\");\\n                    }\\n                    displayResultSet(null, rs, listMDIndexCols, null);\\n                    return;\\n                default :\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.SPECIAL_D_UNKNOWN, new String[] {\\n                                Character.toString(c)}) + LS + D_OPTIONS_TEXT);\\n            }\\n            if (statement == null) {\\n                if (dbProductName.indexOf(\\\"HSQL\\\") > -1) {\\n                    listSet = listMDTableCols[HSQLDB_ELEMENT];\\n                } else if (dbProductName.indexOf(\\\"Oracle\\\") > -1) {\\n                    listSet = listMDTableCols[ORACLE_ELEMENT];\\n                } else {\\n                    listSet = listMDTableCols[DEFAULT_ELEMENT];\\n                }\\n                if (schema == null && filter != null\\n                        && filter.charAt(filter.length() - 1) == '.') {\\n                    schema = filter.substring(0, filter.length() - 1);\\n                    filter = null;\\n                }\\n            }\\n            rs = ((statement == null)\\n                  ? md.getTables(null, schema, null, types)\\n                  : statement.getResultSet());\\n            if (rs == null) {\\n                throw new BadSpecial(rb.getString(\\n                        SqltoolRB.METADATA_FETCH_FAIL));\\n            }\\n            displayResultSet(null, rs, listSet, filter);\\n            if (additionalSchemas != null) {\\n                for (int i = 1; i < additionalSchemas.length; i++) {\\n                    rs = md.getTables(null, additionalSchemas[i], null,\\n                                      types);\\n                    if (rs == null) {\\n                        throw new BadSpecial(rb.getString(\\n                            SqltoolRB.METADATA_FETCH_FAILFOR,\\n                                    new String[] { additionalSchemas[i]}));\\n                    }\\n                    if (!rs.next()) {\\n                        continue;\\n                    }\\n                    displayResultSet(\\n                        null,\\n                        md.getTables(\\n                            null, additionalSchemas[i], null, types), listSet, filter);\\n                }\\n            }\\n        } catch (SQLException se) {\\n            throw new BadSpecial(rb.getString( SqltoolRB.METADATA_FETCH_FAIL),\\n                    se);\\n        } catch (NullPointerException npe) {\\n            throw new BadSpecial(rb.getString( SqltoolRB.METADATA_FETCH_FAIL),\\n                    npe);\\n        } finally {\\n            excludeSysSchemas = false;\\n            if (rs != null) {\\n                rs = null;\\n            }\\n            if (statement != null) {\\n                try {\\n                    statement.close();\\n                } catch (Exception e) {}\\n                statement = null;\\n            }\\n        }\\n    }\\n    private boolean excludeSysSchemas = false;\\n    private void processSQL() throws SQLException, SqlToolError {\\n                                                                                                        lastSqlStatement    = (plMode ? dereference(buffer, true)\\n                                      : buffer);\\n        Statement statement = null;\\n        if (doPrepare) {\\n            if (lastSqlStatement.indexOf('?') < 1) {\\n                lastSqlStatement = null;\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.PREPARE_DEMANDQM));\\n            }\\n            doPrepare = false;\\n            PreparedStatement ps = curConn.prepareStatement(lastSqlStatement);\\n            if (prepareVar == null) {\\n                if (binBuffer == null) {\\n                    lastSqlStatement = null;\\n                    throw new SqlToolError(rb.getString(\\n                            SqltoolRB.BINBUFFER_EMPTY));\\n                }\\n                ps.setBytes(1, binBuffer);\\n            } else {\\n                String val = (String) userVars.get(prepareVar);\\n                if (val == null) {\\n                    lastSqlStatement = null;\\n                    throw new SqlToolError(\\n                            rb.getString(SqltoolRB.PLVAR_UNDEFINED,\\n                                    new String[] {prepareVar}));\\n                }\\n                prepareVar = null;\\n                ps.setString(1, val);\\n            }\\n            ps.executeUpdate();\\n            statement = ps;\\n        } else {\\n            statement = curConn.createStatement();\\n            statement.execute(lastSqlStatement);\\n        }\\n        possiblyUncommitteds.set(true);\\n        try {\\n            displayResultSet(statement, statement.getResultSet(), null, null);\\n        } finally {\\n            try {\\n                statement.close();\\n            } catch (Exception e) {}\\n        }\\n        lastSqlStatement = null;\\n    }\\n    private void displayResultSet(Statement statement, ResultSet r,\\n                                  int[] incCols,\\n                                  String filter) throws SQLException,\\n                                  SqlToolError {\\n        java.sql.Timestamp ts;\\n        int dotAt;\\n        int                updateCount = (statement == null) ? -1\\n                                                             : statement\\n                                                                 .getUpdateCount();\\n        boolean            silent      = silentFetch;\\n        boolean            binary      = fetchBinary;\\n        silentFetch = false;\\n        fetchBinary = false;\\n        if (excludeSysSchemas) {\\n            stdprintln(rb.getString(SqltoolRB.VENDOR_NOSUP_SYSSCHEMAS));\\n        }\\n        switch (updateCount) {\\n            case -1 :\\n                if (r == null) {\\n                    stdprintln(rb.getString(SqltoolRB.NORESULT), true);\\n                    break;\\n                }\\n                ResultSetMetaData m        = r.getMetaData();\\n                int               cols     = m.getColumnCount();\\n                int               incCount = (incCols == null) ? cols\\n                                                               : incCols\\n                                                                   .length;\\n                String            val;\\n                List              rows        = new ArrayList();\\n                String[]          headerArray = null;\\n                String[]          fieldArray;\\n                int[]             maxWidth = new int[incCount];\\n                int               insi;\\n                boolean           skip;\\n                                if (!htmlMode) {\\n                    for (int i = 0; i < maxWidth.length; i++) {\\n                        maxWidth[i] = 0;\\n                    }\\n                }\\n                boolean[] rightJust = new boolean[incCount];\\n                int[]     dataType  = new int[incCount];\\n                boolean[] autonulls = new boolean[incCount];\\n                insi        = -1;\\n                headerArray = new String[incCount];\\n                for (int i = 1; i <= cols; i++) {\\n                    if (incCols != null) {\\n                        skip = true;\\n                        for (int j = 0; j < incCols.length; j++) {\\n                            if (i == incCols[j]) {\\n                                skip = false;\\n                            }\\n                        }\\n                        if (skip) {\\n                            continue;\\n                        }\\n                    }\\n                    headerArray[++insi] = m.getColumnLabel(i);\\n                    dataType[insi]      = m.getColumnType(i);\\n                    rightJust[insi]     = false;\\n                    autonulls[insi]     = true;\\n                    switch (dataType[insi]) {\\n                        case java.sql.Types.BIGINT :\\n                        case java.sql.Types.BIT :\\n                        case java.sql.Types.DECIMAL :\\n                        case java.sql.Types.DOUBLE :\\n                        case java.sql.Types.FLOAT :\\n                        case java.sql.Types.INTEGER :\\n                        case java.sql.Types.NUMERIC :\\n                        case java.sql.Types.REAL :\\n                        case java.sql.Types.SMALLINT :\\n                        case java.sql.Types.TINYINT :\\n                            rightJust[insi] = true;\\n                            break;\\n                        case java.sql.Types.VARBINARY :\\n                        case java.sql.Types.VARCHAR :\\n                        case java.sql.Types.ARRAY :\\n                                                    case java.sql.Types.BLOB :\\n                        case java.sql.Types.CLOB :\\n                        case java.sql.Types.LONGVARBINARY :\\n                        case java.sql.Types.LONGVARCHAR :\\n                            autonulls[insi] = false;\\n                            break;\\n                    }\\n                    if (htmlMode) {\\n                        continue;\\n                    }\\n                    if (headerArray[insi].length() > maxWidth[insi]) {\\n                        maxWidth[insi] = headerArray[insi].length();\\n                    }\\n                }\\n                boolean filteredOut;\\n                while (r.next()) {\\n                    fieldArray  = new String[incCount];\\n                    insi        = -1;\\n                    filteredOut = filter != null;\\n                    for (int i = 1; i <= cols; i++) {\\n                                                                        if (incCols != null) {\\n                            skip = true;\\n                            for (int j = 0; j < incCols.length; j++) {\\n                                if (i == incCols[j]) {\\n                                    skip = false;\\n                                }\\n                            }\\n                            if (skip) {\\n                                continue;\\n                            }\\n                        }\\n                                                                                                ++insi;\\n                        if (!SqlFile.canDisplayType(dataType[insi])) {\\n                            binary = true;\\n                        }\\n                        val = null;\\n                        if (!binary) {\\n                            switch (dataType[insi]) {\\n                                case java.sql.Types.TIMESTAMP:\\n                                case java.sql.Types.DATE:\\n                                case java.sql.Types.TIME:\\n                                    ts  = r.getTimestamp(i);\\n                                    val = ((ts == null) ? null : ts.toString());\\n                                                                                                                                                if (dataType[insi]\\n                                            != java.sql.Types.TIMESTAMP\\n                                            && val != null) {\\n                                        dotAt = val.lastIndexOf('.');\\n                                        for (int z = dotAt + 1;\\n                                                z < val.length(); z++) {\\n                                            if (val.charAt(z) != '0') {\\n                                                dotAt = 0;\\n                                                break;\\n                                            }\\n                                        }\\n                                        if (dotAt > 1) {\\n                                            val = val.substring(0, dotAt);\\n                                        }\\n                                    }\\n                                    break;\\n                                default:\\n                                    val = r.getString(i);\\n                                                                                                                                                if (val == null) {\\n                                        try {\\n                                            val = streamToString(\\n                                                r.getAsciiStream(i), charset);\\n                                        } catch (Exception e) { }\\n                                    }\\n                            }\\n                        }\\n                        if (binary || (val == null &&!r.wasNull())) {\\n                            if (pwDsv != null) {\\n                                throw new SqlToolError(\\n                                        rb.getString(SqltoolRB.DSV_BINCOL));\\n                            }\\n                                                                                    try {\\n                                binBuffer =\\n                                    SqlFile.streamToBytes(r.getBinaryStream(i));\\n                            } catch (IOException ioe) {\\n                                throw new SqlToolError(\\n                                    \\\"Failed to read value using stream\\\",\\n                                    ioe);\\n                            }\\n                            stdprintln(rb.getString(SqltoolRB.BINBUF_WRITE,\\n                                    new String[] {\\n                                       Integer.toString(binBuffer.length),\\n                                       headerArray[insi],\\n                                       SqlFile.sqlTypeToString(dataType[insi])\\n                                    }));\\n                            return;\\n                        }\\n                        if (excludeSysSchemas && val != null && i == 2) {\\n                            for (int z = 0; z < oracleSysSchemas.length;\\n                                    z++) {\\n                                if (val.equals(oracleSysSchemas[z])) {\\n                                    filteredOut = true;\\n                                    break;\\n                                }\\n                            }\\n                        }\\n                        userVars.put(\\\"?\\\", ((val == null) ? nullRepToken : val));\\n                        if (fetchingVar != null) {\\n                            userVars.put(fetchingVar, userVars.get(\\\"?\\\"));\\n                            updateUserSettings();\\n                            fetchingVar = null;\\n                        }\\n                        if (silent) {\\n                            return;\\n                        }\\n                                                                                                if (filter != null\\n                                && (val == null\\n                                    || val.indexOf(filter) > -1)) {\\n                            filteredOut = false;\\n                        }\\n                                                                        if (val == null && pwDsv == null) {\\n                            if (dataType[insi] == java.sql.Types.VARCHAR) {\\n                                fieldArray[insi] = (htmlMode ? \\\"<I>null</I>\\\"\\n                                                             : nullRepToken);\\n                            } else {\\n                                fieldArray[insi] = \\\"\\\";\\n                            }\\n                        } else {\\n                            fieldArray[insi] = val;\\n                        }\\n                                                if (htmlMode || pwDsv != null) {\\n                            continue;\\n                        }\\n                        if (fieldArray[insi].length() > maxWidth[insi]) {\\n                            maxWidth[insi] = fieldArray[insi].length();\\n                        }\\n                    }\\n                    if (!filteredOut) {\\n                        rows.add(fieldArray);\\n                    }\\n                }\\n                                                if (pwDsv == null) {\\n                    condlPrintln(\\\"<TABLE border='1'>\\\", true);\\n                    if (incCount > 1) {\\n                        condlPrint(SqlFile.htmlRow(COL_HEAD) + LS + PRE_TD, true);\\n                        for (int i = 0; i < headerArray.length; i++) {\\n                            condlPrint(\\\"<TD>\\\" + headerArray[i] + \\\"</TD>\\\",\\n                                       true);\\n                            condlPrint(((i > 0) ? SqlFile.spaces(2)\\n                                                : \\\"\\\") + SqlFile.pad(\\n                                                    headerArray[i],\\n                                                    maxWidth[i],\\n                                                    rightJust[i],\\n                                                    (i < headerArray.length\\n                                                     - 1 || rightJust[i])), false);\\n                        }\\n                        condlPrintln(LS + PRE_TR + \\\"</TR>\\\", true);\\n                        condlPrintln(\\\"\\\", false);\\n                        if (!htmlMode) {\\n                            for (int i = 0; i < headerArray.length; i++) {\\n                                condlPrint(((i > 0) ? SqlFile.spaces(2)\\n                                                    : \\\"\\\") + SqlFile.divider(\\n                                                        maxWidth[i]), false);\\n                            }\\n                            condlPrintln(\\\"\\\", false);\\n                        }\\n                    }\\n                    for (int i = 0; i < rows.size(); i++) {\\n                        condlPrint(SqlFile.htmlRow(((i % 2) == 0) ? COL_EVEN\\n                                                          : COL_ODD) + LS\\n                                                          + PRE_TD, true);\\n                        fieldArray = (String[]) rows.get(i);\\n                        for (int j = 0; j < fieldArray.length; j++) {\\n                            condlPrint(\\\"<TD>\\\" + fieldArray[j] + \\\"</TD>\\\",\\n                                       true);\\n                            condlPrint(((j > 0) ? SqlFile.spaces(2)\\n                                                : \\\"\\\") + SqlFile.pad(\\n                                                    fieldArray[j],\\n                                                    maxWidth[j],\\n                                                    rightJust[j],\\n                                                    (j < fieldArray.length\\n                                                     - 1 || rightJust[j])), false);\\n                        }\\n                        condlPrintln(LS + PRE_TR + \\\"</TR>\\\", true);\\n                        condlPrintln(\\\"\\\", false);\\n                    }\\n                    condlPrintln(\\\"</TABLE>\\\", true);\\n                    if (rows.size() != 1) {\\n                        stdprintln(LS + rb.getString(SqltoolRB.ROWS_FETCHED,\\n                                new String[] { Integer.toString(rows.size()) }),\\n                        true);\\n                    }\\n                    condlPrintln(\\\"<HR>\\\", true);\\n                    break;\\n                }\\n                                if (incCount > 0) {\\n                    for (int i = 0; i < headerArray.length; i++) {\\n                        dsvSafe(headerArray[i]);\\n                        pwDsv.print(headerArray[i]);\\n                        if (i < headerArray.length - 1) {\\n                            pwDsv.print(dsvColDelim);\\n                        }\\n                    }\\n                    pwDsv.print(dsvRowDelim);\\n                }\\n                for (int i = 0; i < rows.size(); i++) {\\n                    fieldArray = (String[]) rows.get(i);\\n                    for (int j = 0; j < fieldArray.length; j++) {\\n                        dsvSafe(fieldArray[j]);\\n                        pwDsv.print((fieldArray[j] == null)\\n                                    ? (autonulls[j] ? \\\"\\\"\\n                                                    : nullRepToken)\\n                                    : fieldArray[j]);\\n                        if (j < fieldArray.length - 1) {\\n                            pwDsv.print(dsvColDelim);\\n                        }\\n                    }\\n                    pwDsv.print(dsvRowDelim);\\n                }\\n                stdprintln(rb.getString(SqltoolRB.ROWS_FETCHED_DSV,\\n                        new String[] { Integer.toString(rows.size()) }));\\n                break;\\n            default :\\n                userVars.put(\\\"?\\\", Integer.toString(updateCount));\\n                if (fetchingVar != null) {\\n                    userVars.put(fetchingVar, userVars.get(\\\"?\\\"));\\n                    updateUserSettings();\\n                    fetchingVar = null;\\n                }\\n                if (updateCount != 0) {\\n                    stdprintln((updateCount == 1)\\n                        ? rb.getString(SqltoolRB.ROW_UPDATE_SINGULAR)\\n                        : rb.getString(SqltoolRB.ROW_UPDATE_MULTIPLE,\\n                                new String[] {Integer.toString(updateCount)}));\\n                }\\n                break;\\n        }\\n    }\\n    private static final int    COL_HEAD = 0,\\n                                COL_ODD  = 1,\\n                                COL_EVEN = 2\\n    ;\\n    private static final String PRE_TR   = spaces(4);\\n    private static final String PRE_TD   = spaces(8);\\n    private static String htmlRow(int colType) {\\n        switch (colType) {\\n            case COL_HEAD :\\n                return PRE_TR + \\\"<TR style='font-weight: bold;'>\\\";\\n            case COL_ODD :\\n                return PRE_TR\\n                       + \\\"<TR style='background: #94d6ef; font: normal \\\"\\n                       + \\\"normal 10px/10px Arial, Helvitica, sans-serif;'>\\\";\\n            case COL_EVEN :\\n                return PRE_TR\\n                       + \\\"<TR style='background: silver; font: normal \\\"\\n                       + \\\"normal 10px/10px Arial, Helvitica, sans-serif;'>\\\";\\n        }\\n        return null;\\n    }\\n    private static String divider(int len) {\\n        return (len > DIVIDER.length()) ? DIVIDER\\n                                        : DIVIDER.substring(0, len);\\n    }\\n    private static String spaces(int len) {\\n        return (len > SPACES.length()) ? SPACES\\n                                       : SPACES.substring(0, len);\\n    }\\n    private static String pad(String inString, int fulllen,\\n                              boolean rightJustify, boolean doPad) {\\n        if (!doPad) {\\n            return inString;\\n        }\\n        int len = fulllen - inString.length();\\n        if (len < 1) {\\n            return inString;\\n        }\\n        String pad = SqlFile.spaces(len);\\n        return ((rightJustify ? pad\\n                              : \\\"\\\") + inString + (rightJustify ? \\\"\\\"\\n                                                               : pad));\\n    }\\n    private void showHistory() throws BadSpecial {\\n        if (history == null) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_UNAVAILABLE));\\n        }\\n        if (history.size() < 1) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_NONE));\\n        } else {\\n            for (int i = 0; i < history.size(); i++) {\\n                psStd.println(\\\"#\\\" + (i + oldestHist) + \\\" or \\\"\\n                        + (i - history.size()) + ':');\\n                psStd.println((String) history.get(i));\\n            }\\n        }\\n        if (buffer != null) {\\n            psStd.println(rb.getString(SqltoolRB.EDITBUFFER_CONTENTS,\\n                    new String[] { buffer}));\\n        }\\n        psStd.println();\\n        psStd.println(rb.getString(SqltoolRB.BUFFER_INSTRUCTIONS));\\n    }\\n    private String commandFromHistory(int inIndex) throws BadSpecial {\\n        int index = inIndex;  \\n        if (history == null) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_UNAVAILABLE));\\n        }\\n        if (index == 0) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_NUMBER_REQ));\\n        }\\n        if (index > 0) {\\n                        index -= oldestHist;\\n            if (index < 0) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_BACKTO,\\n                       new String[] { Integer.toString(oldestHist) }));\\n            }\\n            if (index >= history.size()) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_UPTO,\\n                       new String[] { Integer.toString(\\n                               history.size() + oldestHist - 1\\n                       )}));\\n            }\\n        } else {\\n                        index += history.size();\\n            if (index < 0) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_BACK,\\n                       new String[] { Integer.toString(history.size()) }));\\n            }\\n        }\\n        return (String) history.get(index);\\n    }\\n    private void setBuf(String newContent) {\\n        buffer = new String(newContent);\\n            }\\n    int oldestHist = 1;\\n    private void historize() {\\n        if (history == null || buffer == null) {\\n            return;\\n        }\\n        if (history.size() > 0 &&\\n                history.get(history.size() - 1).equals(buffer)) {\\n                        return;\\n        }\\n        history.add(buffer);\\n        if (history.size() <= maxHistoryLength) {\\n            return;\\n        }\\n        history.remove(0);\\n        oldestHist++;\\n    }\\n    private void describe(String tableName,\\n                          String inFilter) throws SQLException {\\n        String    filter = inFilter;\\n        List      rows        = new ArrayList();\\n        String[]  headerArray = {\\n            rb.getString(SqltoolRB.DESCRIBE_TABLE_NAME),\\n            rb.getString(SqltoolRB.DESCRIBE_TABLE_DATATYPE),\\n            rb.getString(SqltoolRB.DESCRIBE_TABLE_WIDTH),\\n            rb.getString(SqltoolRB.DESCRIBE_TABLE_NONULLS),\\n        };\\n        String[]  fieldArray;\\n        int[]     maxWidth  = {\\n            0, 0, 0, 0\\n        };\\n        boolean[] rightJust = {\\n            false, false, true, false\\n        };\\n                for (int i = 0; i < headerArray.length; i++) {\\n            if (htmlMode) {\\n                continue;\\n            }\\n            if (headerArray[i].length() > maxWidth[i]) {\\n                maxWidth[i] = headerArray[i].length();\\n            }\\n        }\\n        Statement statement = curConn.createStatement();\\n        ResultSet r         = null;\\n        try {\\n            statement.execute(\\\"SELECT * FROM \\\" + tableName + \\\" WHERE 1 = 2\\\");\\n            r = statement.getResultSet();\\n            ResultSetMetaData m    = r.getMetaData();\\n            int               cols = m.getColumnCount();\\n            for (int i = 0; i < cols; i++) {\\n                fieldArray    = new String[4];\\n                fieldArray[0] = m.getColumnName(i + 1);\\n                if (filter != null && fieldArray[0].indexOf(filter) < 0) {\\n                    continue;\\n                }\\n                fieldArray[1] = m.getColumnTypeName(i + 1);\\n                fieldArray[2] = Integer.toString(m.getColumnDisplaySize(i\\n                        + 1));\\n                fieldArray[3] =\\n                    ((m.isNullable(i + 1) == java.sql.ResultSetMetaData.columnNullable)\\n                     ? (htmlMode ? \\\"&nbsp;\\\"\\n                                 : \\\"\\\")\\n                     : \\\"*\\\");\\n                rows.add(fieldArray);\\n                for (int j = 0; j < fieldArray.length; j++) {\\n                    if (fieldArray[j].length() > maxWidth[j]) {\\n                        maxWidth[j] = fieldArray[j].length();\\n                    }\\n                }\\n            }\\n                        condlPrint(\\\"<TABLE border='1'>\\\" + LS + SqlFile.htmlRow(COL_HEAD) + LS\\n                       + PRE_TD, true);\\n            for (int i = 0; i < headerArray.length; i++) {\\n                condlPrint(\\\"<TD>\\\" + headerArray[i] + \\\"</TD>\\\", true);\\n                condlPrint(((i > 0) ? SqlFile.spaces(2)\\n                                    : \\\"\\\") + SqlFile.pad(headerArray[i], maxWidth[i],\\n                                                rightJust[i],\\n                                                (i < headerArray.length - 1\\n                                                 || rightJust[i])), false);\\n            }\\n            condlPrintln(LS + PRE_TR + \\\"</TR>\\\", true);\\n            condlPrintln(\\\"\\\", false);\\n            if (!htmlMode) {\\n                for (int i = 0; i < headerArray.length; i++) {\\n                    condlPrint(((i > 0) ? SqlFile.spaces(2)\\n                                        : \\\"\\\") + SqlFile.divider(maxWidth[i]), false);\\n                }\\n                condlPrintln(\\\"\\\", false);\\n            }\\n            for (int i = 0; i < rows.size(); i++) {\\n                condlPrint(SqlFile.htmlRow(((i % 2) == 0) ? COL_EVEN\\n                                                  : COL_ODD) + LS\\n                                                  + PRE_TD, true);\\n                fieldArray = (String[]) rows.get(i);\\n                for (int j = 0; j < fieldArray.length; j++) {\\n                    condlPrint(\\\"<TD>\\\" + fieldArray[j] + \\\"</TD>\\\", true);\\n                    condlPrint(((j > 0) ? SqlFile.spaces(2)\\n                                        : \\\"\\\") + SqlFile.pad(\\n                                            fieldArray[j], maxWidth[j],\\n                                            rightJust[j],\\n                                            (j < fieldArray.length - 1\\n                                             || rightJust[j])), false);\\n                }\\n                condlPrintln(LS + PRE_TR + \\\"</TR>\\\", true);\\n                condlPrintln(\\\"\\\", false);\\n            }\\n            condlPrintln(LS + \\\"</TABLE>\\\" + LS + \\\"<HR>\\\", true);\\n        } finally {\\n            try {\\n                if (r != null) {\\n                    r.close();\\n                    r = null;\\n                }\\n                statement.close();\\n            } catch (Exception e) {}\\n        }\\n    }\\n    private boolean eval(String[] inTokens) throws BadSpecial {\\n                        boolean  negate = inTokens.length > 0 && inTokens[0].equals(\\\"!\\\");\\n        String[] tokens = new String[negate ? (inTokens.length - 1)\\n                                            : inTokens.length];\\n        String inToken;\\n        String varName;\\n        for (int i = 0; i < tokens.length; i++) {\\n            inToken = inTokens[i + (negate ? 1 : 0)];\\n            if (inToken.length() > 1 && inToken.charAt(0) == '*') {\\n                varName = inToken.substring(1);\\n                tokens[i] = (String) userVars.get(inToken.substring(1));\\n            } else {\\n                tokens[i] = inTokens[i + (negate ? 1 : 0)];\\n            }\\n                                    if (tokens[i] == null) {\\n                tokens[i] = \\\"\\\";\\n            }\\n        }\\n        if (tokens.length == 1) {\\n            return (tokens[0].length() > 0 &&!tokens[0].equals(\\\"0\\\")) ^ negate;\\n        }\\n        if (tokens.length == 3) {\\n            if (tokens[1].equals(\\\"==\\\")) {\\n                return tokens[0].equals(tokens[2]) ^ negate;\\n            }\\n            if (tokens[1].equals(\\\"!=\\\") || tokens[1].equals(\\\"<>\\\")\\n                    || tokens[1].equals(\\\"><\\\")) {\\n                return (!tokens[0].equals(tokens[2])) ^ negate;\\n            }\\n            if (tokens[1].equals(\\\">\\\")) {\\n                return (tokens[0].length() > tokens[2].length() || ((tokens[0].length() == tokens[2].length()) && tokens[0].compareTo(tokens[2]) > 0))\\n                       ^ negate;\\n            }\\n            if (tokens[1].equals(\\\"<\\\")) {\\n                return (tokens[2].length() > tokens[0].length() || ((tokens[2].length() == tokens[0].length()) && tokens[2].compareTo(tokens[0]) > 0))\\n                       ^ negate;\\n            }\\n        }\\n        throw new BadSpecial(rb.getString(SqltoolRB.LOGICAL_UNRECOGNIZED));\\n    }\\n    private void closeQueryOutputStream() {\\n        if (pwQuery == null) {\\n            return;\\n        }\\n        if (htmlMode) {\\n            pwQuery.println(\\\"</BODY></HTML>\\\");\\n            pwQuery.flush();\\n        }\\n        pwQuery.close();\\n        pwQuery = null;\\n    }\\n    private void condlPrintln(String s, boolean printHtml) {\\n        if ((printHtml &&!htmlMode) || (htmlMode &&!printHtml)) {\\n            return;\\n        }\\n        psStd.println(s);\\n        if (pwQuery != null) {\\n            pwQuery.println(s);\\n            pwQuery.flush();\\n        }\\n    }\\n    private void condlPrint(String s, boolean printHtml) {\\n        if ((printHtml &&!htmlMode) || (htmlMode &&!printHtml)) {\\n            return;\\n        }\\n        psStd.print(s);\\n        if (pwQuery != null) {\\n            pwQuery.print(s);\\n            pwQuery.flush();\\n        }\\n    }\\n    private String formatNicely(Map map, boolean withValues) {\\n        String       key;\\n        StringBuffer sb = new StringBuffer();\\n        Iterator     it = (new TreeMap(map)).keySet().iterator();\\n        if (withValues) {\\n            SqlFile.appendLine(sb, rb.getString(SqltoolRB.PL_LIST_PARENS));\\n        } else {\\n            SqlFile.appendLine(sb, rb.getString(SqltoolRB.PL_LIST_LENGTHS));\\n        }\\n        while (it.hasNext()) {\\n            key = (String) it.next();\\n            String s = (String) map.get(key);\\n            SqlFile.appendLine(sb, \\\"    \\\" + key + \\\": \\\" + (withValues ? (\\\"(\\\" + s + ')')\\n                                                        : Integer.toString(\\n                                                        s.length())));\\n        }\\n        return sb.toString();\\n    }\\n    private void dump(String varName,\\n                      File dumpFile) throws IOException, BadSpecial {\\n        String val = (String) userVars.get(varName);\\n        if (val == null) {\\n            throw new BadSpecial(rb.getString(\\n                    SqltoolRB.PLVAR_UNDEFINED, new String[] {varName}));\\n        }\\n        OutputStreamWriter osw = ((charset == null)\\n                ? (new OutputStreamWriter(new FileOutputStream(dumpFile)))\\n                : (new OutputStreamWriter(new FileOutputStream(dumpFile),\\n                            charset)));\\n        try {\\n            osw.write(val);\\n            if (val.length() > 0) {\\n                char lastChar = val.charAt(val.length() - 1);\\n                if (lastChar != '\\\\n' && lastChar != '\\\\r') {\\n                    osw.write(LS);\\n                }\\n            }\\n            osw.flush();\\n        } finally {\\n            osw.close();\\n        }\\n                        stdprintln(rb.getString(SqltoolRB.FILE_WROTECHARS, new String[] {\\n                Long.toString(dumpFile.length()), dumpFile.toString() }));\\n    }\\n    byte[] binBuffer = null;\\n    private void dump(File dumpFile) throws IOException, BadSpecial {\\n        if (binBuffer == null) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.BINBUFFER_EMPTY));\\n        }\\n        FileOutputStream fos = new FileOutputStream(dumpFile);\\n        int len = 0;\\n        try {\\n            fos.write(binBuffer);\\n            len = binBuffer.length;\\n            binBuffer = null;\\n            fos.flush();\\n        } finally {\\n            fos.close();\\n        }\\n        stdprintln(rb.getString(SqltoolRB.FILE_WROTECHARS,\\n                new String[] { Integer.toString(len), dumpFile.toString() }));\\n    }\\n    public String streamToString(InputStream is, String cs)\\n            throws IOException {\\n        try {\\n            byte[] ba = null;\\n            int bytesread = 0;\\n            int retval;\\n            try {\\n                ba = new byte[is.available()];\\n            } catch (RuntimeException re) {\\n                throw new IOException(rb.getString(SqltoolRB.READ_TOOBIG));\\n            }\\n            while (bytesread < ba.length &&\\n                    (retval = is.read(\\n                            ba, bytesread, ba.length - bytesread)) > 0) {\\n                bytesread += retval;\\n            }\\n            if (bytesread != ba.length) {\\n                throw new IOException(rb.getString(\\n                        SqltoolRB.READ_PARTIAL, new String[] {\\n                            Integer.toString(bytesread),\\n                            Integer.toString(ba.length)\\n                        }));\\n            }\\n            try {\\n                return (cs == null) ? (new String(ba))\\n                                         : (new String(ba, cs));\\n            } catch (UnsupportedEncodingException uee) {\\n                throw new RuntimeException(uee);\\n            } catch (RuntimeException re) {\\n                throw new IOException(rb.getString(SqltoolRB.READ_CONVERTFAIL));\\n            }\\n        } finally {\\n            is.close();\\n        }\\n    }\\n    private void load(String varName, File asciiFile, String cs)\\n            throws IOException {\\n        String string = streamToString(new FileInputStream(asciiFile), cs);\\n        userVars.put(varName, string);\\n        updateUserSettings();\\n    }\\n    static public byte[] streamToBytes(InputStream is) throws IOException {\\n        byte[]                xferBuffer = new byte[10240];\\n        ByteArrayOutputStream baos       = new ByteArrayOutputStream();\\n        int                   i;\\n        while ((i = is.read(xferBuffer)) > 0) {\\n            baos.write(xferBuffer, 0, i);\\n        }\\n        return baos.toByteArray();\\n    }\\n    static public byte[] loadBinary(File binFile) throws IOException {\\n        byte[]                xferBuffer = new byte[10240];\\n        ByteArrayOutputStream baos       = new ByteArrayOutputStream();\\n        int                   i;\\n        FileInputStream       fis        = new FileInputStream(binFile);\\n        try {\\n            while ((i = fis.read(xferBuffer)) > 0) {\\n                baos.write(xferBuffer, 0, i);\\n            }\\n        } finally {\\n            fis.close();\\n        }\\n        byte[] ba = baos.toByteArray();\\n        return ba;\\n    }\\n    public static boolean canDisplayType(int i) {\\n        switch (i) {\\n                        case java.sql.Types.BLOB :\\n            case java.sql.Types.JAVA_OBJECT :\\n                                    case java.sql.Types.OTHER :\\n            case java.sql.Types.STRUCT :\\n                                return false;\\n        }\\n        return true;\\n    }\\n        private static final int JDBC3_BOOLEAN  = 16;\\n    private static final int JDBC3_DATALINK = 70;\\n    public static String sqlTypeToString(int i) {\\n        switch (i) {\\n            case java.sql.Types.ARRAY :\\n                return \\\"ARRAY\\\";\\n            case java.sql.Types.BIGINT :\\n                return \\\"BIGINT\\\";\\n            case java.sql.Types.BINARY :\\n                return \\\"BINARY\\\";\\n            case java.sql.Types.BIT :\\n                return \\\"BIT\\\";\\n            case java.sql.Types.BLOB :\\n                return \\\"BLOB\\\";\\n            case JDBC3_BOOLEAN :\\n                return \\\"BOOLEAN\\\";\\n            case java.sql.Types.CHAR :\\n                return \\\"CHAR\\\";\\n            case java.sql.Types.CLOB :\\n                return \\\"CLOB\\\";\\n            case JDBC3_DATALINK :\\n                return \\\"DATALINK\\\";\\n            case java.sql.Types.DATE :\\n                return \\\"DATE\\\";\\n            case java.sql.Types.DECIMAL :\\n                return \\\"DECIMAL\\\";\\n            case java.sql.Types.DISTINCT :\\n                return \\\"DISTINCT\\\";\\n            case java.sql.Types.DOUBLE :\\n                return \\\"DOUBLE\\\";\\n            case java.sql.Types.FLOAT :\\n                return \\\"FLOAT\\\";\\n            case java.sql.Types.INTEGER :\\n                return \\\"INTEGER\\\";\\n            case java.sql.Types.JAVA_OBJECT :\\n                return \\\"JAVA_OBJECT\\\";\\n            case java.sql.Types.LONGVARBINARY :\\n                return \\\"LONGVARBINARY\\\";\\n            case java.sql.Types.LONGVARCHAR :\\n                return \\\"LONGVARCHAR\\\";\\n            case java.sql.Types.NULL :\\n                return \\\"NULL\\\";\\n            case java.sql.Types.NUMERIC :\\n                return \\\"NUMERIC\\\";\\n            case java.sql.Types.OTHER :\\n                return \\\"OTHER\\\";\\n            case java.sql.Types.REAL :\\n                return \\\"REAL\\\";\\n            case java.sql.Types.REF :\\n                return \\\"REF\\\";\\n            case java.sql.Types.SMALLINT :\\n                return \\\"SMALLINT\\\";\\n            case java.sql.Types.STRUCT :\\n                return \\\"STRUCT\\\";\\n            case java.sql.Types.TIME :\\n                return \\\"TIME\\\";\\n            case java.sql.Types.TIMESTAMP :\\n                return \\\"TIMESTAMP\\\";\\n            case java.sql.Types.TINYINT :\\n                return \\\"TINYINT\\\";\\n            case java.sql.Types.VARBINARY :\\n                return \\\"VARBINARY\\\";\\n            case java.sql.Types.VARCHAR :\\n                return \\\"VARCHAR\\\";\\n        }\\n        return \\\"Unknown type \\\" + i;\\n    }\\n    public void dsvSafe(String s) throws SqlToolError {\\n        if (pwDsv == null || dsvColDelim == null || dsvRowDelim == null\\n                || nullRepToken == null) {\\n            throw new RuntimeException(\\n                \\\"Assertion failed.  \\\\n\\\"\\n                + \\\"dsvSafe called when DSV settings are incomplete\\\");\\n        }\\n        if (s == null) {\\n            return;\\n        }\\n        if (s.indexOf(dsvColDelim) > 0) {\\n            throw new SqlToolError(rb.getString(SqltoolRB.DSV_COLDELIM_PRESENT,\\n                        new String[] {dsvColDelim}));\\n        }\\n        if (s.indexOf(dsvRowDelim) > 0) {\\n            throw new SqlToolError(rb.getString(SqltoolRB.DSV_ROWDELIM_PRESENT,\\n                        new String[] {dsvRowDelim}));\\n        }\\n        if (s.trim().equals(nullRepToken)) {\\n                                    throw new SqlToolError(rb.getString(SqltoolRB.DSV_NULLREP_PRESENT,\\n                        new String[] {nullRepToken}));\\n        }\\n    }\\n    public static String convertEscapes(String inString) {\\n        if (inString == null) {\\n            return null;\\n        }\\n        return convertNumericEscapes(\\n                convertEscapes(convertEscapes(convertEscapes(convertEscapes(\\n                    convertEscapes(inString, \\\"\\\\\\\\n\\\", \\\"\\\\n\\\"), \\\"\\\\\\\\r\\\", \\\"\\\\r\\\"),\\n                \\\"\\\\\\\\t\\\", \\\"\\\\t\\\"), \\\"\\\\\\\\\\\\\\\\\\\", \\\"\\\\\\\\\\\"),\\n            \\\"\\\\\\\\f\\\", \\\"\\\\f\\\")\\n        );\\n    }\\n    private static String convertNumericEscapes(String string) {\\n        String workString = string;\\n        int i = 0;\\n        for (char dig = '0'; dig <= '9'; dig++) {\\n            while ((i = workString.indexOf(\\\"\\\\\\\\\\\" + dig, i)) > -1\\n                    && i < workString.length() - 1) {\\n                workString = convertNumericEscape(string, i);\\n            }\\n            while ((i = workString.indexOf(\\\"\\\\\\\\x\\\" + dig, i)) > -1\\n                    && i < workString.length() - 1) {\\n                workString = convertNumericEscape(string, i);\\n            }\\n            while ((i = workString.indexOf(\\\"\\\\\\\\X\\\" + dig, i)) > -1\\n                    && i < workString.length() - 1) {\\n                workString = convertNumericEscape(string, i);\\n            }\\n        }\\n        return workString;\\n    }\\n    private static String convertNumericEscape(String string, int offset) {\\n        int post = -1;\\n        int firstDigit = -1;\\n        int radix = -1;\\n        if (Character.toUpperCase(string.charAt(offset + 1)) == 'X') {\\n            firstDigit = offset + 2;\\n            radix = 16;\\n            post = firstDigit + 2;\\n            if (post > string.length()) post = string.length();\\n        } else {\\n            firstDigit = offset + 1;\\n            radix = (Character.toUpperCase(string.charAt(firstDigit)) == '0')\\n                    ? 8 : 10;\\n            for (post = firstDigit + 1; post < string.length()\\n                    && Character.isDigit(string.charAt(post)); post++) ;\\n        }\\n        return string.substring(0, offset) + ((char)\\n                Integer.parseInt(string.substring(firstDigit, post), radix))\\n                + string.substring(post);\\n    }\\n    private static String convertEscapes(String string, String from, String to) {\\n        String workString = string;\\n        int i = 0;\\n        int fromLen = from.length();\\n        while ((i = workString.indexOf(from, i)) > -1\\n                && i < workString.length() - 1) {\\n            workString = workString.substring(0, i) + to\\n                         + workString.substring(i + fromLen);\\n        }\\n        return workString;\\n    }\\n    public void importDsv(String filePath, String skipPrefix)\\n            throws SqlToolError {\\n        byte[] bfr  = null;\\n        File   file = new File(filePath);\\n        SortedMap constColMap = null;\\n        int constColMapSize = 0;\\n        if (dsvConstCols != null) {\\n                                    constColMap = new TreeMap();\\n            String[] constPairs = dsvConstCols.split(\\\"\\\\\\\\Q\\\"\\n                    + dsvColDelim + \\\"\\\\\\\\E\\\\\\\\s*\\\");\\n            int firstEq;\\n            String n;\\n            for (int i = 0; i < constPairs.length; i++) {\\n                firstEq = constPairs[i].indexOf('=');\\n                n = constPairs[i].substring(0, i).trim();\\n                if (n.trim().length() < 1) {\\n                    throw new SqlToolError(\\n                            rb.getString(SqltoolRB.DSV_CONSTCOLS_NULLCOL));\\n                }\\n                constColMap.put(n, constPairs[i].substring(firstEq + 1));\\n            }\\n        }\\n        Set ucSkipCols = null;\\n        if (dsvSkipCols != null) {\\n            ucSkipCols = new HashSet();\\n            String[] skipCols = dsvSkipCols.split(\\\"\\\\\\\\s*\\\\\\\\Q\\\"\\n                    + dsvColDelim + \\\"\\\\\\\\E\\\\\\\\s*\\\");\\n            for (int i = 0; i < skipCols.length; i++) {\\n                ucSkipCols.add(skipCols[i].toUpperCase());\\n            }\\n        }\\n        if (!file.canRead()) {\\n            throw new SqlToolError(rb.getString(SqltoolRB.FILE_READFAIL,\\n                    new String[] {file.toString()} ));\\n        }\\n        try {\\n            bfr = new byte[(int) file.length()];\\n        } catch (RuntimeException re) {\\n            throw new SqlToolError(rb.getString(SqltoolRB.READ_TOOBIG), re);\\n        }\\n        int bytesread = 0;\\n        int retval;\\n        InputStream is = null;\\n        try {\\n            is = new FileInputStream(file);\\n            while (bytesread < bfr.length &&\\n                    (retval = is.read(bfr, bytesread, bfr.length - bytesread))\\n                    > 0) {\\n                bytesread += retval;\\n            }\\n        } catch (IOException ioe) {\\n            throw new SqlToolError(ioe);\\n        } finally {\\n            if (is != null) try {\\n                is.close();\\n            } catch (IOException ioe) {\\n                errprintln(rb.getString(SqltoolRB.INPUTFILE_CLOSEFAIL)\\n                        + \\\": \\\" + ioe);\\n            }\\n        }\\n        if (bytesread != bfr.length) {\\n            throw new SqlToolError(rb.getString(SqltoolRB.READ_PARTIAL,\\n                    new String[] {\\n                        Integer.toString(bytesread),\\n                        Integer.toString(bfr.length)\\n                    }));\\n        }\\n        String string = null;\\n        String dateString;\\n        try {\\n            string = ((charset == null)\\n                    ? (new String(bfr)) : (new String(bfr, charset)));\\n        } catch (UnsupportedEncodingException uee) {\\n            throw new RuntimeException(uee);\\n        } catch (RuntimeException re) {\\n            throw new SqlToolError(rb.getString(SqltoolRB.READ_CONVERTFAIL),\\n                    re);\\n        }\\n        List     headerList = new ArrayList();\\n        String    tableName = dsvTargetTable;\\n                int recEnd = -1000;                                     int colStart;\\n        int colEnd;\\n                int lineCount = 0;         int recStart = -1;\\n        String trimmedLine = null;\\n        boolean switching = false;\\n        while (true) {\\n            recStart = (recStart < 0) ? 0 : (recEnd + dsvRowDelim.length());\\n            if (recStart > string.length() - 2) {\\n                throw new SqlToolError(rb.getString(SqltoolRB.DSV_HEADER_NONE));\\n            }\\n            recEnd = string.indexOf(dsvRowDelim, recStart);\\n            lineCount++; \\n            if (recEnd < 0) {\\n                                recEnd = string.length();\\n            }\\n            trimmedLine = string.substring(recStart, recEnd).trim();\\n            if (trimmedLine.length() < 1\\n                    || (skipPrefix != null\\n                            && trimmedLine.startsWith(skipPrefix))) {\\n                continue;\\n            }\\n            if (trimmedLine.startsWith(\\\"targettable=\\\")) {\\n                if (tableName == null) {\\n                    tableName = trimmedLine.substring(\\n                            \\\"targettable=\\\".length()).trim();\\n                }\\n                continue;\\n            }\\n            if (trimmedLine.equals(\\\"headerswitch{\\\")) {\\n                if (tableName == null) {\\n                    throw new SqlToolError(rb.getString(\\n                            SqltoolRB.DSV_HEADER_NOSWITCHTARG, new String[] {\\n                            Integer.toString(lineCount)}));\\n                }\\n                switching = true;\\n                continue;\\n            }\\n            if (trimmedLine.equals(\\\"}\\\")) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.DSV_HEADER_NOSWITCHMATCH, new String[] {\\n                                Integer.toString(lineCount)}));\\n            }\\n            if (!switching) {\\n                break;\\n            }\\n            int colonAt = trimmedLine.indexOf(':');\\n            if (colonAt < 1 || colonAt == trimmedLine.length() - 1) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.DSV_HEADER_NONSWITCHED, new String[] {\\n                                Integer.toString(lineCount)}));\\n            }\\n            String matcher = trimmedLine.substring(0, colonAt).trim();\\n                                    if (matcher.equals(\\\"*\\\") || matcher.equalsIgnoreCase(tableName)){\\n                recStart = 1 + string.indexOf(':', recStart);\\n                break;\\n            }\\n                    }\\n        String headerLine = string.substring(recStart, recEnd);\\n        colStart = recStart;\\n        colEnd   = -1;\\n        String colName;\\n        while (true) {\\n            if (colEnd == recEnd) {\\n                                break;\\n            }\\n            colEnd = string.indexOf(dsvColDelim, colStart);\\n            if (colEnd < 0 || colEnd > recEnd) {\\n                colEnd = recEnd;\\n            }\\n            if (colEnd - colStart < 1) {\\n                throw new SqlToolError(rb.getString(\\n                            SqltoolRB.DSV_NOCOLHEADER, new String[] {\\n                        Integer.toString(headerList.size() + 1),\\n                        Integer.toString(lineCount)\\n                }));\\n            }\\n            colName = string.substring(colStart, colEnd).trim();\\n            headerList.add(\\n                (colName.equals(\\\"-\\\")\\n                        || (ucSkipCols != null\\n                                && ucSkipCols.remove(colName.toUpperCase()))\\n                )\\n                ? ((String) null)\\n                : colName);\\n            colStart = colEnd + dsvColDelim.length();\\n        } if (ucSkipCols != null && ucSkipCols.size() > 0) {\\n            throw new SqlToolError(rb.getString(\\n                    SqltoolRB.DSV_SKIPCOLS_MISSING, new String[] {\\n                            ucSkipCols.toString()}));\\n        }\\n        boolean oneCol = false;          for (int i = 0; i < headerList.size(); i++) {\\n            if (headerList.get(i) != null) {\\n                oneCol = true;\\n                break;\\n            }\\n        }\\n        if (oneCol == false) {\\n                                                throw new SqlToolError((dsvSkipCols == null)\\n                    ? rb.getString(SqltoolRB.DSV_NOCOLSLEFT)\\n                    : (rb.getString(SqltoolRB.DSV_NOCOLSLEFT_WSK,\\n                            new String[] {dsvSkipCols}))\\n            );\\n        }\\n        if (constColMap != null) {\\n            headerList.addAll(constColMap.keySet());\\n        }\\n        String[]  headers   = (String[]) headerList.toArray(new String[0]);\\n        if (tableName == null) {\\n            tableName = file.getName();\\n            int i = tableName.lastIndexOf('.');\\n            if (i > 0) {\\n                tableName = tableName.substring(0, i);\\n            }\\n        }\\n        StringBuffer tmpSb = new StringBuffer();\\n        List tmpList = new ArrayList();\\n        int skippers = 0;\\n        for (int i = 0; i < headers.length; i++) {\\n            if (headers[i] == null) {\\n                skippers++;\\n                continue;\\n            }\\n            if (tmpSb.length() > 0) {\\n                tmpSb.append(\\\", \\\");\\n            }\\n            tmpSb.append(headers[i]);\\n            tmpList.add(headers[i]);\\n        }\\n        boolean[] autonulls = new boolean[headers.length - skippers];\\n        boolean[] parseDate = new boolean[autonulls.length];\\n        boolean[] parseBool = new boolean[autonulls.length];\\n        String[] insertFieldName = (String[]) tmpList.toArray(new String[] {});\\n        StringBuffer sb = new StringBuffer(\\\"INSERT INTO \\\" + tableName + \\\" (\\\"\\n                                           + tmpSb + \\\") VALUES (\\\");\\n        StringBuffer typeQuerySb = new StringBuffer(\\\"SELECT \\\" + tmpSb\\n            + \\\" FROM \\\" + tableName + \\\" WHERE 1 = 2\\\");\\n        try {\\n            ResultSetMetaData rsmd = curConn.createStatement().executeQuery(\\n                typeQuerySb.toString()).getMetaData();\\n            if (rsmd.getColumnCount() != autonulls.length) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.DSV_METADATA_MISMATCH));\\n                                                                                            }\\n            for (int i = 0; i < autonulls.length; i++) {\\n                autonulls[i] = true;\\n                parseDate[i] = false;\\n                parseBool[i] = false;\\n                switch(rsmd.getColumnType(i + 1)) {\\n                    case java.sql.Types.BOOLEAN:\\n                        parseBool[i] = true;\\n                        break;\\n                    case java.sql.Types.VARBINARY :\\n                    case java.sql.Types.VARCHAR :\\n                    case java.sql.Types.ARRAY :\\n                                            case java.sql.Types.BLOB :\\n                    case java.sql.Types.CLOB :\\n                    case java.sql.Types.LONGVARBINARY :\\n                    case java.sql.Types.LONGVARCHAR :\\n                        autonulls[i] = false;\\n                                                                                                break;\\n                    case java.sql.Types.DATE:\\n                    case java.sql.Types.TIME:\\n                    case java.sql.Types.TIMESTAMP:\\n                        parseDate[i] = true;\\n                }\\n            }\\n        } catch (SQLException se) {\\n            throw new SqlToolError(rb.getString(\\n                    SqltoolRB.QUERY_METADATAFAIL, new String[] {\\n                            typeQuerySb.toString()}), se);\\n        }\\n        for (int i = 0; i < autonulls.length; i++) {\\n            if (i > 0) {\\n                sb.append(\\\", \\\");\\n            }\\n            sb.append('?');\\n        }\\n                int rejectCount = 0;\\n        File rejectFile = null;\\n        File rejectReportFile = null;\\n        PrintWriter rejectWriter = null;\\n        PrintWriter rejectReportWriter = null;\\n        if (dsvRejectFile != null) try {\\n            rejectFile = new File(dsvRejectFile);\\n            rejectWriter = new PrintWriter((charset == null)\\n                    ? (new OutputStreamWriter(new FileOutputStream(rejectFile)))\\n                    : (new OutputStreamWriter(new FileOutputStream(rejectFile),\\n                            charset)));\\n                                                                        rejectWriter.print(headerLine + dsvRowDelim);\\n        } catch (IOException ioe) {\\n            throw new SqlToolError(rb.getString(\\n                    SqltoolRB.DSV_REJECTFILE_SETUPFAIL, new String[] {\\n                            dsvRejectFile\\n                    }), ioe);\\n        }\\n        if (dsvRejectReport != null) try {\\n            rejectReportFile = new File(dsvRejectReport);\\n            rejectReportWriter = new PrintWriter((charset == null)\\n                    ? (new OutputStreamWriter(\\n                            new FileOutputStream(rejectReportFile)))\\n                    : (new OutputStreamWriter(\\n                            new FileOutputStream(rejectReportFile), charset)));\\n                                                                        rejectReportWriter.println(rb.getString(\\n                    SqltoolRB.REJECTREPORT_TOP, new String[] {\\n                        (new java.util.Date()).toString(),\\n                        file.getPath(),\\n                        ((rejectFile == null) ? rb.getString(SqltoolRB.NONE)\\n                                        : rejectFile.getPath()),\\n                        ((rejectFile == null)\\n                                ? rb.getString(SqltoolRB.BLOCK_DISABLED)\\n                                : \\\"-->\\\"),\\n                        ((rejectFile == null)\\n                                ? rb.getString(SqltoolRB.BLOCK_DISABLED)\\n                                : \\\"<!--\\\"),\\n                    }));\\n        } catch (IOException ioe) {\\n            throw new SqlToolError(rb.getString(\\n                    SqltoolRB.DSV_REJECTREPORT_SETUPFAIL, new String[] {\\n                            dsvRejectReport\\n                    }), ioe);\\n        }\\n        int recCount = 0;\\n        int skipCount = 0;\\n        PreparedStatement ps = null;\\n        boolean importAborted = false;\\n        try {\\n            try {\\n                ps = curConn.prepareStatement(sb.toString() + ')');\\n            } catch (SQLException se) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.INSERTION_PREPAREFAIL, new String[] {\\n                                sb.toString() }), se);\\n            }\\n            String[] dataVals = new String[autonulls.length];\\n                        int      readColCount;\\n            int      storeColCount;\\n            String   currentFieldName = null;\\n                        while (true) try { try {\\n                recStart = recEnd + dsvRowDelim.length();\\n                if (recStart >= string.length()) {\\n                    break;\\n                }\\n                recEnd = string.indexOf(dsvRowDelim, recStart);\\n                lineCount++; \\n                if (recEnd < 0) {\\n                                        recEnd = string.length();\\n                }\\n                trimmedLine = string.substring(recStart, recEnd).trim();\\n                if (trimmedLine.length() < 1) {\\n                    continue;                  }\\n                if (skipPrefix != null\\n                        && trimmedLine.startsWith(skipPrefix)) {\\n                    skipCount++;\\n                    continue;\\n                }\\n                if (switching) {\\n                    if (trimmedLine.equals(\\\"}\\\")) {\\n                        switching = false;\\n                        continue;\\n                    }\\n                    int colonAt = trimmedLine.indexOf(':');\\n                    if (colonAt < 1 || colonAt == trimmedLine.length() - 1) {\\n                        throw new SqlToolError(rb.getString(\\n                                SqltoolRB.DSV_HEADER_MATCHERNONHEAD,\\n                                        new String[] {\\n                                                Integer.toString(lineCount)}));\\n                    }\\n                    continue;\\n                }\\n                                recCount++;\\n                colStart = recStart;\\n                colEnd   = -1;\\n                readColCount = 0;\\n                storeColCount = 0;\\n                while (true) {\\n                    if (colEnd == recEnd) {\\n                                                break;\\n                    }\\n                    colEnd = string.indexOf(dsvColDelim, colStart);\\n                    if (colEnd < 0 || colEnd > recEnd) {\\n                        colEnd = recEnd;\\n                    }\\n                    if (readColCount == headers.length - constColMapSize) {\\n                        throw new RowError(rb.getString(\\n                                SqltoolRB.DSV_COLCOUNT_MISMATCH,\\n                                        new String[] {\\n                                                Integer.toString(headers.length\\n                                                        - constColMapSize),\\n                                                Integer.toString(1 +\\n                                                        readColCount),\\n                                        }));\\n                    }\\n                    if (headers[readColCount++] != null) {\\n                        dataVals[storeColCount++] =\\n                                string.substring(colStart, colEnd);\\n                    }\\n                    colStart             = colEnd + dsvColDelim.length();\\n                }\\n                if (constColMap != null) {\\n                    Iterator it = constColMap.values().iterator();\\n                    while (it.hasNext()) {\\n                        dataVals[storeColCount++] = (String) it.next();\\n                    }\\n                }\\n                if (readColCount != headers.length - constColMapSize) {\\n                    throw new RowError(rb.getString(\\n                            SqltoolRB.DSV_COLCOUNT_MISMATCH,\\n                                    new String[] {\\n                                            Integer.toString(headers.length\\n                                                    - constColMapSize),\\n                                            Integer.toString(1 +\\n                                                    readColCount),\\n                                    }));\\n                }\\n                if (storeColCount != dataVals.length) {\\n                    throw new RowError(rb.getString(\\n                            SqltoolRB.DSV_COLCOUNT_MISMATCH,\\n                                    new String[] {\\n                                            Integer.toString(dataVals.length\\n                                                    - constColMapSize),\\n                                            Integer.toString(storeColCount\\n                                                    - constColMapSize),\\n                                    }));\\n                }\\n                for (int i = 0; i < dataVals.length; i++) {\\n                    currentFieldName = insertFieldName[i];\\n                    if (autonulls[i]) dataVals[i] = dataVals[i].trim();\\n                    if (parseDate[i]) {\\n                        if ((dataVals[i].length() < 1 && autonulls[i])\\n                              || dataVals[i].equals(nullRepToken)) {\\n                            ps.setTimestamp(i + 1, null);\\n                        } else {\\n                            dateString = (dataVals[i].indexOf(':') > 0)\\n                                       ? dataVals[i]\\n                                       : (dataVals[i] + \\\" 0:00:00\\\");\\n                                                                                    try {\\n                                ps.setTimestamp(i + 1,\\n                                        java.sql.Timestamp.valueOf(dateString));\\n                            } catch (IllegalArgumentException iae) {\\n                                throw new RowError(rb.getString(\\n                                        SqltoolRB.TIME_BAD, new String[] {\\n                                                dateString\\n                                        }), iae);\\n                            }\\n                        }\\n                    } else if (parseBool[i]) {\\n                        if ((dataVals[i].length() < 1 && autonulls[i])\\n                              || dataVals[i].equals(nullRepToken)) {\\n                            ps.setNull(i + 1, java.sql.Types.BOOLEAN);\\n                        } else {\\n                            try {\\n                                ps.setBoolean(i + 1, Boolean.valueOf(\\n                                        dataVals[i]).booleanValue());\\n                                                                                            } catch (IllegalArgumentException iae) {\\n                                throw new RowError(rb.getString(\\n                                        SqltoolRB.BOOLEAN_BAD, new String[] {\\n                                                dataVals[i]\\n                                        }), iae);\\n                            }\\n                        }\\n                    } else {\\n                        ps.setString(\\n                            i + 1,\\n                            (((dataVals[i].length() < 1 && autonulls[i])\\n                              || dataVals[i].equals(nullRepToken))\\n                             ? null\\n                             : dataVals[i]));\\n                    }\\n                    currentFieldName = null;\\n                }\\n                retval = ps.executeUpdate();\\n                if (retval != 1) {\\n                    throw new RowError(rb.getString(\\n                            SqltoolRB.INPUTREC_MODIFIED, new String[] {\\n                                    Integer.toString(retval)\\n                            }));\\n                }\\n                possiblyUncommitteds.set(true);\\n            } catch (SQLException se) {\\n                throw new RowError(null, se);\\n            } } catch (RowError re) {\\n                rejectCount++;\\n                if (rejectWriter != null || rejectReportWriter != null) {\\n                    if (rejectWriter != null) {\\n                        rejectWriter.print(string.substring(\\n                                recStart, recEnd) + dsvRowDelim);\\n                    }\\n                    if (rejectReportWriter != null) {\\n                        genRejectReportRecord(rejectReportWriter,\\n                                rejectCount, lineCount,\\n                                currentFieldName, re.getMessage(),\\n                                re.getCause());\\n                    }\\n                } else {\\n                    importAborted = true;\\n                    throw new SqlToolError(((currentFieldName == null)\\n                            ? rb.getString(SqltoolRB.DSV_RECIN_FAIL,\\n                                    new String[] {Integer.toString(lineCount)})\\n                            : rb.getString(SqltoolRB.DSV_RECIN_FAIL_WCOL,\\n                                    new String[] {\\n                                            Integer.toString(lineCount),\\n                                            currentFieldName,\\n                                    }\\n                            )) + ((re.getMessage() == null)\\n                                    ? \\\"\\\" : (\\\"  \\\" + re.getMessage())),\\n                                            re.getCause());\\n                }\\n            }\\n        } finally {\\n            String summaryString = null;\\n            if (recCount > 0) {\\n                summaryString = rb.getString((importAborted\\n                        ? SqltoolRB.DSV_IMPORT_SUMMARY_WABORT\\n                        : SqltoolRB.DSV_IMPORT_SUMMARY),\\n                        new String[] {\\n                                ((skipPrefix == null)\\n                                          ? \\\"\\\" : (\\\"'\\\" + skipPrefix + \\\"'-\\\")),\\n                                Integer.toString(skipCount),\\n                                Integer.toString(rejectCount),\\n                                Integer.toString(recCount - rejectCount),\\n                        });\\n                stdprintln(summaryString);\\n            }\\n            try {\\n                if (recCount > rejectCount && !curConn.getAutoCommit()) {\\n                    stdprintln(rb.getString(SqltoolRB.INSERTIONS_NOTCOMMITTED));\\n                }\\n            } catch (SQLException se) {\\n                stdprintln(rb.getString(SqltoolRB.AUTOCOMMIT_FETCHFAIL));\\n                stdprintln(rb.getString(SqltoolRB.INSERTIONS_NOTCOMMITTED));\\n                                            }\\n            if (rejectWriter != null) {\\n                rejectWriter.flush();\\n                rejectWriter.close();\\n            }\\n            if (rejectReportWriter != null && rejectCount > 0) {\\n                rejectReportWriter.println(rb.getString(\\n                        SqltoolRB.REJECTREPORT_BOTTOM, new String[] {\\n                            summaryString,\\n                            revnum,\\n                        }));\\n                rejectReportWriter.flush();\\n                rejectReportWriter.close();\\n            }\\n            if (rejectCount == 0) {\\n                if (rejectFile != null && rejectFile.exists()\\n                        && !rejectFile.delete())\\n                    errprintln(rb.getString(SqltoolRB.DSV_REJECTFILE_PURGEFAIL,\\n                            new String[] {rejectFile.toString()}));\\n                if (rejectReportFile != null && !rejectReportFile.delete())\\n                    errprintln(rb.getString(\\n                            SqltoolRB.DSV_REJECTREPORT_PURGEFAIL,\\n                            new String[] {rejectFile.toString()}));\\n                            }\\n        }\\n    }\\n    public static void appendLine(StringBuffer sb, String s) {\\n        sb.append(s + LS);\\n    }\\n    static private String[] genWinArgs(String monolithic) {\\n        List list = new ArrayList();\\n        list.add(\\\"cmd.exe\\\");\\n        list.add(\\\"/y\\\");\\n        list.add(\\\"/c\\\");\\n        Matcher m = wincmdPattern.matcher(monolithic);\\n        String[] internalTokens;\\n        while (m.find()) {\\n            for (int i = 1; i <= m.groupCount(); i++) {\\n                if (m.group(i) == null) continue;\\n                if (m.group(i).length() > 1 && m.group(i).charAt(0) == '\\\"') {\\n                    list.add(m.group(i).substring(1, m.group(i).length() - 1));\\n                    continue;\\n                }\\n                internalTokens = m.group(i).split(\\\"\\\\\\\\s+\\\");\\n                for (int j = 0; j < internalTokens.length; j++)\\n                    list.add(internalTokens[j]);\\n            }\\n        }\\n        return (String[]) list.toArray(new String[] {});\\n    }\\n    private void genRejectReportRecord(PrintWriter pw, int rCount,\\n            int lCount, String field, String eMsg, Throwable cause) {\\n        pw.println(rb.getString(SqltoolRB.REJECTREPORT_ROW,\\n                new String[] {\\n                    ((rCount % 2 == 0) ? \\\"even\\\" : \\\"odd\\\") + \\\"row\\\",\\n                    Integer.toString(rCount),\\n                    Integer.toString(lCount),\\n                    ((field == null) ? \\\"&nbsp;\\\" : field),\\n                    (((eMsg == null) ? \\\"\\\" : eMsg)\\n                            + ((eMsg == null || cause == null) ? \\\"\\\" : \\\"<HR/>\\\")\\n                            + ((cause == null) ? \\\"\\\" : (\\n                                    (cause instanceof SQLException\\n                                            && cause.getMessage() != null)\\n                                        ? cause.getMessage()\\n                                        : cause.toString()\\n                                    )\\n                            )\\n                    )\\n                }));\\n    }\\n}\""
        },
        {
            "content": "From the source code analysis of `SqlFile.java`, we can observe the following:\n\n### Key Observations:\n1. **Dependencies and Imports**:\n   - `SqlFile.java` imports numerous Java standard libraries, including I/O, SQL, and utility packages.\n   - It also references several internal classes like `SqltoolRB`, `AppendableException`, and others that appear to be part of the HSQLDB project.\n\n2. **Relationship with `SqlTool.java`**:\n   - The class `SqlFile` appears to be tightly integrated with `SqlTool.java`. This is evident from the co-change relationship where `SqlTool.java` had a confidence score of 0.72 \u2014 indicating frequent changes together.\n   - `SqlFile` uses resource bundles (`SqltoolRB`) and exceptions (`AppendableException`, `SqlToolError`) that are likely defined or coordinated in `SqlTool.java`.\n\n3. **Functionality**:\n   - `SqlFile` deals with reading and processing SQL files, handling user input, managing variables, executing SQL commands, and providing advanced features like scripting, looping, and conditional execution.\n   - It heavily interacts with the database using JDBC APIs, which suggests dependencies on other utility classes for SQL execution and result handling.\n\n4. **Internal Classes**:\n   - Internal classes like `BooleanBucket`, `QuitNow`, `BreakException`, etc., are defined within `SqlFile.java`. These may have counterparts or be referenced in other parts of the system such as `SqlTool.java`.\n\n---\n\n### Next Steps in CIA:\nTo determine the ripple effect of a change in `SqlFile.java`, we should focus on entities that:\n- Directly depend on `SqlFile`.\n- Are frequently co-changed with it (like `SqlTool.java`).\n- Share conceptual coupling (i.e., semantically related code).\n\n#### Let's proceed with the following steps:\n1. **Check Coupling Dependencies**: We will call `get_coupling_dependencies` between `SqlFile.java` and `SqlTool.java` to see if there are any direct structural dependencies.\n\n2. **Conceptual Coupling**: Use `get_conceptual_coupling` between `SqlFile.java` and key co-changed files (e.g., `SqlTool.java`, `SqltoolRB.java`) to assess semantic similarity.\n\nI'll start by checking coupling dependencies between `SqlFile.java` and `SqlTool.java`.\n\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_4a39ff0c698b4f23abe9d4",
                    "function": {
                        "arguments": "{\"entity1\": \"SqlFile.java\", \"entity2\": \"SqlTool.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"There are no coupling dependencies between these two entities\"]"
        },
        {
            "content": "The result indicates that there are **no direct structural coupling dependencies** between `SqlFile.java` and `SqlTool.java`. This suggests that the two classes do not directly reference or depend on each other through standard code-level relationships (e.g., inheritance, method calls, variable usage).\n\nHowever, from the co-change analysis and source code inspection, we know that:\n- `SqlFile.java` uses several classes and exceptions (`AppendableException`, `SqlToolError`, `SqltoolRB`) that are likely tied to `SqlTool.java`.\n- The high co-change confidence (0.72) implies a **semantic or functional dependency**, even if no direct syntactic coupling exists.\n\n### Next Step: Analyze Conceptual Coupling\nTo better understand the relationship between `SqlFile.java` and `SqlTool.java`, we should analyze their **conceptual coupling** \u2014 i.e., whether they share similar semantics or topics in their code, even without direct references.\n\nI will now call `get_conceptual_coupling` between `SqlFile.java` and `SqlTool.java`.\n\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_03afcbd1e19f4c288bef4f",
                    "function": {
                        "arguments": "{\"entity1\": \"SqlFile.java\", \"entity2\": \"SqlTool.java\"}",
                        "name": "get_conceptual_coupling"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_conceptual_coupling",
            "content": "\"0.7136133\""
        },
        {
            "content": "The conceptual coupling similarity score between `SqlFile.java` and `SqlTool.java` is **0.7136**, which indicates a **strong semantic relationship** between the two files.\n\n### Interpretation:\n- Although there are no direct structural dependencies (method calls, inheritance, etc.), the high conceptual coupling suggests that these two classes likely share similar responsibilities, logic, or domain context.\n- This aligns with our earlier observation from co-change data: these files are frequently modified together because they logically collaborate in the system \u2014 even if indirectly.\n\n### Conclusion of CIA So Far:\n1. **Co-Change Relationship**: Strong (confidence = 0.72).\n2. **Structural Coupling**: No direct coupling found.\n3. **Conceptual Coupling**: High similarity (0.7136), indicating shared functionality or domain logic.\n\nThis implies that changes to `SqlFile.java` could **semantically impact** `SqlTool.java`, especially since both appear to be involved in SQL execution, scripting, and error handling within the HSQLDB utility suite.\n\n---\n\n### Recommendation for Synchronization:\nTo ensure consistency:\n- Any change affecting SQL processing logic, script parsing, or error handling in `SqlFile.java` should be reviewed in `SqlTool.java`.\n- Consider synchronizing updates to resource bundles (`SqltoolRB.java`) and shared exceptions like `SqlToolError.java`.\n\nWould you like me to:\n1. Analyze conceptual coupling between `SqlFile.java` and other highly co-changed entities (e.g., `SqltoolRB.java`, `SqlToolError.java`)?\n2. Proceed to analyze the call graph or dependencies of `SqlTool.java`?\n\nLet me know how you'd like to proceed!",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        },
        {
            "role": "user",
            "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
        },
        {
            "content": "Title: Diagnosis of starting entity `SqlFile.java`\n\nChange set: [SqlTool.java, SqltoolRB.java, AppendableException.java, SqlToolError.java, BooleanBucket.java, RCData.java, ScriptWriterText.java, SqlToolSprayer.java, ValidatingResourceBundle.java, RefCapablePropertyResourceBundle.java, SharedFields.java, TokenList.java, Token.java, TokenSource.java, DatabaseManagerSwing.java, DatabaseManager.java, TarGenerator.java, TarHeaderFields.java, TarReader.java, TarFileOutputStream.java, TarFileInputStream.java, TarEntrySupplicant.java, SimpleLog.java, PrivateException.java, RB.java, PIFData.java, RowError.java, BadSubst.java, ContinueException.java, BreakException.java, QuitNow.java, FrameworkLogger.java, AuthUtils.java, AuthBeanMultiplexer.java, ToolLogger.java, DbBackup.java, Calculator.java, Atom.java, BadCmdline.java, BadSpecial.java]\n\nDetails:\n1. **SqlTool.java**: Strong co-change confidence (0.72), conceptual coupling score (0.7136). Shares core SQL execution and scripting logic with SqlFile.\n\n2. **SqltoolRB.java**: Used directly in `SqlFile` for resource handling. Likely involved in error messages and internationalization used across both `SqlFile` and `SqlTool`.\n\n3. **AppendableException.java**: Extended by inner classes in `SqlFile`, likely shared exception hierarchy also used in `SqlTool`.\n\n4. **SqlToolError.java**: Used as a custom error type in `SqlFile`. High co-change relationship suggests shared error-handling logic.\n\n5. **BooleanBucket.java**: Defined internally in `SqlFile`, but has external counterparts that may be shared or referenced elsewhere like in `SqlTool`.\n\n6. **RCData.java**: Frequent co-change (support = 6, confidence = 0.166). May represent data structures used in result handling or script processing.\n\n7. **ScriptWriterText.java**: Co-changed infrequently but appears to be related to output generation which aligns with the DSV/SQL output features in `SqlFile`.\n\n8. **SqlToolSprayer.java**: Co-change support = 7 (confidence = 0.194). May relate to command dispatching or dynamic execution features.\n\n9. **ValidatingResourceBundle.java**: Support = 6 (0.166). Resource bundle validation is central to both localization and configuration logic in SQL tools.\n\n10. **RefCapablePropertyResourceBundle.java**: Support = 9 (0.25). Related to advanced resource handling; used alongside `SqltoolRB`.\n\n11. **SharedFields.java**: Support = 2 (0.055). Likely contains constants or shared metadata used across multiple utility classes including `SqlFile`.\n\n12. **TokenList.java**: Support = 2 (0.055). Suggests involvement in parsing or tokenizing SQL scripts\u2014core to `SqlFile`'s functionality.\n\n13. **Token.java**: Support = 3 (0.083). Part of the lexical analysis layer, possibly used in both `SqlFile` and other tool components.\n\n14. **TokenSource.java**: Support = 1 (0.027). Likely an interface or base class for token stream providers.\n\n15. **DatabaseManagerSwing.java**: Support = 1 (0.027). May use `SqlFile` indirectly via UI-driven script execution.\n\n16. **DatabaseManager.java**: Support = 1 (0.027). Core database management component that may invoke SQL files or scripting utilities.\n\n17. **TarGenerator.java**, **TarHeaderFields.java**, **TarReader.java**, **TarFileOutputStream.java**, **TarFileInputStream.java**, **TarEntrySupplicant.java**: These are part of file packaging or archive utilities. Could be used in backup/export operations involving SQL scripts.\n\n18. **SimpleLog.java**: Support = 1 (0.027). Logging infrastructure used across utility classes.\n\n19. **PrivateException.java**: Support = 1 (0.027). Possibly a base class for internal exceptions.\n\n20. **RB.java**: Support = 1 (0.027). Likely another resource bundle utility used in parallel with `SqltoolRB`.\n\n21. **PIFData.java**: Support = 3 (0.083). Possibly related to import/export or persistent intermediate format data.\n\n22. **RowError.java**: Support = 3 (0.083). Used during DSV or SQL result processing\u2014directly handled in `SqlFile`.\n\n23. **BadSubst.java**: Support = 1 (0.027). Thrown during substitution errors\u2014defined in `SqlFile`, likely used in similar contexts elsewhere.\n\n24. **ContinueException.java**, **BreakException.java**, **QuitNow.java**: Used internally in `SqlFile` for control flow in scripting mode. Likely shared with `SqlTool` or other script interpreters.\n\n25. **FrameworkLogger.java**, **AuthUtils.java**, **AuthBeanMultiplexer.java**, **ToolLogger.java**: Infrastructure classes potentially used for logging, authentication, and integration with larger systems.\n\n26. **DbBackup.java**: Support = 2 (0.055). May involve SQL script execution or file reading, hence co-change likelihood.\n\n27. **Calculator.java**, **Atom.java**: Possibly used in expression evaluation during scripting.\n\n28. **BadCmdline.java**: Support = 2 (0.055). Related to command-line parsing, a shared concern in CLI-based SQL tools.\n\n29. **CSVWriter.java**, **MainInvoker.java**, **BadSpecial.java**, etc.: Additional classes with low co-change support but semantically relevant roles in SQL scripting or file handling.\n\nThese entities were selected based on co-change history, conceptual similarity, semantic relevance, and inferred functional dependencies. All changes impacting SQL parsing, scripting, result handling, or resource management in `SqlFile.java` should consider synchronizing changes in these files to avoid inconsistencies.",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        }
    ],
    "interaction_records": {
        "step_histories": [
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4"
                ],
                "response_message": "m5"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6"
                ],
                "response_message": "m7"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8"
                ],
                "response_message": "m9"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10"
                ],
                "response_message": "m11"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12"
                ],
                "response_message": "m13"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14"
                ],
                "response_message": "m15"
            }
        ],
        "mid_to_message": {
            "m1": {
                "role": "system",
                "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
            },
            "m2": {
                "role": "user",
                "content": "The project you need to analyze is `hsqldb`, a well-known Java open source project. The starting entity you need to deal with is SqlFile.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
            },
            "m3": {
                "content": "",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_b6a2246d6c8045fba7477b",
                        "function": {
                            "arguments": "{\"entity\": \"SqlFile.java\"}",
                            "name": "get_co_change_relationship"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m4": {
                "name": "get_co_change_relationship",
                "role": "tool",
                "content": "[[\"RCData\", \"6\", \"0.16666666666666666\"], [\"AppendableException\", \"4\", \"0.1111111111111111\"], [\"SqlToolSprayer\", \"7\", \"0.19444444444444445\"], [\"BooleanBucket\", \"2\", \"0.05555555555555555\"], [\"SqlToolException\", \"2\", \"0.05555555555555555\"], [\"BadCmdline\", \"2\", \"0.05555555555555555\"], [\"ContinueException\", \"1\", \"0.027777777777777776\"], [\"BreakException\", \"1\", \"0.027777777777777776\"], [\"QuitNow\", \"1\", \"0.027777777777777776\"], [\"SqlToolError\", \"4\", \"0.1111111111111111\"], [\"ScriptWriterText\", \"1\", \"0.027777777777777776\"], [\"SqlTool\", \"26\", \"0.7222222222222222\"], [\"CSVWriter\", \"1\", \"0.027777777777777776\"], [\"MainInvoker\", \"1\", \"0.027777777777777776\"], [\"RowError\", \"3\", \"0.08333333333333333\"], [\"BadSpecial\", \"2\", \"0.05555555555555555\"], [\"BadSubst\", \"1\", \"0.027777777777777776\"], [\"ValidatingResourceBundle\", \"6\", \"0.16666666666666666\"], [\"RefCapablePropertyResourceBundle\", \"9\", \"0.25\"], [\"SqltoolRB\", \"13\", \"0.3611111111111111\"], [\"DatabaseManagerSwing\", \"1\", \"0.027777777777777776\"], [\"SqlFileScanner\", \"4\", \"0.1111111111111111\"], [\"DatabaseManager\", \"1\", \"0.027777777777777776\"], [\"SharedFields\", \"2\", \"0.05555555555555555\"], [\"SimpleLog\", \"1\", \"0.027777777777777776\"], [\"PrivateException\", \"1\", \"0.027777777777777776\"], [\"RB\", \"1\", \"0.027777777777777776\"], [\"TokenList\", \"2\", \"0.05555555555555555\"], [\"TarGenerator\", \"1\", \"0.027777777777777776\"], [\"TarHeaderFields\", \"1\", \"0.027777777777777776\"], [\"PIFData\", \"3\", \"0.08333333333333333\"], [\"TarFileOutputStream\", \"1\", \"0.027777777777777776\"], [\"TarFileInputStream\", \"1\", \"0.027777777777777776\"], [\"TarEntrySupplicant\", \"1\", \"0.027777777777777776\"], [\"DbBackup\", \"2\", \"0.05555555555555555\"], [\"TarReader\", \"1\", \"0.027777777777777776\"], [\"Token\", \"3\", \"0.08333333333333333\"], [\"TokenSource\", \"1\", \"0.027777777777777776\"], [\"Calculator\", \"1\", \"0.027777777777777776\"], [\"Atom\", \"1\", \"0.027777777777777776\"], [\"FrameworkLogger\", \"1\", \"0.027777777777777776\"], [\"AuthUtils\", \"1\", \"0.027777777777777776\"], [\"AuthBeanMultiplexer\", \"1\", \"0.027777777777777776\"], [\"ToolLogger\", \"1\", \"0.027777777777777776\"]]"
            },
            "m5": {
                "content": "The co-change relationships for `SqlFile.java` have been retrieved, and the results indicate various entities that are frequently modified together with `SqlFile.java`. The most significant co-changed entity is `SqlTool.java` with a high confidence of 0.72.\n\nTo proceed with the CIA task, we should investigate further how these co-changed entities are related to `SqlFile.java`. To understand the ripple effects, it's important to explore:\n\n1. **Call Graph**: Understand which entities are directly called or referenced by `SqlFile.java`.\n2. **Coupling Dependencies**: Analyze dependencies between `SqlFile.java` and the top co-changed entities (e.g., `SqlTool.java`, `SqltoolRB.java`, etc.) to determine if there are strong ties.\n3. **Conceptual Coupling**: Check semantic similarities between `SqlFile.java` and highly co-changed files to identify potential indirect impacts.\n\nLet us first examine the **call graph** of `SqlFile.java` to find out what entities it directly interacts with. \n\nI will now call the `get_call_graph` function on `SqlFile.java`. \n\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_52cc4191a5f54e8aa77c7e",
                        "function": {
                            "arguments": "{\"entity\": \"SqlFile.java\"}",
                            "name": "get_call_graph"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m6": {
                "role": "tool",
                "name": "get_call_graph",
                "content": "[]"
            },
            "m7": {
                "content": "The call graph for `SqlFile.java` is empty, which suggests that either:\n\n1. `SqlFile.java` does not directly invoke or reference any other entities in the current context.\n2. The parsing mechanism might have failed to extract the call information correctly.\n\nGiven this result, we need to further inspect the source code of `SqlFile.java` to understand its structure and identify potential interactions manually. This will help us determine if there are any implicit dependencies or reasons why certain files (like `SqlTool.java`) appear to be strongly co-changed with `SqlFile.java`.\n\nNext, I will retrieve the origin code of `SqlFile.java` for analysis:\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_6ef95cf41289419d92a27a",
                        "function": {
                            "arguments": "{\"entity\": \"SqlFile.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m8": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package org.hsqldb.util;\\nimport java.io.BufferedReader;\\nimport java.io.ByteArrayOutputStream;\\nimport java.io.File;\\nimport java.io.FileInputStream;\\nimport java.io.FileNotFoundException;\\nimport java.io.FileOutputStream;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nimport java.io.InputStreamReader;\\nimport java.io.OutputStreamWriter;\\nimport java.io.PrintStream;\\nimport java.io.PrintWriter;\\nimport java.io.UnsupportedEncodingException;\\nimport java.sql.Connection;\\nimport java.sql.DatabaseMetaData;\\nimport java.sql.PreparedStatement;\\nimport java.sql.ResultSet;\\nimport java.sql.ResultSetMetaData;\\nimport java.sql.SQLException;\\nimport java.sql.Statement;\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.Iterator;\\nimport java.util.List;\\nimport java.util.Set;\\nimport java.util.HashSet;\\nimport java.util.Map;\\nimport java.util.SortedMap;\\nimport java.util.TreeMap;\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\nimport java.util.regex.PatternSyntaxException;\\npublic class SqlFile {\\n    private static final int DEFAULT_HISTORY_SIZE = 40;\\n    private File             file;\\n    private boolean          interactive;\\n    private String           primaryPrompt    = \\\"sql> \\\";\\n    private String           rawPrompt      = null;\\n    private String           contPrompt       = \\\"  +> \\\";\\n    private Connection       curConn          = null;\\n    private boolean          htmlMode         = false;\\n    private Map              userVars;     private List             history          = null;\\n    private int              rawMode          = RAW_FALSE;\\n    private String           nullRepToken     = null;\\n    private String           dsvTargetFile    = null;\\n    private String           dsvTargetTable   = null;\\n    private String           dsvConstCols     = null;\\n    private String           dsvRejectFile    = null;\\n    private String           dsvRejectReport  = null;\\n    public static String     LS = System.getProperty(\\\"line.separator\\\");\\n    private int              maxHistoryLength = 1;\\n    private SqltoolRB        rb               = null;\\n    private static final int RAW_FALSE = 0;     private static final int RAW_EMPTY = 1;     private static final int RAW_DATA  = 2; \\n    private static Pattern   specialPattern   =\\n            Pattern.compile(\\\"\\\\\\\\s*\\\\\\\\\\\\\\\\(\\\\\\\\S+)(?:\\\\\\\\s+(.*\\\\\\\\S))?\\\\\\\\s*\\\");\\n    private static Pattern   plPattern   =\\n            Pattern.compile(\\\"\\\\\\\\s*\\\\\\\\*\\\\\\\\s*(.*\\\\\\\\S)?\\\\\\\\s*\\\");\\n    private static Pattern   foreachPattern   =\\n            Pattern.compile(\\\"\\\\\\\\s*\\\\\\\\*\\\\\\\\s*foreach\\\\\\\\s+(\\\\\\\\S+)\\\\\\\\s*\\\\\\\\(([^)]*)\\\\\\\\)\\\\\\\\s*\\\");\\n    private static Pattern   ifwhilePattern   =\\n            Pattern.compile(\\\"\\\\\\\\s*\\\\\\\\*\\\\\\\\s*\\\\\\\\S+\\\\\\\\s*\\\\\\\\(([^)]*)\\\\\\\\)\\\\\\\\s*\\\");\\n    private static Pattern   varsetPattern   =\\n            Pattern.compile(\\\"\\\\\\\\s*\\\\\\\\*\\\\\\\\s*(\\\\\\\\S+)\\\\\\\\s*([=_~])\\\\\\\\s*(?:(.*\\\\\\\\S)\\\\\\\\s*)?\\\");\\n    private static Pattern   substitutionPattern   =\\n            Pattern.compile(\\\"\\\\\\\\s*s(\\\\\\\\S)(.+?)\\\\\\\\1(.*?)\\\\\\\\1(.+)?\\\\\\\\s*\\\");\\n                private static Pattern wincmdPattern = null;\\n    static {\\n        if (System.getProperty(\\\"os.name\\\").startsWith(\\\"Windows\\\")) {\\n            wincmdPattern = Pattern.compile(\\\"([^\\\\\\\"]+)?(\\\\\\\"[^\\\\\\\"]*\\\\\\\")?\\\");\\n        }\\n    }\\n    private void updateUserSettings() {\\n        dsvSkipPrefix = SqlFile.convertEscapes(\\n                (String) userVars.get(\\\"*DSV_SKIP_PREFIX\\\"));\\n        if (dsvSkipPrefix == null) {\\n            dsvSkipPrefix = DEFAULT_SKIP_PREFIX;\\n        }\\n        dsvSkipCols = (String) userVars.get(\\\"*DSV_SKIP_COLS\\\");\\n        dsvColDelim =\\n            SqlFile.convertEscapes((String) userVars.get(\\\"*DSV_COL_DELIM\\\"));\\n        if (dsvColDelim == null) {\\n            dsvColDelim =\\n                SqlFile.convertEscapes((String) userVars.get(\\\"*CSV_COL_DELIM\\\"));\\n        }\\n        if (dsvColDelim == null) {\\n            dsvColDelim = DEFAULT_COL_DELIM;\\n        }\\n        dsvRowDelim =\\n            SqlFile.convertEscapes((String) userVars.get(\\\"*DSV_ROW_DELIM\\\"));\\n        if (dsvRowDelim == null) {\\n            dsvRowDelim =\\n                SqlFile.convertEscapes((String) userVars.get(\\\"*CSV_ROW_DELIM\\\"));\\n        }\\n        if (dsvRowDelim == null) {\\n            dsvRowDelim = DEFAULT_ROW_DELIM;\\n        }\\n        dsvTargetFile = (String) userVars.get(\\\"*DSV_TARGET_FILE\\\");\\n        if (dsvTargetFile == null) {\\n            dsvTargetFile = (String) userVars.get(\\\"*CSV_FILEPATH\\\");\\n        }\\n        dsvTargetTable = (String) userVars.get(\\\"*DSV_TARGET_TABLE\\\");\\n        if (dsvTargetTable == null) {\\n            dsvTargetTable = (String) userVars.get(\\\"*CSV_TABLENAME\\\");\\n                    }\\n        dsvConstCols = (String) userVars.get(\\\"*DSV_CONST_COLS\\\");\\n        dsvRejectFile = (String) userVars.get(\\\"*DSV_REJECT_FILE\\\");\\n        dsvRejectReport = (String) userVars.get(\\\"*DSV_REJECT_REPORT\\\");\\n        nullRepToken = (String) userVars.get(\\\"*NULL_REP_TOKEN\\\");\\n        if (nullRepToken == null) {\\n            nullRepToken = (String) userVars.get(\\\"*CSV_NULL_REP\\\");\\n        }\\n        if (nullRepToken == null) {\\n            nullRepToken = DEFAULT_NULL_REP;\\n        }\\n    }\\n    private static class BooleanBucket {\\n        BooleanBucket() {}\\n        private boolean bPriv = false;\\n        public void set(boolean bIn) {\\n            bPriv = bIn;\\n        }\\n        public boolean get() {\\n            return bPriv;\\n        }\\n    }\\n    BooleanBucket possiblyUncommitteds = new BooleanBucket();\\n    private static final String DIVIDER =\\n        \\\"-----------------------------------------------------------------\\\"\\n        + \\\"-----------------------------------------------------------------\\\";\\n        private static final String SPACES =\\n        \\\"                                                                 \\\"\\n        + \\\"                                                                 \\\";\\n        private static String revnum = null;\\n    static {\\n        revnum = \\\"$Revision: 315 $\\\".substring(\\\"$Revision: \\\".length(),\\n                \\\"$Revision: 315 $\\\".length() - 2);\\n    }\\n    private String DSV_OPTIONS_TEXT = null;\\n    private String D_OPTIONS_TEXT = null;\\n    private String RAW_LEADIN_MSG = null;\\n    public SqlFile(File inFile, boolean inInteractive, Map inVars)\\n            throws IOException {\\n                        try {\\n            rb = new SqltoolRB();\\n            rb.validate();\\n            rb.setMissingPosValueBehavior(\\n                    ValidatingResourceBundle.NOOP_BEHAVIOR);\\n            rb.setMissingPropertyBehavior(\\n                    ValidatingResourceBundle.NOOP_BEHAVIOR);\\n        } catch (RuntimeException re) {\\n            System.err.println(\\\"Failed to initialize resource bundle\\\");\\n            throw re;\\n        }\\n        rawPrompt = rb.getString(SqltoolRB.RAWMODE_PROMPT) + \\\"> \\\";\\n        DSV_OPTIONS_TEXT = rb.getString(SqltoolRB.DSV_OPTIONS);\\n        D_OPTIONS_TEXT = rb.getString(SqltoolRB.D_OPTIONS);\\n        RAW_LEADIN_MSG = rb.getString(SqltoolRB.RAW_LEADIN);\\n        DSV_X_SYNTAX_MSG = rb.getString(SqltoolRB.DSV_X_SYNTAX);\\n        DSV_M_SYNTAX_MSG = rb.getString(SqltoolRB.DSV_M_SYNTAX);\\n        nobufferYetString = rb.getString(SqltoolRB.NOBUFFER_YET);\\n        file        = inFile;\\n        interactive = inInteractive;\\n        userVars    = inVars;\\n        if (userVars == null) {\\n            userVars = new HashMap();\\n        }\\n        updateUserSettings();\\n        if (file != null &&!file.canRead()) {\\n            throw new IOException(rb.getString(SqltoolRB.SQLFILE_READFAIL,\\n                    new String[] {file.toString()} ));\\n        }\\n        if (interactive) {\\n            history = new ArrayList();\\n            String histLenString = System.getProperty(\\\"sqltool.historyLength\\\");\\n            if (histLenString != null) try {\\n                maxHistoryLength = Integer.parseInt(histLenString);\\n            } catch (Exception e) {\\n            } else {\\n                maxHistoryLength = DEFAULT_HISTORY_SIZE;\\n            }\\n        }\\n    }\\n    public SqlFile(boolean inInteractive, Map inVars) throws IOException {\\n        this(null, inInteractive, inVars);\\n    }\\n    public void execute(Connection conn,\\n                        Boolean coeOverride)\\n                        throws SqlToolError, SQLException {\\n        execute(conn, System.out, System.err, coeOverride);\\n    }\\n    public void execute(Connection conn,\\n                        boolean coeOverride)\\n                        throws SqlToolError, SQLException {\\n        execute(conn, System.out, System.err, new Boolean(coeOverride));\\n    }\\n        public boolean      recursed     = false;\\n    private String      lastSqlStatement   = null;\\n    private int         curLinenum   = -1;\\n    private PrintStream psStd        = null;\\n    private PrintStream psErr        = null;\\n    private PrintWriter pwQuery      = null;\\n    private PrintWriter pwDsv        = null;\\n    StringBuffer        immCmdSB     = new StringBuffer();\\n    private boolean             continueOnError = false;\\n    private static final String DEFAULT_CHARSET = null;\\n        private BufferedReader      br              = null;\\n    private String              charset         = null;\\n    private String              buffer          = null;\\n    private boolean             withholdPrompt  = false;\\n    public synchronized void execute(Connection conn, PrintStream stdIn,\\n                                     PrintStream errIn,\\n                                     Boolean coeOverride)\\n                                     throws SqlToolError,\\n                                         SQLException {\\n        psStd      = stdIn;\\n        psErr      = errIn;\\n        curConn    = conn;\\n        curLinenum = -1;\\n        String  inputLine;\\n        String  trimmedInput;\\n        String  deTerminated;\\n        boolean inComment = false;            int     postCommentIndex;\\n        boolean rollbackUncoms = true;\\n        continueOnError = (coeOverride == null) ? interactive\\n                                                : coeOverride.booleanValue();\\n        if (userVars.size() > 0) {\\n            plMode = true;\\n        }\\n        String specifiedCharSet = System.getProperty(\\\"sqlfile.charset\\\");\\n        charset = ((specifiedCharSet == null) ? DEFAULT_CHARSET\\n                                              : specifiedCharSet);\\n        try {\\n            br = new BufferedReader((charset == null)\\n                    ?  (new InputStreamReader((file == null)\\n                            ? System.in : (new FileInputStream(file))))\\n                    :  (new InputStreamReader(((file == null)\\n                            ? System.in : (new FileInputStream(file))),\\n                                    charset)));\\n                                    curLinenum = 0;\\n            if (interactive) {\\n                stdprintln(\\n                        rb.getString(SqltoolRB.SQLFILE_BANNER,\\n                        new String[] {revnum}));\\n            }\\n            while (true) {\\n                if (withholdPrompt) {\\n                    withholdPrompt = false;\\n                } else if (interactive) {\\n                    psStd.print((immCmdSB.length() > 0 || rawMode == RAW_DATA)\\n                            ? contPrompt : ((rawMode == RAW_FALSE)\\n                                    ? primaryPrompt : rawPrompt));\\n                }\\n                inputLine = br.readLine();\\n                if (inputLine == null) {\\n                    if (interactive) {\\n                        psStd.println();\\n                    }\\n                    break;\\n                }\\n                curLinenum++;\\n                if (inComment) {\\n                    postCommentIndex = inputLine.indexOf(\\\"*/\\\") + 2;\\n                    if (postCommentIndex > 1) {\\n                                                inputLine = inputLine.substring(postCommentIndex);\\n                                                                                                immCmdSB.setLength(0);\\n                        inComment = false;\\n                    } else {\\n                                                continue;\\n                    }\\n                }\\n                trimmedInput = inputLine.trim();\\n                try {\\n                    if (rawMode != RAW_FALSE) {\\n                        boolean rawExecute = inputLine.equals(\\\".;\\\");\\n                        if (rawExecute || inputLine.equals(\\\":.\\\")) {\\n                            if (rawMode == RAW_EMPTY) {\\n                                rawMode = RAW_FALSE;\\n                                throw new SqlToolError(\\n                                        rb.getString(SqltoolRB.RAW_EMPTY));\\n                            }\\n                            rawMode = RAW_FALSE;\\n                            setBuf(immCmdSB.toString());\\n                            immCmdSB.setLength(0);\\n                            if (rawExecute) {\\n                                historize();\\n                                processSQL();\\n                            } else if (interactive) {\\n                                stdprintln(rb.getString(\\n                                            SqltoolRB.RAW_MOVEDTOBUFFER));\\n                            }\\n                        } else {\\n                            if (rawMode == RAW_DATA) {\\n                                immCmdSB.append('\\\\n');\\n                            }\\n                            rawMode = RAW_DATA;\\n                            if (inputLine.length() > 0) {\\n                                immCmdSB.append(inputLine);\\n                            }\\n                        }\\n                        continue;\\n                    }\\n                    if (immCmdSB.length() == 0) {\\n                                            if (trimmedInput.startsWith(\\\"\\\", 2)\\n                                               + 2;\\n                            if (postCommentIndex > 1) {\\n                                                                                                inputLine = inputLine.substring(\\n                                    postCommentIndex + inputLine.length()\\n                                    - trimmedInput.length());\\n                                trimmedInput = inputLine.trim();\\n                            } else {\\n                                                                immCmdSB.append(\\\"COMMENT\\\");\\n                                inComment = true;\\n                                continue;\\n                            }\\n                        }\\n                        if (trimmedInput.length() == 0) {\\n                                                                                    continue;\\n                        }\\n                        if ((trimmedInput.charAt(0) == '*'\\n                                && (trimmedInput.length() < 2\\n                                    || trimmedInput.charAt(1) != '{'))\\n                                || trimmedInput.charAt(0) == '\\\\\\\\') {\\n                            setBuf(trimmedInput);\\n                            processFromBuffer();\\n                            continue;\\n                        }\\n                        if (trimmedInput.charAt(0) == ':' && interactive) {\\n                            processBuffHist(trimmedInput.substring(1));\\n                            continue;\\n                        }\\n                        String ucased = trimmedInput.toUpperCase();\\n                        if (ucased.startsWith(\\\"DECLARE\\\")\\n                                || ucased.startsWith(\\\"BEGIN\\\")) {\\n                            rawMode = RAW_EMPTY;\\n                            immCmdSB.append(inputLine);\\n                            if (interactive) {\\n                                stdprintln(RAW_LEADIN_MSG);\\n                            }\\n                            continue;\\n                        }\\n                    }\\n                    if (trimmedInput.length() == 0 && interactive &&!inComment) {\\n                                                                        setBuf(immCmdSB.toString());\\n                        immCmdSB.setLength(0);\\n                        stdprintln(rb.getString(SqltoolRB.INPUT_MOVEDTOBUFFER));\\n                        continue;\\n                    }\\n                    deTerminated = SqlFile.deTerminated(inputLine);\\n                                        if (!trimmedInput.equals(\\\";\\\")) {\\n                        if (immCmdSB.length() > 0) {\\n                            immCmdSB.append('\\\\n');\\n                        }\\n                        immCmdSB.append((deTerminated == null) ? inputLine\\n                                                                   : deTerminated);\\n                    }\\n                    if (deTerminated == null) {\\n                        continue;\\n                    }\\n                    if (immCmdSB.toString().trim().length() == 0) {\\n                        immCmdSB.setLength(0);\\n                        throw new SqlToolError(rb.getString(\\n                                    SqltoolRB.SQLSTATEMENT_EMPTY));\\n                                                                                                                                            }\\n                    setBuf(immCmdSB.toString());\\n                    immCmdSB.setLength(0);\\n                    historize();\\n                    processSQL();\\n                } catch (BadSpecial bs) {\\n                                        errprintln(rb.getString(SqltoolRB.ERRORAT_WITHECHO,\\n                            new String[] {\\n                                ((file == null) ? \\\"stdin\\\" : file.toString()),\\n                                Integer.toString(curLinenum),\\n                                inputLine,\\n                                bs.getMessage(),\\n                            }\\n                    ));\\n                    Throwable cause = bs.getCause();\\n                    if (cause != null) {\\n                        errprintln(rb.getString(SqltoolRB.CAUSEREPORT,\\n                                new String[] {cause.toString()}));\\n                    }\\n                    if (!continueOnError) {\\n                        throw new SqlToolError(bs);\\n                    }\\n                } catch (SQLException se) {\\n                    errprintln(\\\"SQL \\\" + rb.getString(\\n                            ((lastSqlStatement == null) ? SqltoolRB.ERRORAT\\n                                    : SqltoolRB.ERRORAT_WITHECHO),\\n                            ((lastSqlStatement == null) ? (\\n                                new String[] {\\n                                    ((file == null) ? \\\"stdin\\\" : file.toString()),\\n                                    Integer.toString(curLinenum),\\n                                    se.getMessage(),\\n                                }\\n                            ) : (\\n                                new String[] {\\n                                    ((file == null) ? \\\"stdin\\\" : file.toString()),\\n                                    Integer.toString(curLinenum),\\n                                    lastSqlStatement,\\n                                    se.getMessage(),\\n                                }\\n                            ))\\n                    ));\\n                    if (!continueOnError) {\\n                        throw se;\\n                    }\\n                } catch (BreakException be) {\\n                    String msg = be.getMessage();\\n                    if (recursed) {\\n                        rollbackUncoms = false;\\n                                                                                                                    } else if (msg == null || msg.equals(\\\"file\\\")) {\\n                        break;\\n                    } else {\\n                        errprintln(rb.getString(SqltoolRB.BREAK_UNSATISFIED,\\n                                new String[] { msg }));\\n                    }\\n                    if (recursed ||!continueOnError) {\\n                        throw be;\\n                    }\\n                } catch (ContinueException ce) {\\n                    String msg = ce.getMessage();\\n                    if (recursed) {\\n                        rollbackUncoms = false;\\n                    } else {\\n                        errprintln((msg == null)\\n                                ?  rb.getString(SqltoolRB.CONTINUE_UNSATISFIED)\\n                                : rb.getString(\\n                                        SqltoolRB.CONTINUE_UNSATISFIED_TYPED,\\n                                                new String[] {msg}\\n                                ));\\n                    }\\n                    if (recursed ||!continueOnError) {\\n                        throw ce;\\n                    }\\n                } catch (QuitNow qn) {\\n                    throw qn;\\n                } catch (SqlToolError ste) {\\n                    errprint(rb.getString(SqltoolRB.ERRORAT_WITHECHO,\\n                            new String[] {\\n                                ((file == null) ? \\\"stdin\\\" : file.toString()),\\n                                Integer.toString(curLinenum),\\n                                inputLine,\\n                                ((ste.getMessage() == null)\\n                                        ? \\\"\\\" : ste.getMessage())\\n                            }\\n                    ));\\n                    if (ste.getMessage() != null) errprintln(\\\"\\\");\\n                    Throwable cause = ste.getCause();\\n                    if (cause != null) {\\n                        errprintln(rb.getString(SqltoolRB.CAUSEREPORT,\\n                                new String[] {cause.toString()}));\\n                    }\\n                    if (!continueOnError) {\\n                        throw ste;\\n                    }\\n                }\\n                immCmdSB.setLength(0);\\n            }\\n            if (inComment || immCmdSB.length() != 0) {\\n                errprintln(rb.getString(SqltoolRB.INPUT_UNTERMINATED,\\n                        new String[] {immCmdSB.toString()}));\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.INPUT_UNTERMINATED,\\n                        new String[] {immCmdSB.toString()}));\\n            }\\n            rollbackUncoms = false;\\n                    } catch (IOException ioe) {\\n            throw new SqlToolError(rb.getString(\\n                    SqltoolRB.PRIMARYINPUT_ACCESSFAIL), ioe);\\n        } catch (QuitNow qn) {\\n            if (recursed) {\\n                throw qn;\\n                                            }\\n            rollbackUncoms = (qn.getMessage() != null);\\n            if (rollbackUncoms) {\\n                errprintln(rb.getString(SqltoolRB.ABORTING, new String[] {\\n                        qn.getMessage()}));\\n                throw new SqlToolError(qn.getMessage());\\n            }\\n            return;\\n        } finally {\\n            closeQueryOutputStream();\\n            if (fetchingVar != null) {\\n                errprintln(rb.getString(SqltoolRB.PLVAR_SET_INCOMPLETE,\\n                        new String[] {fetchingVar}));\\n                rollbackUncoms = true;\\n            }\\n            if (br != null) try {\\n                br.close();\\n            } catch (IOException ioe) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.INPUTREADER_CLOSEFAIL), ioe);\\n            }\\n            if (rollbackUncoms && possiblyUncommitteds.get()) {\\n                errprintln(rb.getString(SqltoolRB.ROLLINGBACK));\\n                curConn.rollback();\\n                possiblyUncommitteds.set(false);\\n            }\\n        }\\n    }\\n    private static String deTerminated(String inString) {\\n        int index = inString.lastIndexOf(';');\\n        if (index < 0) {\\n            return null;\\n        }\\n        for (int i = index + 1; i < inString.length(); i++) {\\n            if (!Character.isWhitespace(inString.charAt(i))) {\\n                return null;\\n            }\\n        }\\n        return inString.substring(0, index);\\n    }\\n    static private class BadSpecial extends AppendableException {\\n        static final long serialVersionUID = 7162440064026570590L;\\n        BadSpecial(String s) {\\n            super(s);\\n            if (s == null)\\n                throw new RuntimeException(\\n                        \\\"Must construct BadSpecials with non-null message\\\");\\n        }\\n        BadSpecial(String s, Throwable t) {\\n            super(s, t);\\n            if (s == null)\\n                throw new RuntimeException(\\n                        \\\"Must construct BadSpecials with non-null message\\\");\\n        }\\n    }\\n    private class QuitNow extends SqlToolError {\\n        static final long serialVersionUID = 1811094258670900488L;\\n        public QuitNow(String s) {\\n            super(s);\\n        }\\n        public QuitNow() {\\n            super();\\n        }\\n    }\\n    private class BreakException extends SqlToolError {\\n        static final long serialVersionUID = 351150072817675994L;\\n        public BreakException() {\\n            super();\\n        }\\n        public BreakException(String s) {\\n            super(s);\\n        }\\n    }\\n    private class ContinueException extends SqlToolError {\\n        static final long serialVersionUID = 5064604160827106014L;\\n        public ContinueException() {\\n            super();\\n        }\\n        public ContinueException(String s) {\\n            super(s);\\n        }\\n    }\\n    private class BadSubst extends Exception {\\n        static final long serialVersionUID = 7325933736897253269L;\\n        BadSubst(String s) {\\n            super(s);\\n        }\\n    }\\n    private class RowError extends AppendableException {\\n        static final long serialVersionUID = 754346434606022750L;\\n        RowError(String s) {\\n            super(s);\\n        }\\n        RowError(Throwable t) {\\n            this(null, t);\\n        }\\n        RowError(String s, Throwable t) {\\n            super(s, t);\\n        }\\n    }\\n    public void processFromBuffer()\\n            throws BadSpecial, SQLException, SqlToolError {\\n        historize();\\n        if (buffer.charAt(0) == '*' && (buffer.length() < 2\\n                || buffer.charAt(1) != '{')) {\\n                                    processPL(buffer);\\n            return;\\n        }\\n        if (buffer.charAt(0) == '\\\\\\\\') {\\n            processSpecial(buffer);\\n            return;\\n        }\\n        processSQL();\\n    }\\n    private void processBuffHist(String inString)\\n    throws BadSpecial, SQLException, SqlToolError {\\n        if (inString.length() < 1) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.SPECIAL_UNSPECIFIED));\\n        }\\n        char commandChar = inString.charAt(0);\\n        String other       = inString.substring(1);\\n        if (other.trim().length() == 0) {\\n            other = null;\\n        }\\n        switch (commandChar) {\\n            case ';' :\\n                enforce1charBH(other, ';');\\n                if (buffer == null) throw new BadSpecial(\\n                        rb.getString(SqltoolRB.NOBUFFER_YET));\\n                stdprintln(rb.getString(SqltoolRB.BUFFER_EXECUTING,\\n                        new String[] {buffer}));\\n                processFromBuffer();\\n                return;\\n            case 'a' :\\n                if (buffer == null) throw new BadSpecial(\\n                        rb.getString(SqltoolRB.NOBUFFER_YET));\\n                immCmdSB.append(buffer);\\n                if (other != null) {\\n                    String deTerminated = SqlFile.deTerminated(other);\\n                    if (!other.equals(\\\";\\\")) {\\n                        immCmdSB.append(((deTerminated == null)\\n                                ? other : deTerminated));\\n                    }\\n                    if (deTerminated != null) {\\n                        setBuf(immCmdSB.toString());\\n                        immCmdSB.setLength(0);\\n                        stdprintln(rb.getString(SqltoolRB.BUFFER_EXECUTING,\\n                                new String[] {buffer}));\\n                        processFromBuffer();\\n                        return;\\n                    }\\n                }\\n                withholdPrompt = true;\\n                stdprint(immCmdSB.toString());\\n                return;\\n            case 'l' :\\n            case 'b' :\\n                enforce1charBH(other, 'l');\\n                if (buffer == null) {\\n                    stdprintln(nobufferYetString);\\n                } else {\\n                    stdprintln(rb.getString(SqltoolRB.EDITBUFFER_CONTENTS,\\n                            new String[] {buffer}));\\n                }\\n                return;\\n            case 'h' :\\n                enforce1charBH(other, 'h');\\n                showHistory();\\n                return;\\n            case '-' :\\n            case '0' :\\n            case '1' :\\n            case '2' :\\n            case '3' :\\n            case '4' :\\n            case '5' :\\n            case '6' :\\n            case '7' :\\n            case '8' :\\n            case '9' :\\n                boolean executeMode =\\n                    inString.charAt(inString.length() - 1) == ';';\\n                String numStr = inString.substring(0,\\n                        inString.length() + (executeMode ? -1 : 0));\\n                try {\\n                    setBuf(commandFromHistory(Integer.parseInt(numStr)));\\n                } catch (NumberFormatException nfe) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.COMMANDNUM_MALFORMAT,\\n                            new String[] {numStr} ),\\n                    nfe);\\n                }\\n                if (executeMode) {\\n                    stdprintln(rb.getString(SqltoolRB.BUFFER_EXECUTING,\\n                            new String[] {buffer}));\\n                    processFromBuffer();\\n                } else {\\n                    stdprintln(rb.getString(SqltoolRB.BUFFER_RESTORED,\\n                            new String[] {buffer}));\\n                }\\n                return;\\n            case 'w' :\\n                if (other == null) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.DESTFILE_DEMAND));\\n                }\\n                if (buffer == null || buffer.length() == 0) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.BUFFER_EMPTY));\\n                }\\n                PrintWriter pw = null;\\n                try {\\n                    pw = new PrintWriter((charset == null)\\n                            ?  (new OutputStreamWriter(\\n                                    new FileOutputStream(other.trim(), true)))\\n                            :  (new OutputStreamWriter(\\n                                    new FileOutputStream(other.trim(), true),\\n                                            charset))\\n                                                                                                        );\\n                    pw.println(buffer);\\n                                                                                pw.flush();\\n                } catch (Exception e) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.FILE_APPENDFAIL,\\n                            new String[] {other.trim()}), e);\\n                } finally {\\n                    if (pw != null) pw.close();\\n                }\\n                return;\\n            case 's' :\\n                boolean modeExecute = false;\\n                boolean modeGlobal = false;\\n                try {\\n                    if (other == null || other.length() < 3) {\\n                        throw new BadSubst(rb.getString(\\n                                SqltoolRB.SUBSTITUTION_MALFORMAT));\\n                    }\\n                    Matcher m = substitutionPattern.matcher(inString);\\n                    if (buffer == null) {\\n                        stdprintln(nobufferYetString);\\n                        return;\\n                    }\\n                    if (!m.matches()) {\\n                        throw new BadSubst(rb.getString(\\n                                SqltoolRB.SUBSTITUTION_MALFORMAT));\\n                    }\\n                                        if (m.groupCount() < 3 || m.groupCount() > 4) {\\n                                                throw new RuntimeException(\\n                                \\\"Matched substitution pattern, but \\\"\\n                                + \\\"captured \\\" + m.groupCount() + \\\" groups\\\");\\n                    }\\n                    String optionGroup = (\\n                            (m.groupCount() > 3 && m.group(4) != null)\\n                            ? (new String(m.group(4))) : null);\\n                    if (optionGroup != null) {\\n                        if (optionGroup.indexOf(';') > -1) {\\n                            modeExecute = true;\\n                            optionGroup = optionGroup.replaceFirst(\\\";\\\", \\\"\\\");\\n                        }\\n                        if (optionGroup.indexOf('g') > -1) {\\n                            modeGlobal = true;\\n                            optionGroup = optionGroup.replaceFirst(\\\"g\\\", \\\"\\\");\\n                        }\\n                    }\\n                    Matcher bufferMatcher = Pattern.compile(\\\"(?s\\\"\\n                            + ((optionGroup == null) ? \\\"\\\" : optionGroup)\\n                            + ')' + m.group(2)).matcher(buffer);\\n                    String newBuffer = (modeGlobal\\n                            ? bufferMatcher.replaceAll(m.group(3))\\n                            : bufferMatcher.replaceFirst(m.group(3)));\\n                    if (newBuffer.equals(buffer)) {\\n                        stdprintln(rb.getString(\\n                                SqltoolRB.SUBSTITUTION_NOMATCH));\\n                        return;\\n                    }\\n                    setBuf(newBuffer);\\n                    stdprintln(rb.getString((modeExecute\\n                            ? SqltoolRB.BUFFER_EXECUTING\\n                            : SqltoolRB.EDITBUFFER_CONTENTS),\\n                                    new String[] {buffer})\\n                    );\\n                } catch (PatternSyntaxException pse) {\\n                    throw new BadSpecial(\\n                            rb.getString(SqltoolRB.SUBSTITUTION_SYNTAX), pse);\\n                } catch (BadSubst badswitch) {\\n                    throw new BadSpecial(\\n                            rb.getString(SqltoolRB.SUBSTITUTION_SYNTAX));\\n                }\\n                if (modeExecute) {\\n                    immCmdSB.setLength(0);\\n                    processFromBuffer();\\n                }\\n                return;\\n            case '?' :\\n                stdprintln(rb.getString(SqltoolRB.BUFFER_HELP));\\n                return;\\n        }\\n        throw new BadSpecial(rb.getString(SqltoolRB.BUFFER_UNKNOWN,\\n                new String[] { Character.toString(commandChar) }));\\n    }\\n    private boolean doPrepare   = false;\\n    private String  prepareVar  = null;\\n    private String  dsvColDelim = null;\\n    private String  dsvSkipPrefix = null;\\n    private String  dsvRowDelim = null;\\n    private String  dsvSkipCols = null;\\n    private String  DSV_X_SYNTAX_MSG = null;\\n    private String  DSV_M_SYNTAX_MSG = null;\\n    private String  nobufferYetString = null;\\n    private void enforce1charSpecial(String token, char command)\\n            throws BadSpecial {\\n        if (token.length() != 1) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.SPECIAL_EXTRACHARS,\\n                    new String[] { Character.toString(command),\\n                            token.substring(1) }));\\n        }\\n    }\\n    private void enforce1charBH(String token, char command)\\n            throws BadSpecial {\\n        if (token != null) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.BUFFER_EXTRACHARS,\\n                    new String[] { Character.toString(command), token }));\\n        }\\n    }\\n    private void processSpecial(String inString)\\n    throws BadSpecial, QuitNow, SQLException, SqlToolError {\\n        Matcher m = specialPattern.matcher(\\n                plMode ? dereference(inString, false) : inString);\\n        if (!m.matches()) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.SPECIAL_MALFORMAT));\\n                                }\\n        if (m.groupCount() < 1 || m.groupCount() > 2) {\\n                        throw new RuntimeException(\\n                    \\\"Pattern matched, yet captured \\\" + m.groupCount()\\n                    + \\\" groups\\\");\\n        }\\n        String arg1 = m.group(1);\\n        String other = ((m.groupCount() > 1) ? m.group(2) : null);\\n        switch (arg1.charAt(0)) {\\n            case 'q' :\\n                enforce1charSpecial(arg1, 'q');\\n                if (other != null) {\\n                    throw new QuitNow(other);\\n                }\\n                throw new QuitNow();\\n            case 'H' :\\n                enforce1charSpecial(arg1, 'H');\\n                htmlMode = !htmlMode;\\n                stdprintln(rb.getString(SqltoolRB.HTML_MODE, new String[] {\\n                        Boolean.toString(htmlMode)}));\\n                return;\\n            case 'm' :\\n                if (arg1.equals(\\\"m?\\\") ||\\n                        (arg1.equals(\\\"m\\\") && other != null\\n                                 && other.equals(\\\"?\\\"))) {\\n                    stdprintln(DSV_OPTIONS_TEXT + LS + DSV_M_SYNTAX_MSG);\\n                    return;\\n                }\\n                if (arg1.length() != 1 || other == null) {\\n                    throw new BadSpecial(DSV_M_SYNTAX_MSG);\\n                }\\n                boolean noComments = other.charAt(other.length() - 1) == '*';\\n                String skipPrefix = null;\\n                if (noComments) {\\n                    other = other.substring(0, other.length()-1).trim();\\n                    if (other.length() < 1) {\\n                        throw new BadSpecial(DSV_M_SYNTAX_MSG);\\n                    }\\n                } else {\\n                    skipPrefix = dsvSkipPrefix;\\n                }\\n                int colonIndex = other.indexOf(\\\" :\\\");\\n                if (colonIndex > -1 && colonIndex < other.length() - 2) {\\n                    skipPrefix = other.substring(colonIndex + 2);\\n                    other = other.substring(0, colonIndex).trim();\\n                }\\n                importDsv(other, skipPrefix);\\n                return;\\n            case 'x' :\\n                if (arg1.equals(\\\"x?\\\") ||\\n                        (arg1.equals(\\\"x\\\") && other != null\\n                                 && other.equals(\\\"?\\\"))) {\\n                    stdprintln(DSV_OPTIONS_TEXT + LS + DSV_X_SYNTAX_MSG);\\n                    return;\\n                }\\n                try {\\n                    if (arg1.length() != 1 || other == null) {\\n                        throw new BadSpecial(DSV_X_SYNTAX_MSG);\\n                    }\\n                    String tableName = ((other.indexOf(' ') > 0) ? null\\n                                                                 : other);\\n                    if (dsvTargetFile == null && tableName == null) {\\n                        throw new BadSpecial(rb.getString(\\n                                    SqltoolRB.DSV_TARGETFILE_DEMAND));\\n                    }\\n                    File dsvFile = new File((dsvTargetFile == null)\\n                                            ? (tableName + \\\".dsv\\\")\\n                                            : dsvTargetFile);\\n                    pwDsv = new PrintWriter((charset == null)\\n                       ? (new OutputStreamWriter(new FileOutputStream(dsvFile)))\\n                       : (new OutputStreamWriter(new FileOutputStream(dsvFile),\\n                               charset)));\\n                    ResultSet rs = curConn.createStatement().executeQuery(\\n                            (tableName == null) ? other\\n                                                : (\\\"SELECT * FROM \\\"\\n                                                   + tableName));\\n                    List colList = new ArrayList();\\n                    int[] incCols = null;\\n                    if (dsvSkipCols != null) {\\n                        Set ucSkipCols = new HashSet();\\n                        String[] skipCols = dsvSkipCols.split(\\\"\\\\\\\\s*\\\\\\\\Q\\\"\\n                                + dsvColDelim + \\\"\\\\\\\\E\\\\\\\\s*\\\");\\n                        for (int i = 0; i < skipCols.length; i++) {\\n                            ucSkipCols.add(skipCols[i].toUpperCase());\\n                        }\\n                        ResultSetMetaData rsmd = rs.getMetaData();\\n                        for (int i = 1; i <= rsmd.getColumnCount(); i++) {\\n                            if (!ucSkipCols.remove(rsmd.getColumnName(i))) {\\n                                colList.add(new Integer(i));\\n                            }\\n                        }\\n                        if (colList.size() < 1) {\\n                            throw new BadSpecial(rb.getString(\\n                                    SqltoolRB.DSV_NOCOLSLEFT,\\n                                    new String[] {dsvSkipCols}));\\n                        }\\n                        if (ucSkipCols.size() > 0) {\\n                            throw new BadSpecial(rb.getString(\\n                                    SqltoolRB.DSV_SKIPCOLS_MISSING,\\n                                        new String[] {ucSkipCols.toString()}));\\n                        }\\n                        incCols = new int[colList.size()];\\n                        for (int i = 0; i < incCols.length; i++) {\\n                            incCols[i] = ((Integer) colList.get(i)).intValue();\\n                        }\\n                    }\\n                    displayResultSet(null, rs, incCols, null);\\n                    pwDsv.flush();\\n                    stdprintln(rb.getString(SqltoolRB.FILE_WROTECHARS,\\n                            new String[] {\\n                                Long.toString(dsvFile.length()),\\n                                dsvFile.toString(),\\n                            }\\n                    ));\\n                } catch (FileNotFoundException e) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.FILE_WRITEFAIL,\\n                            new String[] {other}), e);\\n                } catch (UnsupportedEncodingException e) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.FILE_WRITEFAIL,\\n                            new String[] {other}), e);\\n                } finally {\\n                                        if (pwDsv != null) {\\n                        pwDsv.close();\\n                    }\\n                    pwDsv       = null;\\n                }\\n                return;\\n            case 'd' :\\n                if (arg1.equals(\\\"d?\\\") ||\\n                        (arg1.equals(\\\"d\\\") && other != null\\n                                 && other.equals(\\\"?\\\"))) {\\n                    stdprintln(D_OPTIONS_TEXT);\\n                    return;\\n                }\\n                if (arg1.length() == 2) {\\n                    listTables(arg1.charAt(1), other);\\n                    return;\\n                }\\n                if (arg1.length() == 1 && other != null) try {\\n                    int space = other.indexOf(' ');\\n                    if (space < 0) {\\n                        describe(other, null);\\n                    } else {\\n                        describe(other.substring(0, space),\\n                                 other.substring(space + 1).trim());\\n                    }\\n                    return;\\n                } catch (SQLException se) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.METADATA_FETCH_FAIL), se);\\n                }\\n                throw new BadSpecial(rb.getString(SqltoolRB.SPECIAL_D_LIKE));\\n            case 'o' :\\n                enforce1charSpecial(arg1, 'o');\\n                if (other == null) {\\n                    if (pwQuery == null) {\\n                        throw new BadSpecial(rb.getString(\\n                                SqltoolRB.OUTPUTFILE_NONETOCLOSE));\\n                    }\\n                    closeQueryOutputStream();\\n                    return;\\n                }\\n                if (pwQuery != null) {\\n                    stdprintln(rb.getString(SqltoolRB.OUTPUTFILE_REOPENING));\\n                    closeQueryOutputStream();\\n                }\\n                try {\\n                    pwQuery = new PrintWriter((charset == null)\\n                            ? (new OutputStreamWriter(\\n                                    new FileOutputStream(other, true)))\\n                            : (new OutputStreamWriter(\\n                                    new FileOutputStream(other, true), charset))\\n                    );\\n                    pwQuery.println((htmlMode\\n                            ? (\\\"<HTML>\\\" + LS + \\\"<!--\\\")\\n                            : \\\"#\\\") + \\\" \\\" + (new java.util.Date()) + \\\".  \\\"\\n                                    + rb.getString(SqltoolRB.OUTPUTFILE_HEADER,\\n                                            new String[] {getClass().getName()})\\n                                    + (htmlMode ? (\\\" -->\\\" + LS + LS + \\\"<BODY>\\\")\\n                                                : LS));\\n                    pwQuery.flush();\\n                } catch (Exception e) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.FILE_WRITEFAIL,\\n                            new String[] {other}), e);\\n                }\\n                return;\\n            case 'i' :\\n                enforce1charSpecial(arg1, 'i');\\n                if (other == null) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.SQLFILE_NAME_DEMAND));\\n                }\\n                try {\\n                    SqlFile sf = new SqlFile(new File(other), false, userVars);\\n                    sf.recursed = true;\\n                                        sf.possiblyUncommitteds = possiblyUncommitteds;\\n                    sf.plMode               = plMode;\\n                    sf.execute(curConn, continueOnError);\\n                } catch (ContinueException ce) {\\n                    throw ce;\\n                } catch (BreakException be) {\\n                    String beMessage = be.getMessage();\\n                                        if (beMessage != null &&!beMessage.equals(\\\"file\\\")) {\\n                        throw be;\\n                    }\\n                } catch (QuitNow qn) {\\n                    throw qn;\\n                } catch (Exception e) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.SQLFILE_EXECUTE_FAIL,\\n                            new String[] {other}), e);\\n                }\\n                return;\\n            case 'p' :\\n                enforce1charSpecial(arg1, 'p');\\n                if (other == null) {\\n                    stdprintln(true);\\n                } else {\\n                    stdprintln(other, true);\\n                }\\n                return;\\n            case 'a' :\\n                enforce1charSpecial(arg1, 'a');\\n                if (other != null) {\\n                    curConn.setAutoCommit(\\n                        Boolean.valueOf(other).booleanValue());\\n                }\\n                stdprintln(rb.getString(SqltoolRB.A_SETTING, new String[] {\\n                        Boolean.toString(curConn.getAutoCommit())}));\\n                return;\\n            case '=' :\\n                enforce1charSpecial(arg1, '=');\\n                curConn.commit();\\n                possiblyUncommitteds.set(false);\\n                stdprintln(rb.getString(SqltoolRB.COMMITTED));\\n                return;\\n            case 'b' :\\n                if (arg1.length() == 1) {\\n                    if (other != null) {\\n                        throw new BadSpecial(rb.getString(\\n                                SqltoolRB.SPECIAL_B_MALFORMAT));\\n                    }\\n                    fetchBinary = true;\\n                    return;\\n                }\\n                if (arg1.charAt(1) == 'p') {\\n                    if (other != null) {\\n                        throw new BadSpecial(rb.getString(\\n                                SqltoolRB.SPECIAL_B_MALFORMAT));\\n                    }\\n                    doPrepare = true;\\n                    return;\\n                }\\n                if ((arg1.charAt(1) != 'd' && arg1.charAt(1) != 'l')\\n                        || other == null) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.SPECIAL_B_MALFORMAT));\\n                }\\n                File file = new File(other);\\n                try {\\n                    if (arg1.charAt(1) == 'd') {\\n                        dump(file);\\n                    } else {\\n                        binBuffer = SqlFile.loadBinary(file);\\n                        stdprintln(rb.getString(\\n                                SqltoolRB.BINARY_LOADEDBYTESINTO,\\n                                new String[] {\\n                                    Integer.toString(binBuffer.length)\\n                                }));\\n                    }\\n                } catch (BadSpecial bs) {\\n                    throw bs;\\n                } catch (IOException ioe) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.BINARY_FILEFAIL,\\n                            new String[] {other}), ioe);\\n                }\\n                return;\\n            case '*' :\\n            case 'c' :\\n                enforce1charSpecial(arg1, '=');\\n                if (other != null) {\\n                                        continueOnError = Boolean.valueOf(other).booleanValue();\\n                }\\n                stdprintln(rb.getString(SqltoolRB.C_SETTING, new String[] {\\n                        Boolean.toString(continueOnError)}));\\n                return;\\n            case '?' :\\n                stdprintln(rb.getString(SqltoolRB.SPECIAL_HELP));\\n                return;\\n            case '!' :\\n                                                                                InputStream stream;\\n                byte[]      ba         = new byte[1024];\\n                String      extCommand = ((arg1.length() == 1)\\n                        ? \\\"\\\" : arg1.substring(1))\\n                    + ((arg1.length() > 1 && other != null)\\n                       ? \\\" \\\" : \\\"\\\") + ((other == null) ? \\\"\\\" : other);\\n                if (extCommand.trim().length() < 1)\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.BANG_INCOMPLETE));\\n                try {\\n                    Runtime runtime = Runtime.getRuntime();\\n                    Process proc = ((wincmdPattern == null)\\n                            ? runtime.exec(extCommand)\\n                            : runtime.exec(genWinArgs(extCommand))\\n                    );\\n                    proc.getOutputStream().close();\\n                    int i;\\n                    stream = proc.getInputStream();\\n                    while ((i = stream.read(ba)) > 0) {\\n                        stdprint(new String(ba, 0, i));\\n                    }\\n                    stream.close();\\n                    stream = proc.getErrorStream();\\n                    while ((i = stream.read(ba)) > 0) {\\n                        errprint(new String(ba, 0, i));\\n                    }\\n                    stream.close();\\n                    if (proc.waitFor() != 0) {\\n                        throw new BadSpecial(rb.getString(\\n                                SqltoolRB.BANG_COMMAND_FAIL,\\n                                new String[] {extCommand}));\\n                    }\\n                } catch (BadSpecial bs) {\\n                    throw bs;\\n                } catch (Exception e) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.BANG_COMMAND_FAIL,\\n                            new String[] {extCommand}), e);\\n                }\\n                return;\\n            case '.' :\\n                enforce1charSpecial(arg1, '.');\\n                rawMode = RAW_EMPTY;\\n                if (interactive) {\\n                    stdprintln(RAW_LEADIN_MSG);\\n                }\\n                return;\\n        }\\n        throw new BadSpecial(rb.getString(SqltoolRB.SPECIAL_UNKNOWN,\\n                new String[] { Character.toString(arg1.charAt(0)) }));\\n    }\\n    private static final char[] nonVarChars = {\\n        ' ', '\\\\t', '=', '}', '\\\\n', '\\\\r'\\n    };\\n    static int pastName(String inString, int startIndex) {\\n        String workString = inString.substring(startIndex);\\n        int    e          = inString.length();            int    nonVarIndex;\\n        for (int i = 0; i < nonVarChars.length; i++) {\\n            nonVarIndex = workString.indexOf(nonVarChars[i]);\\n            if (nonVarIndex > -1 && nonVarIndex < e) {\\n                e = nonVarIndex;\\n            }\\n        }\\n        return startIndex + e;\\n    }\\n    private String dereference(String inString,\\n                               boolean permitAlias) throws SqlToolError {\\n        String       varName, varValue;\\n        StringBuffer expandBuffer = new StringBuffer(inString);\\n        int          b, e;            int iterations;\\n        if (permitAlias && inString.trim().charAt(0) == '/') {\\n            int slashIndex = inString.indexOf('/');\\n            e = SqlFile.pastName(inString.substring(slashIndex + 1), 0);\\n                        if (e < 1) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.PLALIAS_MALFORMAT));\\n            }\\n            varName  = inString.substring(slashIndex + 1, slashIndex + 1 + e);\\n            varValue = (String) userVars.get(varName);\\n            if (varValue == null) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.PLVAR_UNDEFINED, new String[] {varName}));\\n            }\\n            expandBuffer.replace(slashIndex, slashIndex + 1 + e,\\n                                 (String) userVars.get(varName));\\n        }\\n        String s;\\n        boolean permitUnset;\\n        iterations = 0;\\n        while (true) {\\n            s = expandBuffer.toString();\\n            b = s.indexOf(\\\"${\\\");\\n            if (b < 0) {\\n                                break;\\n            }\\n            e = s.indexOf('}', b + 2);\\n            if (e == b + 2) {\\n                throw new SqlToolError(rb.getString(SqltoolRB.SYSPROP_EMPTY));\\n            }\\n            if (e < 0) {\\n                throw new SqlToolError(rb.getString(\\n                            SqltoolRB.SYSPROP_UNTERMINATED));\\n            }\\n            permitUnset = (s.charAt(b + 2) == ':');\\n            varName = s.substring(b + (permitUnset ? 3 : 2), e);\\n            if (iterations++ > 10000)\\n                throw new SqlToolError(rb.getString(SqltoolRB.VAR_INFINITE,\\n                        new String[] {varName}));\\n            varValue = System.getProperty(varName);\\n            if (varValue == null) {\\n                if (permitUnset) {\\n                    varValue = \\\"\\\";\\n                } else {\\n                    throw new SqlToolError(rb.getString(\\n                            SqltoolRB.SYSPROP_UNDEFINED,\\n                                    new String[] {varName}));\\n                }\\n            }\\n            expandBuffer.replace(b, e + 1, varValue);\\n        }\\n        iterations = 0;\\n        while (true) {\\n            s = expandBuffer.toString();\\n            b = s.indexOf(\\\"*{\\\");\\n            if (b < 0) {\\n                                break;\\n            }\\n            e = s.indexOf('}', b + 2);\\n            if (e == b + 2) {\\n                throw new SqlToolError(rb.getString(SqltoolRB.PLVAR_NAMEEMPTY));\\n            }\\n            if (e < 0) {\\n                throw new SqlToolError(rb.getString(\\n                            SqltoolRB.PLVAR_UNTERMINATED));\\n            }\\n            permitUnset = (s.charAt(b + 2) == ':');\\n            varName = s.substring(b + (permitUnset ? 3 : 2), e);\\n            if (iterations++ > 10000)\\n                throw new SqlToolError(rb.getString(SqltoolRB.VAR_INFINITE,\\n                        new String[] {varName}));\\n            varValue = (String) userVars.get(varName);\\n            if (varValue == null) {\\n                if (permitUnset) {\\n                    varValue = \\\"\\\";\\n                } else {\\n                    throw new SqlToolError(rb.getString(\\n                            SqltoolRB.PLVAR_UNDEFINED, new String[] {varName}));\\n                }\\n            }\\n            expandBuffer.replace(b, e + 1, varValue);\\n        }\\n        return expandBuffer.toString();\\n    }\\n    public boolean plMode = false;\\n        private String  fetchingVar = null;\\n    private boolean silentFetch = false;\\n    private boolean fetchBinary = false;\\n    private void processPL(String inString) throws BadSpecial, SqlToolError {\\n        Matcher m = plPattern.matcher(dereference(inString, false));\\n        if (!m.matches()) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.PL_MALFORMAT));\\n                                }\\n        if (m.groupCount() < 1 || m.group(1) == null) {\\n            plMode = true;\\n            stdprintln(rb.getString(SqltoolRB.PL_EXPANSIONMODE,\\n                   new String[] {\\\"on\\\"}));\\n            return;\\n        }\\n        String[] tokens = m.group(1).split(\\\"\\\\\\\\s+\\\");\\n        if (tokens[0].charAt(0) == '?') {\\n            stdprintln(rb.getString(SqltoolRB.PL_HELP));\\n            return;\\n        }\\n                plMode = true;\\n        if (tokens[0].equals(\\\"end\\\")) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.END_NOBLOCK));\\n        }\\n        if (tokens[0].equals(\\\"continue\\\")) {\\n            if (tokens.length > 1) {\\n                if (tokens.length == 2 &&\\n                        (tokens[1].equals(\\\"foreach\\\") ||\\n                         tokens[1].equals(\\\"while\\\"))) {\\n                    throw new ContinueException(tokens[1]);\\n                }\\n                throw new BadSpecial(rb.getString(SqltoolRB.CONTINUE_SYNTAX));\\n            }\\n            throw new ContinueException();\\n        }\\n        if (tokens[0].equals(\\\"break\\\")) {\\n            if (tokens.length > 1) {\\n                if (tokens.length == 2 &&\\n                        (tokens[1].equals(\\\"foreach\\\") ||\\n                         tokens[1].equals(\\\"if\\\") ||\\n                         tokens[1].equals(\\\"while\\\") ||\\n                         tokens[1].equals(\\\"file\\\"))) {\\n                    throw new BreakException(tokens[1]);\\n                }\\n                throw new BadSpecial(rb.getString(SqltoolRB.BREAK_SYNTAX));\\n            }\\n            throw new BreakException();\\n        }\\n        if (tokens[0].equals(\\\"list\\\") || tokens[0].equals(\\\"listvalues\\\")\\n                || tokens[0].equals(\\\"listsysprops\\\")) {\\n            boolean sysProps =tokens[0].equals(\\\"listsysprops\\\");\\n            String  s;\\n            boolean doValues = (tokens[0].equals(\\\"listvalues\\\") || sysProps);\\n            if (tokens.length == 1) {\\n                stdprint(formatNicely(\\n                        (sysProps ? System.getProperties() : userVars),\\n                        doValues));\\n            } else {\\n                if (doValues) {\\n                    stdprintln(rb.getString(SqltoolRB.PL_LIST_PARENS));\\n                } else {\\n                    stdprintln(rb.getString(SqltoolRB.PL_LIST_LENGTHS));\\n                }\\n                for (int i = 1; i < tokens.length; i++) {\\n                    s = (String) (sysProps ? System.getProperties() : userVars).\\n                            get(tokens[i]);\\n                    if (s == null) continue;\\n                    stdprintln(\\\"    \\\" + tokens[i] + \\\": \\\"\\n                               + (doValues ? (\\\"(\\\" + s + ')')\\n                                           : Integer.toString(s.length())));\\n                }\\n            }\\n            return;\\n        }\\n        if (tokens[0].equals(\\\"dump\\\") || tokens[0].equals(\\\"load\\\")) {\\n            if (tokens.length != 3) {\\n                throw new BadSpecial(rb.getString(\\n                        SqltoolRB.DUMPLOAD_MALFORMAT));\\n            }\\n            String varName = tokens[1];\\n            if (varName.indexOf(':') > -1) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.PLVAR_NOCOLON));\\n            }\\n            File   file    = new File(tokens[2]);\\n            try {\\n                if (tokens[0].equals(\\\"dump\\\")) {\\n                    dump(varName, file);\\n                } else {\\n                    load(varName, file, charset);\\n                }\\n            } catch (IOException ioe) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.DUMPLOAD_FAIL,\\n                        new String[] { varName, file.toString() }), ioe);\\n            }\\n            return;\\n        }\\n        if (tokens[0].equals(\\\"prepare\\\")) {\\n            if (tokens.length != 2) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.PREPARE_MALFORMAT));\\n            }\\n            if (userVars.get(tokens[1]) == null) {\\n                throw new BadSpecial(rb.getString(\\n                    SqltoolRB.PLVAR_UNDEFINED, new String[] {tokens[1]}));\\n            }\\n            prepareVar = tokens[1];\\n            doPrepare  = true;\\n            return;\\n        }\\n        if (tokens[0].equals(\\\"foreach\\\")) {\\n            Matcher foreachM= foreachPattern.matcher(\\n                    dereference(inString, false));\\n            if (!foreachM.matches()) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.FOREACH_MALFORMAT));\\n            }\\n            if (foreachM.groupCount() != 2) {\\n                throw new RuntimeException(\\n                        \\\"foreach pattern matched, but captured \\\"\\n                        + foreachM.groupCount() + \\\" groups\\\");\\n            }\\n            String varName   = foreachM.group(1);\\n            if (varName.indexOf(':') > -1) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.PLVAR_NOCOLON));\\n            }\\n            String[] values = foreachM.group(2).split(\\\"\\\\\\\\s+\\\");\\n            File   tmpFile = null;\\n            String varVal;\\n            try {\\n                tmpFile = plBlockFile(\\\"foreach\\\");\\n            } catch (IOException ioe) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.PL_TEMPFILE_FAIL),\\n                    ioe);\\n            }\\n            String origval = (String) userVars.get(varName);\\n            try {\\n                SqlFile sf;\\n                for (int i = 0; i < values.length; i++) {\\n                    try {\\n                        varVal = values[i];\\n                        userVars.put(varName, varVal);\\n                        updateUserSettings();\\n                        sf          = new SqlFile(tmpFile, false, userVars);\\n                        sf.plMode   = true;\\n                        sf.recursed = true;\\n                                                sf.possiblyUncommitteds = possiblyUncommitteds;\\n                        sf.execute(curConn, continueOnError);\\n                    } catch (ContinueException ce) {\\n                        String ceMessage = ce.getMessage();\\n                        if (ceMessage != null\\n                                &&!ceMessage.equals(\\\"foreach\\\")) {\\n                            throw ce;\\n                        }\\n                    }\\n                }\\n            } catch (BreakException be) {\\n                String beMessage = be.getMessage();\\n                                if (beMessage != null &&!beMessage.equals(\\\"foreach\\\")) {\\n                    throw be;\\n                }\\n            } catch (QuitNow qn) {\\n                throw qn;\\n            } catch (Exception e) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.PL_BLOCK_FAIL), e);\\n            }\\n            if (origval == null) {\\n                userVars.remove(varName);\\n                updateUserSettings();\\n            } else {\\n                userVars.put(varName, origval);\\n            }\\n            if (tmpFile != null &&!tmpFile.delete()) {\\n                throw new BadSpecial(rb.getString(\\n                        SqltoolRB.TEMPFILE_REMOVAL_FAIL,\\n                                new String[] {tmpFile.toString()} ));\\n            }\\n            return;\\n        }\\n        if (tokens[0].equals(\\\"if\\\") || tokens[0].equals(\\\"while\\\")) {\\n            Matcher ifwhileM= ifwhilePattern.matcher(\\n                    dereference(inString, false));\\n            if (!ifwhileM.matches()) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.IFWHILE_MALFORMAT));\\n            }\\n            if (ifwhileM.groupCount() != 1) {\\n                throw new RuntimeException(\\n                        \\\"if/while pattern matched, but captured \\\"\\n                        + ifwhileM.groupCount() + \\\" groups\\\");\\n            }\\n            String[] values =\\n                    ifwhileM.group(1).replaceAll(\\\"!([a-zA-Z0-9*])\\\", \\\"! $1\\\").\\n                            replaceAll(\\\"([a-zA-Z0-9*])!\\\", \\\"$1 !\\\").split(\\\"\\\\\\\\s+\\\");\\n            File tmpFile = null;\\n            if (tokens[0].equals(\\\"if\\\")) {\\n                try {\\n                    tmpFile = plBlockFile(\\\"if\\\");\\n                } catch (IOException ioe) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.PL_BLOCK_FAIL),\\n                            ioe);\\n                }\\n                try {\\n                    if (eval(values)) {\\n                        SqlFile sf = new SqlFile(tmpFile, false, userVars);\\n                        sf.plMode   = true;\\n                        sf.recursed = true;\\n                                                sf.possiblyUncommitteds = possiblyUncommitteds;\\n                        sf.execute(curConn, continueOnError);\\n                    }\\n                } catch (BreakException be) {\\n                    String beMessage = be.getMessage();\\n                                        if (beMessage == null ||!beMessage.equals(\\\"if\\\")) {\\n                        throw be;\\n                    }\\n                } catch (ContinueException ce) {\\n                    throw ce;\\n                } catch (QuitNow qn) {\\n                    throw qn;\\n                } catch (BadSpecial bs) {\\n                    bs.appendMessage(rb.getString(SqltoolRB.IF_MALFORMAT));\\n                    throw bs;\\n                } catch (Exception e) {\\n                    throw new BadSpecial(\\n                        rb.getString(SqltoolRB.PL_BLOCK_FAIL), e);\\n                }\\n            } else if (tokens[0].equals(\\\"while\\\")) {\\n                try {\\n                    tmpFile = plBlockFile(\\\"while\\\");\\n                } catch (IOException ioe) {\\n                    throw new BadSpecial(\\n                        rb.getString(SqltoolRB.PL_TEMPFILE_FAIL), ioe);\\n                }\\n                try {\\n                    SqlFile sf;\\n                    while (eval(values)) {\\n                        try {\\n                            sf          = new SqlFile(tmpFile, false, userVars);\\n                            sf.recursed = true;\\n                                                        sf.possiblyUncommitteds = possiblyUncommitteds;\\n                            sf.plMode               = true;\\n                            sf.execute(curConn, continueOnError);\\n                        } catch (ContinueException ce) {\\n                            String ceMessage = ce.getMessage();\\n                            if (ceMessage != null &&!ceMessage.equals(\\\"while\\\")) {\\n                                throw ce;\\n                            }\\n                        }\\n                    }\\n                } catch (BreakException be) {\\n                    String beMessage = be.getMessage();\\n                                        if (beMessage != null &&!beMessage.equals(\\\"while\\\")) {\\n                        throw be;\\n                    }\\n                } catch (QuitNow qn) {\\n                    throw qn;\\n                } catch (BadSpecial bs) {\\n                    bs.appendMessage(rb.getString(SqltoolRB.WHILE_MALFORMAT));\\n                    throw bs;\\n                } catch (Exception e) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.PL_BLOCK_FAIL),\\n                            e);\\n                }\\n            } else {\\n                                throw new RuntimeException(rb.getString(SqltoolRB.PL_UNKNOWN,\\n                        new String[] {tokens[0]}));\\n            }\\n            if (tmpFile != null &&!tmpFile.delete()) {\\n                throw new BadSpecial(rb.getString(\\n                        SqltoolRB.TEMPFILE_REMOVAL_FAIL, new String[] {\\n                                tmpFile.toString()}));\\n            }\\n            return;\\n        }\\n        m = varsetPattern.matcher(dereference(inString, false));\\n        if (!m.matches()) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.PL_UNKNOWN,\\n                    new String[] {tokens[0]}));\\n        }\\n        if (m.groupCount() < 2 || m.groupCount() > 3) {\\n                        throw new RuntimeException(\\\"varset pattern matched but captured \\\"\\n                    + m.groupCount() + \\\" groups\\\");\\n        }\\n        String varName  = m.group(1);\\n        if (varName.indexOf(':') > -1) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.PLVAR_NOCOLON));\\n        }\\n        switch (m.group(2).charAt(0)) {\\n            case '_' :\\n                silentFetch = true;\\n            case '~' :\\n                if (m.groupCount() > 2 && m.group(3) != null) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.PLVAR_TILDEDASH_NOMOREARGS, new String[] {\\n                                m.group(3)}));\\n                }\\n                userVars.remove(varName);\\n                updateUserSettings();\\n                fetchingVar = varName;\\n                return;\\n            case '=' :\\n                if (fetchingVar != null && fetchingVar.equals(varName)) {\\n                    fetchingVar = null;\\n                }\\n                if (m.groupCount() > 2 && m.group(3) != null) {\\n                    userVars.put(varName, m.group(3));\\n                } else {\\n                    userVars.remove(varName);\\n                }\\n                updateUserSettings();\\n                return;\\n        }\\n        throw new BadSpecial(rb.getString(SqltoolRB.PL_UNKNOWN,\\n                new String[] {tokens[0]}));\\n            }\\n    private File plBlockFile(String seeking) throws IOException, SqlToolError {\\n        String          s;\\n                                int    nestlevel = 1;\\n        String curPlCommand;\\n        if (seeking == null\\n                || ((!seeking.equals(\\\"foreach\\\")) && (!seeking.equals(\\\"if\\\"))\\n                    && (!seeking.equals(\\\"while\\\")))) {\\n            throw new RuntimeException(\\n                \\\"Assertion failed.  Unsupported PL block type:  \\\" + seeking);\\n        }\\n        File tmpFile = File.createTempFile(\\\"sqltool-\\\", \\\".sql\\\");\\n        PrintWriter pw = new PrintWriter((charset == null)\\n                ?  (new OutputStreamWriter(new FileOutputStream(tmpFile)))\\n                :  (new OutputStreamWriter(new FileOutputStream(tmpFile),\\n                        charset)));\\n        try {\\n        pw.println(\\\"\\\");\\n        pw.println();\\n        Matcher m;\\n        while (true) {\\n            s = br.readLine();\\n            if (s == null) {\\n                s = rb.getString(SqltoolRB.PL_BLOCK_UNTERMINATED,\\n                        new String[] {seeking});\\n                errprintln(s);\\n                throw new SqlToolError(s);\\n            }\\n            curLinenum++;\\n            m = plPattern.matcher(s);\\n            if (m.matches() && m.groupCount() > 0 && m.group(1) != null) {\\n                String[] tokens = m.group(1).split(\\\"\\\\\\\\s+\\\");\\n                curPlCommand = tokens[0];\\n                                if (curPlCommand.equals(seeking)) {\\n                    nestlevel++;\\n                } else if (curPlCommand.equals(\\\"end\\\")) {\\n                    if (tokens.length < 2) {\\n                        s = rb.getString(SqltoolRB.END_SYNTAX,\\n                                new String[] {\\\"1\\\"});\\n                        errprintln(s);\\n                        throw new SqlToolError(s);\\n                    }\\n                    String inType = tokens[1];\\n                    if (inType.equals(seeking)) {\\n                        nestlevel--;\\n                        if (nestlevel < 1) {\\n                            break;\\n                        }\\n                    }\\n                    if ((!inType.equals(\\\"foreach\\\")) && (!inType.equals(\\\"if\\\"))\\n                            && (!inType.equals(\\\"while\\\"))) {\\n                        s = rb.getString(SqltoolRB.END_SYNTAX,\\n                                new String[] {\\\"2\\\"});\\n                        errprintln(s);\\n                        throw new SqlToolError(s);\\n                    }\\n                }\\n            }\\n            pw.println(s);\\n        }\\n        pw.flush();\\n        } finally {\\n            pw.close();\\n        }\\n        return tmpFile;\\n    }\\n    private void stdprintln() {\\n        stdprintln(false);\\n    }\\n    private void stdprint(String s) {\\n        stdprint(s, false);\\n    }\\n    private void stdprintln(String s) {\\n        stdprintln(s, false);\\n    }\\n    private void stdprintln(boolean queryOutput) {\\n        if (htmlMode) {\\n            psStd.println(\\\"<BR>\\\");\\n        } else {\\n            psStd.println();\\n        }\\n        if (queryOutput && pwQuery != null) {\\n            if (htmlMode) {\\n                pwQuery.println(\\\"<BR>\\\");\\n            } else {\\n                pwQuery.println();\\n            }\\n            pwQuery.flush();\\n        }\\n    }\\n    private void errprint(String s) {\\n        psErr.print(htmlMode\\n                    ? (\\\"<DIV style='color:white; background: red; \\\"\\n                       + \\\"font-weight: bold'>\\\" + s + \\\"</DIV>\\\")\\n                    : s);\\n    }\\n    private void errprintln(String s) {\\n        psErr.println(htmlMode\\n                      ? (\\\"<DIV style='color:white; background: red; \\\"\\n                         + \\\"font-weight: bold'>\\\" + s + \\\"</DIV>\\\")\\n                      : s);\\n    }\\n    private void stdprint(String s, boolean queryOutput) {\\n        psStd.print(htmlMode ? (\\\"<P>\\\" + s + \\\"</P>\\\")\\n                             : s);\\n        if (queryOutput && pwQuery != null) {\\n            pwQuery.print(htmlMode ? (\\\"<P>\\\" + s + \\\"</P>\\\")\\n                                   : s);\\n            pwQuery.flush();\\n        }\\n    }\\n    private void stdprintln(String s, boolean queryOutput) {\\n        psStd.println(htmlMode ? (\\\"<P>\\\" + s + \\\"</P>\\\")\\n                               : s);\\n        if (queryOutput && pwQuery != null) {\\n            pwQuery.println(htmlMode ? (\\\"<P>\\\" + s + \\\"</P>\\\")\\n                                     : s);\\n            pwQuery.flush();\\n        }\\n    }\\n                private static final String DEFAULT_NULL_REP = \\\"[null]\\\";\\n    private static final String DEFAULT_ROW_DELIM = LS;\\n    private static final String DEFAULT_COL_DELIM = \\\"|\\\";\\n    private static final String DEFAULT_SKIP_PREFIX = \\\"#\\\";\\n    private static final int    DEFAULT_ELEMENT   = 0,\\n                                HSQLDB_ELEMENT    = 1,\\n                                ORACLE_ELEMENT    = 2\\n    ;\\n        private static final int[] listMDSchemaCols = { 1 };\\n    private static final int[] listMDIndexCols  = {\\n        2, 6, 3, 9, 4, 10, 11\\n    };\\n    private static final int[][] listMDTableCols = {\\n        {\\n            2, 3\\n        },            {\\n            2, 3\\n        },            {\\n            2, 3\\n        },        };\\n    private static final String[] oracleSysSchemas = {\\n        \\\"SYS\\\", \\\"SYSTEM\\\", \\\"OUTLN\\\", \\\"DBSNMP\\\", \\\"OUTLN\\\", \\\"MDSYS\\\", \\\"ORDSYS\\\",\\n        \\\"ORDPLUGINS\\\", \\\"CTXSYS\\\", \\\"DSSYS\\\", \\\"PERFSTAT\\\", \\\"WKPROXY\\\", \\\"WKSYS\\\",\\n        \\\"WMSYS\\\", \\\"XDB\\\", \\\"ANONYMOUS\\\", \\\"ODM\\\", \\\"ODM_MTR\\\", \\\"OLAPSYS\\\", \\\"TRACESVR\\\",\\n        \\\"REPADMIN\\\"\\n    };\\n    private void listTables(char c, String inFilter) throws BadSpecial,\\n            SqlToolError {\\n        String   schema  = null;\\n        int[]    listSet = null;\\n        String[] types   = null;\\n        String[] additionalSchemas = null;\\n        Statement statement = null;\\n        ResultSet rs        = null;\\n        String    narrower  = \\\"\\\";\\n        String filter = inFilter;\\n        try {\\n            DatabaseMetaData md            = curConn.getMetaData();\\n            String           dbProductName = md.getDatabaseProductName();\\n            types = new String[1];\\n            switch (c) {\\n                case '*' :\\n                    types = null;\\n                    break;\\n                case 'S' :\\n                    if (dbProductName.indexOf(\\\"Oracle\\\") > -1) {\\n                        errprintln(rb.getString(SqltoolRB.VENDOR_ORACLE_DS));\\n                        types[0]          = \\\"TABLE\\\";\\n                        schema            = \\\"SYS\\\";\\n                        additionalSchemas = oracleSysSchemas;\\n                    } else {\\n                        types[0] = \\\"SYSTEM TABLE\\\";\\n                    }\\n                    break;\\n                case 's' :\\n                    if (dbProductName.indexOf(\\\"HSQL\\\") > -1) {\\n                                                                                                if (filter != null\\n                                && filter.charAt(filter.length() - 1)\\n                                   == '.') {\\n                            narrower =\\n                                \\\"\\\\nWHERE sequence_schema = '\\\"\\n                                + filter.substring(0, filter.length() - 1)\\n                                + \\\"'\\\";\\n                            filter = null;\\n                        }\\n                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT sequence_schema, sequence_name FROM \\\"\\n                            + \\\"information_schema.system_sequences\\\"\\n                            + narrower);\\n                    } else {\\n                        types[0] = \\\"SEQUENCE\\\";\\n                    }\\n                    break;\\n                case 'r' :\\n                    if (dbProductName.indexOf(\\\"HSQL\\\") > -1) {\\n                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT authorization_name FROM \\\"\\n                            + \\\"information_schema.system_authorizations\\\\n\\\"\\n                            + \\\"WHERE authorization_type = 'ROLE'\\\\n\\\"\\n                            + \\\"ORDER BY authorization_name\\\");\\n                    } else if (dbProductName.indexOf(\\n                            \\\"Adaptive Server Enterprise\\\") > -1) {\\n                                                                                                                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT name FROM syssrvroles ORDER BY name\\\");\\n                    } else if (dbProductName.indexOf(\\n                            \\\"Apache Derby\\\") > -1) {\\n                        throw new BadSpecial(\\n                            rb.getString(SqltoolRB.VENDOR_DERBY_DR));\\n                    } else {\\n                        throw new BadSpecial(\\n                            rb.getString(SqltoolRB.VENDOR_NOSUP_D,\\n                                    new String[] {\\\"r\\\"}));\\n                    }\\n                    break;\\n                case 'u' :\\n                    if (dbProductName.indexOf(\\\"HSQL\\\") > -1) {\\n                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT user, admin FROM \\\"\\n                            + \\\"information_schema.system_users\\\\n\\\"\\n                            + \\\"ORDER BY user\\\");\\n                    } else if (dbProductName.indexOf(\\\"Oracle\\\") > -1) {\\n                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT username, created FROM all_users \\\"\\n                            + \\\"ORDER BY username\\\");\\n                    } else if (dbProductName.indexOf(\\\"PostgreSQL\\\") > -1) {\\n                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT usename, usesuper FROM pg_catalog.pg_user \\\"\\n                            + \\\"ORDER BY usename\\\");\\n                    } else if (dbProductName.indexOf(\\n                            \\\"Adaptive Server Enterprise\\\") > -1) {\\n                                                                                                                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT name, accdate, fullname FROM syslogins \\\"\\n                            + \\\"ORDER BY name\\\");\\n                    } else if (dbProductName.indexOf(\\n                            \\\"Apache Derby\\\") > -1) {\\n                        throw new BadSpecial(\\n                            rb.getString(SqltoolRB.VENDOR_DERBY_DU));\\n                    } else {\\n                        throw new BadSpecial(\\n                            rb.getString(SqltoolRB.VENDOR_NOSUP_D,\\n                                    new String[] {\\\"u\\\"}));\\n                    }\\n                    break;\\n                case 'a' :\\n                    if (dbProductName.indexOf(\\\"HSQL\\\") > -1) {\\n                                                                        if (filter != null\\n                                && filter.charAt(filter.length() - 1)\\n                                   == '.') {\\n                            narrower =\\n                                \\\"\\\\nWHERE alias_schem = '\\\"\\n                                + filter.substring(0, filter.length() - 1)\\n                                + \\\"'\\\";\\n                            filter = null;\\n                        }\\n                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT alias_schem, alias FROM \\\"\\n                            + \\\"information_schema.system_aliases\\\" + narrower);\\n                    } else {\\n                        types[0] = \\\"ALIAS\\\";\\n                    }\\n                    break;\\n                case 't' :\\n                    excludeSysSchemas = (dbProductName.indexOf(\\\"Oracle\\\")\\n                                         > -1);\\n                    types[0] = \\\"TABLE\\\";\\n                    break;\\n                case 'v' :\\n                    types[0] = \\\"VIEW\\\";\\n                    break;\\n                case 'n' :\\n                    rs = md.getSchemas();\\n                    if (rs == null) {\\n                        throw new BadSpecial(\\n                            \\\"Failed to get metadata from database\\\");\\n                    }\\n                    displayResultSet(null, rs, listMDSchemaCols, filter);\\n                    return;\\n                case 'i' :\\n                    String table = null;\\n                    if (filter != null) {\\n                        int dotat = filter.indexOf('.');\\n                        schema = ((dotat > 0) ? filter.substring(0, dotat)\\n                                              : null);\\n                        if (dotat < filter.length() - 1) {\\n                                                        table = ((dotat > 0) ? filter.substring(dotat + 1)\\n                                                 : filter);\\n                        }\\n                        filter = null;\\n                    }\\n                                                                                                    rs = md.getIndexInfo(null, schema, table, false, true);\\n                    if (rs == null) {\\n                        throw new BadSpecial(\\n                            \\\"Failed to get metadata from database\\\");\\n                    }\\n                    displayResultSet(null, rs, listMDIndexCols, null);\\n                    return;\\n                default :\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.SPECIAL_D_UNKNOWN, new String[] {\\n                                Character.toString(c)}) + LS + D_OPTIONS_TEXT);\\n            }\\n            if (statement == null) {\\n                if (dbProductName.indexOf(\\\"HSQL\\\") > -1) {\\n                    listSet = listMDTableCols[HSQLDB_ELEMENT];\\n                } else if (dbProductName.indexOf(\\\"Oracle\\\") > -1) {\\n                    listSet = listMDTableCols[ORACLE_ELEMENT];\\n                } else {\\n                    listSet = listMDTableCols[DEFAULT_ELEMENT];\\n                }\\n                if (schema == null && filter != null\\n                        && filter.charAt(filter.length() - 1) == '.') {\\n                    schema = filter.substring(0, filter.length() - 1);\\n                    filter = null;\\n                }\\n            }\\n            rs = ((statement == null)\\n                  ? md.getTables(null, schema, null, types)\\n                  : statement.getResultSet());\\n            if (rs == null) {\\n                throw new BadSpecial(rb.getString(\\n                        SqltoolRB.METADATA_FETCH_FAIL));\\n            }\\n            displayResultSet(null, rs, listSet, filter);\\n            if (additionalSchemas != null) {\\n                for (int i = 1; i < additionalSchemas.length; i++) {\\n                    rs = md.getTables(null, additionalSchemas[i], null,\\n                                      types);\\n                    if (rs == null) {\\n                        throw new BadSpecial(rb.getString(\\n                            SqltoolRB.METADATA_FETCH_FAILFOR,\\n                                    new String[] { additionalSchemas[i]}));\\n                    }\\n                    if (!rs.next()) {\\n                        continue;\\n                    }\\n                    displayResultSet(\\n                        null,\\n                        md.getTables(\\n                            null, additionalSchemas[i], null, types), listSet, filter);\\n                }\\n            }\\n        } catch (SQLException se) {\\n            throw new BadSpecial(rb.getString( SqltoolRB.METADATA_FETCH_FAIL),\\n                    se);\\n        } catch (NullPointerException npe) {\\n            throw new BadSpecial(rb.getString( SqltoolRB.METADATA_FETCH_FAIL),\\n                    npe);\\n        } finally {\\n            excludeSysSchemas = false;\\n            if (rs != null) {\\n                rs = null;\\n            }\\n            if (statement != null) {\\n                try {\\n                    statement.close();\\n                } catch (Exception e) {}\\n                statement = null;\\n            }\\n        }\\n    }\\n    private boolean excludeSysSchemas = false;\\n    private void processSQL() throws SQLException, SqlToolError {\\n                                                                                                        lastSqlStatement    = (plMode ? dereference(buffer, true)\\n                                      : buffer);\\n        Statement statement = null;\\n        if (doPrepare) {\\n            if (lastSqlStatement.indexOf('?') < 1) {\\n                lastSqlStatement = null;\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.PREPARE_DEMANDQM));\\n            }\\n            doPrepare = false;\\n            PreparedStatement ps = curConn.prepareStatement(lastSqlStatement);\\n            if (prepareVar == null) {\\n                if (binBuffer == null) {\\n                    lastSqlStatement = null;\\n                    throw new SqlToolError(rb.getString(\\n                            SqltoolRB.BINBUFFER_EMPTY));\\n                }\\n                ps.setBytes(1, binBuffer);\\n            } else {\\n                String val = (String) userVars.get(prepareVar);\\n                if (val == null) {\\n                    lastSqlStatement = null;\\n                    throw new SqlToolError(\\n                            rb.getString(SqltoolRB.PLVAR_UNDEFINED,\\n                                    new String[] {prepareVar}));\\n                }\\n                prepareVar = null;\\n                ps.setString(1, val);\\n            }\\n            ps.executeUpdate();\\n            statement = ps;\\n        } else {\\n            statement = curConn.createStatement();\\n            statement.execute(lastSqlStatement);\\n        }\\n        possiblyUncommitteds.set(true);\\n        try {\\n            displayResultSet(statement, statement.getResultSet(), null, null);\\n        } finally {\\n            try {\\n                statement.close();\\n            } catch (Exception e) {}\\n        }\\n        lastSqlStatement = null;\\n    }\\n    private void displayResultSet(Statement statement, ResultSet r,\\n                                  int[] incCols,\\n                                  String filter) throws SQLException,\\n                                  SqlToolError {\\n        java.sql.Timestamp ts;\\n        int dotAt;\\n        int                updateCount = (statement == null) ? -1\\n                                                             : statement\\n                                                                 .getUpdateCount();\\n        boolean            silent      = silentFetch;\\n        boolean            binary      = fetchBinary;\\n        silentFetch = false;\\n        fetchBinary = false;\\n        if (excludeSysSchemas) {\\n            stdprintln(rb.getString(SqltoolRB.VENDOR_NOSUP_SYSSCHEMAS));\\n        }\\n        switch (updateCount) {\\n            case -1 :\\n                if (r == null) {\\n                    stdprintln(rb.getString(SqltoolRB.NORESULT), true);\\n                    break;\\n                }\\n                ResultSetMetaData m        = r.getMetaData();\\n                int               cols     = m.getColumnCount();\\n                int               incCount = (incCols == null) ? cols\\n                                                               : incCols\\n                                                                   .length;\\n                String            val;\\n                List              rows        = new ArrayList();\\n                String[]          headerArray = null;\\n                String[]          fieldArray;\\n                int[]             maxWidth = new int[incCount];\\n                int               insi;\\n                boolean           skip;\\n                                if (!htmlMode) {\\n                    for (int i = 0; i < maxWidth.length; i++) {\\n                        maxWidth[i] = 0;\\n                    }\\n                }\\n                boolean[] rightJust = new boolean[incCount];\\n                int[]     dataType  = new int[incCount];\\n                boolean[] autonulls = new boolean[incCount];\\n                insi        = -1;\\n                headerArray = new String[incCount];\\n                for (int i = 1; i <= cols; i++) {\\n                    if (incCols != null) {\\n                        skip = true;\\n                        for (int j = 0; j < incCols.length; j++) {\\n                            if (i == incCols[j]) {\\n                                skip = false;\\n                            }\\n                        }\\n                        if (skip) {\\n                            continue;\\n                        }\\n                    }\\n                    headerArray[++insi] = m.getColumnLabel(i);\\n                    dataType[insi]      = m.getColumnType(i);\\n                    rightJust[insi]     = false;\\n                    autonulls[insi]     = true;\\n                    switch (dataType[insi]) {\\n                        case java.sql.Types.BIGINT :\\n                        case java.sql.Types.BIT :\\n                        case java.sql.Types.DECIMAL :\\n                        case java.sql.Types.DOUBLE :\\n                        case java.sql.Types.FLOAT :\\n                        case java.sql.Types.INTEGER :\\n                        case java.sql.Types.NUMERIC :\\n                        case java.sql.Types.REAL :\\n                        case java.sql.Types.SMALLINT :\\n                        case java.sql.Types.TINYINT :\\n                            rightJust[insi] = true;\\n                            break;\\n                        case java.sql.Types.VARBINARY :\\n                        case java.sql.Types.VARCHAR :\\n                        case java.sql.Types.ARRAY :\\n                                                    case java.sql.Types.BLOB :\\n                        case java.sql.Types.CLOB :\\n                        case java.sql.Types.LONGVARBINARY :\\n                        case java.sql.Types.LONGVARCHAR :\\n                            autonulls[insi] = false;\\n                            break;\\n                    }\\n                    if (htmlMode) {\\n                        continue;\\n                    }\\n                    if (headerArray[insi].length() > maxWidth[insi]) {\\n                        maxWidth[insi] = headerArray[insi].length();\\n                    }\\n                }\\n                boolean filteredOut;\\n                while (r.next()) {\\n                    fieldArray  = new String[incCount];\\n                    insi        = -1;\\n                    filteredOut = filter != null;\\n                    for (int i = 1; i <= cols; i++) {\\n                                                                        if (incCols != null) {\\n                            skip = true;\\n                            for (int j = 0; j < incCols.length; j++) {\\n                                if (i == incCols[j]) {\\n                                    skip = false;\\n                                }\\n                            }\\n                            if (skip) {\\n                                continue;\\n                            }\\n                        }\\n                                                                                                ++insi;\\n                        if (!SqlFile.canDisplayType(dataType[insi])) {\\n                            binary = true;\\n                        }\\n                        val = null;\\n                        if (!binary) {\\n                            switch (dataType[insi]) {\\n                                case java.sql.Types.TIMESTAMP:\\n                                case java.sql.Types.DATE:\\n                                case java.sql.Types.TIME:\\n                                    ts  = r.getTimestamp(i);\\n                                    val = ((ts == null) ? null : ts.toString());\\n                                                                                                                                                if (dataType[insi]\\n                                            != java.sql.Types.TIMESTAMP\\n                                            && val != null) {\\n                                        dotAt = val.lastIndexOf('.');\\n                                        for (int z = dotAt + 1;\\n                                                z < val.length(); z++) {\\n                                            if (val.charAt(z) != '0') {\\n                                                dotAt = 0;\\n                                                break;\\n                                            }\\n                                        }\\n                                        if (dotAt > 1) {\\n                                            val = val.substring(0, dotAt);\\n                                        }\\n                                    }\\n                                    break;\\n                                default:\\n                                    val = r.getString(i);\\n                                                                                                                                                if (val == null) {\\n                                        try {\\n                                            val = streamToString(\\n                                                r.getAsciiStream(i), charset);\\n                                        } catch (Exception e) { }\\n                                    }\\n                            }\\n                        }\\n                        if (binary || (val == null &&!r.wasNull())) {\\n                            if (pwDsv != null) {\\n                                throw new SqlToolError(\\n                                        rb.getString(SqltoolRB.DSV_BINCOL));\\n                            }\\n                                                                                    try {\\n                                binBuffer =\\n                                    SqlFile.streamToBytes(r.getBinaryStream(i));\\n                            } catch (IOException ioe) {\\n                                throw new SqlToolError(\\n                                    \\\"Failed to read value using stream\\\",\\n                                    ioe);\\n                            }\\n                            stdprintln(rb.getString(SqltoolRB.BINBUF_WRITE,\\n                                    new String[] {\\n                                       Integer.toString(binBuffer.length),\\n                                       headerArray[insi],\\n                                       SqlFile.sqlTypeToString(dataType[insi])\\n                                    }));\\n                            return;\\n                        }\\n                        if (excludeSysSchemas && val != null && i == 2) {\\n                            for (int z = 0; z < oracleSysSchemas.length;\\n                                    z++) {\\n                                if (val.equals(oracleSysSchemas[z])) {\\n                                    filteredOut = true;\\n                                    break;\\n                                }\\n                            }\\n                        }\\n                        userVars.put(\\\"?\\\", ((val == null) ? nullRepToken : val));\\n                        if (fetchingVar != null) {\\n                            userVars.put(fetchingVar, userVars.get(\\\"?\\\"));\\n                            updateUserSettings();\\n                            fetchingVar = null;\\n                        }\\n                        if (silent) {\\n                            return;\\n                        }\\n                                                                                                if (filter != null\\n                                && (val == null\\n                                    || val.indexOf(filter) > -1)) {\\n                            filteredOut = false;\\n                        }\\n                                                                        if (val == null && pwDsv == null) {\\n                            if (dataType[insi] == java.sql.Types.VARCHAR) {\\n                                fieldArray[insi] = (htmlMode ? \\\"<I>null</I>\\\"\\n                                                             : nullRepToken);\\n                            } else {\\n                                fieldArray[insi] = \\\"\\\";\\n                            }\\n                        } else {\\n                            fieldArray[insi] = val;\\n                        }\\n                                                if (htmlMode || pwDsv != null) {\\n                            continue;\\n                        }\\n                        if (fieldArray[insi].length() > maxWidth[insi]) {\\n                            maxWidth[insi] = fieldArray[insi].length();\\n                        }\\n                    }\\n                    if (!filteredOut) {\\n                        rows.add(fieldArray);\\n                    }\\n                }\\n                                                if (pwDsv == null) {\\n                    condlPrintln(\\\"<TABLE border='1'>\\\", true);\\n                    if (incCount > 1) {\\n                        condlPrint(SqlFile.htmlRow(COL_HEAD) + LS + PRE_TD, true);\\n                        for (int i = 0; i < headerArray.length; i++) {\\n                            condlPrint(\\\"<TD>\\\" + headerArray[i] + \\\"</TD>\\\",\\n                                       true);\\n                            condlPrint(((i > 0) ? SqlFile.spaces(2)\\n                                                : \\\"\\\") + SqlFile.pad(\\n                                                    headerArray[i],\\n                                                    maxWidth[i],\\n                                                    rightJust[i],\\n                                                    (i < headerArray.length\\n                                                     - 1 || rightJust[i])), false);\\n                        }\\n                        condlPrintln(LS + PRE_TR + \\\"</TR>\\\", true);\\n                        condlPrintln(\\\"\\\", false);\\n                        if (!htmlMode) {\\n                            for (int i = 0; i < headerArray.length; i++) {\\n                                condlPrint(((i > 0) ? SqlFile.spaces(2)\\n                                                    : \\\"\\\") + SqlFile.divider(\\n                                                        maxWidth[i]), false);\\n                            }\\n                            condlPrintln(\\\"\\\", false);\\n                        }\\n                    }\\n                    for (int i = 0; i < rows.size(); i++) {\\n                        condlPrint(SqlFile.htmlRow(((i % 2) == 0) ? COL_EVEN\\n                                                          : COL_ODD) + LS\\n                                                          + PRE_TD, true);\\n                        fieldArray = (String[]) rows.get(i);\\n                        for (int j = 0; j < fieldArray.length; j++) {\\n                            condlPrint(\\\"<TD>\\\" + fieldArray[j] + \\\"</TD>\\\",\\n                                       true);\\n                            condlPrint(((j > 0) ? SqlFile.spaces(2)\\n                                                : \\\"\\\") + SqlFile.pad(\\n                                                    fieldArray[j],\\n                                                    maxWidth[j],\\n                                                    rightJust[j],\\n                                                    (j < fieldArray.length\\n                                                     - 1 || rightJust[j])), false);\\n                        }\\n                        condlPrintln(LS + PRE_TR + \\\"</TR>\\\", true);\\n                        condlPrintln(\\\"\\\", false);\\n                    }\\n                    condlPrintln(\\\"</TABLE>\\\", true);\\n                    if (rows.size() != 1) {\\n                        stdprintln(LS + rb.getString(SqltoolRB.ROWS_FETCHED,\\n                                new String[] { Integer.toString(rows.size()) }),\\n                        true);\\n                    }\\n                    condlPrintln(\\\"<HR>\\\", true);\\n                    break;\\n                }\\n                                if (incCount > 0) {\\n                    for (int i = 0; i < headerArray.length; i++) {\\n                        dsvSafe(headerArray[i]);\\n                        pwDsv.print(headerArray[i]);\\n                        if (i < headerArray.length - 1) {\\n                            pwDsv.print(dsvColDelim);\\n                        }\\n                    }\\n                    pwDsv.print(dsvRowDelim);\\n                }\\n                for (int i = 0; i < rows.size(); i++) {\\n                    fieldArray = (String[]) rows.get(i);\\n                    for (int j = 0; j < fieldArray.length; j++) {\\n                        dsvSafe(fieldArray[j]);\\n                        pwDsv.print((fieldArray[j] == null)\\n                                    ? (autonulls[j] ? \\\"\\\"\\n                                                    : nullRepToken)\\n                                    : fieldArray[j]);\\n                        if (j < fieldArray.length - 1) {\\n                            pwDsv.print(dsvColDelim);\\n                        }\\n                    }\\n                    pwDsv.print(dsvRowDelim);\\n                }\\n                stdprintln(rb.getString(SqltoolRB.ROWS_FETCHED_DSV,\\n                        new String[] { Integer.toString(rows.size()) }));\\n                break;\\n            default :\\n                userVars.put(\\\"?\\\", Integer.toString(updateCount));\\n                if (fetchingVar != null) {\\n                    userVars.put(fetchingVar, userVars.get(\\\"?\\\"));\\n                    updateUserSettings();\\n                    fetchingVar = null;\\n                }\\n                if (updateCount != 0) {\\n                    stdprintln((updateCount == 1)\\n                        ? rb.getString(SqltoolRB.ROW_UPDATE_SINGULAR)\\n                        : rb.getString(SqltoolRB.ROW_UPDATE_MULTIPLE,\\n                                new String[] {Integer.toString(updateCount)}));\\n                }\\n                break;\\n        }\\n    }\\n    private static final int    COL_HEAD = 0,\\n                                COL_ODD  = 1,\\n                                COL_EVEN = 2\\n    ;\\n    private static final String PRE_TR   = spaces(4);\\n    private static final String PRE_TD   = spaces(8);\\n    private static String htmlRow(int colType) {\\n        switch (colType) {\\n            case COL_HEAD :\\n                return PRE_TR + \\\"<TR style='font-weight: bold;'>\\\";\\n            case COL_ODD :\\n                return PRE_TR\\n                       + \\\"<TR style='background: #94d6ef; font: normal \\\"\\n                       + \\\"normal 10px/10px Arial, Helvitica, sans-serif;'>\\\";\\n            case COL_EVEN :\\n                return PRE_TR\\n                       + \\\"<TR style='background: silver; font: normal \\\"\\n                       + \\\"normal 10px/10px Arial, Helvitica, sans-serif;'>\\\";\\n        }\\n        return null;\\n    }\\n    private static String divider(int len) {\\n        return (len > DIVIDER.length()) ? DIVIDER\\n                                        : DIVIDER.substring(0, len);\\n    }\\n    private static String spaces(int len) {\\n        return (len > SPACES.length()) ? SPACES\\n                                       : SPACES.substring(0, len);\\n    }\\n    private static String pad(String inString, int fulllen,\\n                              boolean rightJustify, boolean doPad) {\\n        if (!doPad) {\\n            return inString;\\n        }\\n        int len = fulllen - inString.length();\\n        if (len < 1) {\\n            return inString;\\n        }\\n        String pad = SqlFile.spaces(len);\\n        return ((rightJustify ? pad\\n                              : \\\"\\\") + inString + (rightJustify ? \\\"\\\"\\n                                                               : pad));\\n    }\\n    private void showHistory() throws BadSpecial {\\n        if (history == null) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_UNAVAILABLE));\\n        }\\n        if (history.size() < 1) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_NONE));\\n        } else {\\n            for (int i = 0; i < history.size(); i++) {\\n                psStd.println(\\\"#\\\" + (i + oldestHist) + \\\" or \\\"\\n                        + (i - history.size()) + ':');\\n                psStd.println((String) history.get(i));\\n            }\\n        }\\n        if (buffer != null) {\\n            psStd.println(rb.getString(SqltoolRB.EDITBUFFER_CONTENTS,\\n                    new String[] { buffer}));\\n        }\\n        psStd.println();\\n        psStd.println(rb.getString(SqltoolRB.BUFFER_INSTRUCTIONS));\\n    }\\n    private String commandFromHistory(int inIndex) throws BadSpecial {\\n        int index = inIndex;  \\n        if (history == null) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_UNAVAILABLE));\\n        }\\n        if (index == 0) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_NUMBER_REQ));\\n        }\\n        if (index > 0) {\\n                        index -= oldestHist;\\n            if (index < 0) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_BACKTO,\\n                       new String[] { Integer.toString(oldestHist) }));\\n            }\\n            if (index >= history.size()) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_UPTO,\\n                       new String[] { Integer.toString(\\n                               history.size() + oldestHist - 1\\n                       )}));\\n            }\\n        } else {\\n                        index += history.size();\\n            if (index < 0) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_BACK,\\n                       new String[] { Integer.toString(history.size()) }));\\n            }\\n        }\\n        return (String) history.get(index);\\n    }\\n    private void setBuf(String newContent) {\\n        buffer = new String(newContent);\\n            }\\n    int oldestHist = 1;\\n    private void historize() {\\n        if (history == null || buffer == null) {\\n            return;\\n        }\\n        if (history.size() > 0 &&\\n                history.get(history.size() - 1).equals(buffer)) {\\n                        return;\\n        }\\n        history.add(buffer);\\n        if (history.size() <= maxHistoryLength) {\\n            return;\\n        }\\n        history.remove(0);\\n        oldestHist++;\\n    }\\n    private void describe(String tableName,\\n                          String inFilter) throws SQLException {\\n        String    filter = inFilter;\\n        List      rows        = new ArrayList();\\n        String[]  headerArray = {\\n            rb.getString(SqltoolRB.DESCRIBE_TABLE_NAME),\\n            rb.getString(SqltoolRB.DESCRIBE_TABLE_DATATYPE),\\n            rb.getString(SqltoolRB.DESCRIBE_TABLE_WIDTH),\\n            rb.getString(SqltoolRB.DESCRIBE_TABLE_NONULLS),\\n        };\\n        String[]  fieldArray;\\n        int[]     maxWidth  = {\\n            0, 0, 0, 0\\n        };\\n        boolean[] rightJust = {\\n            false, false, true, false\\n        };\\n                for (int i = 0; i < headerArray.length; i++) {\\n            if (htmlMode) {\\n                continue;\\n            }\\n            if (headerArray[i].length() > maxWidth[i]) {\\n                maxWidth[i] = headerArray[i].length();\\n            }\\n        }\\n        Statement statement = curConn.createStatement();\\n        ResultSet r         = null;\\n        try {\\n            statement.execute(\\\"SELECT * FROM \\\" + tableName + \\\" WHERE 1 = 2\\\");\\n            r = statement.getResultSet();\\n            ResultSetMetaData m    = r.getMetaData();\\n            int               cols = m.getColumnCount();\\n            for (int i = 0; i < cols; i++) {\\n                fieldArray    = new String[4];\\n                fieldArray[0] = m.getColumnName(i + 1);\\n                if (filter != null && fieldArray[0].indexOf(filter) < 0) {\\n                    continue;\\n                }\\n                fieldArray[1] = m.getColumnTypeName(i + 1);\\n                fieldArray[2] = Integer.toString(m.getColumnDisplaySize(i\\n                        + 1));\\n                fieldArray[3] =\\n                    ((m.isNullable(i + 1) == java.sql.ResultSetMetaData.columnNullable)\\n                     ? (htmlMode ? \\\"&nbsp;\\\"\\n                                 : \\\"\\\")\\n                     : \\\"*\\\");\\n                rows.add(fieldArray);\\n                for (int j = 0; j < fieldArray.length; j++) {\\n                    if (fieldArray[j].length() > maxWidth[j]) {\\n                        maxWidth[j] = fieldArray[j].length();\\n                    }\\n                }\\n            }\\n                        condlPrint(\\\"<TABLE border='1'>\\\" + LS + SqlFile.htmlRow(COL_HEAD) + LS\\n                       + PRE_TD, true);\\n            for (int i = 0; i < headerArray.length; i++) {\\n                condlPrint(\\\"<TD>\\\" + headerArray[i] + \\\"</TD>\\\", true);\\n                condlPrint(((i > 0) ? SqlFile.spaces(2)\\n                                    : \\\"\\\") + SqlFile.pad(headerArray[i], maxWidth[i],\\n                                                rightJust[i],\\n                                                (i < headerArray.length - 1\\n                                                 || rightJust[i])), false);\\n            }\\n            condlPrintln(LS + PRE_TR + \\\"</TR>\\\", true);\\n            condlPrintln(\\\"\\\", false);\\n            if (!htmlMode) {\\n                for (int i = 0; i < headerArray.length; i++) {\\n                    condlPrint(((i > 0) ? SqlFile.spaces(2)\\n                                        : \\\"\\\") + SqlFile.divider(maxWidth[i]), false);\\n                }\\n                condlPrintln(\\\"\\\", false);\\n            }\\n            for (int i = 0; i < rows.size(); i++) {\\n                condlPrint(SqlFile.htmlRow(((i % 2) == 0) ? COL_EVEN\\n                                                  : COL_ODD) + LS\\n                                                  + PRE_TD, true);\\n                fieldArray = (String[]) rows.get(i);\\n                for (int j = 0; j < fieldArray.length; j++) {\\n                    condlPrint(\\\"<TD>\\\" + fieldArray[j] + \\\"</TD>\\\", true);\\n                    condlPrint(((j > 0) ? SqlFile.spaces(2)\\n                                        : \\\"\\\") + SqlFile.pad(\\n                                            fieldArray[j], maxWidth[j],\\n                                            rightJust[j],\\n                                            (j < fieldArray.length - 1\\n                                             || rightJust[j])), false);\\n                }\\n                condlPrintln(LS + PRE_TR + \\\"</TR>\\\", true);\\n                condlPrintln(\\\"\\\", false);\\n            }\\n            condlPrintln(LS + \\\"</TABLE>\\\" + LS + \\\"<HR>\\\", true);\\n        } finally {\\n            try {\\n                if (r != null) {\\n                    r.close();\\n                    r = null;\\n                }\\n                statement.close();\\n            } catch (Exception e) {}\\n        }\\n    }\\n    private boolean eval(String[] inTokens) throws BadSpecial {\\n                        boolean  negate = inTokens.length > 0 && inTokens[0].equals(\\\"!\\\");\\n        String[] tokens = new String[negate ? (inTokens.length - 1)\\n                                            : inTokens.length];\\n        String inToken;\\n        String varName;\\n        for (int i = 0; i < tokens.length; i++) {\\n            inToken = inTokens[i + (negate ? 1 : 0)];\\n            if (inToken.length() > 1 && inToken.charAt(0) == '*') {\\n                varName = inToken.substring(1);\\n                tokens[i] = (String) userVars.get(inToken.substring(1));\\n            } else {\\n                tokens[i] = inTokens[i + (negate ? 1 : 0)];\\n            }\\n                                    if (tokens[i] == null) {\\n                tokens[i] = \\\"\\\";\\n            }\\n        }\\n        if (tokens.length == 1) {\\n            return (tokens[0].length() > 0 &&!tokens[0].equals(\\\"0\\\")) ^ negate;\\n        }\\n        if (tokens.length == 3) {\\n            if (tokens[1].equals(\\\"==\\\")) {\\n                return tokens[0].equals(tokens[2]) ^ negate;\\n            }\\n            if (tokens[1].equals(\\\"!=\\\") || tokens[1].equals(\\\"<>\\\")\\n                    || tokens[1].equals(\\\"><\\\")) {\\n                return (!tokens[0].equals(tokens[2])) ^ negate;\\n            }\\n            if (tokens[1].equals(\\\">\\\")) {\\n                return (tokens[0].length() > tokens[2].length() || ((tokens[0].length() == tokens[2].length()) && tokens[0].compareTo(tokens[2]) > 0))\\n                       ^ negate;\\n            }\\n            if (tokens[1].equals(\\\"<\\\")) {\\n                return (tokens[2].length() > tokens[0].length() || ((tokens[2].length() == tokens[0].length()) && tokens[2].compareTo(tokens[0]) > 0))\\n                       ^ negate;\\n            }\\n        }\\n        throw new BadSpecial(rb.getString(SqltoolRB.LOGICAL_UNRECOGNIZED));\\n    }\\n    private void closeQueryOutputStream() {\\n        if (pwQuery == null) {\\n            return;\\n        }\\n        if (htmlMode) {\\n            pwQuery.println(\\\"</BODY></HTML>\\\");\\n            pwQuery.flush();\\n        }\\n        pwQuery.close();\\n        pwQuery = null;\\n    }\\n    private void condlPrintln(String s, boolean printHtml) {\\n        if ((printHtml &&!htmlMode) || (htmlMode &&!printHtml)) {\\n            return;\\n        }\\n        psStd.println(s);\\n        if (pwQuery != null) {\\n            pwQuery.println(s);\\n            pwQuery.flush();\\n        }\\n    }\\n    private void condlPrint(String s, boolean printHtml) {\\n        if ((printHtml &&!htmlMode) || (htmlMode &&!printHtml)) {\\n            return;\\n        }\\n        psStd.print(s);\\n        if (pwQuery != null) {\\n            pwQuery.print(s);\\n            pwQuery.flush();\\n        }\\n    }\\n    private String formatNicely(Map map, boolean withValues) {\\n        String       key;\\n        StringBuffer sb = new StringBuffer();\\n        Iterator     it = (new TreeMap(map)).keySet().iterator();\\n        if (withValues) {\\n            SqlFile.appendLine(sb, rb.getString(SqltoolRB.PL_LIST_PARENS));\\n        } else {\\n            SqlFile.appendLine(sb, rb.getString(SqltoolRB.PL_LIST_LENGTHS));\\n        }\\n        while (it.hasNext()) {\\n            key = (String) it.next();\\n            String s = (String) map.get(key);\\n            SqlFile.appendLine(sb, \\\"    \\\" + key + \\\": \\\" + (withValues ? (\\\"(\\\" + s + ')')\\n                                                        : Integer.toString(\\n                                                        s.length())));\\n        }\\n        return sb.toString();\\n    }\\n    private void dump(String varName,\\n                      File dumpFile) throws IOException, BadSpecial {\\n        String val = (String) userVars.get(varName);\\n        if (val == null) {\\n            throw new BadSpecial(rb.getString(\\n                    SqltoolRB.PLVAR_UNDEFINED, new String[] {varName}));\\n        }\\n        OutputStreamWriter osw = ((charset == null)\\n                ? (new OutputStreamWriter(new FileOutputStream(dumpFile)))\\n                : (new OutputStreamWriter(new FileOutputStream(dumpFile),\\n                            charset)));\\n        try {\\n            osw.write(val);\\n            if (val.length() > 0) {\\n                char lastChar = val.charAt(val.length() - 1);\\n                if (lastChar != '\\\\n' && lastChar != '\\\\r') {\\n                    osw.write(LS);\\n                }\\n            }\\n            osw.flush();\\n        } finally {\\n            osw.close();\\n        }\\n                        stdprintln(rb.getString(SqltoolRB.FILE_WROTECHARS, new String[] {\\n                Long.toString(dumpFile.length()), dumpFile.toString() }));\\n    }\\n    byte[] binBuffer = null;\\n    private void dump(File dumpFile) throws IOException, BadSpecial {\\n        if (binBuffer == null) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.BINBUFFER_EMPTY));\\n        }\\n        FileOutputStream fos = new FileOutputStream(dumpFile);\\n        int len = 0;\\n        try {\\n            fos.write(binBuffer);\\n            len = binBuffer.length;\\n            binBuffer = null;\\n            fos.flush();\\n        } finally {\\n            fos.close();\\n        }\\n        stdprintln(rb.getString(SqltoolRB.FILE_WROTECHARS,\\n                new String[] { Integer.toString(len), dumpFile.toString() }));\\n    }\\n    public String streamToString(InputStream is, String cs)\\n            throws IOException {\\n        try {\\n            byte[] ba = null;\\n            int bytesread = 0;\\n            int retval;\\n            try {\\n                ba = new byte[is.available()];\\n            } catch (RuntimeException re) {\\n                throw new IOException(rb.getString(SqltoolRB.READ_TOOBIG));\\n            }\\n            while (bytesread < ba.length &&\\n                    (retval = is.read(\\n                            ba, bytesread, ba.length - bytesread)) > 0) {\\n                bytesread += retval;\\n            }\\n            if (bytesread != ba.length) {\\n                throw new IOException(rb.getString(\\n                        SqltoolRB.READ_PARTIAL, new String[] {\\n                            Integer.toString(bytesread),\\n                            Integer.toString(ba.length)\\n                        }));\\n            }\\n            try {\\n                return (cs == null) ? (new String(ba))\\n                                         : (new String(ba, cs));\\n            } catch (UnsupportedEncodingException uee) {\\n                throw new RuntimeException(uee);\\n            } catch (RuntimeException re) {\\n                throw new IOException(rb.getString(SqltoolRB.READ_CONVERTFAIL));\\n            }\\n        } finally {\\n            is.close();\\n        }\\n    }\\n    private void load(String varName, File asciiFile, String cs)\\n            throws IOException {\\n        String string = streamToString(new FileInputStream(asciiFile), cs);\\n        userVars.put(varName, string);\\n        updateUserSettings();\\n    }\\n    static public byte[] streamToBytes(InputStream is) throws IOException {\\n        byte[]                xferBuffer = new byte[10240];\\n        ByteArrayOutputStream baos       = new ByteArrayOutputStream();\\n        int                   i;\\n        while ((i = is.read(xferBuffer)) > 0) {\\n            baos.write(xferBuffer, 0, i);\\n        }\\n        return baos.toByteArray();\\n    }\\n    static public byte[] loadBinary(File binFile) throws IOException {\\n        byte[]                xferBuffer = new byte[10240];\\n        ByteArrayOutputStream baos       = new ByteArrayOutputStream();\\n        int                   i;\\n        FileInputStream       fis        = new FileInputStream(binFile);\\n        try {\\n            while ((i = fis.read(xferBuffer)) > 0) {\\n                baos.write(xferBuffer, 0, i);\\n            }\\n        } finally {\\n            fis.close();\\n        }\\n        byte[] ba = baos.toByteArray();\\n        return ba;\\n    }\\n    public static boolean canDisplayType(int i) {\\n        switch (i) {\\n                        case java.sql.Types.BLOB :\\n            case java.sql.Types.JAVA_OBJECT :\\n                                    case java.sql.Types.OTHER :\\n            case java.sql.Types.STRUCT :\\n                                return false;\\n        }\\n        return true;\\n    }\\n        private static final int JDBC3_BOOLEAN  = 16;\\n    private static final int JDBC3_DATALINK = 70;\\n    public static String sqlTypeToString(int i) {\\n        switch (i) {\\n            case java.sql.Types.ARRAY :\\n                return \\\"ARRAY\\\";\\n            case java.sql.Types.BIGINT :\\n                return \\\"BIGINT\\\";\\n            case java.sql.Types.BINARY :\\n                return \\\"BINARY\\\";\\n            case java.sql.Types.BIT :\\n                return \\\"BIT\\\";\\n            case java.sql.Types.BLOB :\\n                return \\\"BLOB\\\";\\n            case JDBC3_BOOLEAN :\\n                return \\\"BOOLEAN\\\";\\n            case java.sql.Types.CHAR :\\n                return \\\"CHAR\\\";\\n            case java.sql.Types.CLOB :\\n                return \\\"CLOB\\\";\\n            case JDBC3_DATALINK :\\n                return \\\"DATALINK\\\";\\n            case java.sql.Types.DATE :\\n                return \\\"DATE\\\";\\n            case java.sql.Types.DECIMAL :\\n                return \\\"DECIMAL\\\";\\n            case java.sql.Types.DISTINCT :\\n                return \\\"DISTINCT\\\";\\n            case java.sql.Types.DOUBLE :\\n                return \\\"DOUBLE\\\";\\n            case java.sql.Types.FLOAT :\\n                return \\\"FLOAT\\\";\\n            case java.sql.Types.INTEGER :\\n                return \\\"INTEGER\\\";\\n            case java.sql.Types.JAVA_OBJECT :\\n                return \\\"JAVA_OBJECT\\\";\\n            case java.sql.Types.LONGVARBINARY :\\n                return \\\"LONGVARBINARY\\\";\\n            case java.sql.Types.LONGVARCHAR :\\n                return \\\"LONGVARCHAR\\\";\\n            case java.sql.Types.NULL :\\n                return \\\"NULL\\\";\\n            case java.sql.Types.NUMERIC :\\n                return \\\"NUMERIC\\\";\\n            case java.sql.Types.OTHER :\\n                return \\\"OTHER\\\";\\n            case java.sql.Types.REAL :\\n                return \\\"REAL\\\";\\n            case java.sql.Types.REF :\\n                return \\\"REF\\\";\\n            case java.sql.Types.SMALLINT :\\n                return \\\"SMALLINT\\\";\\n            case java.sql.Types.STRUCT :\\n                return \\\"STRUCT\\\";\\n            case java.sql.Types.TIME :\\n                return \\\"TIME\\\";\\n            case java.sql.Types.TIMESTAMP :\\n                return \\\"TIMESTAMP\\\";\\n            case java.sql.Types.TINYINT :\\n                return \\\"TINYINT\\\";\\n            case java.sql.Types.VARBINARY :\\n                return \\\"VARBINARY\\\";\\n            case java.sql.Types.VARCHAR :\\n                return \\\"VARCHAR\\\";\\n        }\\n        return \\\"Unknown type \\\" + i;\\n    }\\n    public void dsvSafe(String s) throws SqlToolError {\\n        if (pwDsv == null || dsvColDelim == null || dsvRowDelim == null\\n                || nullRepToken == null) {\\n            throw new RuntimeException(\\n                \\\"Assertion failed.  \\\\n\\\"\\n                + \\\"dsvSafe called when DSV settings are incomplete\\\");\\n        }\\n        if (s == null) {\\n            return;\\n        }\\n        if (s.indexOf(dsvColDelim) > 0) {\\n            throw new SqlToolError(rb.getString(SqltoolRB.DSV_COLDELIM_PRESENT,\\n                        new String[] {dsvColDelim}));\\n        }\\n        if (s.indexOf(dsvRowDelim) > 0) {\\n            throw new SqlToolError(rb.getString(SqltoolRB.DSV_ROWDELIM_PRESENT,\\n                        new String[] {dsvRowDelim}));\\n        }\\n        if (s.trim().equals(nullRepToken)) {\\n                                    throw new SqlToolError(rb.getString(SqltoolRB.DSV_NULLREP_PRESENT,\\n                        new String[] {nullRepToken}));\\n        }\\n    }\\n    public static String convertEscapes(String inString) {\\n        if (inString == null) {\\n            return null;\\n        }\\n        return convertNumericEscapes(\\n                convertEscapes(convertEscapes(convertEscapes(convertEscapes(\\n                    convertEscapes(inString, \\\"\\\\\\\\n\\\", \\\"\\\\n\\\"), \\\"\\\\\\\\r\\\", \\\"\\\\r\\\"),\\n                \\\"\\\\\\\\t\\\", \\\"\\\\t\\\"), \\\"\\\\\\\\\\\\\\\\\\\", \\\"\\\\\\\\\\\"),\\n            \\\"\\\\\\\\f\\\", \\\"\\\\f\\\")\\n        );\\n    }\\n    private static String convertNumericEscapes(String string) {\\n        String workString = string;\\n        int i = 0;\\n        for (char dig = '0'; dig <= '9'; dig++) {\\n            while ((i = workString.indexOf(\\\"\\\\\\\\\\\" + dig, i)) > -1\\n                    && i < workString.length() - 1) {\\n                workString = convertNumericEscape(string, i);\\n            }\\n            while ((i = workString.indexOf(\\\"\\\\\\\\x\\\" + dig, i)) > -1\\n                    && i < workString.length() - 1) {\\n                workString = convertNumericEscape(string, i);\\n            }\\n            while ((i = workString.indexOf(\\\"\\\\\\\\X\\\" + dig, i)) > -1\\n                    && i < workString.length() - 1) {\\n                workString = convertNumericEscape(string, i);\\n            }\\n        }\\n        return workString;\\n    }\\n    private static String convertNumericEscape(String string, int offset) {\\n        int post = -1;\\n        int firstDigit = -1;\\n        int radix = -1;\\n        if (Character.toUpperCase(string.charAt(offset + 1)) == 'X') {\\n            firstDigit = offset + 2;\\n            radix = 16;\\n            post = firstDigit + 2;\\n            if (post > string.length()) post = string.length();\\n        } else {\\n            firstDigit = offset + 1;\\n            radix = (Character.toUpperCase(string.charAt(firstDigit)) == '0')\\n                    ? 8 : 10;\\n            for (post = firstDigit + 1; post < string.length()\\n                    && Character.isDigit(string.charAt(post)); post++) ;\\n        }\\n        return string.substring(0, offset) + ((char)\\n                Integer.parseInt(string.substring(firstDigit, post), radix))\\n                + string.substring(post);\\n    }\\n    private static String convertEscapes(String string, String from, String to) {\\n        String workString = string;\\n        int i = 0;\\n        int fromLen = from.length();\\n        while ((i = workString.indexOf(from, i)) > -1\\n                && i < workString.length() - 1) {\\n            workString = workString.substring(0, i) + to\\n                         + workString.substring(i + fromLen);\\n        }\\n        return workString;\\n    }\\n    public void importDsv(String filePath, String skipPrefix)\\n            throws SqlToolError {\\n        byte[] bfr  = null;\\n        File   file = new File(filePath);\\n        SortedMap constColMap = null;\\n        int constColMapSize = 0;\\n        if (dsvConstCols != null) {\\n                                    constColMap = new TreeMap();\\n            String[] constPairs = dsvConstCols.split(\\\"\\\\\\\\Q\\\"\\n                    + dsvColDelim + \\\"\\\\\\\\E\\\\\\\\s*\\\");\\n            int firstEq;\\n            String n;\\n            for (int i = 0; i < constPairs.length; i++) {\\n                firstEq = constPairs[i].indexOf('=');\\n                n = constPairs[i].substring(0, i).trim();\\n                if (n.trim().length() < 1) {\\n                    throw new SqlToolError(\\n                            rb.getString(SqltoolRB.DSV_CONSTCOLS_NULLCOL));\\n                }\\n                constColMap.put(n, constPairs[i].substring(firstEq + 1));\\n            }\\n        }\\n        Set ucSkipCols = null;\\n        if (dsvSkipCols != null) {\\n            ucSkipCols = new HashSet();\\n            String[] skipCols = dsvSkipCols.split(\\\"\\\\\\\\s*\\\\\\\\Q\\\"\\n                    + dsvColDelim + \\\"\\\\\\\\E\\\\\\\\s*\\\");\\n            for (int i = 0; i < skipCols.length; i++) {\\n                ucSkipCols.add(skipCols[i].toUpperCase());\\n            }\\n        }\\n        if (!file.canRead()) {\\n            throw new SqlToolError(rb.getString(SqltoolRB.FILE_READFAIL,\\n                    new String[] {file.toString()} ));\\n        }\\n        try {\\n            bfr = new byte[(int) file.length()];\\n        } catch (RuntimeException re) {\\n            throw new SqlToolError(rb.getString(SqltoolRB.READ_TOOBIG), re);\\n        }\\n        int bytesread = 0;\\n        int retval;\\n        InputStream is = null;\\n        try {\\n            is = new FileInputStream(file);\\n            while (bytesread < bfr.length &&\\n                    (retval = is.read(bfr, bytesread, bfr.length - bytesread))\\n                    > 0) {\\n                bytesread += retval;\\n            }\\n        } catch (IOException ioe) {\\n            throw new SqlToolError(ioe);\\n        } finally {\\n            if (is != null) try {\\n                is.close();\\n            } catch (IOException ioe) {\\n                errprintln(rb.getString(SqltoolRB.INPUTFILE_CLOSEFAIL)\\n                        + \\\": \\\" + ioe);\\n            }\\n        }\\n        if (bytesread != bfr.length) {\\n            throw new SqlToolError(rb.getString(SqltoolRB.READ_PARTIAL,\\n                    new String[] {\\n                        Integer.toString(bytesread),\\n                        Integer.toString(bfr.length)\\n                    }));\\n        }\\n        String string = null;\\n        String dateString;\\n        try {\\n            string = ((charset == null)\\n                    ? (new String(bfr)) : (new String(bfr, charset)));\\n        } catch (UnsupportedEncodingException uee) {\\n            throw new RuntimeException(uee);\\n        } catch (RuntimeException re) {\\n            throw new SqlToolError(rb.getString(SqltoolRB.READ_CONVERTFAIL),\\n                    re);\\n        }\\n        List     headerList = new ArrayList();\\n        String    tableName = dsvTargetTable;\\n                int recEnd = -1000;                                     int colStart;\\n        int colEnd;\\n                int lineCount = 0;         int recStart = -1;\\n        String trimmedLine = null;\\n        boolean switching = false;\\n        while (true) {\\n            recStart = (recStart < 0) ? 0 : (recEnd + dsvRowDelim.length());\\n            if (recStart > string.length() - 2) {\\n                throw new SqlToolError(rb.getString(SqltoolRB.DSV_HEADER_NONE));\\n            }\\n            recEnd = string.indexOf(dsvRowDelim, recStart);\\n            lineCount++; \\n            if (recEnd < 0) {\\n                                recEnd = string.length();\\n            }\\n            trimmedLine = string.substring(recStart, recEnd).trim();\\n            if (trimmedLine.length() < 1\\n                    || (skipPrefix != null\\n                            && trimmedLine.startsWith(skipPrefix))) {\\n                continue;\\n            }\\n            if (trimmedLine.startsWith(\\\"targettable=\\\")) {\\n                if (tableName == null) {\\n                    tableName = trimmedLine.substring(\\n                            \\\"targettable=\\\".length()).trim();\\n                }\\n                continue;\\n            }\\n            if (trimmedLine.equals(\\\"headerswitch{\\\")) {\\n                if (tableName == null) {\\n                    throw new SqlToolError(rb.getString(\\n                            SqltoolRB.DSV_HEADER_NOSWITCHTARG, new String[] {\\n                            Integer.toString(lineCount)}));\\n                }\\n                switching = true;\\n                continue;\\n            }\\n            if (trimmedLine.equals(\\\"}\\\")) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.DSV_HEADER_NOSWITCHMATCH, new String[] {\\n                                Integer.toString(lineCount)}));\\n            }\\n            if (!switching) {\\n                break;\\n            }\\n            int colonAt = trimmedLine.indexOf(':');\\n            if (colonAt < 1 || colonAt == trimmedLine.length() - 1) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.DSV_HEADER_NONSWITCHED, new String[] {\\n                                Integer.toString(lineCount)}));\\n            }\\n            String matcher = trimmedLine.substring(0, colonAt).trim();\\n                                    if (matcher.equals(\\\"*\\\") || matcher.equalsIgnoreCase(tableName)){\\n                recStart = 1 + string.indexOf(':', recStart);\\n                break;\\n            }\\n                    }\\n        String headerLine = string.substring(recStart, recEnd);\\n        colStart = recStart;\\n        colEnd   = -1;\\n        String colName;\\n        while (true) {\\n            if (colEnd == recEnd) {\\n                                break;\\n            }\\n            colEnd = string.indexOf(dsvColDelim, colStart);\\n            if (colEnd < 0 || colEnd > recEnd) {\\n                colEnd = recEnd;\\n            }\\n            if (colEnd - colStart < 1) {\\n                throw new SqlToolError(rb.getString(\\n                            SqltoolRB.DSV_NOCOLHEADER, new String[] {\\n                        Integer.toString(headerList.size() + 1),\\n                        Integer.toString(lineCount)\\n                }));\\n            }\\n            colName = string.substring(colStart, colEnd).trim();\\n            headerList.add(\\n                (colName.equals(\\\"-\\\")\\n                        || (ucSkipCols != null\\n                                && ucSkipCols.remove(colName.toUpperCase()))\\n                )\\n                ? ((String) null)\\n                : colName);\\n            colStart = colEnd + dsvColDelim.length();\\n        } if (ucSkipCols != null && ucSkipCols.size() > 0) {\\n            throw new SqlToolError(rb.getString(\\n                    SqltoolRB.DSV_SKIPCOLS_MISSING, new String[] {\\n                            ucSkipCols.toString()}));\\n        }\\n        boolean oneCol = false;          for (int i = 0; i < headerList.size(); i++) {\\n            if (headerList.get(i) != null) {\\n                oneCol = true;\\n                break;\\n            }\\n        }\\n        if (oneCol == false) {\\n                                                throw new SqlToolError((dsvSkipCols == null)\\n                    ? rb.getString(SqltoolRB.DSV_NOCOLSLEFT)\\n                    : (rb.getString(SqltoolRB.DSV_NOCOLSLEFT_WSK,\\n                            new String[] {dsvSkipCols}))\\n            );\\n        }\\n        if (constColMap != null) {\\n            headerList.addAll(constColMap.keySet());\\n        }\\n        String[]  headers   = (String[]) headerList.toArray(new String[0]);\\n        if (tableName == null) {\\n            tableName = file.getName();\\n            int i = tableName.lastIndexOf('.');\\n            if (i > 0) {\\n                tableName = tableName.substring(0, i);\\n            }\\n        }\\n        StringBuffer tmpSb = new StringBuffer();\\n        List tmpList = new ArrayList();\\n        int skippers = 0;\\n        for (int i = 0; i < headers.length; i++) {\\n            if (headers[i] == null) {\\n                skippers++;\\n                continue;\\n            }\\n            if (tmpSb.length() > 0) {\\n                tmpSb.append(\\\", \\\");\\n            }\\n            tmpSb.append(headers[i]);\\n            tmpList.add(headers[i]);\\n        }\\n        boolean[] autonulls = new boolean[headers.length - skippers];\\n        boolean[] parseDate = new boolean[autonulls.length];\\n        boolean[] parseBool = new boolean[autonulls.length];\\n        String[] insertFieldName = (String[]) tmpList.toArray(new String[] {});\\n        StringBuffer sb = new StringBuffer(\\\"INSERT INTO \\\" + tableName + \\\" (\\\"\\n                                           + tmpSb + \\\") VALUES (\\\");\\n        StringBuffer typeQuerySb = new StringBuffer(\\\"SELECT \\\" + tmpSb\\n            + \\\" FROM \\\" + tableName + \\\" WHERE 1 = 2\\\");\\n        try {\\n            ResultSetMetaData rsmd = curConn.createStatement().executeQuery(\\n                typeQuerySb.toString()).getMetaData();\\n            if (rsmd.getColumnCount() != autonulls.length) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.DSV_METADATA_MISMATCH));\\n                                                                                            }\\n            for (int i = 0; i < autonulls.length; i++) {\\n                autonulls[i] = true;\\n                parseDate[i] = false;\\n                parseBool[i] = false;\\n                switch(rsmd.getColumnType(i + 1)) {\\n                    case java.sql.Types.BOOLEAN:\\n                        parseBool[i] = true;\\n                        break;\\n                    case java.sql.Types.VARBINARY :\\n                    case java.sql.Types.VARCHAR :\\n                    case java.sql.Types.ARRAY :\\n                                            case java.sql.Types.BLOB :\\n                    case java.sql.Types.CLOB :\\n                    case java.sql.Types.LONGVARBINARY :\\n                    case java.sql.Types.LONGVARCHAR :\\n                        autonulls[i] = false;\\n                                                                                                break;\\n                    case java.sql.Types.DATE:\\n                    case java.sql.Types.TIME:\\n                    case java.sql.Types.TIMESTAMP:\\n                        parseDate[i] = true;\\n                }\\n            }\\n        } catch (SQLException se) {\\n            throw new SqlToolError(rb.getString(\\n                    SqltoolRB.QUERY_METADATAFAIL, new String[] {\\n                            typeQuerySb.toString()}), se);\\n        }\\n        for (int i = 0; i < autonulls.length; i++) {\\n            if (i > 0) {\\n                sb.append(\\\", \\\");\\n            }\\n            sb.append('?');\\n        }\\n                int rejectCount = 0;\\n        File rejectFile = null;\\n        File rejectReportFile = null;\\n        PrintWriter rejectWriter = null;\\n        PrintWriter rejectReportWriter = null;\\n        if (dsvRejectFile != null) try {\\n            rejectFile = new File(dsvRejectFile);\\n            rejectWriter = new PrintWriter((charset == null)\\n                    ? (new OutputStreamWriter(new FileOutputStream(rejectFile)))\\n                    : (new OutputStreamWriter(new FileOutputStream(rejectFile),\\n                            charset)));\\n                                                                        rejectWriter.print(headerLine + dsvRowDelim);\\n        } catch (IOException ioe) {\\n            throw new SqlToolError(rb.getString(\\n                    SqltoolRB.DSV_REJECTFILE_SETUPFAIL, new String[] {\\n                            dsvRejectFile\\n                    }), ioe);\\n        }\\n        if (dsvRejectReport != null) try {\\n            rejectReportFile = new File(dsvRejectReport);\\n            rejectReportWriter = new PrintWriter((charset == null)\\n                    ? (new OutputStreamWriter(\\n                            new FileOutputStream(rejectReportFile)))\\n                    : (new OutputStreamWriter(\\n                            new FileOutputStream(rejectReportFile), charset)));\\n                                                                        rejectReportWriter.println(rb.getString(\\n                    SqltoolRB.REJECTREPORT_TOP, new String[] {\\n                        (new java.util.Date()).toString(),\\n                        file.getPath(),\\n                        ((rejectFile == null) ? rb.getString(SqltoolRB.NONE)\\n                                        : rejectFile.getPath()),\\n                        ((rejectFile == null)\\n                                ? rb.getString(SqltoolRB.BLOCK_DISABLED)\\n                                : \\\"-->\\\"),\\n                        ((rejectFile == null)\\n                                ? rb.getString(SqltoolRB.BLOCK_DISABLED)\\n                                : \\\"<!--\\\"),\\n                    }));\\n        } catch (IOException ioe) {\\n            throw new SqlToolError(rb.getString(\\n                    SqltoolRB.DSV_REJECTREPORT_SETUPFAIL, new String[] {\\n                            dsvRejectReport\\n                    }), ioe);\\n        }\\n        int recCount = 0;\\n        int skipCount = 0;\\n        PreparedStatement ps = null;\\n        boolean importAborted = false;\\n        try {\\n            try {\\n                ps = curConn.prepareStatement(sb.toString() + ')');\\n            } catch (SQLException se) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.INSERTION_PREPAREFAIL, new String[] {\\n                                sb.toString() }), se);\\n            }\\n            String[] dataVals = new String[autonulls.length];\\n                        int      readColCount;\\n            int      storeColCount;\\n            String   currentFieldName = null;\\n                        while (true) try { try {\\n                recStart = recEnd + dsvRowDelim.length();\\n                if (recStart >= string.length()) {\\n                    break;\\n                }\\n                recEnd = string.indexOf(dsvRowDelim, recStart);\\n                lineCount++; \\n                if (recEnd < 0) {\\n                                        recEnd = string.length();\\n                }\\n                trimmedLine = string.substring(recStart, recEnd).trim();\\n                if (trimmedLine.length() < 1) {\\n                    continue;                  }\\n                if (skipPrefix != null\\n                        && trimmedLine.startsWith(skipPrefix)) {\\n                    skipCount++;\\n                    continue;\\n                }\\n                if (switching) {\\n                    if (trimmedLine.equals(\\\"}\\\")) {\\n                        switching = false;\\n                        continue;\\n                    }\\n                    int colonAt = trimmedLine.indexOf(':');\\n                    if (colonAt < 1 || colonAt == trimmedLine.length() - 1) {\\n                        throw new SqlToolError(rb.getString(\\n                                SqltoolRB.DSV_HEADER_MATCHERNONHEAD,\\n                                        new String[] {\\n                                                Integer.toString(lineCount)}));\\n                    }\\n                    continue;\\n                }\\n                                recCount++;\\n                colStart = recStart;\\n                colEnd   = -1;\\n                readColCount = 0;\\n                storeColCount = 0;\\n                while (true) {\\n                    if (colEnd == recEnd) {\\n                                                break;\\n                    }\\n                    colEnd = string.indexOf(dsvColDelim, colStart);\\n                    if (colEnd < 0 || colEnd > recEnd) {\\n                        colEnd = recEnd;\\n                    }\\n                    if (readColCount == headers.length - constColMapSize) {\\n                        throw new RowError(rb.getString(\\n                                SqltoolRB.DSV_COLCOUNT_MISMATCH,\\n                                        new String[] {\\n                                                Integer.toString(headers.length\\n                                                        - constColMapSize),\\n                                                Integer.toString(1 +\\n                                                        readColCount),\\n                                        }));\\n                    }\\n                    if (headers[readColCount++] != null) {\\n                        dataVals[storeColCount++] =\\n                                string.substring(colStart, colEnd);\\n                    }\\n                    colStart             = colEnd + dsvColDelim.length();\\n                }\\n                if (constColMap != null) {\\n                    Iterator it = constColMap.values().iterator();\\n                    while (it.hasNext()) {\\n                        dataVals[storeColCount++] = (String) it.next();\\n                    }\\n                }\\n                if (readColCount != headers.length - constColMapSize) {\\n                    throw new RowError(rb.getString(\\n                            SqltoolRB.DSV_COLCOUNT_MISMATCH,\\n                                    new String[] {\\n                                            Integer.toString(headers.length\\n                                                    - constColMapSize),\\n                                            Integer.toString(1 +\\n                                                    readColCount),\\n                                    }));\\n                }\\n                if (storeColCount != dataVals.length) {\\n                    throw new RowError(rb.getString(\\n                            SqltoolRB.DSV_COLCOUNT_MISMATCH,\\n                                    new String[] {\\n                                            Integer.toString(dataVals.length\\n                                                    - constColMapSize),\\n                                            Integer.toString(storeColCount\\n                                                    - constColMapSize),\\n                                    }));\\n                }\\n                for (int i = 0; i < dataVals.length; i++) {\\n                    currentFieldName = insertFieldName[i];\\n                    if (autonulls[i]) dataVals[i] = dataVals[i].trim();\\n                    if (parseDate[i]) {\\n                        if ((dataVals[i].length() < 1 && autonulls[i])\\n                              || dataVals[i].equals(nullRepToken)) {\\n                            ps.setTimestamp(i + 1, null);\\n                        } else {\\n                            dateString = (dataVals[i].indexOf(':') > 0)\\n                                       ? dataVals[i]\\n                                       : (dataVals[i] + \\\" 0:00:00\\\");\\n                                                                                    try {\\n                                ps.setTimestamp(i + 1,\\n                                        java.sql.Timestamp.valueOf(dateString));\\n                            } catch (IllegalArgumentException iae) {\\n                                throw new RowError(rb.getString(\\n                                        SqltoolRB.TIME_BAD, new String[] {\\n                                                dateString\\n                                        }), iae);\\n                            }\\n                        }\\n                    } else if (parseBool[i]) {\\n                        if ((dataVals[i].length() < 1 && autonulls[i])\\n                              || dataVals[i].equals(nullRepToken)) {\\n                            ps.setNull(i + 1, java.sql.Types.BOOLEAN);\\n                        } else {\\n                            try {\\n                                ps.setBoolean(i + 1, Boolean.valueOf(\\n                                        dataVals[i]).booleanValue());\\n                                                                                            } catch (IllegalArgumentException iae) {\\n                                throw new RowError(rb.getString(\\n                                        SqltoolRB.BOOLEAN_BAD, new String[] {\\n                                                dataVals[i]\\n                                        }), iae);\\n                            }\\n                        }\\n                    } else {\\n                        ps.setString(\\n                            i + 1,\\n                            (((dataVals[i].length() < 1 && autonulls[i])\\n                              || dataVals[i].equals(nullRepToken))\\n                             ? null\\n                             : dataVals[i]));\\n                    }\\n                    currentFieldName = null;\\n                }\\n                retval = ps.executeUpdate();\\n                if (retval != 1) {\\n                    throw new RowError(rb.getString(\\n                            SqltoolRB.INPUTREC_MODIFIED, new String[] {\\n                                    Integer.toString(retval)\\n                            }));\\n                }\\n                possiblyUncommitteds.set(true);\\n            } catch (SQLException se) {\\n                throw new RowError(null, se);\\n            } } catch (RowError re) {\\n                rejectCount++;\\n                if (rejectWriter != null || rejectReportWriter != null) {\\n                    if (rejectWriter != null) {\\n                        rejectWriter.print(string.substring(\\n                                recStart, recEnd) + dsvRowDelim);\\n                    }\\n                    if (rejectReportWriter != null) {\\n                        genRejectReportRecord(rejectReportWriter,\\n                                rejectCount, lineCount,\\n                                currentFieldName, re.getMessage(),\\n                                re.getCause());\\n                    }\\n                } else {\\n                    importAborted = true;\\n                    throw new SqlToolError(((currentFieldName == null)\\n                            ? rb.getString(SqltoolRB.DSV_RECIN_FAIL,\\n                                    new String[] {Integer.toString(lineCount)})\\n                            : rb.getString(SqltoolRB.DSV_RECIN_FAIL_WCOL,\\n                                    new String[] {\\n                                            Integer.toString(lineCount),\\n                                            currentFieldName,\\n                                    }\\n                            )) + ((re.getMessage() == null)\\n                                    ? \\\"\\\" : (\\\"  \\\" + re.getMessage())),\\n                                            re.getCause());\\n                }\\n            }\\n        } finally {\\n            String summaryString = null;\\n            if (recCount > 0) {\\n                summaryString = rb.getString((importAborted\\n                        ? SqltoolRB.DSV_IMPORT_SUMMARY_WABORT\\n                        : SqltoolRB.DSV_IMPORT_SUMMARY),\\n                        new String[] {\\n                                ((skipPrefix == null)\\n                                          ? \\\"\\\" : (\\\"'\\\" + skipPrefix + \\\"'-\\\")),\\n                                Integer.toString(skipCount),\\n                                Integer.toString(rejectCount),\\n                                Integer.toString(recCount - rejectCount),\\n                        });\\n                stdprintln(summaryString);\\n            }\\n            try {\\n                if (recCount > rejectCount && !curConn.getAutoCommit()) {\\n                    stdprintln(rb.getString(SqltoolRB.INSERTIONS_NOTCOMMITTED));\\n                }\\n            } catch (SQLException se) {\\n                stdprintln(rb.getString(SqltoolRB.AUTOCOMMIT_FETCHFAIL));\\n                stdprintln(rb.getString(SqltoolRB.INSERTIONS_NOTCOMMITTED));\\n                                            }\\n            if (rejectWriter != null) {\\n                rejectWriter.flush();\\n                rejectWriter.close();\\n            }\\n            if (rejectReportWriter != null && rejectCount > 0) {\\n                rejectReportWriter.println(rb.getString(\\n                        SqltoolRB.REJECTREPORT_BOTTOM, new String[] {\\n                            summaryString,\\n                            revnum,\\n                        }));\\n                rejectReportWriter.flush();\\n                rejectReportWriter.close();\\n            }\\n            if (rejectCount == 0) {\\n                if (rejectFile != null && rejectFile.exists()\\n                        && !rejectFile.delete())\\n                    errprintln(rb.getString(SqltoolRB.DSV_REJECTFILE_PURGEFAIL,\\n                            new String[] {rejectFile.toString()}));\\n                if (rejectReportFile != null && !rejectReportFile.delete())\\n                    errprintln(rb.getString(\\n                            SqltoolRB.DSV_REJECTREPORT_PURGEFAIL,\\n                            new String[] {rejectFile.toString()}));\\n                            }\\n        }\\n    }\\n    public static void appendLine(StringBuffer sb, String s) {\\n        sb.append(s + LS);\\n    }\\n    static private String[] genWinArgs(String monolithic) {\\n        List list = new ArrayList();\\n        list.add(\\\"cmd.exe\\\");\\n        list.add(\\\"/y\\\");\\n        list.add(\\\"/c\\\");\\n        Matcher m = wincmdPattern.matcher(monolithic);\\n        String[] internalTokens;\\n        while (m.find()) {\\n            for (int i = 1; i <= m.groupCount(); i++) {\\n                if (m.group(i) == null) continue;\\n                if (m.group(i).length() > 1 && m.group(i).charAt(0) == '\\\"') {\\n                    list.add(m.group(i).substring(1, m.group(i).length() - 1));\\n                    continue;\\n                }\\n                internalTokens = m.group(i).split(\\\"\\\\\\\\s+\\\");\\n                for (int j = 0; j < internalTokens.length; j++)\\n                    list.add(internalTokens[j]);\\n            }\\n        }\\n        return (String[]) list.toArray(new String[] {});\\n    }\\n    private void genRejectReportRecord(PrintWriter pw, int rCount,\\n            int lCount, String field, String eMsg, Throwable cause) {\\n        pw.println(rb.getString(SqltoolRB.REJECTREPORT_ROW,\\n                new String[] {\\n                    ((rCount % 2 == 0) ? \\\"even\\\" : \\\"odd\\\") + \\\"row\\\",\\n                    Integer.toString(rCount),\\n                    Integer.toString(lCount),\\n                    ((field == null) ? \\\"&nbsp;\\\" : field),\\n                    (((eMsg == null) ? \\\"\\\" : eMsg)\\n                            + ((eMsg == null || cause == null) ? \\\"\\\" : \\\"<HR/>\\\")\\n                            + ((cause == null) ? \\\"\\\" : (\\n                                    (cause instanceof SQLException\\n                                            && cause.getMessage() != null)\\n                                        ? cause.getMessage()\\n                                        : cause.toString()\\n                                    )\\n                            )\\n                    )\\n                }));\\n    }\\n}\""
            },
            "m9": {
                "content": "From the source code analysis of `SqlFile.java`, we can observe the following:\n\n### Key Observations:\n1. **Dependencies and Imports**:\n   - `SqlFile.java` imports numerous Java standard libraries, including I/O, SQL, and utility packages.\n   - It also references several internal classes like `SqltoolRB`, `AppendableException`, and others that appear to be part of the HSQLDB project.\n\n2. **Relationship with `SqlTool.java`**:\n   - The class `SqlFile` appears to be tightly integrated with `SqlTool.java`. This is evident from the co-change relationship where `SqlTool.java` had a confidence score of 0.72 \u2014 indicating frequent changes together.\n   - `SqlFile` uses resource bundles (`SqltoolRB`) and exceptions (`AppendableException`, `SqlToolError`) that are likely defined or coordinated in `SqlTool.java`.\n\n3. **Functionality**:\n   - `SqlFile` deals with reading and processing SQL files, handling user input, managing variables, executing SQL commands, and providing advanced features like scripting, looping, and conditional execution.\n   - It heavily interacts with the database using JDBC APIs, which suggests dependencies on other utility classes for SQL execution and result handling.\n\n4. **Internal Classes**:\n   - Internal classes like `BooleanBucket`, `QuitNow`, `BreakException`, etc., are defined within `SqlFile.java`. These may have counterparts or be referenced in other parts of the system such as `SqlTool.java`.\n\n---\n\n### Next Steps in CIA:\nTo determine the ripple effect of a change in `SqlFile.java`, we should focus on entities that:\n- Directly depend on `SqlFile`.\n- Are frequently co-changed with it (like `SqlTool.java`).\n- Share conceptual coupling (i.e., semantically related code).\n\n#### Let's proceed with the following steps:\n1. **Check Coupling Dependencies**: We will call `get_coupling_dependencies` between `SqlFile.java` and `SqlTool.java` to see if there are any direct structural dependencies.\n\n2. **Conceptual Coupling**: Use `get_conceptual_coupling` between `SqlFile.java` and key co-changed files (e.g., `SqlTool.java`, `SqltoolRB.java`) to assess semantic similarity.\n\nI'll start by checking coupling dependencies between `SqlFile.java` and `SqlTool.java`.\n\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_4a39ff0c698b4f23abe9d4",
                        "function": {
                            "arguments": "{\"entity1\": \"SqlFile.java\", \"entity2\": \"SqlTool.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m10": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"There are no coupling dependencies between these two entities\"]"
            },
            "m11": {
                "content": "The result indicates that there are **no direct structural coupling dependencies** between `SqlFile.java` and `SqlTool.java`. This suggests that the two classes do not directly reference or depend on each other through standard code-level relationships (e.g., inheritance, method calls, variable usage).\n\nHowever, from the co-change analysis and source code inspection, we know that:\n- `SqlFile.java` uses several classes and exceptions (`AppendableException`, `SqlToolError`, `SqltoolRB`) that are likely tied to `SqlTool.java`.\n- The high co-change confidence (0.72) implies a **semantic or functional dependency**, even if no direct syntactic coupling exists.\n\n### Next Step: Analyze Conceptual Coupling\nTo better understand the relationship between `SqlFile.java` and `SqlTool.java`, we should analyze their **conceptual coupling** \u2014 i.e., whether they share similar semantics or topics in their code, even without direct references.\n\nI will now call `get_conceptual_coupling` between `SqlFile.java` and `SqlTool.java`.\n\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_03afcbd1e19f4c288bef4f",
                        "function": {
                            "arguments": "{\"entity1\": \"SqlFile.java\", \"entity2\": \"SqlTool.java\"}",
                            "name": "get_conceptual_coupling"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m12": {
                "role": "tool",
                "name": "get_conceptual_coupling",
                "content": "\"0.7136133\""
            },
            "m13": {
                "content": "The conceptual coupling similarity score between `SqlFile.java` and `SqlTool.java` is **0.7136**, which indicates a **strong semantic relationship** between the two files.\n\n### Interpretation:\n- Although there are no direct structural dependencies (method calls, inheritance, etc.), the high conceptual coupling suggests that these two classes likely share similar responsibilities, logic, or domain context.\n- This aligns with our earlier observation from co-change data: these files are frequently modified together because they logically collaborate in the system \u2014 even if indirectly.\n\n### Conclusion of CIA So Far:\n1. **Co-Change Relationship**: Strong (confidence = 0.72).\n2. **Structural Coupling**: No direct coupling found.\n3. **Conceptual Coupling**: High similarity (0.7136), indicating shared functionality or domain logic.\n\nThis implies that changes to `SqlFile.java` could **semantically impact** `SqlTool.java`, especially since both appear to be involved in SQL execution, scripting, and error handling within the HSQLDB utility suite.\n\n---\n\n### Recommendation for Synchronization:\nTo ensure consistency:\n- Any change affecting SQL processing logic, script parsing, or error handling in `SqlFile.java` should be reviewed in `SqlTool.java`.\n- Consider synchronizing updates to resource bundles (`SqltoolRB.java`) and shared exceptions like `SqlToolError.java`.\n\nWould you like me to:\n1. Analyze conceptual coupling between `SqlFile.java` and other highly co-changed entities (e.g., `SqltoolRB.java`, `SqlToolError.java`)?\n2. Proceed to analyze the call graph or dependencies of `SqlTool.java`?\n\nLet me know how you'd like to proceed!",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            },
            "m14": {
                "role": "user",
                "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
            },
            "m15": {
                "content": "Title: Diagnosis of starting entity `SqlFile.java`\n\nChange set: [SqlTool.java, SqltoolRB.java, AppendableException.java, SqlToolError.java, BooleanBucket.java, RCData.java, ScriptWriterText.java, SqlToolSprayer.java, ValidatingResourceBundle.java, RefCapablePropertyResourceBundle.java, SharedFields.java, TokenList.java, Token.java, TokenSource.java, DatabaseManagerSwing.java, DatabaseManager.java, TarGenerator.java, TarHeaderFields.java, TarReader.java, TarFileOutputStream.java, TarFileInputStream.java, TarEntrySupplicant.java, SimpleLog.java, PrivateException.java, RB.java, PIFData.java, RowError.java, BadSubst.java, ContinueException.java, BreakException.java, QuitNow.java, FrameworkLogger.java, AuthUtils.java, AuthBeanMultiplexer.java, ToolLogger.java, DbBackup.java, Calculator.java, Atom.java, BadCmdline.java, BadSpecial.java]\n\nDetails:\n1. **SqlTool.java**: Strong co-change confidence (0.72), conceptual coupling score (0.7136). Shares core SQL execution and scripting logic with SqlFile.\n\n2. **SqltoolRB.java**: Used directly in `SqlFile` for resource handling. Likely involved in error messages and internationalization used across both `SqlFile` and `SqlTool`.\n\n3. **AppendableException.java**: Extended by inner classes in `SqlFile`, likely shared exception hierarchy also used in `SqlTool`.\n\n4. **SqlToolError.java**: Used as a custom error type in `SqlFile`. High co-change relationship suggests shared error-handling logic.\n\n5. **BooleanBucket.java**: Defined internally in `SqlFile`, but has external counterparts that may be shared or referenced elsewhere like in `SqlTool`.\n\n6. **RCData.java**: Frequent co-change (support = 6, confidence = 0.166). May represent data structures used in result handling or script processing.\n\n7. **ScriptWriterText.java**: Co-changed infrequently but appears to be related to output generation which aligns with the DSV/SQL output features in `SqlFile`.\n\n8. **SqlToolSprayer.java**: Co-change support = 7 (confidence = 0.194). May relate to command dispatching or dynamic execution features.\n\n9. **ValidatingResourceBundle.java**: Support = 6 (0.166). Resource bundle validation is central to both localization and configuration logic in SQL tools.\n\n10. **RefCapablePropertyResourceBundle.java**: Support = 9 (0.25). Related to advanced resource handling; used alongside `SqltoolRB`.\n\n11. **SharedFields.java**: Support = 2 (0.055). Likely contains constants or shared metadata used across multiple utility classes including `SqlFile`.\n\n12. **TokenList.java**: Support = 2 (0.055). Suggests involvement in parsing or tokenizing SQL scripts\u2014core to `SqlFile`'s functionality.\n\n13. **Token.java**: Support = 3 (0.083). Part of the lexical analysis layer, possibly used in both `SqlFile` and other tool components.\n\n14. **TokenSource.java**: Support = 1 (0.027). Likely an interface or base class for token stream providers.\n\n15. **DatabaseManagerSwing.java**: Support = 1 (0.027). May use `SqlFile` indirectly via UI-driven script execution.\n\n16. **DatabaseManager.java**: Support = 1 (0.027). Core database management component that may invoke SQL files or scripting utilities.\n\n17. **TarGenerator.java**, **TarHeaderFields.java**, **TarReader.java**, **TarFileOutputStream.java**, **TarFileInputStream.java**, **TarEntrySupplicant.java**: These are part of file packaging or archive utilities. Could be used in backup/export operations involving SQL scripts.\n\n18. **SimpleLog.java**: Support = 1 (0.027). Logging infrastructure used across utility classes.\n\n19. **PrivateException.java**: Support = 1 (0.027). Possibly a base class for internal exceptions.\n\n20. **RB.java**: Support = 1 (0.027). Likely another resource bundle utility used in parallel with `SqltoolRB`.\n\n21. **PIFData.java**: Support = 3 (0.083). Possibly related to import/export or persistent intermediate format data.\n\n22. **RowError.java**: Support = 3 (0.083). Used during DSV or SQL result processing\u2014directly handled in `SqlFile`.\n\n23. **BadSubst.java**: Support = 1 (0.027). Thrown during substitution errors\u2014defined in `SqlFile`, likely used in similar contexts elsewhere.\n\n24. **ContinueException.java**, **BreakException.java**, **QuitNow.java**: Used internally in `SqlFile` for control flow in scripting mode. Likely shared with `SqlTool` or other script interpreters.\n\n25. **FrameworkLogger.java**, **AuthUtils.java**, **AuthBeanMultiplexer.java**, **ToolLogger.java**: Infrastructure classes potentially used for logging, authentication, and integration with larger systems.\n\n26. **DbBackup.java**: Support = 2 (0.055). May involve SQL script execution or file reading, hence co-change likelihood.\n\n27. **Calculator.java**, **Atom.java**: Possibly used in expression evaluation during scripting.\n\n28. **BadCmdline.java**: Support = 2 (0.055). Related to command-line parsing, a shared concern in CLI-based SQL tools.\n\n29. **CSVWriter.java**, **MainInvoker.java**, **BadSpecial.java**, etc.: Additional classes with low co-change support but semantically relevant roles in SQL scripting or file handling.\n\nThese entities were selected based on co-change history, conceptual similarity, semantic relevance, and inferred functional dependencies. All changes impacting SQL parsing, scripting, result handling, or resource management in `SqlFile.java` should consider synchronizing changes in these files to avoid inconsistencies.",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            }
        }
    }
}