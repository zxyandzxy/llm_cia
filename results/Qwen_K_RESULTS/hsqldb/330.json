{
    "time": 1749472860.4460196,
    "messages": [
        {
            "role": "system",
            "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
        },
        {
            "role": "user",
            "content": "The project you need to analyze is `hsqldb`, a well-known Java open source project. The starting entity you need to deal with is SqlFile.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
        },
        {
            "content": "",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_f8631c829c9a44b2adc468",
                    "function": {
                        "arguments": "{\"entity\": \"SqlFile.java\"}",
                        "name": "get_co_change_relationship"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "name": "get_co_change_relationship",
            "role": "tool",
            "content": "[[\"RCData\", \"6\", \"0.16666666666666666\"], [\"AppendableException\", \"4\", \"0.1111111111111111\"], [\"SqlToolSprayer\", \"7\", \"0.19444444444444445\"], [\"BooleanBucket\", \"2\", \"0.05555555555555555\"], [\"SqlToolException\", \"2\", \"0.05555555555555555\"], [\"BadCmdline\", \"2\", \"0.05555555555555555\"], [\"ContinueException\", \"1\", \"0.027777777777777776\"], [\"BreakException\", \"1\", \"0.027777777777777776\"], [\"QuitNow\", \"1\", \"0.027777777777777776\"], [\"SqlToolError\", \"4\", \"0.1111111111111111\"], [\"ScriptWriterText\", \"1\", \"0.027777777777777776\"], [\"SqlTool\", \"26\", \"0.7222222222222222\"], [\"CSVWriter\", \"1\", \"0.027777777777777776\"], [\"MainInvoker\", \"1\", \"0.027777777777777776\"], [\"RowError\", \"3\", \"0.08333333333333333\"], [\"BadSpecial\", \"2\", \"0.05555555555555555\"], [\"BadSubst\", \"1\", \"0.027777777777777776\"], [\"ValidatingResourceBundle\", \"6\", \"0.16666666666666666\"], [\"RefCapablePropertyResourceBundle\", \"9\", \"0.25\"], [\"SqltoolRB\", \"13\", \"0.3611111111111111\"], [\"DatabaseManagerSwing\", \"1\", \"0.027777777777777776\"], [\"SqlFileScanner\", \"4\", \"0.1111111111111111\"], [\"DatabaseManager\", \"1\", \"0.027777777777777776\"], [\"SharedFields\", \"2\", \"0.05555555555555555\"], [\"SimpleLog\", \"1\", \"0.027777777777777776\"], [\"PrivateException\", \"1\", \"0.027777777777777776\"], [\"RB\", \"1\", \"0.027777777777777776\"], [\"TokenList\", \"2\", \"0.05555555555555555\"], [\"TarGenerator\", \"1\", \"0.027777777777777776\"], [\"TarHeaderFields\", \"1\", \"0.027777777777777776\"], [\"PIFData\", \"3\", \"0.08333333333333333\"], [\"TarFileOutputStream\", \"1\", \"0.027777777777777776\"], [\"TarFileInputStream\", \"1\", \"0.027777777777777776\"], [\"TarEntrySupplicant\", \"1\", \"0.027777777777777776\"], [\"DbBackup\", \"2\", \"0.05555555555555555\"], [\"TarReader\", \"1\", \"0.027777777777777776\"], [\"Token\", \"3\", \"0.08333333333333333\"], [\"TokenSource\", \"1\", \"0.027777777777777776\"], [\"Calculator\", \"1\", \"0.027777777777777776\"], [\"Atom\", \"1\", \"0.027777777777777776\"], [\"FrameworkLogger\", \"1\", \"0.027777777777777776\"], [\"AuthUtils\", \"1\", \"0.027777777777777776\"], [\"AuthBeanMultiplexer\", \"1\", \"0.027777777777777776\"], [\"ToolLogger\", \"1\", \"0.027777777777777776\"]]"
        },
        {
            "content": "From the co-change relationship results, we can observe that certain entities have a higher confidence value, indicating they are frequently modified together with `SqlFile.java`. These entities are more likely to be impacted by changes in `SqlFile.java` and should be considered for synchronization. Here's an interpretation of the results:\n\n### High Confidence Co-Changes (> 0.25):\n1. **SqltoolRB** - Confidence: `0.3611`\n   - This appears to be a resource bundle related to SQL tools, possibly handling localized strings or configurations. Changes in `SqlFile.java` might affect this file due to shared logic or configuration.\n\n2. **RefCapablePropertyResourceBundle** - Confidence: `0.25`\n   - Another resource bundle entity, potentially used for property management alongside `SqltoolRB`.\n\n### Moderate Confidence Co-Changes (Between 0.1 and 0.25):\n1. **SqlTool** - Confidence: `0.7222`\n   - A very high support count (`26`) suggests a strong dependency. This is likely a core class interacting directly with `SqlFile.java`.\n\n2. **RCData** & **ValidatingResourceBundle** - Confidence: `0.1667`\n   - These could be related to data handling or validation logic tied to `SqlFile.java`.\n\n3. **SqlToolSprayer** - Confidence: `0.1944`\n   - Possibly involved in distributing or applying SQL tool functionalities across files.\n\n4. **SqlFileScanner** - Confidence: `0.1111`\n   - Likely involved in scanning or parsing SQL files; directly related to `SqlFile.java`.\n\n### Recommended Entities to Investigate Further:\nGiven the above analysis, the most relevant entities to synchronize or examine further are:\n- `SqlFile.java` (starting point)\n- `SqltoolRB.java`\n- `SqlTool.java`\n- `SqlToolSprayer.java`\n- `SqlFileScanner.java`\n\nNext, let's analyze the coupling dependencies between `SqlFile.java` and these key entities to understand their structural relationships. I will start with `SqlTool.java`, as it has the highest confidence among co-changes.\n\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_28e7c932e2da4afaac74a6",
                    "function": {
                        "arguments": "{\"entity1\": \"SqlFile.java\", \"entity2\": \"SqlTool.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"There are no coupling dependencies between these two entities\"]"
        },
        {
            "content": "The result indicates that there is no direct structural coupling between `SqlFile.java` and `SqlTool.java`. This suggests that the co-change relationship might be due to functional or behavioral dependencies rather than direct code-level dependencies.\n\nNext, let's examine the coupling dependencies between `SqlFile.java` and `SqlFileScanner.java`, as this entity is likely involved in parsing or scanning SQL files and may have a more direct relationship with `SqlFile.java`.\n\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_3526da5914e3403f96411b",
                    "function": {
                        "arguments": "{\"entity1\": \"SqlFile.java\", \"entity2\": \"SqlFileScanner.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"SqlFileScanner has been removed from the project due to project version iteration\"]"
        },
        {
            "content": "It appears that `SqlFileScanner.java` has been removed from the project due to version updates, which explains the lack of coupling information. This suggests that the functionality previously handled by `SqlFileScanner.java` may have been moved or integrated elsewhere, possibly within `SqlFile.java` itself or another entity.\n\nLet\u2019s now check the coupling dependencies between `SqlFile.java` and `SqltoolRB.java`, which showed a relatively high confidence in co-change relationships. This will help us understand if there is any structural dependency between them.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_1d1be26758a045f983872d",
                    "function": {
                        "arguments": "{\"entity1\": \"SqlFile.java\", \"entity2\": \"SqltoolRB.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"StaticVariableInvoking(SAI): Static Variable Invoking found: execute invokes static variable SQLFILE_BANNER,  Static Variable Invoking found: execute invokes static variable RAW_EMPTY,  Static Variable Invoking found: execute invokes static variable RAW_MOVEDTOBUFFER,  Static Variable Invoking found: execute invokes static variable INPUT_MOVEDTOBUFFER,  Static Variable Invoking found: execute invokes static variable SQLSTATEMENT_EMPTY,  Static Variable Invoking found: execute invokes static variable ERRORAT,  Static Variable Invoking found: execute invokes static variable CAUSEREPORT,  Static Variable Invoking found: execute invokes static variable ERRORAT,  Static Variable Invoking found: execute invokes static variable BREAK_UNSATISFIED,  Static Variable Invoking found: execute invokes static variable CONTINUE_UNSATISFIED,  Static Variable Invoking found: execute invokes static variable ERRORAT,  Static Variable Invoking found: execute invokes static variable CAUSEREPORT,  Static Variable Invoking found: execute invokes static variable INPUT_UNTERMINATED,  Static Variable Invoking found: execute invokes static variable INPUT_UNTERMINATED,  Static Variable Invoking found: execute invokes static variable PRIMARYINPUT_ACCESSFAIL,  Static Variable Invoking found: execute invokes static variable ABORTING,  Static Variable Invoking found: execute invokes static variable PLVAR_SET_INCOMPLETE,  Static Variable Invoking found: execute invokes static variable INPUTREADER_CLOSEFAIL,  Static Variable Invoking found: execute invokes static variable ROLLINGBACK,  Static Variable Invoking found: processBuffHist invokes static variable BUFHIST_UNSPECIFIED,  Static Variable Invoking found: processBuffHist invokes static variable NOBUFFER_YET,  Static Variable Invoking found: processBuffHist invokes static variable BUFFER_EXECUTING,  Static Variable Invoking found: processBuffHist invokes static variable NOBUFFER_YET,  Static Variable Invoking found: processBuffHist invokes static variable BUFFER_EXECUTING,  Static Variable Invoking found: processBuffHist invokes static variable EDITBUFFER_CONTENTS,  Static Variable Invoking found: processBuffHist invokes static variable COMMANDNUM_MALFORMAT,  Static Variable Invoking found: processBuffHist invokes static variable BUFFER_EXECUTING,  Static Variable Invoking found: processBuffHist invokes static variable BUFFER_RESTORED,  Static Variable Invoking found: processBuffHist invokes static variable DESTFILE_DEMAND,  Static Variable Invoking found: processBuffHist invokes static variable BUFFER_EMPTY,  Static Variable Invoking found: processBuffHist invokes static variable FILE_APPENDFAIL,  Static Variable Invoking found: processBuffHist invokes static variable SUBSTITUTION_MALFORMAT,  Static Variable Invoking found: processBuffHist invokes static variable SUBSTITUTION_MALFORMAT,  Static Variable Invoking found: processBuffHist invokes static variable SUBSTITUTION_NOMATCH,  Static Variable Invoking found: processBuffHist invokes static variable BUFFER_EXECUTING,  Static Variable Invoking found: processBuffHist invokes static variable EDITBUFFER_CONTENTS,  Static Variable Invoking found: processBuffHist invokes static variable SUBSTITUTION_SYNTAX,  Static Variable Invoking found: processBuffHist invokes static variable SUBSTITUTION_SYNTAX,  Static Variable Invoking found: processBuffHist invokes static variable BUFFER_HELP,  Static Variable Invoking found: processBuffHist invokes static variable BUFFER_UNKNOWN,  Static Variable Invoking found: enforce1charSpecial invokes static variable SPECIAL_EXTRACHARS,  Static Variable Invoking found: enforce1charBH invokes static variable BUFFER_EXTRACHARS,  Static Variable Invoking found: processSpecial invokes static variable SPECIAL_UNSPECIFIED,  Static Variable Invoking found: processSpecial invokes static variable SPECIAL_MALFORMAT,  Static Variable Invoking found: processSpecial invokes static variable HTML_MODE,  Static Variable Invoking found: processSpecial invokes static variable DSV_TARGETFILE_DEMAND,  Static Variable Invoking found: processSpecial invokes static variable DSV_NOCOLSLEFT,  Static Variable Invoking found: processSpecial invokes static variable DSV_SKIPCOLS_MISSING,  Static Variable Invoking found: processSpecial invokes static variable FILE_WROTECHARS,  Static Variable Invoking found: processSpecial invokes static variable FILE_WRITEFAIL,  Static Variable Invoking found: processSpecial invokes static variable FILE_WRITEFAIL,  Static Variable Invoking found: processSpecial invokes static variable METADATA_FETCH_FAIL,  Static Variable Invoking found: processSpecial invokes static variable SPECIAL_D_LIKE,  Static Variable Invoking found: processSpecial invokes static variable OUTPUTFILE_NONETOCLOSE,  Static Variable Invoking found: processSpecial invokes static variable OUTPUTFILE_REOPENING,  Static Variable Invoking found: processSpecial invokes static variable OUTPUTFILE_HEADER,  Static Variable Invoking found: processSpecial invokes static variable FILE_WRITEFAIL,  Static Variable Invoking found: processSpecial invokes static variable SQLFILE_NAME_DEMAND,  Static Variable Invoking found: processSpecial invokes static variable SQLFILE_EXECUTE_FAIL,  Static Variable Invoking found: processSpecial invokes static variable A_SETTING,  Static Variable Invoking found: processSpecial invokes static variable COMMITTED,  Static Variable Invoking found: processSpecial invokes static variable SPECIAL_B_MALFORMAT,  Static Variable Invoking found: processSpecial invokes static variable SPECIAL_B_MALFORMAT,  Static Variable Invoking found: processSpecial invokes static variable SPECIAL_B_MALFORMAT,  Static Variable Invoking found: processSpecial invokes static variable BINARY_LOADEDBYTESINTO,  Static Variable Invoking found: processSpecial invokes static variable BINARY_FILEFAIL,  Static Variable Invoking found: processSpecial invokes static variable C_SETTING,  Static Variable Invoking found: processSpecial invokes static variable SPECIAL_HELP,  Static Variable Invoking found: processSpecial invokes static variable BANG_INCOMPLETE,  Static Variable Invoking found: processSpecial invokes static variable BANG_COMMAND_FAIL,  Static Variable Invoking found: processSpecial invokes static variable BANG_COMMAND_FAIL,  Static Variable Invoking found: processSpecial invokes static variable SPECIAL_UNKNOWN,  Static Variable Invoking found: dereference invokes static variable PLALIAS_MALFORMAT,  Static Variable Invoking found: dereference invokes static variable PLVAR_UNDEFINED,  Static Variable Invoking found: dereference invokes static variable SYSPROP_EMPTY,  Static Variable Invoking found: dereference invokes static variable SYSPROP_UNTERMINATED,  Static Variable Invoking found: dereference invokes static variable VAR_INFINITE,  Static Variable Invoking found: dereference invokes static variable SYSPROP_UNDEFINED,  Static Variable Invoking found: dereference invokes static variable PLVAR_NAMEEMPTY,  Static Variable Invoking found: dereference invokes static variable PLVAR_UNTERMINATED,  Static Variable Invoking found: dereference invokes static variable VAR_INFINITE,  Static Variable Invoking found: dereference invokes static variable PLVAR_UNDEFINED,  Static Variable Invoking found: processPL invokes static variable PL_MALFORMAT,  Static Variable Invoking found: processPL invokes static variable PL_EXPANSIONMODE,  Static Variable Invoking found: processPL invokes static variable PL_HELP,  Static Variable Invoking found: processPL invokes static variable END_NOBLOCK,  Static Variable Invoking found: processPL invokes static variable CONTINUE_SYNTAX,  Static Variable Invoking found: processPL invokes static variable BREAK_SYNTAX,  Static Variable Invoking found: processPL invokes static variable PL_LIST_PARENS,  Static Variable Invoking found: processPL invokes static variable PL_LIST_LENGTHS,  Static Variable Invoking found: processPL invokes static variable DUMPLOAD_MALFORMAT,  Static Variable Invoking found: processPL invokes static variable PLVAR_NOCOLON,  Static Variable Invoking found: processPL invokes static variable DUMPLOAD_FAIL,  Static Variable Invoking found: processPL invokes static variable PREPARE_MALFORMAT,  Static Variable Invoking found: processPL invokes static variable PLVAR_UNDEFINED,  Static Variable Invoking found: processPL invokes static variable FOREACH_MALFORMAT,  Static Variable Invoking found: processPL invokes static variable PLVAR_NOCOLON,  Static Variable Invoking found: processPL invokes static variable PL_TEMPFILE_FAIL,  Static Variable Invoking found: processPL invokes static variable PL_BLOCK_FAIL,  Static Variable Invoking found: processPL invokes static variable TEMPFILE_REMOVAL_FAIL,  Static Variable Invoking found: processPL invokes static variable IFWHILE_MALFORMAT,  Static Variable Invoking found: processPL invokes static variable PL_BLOCK_FAIL,  Static Variable Invoking found: processPL invokes static variable IF_MALFORMAT,  Static Variable Invoking found: processPL invokes static variable PL_BLOCK_FAIL,  Static Variable Invoking found: processPL invokes static variable PL_TEMPFILE_FAIL,  Static Variable Invoking found: processPL invokes static variable WHILE_MALFORMAT,  Static Variable Invoking found: processPL invokes static variable PL_BLOCK_FAIL,  Static Variable Invoking found: processPL invokes static variable PL_UNKNOWN,  Static Variable Invoking found: processPL invokes static variable TEMPFILE_REMOVAL_FAIL,  Static Variable Invoking found: processPL invokes static variable PL_UNKNOWN,  Static Variable Invoking found: processPL invokes static variable PLVAR_NOCOLON,  Static Variable Invoking found: processPL invokes static variable PLVAR_TILDEDASH_NOMOREARGS,  Static Variable Invoking found: processPL invokes static variable PL_UNKNOWN,  Static Variable Invoking found: plBlockFile invokes static variable PL_BLOCK_UNTERMINATED,  Static Variable Invoking found: plBlockFile invokes static variable END_SYNTAX,  Static Variable Invoking found: plBlockFile invokes static variable END_SYNTAX,  Static Variable Invoking found: listTables invokes static variable VENDOR_ORACLE_DS,  Static Variable Invoking found: listTables invokes static variable VENDOR_DERBY_DR,  Static Variable Invoking found: listTables invokes static variable VENDOR_NOSUP_D,  Static Variable Invoking found: listTables invokes static variable VENDOR_DERBY_DU,  Static Variable Invoking found: listTables invokes static variable VENDOR_NOSUP_D,  Static Variable Invoking found: listTables invokes static variable SPECIAL_D_UNKNOWN,  Static Variable Invoking found: listTables invokes static variable METADATA_FETCH_FAIL,  Static Variable Invoking found: listTables invokes static variable METADATA_FETCH_FAILFOR,  Static Variable Invoking found: listTables invokes static variable METADATA_FETCH_FAIL,  Static Variable Invoking found: listTables invokes static variable METADATA_FETCH_FAIL,  Static Variable Invoking found: processSQL invokes static variable PREPARE_DEMANDQM,  Static Variable Invoking found: processSQL invokes static variable BINBUFFER_EMPTY,  Static Variable Invoking found: processSQL invokes static variable PLVAR_UNDEFINED,  Static Variable Invoking found: displayResultSet invokes static variable VENDOR_NOSUP_SYSSCHEMAS,  Static Variable Invoking found: displayResultSet invokes static variable NORESULT,  Static Variable Invoking found: displayResultSet invokes static variable DSV_BINCOL,  Static Variable Invoking found: displayResultSet invokes static variable BINBUF_WRITE,  Static Variable Invoking found: displayResultSet invokes static variable ROWS_FETCHED,  Static Variable Invoking found: displayResultSet invokes static variable ROWS_FETCHED_DSV,  Static Variable Invoking found: displayResultSet invokes static variable ROW_UPDATE_SINGULAR,  Static Variable Invoking found: displayResultSet invokes static variable ROW_UPDATE_MULTIPLE,  Static Variable Invoking found: showHistory invokes static variable HISTORY_UNAVAILABLE,  Static Variable Invoking found: showHistory invokes static variable HISTORY_NONE,  Static Variable Invoking found: showHistory invokes static variable EDITBUFFER_CONTENTS,  Static Variable Invoking found: showHistory invokes static variable BUFFER_INSTRUCTIONS,  Static Variable Invoking found: commandFromHistory invokes static variable HISTORY_UNAVAILABLE,  Static Variable Invoking found: commandFromHistory invokes static variable HISTORY_NUMBER_REQ,  Static Variable Invoking found: commandFromHistory invokes static variable HISTORY_BACKTO,  Static Variable Invoking found: commandFromHistory invokes static variable HISTORY_UPTO,  Static Variable Invoking found: commandFromHistory invokes static variable HISTORY_BACK,  Static Variable Invoking found: describe invokes static variable DESCRIBE_TABLE_NAME,  Static Variable Invoking found: describe invokes static variable DESCRIBE_TABLE_DATATYPE,  Static Variable Invoking found: describe invokes static variable DESCRIBE_TABLE_WIDTH,  Static Variable Invoking found: describe invokes static variable DESCRIBE_TABLE_NONULLS,  Static Variable Invoking found: eval invokes static variable LOGICAL_UNRECOGNIZED,  Static Variable Invoking found: formatNicely invokes static variable PL_LIST_PARENS,  Static Variable Invoking found: formatNicely invokes static variable PL_LIST_LENGTHS,  Static Variable Invoking found: dump invokes static variable PLVAR_UNDEFINED,  Static Variable Invoking found: dump invokes static variable FILE_WROTECHARS,  Static Variable Invoking found: dump invokes static variable BINBUFFER_EMPTY,  Static Variable Invoking found: dump invokes static variable FILE_WROTECHARS,  Static Variable Invoking found: streamToString invokes static variable READ_TOOBIG,  Static Variable Invoking found: streamToString invokes static variable READ_PARTIAL,  Static Variable Invoking found: streamToString invokes static variable READ_CONVERTFAIL,  Static Variable Invoking found: dsvSafe invokes static variable DSV_COLDELIM_PRESENT,  Static Variable Invoking found: dsvSafe invokes static variable DSV_ROWDELIM_PRESENT,  Static Variable Invoking found: dsvSafe invokes static variable DSV_NULLREP_PRESENT,  Static Variable Invoking found: importDsv invokes static variable DSV_CONSTCOLS_NULLCOL,  Static Variable Invoking found: importDsv invokes static variable FILE_READFAIL,  Static Variable Invoking found: importDsv invokes static variable READ_TOOBIG,  Static Variable Invoking found: importDsv invokes static variable INPUTFILE_CLOSEFAIL,  Static Variable Invoking found: importDsv invokes static variable READ_PARTIAL,  Static Variable Invoking found: importDsv invokes static variable READ_CONVERTFAIL,  Static Variable Invoking found: importDsv invokes static variable DSV_HEADER_NONE,  Static Variable Invoking found: importDsv invokes static variable DSV_HEADER_NOSWITCHTARG,  Static Variable Invoking found: importDsv invokes static variable DSV_HEADER_NOSWITCHMATCH,  Static Variable Invoking found: importDsv invokes static variable DSV_HEADER_NONSWITCHED,  Static Variable Invoking found: importDsv invokes static variable DSV_NOCOLHEADER,  Static Variable Invoking found: importDsv invokes static variable DSV_SKIPCOLS_MISSING,  Static Variable Invoking found: importDsv invokes static variable DSV_NOCOLSLEFT,  Static Variable Invoking found: importDsv invokes static variable DSV_METADATA_MISMATCH,  Static Variable Invoking found: importDsv invokes static variable QUERY_METADATAFAIL,  Static Variable Invoking found: importDsv invokes static variable DSV_REJECTFILE_SETUPFAIL,  Static Variable Invoking found: importDsv invokes static variable REJECTREPORT_TOP,  Static Variable Invoking found: importDsv invokes static variable NONE,  Static Variable Invoking found: importDsv invokes static variable DSV_REJECTREPORT_SETUPFAIL,  Static Variable Invoking found: importDsv invokes static variable INSERTION_PREPAREFAIL,  Static Variable Invoking found: importDsv invokes static variable DSV_HEADER_MATCHERNONHEAD,  Static Variable Invoking found: importDsv invokes static variable DSV_COLCOUNT_MISMATCH,  Static Variable Invoking found: importDsv invokes static variable DSV_COLCOUNT_MISMATCH,  Static Variable Invoking found: importDsv invokes static variable DSV_INSERTCOL_MISMATCH,  Static Variable Invoking found: importDsv invokes static variable TIME_BAD,  Static Variable Invoking found: importDsv invokes static variable BOOLEAN_BAD,  Static Variable Invoking found: importDsv invokes static variable INPUTREC_MODIFIED,  Static Variable Invoking found: importDsv invokes static variable DSV_RECIN_FAIL,  Static Variable Invoking found: importDsv invokes static variable DSV_IMPORT_SUMMARY,  Static Variable Invoking found: importDsv invokes static variable INSERTIONS_NOTCOMMITTED,  Static Variable Invoking found: importDsv invokes static variable AUTOCOMMIT_FETCHFAIL,  Static Variable Invoking found: importDsv invokes static variable INSERTIONS_NOTCOMMITTED,  Static Variable Invoking found: importDsv invokes static variable REJECTREPORT_BOTTOM,  Static Variable Invoking found: importDsv invokes static variable DSV_REJECTFILE_PURGEFAIL,  Static Variable Invoking found: importDsv invokes static variable DSV_REJECTREPORT_PURGEFAIL,  Static Variable Invoking found: genRejectReportRecord invokes static variable REJECTREPORT_ROW,  \", \"ConstructorInvoking(CMI): Construction Method Invoking found: new SqltoolRB(),  \", \"ConstructorInvoking(CMAIM): Coupling found in method execute, at line: 448. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 506. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 517. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 598. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 623. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 639. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 649. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 658. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 684. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 697. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 707. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 719. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 731. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 733. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 740. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 751. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 760. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 768. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 773. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 949. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 964. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 966. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 973. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 990. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1009. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1042. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1047. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1051. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1058. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1063. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1083. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1097. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1106. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1139. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1145. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1150. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1153. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1164. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1169. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method enforce1charSpecial, at line: 1186. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method enforce1charBH, at line: 1193. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1211. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1216. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1242. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1294. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1330. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1334. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1345. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1349. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1352. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1390. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1394. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1399. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1409. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1430. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1436. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1445. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1471. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1494. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1502. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1509. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1519. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1529. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1540. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1547. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1561. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1567. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1592. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1623. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1629. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1646. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dereference, at line: 1697. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dereference, at line: 1705. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dereference, at line: 1731. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dereference, at line: 1735. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dereference, at line: 1743. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dereference, at line: 1751. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dereference, at line: 1772. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dereference, at line: 1776. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dereference, at line: 1784. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dereference, at line: 1794. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1824. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1830. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1837. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1846. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1856. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1871. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1891. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1893. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1911. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1918. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1929. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1938. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1942. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1956. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1966. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1975. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2019. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2030. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2041. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2058. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2086. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2090. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2097. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2131. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2134. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2139. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2144. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2153. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2164. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2172. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2198. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method plBlockFile, at line: 2253. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method plBlockFile, at line: 2270. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method plBlockFile, at line: 2287. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method listTables, at line: 2513. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method listTables, at line: 2571. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method listTables, at line: 2574. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method listTables, at line: 2612. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method listTables, at line: 2615. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method listTables, at line: 2707. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method listTables, at line: 2733. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method listTables, at line: 2750. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method listTables, at line: 2766. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method listTables, at line: 2769. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSQL, at line: 2816. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSQL, at line: 2827. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSQL, at line: 2838. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method displayResultSet, at line: 2900. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method displayResultSet, at line: 2906. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method displayResultSet, at line: 3084. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method displayResultSet, at line: 3098. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method displayResultSet, at line: 3227. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method displayResultSet, at line: 3268. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method displayResultSet, at line: 3282. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method displayResultSet, at line: 3283. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method showHistory, at line: 3374. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method showHistory, at line: 3377. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method showHistory, at line: 3385. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method showHistory, at line: 3389. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method commandFromHistory, at line: 3399. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method commandFromHistory, at line: 3402. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method commandFromHistory, at line: 3408. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method commandFromHistory, at line: 3412. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method commandFromHistory, at line: 3419. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method describe, at line: 3470. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method describe, at line: 3471. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method describe, at line: 3472. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method describe, at line: 3473. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method eval, at line: 3639. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method formatNicely, at line: 3697. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method formatNicely, at line: 3699. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dump, at line: 3725. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dump, at line: 3754. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dump, at line: 3767. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dump, at line: 3784. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method streamToString, at line: 3801. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method streamToString, at line: 3809. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method streamToString, at line: 3819. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dsvSafe, at line: 4026. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dsvSafe, at line: 4031. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dsvSafe, at line: 4038. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4171. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4187. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4194. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4215. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4220. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4233. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4255. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4279. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4286. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4294. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4325. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4343. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4358. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4416. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4453. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4483. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4496. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4500. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4505. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4519. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4559. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4588. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4600. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4613. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4641. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4656. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4675. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4698. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4708. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4721. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4724. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4725. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4734. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4742. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4745. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method genRejectReportRecord, at line: 4786. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.\"]"
        },
        {
            "content": "The coupling dependencies between `SqlFile.java` and `SqltoolRB.java` reveal a strong functional relationship. Here's the breakdown:\n\n### Coupling Dependency Types:\n1. **Static Variable Invoking (SAI)**:\n   - Numerous static variables from `SqltoolRB.java` are invoked in `SqlFile.java`, especially within methods like `execute`, `processBuffHist`, and `processSpecial`.\n   - These static variables seem to be error messages or string constants used throughout `SqlFile.java`.\n\n2. **Constructor Invoking (CMI)**:\n   - A new instance of `SqltoolRB` is created using its constructor in `SqlFile.java`.\n\n3. **Method Invoking (CMAIM)**:\n   - The `getString()` method of `SqltoolRB` is frequently called across many methods in `SqlFile.java`. This indicates that `SqlFile.java` relies heavily on `SqltoolRB.java` for retrieving localized strings or messages, likely for logging or user feedback.\n\n### Implications:\n- `SqlFile.java` uses `SqltoolRB.java` as a resource bundle to fetch localized or configurable strings.\n- Any change in the structure or content of `SqltoolRB.java` could directly impact the behavior of `SqlFile.java`, especially if string keys or static variables are modified or removed.\n\n### Next Steps:\nSince we've identified a significant dependency between `SqlFile.java` and `SqltoolRB.java`, it would be beneficial to examine the origin code of `SqlFile.java` to understand how these dependencies are utilized in more detail. I will now retrieve the source code of `SqlFile.java` for further analysis.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_76a34ce6520148c1b93a54",
                    "function": {
                        "arguments": "{\"entity\": \"SqlFile.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package org.hsqldb.util;\\nimport java.io.BufferedReader;\\nimport java.io.ByteArrayOutputStream;\\nimport java.io.File;\\nimport java.io.FileInputStream;\\nimport java.io.FileNotFoundException;\\nimport java.io.FileOutputStream;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nimport java.io.InputStreamReader;\\nimport java.io.OutputStreamWriter;\\nimport java.io.PrintStream;\\nimport java.io.PrintWriter;\\nimport java.io.UnsupportedEncodingException;\\nimport java.sql.Connection;\\nimport java.sql.DatabaseMetaData;\\nimport java.sql.PreparedStatement;\\nimport java.sql.ResultSet;\\nimport java.sql.ResultSetMetaData;\\nimport java.sql.SQLException;\\nimport java.sql.Statement;\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.Iterator;\\nimport java.util.List;\\nimport java.util.Set;\\nimport java.util.HashSet;\\nimport java.util.Map;\\nimport java.util.SortedMap;\\nimport java.util.TreeMap;\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\nimport java.util.regex.PatternSyntaxException;\\npublic class SqlFile {\\n    private static final int DEFAULT_HISTORY_SIZE = 40;\\n    private File             file;\\n    private boolean          interactive;\\n    private String           primaryPrompt    = \\\"sql> \\\";\\n    private String           rawPrompt      = null;\\n    private String           contPrompt       = \\\"  +> \\\";\\n    private Connection       curConn          = null;\\n    private boolean          htmlMode         = false;\\n    private Map              userVars;     private List             history          = null;\\n    private int              rawMode          = RAW_FALSE;\\n    private String           nullRepToken     = null;\\n    private String           dsvTargetFile    = null;\\n    private String           dsvTargetTable   = null;\\n    private String           dsvConstCols     = null;\\n    private String           dsvRejectFile    = null;\\n    private String           dsvRejectReport  = null;\\n    public static String     LS = System.getProperty(\\\"line.separator\\\");\\n    private int              maxHistoryLength = 1;\\n    private SqltoolRB        rb               = null;\\n    private static final int RAW_FALSE = 0;     private static final int RAW_EMPTY = 1;     private static final int RAW_DATA  = 2; \\n    private static Pattern   specialPattern =\\n            Pattern.compile(\\\"\\\\\\\\s*\\\\\\\\\\\\\\\\(\\\\\\\\S+)(?:\\\\\\\\s+(.*\\\\\\\\S))?\\\\\\\\s*\\\");\\n    private static Pattern   plPattern  =\\n            Pattern.compile(\\\"\\\\\\\\s*\\\\\\\\*\\\\\\\\s*(.*\\\\\\\\S)?\\\\\\\\s*\\\");\\n    private static Pattern   foreachPattern =\\n            Pattern.compile(\\\"\\\\\\\\s*\\\\\\\\*\\\\\\\\s*foreach\\\\\\\\s+(\\\\\\\\S+)\\\\\\\\s*\\\\\\\\(([^)]*)\\\\\\\\)\\\\\\\\s*\\\");\\n    private static Pattern   ifwhilePattern =\\n            Pattern.compile(\\\"\\\\\\\\s*\\\\\\\\*\\\\\\\\s*\\\\\\\\S+\\\\\\\\s*\\\\\\\\(([^)]*)\\\\\\\\)\\\\\\\\s*\\\");\\n    private static Pattern   varsetPattern =\\n            Pattern.compile(\\\"\\\\\\\\s*\\\\\\\\*\\\\\\\\s*(\\\\\\\\S+)\\\\\\\\s*([=_~])\\\\\\\\s*(?:(.*\\\\\\\\S)\\\\\\\\s*)?\\\");\\n    private static Pattern   substitutionPattern =\\n            Pattern.compile(\\\"\\\\\\\\s*s(\\\\\\\\S)(.+?)\\\\\\\\1(.*?)\\\\\\\\1(.+)?\\\\\\\\s*\\\");\\n                private static Pattern wincmdPattern = null;\\n    static {\\n        if (System.getProperty(\\\"os.name\\\").startsWith(\\\"Windows\\\")) {\\n            wincmdPattern = Pattern.compile(\\\"([^\\\\\\\"]+)?(\\\\\\\"[^\\\\\\\"]*\\\\\\\")?\\\");\\n        }\\n    }\\n    private void updateUserSettings() {\\n        dsvSkipPrefix = SqlFile.convertEscapes(\\n                (String) userVars.get(\\\"*DSV_SKIP_PREFIX\\\"));\\n        if (dsvSkipPrefix == null) {\\n            dsvSkipPrefix = DEFAULT_SKIP_PREFIX;\\n        }\\n        dsvSkipCols = (String) userVars.get(\\\"*DSV_SKIP_COLS\\\");\\n        dsvColDelim =\\n            SqlFile.convertEscapes((String) userVars.get(\\\"*DSV_COL_DELIM\\\"));\\n        if (dsvColDelim == null) {\\n            dsvColDelim =\\n                SqlFile.convertEscapes((String) userVars.get(\\\"*CSV_COL_DELIM\\\"));\\n        }\\n        if (dsvColDelim == null) {\\n            dsvColDelim = DEFAULT_COL_DELIM;\\n        }\\n        dsvRowDelim =\\n            SqlFile.convertEscapes((String) userVars.get(\\\"*DSV_ROW_DELIM\\\"));\\n        if (dsvRowDelim == null) {\\n            dsvRowDelim =\\n                SqlFile.convertEscapes((String) userVars.get(\\\"*CSV_ROW_DELIM\\\"));\\n        }\\n        if (dsvRowDelim == null) {\\n            dsvRowDelim = DEFAULT_ROW_DELIM;\\n        }\\n        dsvTargetFile = (String) userVars.get(\\\"*DSV_TARGET_FILE\\\");\\n        if (dsvTargetFile == null) {\\n            dsvTargetFile = (String) userVars.get(\\\"*CSV_FILEPATH\\\");\\n        }\\n        dsvTargetTable = (String) userVars.get(\\\"*DSV_TARGET_TABLE\\\");\\n        if (dsvTargetTable == null) {\\n            dsvTargetTable = (String) userVars.get(\\\"*CSV_TABLENAME\\\");\\n                    }\\n        dsvConstCols = (String) userVars.get(\\\"*DSV_CONST_COLS\\\");\\n        dsvRejectFile = (String) userVars.get(\\\"*DSV_REJECT_FILE\\\");\\n        dsvRejectReport = (String) userVars.get(\\\"*DSV_REJECT_REPORT\\\");\\n        nullRepToken = (String) userVars.get(\\\"*NULL_REP_TOKEN\\\");\\n        if (nullRepToken == null) {\\n            nullRepToken = (String) userVars.get(\\\"*CSV_NULL_REP\\\");\\n        }\\n        if (nullRepToken == null) {\\n            nullRepToken = DEFAULT_NULL_REP;\\n        }\\n    }\\n    private static class BooleanBucket {\\n        BooleanBucket() {}\\n        private boolean bPriv = false;\\n        public void set(boolean bIn) {\\n            bPriv = bIn;\\n        }\\n        public boolean get() {\\n            return bPriv;\\n        }\\n    }\\n    BooleanBucket possiblyUncommitteds = new BooleanBucket();\\n    private static final String DIVIDER =\\n        \\\"-----------------------------------------------------------------\\\"\\n        + \\\"-----------------------------------------------------------------\\\";\\n        private static final String SPACES =\\n        \\\"                                                                 \\\"\\n        + \\\"                                                                 \\\";\\n        private static String revnum = null;\\n    static {\\n        revnum = \\\"$Revision: 330 $\\\".substring(\\\"$Revision: \\\".length(),\\n                \\\"$Revision: 330 $\\\".length() - 2);\\n    }\\n    private String DSV_OPTIONS_TEXT = null;\\n    private String D_OPTIONS_TEXT = null;\\n    private String RAW_LEADIN_MSG = null;\\n    public SqlFile(File inFile, boolean inInteractive, Map inVars)\\n            throws IOException {\\n                        try {\\n            rb = new SqltoolRB();\\n            rb.validate();\\n            rb.setMissingPosValueBehavior(\\n                    ValidatingResourceBundle.NOOP_BEHAVIOR);\\n            rb.setMissingPropertyBehavior(\\n                    ValidatingResourceBundle.NOOP_BEHAVIOR);\\n        } catch (RuntimeException re) {\\n            System.err.println(\\\"Failed to initialize resource bundle\\\");\\n            throw re;\\n        }\\n        rawPrompt = rb.getString(SqltoolRB.RAWMODE_PROMPT) + \\\"> \\\";\\n        DSV_OPTIONS_TEXT = rb.getString(SqltoolRB.DSV_OPTIONS);\\n        D_OPTIONS_TEXT = rb.getString(SqltoolRB.D_OPTIONS);\\n        RAW_LEADIN_MSG = rb.getString(SqltoolRB.RAW_LEADIN);\\n        DSV_X_SYNTAX_MSG = rb.getString(SqltoolRB.DSV_X_SYNTAX);\\n        DSV_M_SYNTAX_MSG = rb.getString(SqltoolRB.DSV_M_SYNTAX);\\n        nobufferYetString = rb.getString(SqltoolRB.NOBUFFER_YET);\\n        file        = inFile;\\n        interactive = inInteractive;\\n        userVars    = inVars;\\n        if (userVars == null) {\\n            userVars = new HashMap();\\n        }\\n        updateUserSettings();\\n        if (file != null &&!file.canRead()) {\\n            throw new IOException(rb.getString(SqltoolRB.SQLFILE_READFAIL,\\n                    file.toString()));\\n        }\\n        if (interactive) {\\n            history = new ArrayList();\\n            String histLenString = System.getProperty(\\\"sqltool.historyLength\\\");\\n            if (histLenString != null) try {\\n                maxHistoryLength = Integer.parseInt(histLenString);\\n            } catch (Exception e) {\\n            } else {\\n                maxHistoryLength = DEFAULT_HISTORY_SIZE;\\n            }\\n        }\\n    }\\n    public SqlFile(boolean inInteractive, Map inVars) throws IOException {\\n        this(null, inInteractive, inVars);\\n    }\\n    public void execute(Connection conn,\\n                        Boolean coeOverride)\\n                        throws SqlToolError, SQLException {\\n        execute(conn, System.out, System.err, coeOverride);\\n    }\\n    public void execute(Connection conn,\\n                        boolean coeOverride)\\n                        throws SqlToolError, SQLException {\\n        execute(conn, System.out, System.err, new Boolean(coeOverride));\\n    }\\n        public boolean      recursed     = false;\\n    private String      lastSqlStatement   = null;\\n    private int         curLinenum   = -1;\\n    private PrintStream psStd        = null;\\n    private PrintStream psErr        = null;\\n    private PrintWriter pwQuery      = null;\\n    private PrintWriter pwDsv        = null;\\n    StringBuffer        immCmdSB     = new StringBuffer();\\n    private boolean             continueOnError = false;\\n    private static final String DEFAULT_CHARSET = null;\\n        private BufferedReader      br              = null;\\n    private String              charset         = null;\\n    private String              buffer          = null;\\n    private boolean             withholdPrompt  = false;\\n    public synchronized void execute(Connection conn, PrintStream stdIn,\\n                                     PrintStream errIn,\\n                                     Boolean coeOverride)\\n                                     throws SqlToolError,\\n                                         SQLException {\\n        psStd      = stdIn;\\n        psErr      = errIn;\\n        curConn    = conn;\\n        curLinenum = -1;\\n        String  inputLine;\\n        String  trimmedInput;\\n        String  deTerminated;\\n        boolean inComment = false;            int     postCommentIndex;\\n        boolean rollbackUncoms = true;\\n        continueOnError = (coeOverride == null) ? interactive\\n                                                : coeOverride.booleanValue();\\n        if (userVars.size() > 0) {\\n            plMode = true;\\n        }\\n        String specifiedCharSet = System.getProperty(\\\"sqlfile.charset\\\");\\n        charset = ((specifiedCharSet == null) ? DEFAULT_CHARSET\\n                                              : specifiedCharSet);\\n        try {\\n            br = new BufferedReader((charset == null)\\n                    ?  (new InputStreamReader((file == null)\\n                            ? System.in : (new FileInputStream(file))))\\n                    :  (new InputStreamReader(((file == null)\\n                            ? System.in : (new FileInputStream(file))),\\n                                    charset)));\\n                                    curLinenum = 0;\\n            if (interactive) {\\n                stdprintln(rb.getString(SqltoolRB.SQLFILE_BANNER, revnum));\\n            }\\n            while (true) {\\n                if (withholdPrompt) {\\n                    withholdPrompt = false;\\n                } else if (interactive) {\\n                    psStd.print((immCmdSB.length() > 0 || rawMode == RAW_DATA)\\n                            ? contPrompt : ((rawMode == RAW_FALSE)\\n                                    ? primaryPrompt : rawPrompt));\\n                }\\n                inputLine = br.readLine();\\n                if (inputLine == null) {\\n                    if (interactive) {\\n                        psStd.println();\\n                    }\\n                    break;\\n                }\\n                curLinenum++;\\n                if (inComment) {\\n                    postCommentIndex = inputLine.indexOf(\\\"*/\\\") + 2;\\n                    if (postCommentIndex > 1) {\\n                                                inputLine = inputLine.substring(postCommentIndex);\\n                                                                                                immCmdSB.setLength(0);\\n                        inComment = false;\\n                    } else {\\n                                                continue;\\n                    }\\n                }\\n                trimmedInput = inputLine.trim();\\n                try {\\n                    if (rawMode != RAW_FALSE) {\\n                        boolean rawExecute = inputLine.equals(\\\".;\\\");\\n                        if (rawExecute || inputLine.equals(\\\":.\\\")) {\\n                            if (rawMode == RAW_EMPTY) {\\n                                rawMode = RAW_FALSE;\\n                                throw new SqlToolError(\\n                                        rb.getString(SqltoolRB.RAW_EMPTY));\\n                            }\\n                            rawMode = RAW_FALSE;\\n                            setBuf(immCmdSB.toString());\\n                            immCmdSB.setLength(0);\\n                            if (rawExecute) {\\n                                historize();\\n                                processSQL();\\n                            } else if (interactive) {\\n                                stdprintln(rb.getString(\\n                                            SqltoolRB.RAW_MOVEDTOBUFFER));\\n                            }\\n                        } else {\\n                            if (rawMode == RAW_DATA) {\\n                                immCmdSB.append('\\\\n');\\n                            }\\n                            rawMode = RAW_DATA;\\n                            if (inputLine.length() > 0) {\\n                                immCmdSB.append(inputLine);\\n                            }\\n                        }\\n                        continue;\\n                    }\\n                    if (immCmdSB.length() == 0) {\\n                                            if (trimmedInput.startsWith(\\\"\\\", 2)\\n                                               + 2;\\n                            if (postCommentIndex > 1) {\\n                                                                                                inputLine = inputLine.substring(\\n                                    postCommentIndex + inputLine.length()\\n                                    - trimmedInput.length());\\n                                trimmedInput = inputLine.trim();\\n                            } else {\\n                                                                immCmdSB.append(\\\"COMMENT\\\");\\n                                inComment = true;\\n                                continue;\\n                            }\\n                        }\\n                        if (trimmedInput.length() == 0) {\\n                                                                                    continue;\\n                        }\\n                        if ((trimmedInput.charAt(0) == '*'\\n                                && (trimmedInput.length() < 2\\n                                    || trimmedInput.charAt(1) != '{'))\\n                                || trimmedInput.charAt(0) == '\\\\\\\\') {\\n                            setBuf(trimmedInput);\\n                            processFromBuffer();\\n                            continue;\\n                        }\\n                        if (trimmedInput.charAt(0) == ':' && interactive) {\\n                            processBuffHist(trimmedInput.substring(1));\\n                            continue;\\n                        }\\n                        String ucased = trimmedInput.toUpperCase();\\n                        if (ucased.startsWith(\\\"DECLARE\\\")\\n                                || ucased.startsWith(\\\"BEGIN\\\")) {\\n                            rawMode = RAW_EMPTY;\\n                            immCmdSB.append(inputLine);\\n                            if (interactive) {\\n                                stdprintln(RAW_LEADIN_MSG);\\n                            }\\n                            continue;\\n                        }\\n                    }\\n                    if (trimmedInput.length() == 0 && interactive &&!inComment) {\\n                                                                        setBuf(immCmdSB.toString());\\n                        immCmdSB.setLength(0);\\n                        stdprintln(rb.getString(SqltoolRB.INPUT_MOVEDTOBUFFER));\\n                        continue;\\n                    }\\n                    deTerminated = SqlFile.deTerminated(inputLine);\\n                                        if (!trimmedInput.equals(\\\";\\\")) {\\n                        if (immCmdSB.length() > 0) {\\n                            immCmdSB.append('\\\\n');\\n                        }\\n                        immCmdSB.append((deTerminated == null) ? inputLine\\n                                                                   : deTerminated);\\n                    }\\n                    if (deTerminated == null) {\\n                        continue;\\n                    }\\n                    if (immCmdSB.toString().trim().length() == 0) {\\n                        immCmdSB.setLength(0);\\n                        throw new SqlToolError(rb.getString(\\n                                    SqltoolRB.SQLSTATEMENT_EMPTY));\\n                                                                                                                                            }\\n                    setBuf(immCmdSB.toString());\\n                    bufContainsSql = true;\\n                    immCmdSB.setLength(0);\\n                    historize();\\n                    processSQL();\\n                } catch (BadSpecial bs) {\\n                                        errprintln(rb.getString(SqltoolRB.ERRORAT,\\n                            new String[] {\\n                                ((file == null) ? \\\"stdin\\\" : file.toString()),\\n                                Integer.toString(curLinenum),\\n                                inputLine,\\n                                bs.getMessage(),\\n                            }\\n                    ));\\n                    Throwable cause = bs.getCause();\\n                    if (cause != null) {\\n                        errprintln(rb.getString(SqltoolRB.CAUSEREPORT,\\n                                cause.toString()));\\n                    }\\n                    if (!continueOnError) {\\n                        throw new SqlToolError(bs);\\n                    }\\n                } catch (SQLException se) {\\n                    errprintln(\\\"SQL \\\" + rb.getString(SqltoolRB.ERRORAT,\\n                            new String[] {\\n                                ((file == null) ? \\\"stdin\\\" : file.toString()),\\n                                Integer.toString(curLinenum),\\n                                lastSqlStatement,\\n                                se.getMessage(),\\n                            }));\\n                    if (!continueOnError) {\\n                        throw se;\\n                    }\\n                } catch (BreakException be) {\\n                    String msg = be.getMessage();\\n                    if (recursed) {\\n                        rollbackUncoms = false;\\n                                                                                                                    } else if (msg == null || msg.equals(\\\"file\\\")) {\\n                        break;\\n                    } else {\\n                        errprintln(rb.getString(SqltoolRB.BREAK_UNSATISFIED,\\n                                msg));\\n                    }\\n                    if (recursed ||!continueOnError) {\\n                        throw be;\\n                    }\\n                } catch (ContinueException ce) {\\n                    String msg = ce.getMessage();\\n                    if (recursed) {\\n                        rollbackUncoms = false;\\n                    } else {\\n                        errprintln(rb.getString(SqltoolRB.CONTINUE_UNSATISFIED,\\n                                msg));\\n                    }\\n                    if (recursed ||!continueOnError) {\\n                        throw ce;\\n                    }\\n                } catch (QuitNow qn) {\\n                    throw qn;\\n                } catch (SqlToolError ste) {\\n                    errprint(rb.getString(SqltoolRB.ERRORAT,\\n                            new String[] {\\n                                ((file == null) ? \\\"stdin\\\" : file.toString()),\\n                                Integer.toString(curLinenum),\\n                                inputLine,\\n                                ((ste.getMessage() == null)\\n                                        ? \\\"\\\" : ste.getMessage())\\n                            }\\n                    ));\\n                    if (ste.getMessage() != null) errprintln(\\\"\\\");\\n                    Throwable cause = ste.getCause();\\n                    if (cause != null) {\\n                        errprintln(rb.getString(SqltoolRB.CAUSEREPORT,\\n                                cause.toString()));\\n                    }\\n                    if (!continueOnError) {\\n                        throw ste;\\n                    }\\n                }\\n                immCmdSB.setLength(0);\\n            }\\n            if (inComment || immCmdSB.length() != 0) {\\n                errprintln(rb.getString(SqltoolRB.INPUT_UNTERMINATED,\\n                        immCmdSB.toString()));\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.INPUT_UNTERMINATED, immCmdSB.toString()));\\n            }\\n            rollbackUncoms = false;\\n                    } catch (IOException ioe) {\\n            throw new SqlToolError(rb.getString(\\n                    SqltoolRB.PRIMARYINPUT_ACCESSFAIL), ioe);\\n        } catch (QuitNow qn) {\\n            if (recursed) {\\n                throw qn;\\n                                            }\\n            rollbackUncoms = (qn.getMessage() != null);\\n            if (rollbackUncoms) {\\n                errprintln(rb.getString(SqltoolRB.ABORTING, qn.getMessage()));\\n                throw new SqlToolError(qn.getMessage());\\n            }\\n            return;\\n        } finally {\\n            closeQueryOutputStream();\\n            if (fetchingVar != null) {\\n                errprintln(rb.getString(SqltoolRB.PLVAR_SET_INCOMPLETE,\\n                        fetchingVar));\\n                rollbackUncoms = true;\\n            }\\n            if (br != null) try {\\n                br.close();\\n            } catch (IOException ioe) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.INPUTREADER_CLOSEFAIL), ioe);\\n            }\\n            if (rollbackUncoms && possiblyUncommitteds.get()) {\\n                errprintln(rb.getString(SqltoolRB.ROLLINGBACK));\\n                curConn.rollback();\\n                possiblyUncommitteds.set(false);\\n            }\\n        }\\n    }\\n    private static String deTerminated(String inString) {\\n        int index = inString.lastIndexOf(';');\\n        if (index < 0) {\\n            return null;\\n        }\\n        for (int i = index + 1; i < inString.length(); i++) {\\n            if (!Character.isWhitespace(inString.charAt(i))) {\\n                return null;\\n            }\\n        }\\n        return inString.substring(0, index);\\n    }\\n    static private class BadSpecial extends AppendableException {\\n        static final long serialVersionUID = 7162440064026570590L;\\n        BadSpecial(String s) {\\n            super(s);\\n            if (s == null)\\n                throw new RuntimeException(\\n                        \\\"Must construct BadSpecials with non-null message\\\");\\n        }\\n        BadSpecial(String s, Throwable t) {\\n            super(s, t);\\n            if (s == null)\\n                throw new RuntimeException(\\n                        \\\"Must construct BadSpecials with non-null message\\\");\\n        }\\n    }\\n    private class QuitNow extends SqlToolError {\\n        static final long serialVersionUID = 1811094258670900488L;\\n        public QuitNow(String s) {\\n            super(s);\\n        }\\n        public QuitNow() {\\n            super();\\n        }\\n    }\\n    private class BreakException extends SqlToolError {\\n        static final long serialVersionUID = 351150072817675994L;\\n        public BreakException() {\\n            super();\\n        }\\n        public BreakException(String s) {\\n            super(s);\\n        }\\n    }\\n    private class ContinueException extends SqlToolError {\\n        static final long serialVersionUID = 5064604160827106014L;\\n        public ContinueException() {\\n            super();\\n        }\\n        public ContinueException(String s) {\\n            super(s);\\n        }\\n    }\\n    private class BadSubst extends Exception {\\n        static final long serialVersionUID = 7325933736897253269L;\\n        BadSubst(String s) {\\n            super(s);\\n        }\\n    }\\n    private class RowError extends AppendableException {\\n        static final long serialVersionUID = 754346434606022750L;\\n        RowError(String s) {\\n            super(s);\\n        }\\n        RowError(Throwable t) {\\n            this(null, t);\\n        }\\n        RowError(String s, Throwable t) {\\n            super(s, t);\\n        }\\n    }\\n    public void processFromBuffer()\\n            throws BadSpecial, SQLException, SqlToolError {\\n        historize();\\n        if (buffer.charAt(0) == '*' && (buffer.length() < 2\\n                || buffer.charAt(1) != '{')) {\\n                                    processPL(buffer);\\n            return;\\n        }\\n        if (buffer.charAt(0) == '\\\\\\\\') {\\n            processSpecial(buffer);\\n            return;\\n        }\\n        bufContainsSql = true;\\n        processSQL();\\n    }\\n    private void processBuffHist(String inString)\\n    throws BadSpecial, SQLException, SqlToolError {\\n        if (inString.length() < 1) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.BUFHIST_UNSPECIFIED));\\n        }\\n        char commandChar = inString.charAt(0);\\n        String other       = inString.substring(1);\\n        if (other.trim().length() == 0) {\\n            other = null;\\n        }\\n        switch (commandChar) {\\n            case ';' :\\n                enforce1charBH(other, ';');\\n                if (buffer == null) throw new BadSpecial(\\n                        rb.getString(SqltoolRB.NOBUFFER_YET));\\n                stdprintln(rb.getString(SqltoolRB.BUFFER_EXECUTING, buffer));\\n                processFromBuffer();\\n                return;\\n            case 'a' :\\n                if (buffer == null) throw new BadSpecial(\\n                        rb.getString(SqltoolRB.NOBUFFER_YET));\\n                immCmdSB.append(buffer);\\n                if (other != null) {\\n                    String deTerminated = SqlFile.deTerminated(other);\\n                    if (!other.equals(\\\";\\\")) {\\n                        immCmdSB.append(((deTerminated == null)\\n                                ? other : deTerminated));\\n                    }\\n                    if (deTerminated != null) {\\n                        setBuf(immCmdSB.toString());\\n                        immCmdSB.setLength(0);\\n                        stdprintln(rb.getString(SqltoolRB.BUFFER_EXECUTING,\\n                                buffer));\\n                        processFromBuffer();\\n                        return;\\n                    }\\n                }\\n                withholdPrompt = true;\\n                stdprint(immCmdSB.toString());\\n                return;\\n            case 'l' :\\n            case 'b' :\\n                enforce1charBH(other, 'l');\\n                if (buffer == null) {\\n                    stdprintln(nobufferYetString);\\n                } else {\\n                    stdprintln(rb.getString(SqltoolRB.EDITBUFFER_CONTENTS,\\n                            buffer));\\n                }\\n                return;\\n            case 'h' :\\n                enforce1charBH(other, 'h');\\n                showHistory();\\n                return;\\n            case '-' :\\n            case '0' :\\n            case '1' :\\n            case '2' :\\n            case '3' :\\n            case '4' :\\n            case '5' :\\n            case '6' :\\n            case '7' :\\n            case '8' :\\n            case '9' :\\n                boolean executeMode =\\n                    inString.charAt(inString.length() - 1) == ';';\\n                String numStr = inString.substring(0,\\n                        inString.length() + (executeMode ? -1 : 0));\\n                try {\\n                    setBuf(commandFromHistory(Integer.parseInt(numStr)));\\n                } catch (NumberFormatException nfe) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.COMMANDNUM_MALFORMAT, numStr), nfe);\\n                }\\n                if (executeMode) {\\n                    stdprintln(rb.getString(SqltoolRB.BUFFER_EXECUTING,\\n                            buffer));\\n                    processFromBuffer();\\n                } else {\\n                    stdprintln(rb.getString(SqltoolRB.BUFFER_RESTORED, buffer));\\n                }\\n                return;\\n            case 'w' :\\n                if (other == null) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.DESTFILE_DEMAND));\\n                }\\n                if (buffer == null || buffer.length() == 0) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.BUFFER_EMPTY));\\n                }\\n                PrintWriter pw = null;\\n                try {\\n                    pw = new PrintWriter((charset == null)\\n                            ?  (new OutputStreamWriter(\\n                                    new FileOutputStream(other.trim(), true)))\\n                            :  (new OutputStreamWriter(\\n                                    new FileOutputStream(other.trim(), true),\\n                                            charset))\\n                                                );\\n                    pw.println(buffer + (bufContainsSql ? \\\";\\\" : \\\"\\\"));\\n                    pw.flush();\\n                } catch (Exception e) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.FILE_APPENDFAIL,\\n                            other.trim()), e);\\n                } finally {\\n                    if (pw != null) pw.close();\\n                }\\n                return;\\n            case 's' :\\n                boolean modeExecute = false;\\n                boolean modeGlobal = false;\\n                try {\\n                    if (other == null || other.length() < 3) {\\n                        throw new BadSubst(rb.getString(\\n                                SqltoolRB.SUBSTITUTION_MALFORMAT));\\n                    }\\n                    Matcher m = substitutionPattern.matcher(inString);\\n                    if (buffer == null) {\\n                        stdprintln(nobufferYetString);\\n                        return;\\n                    }\\n                    if (!m.matches()) {\\n                        throw new BadSubst(rb.getString(\\n                                SqltoolRB.SUBSTITUTION_MALFORMAT));\\n                    }\\n                                        if (m.groupCount() < 3 || m.groupCount() > 4) {\\n                                                throw new RuntimeException(\\n                                \\\"Matched substitution pattern, but \\\"\\n                                + \\\"captured \\\" + m.groupCount() + \\\" groups\\\");\\n                    }\\n                    String optionGroup = (\\n                            (m.groupCount() > 3 && m.group(4) != null)\\n                            ? (new String(m.group(4))) : null);\\n                    if (optionGroup != null) {\\n                        if (optionGroup.indexOf(';') > -1) {\\n                            modeExecute = true;\\n                            optionGroup = optionGroup.replaceFirst(\\\";\\\", \\\"\\\");\\n                        }\\n                        if (optionGroup.indexOf('g') > -1) {\\n                            modeGlobal = true;\\n                            optionGroup = optionGroup.replaceFirst(\\\"g\\\", \\\"\\\");\\n                        }\\n                    }\\n                    Matcher bufferMatcher = Pattern.compile(\\\"(?s\\\"\\n                            + ((optionGroup == null) ? \\\"\\\" : optionGroup)\\n                            + ')' + m.group(2)).matcher(buffer);\\n                    String newBuffer = (modeGlobal\\n                            ? bufferMatcher.replaceAll(m.group(3))\\n                            : bufferMatcher.replaceFirst(m.group(3)));\\n                    if (newBuffer.equals(buffer)) {\\n                        stdprintln(rb.getString(\\n                                SqltoolRB.SUBSTITUTION_NOMATCH));\\n                        return;\\n                    }\\n                    setBuf(newBuffer);\\n                    stdprintln(rb.getString((modeExecute\\n                            ? SqltoolRB.BUFFER_EXECUTING\\n                            : SqltoolRB.EDITBUFFER_CONTENTS), buffer));\\n                } catch (PatternSyntaxException pse) {\\n                    throw new BadSpecial(\\n                            rb.getString(SqltoolRB.SUBSTITUTION_SYNTAX), pse);\\n                } catch (BadSubst badswitch) {\\n                    throw new BadSpecial(\\n                            rb.getString(SqltoolRB.SUBSTITUTION_SYNTAX));\\n                }\\n                if (modeExecute) {\\n                    immCmdSB.setLength(0);\\n                    processFromBuffer();\\n                }\\n                return;\\n            case '?' :\\n                stdprintln(rb.getString(SqltoolRB.BUFFER_HELP));\\n                return;\\n        }\\n        throw new BadSpecial(rb.getString(SqltoolRB.BUFFER_UNKNOWN,\\n                Character.toString(commandChar)));\\n    }\\n    private boolean doPrepare   = false;\\n    private String  prepareVar  = null;\\n    private String  dsvColDelim = null;\\n    private String  dsvSkipPrefix = null;\\n    private String  dsvRowDelim = null;\\n    private String  dsvSkipCols = null;\\n    private String  DSV_X_SYNTAX_MSG = null;\\n    private String  DSV_M_SYNTAX_MSG = null;\\n    private String  nobufferYetString = null;\\n    private void enforce1charSpecial(String token, char command)\\n            throws BadSpecial {\\n        if (token.length() != 1) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.SPECIAL_EXTRACHARS,\\n                     Character.toString(command), token.substring(1)));\\n        }\\n    }\\n    private void enforce1charBH(String token, char command)\\n            throws BadSpecial {\\n        if (token != null) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.BUFFER_EXTRACHARS,\\n                    Character.toString(command), token));\\n        }\\n    }\\n    private void processSpecial(String inString)\\n    throws BadSpecial, QuitNow, SQLException, SqlToolError {\\n        if (inString.equals(\\\"\\\\\\\\\\\")) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.SPECIAL_UNSPECIFIED));\\n        }\\n        Matcher m = specialPattern.matcher(\\n                plMode ? dereference(inString, false) : inString);\\n        if (!m.matches()) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.SPECIAL_MALFORMAT));\\n                                }\\n        if (m.groupCount() < 1 || m.groupCount() > 2) {\\n                        throw new RuntimeException(\\n                    \\\"Pattern matched, yet captured \\\" + m.groupCount()\\n                    + \\\" groups\\\");\\n        }\\n        String arg1 = m.group(1);\\n        String other = ((m.groupCount() > 1) ? m.group(2) : null);\\n        switch (arg1.charAt(0)) {\\n            case 'q' :\\n                enforce1charSpecial(arg1, 'q');\\n                if (other != null) {\\n                    throw new QuitNow(other);\\n                }\\n                throw new QuitNow();\\n            case 'H' :\\n                enforce1charSpecial(arg1, 'H');\\n                htmlMode = !htmlMode;\\n                stdprintln(rb.getString(SqltoolRB.HTML_MODE,\\n                        Boolean.toString(htmlMode)));\\n                return;\\n            case 'm' :\\n                if (arg1.equals(\\\"m?\\\") ||\\n                        (arg1.equals(\\\"m\\\") && other != null\\n                                 && other.equals(\\\"?\\\"))) {\\n                    stdprintln(DSV_OPTIONS_TEXT + LS + DSV_M_SYNTAX_MSG);\\n                    return;\\n                }\\n                if (arg1.length() != 1 || other == null) {\\n                    throw new BadSpecial(DSV_M_SYNTAX_MSG);\\n                }\\n                boolean noComments = other.charAt(other.length() - 1) == '*';\\n                String skipPrefix = null;\\n                if (noComments) {\\n                    other = other.substring(0, other.length()-1).trim();\\n                    if (other.length() < 1) {\\n                        throw new BadSpecial(DSV_M_SYNTAX_MSG);\\n                    }\\n                } else {\\n                    skipPrefix = dsvSkipPrefix;\\n                }\\n                int colonIndex = other.indexOf(\\\" :\\\");\\n                if (colonIndex > -1 && colonIndex < other.length() - 2) {\\n                    skipPrefix = other.substring(colonIndex + 2);\\n                    other = other.substring(0, colonIndex).trim();\\n                }\\n                importDsv(other, skipPrefix);\\n                return;\\n            case 'x' :\\n                if (arg1.equals(\\\"x?\\\") ||\\n                        (arg1.equals(\\\"x\\\") && other != null\\n                                 && other.equals(\\\"?\\\"))) {\\n                    stdprintln(DSV_OPTIONS_TEXT + LS + DSV_X_SYNTAX_MSG);\\n                    return;\\n                }\\n                try {\\n                    if (arg1.length() != 1 || other == null) {\\n                        throw new BadSpecial(DSV_X_SYNTAX_MSG);\\n                    }\\n                    String tableName = ((other.indexOf(' ') > 0) ? null\\n                                                                 : other);\\n                    if (dsvTargetFile == null && tableName == null) {\\n                        throw new BadSpecial(rb.getString(\\n                                    SqltoolRB.DSV_TARGETFILE_DEMAND));\\n                    }\\n                    File dsvFile = new File((dsvTargetFile == null)\\n                                            ? (tableName + \\\".dsv\\\")\\n                                            : dsvTargetFile);\\n                    pwDsv = new PrintWriter((charset == null)\\n                       ? (new OutputStreamWriter(new FileOutputStream(dsvFile)))\\n                       : (new OutputStreamWriter(new FileOutputStream(dsvFile),\\n                               charset)));\\n                    ResultSet rs = curConn.createStatement().executeQuery(\\n                            (tableName == null) ? other\\n                                                : (\\\"SELECT * FROM \\\"\\n                                                   + tableName));\\n                    List colList = new ArrayList();\\n                    int[] incCols = null;\\n                    if (dsvSkipCols != null) {\\n                        Set skipCols = new HashSet();\\n                        String[] skipColsArray = dsvSkipCols.split(\\\"\\\\\\\\s*\\\\\\\\Q\\\"\\n                                + dsvColDelim + \\\"\\\\\\\\E\\\\\\\\s*\\\");\\n                        for (int i = 0; i < skipColsArray.length; i++) {\\n                            skipCols.add(skipColsArray[i].toLowerCase());\\n                        }\\n                        ResultSetMetaData rsmd = rs.getMetaData();\\n                        for (int i = 1; i <= rsmd.getColumnCount(); i++) {\\n                            if (!skipCols.remove(rsmd.getColumnName(i)\\n                                    .toLowerCase())) {\\n                                colList.add(new Integer(i));\\n                            }\\n                        }\\n                        if (colList.size() < 1) {\\n                            throw new BadSpecial(rb.getString(\\n                                    SqltoolRB.DSV_NOCOLSLEFT, dsvSkipCols));\\n                        }\\n                        if (skipCols.size() > 0) {\\n                            throw new BadSpecial(rb.getString(\\n                                    SqltoolRB.DSV_SKIPCOLS_MISSING,\\n                                        skipCols.toString()));\\n                        }\\n                        incCols = new int[colList.size()];\\n                        for (int i = 0; i < incCols.length; i++) {\\n                            incCols[i] = ((Integer) colList.get(i)).intValue();\\n                        }\\n                    }\\n                    displayResultSet(null, rs, incCols, null);\\n                    pwDsv.flush();\\n                    stdprintln(rb.getString(SqltoolRB.FILE_WROTECHARS,\\n                            Long.toString(dsvFile.length()),\\n                            dsvFile.toString()));\\n                } catch (FileNotFoundException e) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.FILE_WRITEFAIL,\\n                            other), e);\\n                } catch (UnsupportedEncodingException e) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.FILE_WRITEFAIL,\\n                            other), e);\\n                } finally {\\n                                        if (pwDsv != null) {\\n                        pwDsv.close();\\n                    }\\n                    pwDsv       = null;\\n                }\\n                return;\\n            case 'd' :\\n                if (arg1.equals(\\\"d?\\\") ||\\n                        (arg1.equals(\\\"d\\\") && other != null\\n                                 && other.equals(\\\"?\\\"))) {\\n                    stdprintln(D_OPTIONS_TEXT);\\n                    return;\\n                }\\n                if (arg1.length() == 2) {\\n                    listTables(arg1.charAt(1), other);\\n                    return;\\n                }\\n                if (arg1.length() == 1 && other != null) try {\\n                    int space = other.indexOf(' ');\\n                    if (space < 0) {\\n                        describe(other, null);\\n                    } else {\\n                        describe(other.substring(0, space),\\n                                 other.substring(space + 1).trim());\\n                    }\\n                    return;\\n                } catch (SQLException se) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.METADATA_FETCH_FAIL), se);\\n                }\\n                throw new BadSpecial(rb.getString(SqltoolRB.SPECIAL_D_LIKE));\\n            case 'o' :\\n                enforce1charSpecial(arg1, 'o');\\n                if (other == null) {\\n                    if (pwQuery == null) {\\n                        throw new BadSpecial(rb.getString(\\n                                SqltoolRB.OUTPUTFILE_NONETOCLOSE));\\n                    }\\n                    closeQueryOutputStream();\\n                    return;\\n                }\\n                if (pwQuery != null) {\\n                    stdprintln(rb.getString(SqltoolRB.OUTPUTFILE_REOPENING));\\n                    closeQueryOutputStream();\\n                }\\n                try {\\n                    pwQuery = new PrintWriter((charset == null)\\n                            ? (new OutputStreamWriter(\\n                                    new FileOutputStream(other, true)))\\n                            : (new OutputStreamWriter(\\n                                    new FileOutputStream(other, true), charset))\\n                    );\\n                    pwQuery.println((htmlMode\\n                            ? (\\\"<HTML>\\\" + LS + \\\"<!--\\\")\\n                            : \\\"#\\\") + \\\" \\\" + (new java.util.Date()) + \\\".  \\\"\\n                                    + rb.getString(SqltoolRB.OUTPUTFILE_HEADER,\\n                                            getClass().getName())\\n                                    + (htmlMode ? (\\\" -->\\\" + LS + LS + \\\"<BODY>\\\")\\n                                                : LS));\\n                    pwQuery.flush();\\n                } catch (Exception e) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.FILE_WRITEFAIL,\\n                            other), e);\\n                }\\n                return;\\n            case 'i' :\\n                enforce1charSpecial(arg1, 'i');\\n                if (other == null) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.SQLFILE_NAME_DEMAND));\\n                }\\n                try {\\n                    SqlFile sf = new SqlFile(new File(other), false, userVars);\\n                    sf.recursed = true;\\n                                        sf.possiblyUncommitteds = possiblyUncommitteds;\\n                    sf.plMode               = plMode;\\n                    sf.execute(curConn, continueOnError);\\n                } catch (ContinueException ce) {\\n                    throw ce;\\n                } catch (BreakException be) {\\n                    String beMessage = be.getMessage();\\n                                        if (beMessage != null &&!beMessage.equals(\\\"file\\\")) {\\n                        throw be;\\n                    }\\n                } catch (QuitNow qn) {\\n                    throw qn;\\n                } catch (Exception e) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.SQLFILE_EXECUTE_FAIL, other), e);\\n                }\\n                return;\\n            case 'p' :\\n                enforce1charSpecial(arg1, 'p');\\n                if (other == null) {\\n                    stdprintln(true);\\n                } else {\\n                    stdprintln(other, true);\\n                }\\n                return;\\n            case 'a' :\\n                enforce1charSpecial(arg1, 'a');\\n                if (other != null) {\\n                    curConn.setAutoCommit(\\n                        Boolean.valueOf(other).booleanValue());\\n                }\\n                stdprintln(rb.getString(SqltoolRB.A_SETTING,\\n                        Boolean.toString(curConn.getAutoCommit())));\\n                return;\\n            case '=' :\\n                enforce1charSpecial(arg1, '=');\\n                curConn.commit();\\n                possiblyUncommitteds.set(false);\\n                stdprintln(rb.getString(SqltoolRB.COMMITTED));\\n                return;\\n            case 'b' :\\n                if (arg1.length() == 1) {\\n                    if (other != null) {\\n                        throw new BadSpecial(rb.getString(\\n                                SqltoolRB.SPECIAL_B_MALFORMAT));\\n                    }\\n                    fetchBinary = true;\\n                    return;\\n                }\\n                if (arg1.charAt(1) == 'p') {\\n                    if (other != null) {\\n                        throw new BadSpecial(rb.getString(\\n                                SqltoolRB.SPECIAL_B_MALFORMAT));\\n                    }\\n                    doPrepare = true;\\n                    return;\\n                }\\n                if ((arg1.charAt(1) != 'd' && arg1.charAt(1) != 'l')\\n                        || other == null) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.SPECIAL_B_MALFORMAT));\\n                }\\n                File file = new File(other);\\n                try {\\n                    if (arg1.charAt(1) == 'd') {\\n                        dump(file);\\n                    } else {\\n                        binBuffer = SqlFile.loadBinary(file);\\n                        stdprintln(rb.getString(\\n                                SqltoolRB.BINARY_LOADEDBYTESINTO,\\n                                        binBuffer.length));\\n                    }\\n                } catch (BadSpecial bs) {\\n                    throw bs;\\n                } catch (IOException ioe) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.BINARY_FILEFAIL,\\n                            other), ioe);\\n                }\\n                return;\\n            case '*' :\\n            case 'c' :\\n                enforce1charSpecial(arg1, '=');\\n                if (other != null) {\\n                                        continueOnError = Boolean.valueOf(other).booleanValue();\\n                }\\n                stdprintln(rb.getString(SqltoolRB.C_SETTING,\\n                        Boolean.toString(continueOnError)));\\n                return;\\n            case '?' :\\n                stdprintln(rb.getString(SqltoolRB.SPECIAL_HELP));\\n                return;\\n            case '!' :\\n                                                                                InputStream stream;\\n                byte[]      ba         = new byte[1024];\\n                String      extCommand = ((arg1.length() == 1)\\n                        ? \\\"\\\" : arg1.substring(1))\\n                    + ((arg1.length() > 1 && other != null)\\n                       ? \\\" \\\" : \\\"\\\") + ((other == null) ? \\\"\\\" : other);\\n                if (extCommand.trim().length() < 1)\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.BANG_INCOMPLETE));\\n                try {\\n                    Runtime runtime = Runtime.getRuntime();\\n                    Process proc = ((wincmdPattern == null)\\n                            ? runtime.exec(extCommand)\\n                            : runtime.exec(genWinArgs(extCommand))\\n                    );\\n                    proc.getOutputStream().close();\\n                    int i;\\n                    stream = proc.getInputStream();\\n                    while ((i = stream.read(ba)) > 0) {\\n                        stdprint(new String(ba, 0, i));\\n                    }\\n                    stream.close();\\n                    stream = proc.getErrorStream();\\n                    while ((i = stream.read(ba)) > 0) {\\n                        errprint(new String(ba, 0, i));\\n                    }\\n                    stream.close();\\n                    if (proc.waitFor() != 0) {\\n                        throw new BadSpecial(rb.getString(\\n                                SqltoolRB.BANG_COMMAND_FAIL, extCommand));\\n                    }\\n                } catch (BadSpecial bs) {\\n                    throw bs;\\n                } catch (Exception e) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.BANG_COMMAND_FAIL, extCommand), e);\\n                }\\n                return;\\n            case '.' :\\n                enforce1charSpecial(arg1, '.');\\n                rawMode = RAW_EMPTY;\\n                if (interactive) {\\n                    stdprintln(RAW_LEADIN_MSG);\\n                }\\n                return;\\n        }\\n        throw new BadSpecial(rb.getString(SqltoolRB.SPECIAL_UNKNOWN,\\n                Character.toString(arg1.charAt(0))));\\n    }\\n    private static final char[] nonVarChars = {\\n        ' ', '\\\\t', '=', '}', '\\\\n', '\\\\r'\\n    };\\n    static int pastName(String inString, int startIndex) {\\n        String workString = inString.substring(startIndex);\\n        int    e          = inString.length();            int    nonVarIndex;\\n        for (int i = 0; i < nonVarChars.length; i++) {\\n            nonVarIndex = workString.indexOf(nonVarChars[i]);\\n            if (nonVarIndex > -1 && nonVarIndex < e) {\\n                e = nonVarIndex;\\n            }\\n        }\\n        return startIndex + e;\\n    }\\n    private String dereference(String inString,\\n                               boolean permitAlias) throws SqlToolError {\\n        String       varName, varValue;\\n        StringBuffer expandBuffer = new StringBuffer(inString);\\n        int          b, e;            int iterations;\\n        if (permitAlias && inString.trim().charAt(0) == '/') {\\n            int slashIndex = inString.indexOf('/');\\n            e = SqlFile.pastName(inString.substring(slashIndex + 1), 0);\\n                        if (e < 1) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.PLALIAS_MALFORMAT));\\n            }\\n            varName  = inString.substring(slashIndex + 1, slashIndex + 1 + e);\\n            varValue = (String) userVars.get(varName);\\n            if (varValue == null) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.PLVAR_UNDEFINED, varName));\\n            }\\n            expandBuffer.replace(slashIndex, slashIndex + 1 + e,\\n                                 (String) userVars.get(varName));\\n        }\\n        String s;\\n        boolean permitUnset;\\n        iterations = 0;\\n        while (true) {\\n            s = expandBuffer.toString();\\n            b = s.indexOf(\\\"${\\\");\\n            if (b < 0) {\\n                                break;\\n            }\\n            e = s.indexOf('}', b + 2);\\n            if (e == b + 2) {\\n                throw new SqlToolError(rb.getString(SqltoolRB.SYSPROP_EMPTY));\\n            }\\n            if (e < 0) {\\n                throw new SqlToolError(rb.getString(\\n                            SqltoolRB.SYSPROP_UNTERMINATED));\\n            }\\n            permitUnset = (s.charAt(b + 2) == ':');\\n            varName = s.substring(b + (permitUnset ? 3 : 2), e);\\n            if (iterations++ > 10000)\\n                throw new SqlToolError(rb.getString(SqltoolRB.VAR_INFINITE,\\n                        varName));\\n            varValue = System.getProperty(varName);\\n            if (varValue == null) {\\n                if (permitUnset) {\\n                    varValue = \\\"\\\";\\n                } else {\\n                    throw new SqlToolError(rb.getString(\\n                            SqltoolRB.SYSPROP_UNDEFINED, varName));\\n                }\\n            }\\n            expandBuffer.replace(b, e + 1, varValue);\\n        }\\n        iterations = 0;\\n        while (true) {\\n            s = expandBuffer.toString();\\n            b = s.indexOf(\\\"*{\\\");\\n            if (b < 0) {\\n                                break;\\n            }\\n            e = s.indexOf('}', b + 2);\\n            if (e == b + 2) {\\n                throw new SqlToolError(rb.getString(SqltoolRB.PLVAR_NAMEEMPTY));\\n            }\\n            if (e < 0) {\\n                throw new SqlToolError(rb.getString(\\n                            SqltoolRB.PLVAR_UNTERMINATED));\\n            }\\n            permitUnset = (s.charAt(b + 2) == ':');\\n            varName = s.substring(b + (permitUnset ? 3 : 2), e);\\n            if (iterations++ > 10000)\\n                throw new SqlToolError(rb.getString(SqltoolRB.VAR_INFINITE,\\n                        varName));\\n            varValue = (String) userVars.get(varName);\\n            if (varValue == null) {\\n                if (permitUnset) {\\n                    varValue = \\\"\\\";\\n                } else {\\n                    throw new SqlToolError(rb.getString(\\n                            SqltoolRB.PLVAR_UNDEFINED, varName));\\n                }\\n            }\\n            expandBuffer.replace(b, e + 1, varValue);\\n        }\\n        return expandBuffer.toString();\\n    }\\n    public boolean plMode = false;\\n        private String  fetchingVar = null;\\n    private boolean silentFetch = false;\\n    private boolean fetchBinary = false;\\n    private void processPL(String inString) throws BadSpecial, SqlToolError {\\n        Matcher m = plPattern.matcher(dereference(inString, false));\\n        if (!m.matches()) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.PL_MALFORMAT));\\n                                }\\n        if (m.groupCount() < 1 || m.group(1) == null) {\\n            plMode = true;\\n            stdprintln(rb.getString(SqltoolRB.PL_EXPANSIONMODE, \\\"on\\\"));\\n            return;\\n        }\\n        String[] tokens = m.group(1).split(\\\"\\\\\\\\s+\\\");\\n        if (tokens[0].charAt(0) == '?') {\\n            stdprintln(rb.getString(SqltoolRB.PL_HELP));\\n            return;\\n        }\\n                plMode = true;\\n        if (tokens[0].equals(\\\"end\\\")) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.END_NOBLOCK));\\n        }\\n        if (tokens[0].equals(\\\"continue\\\")) {\\n            if (tokens.length > 1) {\\n                if (tokens.length == 2 &&\\n                        (tokens[1].equals(\\\"foreach\\\") ||\\n                         tokens[1].equals(\\\"while\\\"))) {\\n                    throw new ContinueException(tokens[1]);\\n                }\\n                throw new BadSpecial(rb.getString(SqltoolRB.CONTINUE_SYNTAX));\\n            }\\n            throw new ContinueException();\\n        }\\n        if (tokens[0].equals(\\\"break\\\")) {\\n            if (tokens.length > 1) {\\n                if (tokens.length == 2 &&\\n                        (tokens[1].equals(\\\"foreach\\\") ||\\n                         tokens[1].equals(\\\"if\\\") ||\\n                         tokens[1].equals(\\\"while\\\") ||\\n                         tokens[1].equals(\\\"file\\\"))) {\\n                    throw new BreakException(tokens[1]);\\n                }\\n                throw new BadSpecial(rb.getString(SqltoolRB.BREAK_SYNTAX));\\n            }\\n            throw new BreakException();\\n        }\\n        if (tokens[0].equals(\\\"list\\\") || tokens[0].equals(\\\"listvalues\\\")\\n                || tokens[0].equals(\\\"listsysprops\\\")) {\\n            boolean sysProps =tokens[0].equals(\\\"listsysprops\\\");\\n            String  s;\\n            boolean doValues = (tokens[0].equals(\\\"listvalues\\\") || sysProps);\\n            if (tokens.length == 1) {\\n                stdprint(formatNicely(\\n                        (sysProps ? System.getProperties() : userVars),\\n                        doValues));\\n            } else {\\n                if (doValues) {\\n                    stdprintln(rb.getString(SqltoolRB.PL_LIST_PARENS));\\n                } else {\\n                    stdprintln(rb.getString(SqltoolRB.PL_LIST_LENGTHS));\\n                }\\n                for (int i = 1; i < tokens.length; i++) {\\n                    s = (String) (sysProps ? System.getProperties() : userVars).\\n                            get(tokens[i]);\\n                    if (s == null) continue;\\n                    stdprintln(\\\"    \\\" + tokens[i] + \\\": \\\"\\n                               + (doValues ? (\\\"(\\\" + s + ')')\\n                                           : Integer.toString(s.length())));\\n                }\\n            }\\n            return;\\n        }\\n        if (tokens[0].equals(\\\"dump\\\") || tokens[0].equals(\\\"load\\\")) {\\n            if (tokens.length != 3) {\\n                throw new BadSpecial(rb.getString(\\n                        SqltoolRB.DUMPLOAD_MALFORMAT));\\n            }\\n            String varName = tokens[1];\\n            if (varName.indexOf(':') > -1) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.PLVAR_NOCOLON));\\n            }\\n            File   file    = new File(tokens[2]);\\n            try {\\n                if (tokens[0].equals(\\\"dump\\\")) {\\n                    dump(varName, file);\\n                } else {\\n                    load(varName, file, charset);\\n                }\\n            } catch (IOException ioe) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.DUMPLOAD_FAIL,\\n                        varName, file.toString()), ioe);\\n            }\\n            return;\\n        }\\n        if (tokens[0].equals(\\\"prepare\\\")) {\\n            if (tokens.length != 2) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.PREPARE_MALFORMAT));\\n            }\\n            if (userVars.get(tokens[1]) == null) {\\n                throw new BadSpecial(rb.getString(\\n                    SqltoolRB.PLVAR_UNDEFINED, tokens[1]));\\n            }\\n            prepareVar = tokens[1];\\n            doPrepare  = true;\\n            return;\\n        }\\n        if (tokens[0].equals(\\\"foreach\\\")) {\\n            Matcher foreachM= foreachPattern.matcher(\\n                    dereference(inString, false));\\n            if (!foreachM.matches()) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.FOREACH_MALFORMAT));\\n            }\\n            if (foreachM.groupCount() != 2) {\\n                throw new RuntimeException(\\n                        \\\"foreach pattern matched, but captured \\\"\\n                        + foreachM.groupCount() + \\\" groups\\\");\\n            }\\n            String varName   = foreachM.group(1);\\n            if (varName.indexOf(':') > -1) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.PLVAR_NOCOLON));\\n            }\\n            String[] values = foreachM.group(2).split(\\\"\\\\\\\\s+\\\");\\n            File   tmpFile = null;\\n            String varVal;\\n            try {\\n                tmpFile = plBlockFile(\\\"foreach\\\");\\n            } catch (IOException ioe) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.PL_TEMPFILE_FAIL),\\n                    ioe);\\n            }\\n            String origval = (String) userVars.get(varName);\\n            try {\\n                SqlFile sf;\\n                for (int i = 0; i < values.length; i++) {\\n                    try {\\n                        varVal = values[i];\\n                        userVars.put(varName, varVal);\\n                        updateUserSettings();\\n                        sf          = new SqlFile(tmpFile, false, userVars);\\n                        sf.plMode   = true;\\n                        sf.recursed = true;\\n                                                sf.possiblyUncommitteds = possiblyUncommitteds;\\n                        sf.execute(curConn, continueOnError);\\n                    } catch (ContinueException ce) {\\n                        String ceMessage = ce.getMessage();\\n                        if (ceMessage != null\\n                                &&!ceMessage.equals(\\\"foreach\\\")) {\\n                            throw ce;\\n                        }\\n                    }\\n                }\\n            } catch (BreakException be) {\\n                String beMessage = be.getMessage();\\n                                if (beMessage != null &&!beMessage.equals(\\\"foreach\\\")) {\\n                    throw be;\\n                }\\n            } catch (QuitNow qn) {\\n                throw qn;\\n            } catch (Exception e) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.PL_BLOCK_FAIL), e);\\n            }\\n            if (origval == null) {\\n                userVars.remove(varName);\\n                updateUserSettings();\\n            } else {\\n                userVars.put(varName, origval);\\n            }\\n            if (tmpFile != null &&!tmpFile.delete()) {\\n                throw new BadSpecial(rb.getString(\\n                        SqltoolRB.TEMPFILE_REMOVAL_FAIL, tmpFile.toString()));\\n            }\\n            return;\\n        }\\n        if (tokens[0].equals(\\\"if\\\") || tokens[0].equals(\\\"while\\\")) {\\n            Matcher ifwhileM= ifwhilePattern.matcher(\\n                    dereference(inString, false));\\n            if (!ifwhileM.matches()) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.IFWHILE_MALFORMAT));\\n            }\\n            if (ifwhileM.groupCount() != 1) {\\n                throw new RuntimeException(\\n                        \\\"if/while pattern matched, but captured \\\"\\n                        + ifwhileM.groupCount() + \\\" groups\\\");\\n            }\\n            String[] values =\\n                    ifwhileM.group(1).replaceAll(\\\"!([a-zA-Z0-9*])\\\", \\\"! $1\\\").\\n                            replaceAll(\\\"([a-zA-Z0-9*])!\\\", \\\"$1 !\\\").split(\\\"\\\\\\\\s+\\\");\\n            File tmpFile = null;\\n            if (tokens[0].equals(\\\"if\\\")) {\\n                try {\\n                    tmpFile = plBlockFile(\\\"if\\\");\\n                } catch (IOException ioe) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.PL_BLOCK_FAIL),\\n                            ioe);\\n                }\\n                try {\\n                    if (eval(values)) {\\n                        SqlFile sf = new SqlFile(tmpFile, false, userVars);\\n                        sf.plMode   = true;\\n                        sf.recursed = true;\\n                                                sf.possiblyUncommitteds = possiblyUncommitteds;\\n                        sf.execute(curConn, continueOnError);\\n                    }\\n                } catch (BreakException be) {\\n                    String beMessage = be.getMessage();\\n                                        if (beMessage == null ||!beMessage.equals(\\\"if\\\")) {\\n                        throw be;\\n                    }\\n                } catch (ContinueException ce) {\\n                    throw ce;\\n                } catch (QuitNow qn) {\\n                    throw qn;\\n                } catch (BadSpecial bs) {\\n                    bs.appendMessage(rb.getString(SqltoolRB.IF_MALFORMAT));\\n                    throw bs;\\n                } catch (Exception e) {\\n                    throw new BadSpecial(\\n                        rb.getString(SqltoolRB.PL_BLOCK_FAIL), e);\\n                }\\n            } else if (tokens[0].equals(\\\"while\\\")) {\\n                try {\\n                    tmpFile = plBlockFile(\\\"while\\\");\\n                } catch (IOException ioe) {\\n                    throw new BadSpecial(\\n                        rb.getString(SqltoolRB.PL_TEMPFILE_FAIL), ioe);\\n                }\\n                try {\\n                    SqlFile sf;\\n                    while (eval(values)) {\\n                        try {\\n                            sf          = new SqlFile(tmpFile, false, userVars);\\n                            sf.recursed = true;\\n                                                        sf.possiblyUncommitteds = possiblyUncommitteds;\\n                            sf.plMode               = true;\\n                            sf.execute(curConn, continueOnError);\\n                        } catch (ContinueException ce) {\\n                            String ceMessage = ce.getMessage();\\n                            if (ceMessage != null &&!ceMessage.equals(\\\"while\\\")) {\\n                                throw ce;\\n                            }\\n                        }\\n                    }\\n                } catch (BreakException be) {\\n                    String beMessage = be.getMessage();\\n                                        if (beMessage != null &&!beMessage.equals(\\\"while\\\")) {\\n                        throw be;\\n                    }\\n                } catch (QuitNow qn) {\\n                    throw qn;\\n                } catch (BadSpecial bs) {\\n                    bs.appendMessage(rb.getString(SqltoolRB.WHILE_MALFORMAT));\\n                    throw bs;\\n                } catch (Exception e) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.PL_BLOCK_FAIL),\\n                            e);\\n                }\\n            } else {\\n                                throw new RuntimeException(rb.getString(SqltoolRB.PL_UNKNOWN,\\n                        tokens[0]));\\n            }\\n            if (tmpFile != null &&!tmpFile.delete()) {\\n                throw new BadSpecial(rb.getString(\\n                        SqltoolRB.TEMPFILE_REMOVAL_FAIL, tmpFile.toString()));\\n            }\\n            return;\\n        }\\n        m = varsetPattern.matcher(dereference(inString, false));\\n        if (!m.matches()) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.PL_UNKNOWN, tokens[0]));\\n        }\\n        if (m.groupCount() < 2 || m.groupCount() > 3) {\\n                        throw new RuntimeException(\\\"varset pattern matched but captured \\\"\\n                    + m.groupCount() + \\\" groups\\\");\\n        }\\n        String varName  = m.group(1);\\n        if (varName.indexOf(':') > -1) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.PLVAR_NOCOLON));\\n        }\\n        switch (m.group(2).charAt(0)) {\\n            case '_' :\\n                silentFetch = true;\\n            case '~' :\\n                if (m.groupCount() > 2 && m.group(3) != null) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.PLVAR_TILDEDASH_NOMOREARGS, m.group(3)));\\n                }\\n                userVars.remove(varName);\\n                updateUserSettings();\\n                fetchingVar = varName;\\n                return;\\n            case '=' :\\n                if (fetchingVar != null && fetchingVar.equals(varName)) {\\n                    fetchingVar = null;\\n                }\\n                if (m.groupCount() > 2 && m.group(3) != null) {\\n                    userVars.put(varName, m.group(3));\\n                } else {\\n                    userVars.remove(varName);\\n                }\\n                updateUserSettings();\\n                return;\\n        }\\n        throw new BadSpecial(rb.getString(SqltoolRB.PL_UNKNOWN, tokens[0]));\\n            }\\n    private File plBlockFile(String seeking) throws IOException, SqlToolError {\\n        String          s;\\n                                int    nestlevel = 1;\\n        String curPlCommand;\\n        if (seeking == null\\n                || ((!seeking.equals(\\\"foreach\\\")) && (!seeking.equals(\\\"if\\\"))\\n                    && (!seeking.equals(\\\"while\\\")))) {\\n            throw new RuntimeException(\\n                \\\"Assertion failed.  Unsupported PL block type:  \\\" + seeking);\\n        }\\n        File tmpFile = File.createTempFile(\\\"sqltool-\\\", \\\".sql\\\");\\n        PrintWriter pw = new PrintWriter((charset == null)\\n                ?  (new OutputStreamWriter(new FileOutputStream(tmpFile)))\\n                :  (new OutputStreamWriter(new FileOutputStream(tmpFile),\\n                        charset)));\\n        try {\\n        pw.println(\\\"\\\");\\n        pw.println();\\n        Matcher m;\\n        while (true) {\\n            s = br.readLine();\\n            if (s == null) {\\n                s = rb.getString(SqltoolRB.PL_BLOCK_UNTERMINATED, seeking);\\n                errprintln(s);\\n                throw new SqlToolError(s);\\n            }\\n            curLinenum++;\\n            m = plPattern.matcher(s);\\n            if (m.matches() && m.groupCount() > 0 && m.group(1) != null) {\\n                String[] tokens = m.group(1).split(\\\"\\\\\\\\s+\\\");\\n                curPlCommand = tokens[0];\\n                                if (curPlCommand.equals(seeking)) {\\n                    nestlevel++;\\n                } else if (curPlCommand.equals(\\\"end\\\")) {\\n                    if (tokens.length < 2) {\\n                        s = rb.getString(SqltoolRB.END_SYNTAX, \\\"1\\\");\\n                        errprintln(s);\\n                        throw new SqlToolError(s);\\n                    }\\n                    String inType = tokens[1];\\n                    if (inType.equals(seeking)) {\\n                        nestlevel--;\\n                        if (nestlevel < 1) {\\n                            break;\\n                        }\\n                    }\\n                    if ((!inType.equals(\\\"foreach\\\")) && (!inType.equals(\\\"if\\\"))\\n                            && (!inType.equals(\\\"while\\\"))) {\\n                        s = rb.getString(SqltoolRB.END_SYNTAX, \\\"2\\\");\\n                        errprintln(s);\\n                        throw new SqlToolError(s);\\n                    }\\n                }\\n            }\\n            pw.println(s);\\n        }\\n        pw.flush();\\n        } finally {\\n            pw.close();\\n        }\\n        return tmpFile;\\n    }\\n    private void stdprint(String s) {\\n        stdprint(s, false);\\n    }\\n    private void stdprintln(String s) {\\n        stdprintln(s, false);\\n    }\\n    private void stdprintln(boolean queryOutput) {\\n        if (htmlMode) {\\n            psStd.println(\\\"<BR>\\\");\\n        } else {\\n            psStd.println();\\n        }\\n        if (queryOutput && pwQuery != null) {\\n            if (htmlMode) {\\n                pwQuery.println(\\\"<BR>\\\");\\n            } else {\\n                pwQuery.println();\\n            }\\n            pwQuery.flush();\\n        }\\n    }\\n    private void errprint(String s) {\\n        psErr.print(htmlMode\\n                    ? (\\\"<DIV style='color:white; background: red; \\\"\\n                       + \\\"font-weight: bold'>\\\" + s + \\\"</DIV>\\\")\\n                    : s);\\n    }\\n    private void errprintln(String s) {\\n        psErr.println(htmlMode\\n                      ? (\\\"<DIV style='color:white; background: red; \\\"\\n                         + \\\"font-weight: bold'>\\\" + s + \\\"</DIV>\\\")\\n                      : s);\\n    }\\n    private void stdprint(String s, boolean queryOutput) {\\n        psStd.print(htmlMode ? (\\\"<P>\\\" + s + \\\"</P>\\\")\\n                             : s);\\n        if (queryOutput && pwQuery != null) {\\n            pwQuery.print(htmlMode ? (\\\"<P>\\\" + s + \\\"</P>\\\")\\n                                   : s);\\n            pwQuery.flush();\\n        }\\n    }\\n    private void stdprintln(String s, boolean queryOutput) {\\n        psStd.println(htmlMode ? (\\\"<P>\\\" + s + \\\"</P>\\\")\\n                               : s);\\n        if (queryOutput && pwQuery != null) {\\n            pwQuery.println(htmlMode ? (\\\"<P>\\\" + s + \\\"</P>\\\")\\n                                     : s);\\n            pwQuery.flush();\\n        }\\n    }\\n                private static final String DEFAULT_NULL_REP = \\\"[null]\\\";\\n    private static final String DEFAULT_ROW_DELIM = LS;\\n    private static final String DEFAULT_COL_DELIM = \\\"|\\\";\\n    private static final String DEFAULT_SKIP_PREFIX = \\\"#\\\";\\n    private static final int    DEFAULT_ELEMENT   = 0,\\n                                HSQLDB_ELEMENT    = 1,\\n                                ORACLE_ELEMENT    = 2\\n    ;\\n        private static final int[] listMDSchemaCols = { 1 };\\n    private static final int[] listMDIndexCols  = {\\n        2, 6, 3, 9, 4, 10, 11\\n    };\\n    private static final int[][] listMDTableCols = {\\n        {\\n            2, 3\\n        },            {\\n            2, 3\\n        },            {\\n            2, 3\\n        },        };\\n    private static final String[] oracleSysSchemas = {\\n        \\\"SYS\\\", \\\"SYSTEM\\\", \\\"OUTLN\\\", \\\"DBSNMP\\\", \\\"OUTLN\\\", \\\"MDSYS\\\", \\\"ORDSYS\\\",\\n        \\\"ORDPLUGINS\\\", \\\"CTXSYS\\\", \\\"DSSYS\\\", \\\"PERFSTAT\\\", \\\"WKPROXY\\\", \\\"WKSYS\\\",\\n        \\\"WMSYS\\\", \\\"XDB\\\", \\\"ANONYMOUS\\\", \\\"ODM\\\", \\\"ODM_MTR\\\", \\\"OLAPSYS\\\", \\\"TRACESVR\\\",\\n        \\\"REPADMIN\\\"\\n    };\\n    private void listTables(char c, String inFilter) throws BadSpecial,\\n            SqlToolError {\\n        String   schema  = null;\\n        int[]    listSet = null;\\n        String[] types   = null;\\n        String[] additionalSchemas = null;\\n        Statement statement = null;\\n        ResultSet rs        = null;\\n        String    narrower  = \\\"\\\";\\n        String filter = inFilter;\\n        try {\\n            DatabaseMetaData md            = curConn.getMetaData();\\n            String           dbProductName = md.getDatabaseProductName();\\n            types = new String[1];\\n            switch (c) {\\n                case '*' :\\n                    types = null;\\n                    break;\\n                case 'S' :\\n                    if (dbProductName.indexOf(\\\"Oracle\\\") > -1) {\\n                        errprintln(rb.getString(SqltoolRB.VENDOR_ORACLE_DS));\\n                        types[0]          = \\\"TABLE\\\";\\n                        schema            = \\\"SYS\\\";\\n                        additionalSchemas = oracleSysSchemas;\\n                    } else {\\n                        types[0] = \\\"SYSTEM TABLE\\\";\\n                    }\\n                    break;\\n                case 's' :\\n                    if (dbProductName.indexOf(\\\"HSQL\\\") > -1) {\\n                                                                                                if (filter != null\\n                                && filter.charAt(filter.length() - 1)\\n                                   == '.') {\\n                            narrower =\\n                                \\\"\\\\nWHERE sequence_schema = '\\\"\\n                                + filter.substring(0, filter.length() - 1)\\n                                + \\\"'\\\";\\n                            filter = null;\\n                        }\\n                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT sequence_schema, sequence_name FROM \\\"\\n                            + \\\"information_schema.system_sequences\\\"\\n                            + narrower);\\n                    } else {\\n                        types[0] = \\\"SEQUENCE\\\";\\n                    }\\n                    break;\\n                case 'r' :\\n                    if (dbProductName.indexOf(\\\"HSQL\\\") > -1) {\\n                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT authorization_name FROM \\\"\\n                            + \\\"information_schema.system_authorizations\\\\n\\\"\\n                            + \\\"WHERE authorization_type = 'ROLE'\\\\n\\\"\\n                            + \\\"ORDER BY authorization_name\\\");\\n                    } else if (dbProductName.indexOf(\\n                            \\\"Adaptive Server Enterprise\\\") > -1) {\\n                                                                                                                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT name FROM syssrvroles ORDER BY name\\\");\\n                    } else if (dbProductName.indexOf(\\n                            \\\"Apache Derby\\\") > -1) {\\n                        throw new BadSpecial(\\n                            rb.getString(SqltoolRB.VENDOR_DERBY_DR));\\n                    } else {\\n                        throw new BadSpecial(\\n                            rb.getString(SqltoolRB.VENDOR_NOSUP_D, \\\"r\\\"));\\n                    }\\n                    break;\\n                case 'u' :\\n                    if (dbProductName.indexOf(\\\"HSQL\\\") > -1) {\\n                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT user, admin FROM \\\"\\n                            + \\\"information_schema.system_users\\\\n\\\"\\n                            + \\\"ORDER BY user\\\");\\n                    } else if (dbProductName.indexOf(\\\"Oracle\\\") > -1) {\\n                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT username, created FROM all_users \\\"\\n                            + \\\"ORDER BY username\\\");\\n                    } else if (dbProductName.indexOf(\\\"PostgreSQL\\\") > -1) {\\n                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT usename, usesuper FROM pg_catalog.pg_user \\\"\\n                            + \\\"ORDER BY usename\\\");\\n                    } else if (dbProductName.indexOf(\\n                            \\\"Adaptive Server Enterprise\\\") > -1) {\\n                                                                                                                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT name, accdate, fullname FROM syslogins \\\"\\n                            + \\\"ORDER BY name\\\");\\n                    } else if (dbProductName.indexOf(\\n                            \\\"Apache Derby\\\") > -1) {\\n                        throw new BadSpecial(\\n                            rb.getString(SqltoolRB.VENDOR_DERBY_DU));\\n                    } else {\\n                        throw new BadSpecial(\\n                            rb.getString(SqltoolRB.VENDOR_NOSUP_D, \\\"u\\\"));\\n                    }\\n                    break;\\n                case 'a' :\\n                    if (dbProductName.indexOf(\\\"HSQL\\\") > -1) {\\n                                                                        if (filter != null\\n                                && filter.charAt(filter.length() - 1)\\n                                   == '.') {\\n                            narrower =\\n                                \\\"\\\\nWHERE alias_schem = '\\\"\\n                                + filter.substring(0, filter.length() - 1)\\n                                + \\\"'\\\";\\n                            filter = null;\\n                        }\\n                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT alias_schem, alias FROM \\\"\\n                            + \\\"information_schema.system_aliases\\\" + narrower);\\n                    } else {\\n                        types[0] = \\\"ALIAS\\\";\\n                    }\\n                    break;\\n                case 't' :\\n                    excludeSysSchemas = (dbProductName.indexOf(\\\"Oracle\\\")\\n                                         > -1);\\n                    types[0] = \\\"TABLE\\\";\\n                    break;\\n                case 'v' :\\n                    types[0] = \\\"VIEW\\\";\\n                    break;\\n                case 'n' :\\n                    rs = md.getSchemas();\\n                    if (rs == null) {\\n                        throw new BadSpecial(\\n                            \\\"Failed to get metadata from database\\\");\\n                    }\\n                    displayResultSet(null, rs, listMDSchemaCols, filter);\\n                    return;\\n                case 'i' :\\n                    String table = null;\\n                    if (filter != null) {\\n                        int dotat = filter.indexOf('.');\\n                        schema = ((dotat > 0) ? filter.substring(0, dotat)\\n                                              : null);\\n                        if (dotat < filter.length() - 1) {\\n                                                        table = ((dotat > 0) ? filter.substring(dotat + 1)\\n                                                 : filter);\\n                        }\\n                        filter = null;\\n                    }\\n                                                                                                    rs = md.getIndexInfo(null, schema, table, false, true);\\n                    if (rs == null) {\\n                        throw new BadSpecial(\\n                            \\\"Failed to get metadata from database\\\");\\n                    }\\n                    displayResultSet(null, rs, listMDIndexCols, null);\\n                    return;\\n                default :\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.SPECIAL_D_UNKNOWN,\\n                                Character.toString(c)) + LS + D_OPTIONS_TEXT);\\n            }\\n            if (statement == null) {\\n                if (dbProductName.indexOf(\\\"HSQL\\\") > -1) {\\n                    listSet = listMDTableCols[HSQLDB_ELEMENT];\\n                } else if (dbProductName.indexOf(\\\"Oracle\\\") > -1) {\\n                    listSet = listMDTableCols[ORACLE_ELEMENT];\\n                } else {\\n                    listSet = listMDTableCols[DEFAULT_ELEMENT];\\n                }\\n                if (schema == null && filter != null\\n                        && filter.charAt(filter.length() - 1) == '.') {\\n                    schema = filter.substring(0, filter.length() - 1);\\n                    filter = null;\\n                }\\n            }\\n            rs = ((statement == null)\\n                  ? md.getTables(null, schema, null, types)\\n                  : statement.getResultSet());\\n            if (rs == null) {\\n                throw new BadSpecial(rb.getString(\\n                        SqltoolRB.METADATA_FETCH_FAIL));\\n            }\\n            displayResultSet(null, rs, listSet, filter);\\n            if (additionalSchemas != null) {\\n                for (int i = 1; i < additionalSchemas.length; i++) {\\n                    rs = md.getTables(null, additionalSchemas[i], null,\\n                                      types);\\n                    if (rs == null) {\\n                        throw new BadSpecial(rb.getString(\\n                                SqltoolRB.METADATA_FETCH_FAILFOR,\\n                                        additionalSchemas[i]));\\n                    }\\n                    if (!rs.next()) {\\n                        continue;\\n                    }\\n                    displayResultSet(\\n                        null,\\n                        md.getTables(\\n                            null, additionalSchemas[i], null, types), listSet, filter);\\n                }\\n            }\\n        } catch (SQLException se) {\\n            throw new BadSpecial(rb.getString( SqltoolRB.METADATA_FETCH_FAIL),\\n                    se);\\n        } catch (NullPointerException npe) {\\n            throw new BadSpecial(rb.getString( SqltoolRB.METADATA_FETCH_FAIL),\\n                    npe);\\n        } finally {\\n            excludeSysSchemas = false;\\n            if (rs != null) {\\n                rs = null;\\n            }\\n            if (statement != null) {\\n                try {\\n                    statement.close();\\n                } catch (Exception e) {}\\n                statement = null;\\n            }\\n        }\\n    }\\n    private boolean excludeSysSchemas = false;\\n    private void processSQL() throws SQLException, SqlToolError {\\n                                                                                                        lastSqlStatement    = (plMode ? dereference(buffer, true)\\n                                      : buffer);\\n        Statement statement = null;\\n        if (doPrepare) {\\n            if (lastSqlStatement.indexOf('?') < 1) {\\n                lastSqlStatement = null;\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.PREPARE_DEMANDQM));\\n            }\\n            doPrepare = false;\\n            PreparedStatement ps = curConn.prepareStatement(lastSqlStatement);\\n            if (prepareVar == null) {\\n                if (binBuffer == null) {\\n                    lastSqlStatement = null;\\n                    throw new SqlToolError(rb.getString(\\n                            SqltoolRB.BINBUFFER_EMPTY));\\n                }\\n                ps.setBytes(1, binBuffer);\\n            } else {\\n                String val = (String) userVars.get(prepareVar);\\n                if (val == null) {\\n                    lastSqlStatement = null;\\n                    throw new SqlToolError(\\n                            rb.getString(SqltoolRB.PLVAR_UNDEFINED,\\n                                    prepareVar));\\n                }\\n                prepareVar = null;\\n                ps.setString(1, val);\\n            }\\n            ps.executeUpdate();\\n            statement = ps;\\n        } else {\\n            statement = curConn.createStatement();\\n            statement.execute(lastSqlStatement);\\n        }\\n        possiblyUncommitteds.set(true);\\n        try {\\n            displayResultSet(statement, statement.getResultSet(), null, null);\\n        } finally {\\n            try {\\n                statement.close();\\n            } catch (Exception e) {}\\n        }\\n        lastSqlStatement = null;\\n    }\\n    private void displayResultSet(Statement statement, ResultSet r,\\n                                  int[] incCols,\\n                                  String filter) throws SQLException,\\n                                  SqlToolError {\\n        java.sql.Timestamp ts;\\n        int dotAt;\\n        int                updateCount = (statement == null) ? -1\\n                                                             : statement\\n                                                                 .getUpdateCount();\\n        boolean            silent      = silentFetch;\\n        boolean            binary      = fetchBinary;\\n        silentFetch = false;\\n        fetchBinary = false;\\n        if (excludeSysSchemas) {\\n            stdprintln(rb.getString(SqltoolRB.VENDOR_NOSUP_SYSSCHEMAS));\\n        }\\n        switch (updateCount) {\\n            case -1 :\\n                if (r == null) {\\n                    stdprintln(rb.getString(SqltoolRB.NORESULT), true);\\n                    break;\\n                }\\n                ResultSetMetaData m        = r.getMetaData();\\n                int               cols     = m.getColumnCount();\\n                int               incCount = (incCols == null) ? cols\\n                                                               : incCols\\n                                                                   .length;\\n                String            val;\\n                List              rows        = new ArrayList();\\n                String[]          headerArray = null;\\n                String[]          fieldArray;\\n                int[]             maxWidth = new int[incCount];\\n                int               insi;\\n                boolean           skip;\\n                                if (!htmlMode) {\\n                    for (int i = 0; i < maxWidth.length; i++) {\\n                        maxWidth[i] = 0;\\n                    }\\n                }\\n                boolean[] rightJust = new boolean[incCount];\\n                int[]     dataType  = new int[incCount];\\n                boolean[] autonulls = new boolean[incCount];\\n                insi        = -1;\\n                headerArray = new String[incCount];\\n                for (int i = 1; i <= cols; i++) {\\n                    if (incCols != null) {\\n                        skip = true;\\n                        for (int j = 0; j < incCols.length; j++) {\\n                            if (i == incCols[j]) {\\n                                skip = false;\\n                            }\\n                        }\\n                        if (skip) {\\n                            continue;\\n                        }\\n                    }\\n                    headerArray[++insi] = m.getColumnLabel(i);\\n                    dataType[insi]      = m.getColumnType(i);\\n                    rightJust[insi]     = false;\\n                    autonulls[insi]     = true;\\n                    switch (dataType[insi]) {\\n                        case java.sql.Types.BIGINT :\\n                        case java.sql.Types.BIT :\\n                        case java.sql.Types.DECIMAL :\\n                        case java.sql.Types.DOUBLE :\\n                        case java.sql.Types.FLOAT :\\n                        case java.sql.Types.INTEGER :\\n                        case java.sql.Types.NUMERIC :\\n                        case java.sql.Types.REAL :\\n                        case java.sql.Types.SMALLINT :\\n                        case java.sql.Types.TINYINT :\\n                            rightJust[insi] = true;\\n                            break;\\n                        case java.sql.Types.VARBINARY :\\n                        case java.sql.Types.VARCHAR :\\n                        case java.sql.Types.ARRAY :\\n                                                    case java.sql.Types.BLOB :\\n                        case java.sql.Types.CLOB :\\n                        case java.sql.Types.LONGVARBINARY :\\n                        case java.sql.Types.LONGVARCHAR :\\n                            autonulls[insi] = false;\\n                            break;\\n                    }\\n                    if (htmlMode) {\\n                        continue;\\n                    }\\n                    if (headerArray[insi].length() > maxWidth[insi]) {\\n                        maxWidth[insi] = headerArray[insi].length();\\n                    }\\n                }\\n                boolean filteredOut;\\n                while (r.next()) {\\n                    fieldArray  = new String[incCount];\\n                    insi        = -1;\\n                    filteredOut = filter != null;\\n                    for (int i = 1; i <= cols; i++) {\\n                                                                        if (incCols != null) {\\n                            skip = true;\\n                            for (int j = 0; j < incCols.length; j++) {\\n                                if (i == incCols[j]) {\\n                                    skip = false;\\n                                }\\n                            }\\n                            if (skip) {\\n                                continue;\\n                            }\\n                        }\\n                                                                                                ++insi;\\n                        if (!SqlFile.canDisplayType(dataType[insi])) {\\n                            binary = true;\\n                        }\\n                        val = null;\\n                        if (!binary) {\\n                            switch (dataType[insi]) {\\n                                case java.sql.Types.TIMESTAMP:\\n                                case java.sql.Types.DATE:\\n                                case java.sql.Types.TIME:\\n                                    ts  = r.getTimestamp(i);\\n                                    val = ((ts == null) ? null : ts.toString());\\n                                                                                                                                                if (dataType[insi]\\n                                            != java.sql.Types.TIMESTAMP\\n                                            && val != null) {\\n                                        dotAt = val.lastIndexOf('.');\\n                                        for (int z = dotAt + 1;\\n                                                z < val.length(); z++) {\\n                                            if (val.charAt(z) != '0') {\\n                                                dotAt = 0;\\n                                                break;\\n                                            }\\n                                        }\\n                                        if (dotAt > 1) {\\n                                            val = val.substring(0, dotAt);\\n                                        }\\n                                    }\\n                                    break;\\n                                default:\\n                                    val = r.getString(i);\\n                                                                                                                                                if (val == null) {\\n                                        try {\\n                                            val = streamToString(\\n                                                r.getAsciiStream(i), charset);\\n                                        } catch (Exception e) { }\\n                                    }\\n                            }\\n                        }\\n                        if (binary || (val == null &&!r.wasNull())) {\\n                            if (pwDsv != null) {\\n                                throw new SqlToolError(\\n                                        rb.getString(SqltoolRB.DSV_BINCOL));\\n                            }\\n                                                                                    try {\\n                                binBuffer =\\n                                    SqlFile.streamToBytes(r.getBinaryStream(i));\\n                            } catch (IOException ioe) {\\n                                throw new SqlToolError(\\n                                    \\\"Failed to read value using stream\\\",\\n                                    ioe);\\n                            }\\n                            stdprintln(rb.getString(SqltoolRB.BINBUF_WRITE,\\n                                       Integer.toString(binBuffer.length),\\n                                       headerArray[insi],\\n                                       SqlFile.sqlTypeToString(dataType[insi])\\n                                    ));\\n                            return;\\n                        }\\n                        if (excludeSysSchemas && val != null && i == 2) {\\n                            for (int z = 0; z < oracleSysSchemas.length;\\n                                    z++) {\\n                                if (val.equals(oracleSysSchemas[z])) {\\n                                    filteredOut = true;\\n                                    break;\\n                                }\\n                            }\\n                        }\\n                        userVars.put(\\\"?\\\", ((val == null) ? nullRepToken : val));\\n                        if (fetchingVar != null) {\\n                            userVars.put(fetchingVar, userVars.get(\\\"?\\\"));\\n                            updateUserSettings();\\n                            fetchingVar = null;\\n                        }\\n                        if (silent) {\\n                            return;\\n                        }\\n                                                                                                if (filter != null\\n                                && (val == null\\n                                    || val.indexOf(filter) > -1)) {\\n                            filteredOut = false;\\n                        }\\n                                                                        if (val == null && pwDsv == null) {\\n                            if (dataType[insi] == java.sql.Types.VARCHAR) {\\n                                fieldArray[insi] = (htmlMode ? \\\"<I>null</I>\\\"\\n                                                             : nullRepToken);\\n                            } else {\\n                                fieldArray[insi] = \\\"\\\";\\n                            }\\n                        } else {\\n                            fieldArray[insi] = val;\\n                        }\\n                                                if (htmlMode || pwDsv != null) {\\n                            continue;\\n                        }\\n                        if (fieldArray[insi].length() > maxWidth[insi]) {\\n                            maxWidth[insi] = fieldArray[insi].length();\\n                        }\\n                    }\\n                    if (!filteredOut) {\\n                        rows.add(fieldArray);\\n                    }\\n                }\\n                                                if (pwDsv == null) {\\n                    condlPrintln(\\\"<TABLE border='1'>\\\", true);\\n                    if (incCount > 1) {\\n                        condlPrint(SqlFile.htmlRow(COL_HEAD) + LS + PRE_TD, true);\\n                        for (int i = 0; i < headerArray.length; i++) {\\n                            condlPrint(\\\"<TD>\\\" + headerArray[i] + \\\"</TD>\\\",\\n                                       true);\\n                            condlPrint(((i > 0) ? SqlFile.spaces(2)\\n                                                : \\\"\\\") + SqlFile.pad(\\n                                                    headerArray[i],\\n                                                    maxWidth[i],\\n                                                    rightJust[i],\\n                                                    (i < headerArray.length\\n                                                     - 1 || rightJust[i])), false);\\n                        }\\n                        condlPrintln(LS + PRE_TR + \\\"</TR>\\\", true);\\n                        condlPrintln(\\\"\\\", false);\\n                        if (!htmlMode) {\\n                            for (int i = 0; i < headerArray.length; i++) {\\n                                condlPrint(((i > 0) ? SqlFile.spaces(2)\\n                                                    : \\\"\\\") + SqlFile.divider(\\n                                                        maxWidth[i]), false);\\n                            }\\n                            condlPrintln(\\\"\\\", false);\\n                        }\\n                    }\\n                    for (int i = 0; i < rows.size(); i++) {\\n                        condlPrint(SqlFile.htmlRow(((i % 2) == 0) ? COL_EVEN\\n                                                          : COL_ODD) + LS\\n                                                          + PRE_TD, true);\\n                        fieldArray = (String[]) rows.get(i);\\n                        for (int j = 0; j < fieldArray.length; j++) {\\n                            condlPrint(\\\"<TD>\\\" + fieldArray[j] + \\\"</TD>\\\",\\n                                       true);\\n                            condlPrint(((j > 0) ? SqlFile.spaces(2)\\n                                                : \\\"\\\") + SqlFile.pad(\\n                                                    fieldArray[j],\\n                                                    maxWidth[j],\\n                                                    rightJust[j],\\n                                                    (j < fieldArray.length\\n                                                     - 1 || rightJust[j])), false);\\n                        }\\n                        condlPrintln(LS + PRE_TR + \\\"</TR>\\\", true);\\n                        condlPrintln(\\\"\\\", false);\\n                    }\\n                    condlPrintln(\\\"</TABLE>\\\", true);\\n                    if (rows.size() != 1) {\\n                        stdprintln(LS + rb.getString(SqltoolRB.ROWS_FETCHED,\\n                                rows.size()), true);\\n                    }\\n                    condlPrintln(\\\"<HR>\\\", true);\\n                    break;\\n                }\\n                                if (incCount > 0) {\\n                    for (int i = 0; i < headerArray.length; i++) {\\n                        dsvSafe(headerArray[i]);\\n                        pwDsv.print(headerArray[i]);\\n                        if (i < headerArray.length - 1) {\\n                            pwDsv.print(dsvColDelim);\\n                        }\\n                    }\\n                    pwDsv.print(dsvRowDelim);\\n                }\\n                for (int i = 0; i < rows.size(); i++) {\\n                    fieldArray = (String[]) rows.get(i);\\n                    for (int j = 0; j < fieldArray.length; j++) {\\n                        dsvSafe(fieldArray[j]);\\n                        pwDsv.print((fieldArray[j] == null)\\n                                    ? (autonulls[j] ? \\\"\\\"\\n                                                    : nullRepToken)\\n                                    : fieldArray[j]);\\n                        if (j < fieldArray.length - 1) {\\n                            pwDsv.print(dsvColDelim);\\n                        }\\n                    }\\n                    pwDsv.print(dsvRowDelim);\\n                }\\n                stdprintln(rb.getString(SqltoolRB.ROWS_FETCHED_DSV,\\n                        rows.size()));\\n                break;\\n            default :\\n                userVars.put(\\\"?\\\", Integer.toString(updateCount));\\n                if (fetchingVar != null) {\\n                    userVars.put(fetchingVar, userVars.get(\\\"?\\\"));\\n                    updateUserSettings();\\n                    fetchingVar = null;\\n                }\\n                if (updateCount != 0) {\\n                    stdprintln((updateCount == 1)\\n                        ? rb.getString(SqltoolRB.ROW_UPDATE_SINGULAR)\\n                        : rb.getString(SqltoolRB.ROW_UPDATE_MULTIPLE,\\n                                updateCount));\\n                }\\n                break;\\n        }\\n    }\\n    private static final int    COL_HEAD = 0,\\n                                COL_ODD  = 1,\\n                                COL_EVEN = 2\\n    ;\\n    private static final String PRE_TR   = spaces(4);\\n    private static final String PRE_TD   = spaces(8);\\n    private static String htmlRow(int colType) {\\n        switch (colType) {\\n            case COL_HEAD :\\n                return PRE_TR + \\\"<TR style='font-weight: bold;'>\\\";\\n            case COL_ODD :\\n                return PRE_TR\\n                       + \\\"<TR style='background: #94d6ef; font: normal \\\"\\n                       + \\\"normal 10px/10px Arial, Helvitica, sans-serif;'>\\\";\\n            case COL_EVEN :\\n                return PRE_TR\\n                       + \\\"<TR style='background: silver; font: normal \\\"\\n                       + \\\"normal 10px/10px Arial, Helvitica, sans-serif;'>\\\";\\n        }\\n        return null;\\n    }\\n    private static String divider(int len) {\\n        return (len > DIVIDER.length()) ? DIVIDER\\n                                        : DIVIDER.substring(0, len);\\n    }\\n    private static String spaces(int len) {\\n        return (len > SPACES.length()) ? SPACES\\n                                       : SPACES.substring(0, len);\\n    }\\n    private static String pad(String inString, int fulllen,\\n                              boolean rightJustify, boolean doPad) {\\n        if (!doPad) {\\n            return inString;\\n        }\\n        int len = fulllen - inString.length();\\n        if (len < 1) {\\n            return inString;\\n        }\\n        String pad = SqlFile.spaces(len);\\n        return ((rightJustify ? pad\\n                              : \\\"\\\") + inString + (rightJustify ? \\\"\\\"\\n                                                               : pad));\\n    }\\n    private void showHistory() throws BadSpecial {\\n        if (history == null) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_UNAVAILABLE));\\n        }\\n        if (history.size() < 1) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_NONE));\\n        }\\n        for (int i = 0; i < history.size(); i++) {\\n            psStd.println(\\\"#\\\" + (i + oldestHist) + \\\" or \\\"\\n                    + (i - history.size()) + ':');\\n            psStd.println((String) history.get(i));\\n        }\\n        if (buffer != null) {\\n            psStd.println(rb.getString(SqltoolRB.EDITBUFFER_CONTENTS, buffer));\\n        }\\n        psStd.println();\\n        psStd.println(rb.getString(SqltoolRB.BUFFER_INSTRUCTIONS));\\n    }\\n    private String commandFromHistory(int inIndex) throws BadSpecial {\\n        int index = inIndex;  \\n        if (history == null) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_UNAVAILABLE));\\n        }\\n        if (index == 0) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_NUMBER_REQ));\\n        }\\n        if (index > 0) {\\n                        index -= oldestHist;\\n            if (index < 0) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_BACKTO,\\n                       oldestHist));\\n            }\\n            if (index >= history.size()) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_UPTO,\\n                       history.size() + oldestHist - 1));\\n            }\\n        } else {\\n                        index += history.size();\\n            if (index < 0) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_BACK,\\n                       history.size()));\\n            }\\n        }\\n        return (String) history.get(index);\\n    }\\n    private void setBuf(String newContent) {\\n        buffer = new String(newContent);\\n                bufContainsSql = false;\\n    }\\n    int oldestHist = 1;\\n    boolean bufContainsSql = true;\\n    private void historize() {\\n        if (history == null || buffer == null) {\\n            return;\\n        }\\n        if (history.size() > 0 &&\\n                history.get(history.size() - 1).equals(buffer)) {\\n                        return;\\n        }\\n        history.add(buffer);\\n        if (history.size() <= maxHistoryLength) {\\n            return;\\n        }\\n        history.remove(0);\\n        oldestHist++;\\n    }\\n    private void describe(String tableName,\\n                          String inFilter) throws SQLException {\\n        String    filter = inFilter;\\n        List      rows        = new ArrayList();\\n        String[]  headerArray = {\\n            rb.getString(SqltoolRB.DESCRIBE_TABLE_NAME),\\n            rb.getString(SqltoolRB.DESCRIBE_TABLE_DATATYPE),\\n            rb.getString(SqltoolRB.DESCRIBE_TABLE_WIDTH),\\n            rb.getString(SqltoolRB.DESCRIBE_TABLE_NONULLS),\\n        };\\n        String[]  fieldArray;\\n        int[]     maxWidth  = {\\n            0, 0, 0, 0\\n        };\\n        boolean[] rightJust = {\\n            false, false, true, false\\n        };\\n                for (int i = 0; i < headerArray.length; i++) {\\n            if (htmlMode) {\\n                continue;\\n            }\\n            if (headerArray[i].length() > maxWidth[i]) {\\n                maxWidth[i] = headerArray[i].length();\\n            }\\n        }\\n        Statement statement = curConn.createStatement();\\n        ResultSet r         = null;\\n        try {\\n            statement.execute(\\\"SELECT * FROM \\\" + tableName + \\\" WHERE 1 = 2\\\");\\n            r = statement.getResultSet();\\n            ResultSetMetaData m    = r.getMetaData();\\n            int               cols = m.getColumnCount();\\n            for (int i = 0; i < cols; i++) {\\n                fieldArray    = new String[4];\\n                fieldArray[0] = m.getColumnName(i + 1);\\n                if (filter != null && fieldArray[0].indexOf(filter) < 0) {\\n                    continue;\\n                }\\n                fieldArray[1] = m.getColumnTypeName(i + 1);\\n                fieldArray[2] = Integer.toString(m.getColumnDisplaySize(i + 1));\\n                fieldArray[3] =\\n                    ((m.isNullable(i + 1) == java.sql.ResultSetMetaData.columnNullable)\\n                     ? (htmlMode ? \\\"&nbsp;\\\"\\n                                 : \\\"\\\")\\n                     : \\\"*\\\");\\n                rows.add(fieldArray);\\n                for (int j = 0; j < fieldArray.length; j++) {\\n                    if (fieldArray[j].length() > maxWidth[j]) {\\n                        maxWidth[j] = fieldArray[j].length();\\n                    }\\n                }\\n            }\\n                        condlPrint(\\\"<TABLE border='1'>\\\" + LS + SqlFile.htmlRow(COL_HEAD) + LS\\n                       + PRE_TD, true);\\n            for (int i = 0; i < headerArray.length; i++) {\\n                condlPrint(\\\"<TD>\\\" + headerArray[i] + \\\"</TD>\\\", true);\\n                condlPrint(((i > 0) ? SqlFile.spaces(2)\\n                                    : \\\"\\\") + SqlFile.pad(headerArray[i], maxWidth[i],\\n                                                rightJust[i],\\n                                                (i < headerArray.length - 1\\n                                                 || rightJust[i])), false);\\n            }\\n            condlPrintln(LS + PRE_TR + \\\"</TR>\\\", true);\\n            condlPrintln(\\\"\\\", false);\\n            if (!htmlMode) {\\n                for (int i = 0; i < headerArray.length; i++) {\\n                    condlPrint(((i > 0) ? SqlFile.spaces(2)\\n                                        : \\\"\\\") + SqlFile.divider(maxWidth[i]), false);\\n                }\\n                condlPrintln(\\\"\\\", false);\\n            }\\n            for (int i = 0; i < rows.size(); i++) {\\n                condlPrint(SqlFile.htmlRow(((i % 2) == 0) ? COL_EVEN\\n                                                  : COL_ODD) + LS\\n                                                  + PRE_TD, true);\\n                fieldArray = (String[]) rows.get(i);\\n                for (int j = 0; j < fieldArray.length; j++) {\\n                    condlPrint(\\\"<TD>\\\" + fieldArray[j] + \\\"</TD>\\\", true);\\n                    condlPrint(((j > 0) ? SqlFile.spaces(2)\\n                                        : \\\"\\\") + SqlFile.pad(\\n                                            fieldArray[j], maxWidth[j],\\n                                            rightJust[j],\\n                                            (j < fieldArray.length - 1\\n                                             || rightJust[j])), false);\\n                }\\n                condlPrintln(LS + PRE_TR + \\\"</TR>\\\", true);\\n                condlPrintln(\\\"\\\", false);\\n            }\\n            condlPrintln(LS + \\\"</TABLE>\\\" + LS + \\\"<HR>\\\", true);\\n        } finally {\\n            try {\\n                if (r != null) {\\n                    r.close();\\n                    r = null;\\n                }\\n                statement.close();\\n            } catch (Exception e) {}\\n        }\\n    }\\n    private boolean eval(String[] inTokens) throws BadSpecial {\\n                        boolean  negate = inTokens.length > 0 && inTokens[0].equals(\\\"!\\\");\\n        String[] tokens = new String[negate ? (inTokens.length - 1)\\n                                            : inTokens.length];\\n        String inToken;\\n        for (int i = 0; i < tokens.length; i++) {\\n            inToken = inTokens[i + (negate ? 1 : 0)];\\n            if (inToken.length() > 1 && inToken.charAt(0) == '*') {\\n                tokens[i] = (String) userVars.get(inToken.substring(1));\\n            } else {\\n                tokens[i] = inTokens[i + (negate ? 1 : 0)];\\n            }\\n                                    if (tokens[i] == null) {\\n                tokens[i] = \\\"\\\";\\n            }\\n        }\\n        if (tokens.length == 1) {\\n            return (tokens[0].length() > 0 &&!tokens[0].equals(\\\"0\\\")) ^ negate;\\n        }\\n        if (tokens.length == 3) {\\n            if (tokens[1].equals(\\\"==\\\")) {\\n                return tokens[0].equals(tokens[2]) ^ negate;\\n            }\\n            if (tokens[1].equals(\\\"!=\\\") || tokens[1].equals(\\\"<>\\\")\\n                    || tokens[1].equals(\\\"><\\\")) {\\n                return (!tokens[0].equals(tokens[2])) ^ negate;\\n            }\\n            if (tokens[1].equals(\\\">\\\")) {\\n                return (tokens[0].length() > tokens[2].length() || ((tokens[0].length() == tokens[2].length()) && tokens[0].compareTo(tokens[2]) > 0))\\n                       ^ negate;\\n            }\\n            if (tokens[1].equals(\\\"<\\\")) {\\n                return (tokens[2].length() > tokens[0].length() || ((tokens[2].length() == tokens[0].length()) && tokens[2].compareTo(tokens[0]) > 0))\\n                       ^ negate;\\n            }\\n        }\\n        throw new BadSpecial(rb.getString(SqltoolRB.LOGICAL_UNRECOGNIZED));\\n    }\\n    private void closeQueryOutputStream() {\\n        if (pwQuery == null) {\\n            return;\\n        }\\n        if (htmlMode) {\\n            pwQuery.println(\\\"</BODY></HTML>\\\");\\n            pwQuery.flush();\\n        }\\n        pwQuery.close();\\n        pwQuery = null;\\n    }\\n    private void condlPrintln(String s, boolean printHtml) {\\n        if ((printHtml &&!htmlMode) || (htmlMode &&!printHtml)) {\\n            return;\\n        }\\n        psStd.println(s);\\n        if (pwQuery != null) {\\n            pwQuery.println(s);\\n            pwQuery.flush();\\n        }\\n    }\\n    private void condlPrint(String s, boolean printHtml) {\\n        if ((printHtml &&!htmlMode) || (htmlMode &&!printHtml)) {\\n            return;\\n        }\\n        psStd.print(s);\\n        if (pwQuery != null) {\\n            pwQuery.print(s);\\n            pwQuery.flush();\\n        }\\n    }\\n    private String formatNicely(Map map, boolean withValues) {\\n        String       key;\\n        StringBuffer sb = new StringBuffer();\\n        Iterator     it = (new TreeMap(map)).keySet().iterator();\\n        if (withValues) {\\n            SqlFile.appendLine(sb, rb.getString(SqltoolRB.PL_LIST_PARENS));\\n        } else {\\n            SqlFile.appendLine(sb, rb.getString(SqltoolRB.PL_LIST_LENGTHS));\\n        }\\n        while (it.hasNext()) {\\n            key = (String) it.next();\\n            String s = (String) map.get(key);\\n            SqlFile.appendLine(sb, \\\"    \\\" + key + \\\": \\\" + (withValues ? (\\\"(\\\" + s + ')')\\n                                                        : Integer.toString(\\n                                                        s.length())));\\n        }\\n        return sb.toString();\\n    }\\n    private void dump(String varName,\\n                      File dumpFile) throws IOException, BadSpecial {\\n        String val = (String) userVars.get(varName);\\n        if (val == null) {\\n            throw new BadSpecial(rb.getString(\\n                    SqltoolRB.PLVAR_UNDEFINED, varName));\\n        }\\n        OutputStreamWriter osw = ((charset == null)\\n                ? (new OutputStreamWriter(new FileOutputStream(dumpFile)))\\n                : (new OutputStreamWriter(new FileOutputStream(dumpFile),\\n                            charset)));\\n        try {\\n            osw.write(val);\\n            if (val.length() > 0) {\\n                char lastChar = val.charAt(val.length() - 1);\\n                if (lastChar != '\\\\n' && lastChar != '\\\\r') {\\n                    osw.write(LS);\\n                }\\n            }\\n            osw.flush();\\n        } finally {\\n            osw.close();\\n        }\\n                        stdprintln(rb.getString(SqltoolRB.FILE_WROTECHARS,\\n                Long.toString(dumpFile.length()), dumpFile.toString()));\\n    }\\n    byte[] binBuffer = null;\\n    private void dump(File dumpFile) throws IOException, BadSpecial {\\n        if (binBuffer == null) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.BINBUFFER_EMPTY));\\n        }\\n        FileOutputStream fos = new FileOutputStream(dumpFile);\\n        int len = 0;\\n        try {\\n            fos.write(binBuffer);\\n            len = binBuffer.length;\\n            binBuffer = null;\\n            fos.flush();\\n        } finally {\\n            fos.close();\\n        }\\n        stdprintln(rb.getString(SqltoolRB.FILE_WROTECHARS,\\n                len, dumpFile.toString()));\\n    }\\n    public String streamToString(InputStream is, String cs)\\n            throws IOException {\\n        try {\\n            byte[] ba = null;\\n            int bytesread = 0;\\n            int retval;\\n            try {\\n                ba = new byte[is.available()];\\n            } catch (RuntimeException re) {\\n                throw new IOException(rb.getString(SqltoolRB.READ_TOOBIG));\\n            }\\n            while (bytesread < ba.length &&\\n                    (retval = is.read(\\n                            ba, bytesread, ba.length - bytesread)) > 0) {\\n                bytesread += retval;\\n            }\\n            if (bytesread != ba.length) {\\n                throw new IOException(rb.getString(SqltoolRB.READ_PARTIAL,\\n                            bytesread,\\n                            ba.length));\\n            }\\n            try {\\n                return (cs == null) ? (new String(ba))\\n                                         : (new String(ba, cs));\\n            } catch (UnsupportedEncodingException uee) {\\n                throw new RuntimeException(uee);\\n            } catch (RuntimeException re) {\\n                throw new IOException(rb.getString(SqltoolRB.READ_CONVERTFAIL));\\n            }\\n        } finally {\\n            is.close();\\n        }\\n    }\\n    private void load(String varName, File asciiFile, String cs)\\n            throws IOException {\\n        String string = streamToString(new FileInputStream(asciiFile), cs);\\n        userVars.put(varName, string);\\n        updateUserSettings();\\n    }\\n    static public byte[] streamToBytes(InputStream is) throws IOException {\\n        byte[]                xferBuffer = new byte[10240];\\n        ByteArrayOutputStream baos       = new ByteArrayOutputStream();\\n        int                   i;\\n        while ((i = is.read(xferBuffer)) > 0) {\\n            baos.write(xferBuffer, 0, i);\\n        }\\n        return baos.toByteArray();\\n    }\\n    static public byte[] loadBinary(File binFile) throws IOException {\\n        byte[]                xferBuffer = new byte[10240];\\n        ByteArrayOutputStream baos       = new ByteArrayOutputStream();\\n        int                   i;\\n        FileInputStream       fis        = new FileInputStream(binFile);\\n        try {\\n            while ((i = fis.read(xferBuffer)) > 0) {\\n                baos.write(xferBuffer, 0, i);\\n            }\\n        } finally {\\n            fis.close();\\n        }\\n        byte[] ba = baos.toByteArray();\\n        return ba;\\n    }\\n    public static boolean canDisplayType(int i) {\\n        switch (i) {\\n                        case java.sql.Types.BLOB :\\n            case java.sql.Types.JAVA_OBJECT :\\n                                    case java.sql.Types.OTHER :\\n            case java.sql.Types.STRUCT :\\n                                return false;\\n        }\\n        return true;\\n    }\\n        private static final int JDBC3_BOOLEAN  = 16;\\n    private static final int JDBC3_DATALINK = 70;\\n    public static String sqlTypeToString(int i) {\\n        switch (i) {\\n            case java.sql.Types.ARRAY :\\n                return \\\"ARRAY\\\";\\n            case java.sql.Types.BIGINT :\\n                return \\\"BIGINT\\\";\\n            case java.sql.Types.BINARY :\\n                return \\\"BINARY\\\";\\n            case java.sql.Types.BIT :\\n                return \\\"BIT\\\";\\n            case java.sql.Types.BLOB :\\n                return \\\"BLOB\\\";\\n            case JDBC3_BOOLEAN :\\n                return \\\"BOOLEAN\\\";\\n            case java.sql.Types.CHAR :\\n                return \\\"CHAR\\\";\\n            case java.sql.Types.CLOB :\\n                return \\\"CLOB\\\";\\n            case JDBC3_DATALINK :\\n                return \\\"DATALINK\\\";\\n            case java.sql.Types.DATE :\\n                return \\\"DATE\\\";\\n            case java.sql.Types.DECIMAL :\\n                return \\\"DECIMAL\\\";\\n            case java.sql.Types.DISTINCT :\\n                return \\\"DISTINCT\\\";\\n            case java.sql.Types.DOUBLE :\\n                return \\\"DOUBLE\\\";\\n            case java.sql.Types.FLOAT :\\n                return \\\"FLOAT\\\";\\n            case java.sql.Types.INTEGER :\\n                return \\\"INTEGER\\\";\\n            case java.sql.Types.JAVA_OBJECT :\\n                return \\\"JAVA_OBJECT\\\";\\n            case java.sql.Types.LONGVARBINARY :\\n                return \\\"LONGVARBINARY\\\";\\n            case java.sql.Types.LONGVARCHAR :\\n                return \\\"LONGVARCHAR\\\";\\n            case java.sql.Types.NULL :\\n                return \\\"NULL\\\";\\n            case java.sql.Types.NUMERIC :\\n                return \\\"NUMERIC\\\";\\n            case java.sql.Types.OTHER :\\n                return \\\"OTHER\\\";\\n            case java.sql.Types.REAL :\\n                return \\\"REAL\\\";\\n            case java.sql.Types.REF :\\n                return \\\"REF\\\";\\n            case java.sql.Types.SMALLINT :\\n                return \\\"SMALLINT\\\";\\n            case java.sql.Types.STRUCT :\\n                return \\\"STRUCT\\\";\\n            case java.sql.Types.TIME :\\n                return \\\"TIME\\\";\\n            case java.sql.Types.TIMESTAMP :\\n                return \\\"TIMESTAMP\\\";\\n            case java.sql.Types.TINYINT :\\n                return \\\"TINYINT\\\";\\n            case java.sql.Types.VARBINARY :\\n                return \\\"VARBINARY\\\";\\n            case java.sql.Types.VARCHAR :\\n                return \\\"VARCHAR\\\";\\n        }\\n        return \\\"Unknown type \\\" + i;\\n    }\\n    public void dsvSafe(String s) throws SqlToolError {\\n        if (pwDsv == null || dsvColDelim == null || dsvRowDelim == null\\n                || nullRepToken == null) {\\n            throw new RuntimeException(\\n                \\\"Assertion failed.  \\\\n\\\"\\n                + \\\"dsvSafe called when DSV settings are incomplete\\\");\\n        }\\n        if (s == null) {\\n            return;\\n        }\\n        if (s.indexOf(dsvColDelim) > 0) {\\n            throw new SqlToolError(rb.getString(SqltoolRB.DSV_COLDELIM_PRESENT,\\n                        dsvColDelim));\\n        }\\n        if (s.indexOf(dsvRowDelim) > 0) {\\n            throw new SqlToolError(rb.getString(SqltoolRB.DSV_ROWDELIM_PRESENT,\\n                        dsvRowDelim));\\n        }\\n        if (s.trim().equals(nullRepToken)) {\\n                                    throw new SqlToolError(rb.getString(SqltoolRB.DSV_NULLREP_PRESENT,\\n                        nullRepToken));\\n        }\\n    }\\n    public static String convertEscapes(String inString) {\\n        if (inString == null) {\\n            return null;\\n        }\\n        return convertNumericEscapes(\\n                convertEscapes(convertEscapes(convertEscapes(convertEscapes(\\n                    convertEscapes(inString, \\\"\\\\\\\\n\\\", \\\"\\\\n\\\"), \\\"\\\\\\\\r\\\", \\\"\\\\r\\\"),\\n                \\\"\\\\\\\\t\\\", \\\"\\\\t\\\"), \\\"\\\\\\\\\\\\\\\\\\\", \\\"\\\\\\\\\\\"),\\n            \\\"\\\\\\\\f\\\", \\\"\\\\f\\\")\\n        );\\n    }\\n    private static String convertNumericEscapes(String string) {\\n        String workString = string;\\n        int i = 0;\\n        for (char dig = '0'; dig <= '9'; dig++) {\\n            while ((i = workString.indexOf(\\\"\\\\\\\\\\\" + dig, i)) > -1\\n                    && i < workString.length() - 1) {\\n                workString = convertNumericEscape(string, i);\\n            }\\n            while ((i = workString.indexOf(\\\"\\\\\\\\x\\\" + dig, i)) > -1\\n                    && i < workString.length() - 1) {\\n                workString = convertNumericEscape(string, i);\\n            }\\n            while ((i = workString.indexOf(\\\"\\\\\\\\X\\\" + dig, i)) > -1\\n                    && i < workString.length() - 1) {\\n                workString = convertNumericEscape(string, i);\\n            }\\n        }\\n        return workString;\\n    }\\n    private static String convertNumericEscape(String string, int offset) {\\n        int post = -1;\\n        int firstDigit = -1;\\n        int radix = -1;\\n        if (Character.toUpperCase(string.charAt(offset + 1)) == 'X') {\\n            firstDigit = offset + 2;\\n            radix = 16;\\n            post = firstDigit + 2;\\n            if (post > string.length()) post = string.length();\\n        } else {\\n            firstDigit = offset + 1;\\n            radix = (Character.toUpperCase(string.charAt(firstDigit)) == '0')\\n                    ? 8 : 10;\\n            for (post = firstDigit + 1; post < string.length()\\n                    && Character.isDigit(string.charAt(post)); post++) ;\\n        }\\n        return string.substring(0, offset) + ((char)\\n                Integer.parseInt(string.substring(firstDigit, post), radix))\\n                + string.substring(post);\\n    }\\n    private static String convertEscapes(String string, String from, String to) {\\n        String workString = string;\\n        int i = 0;\\n        int fromLen = from.length();\\n        while ((i = workString.indexOf(from, i)) > -1\\n                && i < workString.length() - 1) {\\n            workString = workString.substring(0, i) + to\\n                         + workString.substring(i + fromLen);\\n        }\\n        return workString;\\n    }\\n    public void importDsv(String filePath, String skipPrefix)\\n            throws SqlToolError {\\n        byte[] bfr  = null;\\n        File   file = new File(filePath);\\n        SortedMap constColMap = null;\\n        if (dsvConstCols != null) {\\n                                    constColMap = new TreeMap();\\n            String[] constPairs = dsvConstCols.split(\\\"\\\\\\\\Q\\\"\\n                    + dsvColDelim + \\\"\\\\\\\\E\\\\\\\\s*\\\");\\n            int firstEq;\\n            String n;\\n            for (int i = 0; i < constPairs.length; i++) {\\n                firstEq = constPairs[i].indexOf('=');\\n                n = constPairs[i].substring(0, firstEq).trim().toLowerCase();\\n                if (n.trim().length() < 1) {\\n                    throw new SqlToolError(\\n                            rb.getString(SqltoolRB.DSV_CONSTCOLS_NULLCOL));\\n                }\\n                constColMap.put(n, constPairs[i].substring(firstEq + 1));\\n            }\\n        }\\n        Set skipCols = null;\\n        if (dsvSkipCols != null) {\\n            skipCols = new HashSet();\\n            String[] skipColsArray = dsvSkipCols.split(\\\"\\\\\\\\s*\\\\\\\\Q\\\"\\n                    + dsvColDelim + \\\"\\\\\\\\E\\\\\\\\s*\\\");\\n            for (int i = 0; i < skipColsArray.length; i++) {\\n                skipCols.add(skipColsArray[i].toLowerCase());\\n            }\\n        }\\n        if (!file.canRead()) {\\n            throw new SqlToolError(rb.getString(SqltoolRB.FILE_READFAIL,\\n                    file.toString()));\\n        }\\n        try {\\n            bfr = new byte[(int) file.length()];\\n        } catch (RuntimeException re) {\\n            throw new SqlToolError(rb.getString(SqltoolRB.READ_TOOBIG), re);\\n        }\\n        int bytesread = 0;\\n        int retval;\\n        InputStream is = null;\\n        try {\\n            is = new FileInputStream(file);\\n            while (bytesread < bfr.length &&\\n                    (retval = is.read(bfr, bytesread, bfr.length - bytesread))\\n                    > 0) {\\n                bytesread += retval;\\n            }\\n        } catch (IOException ioe) {\\n            throw new SqlToolError(ioe);\\n        } finally {\\n            if (is != null) try {\\n                is.close();\\n            } catch (IOException ioe) {\\n                errprintln(rb.getString(SqltoolRB.INPUTFILE_CLOSEFAIL)\\n                        + \\\": \\\" + ioe);\\n            }\\n        }\\n        if (bytesread != bfr.length) {\\n            throw new SqlToolError(rb.getString(SqltoolRB.READ_PARTIAL,\\n                    bytesread, bfr.length));\\n        }\\n        String string = null;\\n        String dateString;\\n        try {\\n            string = ((charset == null)\\n                    ? (new String(bfr)) : (new String(bfr, charset)));\\n        } catch (UnsupportedEncodingException uee) {\\n            throw new RuntimeException(uee);\\n        } catch (RuntimeException re) {\\n            throw new SqlToolError(rb.getString(SqltoolRB.READ_CONVERTFAIL),\\n                    re);\\n        }\\n        List     headerList = new ArrayList();\\n        String    tableName = dsvTargetTable;\\n                int recEnd = -1000;                                     int colStart;\\n        int colEnd;\\n                int lineCount = 0;         int recStart = -1;\\n        String trimmedLine = null;\\n        boolean switching = false;\\n        while (true) {\\n            recStart = (recStart < 0) ? 0 : (recEnd + dsvRowDelim.length());\\n            if (recStart > string.length() - 2) {\\n                throw new SqlToolError(rb.getString(SqltoolRB.DSV_HEADER_NONE));\\n            }\\n            recEnd = string.indexOf(dsvRowDelim, recStart);\\n            lineCount++; \\n            if (recEnd < 0) {\\n                                recEnd = string.length();\\n            }\\n            trimmedLine = string.substring(recStart, recEnd).trim();\\n            if (trimmedLine.length() < 1\\n                    || (skipPrefix != null\\n                            && trimmedLine.startsWith(skipPrefix))) {\\n                continue;\\n            }\\n            if (trimmedLine.startsWith(\\\"targettable=\\\")) {\\n                if (tableName == null) {\\n                    tableName = trimmedLine.substring(\\n                            \\\"targettable=\\\".length()).trim();\\n                }\\n                continue;\\n            }\\n            if (trimmedLine.equals(\\\"headerswitch{\\\")) {\\n                if (tableName == null) {\\n                    throw new SqlToolError(rb.getString(\\n                            SqltoolRB.DSV_HEADER_NOSWITCHTARG, lineCount));\\n                }\\n                switching = true;\\n                continue;\\n            }\\n            if (trimmedLine.equals(\\\"}\\\")) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.DSV_HEADER_NOSWITCHMATCH, lineCount));\\n            }\\n            if (!switching) {\\n                break;\\n            }\\n            int colonAt = trimmedLine.indexOf(':');\\n            if (colonAt < 1 || colonAt == trimmedLine.length() - 1) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.DSV_HEADER_NONSWITCHED, lineCount));\\n            }\\n            String matcher = trimmedLine.substring(0, colonAt).trim();\\n                                    if (matcher.equals(\\\"*\\\") || matcher.equalsIgnoreCase(tableName)){\\n                recStart = 1 + string.indexOf(':', recStart);\\n                break;\\n            }\\n                    }\\n        String headerLine = string.substring(recStart, recEnd);\\n        colStart = recStart;\\n        colEnd   = -1;\\n        String colName;\\n        while (true) {\\n            if (colEnd == recEnd) {\\n                                break;\\n            }\\n            colEnd = string.indexOf(dsvColDelim, colStart);\\n            if (colEnd < 0 || colEnd > recEnd) {\\n                colEnd = recEnd;\\n            }\\n            if (colEnd - colStart < 1) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.DSV_NOCOLHEADER,\\n                        headerList.size() + 1, lineCount));\\n            }\\n            colName = string.substring(colStart, colEnd).trim().toLowerCase();\\n            headerList.add(\\n                (colName.equals(\\\"-\\\")\\n                        || (skipCols != null\\n                                && skipCols.remove(colName))\\n                        || (constColMap != null\\n                                && constColMap.containsKey(colName))\\n                )\\n                ? ((String) null)\\n                : colName);\\n            colStart = colEnd + dsvColDelim.length();\\n        } if (skipCols != null && skipCols.size() > 0) {\\n            throw new SqlToolError(rb.getString(\\n                    SqltoolRB.DSV_SKIPCOLS_MISSING, skipCols.toString()));\\n        }\\n        boolean oneCol = false;          for (int i = 0; i < headerList.size(); i++) {\\n            if (headerList.get(i) != null) {\\n                oneCol = true;\\n                break;\\n            }\\n        }\\n        if (oneCol == false) {\\n                                                throw new SqlToolError(rb.getString(SqltoolRB.DSV_NOCOLSLEFT,\\n                    dsvSkipCols));\\n        }\\n        int inputColHeadCount = headerList.size();\\n        if (constColMap != null) {\\n            headerList.addAll(constColMap.keySet());\\n        }\\n        String[]  headers   = (String[]) headerList.toArray(new String[0]);\\n        if (tableName == null) {\\n            tableName = file.getName();\\n            int i = tableName.lastIndexOf('.');\\n            if (i > 0) {\\n                tableName = tableName.substring(0, i);\\n            }\\n        }\\n        StringBuffer tmpSb = new StringBuffer();\\n        List tmpList = new ArrayList();\\n        int skippers = 0;\\n        for (int i = 0; i < headers.length; i++) {\\n            if (headers[i] == null) {\\n                skippers++;\\n                continue;\\n            }\\n            if (tmpSb.length() > 0) {\\n                tmpSb.append(\\\", \\\");\\n            }\\n            tmpSb.append(headers[i]);\\n            tmpList.add(headers[i]);\\n        }\\n        boolean[] autonulls = new boolean[headers.length - skippers];\\n        boolean[] parseDate = new boolean[autonulls.length];\\n        boolean[] parseBool = new boolean[autonulls.length];\\n        String[] insertFieldName = (String[]) tmpList.toArray(new String[] {});\\n        StringBuffer sb = new StringBuffer(\\\"INSERT INTO \\\" + tableName + \\\" (\\\"\\n                                           + tmpSb + \\\") VALUES (\\\");\\n        StringBuffer typeQuerySb = new StringBuffer(\\\"SELECT \\\" + tmpSb\\n            + \\\" FROM \\\" + tableName + \\\" WHERE 1 = 2\\\");\\n        try {\\n            ResultSetMetaData rsmd = curConn.createStatement().executeQuery(\\n                typeQuerySb.toString()).getMetaData();\\n            if (rsmd.getColumnCount() != autonulls.length) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.DSV_METADATA_MISMATCH));\\n                                                                                            }\\n            for (int i = 0; i < autonulls.length; i++) {\\n                autonulls[i] = true;\\n                parseDate[i] = false;\\n                parseBool[i] = false;\\n                switch(rsmd.getColumnType(i + 1)) {\\n                    case java.sql.Types.BOOLEAN:\\n                        parseBool[i] = true;\\n                        break;\\n                    case java.sql.Types.VARBINARY :\\n                    case java.sql.Types.VARCHAR :\\n                    case java.sql.Types.ARRAY :\\n                                            case java.sql.Types.BLOB :\\n                    case java.sql.Types.CLOB :\\n                    case java.sql.Types.LONGVARBINARY :\\n                    case java.sql.Types.LONGVARCHAR :\\n                        autonulls[i] = false;\\n                                                                                                break;\\n                    case java.sql.Types.DATE:\\n                    case java.sql.Types.TIME:\\n                    case java.sql.Types.TIMESTAMP:\\n                        parseDate[i] = true;\\n                }\\n            }\\n        } catch (SQLException se) {\\n            throw new SqlToolError(rb.getString(\\n                    SqltoolRB.QUERY_METADATAFAIL,\\n                            typeQuerySb.toString()), se);\\n        }\\n        for (int i = 0; i < autonulls.length; i++) {\\n            if (i > 0) {\\n                sb.append(\\\", \\\");\\n            }\\n            sb.append('?');\\n        }\\n                int rejectCount = 0;\\n        File rejectFile = null;\\n        File rejectReportFile = null;\\n        PrintWriter rejectWriter = null;\\n        PrintWriter rejectReportWriter = null;\\n        if (dsvRejectFile != null) try {\\n            rejectFile = new File(dsvRejectFile);\\n            rejectWriter = new PrintWriter((charset == null)\\n                    ? (new OutputStreamWriter(new FileOutputStream(rejectFile)))\\n                    : (new OutputStreamWriter(new FileOutputStream(rejectFile),\\n                            charset)));\\n                                                                        rejectWriter.print(headerLine + dsvRowDelim);\\n        } catch (IOException ioe) {\\n            throw new SqlToolError(rb.getString(\\n                    SqltoolRB.DSV_REJECTFILE_SETUPFAIL, dsvRejectFile), ioe);\\n        }\\n        if (dsvRejectReport != null) try {\\n            rejectReportFile = new File(dsvRejectReport);\\n            rejectReportWriter = new PrintWriter((charset == null)\\n                    ? (new OutputStreamWriter(\\n                            new FileOutputStream(rejectReportFile)))\\n                    : (new OutputStreamWriter(\\n                            new FileOutputStream(rejectReportFile), charset)));\\n                                                                        rejectReportWriter.println(rb.getString(\\n                    SqltoolRB.REJECTREPORT_TOP, new String[] {\\n                        (new java.util.Date()).toString(),\\n                        file.getPath(),\\n                        ((rejectFile == null) ? rb.getString(SqltoolRB.NONE)\\n                                        : rejectFile.getPath()),\\n                        ((rejectFile == null) ? null : rejectFile.getPath()),\\n                    }));\\n        } catch (IOException ioe) {\\n            throw new SqlToolError(rb.getString(\\n                    SqltoolRB.DSV_REJECTREPORT_SETUPFAIL, dsvRejectReport),\\n                            ioe);\\n        }\\n        int recCount = 0;\\n        int skipCount = 0;\\n        PreparedStatement ps = null;\\n        boolean importAborted = false;\\n        try {\\n            try {\\n                ps = curConn.prepareStatement(sb.toString() + ')');\\n            } catch (SQLException se) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.INSERTION_PREPAREFAIL, sb.toString()), se);\\n            }\\n            String[] dataVals = new String[autonulls.length];\\n                        int      readColCount;\\n            int      storeColCount;\\n            String   currentFieldName = null;\\n                        while (true) try { try {\\n                recStart = recEnd + dsvRowDelim.length();\\n                if (recStart >= string.length()) {\\n                    break;\\n                }\\n                recEnd = string.indexOf(dsvRowDelim, recStart);\\n                lineCount++; \\n                if (recEnd < 0) {\\n                                        recEnd = string.length();\\n                }\\n                trimmedLine = string.substring(recStart, recEnd).trim();\\n                if (trimmedLine.length() < 1) {\\n                    continue;                  }\\n                if (skipPrefix != null\\n                        && trimmedLine.startsWith(skipPrefix)) {\\n                    skipCount++;\\n                    continue;\\n                }\\n                if (switching) {\\n                    if (trimmedLine.equals(\\\"}\\\")) {\\n                        switching = false;\\n                        continue;\\n                    }\\n                    int colonAt = trimmedLine.indexOf(':');\\n                    if (colonAt < 1 || colonAt == trimmedLine.length() - 1) {\\n                        throw new SqlToolError(rb.getString(\\n                                SqltoolRB.DSV_HEADER_MATCHERNONHEAD,\\n                                        lineCount));\\n                    }\\n                    continue;\\n                }\\n                                recCount++;\\n                colStart = recStart;\\n                colEnd   = -1;\\n                readColCount = 0;\\n                storeColCount = 0;\\n                while (true) {\\n                    if (colEnd == recEnd) {\\n                                                break;\\n                    }\\n                    colEnd = string.indexOf(dsvColDelim, colStart);\\n                    if (colEnd < 0 || colEnd > recEnd) {\\n                        colEnd = recEnd;\\n                    }\\n                    if (readColCount == inputColHeadCount) {\\n                        throw new RowError(rb.getString(\\n                                SqltoolRB.DSV_COLCOUNT_MISMATCH,\\n                                        inputColHeadCount, 1 + readColCount));\\n                    }\\n                    if (headers[readColCount++] != null) {\\n                        dataVals[storeColCount++] =\\n                                string.substring(colStart, colEnd);\\n                    }\\n                    colStart             = colEnd + dsvColDelim.length();\\n                }\\n                if (readColCount < inputColHeadCount) {\\n                    throw new RowError(rb.getString(\\n                            SqltoolRB.DSV_COLCOUNT_MISMATCH,\\n                                    inputColHeadCount, readColCount));\\n                }\\n                if (constColMap != null) {\\n                    Iterator it = constColMap.values().iterator();\\n                    while (it.hasNext()) {\\n                        dataVals[storeColCount++] = (String) it.next();\\n                    }\\n                }\\n                if (storeColCount != dataVals.length) {\\n                    throw new RowError(rb.getString(\\n                            SqltoolRB.DSV_INSERTCOL_MISMATCH,\\n                                    dataVals.length, storeColCount));\\n                }\\n                for (int i = 0; i < dataVals.length; i++) {\\n                    currentFieldName = insertFieldName[i];\\n                    if (autonulls[i]) dataVals[i] = dataVals[i].trim();\\n                    if (parseDate[i]) {\\n                        if ((dataVals[i].length() < 1 && autonulls[i])\\n                              || dataVals[i].equals(nullRepToken)) {\\n                            ps.setTimestamp(i + 1, null);\\n                        } else {\\n                            dateString = (dataVals[i].indexOf(':') > 0)\\n                                       ? dataVals[i]\\n                                       : (dataVals[i] + \\\" 0:00:00\\\");\\n                                                                                    try {\\n                                ps.setTimestamp(i + 1,\\n                                        java.sql.Timestamp.valueOf(dateString));\\n                            } catch (IllegalArgumentException iae) {\\n                                throw new RowError(rb.getString(\\n                                        SqltoolRB.TIME_BAD, dateString), iae);\\n                            }\\n                        }\\n                    } else if (parseBool[i]) {\\n                        if ((dataVals[i].length() < 1 && autonulls[i])\\n                              || dataVals[i].equals(nullRepToken)) {\\n                            ps.setNull(i + 1, java.sql.Types.BOOLEAN);\\n                        } else {\\n                            try {\\n                                ps.setBoolean(i + 1, Boolean.valueOf(\\n                                        dataVals[i]).booleanValue());\\n                                                                                            } catch (IllegalArgumentException iae) {\\n                                throw new RowError(rb.getString(\\n                                        SqltoolRB.BOOLEAN_BAD, dataVals[i]),\\n                                                iae);\\n                            }\\n                        }\\n                    } else {\\n                        ps.setString(\\n                            i + 1,\\n                            (((dataVals[i].length() < 1 && autonulls[i])\\n                              || dataVals[i].equals(nullRepToken))\\n                             ? null\\n                             : dataVals[i]));\\n                    }\\n                    currentFieldName = null;\\n                }\\n                retval = ps.executeUpdate();\\n                if (retval != 1) {\\n                    throw new RowError(rb.getString(\\n                            SqltoolRB.INPUTREC_MODIFIED, retval));\\n                }\\n                possiblyUncommitteds.set(true);\\n            } catch (SQLException se) {\\n                throw new RowError(null, se);\\n            } } catch (RowError re) {\\n                rejectCount++;\\n                if (rejectWriter != null || rejectReportWriter != null) {\\n                    if (rejectWriter != null) {\\n                        rejectWriter.print(string.substring(\\n                                recStart, recEnd) + dsvRowDelim);\\n                    }\\n                    if (rejectReportWriter != null) {\\n                        genRejectReportRecord(rejectReportWriter,\\n                                rejectCount, lineCount,\\n                                currentFieldName, re.getMessage(),\\n                                re.getCause());\\n                    }\\n                } else {\\n                    importAborted = true;\\n                    throw new SqlToolError(\\n                            rb.getString(SqltoolRB.DSV_RECIN_FAIL,\\n                                    lineCount, currentFieldName)\\n                            + ((re.getMessage() == null)\\n                                    ? \\\"\\\" : (\\\"  \\\" + re.getMessage())),\\n                            re.getCause());\\n                }\\n            }\\n        } finally {\\n            String summaryString = null;\\n            if (recCount > 0) {\\n                summaryString = rb.getString(SqltoolRB.DSV_IMPORT_SUMMARY,\\n                        new String[] {\\n                                ((skipPrefix == null)\\n                                          ? \\\"\\\" : (\\\"'\\\" + skipPrefix + \\\"'-\\\")),\\n                                Integer.toString(skipCount),\\n                                Integer.toString(rejectCount),\\n                                Integer.toString(recCount - rejectCount),\\n                                (importAborted ? \\\"importAborted\\\" : null)\\n                        });\\n                stdprintln(summaryString);\\n            }\\n            try {\\n                if (recCount > rejectCount && !curConn.getAutoCommit()) {\\n                    stdprintln(rb.getString(SqltoolRB.INSERTIONS_NOTCOMMITTED));\\n                }\\n            } catch (SQLException se) {\\n                stdprintln(rb.getString(SqltoolRB.AUTOCOMMIT_FETCHFAIL));\\n                stdprintln(rb.getString(SqltoolRB.INSERTIONS_NOTCOMMITTED));\\n                                            }\\n            if (rejectWriter != null) {\\n                rejectWriter.flush();\\n                rejectWriter.close();\\n            }\\n            if (rejectReportWriter != null && rejectCount > 0) {\\n                rejectReportWriter.println(rb.getString(\\n                        SqltoolRB.REJECTREPORT_BOTTOM, summaryString, revnum));\\n                rejectReportWriter.flush();\\n                rejectReportWriter.close();\\n            }\\n            if (rejectCount == 0) {\\n                if (rejectFile != null && rejectFile.exists()\\n                        && !rejectFile.delete())\\n                    errprintln(rb.getString(SqltoolRB.DSV_REJECTFILE_PURGEFAIL,\\n                            rejectFile.toString()));\\n                if (rejectReportFile != null && !rejectReportFile.delete())\\n                    errprintln(rb.getString(\\n                            SqltoolRB.DSV_REJECTREPORT_PURGEFAIL,\\n                                    (rejectFile == null)\\n                                            ? null : rejectFile.toString()));\\n                            }\\n        }\\n    }\\n    public static void appendLine(StringBuffer sb, String s) {\\n        sb.append(s + LS);\\n    }\\n    static private String[] genWinArgs(String monolithic) {\\n        List list = new ArrayList();\\n        list.add(\\\"cmd.exe\\\");\\n        list.add(\\\"/y\\\");\\n        list.add(\\\"/c\\\");\\n        Matcher m = wincmdPattern.matcher(monolithic);\\n        String[] internalTokens;\\n        while (m.find()) {\\n            for (int i = 1; i <= m.groupCount(); i++) {\\n                if (m.group(i) == null) continue;\\n                if (m.group(i).length() > 1 && m.group(i).charAt(0) == '\\\"') {\\n                    list.add(m.group(i).substring(1, m.group(i).length() - 1));\\n                    continue;\\n                }\\n                internalTokens = m.group(i).split(\\\"\\\\\\\\s+\\\");\\n                for (int j = 0; j < internalTokens.length; j++)\\n                    list.add(internalTokens[j]);\\n            }\\n        }\\n        return (String[]) list.toArray(new String[] {});\\n    }\\n    private void genRejectReportRecord(PrintWriter pw, int rCount,\\n            int lCount, String field, String eMsg, Throwable cause) {\\n        pw.println(rb.getString(SqltoolRB.REJECTREPORT_ROW,\\n                new String[] {\\n                    ((rCount % 2 == 0) ? \\\"even\\\" : \\\"odd\\\") + \\\"row\\\",\\n                    Integer.toString(rCount),\\n                    Integer.toString(lCount),\\n                    ((field == null) ? \\\"&nbsp;\\\" : field),\\n                    (((eMsg == null) ? \\\"\\\" : eMsg)\\n                            + ((eMsg == null || cause == null) ? \\\"\\\" : \\\"<HR/>\\\")\\n                            + ((cause == null) ? \\\"\\\" : (\\n                                    (cause instanceof SQLException\\n                                            && cause.getMessage() != null)\\n                                        ? cause.getMessage()\\n                                        : cause.toString()\\n                                    )\\n                            )\\n                    )\\n                }));\\n    }\\n}\""
        },
        {
            "content": "The source code of `SqlFile.java` reveals that it is a comprehensive utility class for processing SQL files, handling interactions with databases, and managing various operations such as executing SQL commands, importing/exporting data, and supporting scripting features.\n\n### Key Observations:\n1. **Resource Bundle Usage**:\n   - A significant number of strings used in `SqlFile.java` are fetched from the `SqltoolRB` resource bundle using `rb.getString(...)`. This confirms the earlier finding of strong coupling between `SqlFile.java` and `SqltoolRB.java`.\n   - These strings are primarily used for logging, user prompts, error messages, and configuration settings.\n\n2. **Functionality Overview**:\n   - The class supports reading and executing SQL scripts.\n   - It provides mechanisms for variable substitution, special command execution (e.g., `\\*foreach`, `\\p`, etc.), and handling PL (procedural language) blocks.\n   - There's support for DSV (Delimiter-Separated Values) file imports and exports, including handling complex cases like quoted values, delimiters, and null representations.\n\n3. **Error Handling and Logging**:\n   - Errors are handled through custom exceptions like `BadSpecial`, `SqlToolError`, and others, often reporting messages retrieved from `SqltoolRB`.\n\n4. **Interaction with Other Entities**:\n   - Several internal classes (`BooleanBucket`, `QuitNow`, `BreakException`, etc.) are defined within `SqlFile.java`, indicating tightly encapsulated logic.\n   - Interactions with other entities like `SqlToolSprayer`, `RCData`, or `ValidatingResourceBundle` (from co-change analysis) could be indirect through these internal classes or via shared resource bundles like `SqltoolRB`.\n\n### Next Steps:\nTo ensure synchronization and maintainability, any changes to `SqlFile.java` should consider the following:\n\n- **Update `SqltoolRB.java` if necessary**: Any change in message keys or static variables used by `SqlFile.java` will require corresponding updates in `SqltoolRB.java`.\n- **Review Coupled Entities**: Based on co-change relationships, review other entities like `SqlTool.java` for potential impacts, even though there\u2019s no direct structural coupling.\n- **Test Error Messages and Localization**: Since many strings come from the resource bundle, ensure localization does not break due to changes.\n\nWould you like to proceed with analyzing another entity, such as `SqlTool.java`, for further insights?",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        },
        {
            "role": "user",
            "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
        },
        {
            "content": "Title: Diagnosis of starting entity `SqlFile.java`\n\nChange set: [SqltoolRB, SqlTool, SqlToolSprayer, RCData, ValidatingResourceBundle, RefCapablePropertyResourceBundle, SqlFileScanner, BooleanBucket, SqlToolException, BadCmdline, ContinueException, BreakException, QuitNow, ScriptWriterText, CSVWriter, MainInvoker, RowError, BadSpecial, SharedFields, SimpleLog, PrivateException, RB, TokenList, TarGenerator, TarHeaderFields, PIFData, TarFileOutputStream, TarFileInputStream, TarEntrySupplicant, DbBackup, TarReader, Token, TokenSource, Calculator, Atom, FrameworkLogger, AuthUtils, AuthBeanMultiplexer, ToolLogger]\n\nDetails:\n1. **SqltoolRB**: Strong coupling through extensive use of static strings and resource bundle methods for message retrieval.\n2. **SqlTool**: High co-change confidence (0.72), likely due to shared SQL execution logic or tooling functionality.\n3. **SqlToolSprayer**: Moderate co-change confidence (0.19), possibly involved in distributing SQL commands or configurations.\n4. **RCData**: Moderate co-change confidence (0.16), potentially involved in data handling or configuration management.\n5. **ValidatingResourceBundle**: Related to resource bundle validation and string management, important for message consistency.\n6. **RefCapablePropertyResourceBundle**: Handles property-based localization; changes may affect localized behavior in SqlFile.\n7. **SqlFileScanner**: Although removed, past dependencies suggest historical relevance in file parsing logic.\n8. **BooleanBucket**: Used for state tracking within SqlFile\u2019s internal logic; high coupling in usage patterns.\n9. **SqlToolException**: Common exception class used across SQL tools, including error handling in SqlFile.\n10. **BadCmdline**: Involved in command-line parsing errors; referenced in SqlFile\u2019s special command processing.\n11. **ContinueException / BreakException / QuitNow**: Control flow exceptions used in scripting blocks (e.g., PL/SQL-like scripts).\n12. **ScriptWriterText / CSVWriter**: Related to output generation; used when writing formatted SQL results.\n13. **MainInvoker**: Likely involved in entry point logic or invocation of SqlFile-related operations.\n14. **RowError / BadSpecial**: Custom exceptions tied to SQL parsing, DSV handling, and script execution.\n15. **SharedFields**: Contains shared constants or variables used across utility classes like SqlFile.\n16. **SimpleLog / FrameworkLogger / ToolLogger**: Logging components that may be used for tracing SqlFile execution.\n17. **PrivateException / RB**: Internal exception and resource management classes linked to SqlFile's error reporting.\n18. **TokenList / Token / TokenSource**: Related to lexical analysis or parsing, possibly from legacy scanner/parser logic.\n19. **TarGenerator / TarFileOutputStream / TarFileInputStream / TarReader / TarHeaderFields / TarEntrySupplicant**: May be indirectly coupled via shared utilities or archiving features triggered by SqlFile.\n20. **PIFData / DbBackup**: Possibly invoked during backup/export operations initiated through SQL scripts.\n21. **AuthUtils / AuthBeanMultiplexer**: Security-related utilities potentially used in restricted file/database access flows.\n22. **Calculator / Atom**: Expression evaluation components possibly used in script expressions or variable substitution.\n\nThese entities were selected based on co-change frequency, semantic similarity, and structural coupling with `SqlFile.java`. Changes in these files may impact logging, error handling, internationalization, control flow, and file/script processing logic within `SqlFile.java`.",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        }
    ],
    "interaction_records": {
        "step_histories": [
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4"
                ],
                "response_message": "m5"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6"
                ],
                "response_message": "m7"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8"
                ],
                "response_message": "m9"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10"
                ],
                "response_message": "m11"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12"
                ],
                "response_message": "m13"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14"
                ],
                "response_message": "m15"
            }
        ],
        "mid_to_message": {
            "m1": {
                "role": "system",
                "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
            },
            "m2": {
                "role": "user",
                "content": "The project you need to analyze is `hsqldb`, a well-known Java open source project. The starting entity you need to deal with is SqlFile.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
            },
            "m3": {
                "content": "",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_f8631c829c9a44b2adc468",
                        "function": {
                            "arguments": "{\"entity\": \"SqlFile.java\"}",
                            "name": "get_co_change_relationship"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m4": {
                "name": "get_co_change_relationship",
                "role": "tool",
                "content": "[[\"RCData\", \"6\", \"0.16666666666666666\"], [\"AppendableException\", \"4\", \"0.1111111111111111\"], [\"SqlToolSprayer\", \"7\", \"0.19444444444444445\"], [\"BooleanBucket\", \"2\", \"0.05555555555555555\"], [\"SqlToolException\", \"2\", \"0.05555555555555555\"], [\"BadCmdline\", \"2\", \"0.05555555555555555\"], [\"ContinueException\", \"1\", \"0.027777777777777776\"], [\"BreakException\", \"1\", \"0.027777777777777776\"], [\"QuitNow\", \"1\", \"0.027777777777777776\"], [\"SqlToolError\", \"4\", \"0.1111111111111111\"], [\"ScriptWriterText\", \"1\", \"0.027777777777777776\"], [\"SqlTool\", \"26\", \"0.7222222222222222\"], [\"CSVWriter\", \"1\", \"0.027777777777777776\"], [\"MainInvoker\", \"1\", \"0.027777777777777776\"], [\"RowError\", \"3\", \"0.08333333333333333\"], [\"BadSpecial\", \"2\", \"0.05555555555555555\"], [\"BadSubst\", \"1\", \"0.027777777777777776\"], [\"ValidatingResourceBundle\", \"6\", \"0.16666666666666666\"], [\"RefCapablePropertyResourceBundle\", \"9\", \"0.25\"], [\"SqltoolRB\", \"13\", \"0.3611111111111111\"], [\"DatabaseManagerSwing\", \"1\", \"0.027777777777777776\"], [\"SqlFileScanner\", \"4\", \"0.1111111111111111\"], [\"DatabaseManager\", \"1\", \"0.027777777777777776\"], [\"SharedFields\", \"2\", \"0.05555555555555555\"], [\"SimpleLog\", \"1\", \"0.027777777777777776\"], [\"PrivateException\", \"1\", \"0.027777777777777776\"], [\"RB\", \"1\", \"0.027777777777777776\"], [\"TokenList\", \"2\", \"0.05555555555555555\"], [\"TarGenerator\", \"1\", \"0.027777777777777776\"], [\"TarHeaderFields\", \"1\", \"0.027777777777777776\"], [\"PIFData\", \"3\", \"0.08333333333333333\"], [\"TarFileOutputStream\", \"1\", \"0.027777777777777776\"], [\"TarFileInputStream\", \"1\", \"0.027777777777777776\"], [\"TarEntrySupplicant\", \"1\", \"0.027777777777777776\"], [\"DbBackup\", \"2\", \"0.05555555555555555\"], [\"TarReader\", \"1\", \"0.027777777777777776\"], [\"Token\", \"3\", \"0.08333333333333333\"], [\"TokenSource\", \"1\", \"0.027777777777777776\"], [\"Calculator\", \"1\", \"0.027777777777777776\"], [\"Atom\", \"1\", \"0.027777777777777776\"], [\"FrameworkLogger\", \"1\", \"0.027777777777777776\"], [\"AuthUtils\", \"1\", \"0.027777777777777776\"], [\"AuthBeanMultiplexer\", \"1\", \"0.027777777777777776\"], [\"ToolLogger\", \"1\", \"0.027777777777777776\"]]"
            },
            "m5": {
                "content": "From the co-change relationship results, we can observe that certain entities have a higher confidence value, indicating they are frequently modified together with `SqlFile.java`. These entities are more likely to be impacted by changes in `SqlFile.java` and should be considered for synchronization. Here's an interpretation of the results:\n\n### High Confidence Co-Changes (> 0.25):\n1. **SqltoolRB** - Confidence: `0.3611`\n   - This appears to be a resource bundle related to SQL tools, possibly handling localized strings or configurations. Changes in `SqlFile.java` might affect this file due to shared logic or configuration.\n\n2. **RefCapablePropertyResourceBundle** - Confidence: `0.25`\n   - Another resource bundle entity, potentially used for property management alongside `SqltoolRB`.\n\n### Moderate Confidence Co-Changes (Between 0.1 and 0.25):\n1. **SqlTool** - Confidence: `0.7222`\n   - A very high support count (`26`) suggests a strong dependency. This is likely a core class interacting directly with `SqlFile.java`.\n\n2. **RCData** & **ValidatingResourceBundle** - Confidence: `0.1667`\n   - These could be related to data handling or validation logic tied to `SqlFile.java`.\n\n3. **SqlToolSprayer** - Confidence: `0.1944`\n   - Possibly involved in distributing or applying SQL tool functionalities across files.\n\n4. **SqlFileScanner** - Confidence: `0.1111`\n   - Likely involved in scanning or parsing SQL files; directly related to `SqlFile.java`.\n\n### Recommended Entities to Investigate Further:\nGiven the above analysis, the most relevant entities to synchronize or examine further are:\n- `SqlFile.java` (starting point)\n- `SqltoolRB.java`\n- `SqlTool.java`\n- `SqlToolSprayer.java`\n- `SqlFileScanner.java`\n\nNext, let's analyze the coupling dependencies between `SqlFile.java` and these key entities to understand their structural relationships. I will start with `SqlTool.java`, as it has the highest confidence among co-changes.\n\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_28e7c932e2da4afaac74a6",
                        "function": {
                            "arguments": "{\"entity1\": \"SqlFile.java\", \"entity2\": \"SqlTool.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m6": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"There are no coupling dependencies between these two entities\"]"
            },
            "m7": {
                "content": "The result indicates that there is no direct structural coupling between `SqlFile.java` and `SqlTool.java`. This suggests that the co-change relationship might be due to functional or behavioral dependencies rather than direct code-level dependencies.\n\nNext, let's examine the coupling dependencies between `SqlFile.java` and `SqlFileScanner.java`, as this entity is likely involved in parsing or scanning SQL files and may have a more direct relationship with `SqlFile.java`.\n\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_3526da5914e3403f96411b",
                        "function": {
                            "arguments": "{\"entity1\": \"SqlFile.java\", \"entity2\": \"SqlFileScanner.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m8": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"SqlFileScanner has been removed from the project due to project version iteration\"]"
            },
            "m9": {
                "content": "It appears that `SqlFileScanner.java` has been removed from the project due to version updates, which explains the lack of coupling information. This suggests that the functionality previously handled by `SqlFileScanner.java` may have been moved or integrated elsewhere, possibly within `SqlFile.java` itself or another entity.\n\nLet\u2019s now check the coupling dependencies between `SqlFile.java` and `SqltoolRB.java`, which showed a relatively high confidence in co-change relationships. This will help us understand if there is any structural dependency between them.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_1d1be26758a045f983872d",
                        "function": {
                            "arguments": "{\"entity1\": \"SqlFile.java\", \"entity2\": \"SqltoolRB.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m10": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"StaticVariableInvoking(SAI): Static Variable Invoking found: execute invokes static variable SQLFILE_BANNER,  Static Variable Invoking found: execute invokes static variable RAW_EMPTY,  Static Variable Invoking found: execute invokes static variable RAW_MOVEDTOBUFFER,  Static Variable Invoking found: execute invokes static variable INPUT_MOVEDTOBUFFER,  Static Variable Invoking found: execute invokes static variable SQLSTATEMENT_EMPTY,  Static Variable Invoking found: execute invokes static variable ERRORAT,  Static Variable Invoking found: execute invokes static variable CAUSEREPORT,  Static Variable Invoking found: execute invokes static variable ERRORAT,  Static Variable Invoking found: execute invokes static variable BREAK_UNSATISFIED,  Static Variable Invoking found: execute invokes static variable CONTINUE_UNSATISFIED,  Static Variable Invoking found: execute invokes static variable ERRORAT,  Static Variable Invoking found: execute invokes static variable CAUSEREPORT,  Static Variable Invoking found: execute invokes static variable INPUT_UNTERMINATED,  Static Variable Invoking found: execute invokes static variable INPUT_UNTERMINATED,  Static Variable Invoking found: execute invokes static variable PRIMARYINPUT_ACCESSFAIL,  Static Variable Invoking found: execute invokes static variable ABORTING,  Static Variable Invoking found: execute invokes static variable PLVAR_SET_INCOMPLETE,  Static Variable Invoking found: execute invokes static variable INPUTREADER_CLOSEFAIL,  Static Variable Invoking found: execute invokes static variable ROLLINGBACK,  Static Variable Invoking found: processBuffHist invokes static variable BUFHIST_UNSPECIFIED,  Static Variable Invoking found: processBuffHist invokes static variable NOBUFFER_YET,  Static Variable Invoking found: processBuffHist invokes static variable BUFFER_EXECUTING,  Static Variable Invoking found: processBuffHist invokes static variable NOBUFFER_YET,  Static Variable Invoking found: processBuffHist invokes static variable BUFFER_EXECUTING,  Static Variable Invoking found: processBuffHist invokes static variable EDITBUFFER_CONTENTS,  Static Variable Invoking found: processBuffHist invokes static variable COMMANDNUM_MALFORMAT,  Static Variable Invoking found: processBuffHist invokes static variable BUFFER_EXECUTING,  Static Variable Invoking found: processBuffHist invokes static variable BUFFER_RESTORED,  Static Variable Invoking found: processBuffHist invokes static variable DESTFILE_DEMAND,  Static Variable Invoking found: processBuffHist invokes static variable BUFFER_EMPTY,  Static Variable Invoking found: processBuffHist invokes static variable FILE_APPENDFAIL,  Static Variable Invoking found: processBuffHist invokes static variable SUBSTITUTION_MALFORMAT,  Static Variable Invoking found: processBuffHist invokes static variable SUBSTITUTION_MALFORMAT,  Static Variable Invoking found: processBuffHist invokes static variable SUBSTITUTION_NOMATCH,  Static Variable Invoking found: processBuffHist invokes static variable BUFFER_EXECUTING,  Static Variable Invoking found: processBuffHist invokes static variable EDITBUFFER_CONTENTS,  Static Variable Invoking found: processBuffHist invokes static variable SUBSTITUTION_SYNTAX,  Static Variable Invoking found: processBuffHist invokes static variable SUBSTITUTION_SYNTAX,  Static Variable Invoking found: processBuffHist invokes static variable BUFFER_HELP,  Static Variable Invoking found: processBuffHist invokes static variable BUFFER_UNKNOWN,  Static Variable Invoking found: enforce1charSpecial invokes static variable SPECIAL_EXTRACHARS,  Static Variable Invoking found: enforce1charBH invokes static variable BUFFER_EXTRACHARS,  Static Variable Invoking found: processSpecial invokes static variable SPECIAL_UNSPECIFIED,  Static Variable Invoking found: processSpecial invokes static variable SPECIAL_MALFORMAT,  Static Variable Invoking found: processSpecial invokes static variable HTML_MODE,  Static Variable Invoking found: processSpecial invokes static variable DSV_TARGETFILE_DEMAND,  Static Variable Invoking found: processSpecial invokes static variable DSV_NOCOLSLEFT,  Static Variable Invoking found: processSpecial invokes static variable DSV_SKIPCOLS_MISSING,  Static Variable Invoking found: processSpecial invokes static variable FILE_WROTECHARS,  Static Variable Invoking found: processSpecial invokes static variable FILE_WRITEFAIL,  Static Variable Invoking found: processSpecial invokes static variable FILE_WRITEFAIL,  Static Variable Invoking found: processSpecial invokes static variable METADATA_FETCH_FAIL,  Static Variable Invoking found: processSpecial invokes static variable SPECIAL_D_LIKE,  Static Variable Invoking found: processSpecial invokes static variable OUTPUTFILE_NONETOCLOSE,  Static Variable Invoking found: processSpecial invokes static variable OUTPUTFILE_REOPENING,  Static Variable Invoking found: processSpecial invokes static variable OUTPUTFILE_HEADER,  Static Variable Invoking found: processSpecial invokes static variable FILE_WRITEFAIL,  Static Variable Invoking found: processSpecial invokes static variable SQLFILE_NAME_DEMAND,  Static Variable Invoking found: processSpecial invokes static variable SQLFILE_EXECUTE_FAIL,  Static Variable Invoking found: processSpecial invokes static variable A_SETTING,  Static Variable Invoking found: processSpecial invokes static variable COMMITTED,  Static Variable Invoking found: processSpecial invokes static variable SPECIAL_B_MALFORMAT,  Static Variable Invoking found: processSpecial invokes static variable SPECIAL_B_MALFORMAT,  Static Variable Invoking found: processSpecial invokes static variable SPECIAL_B_MALFORMAT,  Static Variable Invoking found: processSpecial invokes static variable BINARY_LOADEDBYTESINTO,  Static Variable Invoking found: processSpecial invokes static variable BINARY_FILEFAIL,  Static Variable Invoking found: processSpecial invokes static variable C_SETTING,  Static Variable Invoking found: processSpecial invokes static variable SPECIAL_HELP,  Static Variable Invoking found: processSpecial invokes static variable BANG_INCOMPLETE,  Static Variable Invoking found: processSpecial invokes static variable BANG_COMMAND_FAIL,  Static Variable Invoking found: processSpecial invokes static variable BANG_COMMAND_FAIL,  Static Variable Invoking found: processSpecial invokes static variable SPECIAL_UNKNOWN,  Static Variable Invoking found: dereference invokes static variable PLALIAS_MALFORMAT,  Static Variable Invoking found: dereference invokes static variable PLVAR_UNDEFINED,  Static Variable Invoking found: dereference invokes static variable SYSPROP_EMPTY,  Static Variable Invoking found: dereference invokes static variable SYSPROP_UNTERMINATED,  Static Variable Invoking found: dereference invokes static variable VAR_INFINITE,  Static Variable Invoking found: dereference invokes static variable SYSPROP_UNDEFINED,  Static Variable Invoking found: dereference invokes static variable PLVAR_NAMEEMPTY,  Static Variable Invoking found: dereference invokes static variable PLVAR_UNTERMINATED,  Static Variable Invoking found: dereference invokes static variable VAR_INFINITE,  Static Variable Invoking found: dereference invokes static variable PLVAR_UNDEFINED,  Static Variable Invoking found: processPL invokes static variable PL_MALFORMAT,  Static Variable Invoking found: processPL invokes static variable PL_EXPANSIONMODE,  Static Variable Invoking found: processPL invokes static variable PL_HELP,  Static Variable Invoking found: processPL invokes static variable END_NOBLOCK,  Static Variable Invoking found: processPL invokes static variable CONTINUE_SYNTAX,  Static Variable Invoking found: processPL invokes static variable BREAK_SYNTAX,  Static Variable Invoking found: processPL invokes static variable PL_LIST_PARENS,  Static Variable Invoking found: processPL invokes static variable PL_LIST_LENGTHS,  Static Variable Invoking found: processPL invokes static variable DUMPLOAD_MALFORMAT,  Static Variable Invoking found: processPL invokes static variable PLVAR_NOCOLON,  Static Variable Invoking found: processPL invokes static variable DUMPLOAD_FAIL,  Static Variable Invoking found: processPL invokes static variable PREPARE_MALFORMAT,  Static Variable Invoking found: processPL invokes static variable PLVAR_UNDEFINED,  Static Variable Invoking found: processPL invokes static variable FOREACH_MALFORMAT,  Static Variable Invoking found: processPL invokes static variable PLVAR_NOCOLON,  Static Variable Invoking found: processPL invokes static variable PL_TEMPFILE_FAIL,  Static Variable Invoking found: processPL invokes static variable PL_BLOCK_FAIL,  Static Variable Invoking found: processPL invokes static variable TEMPFILE_REMOVAL_FAIL,  Static Variable Invoking found: processPL invokes static variable IFWHILE_MALFORMAT,  Static Variable Invoking found: processPL invokes static variable PL_BLOCK_FAIL,  Static Variable Invoking found: processPL invokes static variable IF_MALFORMAT,  Static Variable Invoking found: processPL invokes static variable PL_BLOCK_FAIL,  Static Variable Invoking found: processPL invokes static variable PL_TEMPFILE_FAIL,  Static Variable Invoking found: processPL invokes static variable WHILE_MALFORMAT,  Static Variable Invoking found: processPL invokes static variable PL_BLOCK_FAIL,  Static Variable Invoking found: processPL invokes static variable PL_UNKNOWN,  Static Variable Invoking found: processPL invokes static variable TEMPFILE_REMOVAL_FAIL,  Static Variable Invoking found: processPL invokes static variable PL_UNKNOWN,  Static Variable Invoking found: processPL invokes static variable PLVAR_NOCOLON,  Static Variable Invoking found: processPL invokes static variable PLVAR_TILDEDASH_NOMOREARGS,  Static Variable Invoking found: processPL invokes static variable PL_UNKNOWN,  Static Variable Invoking found: plBlockFile invokes static variable PL_BLOCK_UNTERMINATED,  Static Variable Invoking found: plBlockFile invokes static variable END_SYNTAX,  Static Variable Invoking found: plBlockFile invokes static variable END_SYNTAX,  Static Variable Invoking found: listTables invokes static variable VENDOR_ORACLE_DS,  Static Variable Invoking found: listTables invokes static variable VENDOR_DERBY_DR,  Static Variable Invoking found: listTables invokes static variable VENDOR_NOSUP_D,  Static Variable Invoking found: listTables invokes static variable VENDOR_DERBY_DU,  Static Variable Invoking found: listTables invokes static variable VENDOR_NOSUP_D,  Static Variable Invoking found: listTables invokes static variable SPECIAL_D_UNKNOWN,  Static Variable Invoking found: listTables invokes static variable METADATA_FETCH_FAIL,  Static Variable Invoking found: listTables invokes static variable METADATA_FETCH_FAILFOR,  Static Variable Invoking found: listTables invokes static variable METADATA_FETCH_FAIL,  Static Variable Invoking found: listTables invokes static variable METADATA_FETCH_FAIL,  Static Variable Invoking found: processSQL invokes static variable PREPARE_DEMANDQM,  Static Variable Invoking found: processSQL invokes static variable BINBUFFER_EMPTY,  Static Variable Invoking found: processSQL invokes static variable PLVAR_UNDEFINED,  Static Variable Invoking found: displayResultSet invokes static variable VENDOR_NOSUP_SYSSCHEMAS,  Static Variable Invoking found: displayResultSet invokes static variable NORESULT,  Static Variable Invoking found: displayResultSet invokes static variable DSV_BINCOL,  Static Variable Invoking found: displayResultSet invokes static variable BINBUF_WRITE,  Static Variable Invoking found: displayResultSet invokes static variable ROWS_FETCHED,  Static Variable Invoking found: displayResultSet invokes static variable ROWS_FETCHED_DSV,  Static Variable Invoking found: displayResultSet invokes static variable ROW_UPDATE_SINGULAR,  Static Variable Invoking found: displayResultSet invokes static variable ROW_UPDATE_MULTIPLE,  Static Variable Invoking found: showHistory invokes static variable HISTORY_UNAVAILABLE,  Static Variable Invoking found: showHistory invokes static variable HISTORY_NONE,  Static Variable Invoking found: showHistory invokes static variable EDITBUFFER_CONTENTS,  Static Variable Invoking found: showHistory invokes static variable BUFFER_INSTRUCTIONS,  Static Variable Invoking found: commandFromHistory invokes static variable HISTORY_UNAVAILABLE,  Static Variable Invoking found: commandFromHistory invokes static variable HISTORY_NUMBER_REQ,  Static Variable Invoking found: commandFromHistory invokes static variable HISTORY_BACKTO,  Static Variable Invoking found: commandFromHistory invokes static variable HISTORY_UPTO,  Static Variable Invoking found: commandFromHistory invokes static variable HISTORY_BACK,  Static Variable Invoking found: describe invokes static variable DESCRIBE_TABLE_NAME,  Static Variable Invoking found: describe invokes static variable DESCRIBE_TABLE_DATATYPE,  Static Variable Invoking found: describe invokes static variable DESCRIBE_TABLE_WIDTH,  Static Variable Invoking found: describe invokes static variable DESCRIBE_TABLE_NONULLS,  Static Variable Invoking found: eval invokes static variable LOGICAL_UNRECOGNIZED,  Static Variable Invoking found: formatNicely invokes static variable PL_LIST_PARENS,  Static Variable Invoking found: formatNicely invokes static variable PL_LIST_LENGTHS,  Static Variable Invoking found: dump invokes static variable PLVAR_UNDEFINED,  Static Variable Invoking found: dump invokes static variable FILE_WROTECHARS,  Static Variable Invoking found: dump invokes static variable BINBUFFER_EMPTY,  Static Variable Invoking found: dump invokes static variable FILE_WROTECHARS,  Static Variable Invoking found: streamToString invokes static variable READ_TOOBIG,  Static Variable Invoking found: streamToString invokes static variable READ_PARTIAL,  Static Variable Invoking found: streamToString invokes static variable READ_CONVERTFAIL,  Static Variable Invoking found: dsvSafe invokes static variable DSV_COLDELIM_PRESENT,  Static Variable Invoking found: dsvSafe invokes static variable DSV_ROWDELIM_PRESENT,  Static Variable Invoking found: dsvSafe invokes static variable DSV_NULLREP_PRESENT,  Static Variable Invoking found: importDsv invokes static variable DSV_CONSTCOLS_NULLCOL,  Static Variable Invoking found: importDsv invokes static variable FILE_READFAIL,  Static Variable Invoking found: importDsv invokes static variable READ_TOOBIG,  Static Variable Invoking found: importDsv invokes static variable INPUTFILE_CLOSEFAIL,  Static Variable Invoking found: importDsv invokes static variable READ_PARTIAL,  Static Variable Invoking found: importDsv invokes static variable READ_CONVERTFAIL,  Static Variable Invoking found: importDsv invokes static variable DSV_HEADER_NONE,  Static Variable Invoking found: importDsv invokes static variable DSV_HEADER_NOSWITCHTARG,  Static Variable Invoking found: importDsv invokes static variable DSV_HEADER_NOSWITCHMATCH,  Static Variable Invoking found: importDsv invokes static variable DSV_HEADER_NONSWITCHED,  Static Variable Invoking found: importDsv invokes static variable DSV_NOCOLHEADER,  Static Variable Invoking found: importDsv invokes static variable DSV_SKIPCOLS_MISSING,  Static Variable Invoking found: importDsv invokes static variable DSV_NOCOLSLEFT,  Static Variable Invoking found: importDsv invokes static variable DSV_METADATA_MISMATCH,  Static Variable Invoking found: importDsv invokes static variable QUERY_METADATAFAIL,  Static Variable Invoking found: importDsv invokes static variable DSV_REJECTFILE_SETUPFAIL,  Static Variable Invoking found: importDsv invokes static variable REJECTREPORT_TOP,  Static Variable Invoking found: importDsv invokes static variable NONE,  Static Variable Invoking found: importDsv invokes static variable DSV_REJECTREPORT_SETUPFAIL,  Static Variable Invoking found: importDsv invokes static variable INSERTION_PREPAREFAIL,  Static Variable Invoking found: importDsv invokes static variable DSV_HEADER_MATCHERNONHEAD,  Static Variable Invoking found: importDsv invokes static variable DSV_COLCOUNT_MISMATCH,  Static Variable Invoking found: importDsv invokes static variable DSV_COLCOUNT_MISMATCH,  Static Variable Invoking found: importDsv invokes static variable DSV_INSERTCOL_MISMATCH,  Static Variable Invoking found: importDsv invokes static variable TIME_BAD,  Static Variable Invoking found: importDsv invokes static variable BOOLEAN_BAD,  Static Variable Invoking found: importDsv invokes static variable INPUTREC_MODIFIED,  Static Variable Invoking found: importDsv invokes static variable DSV_RECIN_FAIL,  Static Variable Invoking found: importDsv invokes static variable DSV_IMPORT_SUMMARY,  Static Variable Invoking found: importDsv invokes static variable INSERTIONS_NOTCOMMITTED,  Static Variable Invoking found: importDsv invokes static variable AUTOCOMMIT_FETCHFAIL,  Static Variable Invoking found: importDsv invokes static variable INSERTIONS_NOTCOMMITTED,  Static Variable Invoking found: importDsv invokes static variable REJECTREPORT_BOTTOM,  Static Variable Invoking found: importDsv invokes static variable DSV_REJECTFILE_PURGEFAIL,  Static Variable Invoking found: importDsv invokes static variable DSV_REJECTREPORT_PURGEFAIL,  Static Variable Invoking found: genRejectReportRecord invokes static variable REJECTREPORT_ROW,  \", \"ConstructorInvoking(CMI): Construction Method Invoking found: new SqltoolRB(),  \", \"ConstructorInvoking(CMAIM): Coupling found in method execute, at line: 448. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 506. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 517. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 598. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 623. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 639. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 649. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 658. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 684. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 697. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 707. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 719. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 731. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 733. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 740. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 751. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 760. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 768. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method execute, at line: 773. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 949. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 964. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 966. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 973. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 990. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1009. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1042. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1047. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1051. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1058. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1063. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1083. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1097. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1106. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1139. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1145. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1150. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1153. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1164. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processBuffHist, at line: 1169. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method enforce1charSpecial, at line: 1186. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method enforce1charBH, at line: 1193. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1211. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1216. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1242. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1294. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1330. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1334. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1345. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1349. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1352. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1390. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1394. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1399. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1409. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1430. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1436. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1445. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1471. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1494. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1502. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1509. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1519. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1529. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1540. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1547. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1561. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1567. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1592. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1623. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1629. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSpecial, at line: 1646. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dereference, at line: 1697. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dereference, at line: 1705. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dereference, at line: 1731. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dereference, at line: 1735. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dereference, at line: 1743. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dereference, at line: 1751. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dereference, at line: 1772. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dereference, at line: 1776. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dereference, at line: 1784. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dereference, at line: 1794. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1824. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1830. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1837. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1846. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1856. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1871. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1891. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1893. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1911. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1918. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1929. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1938. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1942. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1956. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1966. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 1975. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2019. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2030. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2041. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2058. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2086. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2090. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2097. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2131. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2134. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2139. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2144. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2153. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2164. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2172. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processPL, at line: 2198. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method plBlockFile, at line: 2253. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method plBlockFile, at line: 2270. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method plBlockFile, at line: 2287. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method listTables, at line: 2513. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method listTables, at line: 2571. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method listTables, at line: 2574. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method listTables, at line: 2612. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method listTables, at line: 2615. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method listTables, at line: 2707. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method listTables, at line: 2733. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method listTables, at line: 2750. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method listTables, at line: 2766. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method listTables, at line: 2769. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSQL, at line: 2816. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSQL, at line: 2827. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method processSQL, at line: 2838. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method displayResultSet, at line: 2900. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method displayResultSet, at line: 2906. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method displayResultSet, at line: 3084. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method displayResultSet, at line: 3098. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method displayResultSet, at line: 3227. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method displayResultSet, at line: 3268. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method displayResultSet, at line: 3282. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method displayResultSet, at line: 3283. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method showHistory, at line: 3374. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method showHistory, at line: 3377. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method showHistory, at line: 3385. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method showHistory, at line: 3389. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method commandFromHistory, at line: 3399. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method commandFromHistory, at line: 3402. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method commandFromHistory, at line: 3408. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method commandFromHistory, at line: 3412. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method commandFromHistory, at line: 3419. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method describe, at line: 3470. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method describe, at line: 3471. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method describe, at line: 3472. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method describe, at line: 3473. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method eval, at line: 3639. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method formatNicely, at line: 3697. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method formatNicely, at line: 3699. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dump, at line: 3725. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dump, at line: 3754. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dump, at line: 3767. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dump, at line: 3784. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method streamToString, at line: 3801. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method streamToString, at line: 3809. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method streamToString, at line: 3819. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dsvSafe, at line: 4026. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dsvSafe, at line: 4031. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method dsvSafe, at line: 4038. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4171. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4187. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4194. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4215. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4220. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4233. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4255. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4279. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4286. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4294. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4325. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4343. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4358. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4416. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4453. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4483. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4496. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4500. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4505. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4519. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4559. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4588. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4600. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4613. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4641. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4656. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4675. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4698. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4708. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4721. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4724. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4725. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4734. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4742. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method importDsv, at line: 4745. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.  Coupling found in method genRejectReportRecord, at line: 4786. Instance of SqltoolRB member variable rb is used to call SqltoolRB's method getString.\"]"
            },
            "m11": {
                "content": "The coupling dependencies between `SqlFile.java` and `SqltoolRB.java` reveal a strong functional relationship. Here's the breakdown:\n\n### Coupling Dependency Types:\n1. **Static Variable Invoking (SAI)**:\n   - Numerous static variables from `SqltoolRB.java` are invoked in `SqlFile.java`, especially within methods like `execute`, `processBuffHist`, and `processSpecial`.\n   - These static variables seem to be error messages or string constants used throughout `SqlFile.java`.\n\n2. **Constructor Invoking (CMI)**:\n   - A new instance of `SqltoolRB` is created using its constructor in `SqlFile.java`.\n\n3. **Method Invoking (CMAIM)**:\n   - The `getString()` method of `SqltoolRB` is frequently called across many methods in `SqlFile.java`. This indicates that `SqlFile.java` relies heavily on `SqltoolRB.java` for retrieving localized strings or messages, likely for logging or user feedback.\n\n### Implications:\n- `SqlFile.java` uses `SqltoolRB.java` as a resource bundle to fetch localized or configurable strings.\n- Any change in the structure or content of `SqltoolRB.java` could directly impact the behavior of `SqlFile.java`, especially if string keys or static variables are modified or removed.\n\n### Next Steps:\nSince we've identified a significant dependency between `SqlFile.java` and `SqltoolRB.java`, it would be beneficial to examine the origin code of `SqlFile.java` to understand how these dependencies are utilized in more detail. I will now retrieve the source code of `SqlFile.java` for further analysis.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_76a34ce6520148c1b93a54",
                        "function": {
                            "arguments": "{\"entity\": \"SqlFile.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m12": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package org.hsqldb.util;\\nimport java.io.BufferedReader;\\nimport java.io.ByteArrayOutputStream;\\nimport java.io.File;\\nimport java.io.FileInputStream;\\nimport java.io.FileNotFoundException;\\nimport java.io.FileOutputStream;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nimport java.io.InputStreamReader;\\nimport java.io.OutputStreamWriter;\\nimport java.io.PrintStream;\\nimport java.io.PrintWriter;\\nimport java.io.UnsupportedEncodingException;\\nimport java.sql.Connection;\\nimport java.sql.DatabaseMetaData;\\nimport java.sql.PreparedStatement;\\nimport java.sql.ResultSet;\\nimport java.sql.ResultSetMetaData;\\nimport java.sql.SQLException;\\nimport java.sql.Statement;\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.Iterator;\\nimport java.util.List;\\nimport java.util.Set;\\nimport java.util.HashSet;\\nimport java.util.Map;\\nimport java.util.SortedMap;\\nimport java.util.TreeMap;\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\nimport java.util.regex.PatternSyntaxException;\\npublic class SqlFile {\\n    private static final int DEFAULT_HISTORY_SIZE = 40;\\n    private File             file;\\n    private boolean          interactive;\\n    private String           primaryPrompt    = \\\"sql> \\\";\\n    private String           rawPrompt      = null;\\n    private String           contPrompt       = \\\"  +> \\\";\\n    private Connection       curConn          = null;\\n    private boolean          htmlMode         = false;\\n    private Map              userVars;     private List             history          = null;\\n    private int              rawMode          = RAW_FALSE;\\n    private String           nullRepToken     = null;\\n    private String           dsvTargetFile    = null;\\n    private String           dsvTargetTable   = null;\\n    private String           dsvConstCols     = null;\\n    private String           dsvRejectFile    = null;\\n    private String           dsvRejectReport  = null;\\n    public static String     LS = System.getProperty(\\\"line.separator\\\");\\n    private int              maxHistoryLength = 1;\\n    private SqltoolRB        rb               = null;\\n    private static final int RAW_FALSE = 0;     private static final int RAW_EMPTY = 1;     private static final int RAW_DATA  = 2; \\n    private static Pattern   specialPattern =\\n            Pattern.compile(\\\"\\\\\\\\s*\\\\\\\\\\\\\\\\(\\\\\\\\S+)(?:\\\\\\\\s+(.*\\\\\\\\S))?\\\\\\\\s*\\\");\\n    private static Pattern   plPattern  =\\n            Pattern.compile(\\\"\\\\\\\\s*\\\\\\\\*\\\\\\\\s*(.*\\\\\\\\S)?\\\\\\\\s*\\\");\\n    private static Pattern   foreachPattern =\\n            Pattern.compile(\\\"\\\\\\\\s*\\\\\\\\*\\\\\\\\s*foreach\\\\\\\\s+(\\\\\\\\S+)\\\\\\\\s*\\\\\\\\(([^)]*)\\\\\\\\)\\\\\\\\s*\\\");\\n    private static Pattern   ifwhilePattern =\\n            Pattern.compile(\\\"\\\\\\\\s*\\\\\\\\*\\\\\\\\s*\\\\\\\\S+\\\\\\\\s*\\\\\\\\(([^)]*)\\\\\\\\)\\\\\\\\s*\\\");\\n    private static Pattern   varsetPattern =\\n            Pattern.compile(\\\"\\\\\\\\s*\\\\\\\\*\\\\\\\\s*(\\\\\\\\S+)\\\\\\\\s*([=_~])\\\\\\\\s*(?:(.*\\\\\\\\S)\\\\\\\\s*)?\\\");\\n    private static Pattern   substitutionPattern =\\n            Pattern.compile(\\\"\\\\\\\\s*s(\\\\\\\\S)(.+?)\\\\\\\\1(.*?)\\\\\\\\1(.+)?\\\\\\\\s*\\\");\\n                private static Pattern wincmdPattern = null;\\n    static {\\n        if (System.getProperty(\\\"os.name\\\").startsWith(\\\"Windows\\\")) {\\n            wincmdPattern = Pattern.compile(\\\"([^\\\\\\\"]+)?(\\\\\\\"[^\\\\\\\"]*\\\\\\\")?\\\");\\n        }\\n    }\\n    private void updateUserSettings() {\\n        dsvSkipPrefix = SqlFile.convertEscapes(\\n                (String) userVars.get(\\\"*DSV_SKIP_PREFIX\\\"));\\n        if (dsvSkipPrefix == null) {\\n            dsvSkipPrefix = DEFAULT_SKIP_PREFIX;\\n        }\\n        dsvSkipCols = (String) userVars.get(\\\"*DSV_SKIP_COLS\\\");\\n        dsvColDelim =\\n            SqlFile.convertEscapes((String) userVars.get(\\\"*DSV_COL_DELIM\\\"));\\n        if (dsvColDelim == null) {\\n            dsvColDelim =\\n                SqlFile.convertEscapes((String) userVars.get(\\\"*CSV_COL_DELIM\\\"));\\n        }\\n        if (dsvColDelim == null) {\\n            dsvColDelim = DEFAULT_COL_DELIM;\\n        }\\n        dsvRowDelim =\\n            SqlFile.convertEscapes((String) userVars.get(\\\"*DSV_ROW_DELIM\\\"));\\n        if (dsvRowDelim == null) {\\n            dsvRowDelim =\\n                SqlFile.convertEscapes((String) userVars.get(\\\"*CSV_ROW_DELIM\\\"));\\n        }\\n        if (dsvRowDelim == null) {\\n            dsvRowDelim = DEFAULT_ROW_DELIM;\\n        }\\n        dsvTargetFile = (String) userVars.get(\\\"*DSV_TARGET_FILE\\\");\\n        if (dsvTargetFile == null) {\\n            dsvTargetFile = (String) userVars.get(\\\"*CSV_FILEPATH\\\");\\n        }\\n        dsvTargetTable = (String) userVars.get(\\\"*DSV_TARGET_TABLE\\\");\\n        if (dsvTargetTable == null) {\\n            dsvTargetTable = (String) userVars.get(\\\"*CSV_TABLENAME\\\");\\n                    }\\n        dsvConstCols = (String) userVars.get(\\\"*DSV_CONST_COLS\\\");\\n        dsvRejectFile = (String) userVars.get(\\\"*DSV_REJECT_FILE\\\");\\n        dsvRejectReport = (String) userVars.get(\\\"*DSV_REJECT_REPORT\\\");\\n        nullRepToken = (String) userVars.get(\\\"*NULL_REP_TOKEN\\\");\\n        if (nullRepToken == null) {\\n            nullRepToken = (String) userVars.get(\\\"*CSV_NULL_REP\\\");\\n        }\\n        if (nullRepToken == null) {\\n            nullRepToken = DEFAULT_NULL_REP;\\n        }\\n    }\\n    private static class BooleanBucket {\\n        BooleanBucket() {}\\n        private boolean bPriv = false;\\n        public void set(boolean bIn) {\\n            bPriv = bIn;\\n        }\\n        public boolean get() {\\n            return bPriv;\\n        }\\n    }\\n    BooleanBucket possiblyUncommitteds = new BooleanBucket();\\n    private static final String DIVIDER =\\n        \\\"-----------------------------------------------------------------\\\"\\n        + \\\"-----------------------------------------------------------------\\\";\\n        private static final String SPACES =\\n        \\\"                                                                 \\\"\\n        + \\\"                                                                 \\\";\\n        private static String revnum = null;\\n    static {\\n        revnum = \\\"$Revision: 330 $\\\".substring(\\\"$Revision: \\\".length(),\\n                \\\"$Revision: 330 $\\\".length() - 2);\\n    }\\n    private String DSV_OPTIONS_TEXT = null;\\n    private String D_OPTIONS_TEXT = null;\\n    private String RAW_LEADIN_MSG = null;\\n    public SqlFile(File inFile, boolean inInteractive, Map inVars)\\n            throws IOException {\\n                        try {\\n            rb = new SqltoolRB();\\n            rb.validate();\\n            rb.setMissingPosValueBehavior(\\n                    ValidatingResourceBundle.NOOP_BEHAVIOR);\\n            rb.setMissingPropertyBehavior(\\n                    ValidatingResourceBundle.NOOP_BEHAVIOR);\\n        } catch (RuntimeException re) {\\n            System.err.println(\\\"Failed to initialize resource bundle\\\");\\n            throw re;\\n        }\\n        rawPrompt = rb.getString(SqltoolRB.RAWMODE_PROMPT) + \\\"> \\\";\\n        DSV_OPTIONS_TEXT = rb.getString(SqltoolRB.DSV_OPTIONS);\\n        D_OPTIONS_TEXT = rb.getString(SqltoolRB.D_OPTIONS);\\n        RAW_LEADIN_MSG = rb.getString(SqltoolRB.RAW_LEADIN);\\n        DSV_X_SYNTAX_MSG = rb.getString(SqltoolRB.DSV_X_SYNTAX);\\n        DSV_M_SYNTAX_MSG = rb.getString(SqltoolRB.DSV_M_SYNTAX);\\n        nobufferYetString = rb.getString(SqltoolRB.NOBUFFER_YET);\\n        file        = inFile;\\n        interactive = inInteractive;\\n        userVars    = inVars;\\n        if (userVars == null) {\\n            userVars = new HashMap();\\n        }\\n        updateUserSettings();\\n        if (file != null &&!file.canRead()) {\\n            throw new IOException(rb.getString(SqltoolRB.SQLFILE_READFAIL,\\n                    file.toString()));\\n        }\\n        if (interactive) {\\n            history = new ArrayList();\\n            String histLenString = System.getProperty(\\\"sqltool.historyLength\\\");\\n            if (histLenString != null) try {\\n                maxHistoryLength = Integer.parseInt(histLenString);\\n            } catch (Exception e) {\\n            } else {\\n                maxHistoryLength = DEFAULT_HISTORY_SIZE;\\n            }\\n        }\\n    }\\n    public SqlFile(boolean inInteractive, Map inVars) throws IOException {\\n        this(null, inInteractive, inVars);\\n    }\\n    public void execute(Connection conn,\\n                        Boolean coeOverride)\\n                        throws SqlToolError, SQLException {\\n        execute(conn, System.out, System.err, coeOverride);\\n    }\\n    public void execute(Connection conn,\\n                        boolean coeOverride)\\n                        throws SqlToolError, SQLException {\\n        execute(conn, System.out, System.err, new Boolean(coeOverride));\\n    }\\n        public boolean      recursed     = false;\\n    private String      lastSqlStatement   = null;\\n    private int         curLinenum   = -1;\\n    private PrintStream psStd        = null;\\n    private PrintStream psErr        = null;\\n    private PrintWriter pwQuery      = null;\\n    private PrintWriter pwDsv        = null;\\n    StringBuffer        immCmdSB     = new StringBuffer();\\n    private boolean             continueOnError = false;\\n    private static final String DEFAULT_CHARSET = null;\\n        private BufferedReader      br              = null;\\n    private String              charset         = null;\\n    private String              buffer          = null;\\n    private boolean             withholdPrompt  = false;\\n    public synchronized void execute(Connection conn, PrintStream stdIn,\\n                                     PrintStream errIn,\\n                                     Boolean coeOverride)\\n                                     throws SqlToolError,\\n                                         SQLException {\\n        psStd      = stdIn;\\n        psErr      = errIn;\\n        curConn    = conn;\\n        curLinenum = -1;\\n        String  inputLine;\\n        String  trimmedInput;\\n        String  deTerminated;\\n        boolean inComment = false;            int     postCommentIndex;\\n        boolean rollbackUncoms = true;\\n        continueOnError = (coeOverride == null) ? interactive\\n                                                : coeOverride.booleanValue();\\n        if (userVars.size() > 0) {\\n            plMode = true;\\n        }\\n        String specifiedCharSet = System.getProperty(\\\"sqlfile.charset\\\");\\n        charset = ((specifiedCharSet == null) ? DEFAULT_CHARSET\\n                                              : specifiedCharSet);\\n        try {\\n            br = new BufferedReader((charset == null)\\n                    ?  (new InputStreamReader((file == null)\\n                            ? System.in : (new FileInputStream(file))))\\n                    :  (new InputStreamReader(((file == null)\\n                            ? System.in : (new FileInputStream(file))),\\n                                    charset)));\\n                                    curLinenum = 0;\\n            if (interactive) {\\n                stdprintln(rb.getString(SqltoolRB.SQLFILE_BANNER, revnum));\\n            }\\n            while (true) {\\n                if (withholdPrompt) {\\n                    withholdPrompt = false;\\n                } else if (interactive) {\\n                    psStd.print((immCmdSB.length() > 0 || rawMode == RAW_DATA)\\n                            ? contPrompt : ((rawMode == RAW_FALSE)\\n                                    ? primaryPrompt : rawPrompt));\\n                }\\n                inputLine = br.readLine();\\n                if (inputLine == null) {\\n                    if (interactive) {\\n                        psStd.println();\\n                    }\\n                    break;\\n                }\\n                curLinenum++;\\n                if (inComment) {\\n                    postCommentIndex = inputLine.indexOf(\\\"*/\\\") + 2;\\n                    if (postCommentIndex > 1) {\\n                                                inputLine = inputLine.substring(postCommentIndex);\\n                                                                                                immCmdSB.setLength(0);\\n                        inComment = false;\\n                    } else {\\n                                                continue;\\n                    }\\n                }\\n                trimmedInput = inputLine.trim();\\n                try {\\n                    if (rawMode != RAW_FALSE) {\\n                        boolean rawExecute = inputLine.equals(\\\".;\\\");\\n                        if (rawExecute || inputLine.equals(\\\":.\\\")) {\\n                            if (rawMode == RAW_EMPTY) {\\n                                rawMode = RAW_FALSE;\\n                                throw new SqlToolError(\\n                                        rb.getString(SqltoolRB.RAW_EMPTY));\\n                            }\\n                            rawMode = RAW_FALSE;\\n                            setBuf(immCmdSB.toString());\\n                            immCmdSB.setLength(0);\\n                            if (rawExecute) {\\n                                historize();\\n                                processSQL();\\n                            } else if (interactive) {\\n                                stdprintln(rb.getString(\\n                                            SqltoolRB.RAW_MOVEDTOBUFFER));\\n                            }\\n                        } else {\\n                            if (rawMode == RAW_DATA) {\\n                                immCmdSB.append('\\\\n');\\n                            }\\n                            rawMode = RAW_DATA;\\n                            if (inputLine.length() > 0) {\\n                                immCmdSB.append(inputLine);\\n                            }\\n                        }\\n                        continue;\\n                    }\\n                    if (immCmdSB.length() == 0) {\\n                                            if (trimmedInput.startsWith(\\\"\\\", 2)\\n                                               + 2;\\n                            if (postCommentIndex > 1) {\\n                                                                                                inputLine = inputLine.substring(\\n                                    postCommentIndex + inputLine.length()\\n                                    - trimmedInput.length());\\n                                trimmedInput = inputLine.trim();\\n                            } else {\\n                                                                immCmdSB.append(\\\"COMMENT\\\");\\n                                inComment = true;\\n                                continue;\\n                            }\\n                        }\\n                        if (trimmedInput.length() == 0) {\\n                                                                                    continue;\\n                        }\\n                        if ((trimmedInput.charAt(0) == '*'\\n                                && (trimmedInput.length() < 2\\n                                    || trimmedInput.charAt(1) != '{'))\\n                                || trimmedInput.charAt(0) == '\\\\\\\\') {\\n                            setBuf(trimmedInput);\\n                            processFromBuffer();\\n                            continue;\\n                        }\\n                        if (trimmedInput.charAt(0) == ':' && interactive) {\\n                            processBuffHist(trimmedInput.substring(1));\\n                            continue;\\n                        }\\n                        String ucased = trimmedInput.toUpperCase();\\n                        if (ucased.startsWith(\\\"DECLARE\\\")\\n                                || ucased.startsWith(\\\"BEGIN\\\")) {\\n                            rawMode = RAW_EMPTY;\\n                            immCmdSB.append(inputLine);\\n                            if (interactive) {\\n                                stdprintln(RAW_LEADIN_MSG);\\n                            }\\n                            continue;\\n                        }\\n                    }\\n                    if (trimmedInput.length() == 0 && interactive &&!inComment) {\\n                                                                        setBuf(immCmdSB.toString());\\n                        immCmdSB.setLength(0);\\n                        stdprintln(rb.getString(SqltoolRB.INPUT_MOVEDTOBUFFER));\\n                        continue;\\n                    }\\n                    deTerminated = SqlFile.deTerminated(inputLine);\\n                                        if (!trimmedInput.equals(\\\";\\\")) {\\n                        if (immCmdSB.length() > 0) {\\n                            immCmdSB.append('\\\\n');\\n                        }\\n                        immCmdSB.append((deTerminated == null) ? inputLine\\n                                                                   : deTerminated);\\n                    }\\n                    if (deTerminated == null) {\\n                        continue;\\n                    }\\n                    if (immCmdSB.toString().trim().length() == 0) {\\n                        immCmdSB.setLength(0);\\n                        throw new SqlToolError(rb.getString(\\n                                    SqltoolRB.SQLSTATEMENT_EMPTY));\\n                                                                                                                                            }\\n                    setBuf(immCmdSB.toString());\\n                    bufContainsSql = true;\\n                    immCmdSB.setLength(0);\\n                    historize();\\n                    processSQL();\\n                } catch (BadSpecial bs) {\\n                                        errprintln(rb.getString(SqltoolRB.ERRORAT,\\n                            new String[] {\\n                                ((file == null) ? \\\"stdin\\\" : file.toString()),\\n                                Integer.toString(curLinenum),\\n                                inputLine,\\n                                bs.getMessage(),\\n                            }\\n                    ));\\n                    Throwable cause = bs.getCause();\\n                    if (cause != null) {\\n                        errprintln(rb.getString(SqltoolRB.CAUSEREPORT,\\n                                cause.toString()));\\n                    }\\n                    if (!continueOnError) {\\n                        throw new SqlToolError(bs);\\n                    }\\n                } catch (SQLException se) {\\n                    errprintln(\\\"SQL \\\" + rb.getString(SqltoolRB.ERRORAT,\\n                            new String[] {\\n                                ((file == null) ? \\\"stdin\\\" : file.toString()),\\n                                Integer.toString(curLinenum),\\n                                lastSqlStatement,\\n                                se.getMessage(),\\n                            }));\\n                    if (!continueOnError) {\\n                        throw se;\\n                    }\\n                } catch (BreakException be) {\\n                    String msg = be.getMessage();\\n                    if (recursed) {\\n                        rollbackUncoms = false;\\n                                                                                                                    } else if (msg == null || msg.equals(\\\"file\\\")) {\\n                        break;\\n                    } else {\\n                        errprintln(rb.getString(SqltoolRB.BREAK_UNSATISFIED,\\n                                msg));\\n                    }\\n                    if (recursed ||!continueOnError) {\\n                        throw be;\\n                    }\\n                } catch (ContinueException ce) {\\n                    String msg = ce.getMessage();\\n                    if (recursed) {\\n                        rollbackUncoms = false;\\n                    } else {\\n                        errprintln(rb.getString(SqltoolRB.CONTINUE_UNSATISFIED,\\n                                msg));\\n                    }\\n                    if (recursed ||!continueOnError) {\\n                        throw ce;\\n                    }\\n                } catch (QuitNow qn) {\\n                    throw qn;\\n                } catch (SqlToolError ste) {\\n                    errprint(rb.getString(SqltoolRB.ERRORAT,\\n                            new String[] {\\n                                ((file == null) ? \\\"stdin\\\" : file.toString()),\\n                                Integer.toString(curLinenum),\\n                                inputLine,\\n                                ((ste.getMessage() == null)\\n                                        ? \\\"\\\" : ste.getMessage())\\n                            }\\n                    ));\\n                    if (ste.getMessage() != null) errprintln(\\\"\\\");\\n                    Throwable cause = ste.getCause();\\n                    if (cause != null) {\\n                        errprintln(rb.getString(SqltoolRB.CAUSEREPORT,\\n                                cause.toString()));\\n                    }\\n                    if (!continueOnError) {\\n                        throw ste;\\n                    }\\n                }\\n                immCmdSB.setLength(0);\\n            }\\n            if (inComment || immCmdSB.length() != 0) {\\n                errprintln(rb.getString(SqltoolRB.INPUT_UNTERMINATED,\\n                        immCmdSB.toString()));\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.INPUT_UNTERMINATED, immCmdSB.toString()));\\n            }\\n            rollbackUncoms = false;\\n                    } catch (IOException ioe) {\\n            throw new SqlToolError(rb.getString(\\n                    SqltoolRB.PRIMARYINPUT_ACCESSFAIL), ioe);\\n        } catch (QuitNow qn) {\\n            if (recursed) {\\n                throw qn;\\n                                            }\\n            rollbackUncoms = (qn.getMessage() != null);\\n            if (rollbackUncoms) {\\n                errprintln(rb.getString(SqltoolRB.ABORTING, qn.getMessage()));\\n                throw new SqlToolError(qn.getMessage());\\n            }\\n            return;\\n        } finally {\\n            closeQueryOutputStream();\\n            if (fetchingVar != null) {\\n                errprintln(rb.getString(SqltoolRB.PLVAR_SET_INCOMPLETE,\\n                        fetchingVar));\\n                rollbackUncoms = true;\\n            }\\n            if (br != null) try {\\n                br.close();\\n            } catch (IOException ioe) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.INPUTREADER_CLOSEFAIL), ioe);\\n            }\\n            if (rollbackUncoms && possiblyUncommitteds.get()) {\\n                errprintln(rb.getString(SqltoolRB.ROLLINGBACK));\\n                curConn.rollback();\\n                possiblyUncommitteds.set(false);\\n            }\\n        }\\n    }\\n    private static String deTerminated(String inString) {\\n        int index = inString.lastIndexOf(';');\\n        if (index < 0) {\\n            return null;\\n        }\\n        for (int i = index + 1; i < inString.length(); i++) {\\n            if (!Character.isWhitespace(inString.charAt(i))) {\\n                return null;\\n            }\\n        }\\n        return inString.substring(0, index);\\n    }\\n    static private class BadSpecial extends AppendableException {\\n        static final long serialVersionUID = 7162440064026570590L;\\n        BadSpecial(String s) {\\n            super(s);\\n            if (s == null)\\n                throw new RuntimeException(\\n                        \\\"Must construct BadSpecials with non-null message\\\");\\n        }\\n        BadSpecial(String s, Throwable t) {\\n            super(s, t);\\n            if (s == null)\\n                throw new RuntimeException(\\n                        \\\"Must construct BadSpecials with non-null message\\\");\\n        }\\n    }\\n    private class QuitNow extends SqlToolError {\\n        static final long serialVersionUID = 1811094258670900488L;\\n        public QuitNow(String s) {\\n            super(s);\\n        }\\n        public QuitNow() {\\n            super();\\n        }\\n    }\\n    private class BreakException extends SqlToolError {\\n        static final long serialVersionUID = 351150072817675994L;\\n        public BreakException() {\\n            super();\\n        }\\n        public BreakException(String s) {\\n            super(s);\\n        }\\n    }\\n    private class ContinueException extends SqlToolError {\\n        static final long serialVersionUID = 5064604160827106014L;\\n        public ContinueException() {\\n            super();\\n        }\\n        public ContinueException(String s) {\\n            super(s);\\n        }\\n    }\\n    private class BadSubst extends Exception {\\n        static final long serialVersionUID = 7325933736897253269L;\\n        BadSubst(String s) {\\n            super(s);\\n        }\\n    }\\n    private class RowError extends AppendableException {\\n        static final long serialVersionUID = 754346434606022750L;\\n        RowError(String s) {\\n            super(s);\\n        }\\n        RowError(Throwable t) {\\n            this(null, t);\\n        }\\n        RowError(String s, Throwable t) {\\n            super(s, t);\\n        }\\n    }\\n    public void processFromBuffer()\\n            throws BadSpecial, SQLException, SqlToolError {\\n        historize();\\n        if (buffer.charAt(0) == '*' && (buffer.length() < 2\\n                || buffer.charAt(1) != '{')) {\\n                                    processPL(buffer);\\n            return;\\n        }\\n        if (buffer.charAt(0) == '\\\\\\\\') {\\n            processSpecial(buffer);\\n            return;\\n        }\\n        bufContainsSql = true;\\n        processSQL();\\n    }\\n    private void processBuffHist(String inString)\\n    throws BadSpecial, SQLException, SqlToolError {\\n        if (inString.length() < 1) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.BUFHIST_UNSPECIFIED));\\n        }\\n        char commandChar = inString.charAt(0);\\n        String other       = inString.substring(1);\\n        if (other.trim().length() == 0) {\\n            other = null;\\n        }\\n        switch (commandChar) {\\n            case ';' :\\n                enforce1charBH(other, ';');\\n                if (buffer == null) throw new BadSpecial(\\n                        rb.getString(SqltoolRB.NOBUFFER_YET));\\n                stdprintln(rb.getString(SqltoolRB.BUFFER_EXECUTING, buffer));\\n                processFromBuffer();\\n                return;\\n            case 'a' :\\n                if (buffer == null) throw new BadSpecial(\\n                        rb.getString(SqltoolRB.NOBUFFER_YET));\\n                immCmdSB.append(buffer);\\n                if (other != null) {\\n                    String deTerminated = SqlFile.deTerminated(other);\\n                    if (!other.equals(\\\";\\\")) {\\n                        immCmdSB.append(((deTerminated == null)\\n                                ? other : deTerminated));\\n                    }\\n                    if (deTerminated != null) {\\n                        setBuf(immCmdSB.toString());\\n                        immCmdSB.setLength(0);\\n                        stdprintln(rb.getString(SqltoolRB.BUFFER_EXECUTING,\\n                                buffer));\\n                        processFromBuffer();\\n                        return;\\n                    }\\n                }\\n                withholdPrompt = true;\\n                stdprint(immCmdSB.toString());\\n                return;\\n            case 'l' :\\n            case 'b' :\\n                enforce1charBH(other, 'l');\\n                if (buffer == null) {\\n                    stdprintln(nobufferYetString);\\n                } else {\\n                    stdprintln(rb.getString(SqltoolRB.EDITBUFFER_CONTENTS,\\n                            buffer));\\n                }\\n                return;\\n            case 'h' :\\n                enforce1charBH(other, 'h');\\n                showHistory();\\n                return;\\n            case '-' :\\n            case '0' :\\n            case '1' :\\n            case '2' :\\n            case '3' :\\n            case '4' :\\n            case '5' :\\n            case '6' :\\n            case '7' :\\n            case '8' :\\n            case '9' :\\n                boolean executeMode =\\n                    inString.charAt(inString.length() - 1) == ';';\\n                String numStr = inString.substring(0,\\n                        inString.length() + (executeMode ? -1 : 0));\\n                try {\\n                    setBuf(commandFromHistory(Integer.parseInt(numStr)));\\n                } catch (NumberFormatException nfe) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.COMMANDNUM_MALFORMAT, numStr), nfe);\\n                }\\n                if (executeMode) {\\n                    stdprintln(rb.getString(SqltoolRB.BUFFER_EXECUTING,\\n                            buffer));\\n                    processFromBuffer();\\n                } else {\\n                    stdprintln(rb.getString(SqltoolRB.BUFFER_RESTORED, buffer));\\n                }\\n                return;\\n            case 'w' :\\n                if (other == null) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.DESTFILE_DEMAND));\\n                }\\n                if (buffer == null || buffer.length() == 0) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.BUFFER_EMPTY));\\n                }\\n                PrintWriter pw = null;\\n                try {\\n                    pw = new PrintWriter((charset == null)\\n                            ?  (new OutputStreamWriter(\\n                                    new FileOutputStream(other.trim(), true)))\\n                            :  (new OutputStreamWriter(\\n                                    new FileOutputStream(other.trim(), true),\\n                                            charset))\\n                                                );\\n                    pw.println(buffer + (bufContainsSql ? \\\";\\\" : \\\"\\\"));\\n                    pw.flush();\\n                } catch (Exception e) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.FILE_APPENDFAIL,\\n                            other.trim()), e);\\n                } finally {\\n                    if (pw != null) pw.close();\\n                }\\n                return;\\n            case 's' :\\n                boolean modeExecute = false;\\n                boolean modeGlobal = false;\\n                try {\\n                    if (other == null || other.length() < 3) {\\n                        throw new BadSubst(rb.getString(\\n                                SqltoolRB.SUBSTITUTION_MALFORMAT));\\n                    }\\n                    Matcher m = substitutionPattern.matcher(inString);\\n                    if (buffer == null) {\\n                        stdprintln(nobufferYetString);\\n                        return;\\n                    }\\n                    if (!m.matches()) {\\n                        throw new BadSubst(rb.getString(\\n                                SqltoolRB.SUBSTITUTION_MALFORMAT));\\n                    }\\n                                        if (m.groupCount() < 3 || m.groupCount() > 4) {\\n                                                throw new RuntimeException(\\n                                \\\"Matched substitution pattern, but \\\"\\n                                + \\\"captured \\\" + m.groupCount() + \\\" groups\\\");\\n                    }\\n                    String optionGroup = (\\n                            (m.groupCount() > 3 && m.group(4) != null)\\n                            ? (new String(m.group(4))) : null);\\n                    if (optionGroup != null) {\\n                        if (optionGroup.indexOf(';') > -1) {\\n                            modeExecute = true;\\n                            optionGroup = optionGroup.replaceFirst(\\\";\\\", \\\"\\\");\\n                        }\\n                        if (optionGroup.indexOf('g') > -1) {\\n                            modeGlobal = true;\\n                            optionGroup = optionGroup.replaceFirst(\\\"g\\\", \\\"\\\");\\n                        }\\n                    }\\n                    Matcher bufferMatcher = Pattern.compile(\\\"(?s\\\"\\n                            + ((optionGroup == null) ? \\\"\\\" : optionGroup)\\n                            + ')' + m.group(2)).matcher(buffer);\\n                    String newBuffer = (modeGlobal\\n                            ? bufferMatcher.replaceAll(m.group(3))\\n                            : bufferMatcher.replaceFirst(m.group(3)));\\n                    if (newBuffer.equals(buffer)) {\\n                        stdprintln(rb.getString(\\n                                SqltoolRB.SUBSTITUTION_NOMATCH));\\n                        return;\\n                    }\\n                    setBuf(newBuffer);\\n                    stdprintln(rb.getString((modeExecute\\n                            ? SqltoolRB.BUFFER_EXECUTING\\n                            : SqltoolRB.EDITBUFFER_CONTENTS), buffer));\\n                } catch (PatternSyntaxException pse) {\\n                    throw new BadSpecial(\\n                            rb.getString(SqltoolRB.SUBSTITUTION_SYNTAX), pse);\\n                } catch (BadSubst badswitch) {\\n                    throw new BadSpecial(\\n                            rb.getString(SqltoolRB.SUBSTITUTION_SYNTAX));\\n                }\\n                if (modeExecute) {\\n                    immCmdSB.setLength(0);\\n                    processFromBuffer();\\n                }\\n                return;\\n            case '?' :\\n                stdprintln(rb.getString(SqltoolRB.BUFFER_HELP));\\n                return;\\n        }\\n        throw new BadSpecial(rb.getString(SqltoolRB.BUFFER_UNKNOWN,\\n                Character.toString(commandChar)));\\n    }\\n    private boolean doPrepare   = false;\\n    private String  prepareVar  = null;\\n    private String  dsvColDelim = null;\\n    private String  dsvSkipPrefix = null;\\n    private String  dsvRowDelim = null;\\n    private String  dsvSkipCols = null;\\n    private String  DSV_X_SYNTAX_MSG = null;\\n    private String  DSV_M_SYNTAX_MSG = null;\\n    private String  nobufferYetString = null;\\n    private void enforce1charSpecial(String token, char command)\\n            throws BadSpecial {\\n        if (token.length() != 1) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.SPECIAL_EXTRACHARS,\\n                     Character.toString(command), token.substring(1)));\\n        }\\n    }\\n    private void enforce1charBH(String token, char command)\\n            throws BadSpecial {\\n        if (token != null) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.BUFFER_EXTRACHARS,\\n                    Character.toString(command), token));\\n        }\\n    }\\n    private void processSpecial(String inString)\\n    throws BadSpecial, QuitNow, SQLException, SqlToolError {\\n        if (inString.equals(\\\"\\\\\\\\\\\")) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.SPECIAL_UNSPECIFIED));\\n        }\\n        Matcher m = specialPattern.matcher(\\n                plMode ? dereference(inString, false) : inString);\\n        if (!m.matches()) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.SPECIAL_MALFORMAT));\\n                                }\\n        if (m.groupCount() < 1 || m.groupCount() > 2) {\\n                        throw new RuntimeException(\\n                    \\\"Pattern matched, yet captured \\\" + m.groupCount()\\n                    + \\\" groups\\\");\\n        }\\n        String arg1 = m.group(1);\\n        String other = ((m.groupCount() > 1) ? m.group(2) : null);\\n        switch (arg1.charAt(0)) {\\n            case 'q' :\\n                enforce1charSpecial(arg1, 'q');\\n                if (other != null) {\\n                    throw new QuitNow(other);\\n                }\\n                throw new QuitNow();\\n            case 'H' :\\n                enforce1charSpecial(arg1, 'H');\\n                htmlMode = !htmlMode;\\n                stdprintln(rb.getString(SqltoolRB.HTML_MODE,\\n                        Boolean.toString(htmlMode)));\\n                return;\\n            case 'm' :\\n                if (arg1.equals(\\\"m?\\\") ||\\n                        (arg1.equals(\\\"m\\\") && other != null\\n                                 && other.equals(\\\"?\\\"))) {\\n                    stdprintln(DSV_OPTIONS_TEXT + LS + DSV_M_SYNTAX_MSG);\\n                    return;\\n                }\\n                if (arg1.length() != 1 || other == null) {\\n                    throw new BadSpecial(DSV_M_SYNTAX_MSG);\\n                }\\n                boolean noComments = other.charAt(other.length() - 1) == '*';\\n                String skipPrefix = null;\\n                if (noComments) {\\n                    other = other.substring(0, other.length()-1).trim();\\n                    if (other.length() < 1) {\\n                        throw new BadSpecial(DSV_M_SYNTAX_MSG);\\n                    }\\n                } else {\\n                    skipPrefix = dsvSkipPrefix;\\n                }\\n                int colonIndex = other.indexOf(\\\" :\\\");\\n                if (colonIndex > -1 && colonIndex < other.length() - 2) {\\n                    skipPrefix = other.substring(colonIndex + 2);\\n                    other = other.substring(0, colonIndex).trim();\\n                }\\n                importDsv(other, skipPrefix);\\n                return;\\n            case 'x' :\\n                if (arg1.equals(\\\"x?\\\") ||\\n                        (arg1.equals(\\\"x\\\") && other != null\\n                                 && other.equals(\\\"?\\\"))) {\\n                    stdprintln(DSV_OPTIONS_TEXT + LS + DSV_X_SYNTAX_MSG);\\n                    return;\\n                }\\n                try {\\n                    if (arg1.length() != 1 || other == null) {\\n                        throw new BadSpecial(DSV_X_SYNTAX_MSG);\\n                    }\\n                    String tableName = ((other.indexOf(' ') > 0) ? null\\n                                                                 : other);\\n                    if (dsvTargetFile == null && tableName == null) {\\n                        throw new BadSpecial(rb.getString(\\n                                    SqltoolRB.DSV_TARGETFILE_DEMAND));\\n                    }\\n                    File dsvFile = new File((dsvTargetFile == null)\\n                                            ? (tableName + \\\".dsv\\\")\\n                                            : dsvTargetFile);\\n                    pwDsv = new PrintWriter((charset == null)\\n                       ? (new OutputStreamWriter(new FileOutputStream(dsvFile)))\\n                       : (new OutputStreamWriter(new FileOutputStream(dsvFile),\\n                               charset)));\\n                    ResultSet rs = curConn.createStatement().executeQuery(\\n                            (tableName == null) ? other\\n                                                : (\\\"SELECT * FROM \\\"\\n                                                   + tableName));\\n                    List colList = new ArrayList();\\n                    int[] incCols = null;\\n                    if (dsvSkipCols != null) {\\n                        Set skipCols = new HashSet();\\n                        String[] skipColsArray = dsvSkipCols.split(\\\"\\\\\\\\s*\\\\\\\\Q\\\"\\n                                + dsvColDelim + \\\"\\\\\\\\E\\\\\\\\s*\\\");\\n                        for (int i = 0; i < skipColsArray.length; i++) {\\n                            skipCols.add(skipColsArray[i].toLowerCase());\\n                        }\\n                        ResultSetMetaData rsmd = rs.getMetaData();\\n                        for (int i = 1; i <= rsmd.getColumnCount(); i++) {\\n                            if (!skipCols.remove(rsmd.getColumnName(i)\\n                                    .toLowerCase())) {\\n                                colList.add(new Integer(i));\\n                            }\\n                        }\\n                        if (colList.size() < 1) {\\n                            throw new BadSpecial(rb.getString(\\n                                    SqltoolRB.DSV_NOCOLSLEFT, dsvSkipCols));\\n                        }\\n                        if (skipCols.size() > 0) {\\n                            throw new BadSpecial(rb.getString(\\n                                    SqltoolRB.DSV_SKIPCOLS_MISSING,\\n                                        skipCols.toString()));\\n                        }\\n                        incCols = new int[colList.size()];\\n                        for (int i = 0; i < incCols.length; i++) {\\n                            incCols[i] = ((Integer) colList.get(i)).intValue();\\n                        }\\n                    }\\n                    displayResultSet(null, rs, incCols, null);\\n                    pwDsv.flush();\\n                    stdprintln(rb.getString(SqltoolRB.FILE_WROTECHARS,\\n                            Long.toString(dsvFile.length()),\\n                            dsvFile.toString()));\\n                } catch (FileNotFoundException e) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.FILE_WRITEFAIL,\\n                            other), e);\\n                } catch (UnsupportedEncodingException e) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.FILE_WRITEFAIL,\\n                            other), e);\\n                } finally {\\n                                        if (pwDsv != null) {\\n                        pwDsv.close();\\n                    }\\n                    pwDsv       = null;\\n                }\\n                return;\\n            case 'd' :\\n                if (arg1.equals(\\\"d?\\\") ||\\n                        (arg1.equals(\\\"d\\\") && other != null\\n                                 && other.equals(\\\"?\\\"))) {\\n                    stdprintln(D_OPTIONS_TEXT);\\n                    return;\\n                }\\n                if (arg1.length() == 2) {\\n                    listTables(arg1.charAt(1), other);\\n                    return;\\n                }\\n                if (arg1.length() == 1 && other != null) try {\\n                    int space = other.indexOf(' ');\\n                    if (space < 0) {\\n                        describe(other, null);\\n                    } else {\\n                        describe(other.substring(0, space),\\n                                 other.substring(space + 1).trim());\\n                    }\\n                    return;\\n                } catch (SQLException se) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.METADATA_FETCH_FAIL), se);\\n                }\\n                throw new BadSpecial(rb.getString(SqltoolRB.SPECIAL_D_LIKE));\\n            case 'o' :\\n                enforce1charSpecial(arg1, 'o');\\n                if (other == null) {\\n                    if (pwQuery == null) {\\n                        throw new BadSpecial(rb.getString(\\n                                SqltoolRB.OUTPUTFILE_NONETOCLOSE));\\n                    }\\n                    closeQueryOutputStream();\\n                    return;\\n                }\\n                if (pwQuery != null) {\\n                    stdprintln(rb.getString(SqltoolRB.OUTPUTFILE_REOPENING));\\n                    closeQueryOutputStream();\\n                }\\n                try {\\n                    pwQuery = new PrintWriter((charset == null)\\n                            ? (new OutputStreamWriter(\\n                                    new FileOutputStream(other, true)))\\n                            : (new OutputStreamWriter(\\n                                    new FileOutputStream(other, true), charset))\\n                    );\\n                    pwQuery.println((htmlMode\\n                            ? (\\\"<HTML>\\\" + LS + \\\"<!--\\\")\\n                            : \\\"#\\\") + \\\" \\\" + (new java.util.Date()) + \\\".  \\\"\\n                                    + rb.getString(SqltoolRB.OUTPUTFILE_HEADER,\\n                                            getClass().getName())\\n                                    + (htmlMode ? (\\\" -->\\\" + LS + LS + \\\"<BODY>\\\")\\n                                                : LS));\\n                    pwQuery.flush();\\n                } catch (Exception e) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.FILE_WRITEFAIL,\\n                            other), e);\\n                }\\n                return;\\n            case 'i' :\\n                enforce1charSpecial(arg1, 'i');\\n                if (other == null) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.SQLFILE_NAME_DEMAND));\\n                }\\n                try {\\n                    SqlFile sf = new SqlFile(new File(other), false, userVars);\\n                    sf.recursed = true;\\n                                        sf.possiblyUncommitteds = possiblyUncommitteds;\\n                    sf.plMode               = plMode;\\n                    sf.execute(curConn, continueOnError);\\n                } catch (ContinueException ce) {\\n                    throw ce;\\n                } catch (BreakException be) {\\n                    String beMessage = be.getMessage();\\n                                        if (beMessage != null &&!beMessage.equals(\\\"file\\\")) {\\n                        throw be;\\n                    }\\n                } catch (QuitNow qn) {\\n                    throw qn;\\n                } catch (Exception e) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.SQLFILE_EXECUTE_FAIL, other), e);\\n                }\\n                return;\\n            case 'p' :\\n                enforce1charSpecial(arg1, 'p');\\n                if (other == null) {\\n                    stdprintln(true);\\n                } else {\\n                    stdprintln(other, true);\\n                }\\n                return;\\n            case 'a' :\\n                enforce1charSpecial(arg1, 'a');\\n                if (other != null) {\\n                    curConn.setAutoCommit(\\n                        Boolean.valueOf(other).booleanValue());\\n                }\\n                stdprintln(rb.getString(SqltoolRB.A_SETTING,\\n                        Boolean.toString(curConn.getAutoCommit())));\\n                return;\\n            case '=' :\\n                enforce1charSpecial(arg1, '=');\\n                curConn.commit();\\n                possiblyUncommitteds.set(false);\\n                stdprintln(rb.getString(SqltoolRB.COMMITTED));\\n                return;\\n            case 'b' :\\n                if (arg1.length() == 1) {\\n                    if (other != null) {\\n                        throw new BadSpecial(rb.getString(\\n                                SqltoolRB.SPECIAL_B_MALFORMAT));\\n                    }\\n                    fetchBinary = true;\\n                    return;\\n                }\\n                if (arg1.charAt(1) == 'p') {\\n                    if (other != null) {\\n                        throw new BadSpecial(rb.getString(\\n                                SqltoolRB.SPECIAL_B_MALFORMAT));\\n                    }\\n                    doPrepare = true;\\n                    return;\\n                }\\n                if ((arg1.charAt(1) != 'd' && arg1.charAt(1) != 'l')\\n                        || other == null) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.SPECIAL_B_MALFORMAT));\\n                }\\n                File file = new File(other);\\n                try {\\n                    if (arg1.charAt(1) == 'd') {\\n                        dump(file);\\n                    } else {\\n                        binBuffer = SqlFile.loadBinary(file);\\n                        stdprintln(rb.getString(\\n                                SqltoolRB.BINARY_LOADEDBYTESINTO,\\n                                        binBuffer.length));\\n                    }\\n                } catch (BadSpecial bs) {\\n                    throw bs;\\n                } catch (IOException ioe) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.BINARY_FILEFAIL,\\n                            other), ioe);\\n                }\\n                return;\\n            case '*' :\\n            case 'c' :\\n                enforce1charSpecial(arg1, '=');\\n                if (other != null) {\\n                                        continueOnError = Boolean.valueOf(other).booleanValue();\\n                }\\n                stdprintln(rb.getString(SqltoolRB.C_SETTING,\\n                        Boolean.toString(continueOnError)));\\n                return;\\n            case '?' :\\n                stdprintln(rb.getString(SqltoolRB.SPECIAL_HELP));\\n                return;\\n            case '!' :\\n                                                                                InputStream stream;\\n                byte[]      ba         = new byte[1024];\\n                String      extCommand = ((arg1.length() == 1)\\n                        ? \\\"\\\" : arg1.substring(1))\\n                    + ((arg1.length() > 1 && other != null)\\n                       ? \\\" \\\" : \\\"\\\") + ((other == null) ? \\\"\\\" : other);\\n                if (extCommand.trim().length() < 1)\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.BANG_INCOMPLETE));\\n                try {\\n                    Runtime runtime = Runtime.getRuntime();\\n                    Process proc = ((wincmdPattern == null)\\n                            ? runtime.exec(extCommand)\\n                            : runtime.exec(genWinArgs(extCommand))\\n                    );\\n                    proc.getOutputStream().close();\\n                    int i;\\n                    stream = proc.getInputStream();\\n                    while ((i = stream.read(ba)) > 0) {\\n                        stdprint(new String(ba, 0, i));\\n                    }\\n                    stream.close();\\n                    stream = proc.getErrorStream();\\n                    while ((i = stream.read(ba)) > 0) {\\n                        errprint(new String(ba, 0, i));\\n                    }\\n                    stream.close();\\n                    if (proc.waitFor() != 0) {\\n                        throw new BadSpecial(rb.getString(\\n                                SqltoolRB.BANG_COMMAND_FAIL, extCommand));\\n                    }\\n                } catch (BadSpecial bs) {\\n                    throw bs;\\n                } catch (Exception e) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.BANG_COMMAND_FAIL, extCommand), e);\\n                }\\n                return;\\n            case '.' :\\n                enforce1charSpecial(arg1, '.');\\n                rawMode = RAW_EMPTY;\\n                if (interactive) {\\n                    stdprintln(RAW_LEADIN_MSG);\\n                }\\n                return;\\n        }\\n        throw new BadSpecial(rb.getString(SqltoolRB.SPECIAL_UNKNOWN,\\n                Character.toString(arg1.charAt(0))));\\n    }\\n    private static final char[] nonVarChars = {\\n        ' ', '\\\\t', '=', '}', '\\\\n', '\\\\r'\\n    };\\n    static int pastName(String inString, int startIndex) {\\n        String workString = inString.substring(startIndex);\\n        int    e          = inString.length();            int    nonVarIndex;\\n        for (int i = 0; i < nonVarChars.length; i++) {\\n            nonVarIndex = workString.indexOf(nonVarChars[i]);\\n            if (nonVarIndex > -1 && nonVarIndex < e) {\\n                e = nonVarIndex;\\n            }\\n        }\\n        return startIndex + e;\\n    }\\n    private String dereference(String inString,\\n                               boolean permitAlias) throws SqlToolError {\\n        String       varName, varValue;\\n        StringBuffer expandBuffer = new StringBuffer(inString);\\n        int          b, e;            int iterations;\\n        if (permitAlias && inString.trim().charAt(0) == '/') {\\n            int slashIndex = inString.indexOf('/');\\n            e = SqlFile.pastName(inString.substring(slashIndex + 1), 0);\\n                        if (e < 1) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.PLALIAS_MALFORMAT));\\n            }\\n            varName  = inString.substring(slashIndex + 1, slashIndex + 1 + e);\\n            varValue = (String) userVars.get(varName);\\n            if (varValue == null) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.PLVAR_UNDEFINED, varName));\\n            }\\n            expandBuffer.replace(slashIndex, slashIndex + 1 + e,\\n                                 (String) userVars.get(varName));\\n        }\\n        String s;\\n        boolean permitUnset;\\n        iterations = 0;\\n        while (true) {\\n            s = expandBuffer.toString();\\n            b = s.indexOf(\\\"${\\\");\\n            if (b < 0) {\\n                                break;\\n            }\\n            e = s.indexOf('}', b + 2);\\n            if (e == b + 2) {\\n                throw new SqlToolError(rb.getString(SqltoolRB.SYSPROP_EMPTY));\\n            }\\n            if (e < 0) {\\n                throw new SqlToolError(rb.getString(\\n                            SqltoolRB.SYSPROP_UNTERMINATED));\\n            }\\n            permitUnset = (s.charAt(b + 2) == ':');\\n            varName = s.substring(b + (permitUnset ? 3 : 2), e);\\n            if (iterations++ > 10000)\\n                throw new SqlToolError(rb.getString(SqltoolRB.VAR_INFINITE,\\n                        varName));\\n            varValue = System.getProperty(varName);\\n            if (varValue == null) {\\n                if (permitUnset) {\\n                    varValue = \\\"\\\";\\n                } else {\\n                    throw new SqlToolError(rb.getString(\\n                            SqltoolRB.SYSPROP_UNDEFINED, varName));\\n                }\\n            }\\n            expandBuffer.replace(b, e + 1, varValue);\\n        }\\n        iterations = 0;\\n        while (true) {\\n            s = expandBuffer.toString();\\n            b = s.indexOf(\\\"*{\\\");\\n            if (b < 0) {\\n                                break;\\n            }\\n            e = s.indexOf('}', b + 2);\\n            if (e == b + 2) {\\n                throw new SqlToolError(rb.getString(SqltoolRB.PLVAR_NAMEEMPTY));\\n            }\\n            if (e < 0) {\\n                throw new SqlToolError(rb.getString(\\n                            SqltoolRB.PLVAR_UNTERMINATED));\\n            }\\n            permitUnset = (s.charAt(b + 2) == ':');\\n            varName = s.substring(b + (permitUnset ? 3 : 2), e);\\n            if (iterations++ > 10000)\\n                throw new SqlToolError(rb.getString(SqltoolRB.VAR_INFINITE,\\n                        varName));\\n            varValue = (String) userVars.get(varName);\\n            if (varValue == null) {\\n                if (permitUnset) {\\n                    varValue = \\\"\\\";\\n                } else {\\n                    throw new SqlToolError(rb.getString(\\n                            SqltoolRB.PLVAR_UNDEFINED, varName));\\n                }\\n            }\\n            expandBuffer.replace(b, e + 1, varValue);\\n        }\\n        return expandBuffer.toString();\\n    }\\n    public boolean plMode = false;\\n        private String  fetchingVar = null;\\n    private boolean silentFetch = false;\\n    private boolean fetchBinary = false;\\n    private void processPL(String inString) throws BadSpecial, SqlToolError {\\n        Matcher m = plPattern.matcher(dereference(inString, false));\\n        if (!m.matches()) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.PL_MALFORMAT));\\n                                }\\n        if (m.groupCount() < 1 || m.group(1) == null) {\\n            plMode = true;\\n            stdprintln(rb.getString(SqltoolRB.PL_EXPANSIONMODE, \\\"on\\\"));\\n            return;\\n        }\\n        String[] tokens = m.group(1).split(\\\"\\\\\\\\s+\\\");\\n        if (tokens[0].charAt(0) == '?') {\\n            stdprintln(rb.getString(SqltoolRB.PL_HELP));\\n            return;\\n        }\\n                plMode = true;\\n        if (tokens[0].equals(\\\"end\\\")) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.END_NOBLOCK));\\n        }\\n        if (tokens[0].equals(\\\"continue\\\")) {\\n            if (tokens.length > 1) {\\n                if (tokens.length == 2 &&\\n                        (tokens[1].equals(\\\"foreach\\\") ||\\n                         tokens[1].equals(\\\"while\\\"))) {\\n                    throw new ContinueException(tokens[1]);\\n                }\\n                throw new BadSpecial(rb.getString(SqltoolRB.CONTINUE_SYNTAX));\\n            }\\n            throw new ContinueException();\\n        }\\n        if (tokens[0].equals(\\\"break\\\")) {\\n            if (tokens.length > 1) {\\n                if (tokens.length == 2 &&\\n                        (tokens[1].equals(\\\"foreach\\\") ||\\n                         tokens[1].equals(\\\"if\\\") ||\\n                         tokens[1].equals(\\\"while\\\") ||\\n                         tokens[1].equals(\\\"file\\\"))) {\\n                    throw new BreakException(tokens[1]);\\n                }\\n                throw new BadSpecial(rb.getString(SqltoolRB.BREAK_SYNTAX));\\n            }\\n            throw new BreakException();\\n        }\\n        if (tokens[0].equals(\\\"list\\\") || tokens[0].equals(\\\"listvalues\\\")\\n                || tokens[0].equals(\\\"listsysprops\\\")) {\\n            boolean sysProps =tokens[0].equals(\\\"listsysprops\\\");\\n            String  s;\\n            boolean doValues = (tokens[0].equals(\\\"listvalues\\\") || sysProps);\\n            if (tokens.length == 1) {\\n                stdprint(formatNicely(\\n                        (sysProps ? System.getProperties() : userVars),\\n                        doValues));\\n            } else {\\n                if (doValues) {\\n                    stdprintln(rb.getString(SqltoolRB.PL_LIST_PARENS));\\n                } else {\\n                    stdprintln(rb.getString(SqltoolRB.PL_LIST_LENGTHS));\\n                }\\n                for (int i = 1; i < tokens.length; i++) {\\n                    s = (String) (sysProps ? System.getProperties() : userVars).\\n                            get(tokens[i]);\\n                    if (s == null) continue;\\n                    stdprintln(\\\"    \\\" + tokens[i] + \\\": \\\"\\n                               + (doValues ? (\\\"(\\\" + s + ')')\\n                                           : Integer.toString(s.length())));\\n                }\\n            }\\n            return;\\n        }\\n        if (tokens[0].equals(\\\"dump\\\") || tokens[0].equals(\\\"load\\\")) {\\n            if (tokens.length != 3) {\\n                throw new BadSpecial(rb.getString(\\n                        SqltoolRB.DUMPLOAD_MALFORMAT));\\n            }\\n            String varName = tokens[1];\\n            if (varName.indexOf(':') > -1) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.PLVAR_NOCOLON));\\n            }\\n            File   file    = new File(tokens[2]);\\n            try {\\n                if (tokens[0].equals(\\\"dump\\\")) {\\n                    dump(varName, file);\\n                } else {\\n                    load(varName, file, charset);\\n                }\\n            } catch (IOException ioe) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.DUMPLOAD_FAIL,\\n                        varName, file.toString()), ioe);\\n            }\\n            return;\\n        }\\n        if (tokens[0].equals(\\\"prepare\\\")) {\\n            if (tokens.length != 2) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.PREPARE_MALFORMAT));\\n            }\\n            if (userVars.get(tokens[1]) == null) {\\n                throw new BadSpecial(rb.getString(\\n                    SqltoolRB.PLVAR_UNDEFINED, tokens[1]));\\n            }\\n            prepareVar = tokens[1];\\n            doPrepare  = true;\\n            return;\\n        }\\n        if (tokens[0].equals(\\\"foreach\\\")) {\\n            Matcher foreachM= foreachPattern.matcher(\\n                    dereference(inString, false));\\n            if (!foreachM.matches()) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.FOREACH_MALFORMAT));\\n            }\\n            if (foreachM.groupCount() != 2) {\\n                throw new RuntimeException(\\n                        \\\"foreach pattern matched, but captured \\\"\\n                        + foreachM.groupCount() + \\\" groups\\\");\\n            }\\n            String varName   = foreachM.group(1);\\n            if (varName.indexOf(':') > -1) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.PLVAR_NOCOLON));\\n            }\\n            String[] values = foreachM.group(2).split(\\\"\\\\\\\\s+\\\");\\n            File   tmpFile = null;\\n            String varVal;\\n            try {\\n                tmpFile = plBlockFile(\\\"foreach\\\");\\n            } catch (IOException ioe) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.PL_TEMPFILE_FAIL),\\n                    ioe);\\n            }\\n            String origval = (String) userVars.get(varName);\\n            try {\\n                SqlFile sf;\\n                for (int i = 0; i < values.length; i++) {\\n                    try {\\n                        varVal = values[i];\\n                        userVars.put(varName, varVal);\\n                        updateUserSettings();\\n                        sf          = new SqlFile(tmpFile, false, userVars);\\n                        sf.plMode   = true;\\n                        sf.recursed = true;\\n                                                sf.possiblyUncommitteds = possiblyUncommitteds;\\n                        sf.execute(curConn, continueOnError);\\n                    } catch (ContinueException ce) {\\n                        String ceMessage = ce.getMessage();\\n                        if (ceMessage != null\\n                                &&!ceMessage.equals(\\\"foreach\\\")) {\\n                            throw ce;\\n                        }\\n                    }\\n                }\\n            } catch (BreakException be) {\\n                String beMessage = be.getMessage();\\n                                if (beMessage != null &&!beMessage.equals(\\\"foreach\\\")) {\\n                    throw be;\\n                }\\n            } catch (QuitNow qn) {\\n                throw qn;\\n            } catch (Exception e) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.PL_BLOCK_FAIL), e);\\n            }\\n            if (origval == null) {\\n                userVars.remove(varName);\\n                updateUserSettings();\\n            } else {\\n                userVars.put(varName, origval);\\n            }\\n            if (tmpFile != null &&!tmpFile.delete()) {\\n                throw new BadSpecial(rb.getString(\\n                        SqltoolRB.TEMPFILE_REMOVAL_FAIL, tmpFile.toString()));\\n            }\\n            return;\\n        }\\n        if (tokens[0].equals(\\\"if\\\") || tokens[0].equals(\\\"while\\\")) {\\n            Matcher ifwhileM= ifwhilePattern.matcher(\\n                    dereference(inString, false));\\n            if (!ifwhileM.matches()) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.IFWHILE_MALFORMAT));\\n            }\\n            if (ifwhileM.groupCount() != 1) {\\n                throw new RuntimeException(\\n                        \\\"if/while pattern matched, but captured \\\"\\n                        + ifwhileM.groupCount() + \\\" groups\\\");\\n            }\\n            String[] values =\\n                    ifwhileM.group(1).replaceAll(\\\"!([a-zA-Z0-9*])\\\", \\\"! $1\\\").\\n                            replaceAll(\\\"([a-zA-Z0-9*])!\\\", \\\"$1 !\\\").split(\\\"\\\\\\\\s+\\\");\\n            File tmpFile = null;\\n            if (tokens[0].equals(\\\"if\\\")) {\\n                try {\\n                    tmpFile = plBlockFile(\\\"if\\\");\\n                } catch (IOException ioe) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.PL_BLOCK_FAIL),\\n                            ioe);\\n                }\\n                try {\\n                    if (eval(values)) {\\n                        SqlFile sf = new SqlFile(tmpFile, false, userVars);\\n                        sf.plMode   = true;\\n                        sf.recursed = true;\\n                                                sf.possiblyUncommitteds = possiblyUncommitteds;\\n                        sf.execute(curConn, continueOnError);\\n                    }\\n                } catch (BreakException be) {\\n                    String beMessage = be.getMessage();\\n                                        if (beMessage == null ||!beMessage.equals(\\\"if\\\")) {\\n                        throw be;\\n                    }\\n                } catch (ContinueException ce) {\\n                    throw ce;\\n                } catch (QuitNow qn) {\\n                    throw qn;\\n                } catch (BadSpecial bs) {\\n                    bs.appendMessage(rb.getString(SqltoolRB.IF_MALFORMAT));\\n                    throw bs;\\n                } catch (Exception e) {\\n                    throw new BadSpecial(\\n                        rb.getString(SqltoolRB.PL_BLOCK_FAIL), e);\\n                }\\n            } else if (tokens[0].equals(\\\"while\\\")) {\\n                try {\\n                    tmpFile = plBlockFile(\\\"while\\\");\\n                } catch (IOException ioe) {\\n                    throw new BadSpecial(\\n                        rb.getString(SqltoolRB.PL_TEMPFILE_FAIL), ioe);\\n                }\\n                try {\\n                    SqlFile sf;\\n                    while (eval(values)) {\\n                        try {\\n                            sf          = new SqlFile(tmpFile, false, userVars);\\n                            sf.recursed = true;\\n                                                        sf.possiblyUncommitteds = possiblyUncommitteds;\\n                            sf.plMode               = true;\\n                            sf.execute(curConn, continueOnError);\\n                        } catch (ContinueException ce) {\\n                            String ceMessage = ce.getMessage();\\n                            if (ceMessage != null &&!ceMessage.equals(\\\"while\\\")) {\\n                                throw ce;\\n                            }\\n                        }\\n                    }\\n                } catch (BreakException be) {\\n                    String beMessage = be.getMessage();\\n                                        if (beMessage != null &&!beMessage.equals(\\\"while\\\")) {\\n                        throw be;\\n                    }\\n                } catch (QuitNow qn) {\\n                    throw qn;\\n                } catch (BadSpecial bs) {\\n                    bs.appendMessage(rb.getString(SqltoolRB.WHILE_MALFORMAT));\\n                    throw bs;\\n                } catch (Exception e) {\\n                    throw new BadSpecial(rb.getString(SqltoolRB.PL_BLOCK_FAIL),\\n                            e);\\n                }\\n            } else {\\n                                throw new RuntimeException(rb.getString(SqltoolRB.PL_UNKNOWN,\\n                        tokens[0]));\\n            }\\n            if (tmpFile != null &&!tmpFile.delete()) {\\n                throw new BadSpecial(rb.getString(\\n                        SqltoolRB.TEMPFILE_REMOVAL_FAIL, tmpFile.toString()));\\n            }\\n            return;\\n        }\\n        m = varsetPattern.matcher(dereference(inString, false));\\n        if (!m.matches()) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.PL_UNKNOWN, tokens[0]));\\n        }\\n        if (m.groupCount() < 2 || m.groupCount() > 3) {\\n                        throw new RuntimeException(\\\"varset pattern matched but captured \\\"\\n                    + m.groupCount() + \\\" groups\\\");\\n        }\\n        String varName  = m.group(1);\\n        if (varName.indexOf(':') > -1) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.PLVAR_NOCOLON));\\n        }\\n        switch (m.group(2).charAt(0)) {\\n            case '_' :\\n                silentFetch = true;\\n            case '~' :\\n                if (m.groupCount() > 2 && m.group(3) != null) {\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.PLVAR_TILDEDASH_NOMOREARGS, m.group(3)));\\n                }\\n                userVars.remove(varName);\\n                updateUserSettings();\\n                fetchingVar = varName;\\n                return;\\n            case '=' :\\n                if (fetchingVar != null && fetchingVar.equals(varName)) {\\n                    fetchingVar = null;\\n                }\\n                if (m.groupCount() > 2 && m.group(3) != null) {\\n                    userVars.put(varName, m.group(3));\\n                } else {\\n                    userVars.remove(varName);\\n                }\\n                updateUserSettings();\\n                return;\\n        }\\n        throw new BadSpecial(rb.getString(SqltoolRB.PL_UNKNOWN, tokens[0]));\\n            }\\n    private File plBlockFile(String seeking) throws IOException, SqlToolError {\\n        String          s;\\n                                int    nestlevel = 1;\\n        String curPlCommand;\\n        if (seeking == null\\n                || ((!seeking.equals(\\\"foreach\\\")) && (!seeking.equals(\\\"if\\\"))\\n                    && (!seeking.equals(\\\"while\\\")))) {\\n            throw new RuntimeException(\\n                \\\"Assertion failed.  Unsupported PL block type:  \\\" + seeking);\\n        }\\n        File tmpFile = File.createTempFile(\\\"sqltool-\\\", \\\".sql\\\");\\n        PrintWriter pw = new PrintWriter((charset == null)\\n                ?  (new OutputStreamWriter(new FileOutputStream(tmpFile)))\\n                :  (new OutputStreamWriter(new FileOutputStream(tmpFile),\\n                        charset)));\\n        try {\\n        pw.println(\\\"\\\");\\n        pw.println();\\n        Matcher m;\\n        while (true) {\\n            s = br.readLine();\\n            if (s == null) {\\n                s = rb.getString(SqltoolRB.PL_BLOCK_UNTERMINATED, seeking);\\n                errprintln(s);\\n                throw new SqlToolError(s);\\n            }\\n            curLinenum++;\\n            m = plPattern.matcher(s);\\n            if (m.matches() && m.groupCount() > 0 && m.group(1) != null) {\\n                String[] tokens = m.group(1).split(\\\"\\\\\\\\s+\\\");\\n                curPlCommand = tokens[0];\\n                                if (curPlCommand.equals(seeking)) {\\n                    nestlevel++;\\n                } else if (curPlCommand.equals(\\\"end\\\")) {\\n                    if (tokens.length < 2) {\\n                        s = rb.getString(SqltoolRB.END_SYNTAX, \\\"1\\\");\\n                        errprintln(s);\\n                        throw new SqlToolError(s);\\n                    }\\n                    String inType = tokens[1];\\n                    if (inType.equals(seeking)) {\\n                        nestlevel--;\\n                        if (nestlevel < 1) {\\n                            break;\\n                        }\\n                    }\\n                    if ((!inType.equals(\\\"foreach\\\")) && (!inType.equals(\\\"if\\\"))\\n                            && (!inType.equals(\\\"while\\\"))) {\\n                        s = rb.getString(SqltoolRB.END_SYNTAX, \\\"2\\\");\\n                        errprintln(s);\\n                        throw new SqlToolError(s);\\n                    }\\n                }\\n            }\\n            pw.println(s);\\n        }\\n        pw.flush();\\n        } finally {\\n            pw.close();\\n        }\\n        return tmpFile;\\n    }\\n    private void stdprint(String s) {\\n        stdprint(s, false);\\n    }\\n    private void stdprintln(String s) {\\n        stdprintln(s, false);\\n    }\\n    private void stdprintln(boolean queryOutput) {\\n        if (htmlMode) {\\n            psStd.println(\\\"<BR>\\\");\\n        } else {\\n            psStd.println();\\n        }\\n        if (queryOutput && pwQuery != null) {\\n            if (htmlMode) {\\n                pwQuery.println(\\\"<BR>\\\");\\n            } else {\\n                pwQuery.println();\\n            }\\n            pwQuery.flush();\\n        }\\n    }\\n    private void errprint(String s) {\\n        psErr.print(htmlMode\\n                    ? (\\\"<DIV style='color:white; background: red; \\\"\\n                       + \\\"font-weight: bold'>\\\" + s + \\\"</DIV>\\\")\\n                    : s);\\n    }\\n    private void errprintln(String s) {\\n        psErr.println(htmlMode\\n                      ? (\\\"<DIV style='color:white; background: red; \\\"\\n                         + \\\"font-weight: bold'>\\\" + s + \\\"</DIV>\\\")\\n                      : s);\\n    }\\n    private void stdprint(String s, boolean queryOutput) {\\n        psStd.print(htmlMode ? (\\\"<P>\\\" + s + \\\"</P>\\\")\\n                             : s);\\n        if (queryOutput && pwQuery != null) {\\n            pwQuery.print(htmlMode ? (\\\"<P>\\\" + s + \\\"</P>\\\")\\n                                   : s);\\n            pwQuery.flush();\\n        }\\n    }\\n    private void stdprintln(String s, boolean queryOutput) {\\n        psStd.println(htmlMode ? (\\\"<P>\\\" + s + \\\"</P>\\\")\\n                               : s);\\n        if (queryOutput && pwQuery != null) {\\n            pwQuery.println(htmlMode ? (\\\"<P>\\\" + s + \\\"</P>\\\")\\n                                     : s);\\n            pwQuery.flush();\\n        }\\n    }\\n                private static final String DEFAULT_NULL_REP = \\\"[null]\\\";\\n    private static final String DEFAULT_ROW_DELIM = LS;\\n    private static final String DEFAULT_COL_DELIM = \\\"|\\\";\\n    private static final String DEFAULT_SKIP_PREFIX = \\\"#\\\";\\n    private static final int    DEFAULT_ELEMENT   = 0,\\n                                HSQLDB_ELEMENT    = 1,\\n                                ORACLE_ELEMENT    = 2\\n    ;\\n        private static final int[] listMDSchemaCols = { 1 };\\n    private static final int[] listMDIndexCols  = {\\n        2, 6, 3, 9, 4, 10, 11\\n    };\\n    private static final int[][] listMDTableCols = {\\n        {\\n            2, 3\\n        },            {\\n            2, 3\\n        },            {\\n            2, 3\\n        },        };\\n    private static final String[] oracleSysSchemas = {\\n        \\\"SYS\\\", \\\"SYSTEM\\\", \\\"OUTLN\\\", \\\"DBSNMP\\\", \\\"OUTLN\\\", \\\"MDSYS\\\", \\\"ORDSYS\\\",\\n        \\\"ORDPLUGINS\\\", \\\"CTXSYS\\\", \\\"DSSYS\\\", \\\"PERFSTAT\\\", \\\"WKPROXY\\\", \\\"WKSYS\\\",\\n        \\\"WMSYS\\\", \\\"XDB\\\", \\\"ANONYMOUS\\\", \\\"ODM\\\", \\\"ODM_MTR\\\", \\\"OLAPSYS\\\", \\\"TRACESVR\\\",\\n        \\\"REPADMIN\\\"\\n    };\\n    private void listTables(char c, String inFilter) throws BadSpecial,\\n            SqlToolError {\\n        String   schema  = null;\\n        int[]    listSet = null;\\n        String[] types   = null;\\n        String[] additionalSchemas = null;\\n        Statement statement = null;\\n        ResultSet rs        = null;\\n        String    narrower  = \\\"\\\";\\n        String filter = inFilter;\\n        try {\\n            DatabaseMetaData md            = curConn.getMetaData();\\n            String           dbProductName = md.getDatabaseProductName();\\n            types = new String[1];\\n            switch (c) {\\n                case '*' :\\n                    types = null;\\n                    break;\\n                case 'S' :\\n                    if (dbProductName.indexOf(\\\"Oracle\\\") > -1) {\\n                        errprintln(rb.getString(SqltoolRB.VENDOR_ORACLE_DS));\\n                        types[0]          = \\\"TABLE\\\";\\n                        schema            = \\\"SYS\\\";\\n                        additionalSchemas = oracleSysSchemas;\\n                    } else {\\n                        types[0] = \\\"SYSTEM TABLE\\\";\\n                    }\\n                    break;\\n                case 's' :\\n                    if (dbProductName.indexOf(\\\"HSQL\\\") > -1) {\\n                                                                                                if (filter != null\\n                                && filter.charAt(filter.length() - 1)\\n                                   == '.') {\\n                            narrower =\\n                                \\\"\\\\nWHERE sequence_schema = '\\\"\\n                                + filter.substring(0, filter.length() - 1)\\n                                + \\\"'\\\";\\n                            filter = null;\\n                        }\\n                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT sequence_schema, sequence_name FROM \\\"\\n                            + \\\"information_schema.system_sequences\\\"\\n                            + narrower);\\n                    } else {\\n                        types[0] = \\\"SEQUENCE\\\";\\n                    }\\n                    break;\\n                case 'r' :\\n                    if (dbProductName.indexOf(\\\"HSQL\\\") > -1) {\\n                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT authorization_name FROM \\\"\\n                            + \\\"information_schema.system_authorizations\\\\n\\\"\\n                            + \\\"WHERE authorization_type = 'ROLE'\\\\n\\\"\\n                            + \\\"ORDER BY authorization_name\\\");\\n                    } else if (dbProductName.indexOf(\\n                            \\\"Adaptive Server Enterprise\\\") > -1) {\\n                                                                                                                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT name FROM syssrvroles ORDER BY name\\\");\\n                    } else if (dbProductName.indexOf(\\n                            \\\"Apache Derby\\\") > -1) {\\n                        throw new BadSpecial(\\n                            rb.getString(SqltoolRB.VENDOR_DERBY_DR));\\n                    } else {\\n                        throw new BadSpecial(\\n                            rb.getString(SqltoolRB.VENDOR_NOSUP_D, \\\"r\\\"));\\n                    }\\n                    break;\\n                case 'u' :\\n                    if (dbProductName.indexOf(\\\"HSQL\\\") > -1) {\\n                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT user, admin FROM \\\"\\n                            + \\\"information_schema.system_users\\\\n\\\"\\n                            + \\\"ORDER BY user\\\");\\n                    } else if (dbProductName.indexOf(\\\"Oracle\\\") > -1) {\\n                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT username, created FROM all_users \\\"\\n                            + \\\"ORDER BY username\\\");\\n                    } else if (dbProductName.indexOf(\\\"PostgreSQL\\\") > -1) {\\n                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT usename, usesuper FROM pg_catalog.pg_user \\\"\\n                            + \\\"ORDER BY usename\\\");\\n                    } else if (dbProductName.indexOf(\\n                            \\\"Adaptive Server Enterprise\\\") > -1) {\\n                                                                                                                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT name, accdate, fullname FROM syslogins \\\"\\n                            + \\\"ORDER BY name\\\");\\n                    } else if (dbProductName.indexOf(\\n                            \\\"Apache Derby\\\") > -1) {\\n                        throw new BadSpecial(\\n                            rb.getString(SqltoolRB.VENDOR_DERBY_DU));\\n                    } else {\\n                        throw new BadSpecial(\\n                            rb.getString(SqltoolRB.VENDOR_NOSUP_D, \\\"u\\\"));\\n                    }\\n                    break;\\n                case 'a' :\\n                    if (dbProductName.indexOf(\\\"HSQL\\\") > -1) {\\n                                                                        if (filter != null\\n                                && filter.charAt(filter.length() - 1)\\n                                   == '.') {\\n                            narrower =\\n                                \\\"\\\\nWHERE alias_schem = '\\\"\\n                                + filter.substring(0, filter.length() - 1)\\n                                + \\\"'\\\";\\n                            filter = null;\\n                        }\\n                        statement = curConn.createStatement();\\n                        statement.execute(\\n                            \\\"SELECT alias_schem, alias FROM \\\"\\n                            + \\\"information_schema.system_aliases\\\" + narrower);\\n                    } else {\\n                        types[0] = \\\"ALIAS\\\";\\n                    }\\n                    break;\\n                case 't' :\\n                    excludeSysSchemas = (dbProductName.indexOf(\\\"Oracle\\\")\\n                                         > -1);\\n                    types[0] = \\\"TABLE\\\";\\n                    break;\\n                case 'v' :\\n                    types[0] = \\\"VIEW\\\";\\n                    break;\\n                case 'n' :\\n                    rs = md.getSchemas();\\n                    if (rs == null) {\\n                        throw new BadSpecial(\\n                            \\\"Failed to get metadata from database\\\");\\n                    }\\n                    displayResultSet(null, rs, listMDSchemaCols, filter);\\n                    return;\\n                case 'i' :\\n                    String table = null;\\n                    if (filter != null) {\\n                        int dotat = filter.indexOf('.');\\n                        schema = ((dotat > 0) ? filter.substring(0, dotat)\\n                                              : null);\\n                        if (dotat < filter.length() - 1) {\\n                                                        table = ((dotat > 0) ? filter.substring(dotat + 1)\\n                                                 : filter);\\n                        }\\n                        filter = null;\\n                    }\\n                                                                                                    rs = md.getIndexInfo(null, schema, table, false, true);\\n                    if (rs == null) {\\n                        throw new BadSpecial(\\n                            \\\"Failed to get metadata from database\\\");\\n                    }\\n                    displayResultSet(null, rs, listMDIndexCols, null);\\n                    return;\\n                default :\\n                    throw new BadSpecial(rb.getString(\\n                            SqltoolRB.SPECIAL_D_UNKNOWN,\\n                                Character.toString(c)) + LS + D_OPTIONS_TEXT);\\n            }\\n            if (statement == null) {\\n                if (dbProductName.indexOf(\\\"HSQL\\\") > -1) {\\n                    listSet = listMDTableCols[HSQLDB_ELEMENT];\\n                } else if (dbProductName.indexOf(\\\"Oracle\\\") > -1) {\\n                    listSet = listMDTableCols[ORACLE_ELEMENT];\\n                } else {\\n                    listSet = listMDTableCols[DEFAULT_ELEMENT];\\n                }\\n                if (schema == null && filter != null\\n                        && filter.charAt(filter.length() - 1) == '.') {\\n                    schema = filter.substring(0, filter.length() - 1);\\n                    filter = null;\\n                }\\n            }\\n            rs = ((statement == null)\\n                  ? md.getTables(null, schema, null, types)\\n                  : statement.getResultSet());\\n            if (rs == null) {\\n                throw new BadSpecial(rb.getString(\\n                        SqltoolRB.METADATA_FETCH_FAIL));\\n            }\\n            displayResultSet(null, rs, listSet, filter);\\n            if (additionalSchemas != null) {\\n                for (int i = 1; i < additionalSchemas.length; i++) {\\n                    rs = md.getTables(null, additionalSchemas[i], null,\\n                                      types);\\n                    if (rs == null) {\\n                        throw new BadSpecial(rb.getString(\\n                                SqltoolRB.METADATA_FETCH_FAILFOR,\\n                                        additionalSchemas[i]));\\n                    }\\n                    if (!rs.next()) {\\n                        continue;\\n                    }\\n                    displayResultSet(\\n                        null,\\n                        md.getTables(\\n                            null, additionalSchemas[i], null, types), listSet, filter);\\n                }\\n            }\\n        } catch (SQLException se) {\\n            throw new BadSpecial(rb.getString( SqltoolRB.METADATA_FETCH_FAIL),\\n                    se);\\n        } catch (NullPointerException npe) {\\n            throw new BadSpecial(rb.getString( SqltoolRB.METADATA_FETCH_FAIL),\\n                    npe);\\n        } finally {\\n            excludeSysSchemas = false;\\n            if (rs != null) {\\n                rs = null;\\n            }\\n            if (statement != null) {\\n                try {\\n                    statement.close();\\n                } catch (Exception e) {}\\n                statement = null;\\n            }\\n        }\\n    }\\n    private boolean excludeSysSchemas = false;\\n    private void processSQL() throws SQLException, SqlToolError {\\n                                                                                                        lastSqlStatement    = (plMode ? dereference(buffer, true)\\n                                      : buffer);\\n        Statement statement = null;\\n        if (doPrepare) {\\n            if (lastSqlStatement.indexOf('?') < 1) {\\n                lastSqlStatement = null;\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.PREPARE_DEMANDQM));\\n            }\\n            doPrepare = false;\\n            PreparedStatement ps = curConn.prepareStatement(lastSqlStatement);\\n            if (prepareVar == null) {\\n                if (binBuffer == null) {\\n                    lastSqlStatement = null;\\n                    throw new SqlToolError(rb.getString(\\n                            SqltoolRB.BINBUFFER_EMPTY));\\n                }\\n                ps.setBytes(1, binBuffer);\\n            } else {\\n                String val = (String) userVars.get(prepareVar);\\n                if (val == null) {\\n                    lastSqlStatement = null;\\n                    throw new SqlToolError(\\n                            rb.getString(SqltoolRB.PLVAR_UNDEFINED,\\n                                    prepareVar));\\n                }\\n                prepareVar = null;\\n                ps.setString(1, val);\\n            }\\n            ps.executeUpdate();\\n            statement = ps;\\n        } else {\\n            statement = curConn.createStatement();\\n            statement.execute(lastSqlStatement);\\n        }\\n        possiblyUncommitteds.set(true);\\n        try {\\n            displayResultSet(statement, statement.getResultSet(), null, null);\\n        } finally {\\n            try {\\n                statement.close();\\n            } catch (Exception e) {}\\n        }\\n        lastSqlStatement = null;\\n    }\\n    private void displayResultSet(Statement statement, ResultSet r,\\n                                  int[] incCols,\\n                                  String filter) throws SQLException,\\n                                  SqlToolError {\\n        java.sql.Timestamp ts;\\n        int dotAt;\\n        int                updateCount = (statement == null) ? -1\\n                                                             : statement\\n                                                                 .getUpdateCount();\\n        boolean            silent      = silentFetch;\\n        boolean            binary      = fetchBinary;\\n        silentFetch = false;\\n        fetchBinary = false;\\n        if (excludeSysSchemas) {\\n            stdprintln(rb.getString(SqltoolRB.VENDOR_NOSUP_SYSSCHEMAS));\\n        }\\n        switch (updateCount) {\\n            case -1 :\\n                if (r == null) {\\n                    stdprintln(rb.getString(SqltoolRB.NORESULT), true);\\n                    break;\\n                }\\n                ResultSetMetaData m        = r.getMetaData();\\n                int               cols     = m.getColumnCount();\\n                int               incCount = (incCols == null) ? cols\\n                                                               : incCols\\n                                                                   .length;\\n                String            val;\\n                List              rows        = new ArrayList();\\n                String[]          headerArray = null;\\n                String[]          fieldArray;\\n                int[]             maxWidth = new int[incCount];\\n                int               insi;\\n                boolean           skip;\\n                                if (!htmlMode) {\\n                    for (int i = 0; i < maxWidth.length; i++) {\\n                        maxWidth[i] = 0;\\n                    }\\n                }\\n                boolean[] rightJust = new boolean[incCount];\\n                int[]     dataType  = new int[incCount];\\n                boolean[] autonulls = new boolean[incCount];\\n                insi        = -1;\\n                headerArray = new String[incCount];\\n                for (int i = 1; i <= cols; i++) {\\n                    if (incCols != null) {\\n                        skip = true;\\n                        for (int j = 0; j < incCols.length; j++) {\\n                            if (i == incCols[j]) {\\n                                skip = false;\\n                            }\\n                        }\\n                        if (skip) {\\n                            continue;\\n                        }\\n                    }\\n                    headerArray[++insi] = m.getColumnLabel(i);\\n                    dataType[insi]      = m.getColumnType(i);\\n                    rightJust[insi]     = false;\\n                    autonulls[insi]     = true;\\n                    switch (dataType[insi]) {\\n                        case java.sql.Types.BIGINT :\\n                        case java.sql.Types.BIT :\\n                        case java.sql.Types.DECIMAL :\\n                        case java.sql.Types.DOUBLE :\\n                        case java.sql.Types.FLOAT :\\n                        case java.sql.Types.INTEGER :\\n                        case java.sql.Types.NUMERIC :\\n                        case java.sql.Types.REAL :\\n                        case java.sql.Types.SMALLINT :\\n                        case java.sql.Types.TINYINT :\\n                            rightJust[insi] = true;\\n                            break;\\n                        case java.sql.Types.VARBINARY :\\n                        case java.sql.Types.VARCHAR :\\n                        case java.sql.Types.ARRAY :\\n                                                    case java.sql.Types.BLOB :\\n                        case java.sql.Types.CLOB :\\n                        case java.sql.Types.LONGVARBINARY :\\n                        case java.sql.Types.LONGVARCHAR :\\n                            autonulls[insi] = false;\\n                            break;\\n                    }\\n                    if (htmlMode) {\\n                        continue;\\n                    }\\n                    if (headerArray[insi].length() > maxWidth[insi]) {\\n                        maxWidth[insi] = headerArray[insi].length();\\n                    }\\n                }\\n                boolean filteredOut;\\n                while (r.next()) {\\n                    fieldArray  = new String[incCount];\\n                    insi        = -1;\\n                    filteredOut = filter != null;\\n                    for (int i = 1; i <= cols; i++) {\\n                                                                        if (incCols != null) {\\n                            skip = true;\\n                            for (int j = 0; j < incCols.length; j++) {\\n                                if (i == incCols[j]) {\\n                                    skip = false;\\n                                }\\n                            }\\n                            if (skip) {\\n                                continue;\\n                            }\\n                        }\\n                                                                                                ++insi;\\n                        if (!SqlFile.canDisplayType(dataType[insi])) {\\n                            binary = true;\\n                        }\\n                        val = null;\\n                        if (!binary) {\\n                            switch (dataType[insi]) {\\n                                case java.sql.Types.TIMESTAMP:\\n                                case java.sql.Types.DATE:\\n                                case java.sql.Types.TIME:\\n                                    ts  = r.getTimestamp(i);\\n                                    val = ((ts == null) ? null : ts.toString());\\n                                                                                                                                                if (dataType[insi]\\n                                            != java.sql.Types.TIMESTAMP\\n                                            && val != null) {\\n                                        dotAt = val.lastIndexOf('.');\\n                                        for (int z = dotAt + 1;\\n                                                z < val.length(); z++) {\\n                                            if (val.charAt(z) != '0') {\\n                                                dotAt = 0;\\n                                                break;\\n                                            }\\n                                        }\\n                                        if (dotAt > 1) {\\n                                            val = val.substring(0, dotAt);\\n                                        }\\n                                    }\\n                                    break;\\n                                default:\\n                                    val = r.getString(i);\\n                                                                                                                                                if (val == null) {\\n                                        try {\\n                                            val = streamToString(\\n                                                r.getAsciiStream(i), charset);\\n                                        } catch (Exception e) { }\\n                                    }\\n                            }\\n                        }\\n                        if (binary || (val == null &&!r.wasNull())) {\\n                            if (pwDsv != null) {\\n                                throw new SqlToolError(\\n                                        rb.getString(SqltoolRB.DSV_BINCOL));\\n                            }\\n                                                                                    try {\\n                                binBuffer =\\n                                    SqlFile.streamToBytes(r.getBinaryStream(i));\\n                            } catch (IOException ioe) {\\n                                throw new SqlToolError(\\n                                    \\\"Failed to read value using stream\\\",\\n                                    ioe);\\n                            }\\n                            stdprintln(rb.getString(SqltoolRB.BINBUF_WRITE,\\n                                       Integer.toString(binBuffer.length),\\n                                       headerArray[insi],\\n                                       SqlFile.sqlTypeToString(dataType[insi])\\n                                    ));\\n                            return;\\n                        }\\n                        if (excludeSysSchemas && val != null && i == 2) {\\n                            for (int z = 0; z < oracleSysSchemas.length;\\n                                    z++) {\\n                                if (val.equals(oracleSysSchemas[z])) {\\n                                    filteredOut = true;\\n                                    break;\\n                                }\\n                            }\\n                        }\\n                        userVars.put(\\\"?\\\", ((val == null) ? nullRepToken : val));\\n                        if (fetchingVar != null) {\\n                            userVars.put(fetchingVar, userVars.get(\\\"?\\\"));\\n                            updateUserSettings();\\n                            fetchingVar = null;\\n                        }\\n                        if (silent) {\\n                            return;\\n                        }\\n                                                                                                if (filter != null\\n                                && (val == null\\n                                    || val.indexOf(filter) > -1)) {\\n                            filteredOut = false;\\n                        }\\n                                                                        if (val == null && pwDsv == null) {\\n                            if (dataType[insi] == java.sql.Types.VARCHAR) {\\n                                fieldArray[insi] = (htmlMode ? \\\"<I>null</I>\\\"\\n                                                             : nullRepToken);\\n                            } else {\\n                                fieldArray[insi] = \\\"\\\";\\n                            }\\n                        } else {\\n                            fieldArray[insi] = val;\\n                        }\\n                                                if (htmlMode || pwDsv != null) {\\n                            continue;\\n                        }\\n                        if (fieldArray[insi].length() > maxWidth[insi]) {\\n                            maxWidth[insi] = fieldArray[insi].length();\\n                        }\\n                    }\\n                    if (!filteredOut) {\\n                        rows.add(fieldArray);\\n                    }\\n                }\\n                                                if (pwDsv == null) {\\n                    condlPrintln(\\\"<TABLE border='1'>\\\", true);\\n                    if (incCount > 1) {\\n                        condlPrint(SqlFile.htmlRow(COL_HEAD) + LS + PRE_TD, true);\\n                        for (int i = 0; i < headerArray.length; i++) {\\n                            condlPrint(\\\"<TD>\\\" + headerArray[i] + \\\"</TD>\\\",\\n                                       true);\\n                            condlPrint(((i > 0) ? SqlFile.spaces(2)\\n                                                : \\\"\\\") + SqlFile.pad(\\n                                                    headerArray[i],\\n                                                    maxWidth[i],\\n                                                    rightJust[i],\\n                                                    (i < headerArray.length\\n                                                     - 1 || rightJust[i])), false);\\n                        }\\n                        condlPrintln(LS + PRE_TR + \\\"</TR>\\\", true);\\n                        condlPrintln(\\\"\\\", false);\\n                        if (!htmlMode) {\\n                            for (int i = 0; i < headerArray.length; i++) {\\n                                condlPrint(((i > 0) ? SqlFile.spaces(2)\\n                                                    : \\\"\\\") + SqlFile.divider(\\n                                                        maxWidth[i]), false);\\n                            }\\n                            condlPrintln(\\\"\\\", false);\\n                        }\\n                    }\\n                    for (int i = 0; i < rows.size(); i++) {\\n                        condlPrint(SqlFile.htmlRow(((i % 2) == 0) ? COL_EVEN\\n                                                          : COL_ODD) + LS\\n                                                          + PRE_TD, true);\\n                        fieldArray = (String[]) rows.get(i);\\n                        for (int j = 0; j < fieldArray.length; j++) {\\n                            condlPrint(\\\"<TD>\\\" + fieldArray[j] + \\\"</TD>\\\",\\n                                       true);\\n                            condlPrint(((j > 0) ? SqlFile.spaces(2)\\n                                                : \\\"\\\") + SqlFile.pad(\\n                                                    fieldArray[j],\\n                                                    maxWidth[j],\\n                                                    rightJust[j],\\n                                                    (j < fieldArray.length\\n                                                     - 1 || rightJust[j])), false);\\n                        }\\n                        condlPrintln(LS + PRE_TR + \\\"</TR>\\\", true);\\n                        condlPrintln(\\\"\\\", false);\\n                    }\\n                    condlPrintln(\\\"</TABLE>\\\", true);\\n                    if (rows.size() != 1) {\\n                        stdprintln(LS + rb.getString(SqltoolRB.ROWS_FETCHED,\\n                                rows.size()), true);\\n                    }\\n                    condlPrintln(\\\"<HR>\\\", true);\\n                    break;\\n                }\\n                                if (incCount > 0) {\\n                    for (int i = 0; i < headerArray.length; i++) {\\n                        dsvSafe(headerArray[i]);\\n                        pwDsv.print(headerArray[i]);\\n                        if (i < headerArray.length - 1) {\\n                            pwDsv.print(dsvColDelim);\\n                        }\\n                    }\\n                    pwDsv.print(dsvRowDelim);\\n                }\\n                for (int i = 0; i < rows.size(); i++) {\\n                    fieldArray = (String[]) rows.get(i);\\n                    for (int j = 0; j < fieldArray.length; j++) {\\n                        dsvSafe(fieldArray[j]);\\n                        pwDsv.print((fieldArray[j] == null)\\n                                    ? (autonulls[j] ? \\\"\\\"\\n                                                    : nullRepToken)\\n                                    : fieldArray[j]);\\n                        if (j < fieldArray.length - 1) {\\n                            pwDsv.print(dsvColDelim);\\n                        }\\n                    }\\n                    pwDsv.print(dsvRowDelim);\\n                }\\n                stdprintln(rb.getString(SqltoolRB.ROWS_FETCHED_DSV,\\n                        rows.size()));\\n                break;\\n            default :\\n                userVars.put(\\\"?\\\", Integer.toString(updateCount));\\n                if (fetchingVar != null) {\\n                    userVars.put(fetchingVar, userVars.get(\\\"?\\\"));\\n                    updateUserSettings();\\n                    fetchingVar = null;\\n                }\\n                if (updateCount != 0) {\\n                    stdprintln((updateCount == 1)\\n                        ? rb.getString(SqltoolRB.ROW_UPDATE_SINGULAR)\\n                        : rb.getString(SqltoolRB.ROW_UPDATE_MULTIPLE,\\n                                updateCount));\\n                }\\n                break;\\n        }\\n    }\\n    private static final int    COL_HEAD = 0,\\n                                COL_ODD  = 1,\\n                                COL_EVEN = 2\\n    ;\\n    private static final String PRE_TR   = spaces(4);\\n    private static final String PRE_TD   = spaces(8);\\n    private static String htmlRow(int colType) {\\n        switch (colType) {\\n            case COL_HEAD :\\n                return PRE_TR + \\\"<TR style='font-weight: bold;'>\\\";\\n            case COL_ODD :\\n                return PRE_TR\\n                       + \\\"<TR style='background: #94d6ef; font: normal \\\"\\n                       + \\\"normal 10px/10px Arial, Helvitica, sans-serif;'>\\\";\\n            case COL_EVEN :\\n                return PRE_TR\\n                       + \\\"<TR style='background: silver; font: normal \\\"\\n                       + \\\"normal 10px/10px Arial, Helvitica, sans-serif;'>\\\";\\n        }\\n        return null;\\n    }\\n    private static String divider(int len) {\\n        return (len > DIVIDER.length()) ? DIVIDER\\n                                        : DIVIDER.substring(0, len);\\n    }\\n    private static String spaces(int len) {\\n        return (len > SPACES.length()) ? SPACES\\n                                       : SPACES.substring(0, len);\\n    }\\n    private static String pad(String inString, int fulllen,\\n                              boolean rightJustify, boolean doPad) {\\n        if (!doPad) {\\n            return inString;\\n        }\\n        int len = fulllen - inString.length();\\n        if (len < 1) {\\n            return inString;\\n        }\\n        String pad = SqlFile.spaces(len);\\n        return ((rightJustify ? pad\\n                              : \\\"\\\") + inString + (rightJustify ? \\\"\\\"\\n                                                               : pad));\\n    }\\n    private void showHistory() throws BadSpecial {\\n        if (history == null) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_UNAVAILABLE));\\n        }\\n        if (history.size() < 1) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_NONE));\\n        }\\n        for (int i = 0; i < history.size(); i++) {\\n            psStd.println(\\\"#\\\" + (i + oldestHist) + \\\" or \\\"\\n                    + (i - history.size()) + ':');\\n            psStd.println((String) history.get(i));\\n        }\\n        if (buffer != null) {\\n            psStd.println(rb.getString(SqltoolRB.EDITBUFFER_CONTENTS, buffer));\\n        }\\n        psStd.println();\\n        psStd.println(rb.getString(SqltoolRB.BUFFER_INSTRUCTIONS));\\n    }\\n    private String commandFromHistory(int inIndex) throws BadSpecial {\\n        int index = inIndex;  \\n        if (history == null) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_UNAVAILABLE));\\n        }\\n        if (index == 0) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_NUMBER_REQ));\\n        }\\n        if (index > 0) {\\n                        index -= oldestHist;\\n            if (index < 0) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_BACKTO,\\n                       oldestHist));\\n            }\\n            if (index >= history.size()) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_UPTO,\\n                       history.size() + oldestHist - 1));\\n            }\\n        } else {\\n                        index += history.size();\\n            if (index < 0) {\\n                throw new BadSpecial(rb.getString(SqltoolRB.HISTORY_BACK,\\n                       history.size()));\\n            }\\n        }\\n        return (String) history.get(index);\\n    }\\n    private void setBuf(String newContent) {\\n        buffer = new String(newContent);\\n                bufContainsSql = false;\\n    }\\n    int oldestHist = 1;\\n    boolean bufContainsSql = true;\\n    private void historize() {\\n        if (history == null || buffer == null) {\\n            return;\\n        }\\n        if (history.size() > 0 &&\\n                history.get(history.size() - 1).equals(buffer)) {\\n                        return;\\n        }\\n        history.add(buffer);\\n        if (history.size() <= maxHistoryLength) {\\n            return;\\n        }\\n        history.remove(0);\\n        oldestHist++;\\n    }\\n    private void describe(String tableName,\\n                          String inFilter) throws SQLException {\\n        String    filter = inFilter;\\n        List      rows        = new ArrayList();\\n        String[]  headerArray = {\\n            rb.getString(SqltoolRB.DESCRIBE_TABLE_NAME),\\n            rb.getString(SqltoolRB.DESCRIBE_TABLE_DATATYPE),\\n            rb.getString(SqltoolRB.DESCRIBE_TABLE_WIDTH),\\n            rb.getString(SqltoolRB.DESCRIBE_TABLE_NONULLS),\\n        };\\n        String[]  fieldArray;\\n        int[]     maxWidth  = {\\n            0, 0, 0, 0\\n        };\\n        boolean[] rightJust = {\\n            false, false, true, false\\n        };\\n                for (int i = 0; i < headerArray.length; i++) {\\n            if (htmlMode) {\\n                continue;\\n            }\\n            if (headerArray[i].length() > maxWidth[i]) {\\n                maxWidth[i] = headerArray[i].length();\\n            }\\n        }\\n        Statement statement = curConn.createStatement();\\n        ResultSet r         = null;\\n        try {\\n            statement.execute(\\\"SELECT * FROM \\\" + tableName + \\\" WHERE 1 = 2\\\");\\n            r = statement.getResultSet();\\n            ResultSetMetaData m    = r.getMetaData();\\n            int               cols = m.getColumnCount();\\n            for (int i = 0; i < cols; i++) {\\n                fieldArray    = new String[4];\\n                fieldArray[0] = m.getColumnName(i + 1);\\n                if (filter != null && fieldArray[0].indexOf(filter) < 0) {\\n                    continue;\\n                }\\n                fieldArray[1] = m.getColumnTypeName(i + 1);\\n                fieldArray[2] = Integer.toString(m.getColumnDisplaySize(i + 1));\\n                fieldArray[3] =\\n                    ((m.isNullable(i + 1) == java.sql.ResultSetMetaData.columnNullable)\\n                     ? (htmlMode ? \\\"&nbsp;\\\"\\n                                 : \\\"\\\")\\n                     : \\\"*\\\");\\n                rows.add(fieldArray);\\n                for (int j = 0; j < fieldArray.length; j++) {\\n                    if (fieldArray[j].length() > maxWidth[j]) {\\n                        maxWidth[j] = fieldArray[j].length();\\n                    }\\n                }\\n            }\\n                        condlPrint(\\\"<TABLE border='1'>\\\" + LS + SqlFile.htmlRow(COL_HEAD) + LS\\n                       + PRE_TD, true);\\n            for (int i = 0; i < headerArray.length; i++) {\\n                condlPrint(\\\"<TD>\\\" + headerArray[i] + \\\"</TD>\\\", true);\\n                condlPrint(((i > 0) ? SqlFile.spaces(2)\\n                                    : \\\"\\\") + SqlFile.pad(headerArray[i], maxWidth[i],\\n                                                rightJust[i],\\n                                                (i < headerArray.length - 1\\n                                                 || rightJust[i])), false);\\n            }\\n            condlPrintln(LS + PRE_TR + \\\"</TR>\\\", true);\\n            condlPrintln(\\\"\\\", false);\\n            if (!htmlMode) {\\n                for (int i = 0; i < headerArray.length; i++) {\\n                    condlPrint(((i > 0) ? SqlFile.spaces(2)\\n                                        : \\\"\\\") + SqlFile.divider(maxWidth[i]), false);\\n                }\\n                condlPrintln(\\\"\\\", false);\\n            }\\n            for (int i = 0; i < rows.size(); i++) {\\n                condlPrint(SqlFile.htmlRow(((i % 2) == 0) ? COL_EVEN\\n                                                  : COL_ODD) + LS\\n                                                  + PRE_TD, true);\\n                fieldArray = (String[]) rows.get(i);\\n                for (int j = 0; j < fieldArray.length; j++) {\\n                    condlPrint(\\\"<TD>\\\" + fieldArray[j] + \\\"</TD>\\\", true);\\n                    condlPrint(((j > 0) ? SqlFile.spaces(2)\\n                                        : \\\"\\\") + SqlFile.pad(\\n                                            fieldArray[j], maxWidth[j],\\n                                            rightJust[j],\\n                                            (j < fieldArray.length - 1\\n                                             || rightJust[j])), false);\\n                }\\n                condlPrintln(LS + PRE_TR + \\\"</TR>\\\", true);\\n                condlPrintln(\\\"\\\", false);\\n            }\\n            condlPrintln(LS + \\\"</TABLE>\\\" + LS + \\\"<HR>\\\", true);\\n        } finally {\\n            try {\\n                if (r != null) {\\n                    r.close();\\n                    r = null;\\n                }\\n                statement.close();\\n            } catch (Exception e) {}\\n        }\\n    }\\n    private boolean eval(String[] inTokens) throws BadSpecial {\\n                        boolean  negate = inTokens.length > 0 && inTokens[0].equals(\\\"!\\\");\\n        String[] tokens = new String[negate ? (inTokens.length - 1)\\n                                            : inTokens.length];\\n        String inToken;\\n        for (int i = 0; i < tokens.length; i++) {\\n            inToken = inTokens[i + (negate ? 1 : 0)];\\n            if (inToken.length() > 1 && inToken.charAt(0) == '*') {\\n                tokens[i] = (String) userVars.get(inToken.substring(1));\\n            } else {\\n                tokens[i] = inTokens[i + (negate ? 1 : 0)];\\n            }\\n                                    if (tokens[i] == null) {\\n                tokens[i] = \\\"\\\";\\n            }\\n        }\\n        if (tokens.length == 1) {\\n            return (tokens[0].length() > 0 &&!tokens[0].equals(\\\"0\\\")) ^ negate;\\n        }\\n        if (tokens.length == 3) {\\n            if (tokens[1].equals(\\\"==\\\")) {\\n                return tokens[0].equals(tokens[2]) ^ negate;\\n            }\\n            if (tokens[1].equals(\\\"!=\\\") || tokens[1].equals(\\\"<>\\\")\\n                    || tokens[1].equals(\\\"><\\\")) {\\n                return (!tokens[0].equals(tokens[2])) ^ negate;\\n            }\\n            if (tokens[1].equals(\\\">\\\")) {\\n                return (tokens[0].length() > tokens[2].length() || ((tokens[0].length() == tokens[2].length()) && tokens[0].compareTo(tokens[2]) > 0))\\n                       ^ negate;\\n            }\\n            if (tokens[1].equals(\\\"<\\\")) {\\n                return (tokens[2].length() > tokens[0].length() || ((tokens[2].length() == tokens[0].length()) && tokens[2].compareTo(tokens[0]) > 0))\\n                       ^ negate;\\n            }\\n        }\\n        throw new BadSpecial(rb.getString(SqltoolRB.LOGICAL_UNRECOGNIZED));\\n    }\\n    private void closeQueryOutputStream() {\\n        if (pwQuery == null) {\\n            return;\\n        }\\n        if (htmlMode) {\\n            pwQuery.println(\\\"</BODY></HTML>\\\");\\n            pwQuery.flush();\\n        }\\n        pwQuery.close();\\n        pwQuery = null;\\n    }\\n    private void condlPrintln(String s, boolean printHtml) {\\n        if ((printHtml &&!htmlMode) || (htmlMode &&!printHtml)) {\\n            return;\\n        }\\n        psStd.println(s);\\n        if (pwQuery != null) {\\n            pwQuery.println(s);\\n            pwQuery.flush();\\n        }\\n    }\\n    private void condlPrint(String s, boolean printHtml) {\\n        if ((printHtml &&!htmlMode) || (htmlMode &&!printHtml)) {\\n            return;\\n        }\\n        psStd.print(s);\\n        if (pwQuery != null) {\\n            pwQuery.print(s);\\n            pwQuery.flush();\\n        }\\n    }\\n    private String formatNicely(Map map, boolean withValues) {\\n        String       key;\\n        StringBuffer sb = new StringBuffer();\\n        Iterator     it = (new TreeMap(map)).keySet().iterator();\\n        if (withValues) {\\n            SqlFile.appendLine(sb, rb.getString(SqltoolRB.PL_LIST_PARENS));\\n        } else {\\n            SqlFile.appendLine(sb, rb.getString(SqltoolRB.PL_LIST_LENGTHS));\\n        }\\n        while (it.hasNext()) {\\n            key = (String) it.next();\\n            String s = (String) map.get(key);\\n            SqlFile.appendLine(sb, \\\"    \\\" + key + \\\": \\\" + (withValues ? (\\\"(\\\" + s + ')')\\n                                                        : Integer.toString(\\n                                                        s.length())));\\n        }\\n        return sb.toString();\\n    }\\n    private void dump(String varName,\\n                      File dumpFile) throws IOException, BadSpecial {\\n        String val = (String) userVars.get(varName);\\n        if (val == null) {\\n            throw new BadSpecial(rb.getString(\\n                    SqltoolRB.PLVAR_UNDEFINED, varName));\\n        }\\n        OutputStreamWriter osw = ((charset == null)\\n                ? (new OutputStreamWriter(new FileOutputStream(dumpFile)))\\n                : (new OutputStreamWriter(new FileOutputStream(dumpFile),\\n                            charset)));\\n        try {\\n            osw.write(val);\\n            if (val.length() > 0) {\\n                char lastChar = val.charAt(val.length() - 1);\\n                if (lastChar != '\\\\n' && lastChar != '\\\\r') {\\n                    osw.write(LS);\\n                }\\n            }\\n            osw.flush();\\n        } finally {\\n            osw.close();\\n        }\\n                        stdprintln(rb.getString(SqltoolRB.FILE_WROTECHARS,\\n                Long.toString(dumpFile.length()), dumpFile.toString()));\\n    }\\n    byte[] binBuffer = null;\\n    private void dump(File dumpFile) throws IOException, BadSpecial {\\n        if (binBuffer == null) {\\n            throw new BadSpecial(rb.getString(SqltoolRB.BINBUFFER_EMPTY));\\n        }\\n        FileOutputStream fos = new FileOutputStream(dumpFile);\\n        int len = 0;\\n        try {\\n            fos.write(binBuffer);\\n            len = binBuffer.length;\\n            binBuffer = null;\\n            fos.flush();\\n        } finally {\\n            fos.close();\\n        }\\n        stdprintln(rb.getString(SqltoolRB.FILE_WROTECHARS,\\n                len, dumpFile.toString()));\\n    }\\n    public String streamToString(InputStream is, String cs)\\n            throws IOException {\\n        try {\\n            byte[] ba = null;\\n            int bytesread = 0;\\n            int retval;\\n            try {\\n                ba = new byte[is.available()];\\n            } catch (RuntimeException re) {\\n                throw new IOException(rb.getString(SqltoolRB.READ_TOOBIG));\\n            }\\n            while (bytesread < ba.length &&\\n                    (retval = is.read(\\n                            ba, bytesread, ba.length - bytesread)) > 0) {\\n                bytesread += retval;\\n            }\\n            if (bytesread != ba.length) {\\n                throw new IOException(rb.getString(SqltoolRB.READ_PARTIAL,\\n                            bytesread,\\n                            ba.length));\\n            }\\n            try {\\n                return (cs == null) ? (new String(ba))\\n                                         : (new String(ba, cs));\\n            } catch (UnsupportedEncodingException uee) {\\n                throw new RuntimeException(uee);\\n            } catch (RuntimeException re) {\\n                throw new IOException(rb.getString(SqltoolRB.READ_CONVERTFAIL));\\n            }\\n        } finally {\\n            is.close();\\n        }\\n    }\\n    private void load(String varName, File asciiFile, String cs)\\n            throws IOException {\\n        String string = streamToString(new FileInputStream(asciiFile), cs);\\n        userVars.put(varName, string);\\n        updateUserSettings();\\n    }\\n    static public byte[] streamToBytes(InputStream is) throws IOException {\\n        byte[]                xferBuffer = new byte[10240];\\n        ByteArrayOutputStream baos       = new ByteArrayOutputStream();\\n        int                   i;\\n        while ((i = is.read(xferBuffer)) > 0) {\\n            baos.write(xferBuffer, 0, i);\\n        }\\n        return baos.toByteArray();\\n    }\\n    static public byte[] loadBinary(File binFile) throws IOException {\\n        byte[]                xferBuffer = new byte[10240];\\n        ByteArrayOutputStream baos       = new ByteArrayOutputStream();\\n        int                   i;\\n        FileInputStream       fis        = new FileInputStream(binFile);\\n        try {\\n            while ((i = fis.read(xferBuffer)) > 0) {\\n                baos.write(xferBuffer, 0, i);\\n            }\\n        } finally {\\n            fis.close();\\n        }\\n        byte[] ba = baos.toByteArray();\\n        return ba;\\n    }\\n    public static boolean canDisplayType(int i) {\\n        switch (i) {\\n                        case java.sql.Types.BLOB :\\n            case java.sql.Types.JAVA_OBJECT :\\n                                    case java.sql.Types.OTHER :\\n            case java.sql.Types.STRUCT :\\n                                return false;\\n        }\\n        return true;\\n    }\\n        private static final int JDBC3_BOOLEAN  = 16;\\n    private static final int JDBC3_DATALINK = 70;\\n    public static String sqlTypeToString(int i) {\\n        switch (i) {\\n            case java.sql.Types.ARRAY :\\n                return \\\"ARRAY\\\";\\n            case java.sql.Types.BIGINT :\\n                return \\\"BIGINT\\\";\\n            case java.sql.Types.BINARY :\\n                return \\\"BINARY\\\";\\n            case java.sql.Types.BIT :\\n                return \\\"BIT\\\";\\n            case java.sql.Types.BLOB :\\n                return \\\"BLOB\\\";\\n            case JDBC3_BOOLEAN :\\n                return \\\"BOOLEAN\\\";\\n            case java.sql.Types.CHAR :\\n                return \\\"CHAR\\\";\\n            case java.sql.Types.CLOB :\\n                return \\\"CLOB\\\";\\n            case JDBC3_DATALINK :\\n                return \\\"DATALINK\\\";\\n            case java.sql.Types.DATE :\\n                return \\\"DATE\\\";\\n            case java.sql.Types.DECIMAL :\\n                return \\\"DECIMAL\\\";\\n            case java.sql.Types.DISTINCT :\\n                return \\\"DISTINCT\\\";\\n            case java.sql.Types.DOUBLE :\\n                return \\\"DOUBLE\\\";\\n            case java.sql.Types.FLOAT :\\n                return \\\"FLOAT\\\";\\n            case java.sql.Types.INTEGER :\\n                return \\\"INTEGER\\\";\\n            case java.sql.Types.JAVA_OBJECT :\\n                return \\\"JAVA_OBJECT\\\";\\n            case java.sql.Types.LONGVARBINARY :\\n                return \\\"LONGVARBINARY\\\";\\n            case java.sql.Types.LONGVARCHAR :\\n                return \\\"LONGVARCHAR\\\";\\n            case java.sql.Types.NULL :\\n                return \\\"NULL\\\";\\n            case java.sql.Types.NUMERIC :\\n                return \\\"NUMERIC\\\";\\n            case java.sql.Types.OTHER :\\n                return \\\"OTHER\\\";\\n            case java.sql.Types.REAL :\\n                return \\\"REAL\\\";\\n            case java.sql.Types.REF :\\n                return \\\"REF\\\";\\n            case java.sql.Types.SMALLINT :\\n                return \\\"SMALLINT\\\";\\n            case java.sql.Types.STRUCT :\\n                return \\\"STRUCT\\\";\\n            case java.sql.Types.TIME :\\n                return \\\"TIME\\\";\\n            case java.sql.Types.TIMESTAMP :\\n                return \\\"TIMESTAMP\\\";\\n            case java.sql.Types.TINYINT :\\n                return \\\"TINYINT\\\";\\n            case java.sql.Types.VARBINARY :\\n                return \\\"VARBINARY\\\";\\n            case java.sql.Types.VARCHAR :\\n                return \\\"VARCHAR\\\";\\n        }\\n        return \\\"Unknown type \\\" + i;\\n    }\\n    public void dsvSafe(String s) throws SqlToolError {\\n        if (pwDsv == null || dsvColDelim == null || dsvRowDelim == null\\n                || nullRepToken == null) {\\n            throw new RuntimeException(\\n                \\\"Assertion failed.  \\\\n\\\"\\n                + \\\"dsvSafe called when DSV settings are incomplete\\\");\\n        }\\n        if (s == null) {\\n            return;\\n        }\\n        if (s.indexOf(dsvColDelim) > 0) {\\n            throw new SqlToolError(rb.getString(SqltoolRB.DSV_COLDELIM_PRESENT,\\n                        dsvColDelim));\\n        }\\n        if (s.indexOf(dsvRowDelim) > 0) {\\n            throw new SqlToolError(rb.getString(SqltoolRB.DSV_ROWDELIM_PRESENT,\\n                        dsvRowDelim));\\n        }\\n        if (s.trim().equals(nullRepToken)) {\\n                                    throw new SqlToolError(rb.getString(SqltoolRB.DSV_NULLREP_PRESENT,\\n                        nullRepToken));\\n        }\\n    }\\n    public static String convertEscapes(String inString) {\\n        if (inString == null) {\\n            return null;\\n        }\\n        return convertNumericEscapes(\\n                convertEscapes(convertEscapes(convertEscapes(convertEscapes(\\n                    convertEscapes(inString, \\\"\\\\\\\\n\\\", \\\"\\\\n\\\"), \\\"\\\\\\\\r\\\", \\\"\\\\r\\\"),\\n                \\\"\\\\\\\\t\\\", \\\"\\\\t\\\"), \\\"\\\\\\\\\\\\\\\\\\\", \\\"\\\\\\\\\\\"),\\n            \\\"\\\\\\\\f\\\", \\\"\\\\f\\\")\\n        );\\n    }\\n    private static String convertNumericEscapes(String string) {\\n        String workString = string;\\n        int i = 0;\\n        for (char dig = '0'; dig <= '9'; dig++) {\\n            while ((i = workString.indexOf(\\\"\\\\\\\\\\\" + dig, i)) > -1\\n                    && i < workString.length() - 1) {\\n                workString = convertNumericEscape(string, i);\\n            }\\n            while ((i = workString.indexOf(\\\"\\\\\\\\x\\\" + dig, i)) > -1\\n                    && i < workString.length() - 1) {\\n                workString = convertNumericEscape(string, i);\\n            }\\n            while ((i = workString.indexOf(\\\"\\\\\\\\X\\\" + dig, i)) > -1\\n                    && i < workString.length() - 1) {\\n                workString = convertNumericEscape(string, i);\\n            }\\n        }\\n        return workString;\\n    }\\n    private static String convertNumericEscape(String string, int offset) {\\n        int post = -1;\\n        int firstDigit = -1;\\n        int radix = -1;\\n        if (Character.toUpperCase(string.charAt(offset + 1)) == 'X') {\\n            firstDigit = offset + 2;\\n            radix = 16;\\n            post = firstDigit + 2;\\n            if (post > string.length()) post = string.length();\\n        } else {\\n            firstDigit = offset + 1;\\n            radix = (Character.toUpperCase(string.charAt(firstDigit)) == '0')\\n                    ? 8 : 10;\\n            for (post = firstDigit + 1; post < string.length()\\n                    && Character.isDigit(string.charAt(post)); post++) ;\\n        }\\n        return string.substring(0, offset) + ((char)\\n                Integer.parseInt(string.substring(firstDigit, post), radix))\\n                + string.substring(post);\\n    }\\n    private static String convertEscapes(String string, String from, String to) {\\n        String workString = string;\\n        int i = 0;\\n        int fromLen = from.length();\\n        while ((i = workString.indexOf(from, i)) > -1\\n                && i < workString.length() - 1) {\\n            workString = workString.substring(0, i) + to\\n                         + workString.substring(i + fromLen);\\n        }\\n        return workString;\\n    }\\n    public void importDsv(String filePath, String skipPrefix)\\n            throws SqlToolError {\\n        byte[] bfr  = null;\\n        File   file = new File(filePath);\\n        SortedMap constColMap = null;\\n        if (dsvConstCols != null) {\\n                                    constColMap = new TreeMap();\\n            String[] constPairs = dsvConstCols.split(\\\"\\\\\\\\Q\\\"\\n                    + dsvColDelim + \\\"\\\\\\\\E\\\\\\\\s*\\\");\\n            int firstEq;\\n            String n;\\n            for (int i = 0; i < constPairs.length; i++) {\\n                firstEq = constPairs[i].indexOf('=');\\n                n = constPairs[i].substring(0, firstEq).trim().toLowerCase();\\n                if (n.trim().length() < 1) {\\n                    throw new SqlToolError(\\n                            rb.getString(SqltoolRB.DSV_CONSTCOLS_NULLCOL));\\n                }\\n                constColMap.put(n, constPairs[i].substring(firstEq + 1));\\n            }\\n        }\\n        Set skipCols = null;\\n        if (dsvSkipCols != null) {\\n            skipCols = new HashSet();\\n            String[] skipColsArray = dsvSkipCols.split(\\\"\\\\\\\\s*\\\\\\\\Q\\\"\\n                    + dsvColDelim + \\\"\\\\\\\\E\\\\\\\\s*\\\");\\n            for (int i = 0; i < skipColsArray.length; i++) {\\n                skipCols.add(skipColsArray[i].toLowerCase());\\n            }\\n        }\\n        if (!file.canRead()) {\\n            throw new SqlToolError(rb.getString(SqltoolRB.FILE_READFAIL,\\n                    file.toString()));\\n        }\\n        try {\\n            bfr = new byte[(int) file.length()];\\n        } catch (RuntimeException re) {\\n            throw new SqlToolError(rb.getString(SqltoolRB.READ_TOOBIG), re);\\n        }\\n        int bytesread = 0;\\n        int retval;\\n        InputStream is = null;\\n        try {\\n            is = new FileInputStream(file);\\n            while (bytesread < bfr.length &&\\n                    (retval = is.read(bfr, bytesread, bfr.length - bytesread))\\n                    > 0) {\\n                bytesread += retval;\\n            }\\n        } catch (IOException ioe) {\\n            throw new SqlToolError(ioe);\\n        } finally {\\n            if (is != null) try {\\n                is.close();\\n            } catch (IOException ioe) {\\n                errprintln(rb.getString(SqltoolRB.INPUTFILE_CLOSEFAIL)\\n                        + \\\": \\\" + ioe);\\n            }\\n        }\\n        if (bytesread != bfr.length) {\\n            throw new SqlToolError(rb.getString(SqltoolRB.READ_PARTIAL,\\n                    bytesread, bfr.length));\\n        }\\n        String string = null;\\n        String dateString;\\n        try {\\n            string = ((charset == null)\\n                    ? (new String(bfr)) : (new String(bfr, charset)));\\n        } catch (UnsupportedEncodingException uee) {\\n            throw new RuntimeException(uee);\\n        } catch (RuntimeException re) {\\n            throw new SqlToolError(rb.getString(SqltoolRB.READ_CONVERTFAIL),\\n                    re);\\n        }\\n        List     headerList = new ArrayList();\\n        String    tableName = dsvTargetTable;\\n                int recEnd = -1000;                                     int colStart;\\n        int colEnd;\\n                int lineCount = 0;         int recStart = -1;\\n        String trimmedLine = null;\\n        boolean switching = false;\\n        while (true) {\\n            recStart = (recStart < 0) ? 0 : (recEnd + dsvRowDelim.length());\\n            if (recStart > string.length() - 2) {\\n                throw new SqlToolError(rb.getString(SqltoolRB.DSV_HEADER_NONE));\\n            }\\n            recEnd = string.indexOf(dsvRowDelim, recStart);\\n            lineCount++; \\n            if (recEnd < 0) {\\n                                recEnd = string.length();\\n            }\\n            trimmedLine = string.substring(recStart, recEnd).trim();\\n            if (trimmedLine.length() < 1\\n                    || (skipPrefix != null\\n                            && trimmedLine.startsWith(skipPrefix))) {\\n                continue;\\n            }\\n            if (trimmedLine.startsWith(\\\"targettable=\\\")) {\\n                if (tableName == null) {\\n                    tableName = trimmedLine.substring(\\n                            \\\"targettable=\\\".length()).trim();\\n                }\\n                continue;\\n            }\\n            if (trimmedLine.equals(\\\"headerswitch{\\\")) {\\n                if (tableName == null) {\\n                    throw new SqlToolError(rb.getString(\\n                            SqltoolRB.DSV_HEADER_NOSWITCHTARG, lineCount));\\n                }\\n                switching = true;\\n                continue;\\n            }\\n            if (trimmedLine.equals(\\\"}\\\")) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.DSV_HEADER_NOSWITCHMATCH, lineCount));\\n            }\\n            if (!switching) {\\n                break;\\n            }\\n            int colonAt = trimmedLine.indexOf(':');\\n            if (colonAt < 1 || colonAt == trimmedLine.length() - 1) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.DSV_HEADER_NONSWITCHED, lineCount));\\n            }\\n            String matcher = trimmedLine.substring(0, colonAt).trim();\\n                                    if (matcher.equals(\\\"*\\\") || matcher.equalsIgnoreCase(tableName)){\\n                recStart = 1 + string.indexOf(':', recStart);\\n                break;\\n            }\\n                    }\\n        String headerLine = string.substring(recStart, recEnd);\\n        colStart = recStart;\\n        colEnd   = -1;\\n        String colName;\\n        while (true) {\\n            if (colEnd == recEnd) {\\n                                break;\\n            }\\n            colEnd = string.indexOf(dsvColDelim, colStart);\\n            if (colEnd < 0 || colEnd > recEnd) {\\n                colEnd = recEnd;\\n            }\\n            if (colEnd - colStart < 1) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.DSV_NOCOLHEADER,\\n                        headerList.size() + 1, lineCount));\\n            }\\n            colName = string.substring(colStart, colEnd).trim().toLowerCase();\\n            headerList.add(\\n                (colName.equals(\\\"-\\\")\\n                        || (skipCols != null\\n                                && skipCols.remove(colName))\\n                        || (constColMap != null\\n                                && constColMap.containsKey(colName))\\n                )\\n                ? ((String) null)\\n                : colName);\\n            colStart = colEnd + dsvColDelim.length();\\n        } if (skipCols != null && skipCols.size() > 0) {\\n            throw new SqlToolError(rb.getString(\\n                    SqltoolRB.DSV_SKIPCOLS_MISSING, skipCols.toString()));\\n        }\\n        boolean oneCol = false;          for (int i = 0; i < headerList.size(); i++) {\\n            if (headerList.get(i) != null) {\\n                oneCol = true;\\n                break;\\n            }\\n        }\\n        if (oneCol == false) {\\n                                                throw new SqlToolError(rb.getString(SqltoolRB.DSV_NOCOLSLEFT,\\n                    dsvSkipCols));\\n        }\\n        int inputColHeadCount = headerList.size();\\n        if (constColMap != null) {\\n            headerList.addAll(constColMap.keySet());\\n        }\\n        String[]  headers   = (String[]) headerList.toArray(new String[0]);\\n        if (tableName == null) {\\n            tableName = file.getName();\\n            int i = tableName.lastIndexOf('.');\\n            if (i > 0) {\\n                tableName = tableName.substring(0, i);\\n            }\\n        }\\n        StringBuffer tmpSb = new StringBuffer();\\n        List tmpList = new ArrayList();\\n        int skippers = 0;\\n        for (int i = 0; i < headers.length; i++) {\\n            if (headers[i] == null) {\\n                skippers++;\\n                continue;\\n            }\\n            if (tmpSb.length() > 0) {\\n                tmpSb.append(\\\", \\\");\\n            }\\n            tmpSb.append(headers[i]);\\n            tmpList.add(headers[i]);\\n        }\\n        boolean[] autonulls = new boolean[headers.length - skippers];\\n        boolean[] parseDate = new boolean[autonulls.length];\\n        boolean[] parseBool = new boolean[autonulls.length];\\n        String[] insertFieldName = (String[]) tmpList.toArray(new String[] {});\\n        StringBuffer sb = new StringBuffer(\\\"INSERT INTO \\\" + tableName + \\\" (\\\"\\n                                           + tmpSb + \\\") VALUES (\\\");\\n        StringBuffer typeQuerySb = new StringBuffer(\\\"SELECT \\\" + tmpSb\\n            + \\\" FROM \\\" + tableName + \\\" WHERE 1 = 2\\\");\\n        try {\\n            ResultSetMetaData rsmd = curConn.createStatement().executeQuery(\\n                typeQuerySb.toString()).getMetaData();\\n            if (rsmd.getColumnCount() != autonulls.length) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.DSV_METADATA_MISMATCH));\\n                                                                                            }\\n            for (int i = 0; i < autonulls.length; i++) {\\n                autonulls[i] = true;\\n                parseDate[i] = false;\\n                parseBool[i] = false;\\n                switch(rsmd.getColumnType(i + 1)) {\\n                    case java.sql.Types.BOOLEAN:\\n                        parseBool[i] = true;\\n                        break;\\n                    case java.sql.Types.VARBINARY :\\n                    case java.sql.Types.VARCHAR :\\n                    case java.sql.Types.ARRAY :\\n                                            case java.sql.Types.BLOB :\\n                    case java.sql.Types.CLOB :\\n                    case java.sql.Types.LONGVARBINARY :\\n                    case java.sql.Types.LONGVARCHAR :\\n                        autonulls[i] = false;\\n                                                                                                break;\\n                    case java.sql.Types.DATE:\\n                    case java.sql.Types.TIME:\\n                    case java.sql.Types.TIMESTAMP:\\n                        parseDate[i] = true;\\n                }\\n            }\\n        } catch (SQLException se) {\\n            throw new SqlToolError(rb.getString(\\n                    SqltoolRB.QUERY_METADATAFAIL,\\n                            typeQuerySb.toString()), se);\\n        }\\n        for (int i = 0; i < autonulls.length; i++) {\\n            if (i > 0) {\\n                sb.append(\\\", \\\");\\n            }\\n            sb.append('?');\\n        }\\n                int rejectCount = 0;\\n        File rejectFile = null;\\n        File rejectReportFile = null;\\n        PrintWriter rejectWriter = null;\\n        PrintWriter rejectReportWriter = null;\\n        if (dsvRejectFile != null) try {\\n            rejectFile = new File(dsvRejectFile);\\n            rejectWriter = new PrintWriter((charset == null)\\n                    ? (new OutputStreamWriter(new FileOutputStream(rejectFile)))\\n                    : (new OutputStreamWriter(new FileOutputStream(rejectFile),\\n                            charset)));\\n                                                                        rejectWriter.print(headerLine + dsvRowDelim);\\n        } catch (IOException ioe) {\\n            throw new SqlToolError(rb.getString(\\n                    SqltoolRB.DSV_REJECTFILE_SETUPFAIL, dsvRejectFile), ioe);\\n        }\\n        if (dsvRejectReport != null) try {\\n            rejectReportFile = new File(dsvRejectReport);\\n            rejectReportWriter = new PrintWriter((charset == null)\\n                    ? (new OutputStreamWriter(\\n                            new FileOutputStream(rejectReportFile)))\\n                    : (new OutputStreamWriter(\\n                            new FileOutputStream(rejectReportFile), charset)));\\n                                                                        rejectReportWriter.println(rb.getString(\\n                    SqltoolRB.REJECTREPORT_TOP, new String[] {\\n                        (new java.util.Date()).toString(),\\n                        file.getPath(),\\n                        ((rejectFile == null) ? rb.getString(SqltoolRB.NONE)\\n                                        : rejectFile.getPath()),\\n                        ((rejectFile == null) ? null : rejectFile.getPath()),\\n                    }));\\n        } catch (IOException ioe) {\\n            throw new SqlToolError(rb.getString(\\n                    SqltoolRB.DSV_REJECTREPORT_SETUPFAIL, dsvRejectReport),\\n                            ioe);\\n        }\\n        int recCount = 0;\\n        int skipCount = 0;\\n        PreparedStatement ps = null;\\n        boolean importAborted = false;\\n        try {\\n            try {\\n                ps = curConn.prepareStatement(sb.toString() + ')');\\n            } catch (SQLException se) {\\n                throw new SqlToolError(rb.getString(\\n                        SqltoolRB.INSERTION_PREPAREFAIL, sb.toString()), se);\\n            }\\n            String[] dataVals = new String[autonulls.length];\\n                        int      readColCount;\\n            int      storeColCount;\\n            String   currentFieldName = null;\\n                        while (true) try { try {\\n                recStart = recEnd + dsvRowDelim.length();\\n                if (recStart >= string.length()) {\\n                    break;\\n                }\\n                recEnd = string.indexOf(dsvRowDelim, recStart);\\n                lineCount++; \\n                if (recEnd < 0) {\\n                                        recEnd = string.length();\\n                }\\n                trimmedLine = string.substring(recStart, recEnd).trim();\\n                if (trimmedLine.length() < 1) {\\n                    continue;                  }\\n                if (skipPrefix != null\\n                        && trimmedLine.startsWith(skipPrefix)) {\\n                    skipCount++;\\n                    continue;\\n                }\\n                if (switching) {\\n                    if (trimmedLine.equals(\\\"}\\\")) {\\n                        switching = false;\\n                        continue;\\n                    }\\n                    int colonAt = trimmedLine.indexOf(':');\\n                    if (colonAt < 1 || colonAt == trimmedLine.length() - 1) {\\n                        throw new SqlToolError(rb.getString(\\n                                SqltoolRB.DSV_HEADER_MATCHERNONHEAD,\\n                                        lineCount));\\n                    }\\n                    continue;\\n                }\\n                                recCount++;\\n                colStart = recStart;\\n                colEnd   = -1;\\n                readColCount = 0;\\n                storeColCount = 0;\\n                while (true) {\\n                    if (colEnd == recEnd) {\\n                                                break;\\n                    }\\n                    colEnd = string.indexOf(dsvColDelim, colStart);\\n                    if (colEnd < 0 || colEnd > recEnd) {\\n                        colEnd = recEnd;\\n                    }\\n                    if (readColCount == inputColHeadCount) {\\n                        throw new RowError(rb.getString(\\n                                SqltoolRB.DSV_COLCOUNT_MISMATCH,\\n                                        inputColHeadCount, 1 + readColCount));\\n                    }\\n                    if (headers[readColCount++] != null) {\\n                        dataVals[storeColCount++] =\\n                                string.substring(colStart, colEnd);\\n                    }\\n                    colStart             = colEnd + dsvColDelim.length();\\n                }\\n                if (readColCount < inputColHeadCount) {\\n                    throw new RowError(rb.getString(\\n                            SqltoolRB.DSV_COLCOUNT_MISMATCH,\\n                                    inputColHeadCount, readColCount));\\n                }\\n                if (constColMap != null) {\\n                    Iterator it = constColMap.values().iterator();\\n                    while (it.hasNext()) {\\n                        dataVals[storeColCount++] = (String) it.next();\\n                    }\\n                }\\n                if (storeColCount != dataVals.length) {\\n                    throw new RowError(rb.getString(\\n                            SqltoolRB.DSV_INSERTCOL_MISMATCH,\\n                                    dataVals.length, storeColCount));\\n                }\\n                for (int i = 0; i < dataVals.length; i++) {\\n                    currentFieldName = insertFieldName[i];\\n                    if (autonulls[i]) dataVals[i] = dataVals[i].trim();\\n                    if (parseDate[i]) {\\n                        if ((dataVals[i].length() < 1 && autonulls[i])\\n                              || dataVals[i].equals(nullRepToken)) {\\n                            ps.setTimestamp(i + 1, null);\\n                        } else {\\n                            dateString = (dataVals[i].indexOf(':') > 0)\\n                                       ? dataVals[i]\\n                                       : (dataVals[i] + \\\" 0:00:00\\\");\\n                                                                                    try {\\n                                ps.setTimestamp(i + 1,\\n                                        java.sql.Timestamp.valueOf(dateString));\\n                            } catch (IllegalArgumentException iae) {\\n                                throw new RowError(rb.getString(\\n                                        SqltoolRB.TIME_BAD, dateString), iae);\\n                            }\\n                        }\\n                    } else if (parseBool[i]) {\\n                        if ((dataVals[i].length() < 1 && autonulls[i])\\n                              || dataVals[i].equals(nullRepToken)) {\\n                            ps.setNull(i + 1, java.sql.Types.BOOLEAN);\\n                        } else {\\n                            try {\\n                                ps.setBoolean(i + 1, Boolean.valueOf(\\n                                        dataVals[i]).booleanValue());\\n                                                                                            } catch (IllegalArgumentException iae) {\\n                                throw new RowError(rb.getString(\\n                                        SqltoolRB.BOOLEAN_BAD, dataVals[i]),\\n                                                iae);\\n                            }\\n                        }\\n                    } else {\\n                        ps.setString(\\n                            i + 1,\\n                            (((dataVals[i].length() < 1 && autonulls[i])\\n                              || dataVals[i].equals(nullRepToken))\\n                             ? null\\n                             : dataVals[i]));\\n                    }\\n                    currentFieldName = null;\\n                }\\n                retval = ps.executeUpdate();\\n                if (retval != 1) {\\n                    throw new RowError(rb.getString(\\n                            SqltoolRB.INPUTREC_MODIFIED, retval));\\n                }\\n                possiblyUncommitteds.set(true);\\n            } catch (SQLException se) {\\n                throw new RowError(null, se);\\n            } } catch (RowError re) {\\n                rejectCount++;\\n                if (rejectWriter != null || rejectReportWriter != null) {\\n                    if (rejectWriter != null) {\\n                        rejectWriter.print(string.substring(\\n                                recStart, recEnd) + dsvRowDelim);\\n                    }\\n                    if (rejectReportWriter != null) {\\n                        genRejectReportRecord(rejectReportWriter,\\n                                rejectCount, lineCount,\\n                                currentFieldName, re.getMessage(),\\n                                re.getCause());\\n                    }\\n                } else {\\n                    importAborted = true;\\n                    throw new SqlToolError(\\n                            rb.getString(SqltoolRB.DSV_RECIN_FAIL,\\n                                    lineCount, currentFieldName)\\n                            + ((re.getMessage() == null)\\n                                    ? \\\"\\\" : (\\\"  \\\" + re.getMessage())),\\n                            re.getCause());\\n                }\\n            }\\n        } finally {\\n            String summaryString = null;\\n            if (recCount > 0) {\\n                summaryString = rb.getString(SqltoolRB.DSV_IMPORT_SUMMARY,\\n                        new String[] {\\n                                ((skipPrefix == null)\\n                                          ? \\\"\\\" : (\\\"'\\\" + skipPrefix + \\\"'-\\\")),\\n                                Integer.toString(skipCount),\\n                                Integer.toString(rejectCount),\\n                                Integer.toString(recCount - rejectCount),\\n                                (importAborted ? \\\"importAborted\\\" : null)\\n                        });\\n                stdprintln(summaryString);\\n            }\\n            try {\\n                if (recCount > rejectCount && !curConn.getAutoCommit()) {\\n                    stdprintln(rb.getString(SqltoolRB.INSERTIONS_NOTCOMMITTED));\\n                }\\n            } catch (SQLException se) {\\n                stdprintln(rb.getString(SqltoolRB.AUTOCOMMIT_FETCHFAIL));\\n                stdprintln(rb.getString(SqltoolRB.INSERTIONS_NOTCOMMITTED));\\n                                            }\\n            if (rejectWriter != null) {\\n                rejectWriter.flush();\\n                rejectWriter.close();\\n            }\\n            if (rejectReportWriter != null && rejectCount > 0) {\\n                rejectReportWriter.println(rb.getString(\\n                        SqltoolRB.REJECTREPORT_BOTTOM, summaryString, revnum));\\n                rejectReportWriter.flush();\\n                rejectReportWriter.close();\\n            }\\n            if (rejectCount == 0) {\\n                if (rejectFile != null && rejectFile.exists()\\n                        && !rejectFile.delete())\\n                    errprintln(rb.getString(SqltoolRB.DSV_REJECTFILE_PURGEFAIL,\\n                            rejectFile.toString()));\\n                if (rejectReportFile != null && !rejectReportFile.delete())\\n                    errprintln(rb.getString(\\n                            SqltoolRB.DSV_REJECTREPORT_PURGEFAIL,\\n                                    (rejectFile == null)\\n                                            ? null : rejectFile.toString()));\\n                            }\\n        }\\n    }\\n    public static void appendLine(StringBuffer sb, String s) {\\n        sb.append(s + LS);\\n    }\\n    static private String[] genWinArgs(String monolithic) {\\n        List list = new ArrayList();\\n        list.add(\\\"cmd.exe\\\");\\n        list.add(\\\"/y\\\");\\n        list.add(\\\"/c\\\");\\n        Matcher m = wincmdPattern.matcher(monolithic);\\n        String[] internalTokens;\\n        while (m.find()) {\\n            for (int i = 1; i <= m.groupCount(); i++) {\\n                if (m.group(i) == null) continue;\\n                if (m.group(i).length() > 1 && m.group(i).charAt(0) == '\\\"') {\\n                    list.add(m.group(i).substring(1, m.group(i).length() - 1));\\n                    continue;\\n                }\\n                internalTokens = m.group(i).split(\\\"\\\\\\\\s+\\\");\\n                for (int j = 0; j < internalTokens.length; j++)\\n                    list.add(internalTokens[j]);\\n            }\\n        }\\n        return (String[]) list.toArray(new String[] {});\\n    }\\n    private void genRejectReportRecord(PrintWriter pw, int rCount,\\n            int lCount, String field, String eMsg, Throwable cause) {\\n        pw.println(rb.getString(SqltoolRB.REJECTREPORT_ROW,\\n                new String[] {\\n                    ((rCount % 2 == 0) ? \\\"even\\\" : \\\"odd\\\") + \\\"row\\\",\\n                    Integer.toString(rCount),\\n                    Integer.toString(lCount),\\n                    ((field == null) ? \\\"&nbsp;\\\" : field),\\n                    (((eMsg == null) ? \\\"\\\" : eMsg)\\n                            + ((eMsg == null || cause == null) ? \\\"\\\" : \\\"<HR/>\\\")\\n                            + ((cause == null) ? \\\"\\\" : (\\n                                    (cause instanceof SQLException\\n                                            && cause.getMessage() != null)\\n                                        ? cause.getMessage()\\n                                        : cause.toString()\\n                                    )\\n                            )\\n                    )\\n                }));\\n    }\\n}\""
            },
            "m13": {
                "content": "The source code of `SqlFile.java` reveals that it is a comprehensive utility class for processing SQL files, handling interactions with databases, and managing various operations such as executing SQL commands, importing/exporting data, and supporting scripting features.\n\n### Key Observations:\n1. **Resource Bundle Usage**:\n   - A significant number of strings used in `SqlFile.java` are fetched from the `SqltoolRB` resource bundle using `rb.getString(...)`. This confirms the earlier finding of strong coupling between `SqlFile.java` and `SqltoolRB.java`.\n   - These strings are primarily used for logging, user prompts, error messages, and configuration settings.\n\n2. **Functionality Overview**:\n   - The class supports reading and executing SQL scripts.\n   - It provides mechanisms for variable substitution, special command execution (e.g., `\\*foreach`, `\\p`, etc.), and handling PL (procedural language) blocks.\n   - There's support for DSV (Delimiter-Separated Values) file imports and exports, including handling complex cases like quoted values, delimiters, and null representations.\n\n3. **Error Handling and Logging**:\n   - Errors are handled through custom exceptions like `BadSpecial`, `SqlToolError`, and others, often reporting messages retrieved from `SqltoolRB`.\n\n4. **Interaction with Other Entities**:\n   - Several internal classes (`BooleanBucket`, `QuitNow`, `BreakException`, etc.) are defined within `SqlFile.java`, indicating tightly encapsulated logic.\n   - Interactions with other entities like `SqlToolSprayer`, `RCData`, or `ValidatingResourceBundle` (from co-change analysis) could be indirect through these internal classes or via shared resource bundles like `SqltoolRB`.\n\n### Next Steps:\nTo ensure synchronization and maintainability, any changes to `SqlFile.java` should consider the following:\n\n- **Update `SqltoolRB.java` if necessary**: Any change in message keys or static variables used by `SqlFile.java` will require corresponding updates in `SqltoolRB.java`.\n- **Review Coupled Entities**: Based on co-change relationships, review other entities like `SqlTool.java` for potential impacts, even though there\u2019s no direct structural coupling.\n- **Test Error Messages and Localization**: Since many strings come from the resource bundle, ensure localization does not break due to changes.\n\nWould you like to proceed with analyzing another entity, such as `SqlTool.java`, for further insights?",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            },
            "m14": {
                "role": "user",
                "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
            },
            "m15": {
                "content": "Title: Diagnosis of starting entity `SqlFile.java`\n\nChange set: [SqltoolRB, SqlTool, SqlToolSprayer, RCData, ValidatingResourceBundle, RefCapablePropertyResourceBundle, SqlFileScanner, BooleanBucket, SqlToolException, BadCmdline, ContinueException, BreakException, QuitNow, ScriptWriterText, CSVWriter, MainInvoker, RowError, BadSpecial, SharedFields, SimpleLog, PrivateException, RB, TokenList, TarGenerator, TarHeaderFields, PIFData, TarFileOutputStream, TarFileInputStream, TarEntrySupplicant, DbBackup, TarReader, Token, TokenSource, Calculator, Atom, FrameworkLogger, AuthUtils, AuthBeanMultiplexer, ToolLogger]\n\nDetails:\n1. **SqltoolRB**: Strong coupling through extensive use of static strings and resource bundle methods for message retrieval.\n2. **SqlTool**: High co-change confidence (0.72), likely due to shared SQL execution logic or tooling functionality.\n3. **SqlToolSprayer**: Moderate co-change confidence (0.19), possibly involved in distributing SQL commands or configurations.\n4. **RCData**: Moderate co-change confidence (0.16), potentially involved in data handling or configuration management.\n5. **ValidatingResourceBundle**: Related to resource bundle validation and string management, important for message consistency.\n6. **RefCapablePropertyResourceBundle**: Handles property-based localization; changes may affect localized behavior in SqlFile.\n7. **SqlFileScanner**: Although removed, past dependencies suggest historical relevance in file parsing logic.\n8. **BooleanBucket**: Used for state tracking within SqlFile\u2019s internal logic; high coupling in usage patterns.\n9. **SqlToolException**: Common exception class used across SQL tools, including error handling in SqlFile.\n10. **BadCmdline**: Involved in command-line parsing errors; referenced in SqlFile\u2019s special command processing.\n11. **ContinueException / BreakException / QuitNow**: Control flow exceptions used in scripting blocks (e.g., PL/SQL-like scripts).\n12. **ScriptWriterText / CSVWriter**: Related to output generation; used when writing formatted SQL results.\n13. **MainInvoker**: Likely involved in entry point logic or invocation of SqlFile-related operations.\n14. **RowError / BadSpecial**: Custom exceptions tied to SQL parsing, DSV handling, and script execution.\n15. **SharedFields**: Contains shared constants or variables used across utility classes like SqlFile.\n16. **SimpleLog / FrameworkLogger / ToolLogger**: Logging components that may be used for tracing SqlFile execution.\n17. **PrivateException / RB**: Internal exception and resource management classes linked to SqlFile's error reporting.\n18. **TokenList / Token / TokenSource**: Related to lexical analysis or parsing, possibly from legacy scanner/parser logic.\n19. **TarGenerator / TarFileOutputStream / TarFileInputStream / TarReader / TarHeaderFields / TarEntrySupplicant**: May be indirectly coupled via shared utilities or archiving features triggered by SqlFile.\n20. **PIFData / DbBackup**: Possibly invoked during backup/export operations initiated through SQL scripts.\n21. **AuthUtils / AuthBeanMultiplexer**: Security-related utilities potentially used in restricted file/database access flows.\n22. **Calculator / Atom**: Expression evaluation components possibly used in script expressions or variable substitution.\n\nThese entities were selected based on co-change frequency, semantic similarity, and structural coupling with `SqlFile.java`. Changes in these files may impact logging, error handling, internationalization, control flow, and file/script processing logic within `SqlFile.java`.",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            }
        }
    }
}