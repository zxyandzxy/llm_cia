{
    "time": 1749460319.0425675,
    "messages": [
        {
            "role": "system",
            "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
        },
        {
            "role": "user",
            "content": "The project you need to analyze is `jEdit`, a well-known Java open source project. The starting entity you need to deal with is jEdit.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
        },
        {
            "content": "",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_ccb582a64c534f48a8b7b4",
                    "function": {
                        "arguments": "{\"entity\": \"jEdit.java\"}",
                        "name": "get_co_change_relationship"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "name": "get_co_change_relationship",
            "role": "tool",
            "content": "[[\"Entry\", \"16\", \"0.053156146179401995\"], [\"BufferHistory\", \"15\", \"0.04983388704318937\"], [\"EditPane\", \"29\", \"0.09634551495016612\"], [\"RecentHandler\", \"5\", \"0.016611295681063124\"], [\"Buffer\", \"59\", \"0.19601328903654486\"], [\"SearchAndReplace\", \"19\", \"0.06312292358803986\"], [\"View\", \"47\", \"0.15614617940199335\"], [\"EditServer\", \"20\", \"0.0664451827242525\"], [\"WindowHandler\", \"5\", \"0.016611295681063124\"], [\"ActionHandler\", \"48\", \"0.15946843853820597\"], [\"GeneralOptionPane\", \"11\", \"0.036544850498338874\"], [\"JEditActionContext\", \"2\", \"0.006644518272425249\"], [\"ShortcutsOptionPane\", \"7\", \"0.023255813953488372\"], [\"ToolBarEditDialog\", \"9\", \"0.029900332225913623\"], [\"ActionContext\", \"5\", \"0.016611295681063124\"], [\"JEditVisitorAdapter\", \"1\", \"0.0033222591362126247\"], [\"JEditVisitor\", \"1\", \"0.0033222591362126247\"], [\"CompleteWord\", \"17\", \"0.05647840531561462\"], [\"SaveCaretInfoVisitor\", \"1\", \"0.0033222591362126247\"], [\"SetCursorVisitor\", \"1\", \"0.0033222591362126247\"], [\"GUIUtilities\", \"54\", \"0.17940199335548174\"], [\"RolloverButton\", \"3\", \"0.009966777408637873\"], [\"HyperSearchResults\", \"17\", \"0.05647840531561462\"], [\"ExpansionToggleBorder\", \"2\", \"0.006644518272425249\"], [\"PanelWindowContainer\", \"20\", \"0.0664451827242525\"], [\"AbbrevsOptionPane\", \"8\", \"0.026578073089700997\"], [\"FloatingWindowContainer\", \"13\", \"0.04318936877076412\"], [\"ToolBarOptionPane\", \"2\", \"0.006644518272425249\"], [\"PluginsMenuButton\", \"7\", \"0.023255813953488372\"], [\"CommandsMenuButton\", \"2\", \"0.006644518272425249\"], [\"FavoritesMenuButton\", \"4\", \"0.013289036544850499\"], [\"HistoryButton\", \"1\", \"0.0033222591362126247\"], [\"SaveButton\", \"1\", \"0.0033222591362126247\"], [\"ChoosePluginSet\", \"1\", \"0.0033222591362126247\"], [\"RestoreButton\", \"1\", \"0.0033222591362126247\"], [\"ClearPluginSet\", \"1\", \"0.0033222591362126247\"], [\"MouseOverHandler\", \"1\", \"0.0033222591362126247\"], [\"AppearanceOptionPane\", \"15\", \"0.04983388704318937\"], [\"IconTheme\", \"1\", \"0.0033222591362126247\"], [\"Debug\", \"7\", \"0.023255813953488372\"], [\"GrabKeyDialog\", \"5\", \"0.016611295681063124\"], [\"InputHandler\", \"6\", \"0.019933554817275746\"], [\"KeyEventWorkaround\", \"10\", \"0.03322259136212625\"], [\"TextAreaInputHandler\", \"1\", \"0.0033222591362126247\"], [\"KeyEventTranslator\", \"8\", \"0.026578073089700997\"], [\"MyFocusManager\", \"10\", \"0.03322259136212625\"], [\"InputPane\", \"7\", \"0.023255813953488372\"], [\"BufferSet\", \"1\", \"0.0033222591362126247\"], [\"BufferSetListener\", \"1\", \"0.0033222591362126247\"], [\"BufferSetManager\", \"4\", \"0.013289036544850499\"], [\"BufferSwitcher\", \"3\", \"0.009966777408637873\"], [\"BufferSetAdapter\", \"1\", \"0.0033222591362126247\"], [\"ViewOptionPane\", \"4\", \"0.013289036544850499\"], [\"DockableWindowContainer\", \"5\", \"0.016611295681063124\"], [\"DockableWindowManager\", \"51\", \"0.16943521594684385\"], [\"DockableWindowManagerImpl\", \"1\", \"0.0033222591362126247\"], [\"DockingArea\", \"1\", \"0.0033222591362126247\"], [\"DockingLayout\", \"2\", \"0.006644518272425249\"], [\"DockableLayout\", \"8\", \"0.026578073089700997\"], [\"DockBorder\", \"1\", \"0.0033222591362126247\"], [\"ButtonLayout\", \"4\", \"0.013289036544850499\"], [\"ViewConfig\", \"5\", \"0.016611295681063124\"], [\"DockablePanel\", \"3\", \"0.009966777408637873\"], [\"PerspectiveHandler\", \"6\", \"0.019933554817275746\"], [\"DockableWindowFactory\", \"5\", \"0.016611295681063124\"], [\"DockingLayoutManager\", \"2\", \"0.006644518272425249\"], [\"DockingLayoutSetter\", \"1\", \"0.0033222591362126247\"], [\"PerspectiveManager\", \"14\", \"0.046511627906976744\"], [\"SettingsXML\", \"1\", \"0.0033222591362126247\"], [\"DockingOptionPane\", \"2\", \"0.006644518272425249\"], [\"DockableWindowManagerProvider\", \"1\", \"0.0033222591362126247\"], [\"IDockingFrameworkProvider\", \"1\", \"0.0033222591362126247\"], [\"DockableWindowConfig\", \"1\", \"0.0033222591362126247\"], [\"LoadPerspectiveAction\", \"1\", \"0.0033222591362126247\"], [\"CloseDialog\", \"3\", \"0.009966777408637873\"], [\"SaveBackupOptionPane\", \"3\", \"0.009966777408637873\"], [\"Macros\", \"19\", \"0.06312292358803986\"], [\"DraggedURLLoader\", \"1\", \"0.0033222591362126247\"], [\"StringCompare\", \"2\", \"0.006644518272425249\"], [\"VFS\", \"17\", \"0.05647840531561462\"], [\"PluginTableModel\", \"24\", \"0.07973421926910298\"], [\"TableModelHandler\", \"3\", \"0.009966777408637873\"], [\"BufferOptionPane\", \"1\", \"0.0033222591362126247\"], [\"StyleTableModel\", \"6\", \"0.019933554817275746\"], [\"EditingOptionPane\", \"13\", \"0.04318936877076412\"], [\"EncodingsOptionPane\", \"1\", \"0.0033222591362126247\"], [\"ServiceFoldHandlerProvider\", \"1\", \"0.0033222591362126247\"], [\"RemoveButton\", \"7\", \"0.023255813953488372\"], [\"DirectoryProvider\", \"5\", \"0.016611295681063124\"], [\"SendVFSUpdatesSafely\", \"1\", \"0.0033222591362126247\"], [\"Mode\", \"7\", \"0.023255813953488372\"], [\"JEditTextArea\", \"74\", \"0.24584717607973422\"], [\"ParserRuleSet\", \"6\", \"0.019933554817275746\"], [\"VFSBrowser\", \"36\", \"0.11960132890365449\"], [\"HyperSearchResult\", \"7\", \"0.023255813953488372\"], [\"XModeHandler\", \"6\", \"0.019933554817275746\"], [\"DefaultInputHandler\", \"13\", \"0.04318936877076412\"], [\"PastePrevious\", \"3\", \"0.009966777408637873\"], [\"TokenMarker\", \"15\", \"0.04983388704318937\"], [\"JARClassLoader\", \"23\", \"0.07641196013289037\"], [\"PosBottomHalf\", \"4\", \"0.013289036544850499\"], [\"HyperSearchRequest\", \"11\", \"0.036544850498338874\"], [\"TextUtilities\", \"14\", \"0.046511627906976744\"], [\"Token\", \"1\", \"0.0033222591362126247\"], [\"OffsetManager\", \"17\", \"0.05647840531561462\"], [\"ModeOptionPane\", \"4\", \"0.013289036544850499\"], [\"TokenList\", \"1\", \"0.0033222591362126247\"], [\"CurrentDirectoryMenu\", \"2\", \"0.006644518272425249\"], [\"RecentDirectoriesMenu\", \"3\", \"0.009966777408637873\"], [\"ErrorEntry\", \"3\", \"0.009966777408637873\"], [\"MiscUtilities\", \"57\", \"0.1893687707641196\"], [\"OptionsDialog\", \"14\", \"0.046511627906976744\"], [\"FirewallOptionPane\", \"4\", \"0.013289036544850499\"], [\"Dependency\", \"9\", \"0.029900332225913623\"], [\"FirewallAuthenticator\", \"2\", \"0.006644518272425249\"], [\"OverviewOptionPane\", \"6\", \"0.019933554817275746\"], [\"BrowserJTree\", \"8\", \"0.026578073089700997\"], [\"HistoryTextField\", \"4\", \"0.013289036544850499\"], [\"BrowserView\", \"15\", \"0.04983388704318937\"], [\"PluginManagerProgress\", \"12\", \"0.03986710963455149\"], [\"MouseHandler\", \"45\", \"0.14950166112956811\"], [\"OperatingSystem\", \"12\", \"0.03986710963455149\"], [\"VFSManager\", \"3\", \"0.009966777408637873\"], [\"TextAreaPainter\", \"29\", \"0.09634551495016612\"], [\"BufferChangeHandler\", \"23\", \"0.07641196013289037\"], [\"FileVFS\", \"22\", \"0.07308970099667775\"], [\"StatusBar\", \"20\", \"0.0664451827242525\"], [\"SettingsReloader\", \"4\", \"0.013289036544850499\"], [\"LineInfo\", \"4\", \"0.013289036544850499\"], [\"ChunkCache\", \"18\", \"0.059800664451827246\"], [\"KeyHandler\", \"17\", \"0.05647840531561462\"], [\"EnhancedCheckBoxMenuItem\", \"7\", \"0.023255813953488372\"], [\"MarkersMenuItem\", \"2\", \"0.006644518272425249\"], [\"EnhancedMenuItem\", \"9\", \"0.029900332225913623\"], [\"BufferIORequest\", \"28\", \"0.09302325581395349\"], [\"InstallPluginsDialog\", \"14\", \"0.046511627906976744\"], [\"FileCellRenderer\", \"7\", \"0.023255813953488372\"], [\"PaneNameRenderer\", \"2\", \"0.006644518272425249\"], [\"FocusHandler\", \"2\", \"0.006644518272425249\"], [\"FoldVisibilityManager\", \"9\", \"0.029900332225913623\"], [\"Abbrevs\", \"10\", \"0.03322259136212625\"], [\"FavoritesVFS\", \"5\", \"0.016611295681063124\"], [\"CheckBoxListModel\", \"4\", \"0.013289036544850499\"], [\"BeanShell\", \"11\", \"0.036544850498338874\"], [\"MarkerHighlight\", \"3\", \"0.009966777408637873\"], [\"ListHandler\", \"2\", \"0.006644518272425249\"], [\"PluginList\", \"12\", \"0.03986710963455149\"], [\"WrapGuide\", \"2\", \"0.006644518272425249\"], [\"HelpViewer\", \"20\", \"0.0664451827242525\"], [\"BracketHighlight\", \"2\", \"0.006644518272425249\"], [\"AbstractOptionPane\", \"4\", \"0.013289036544850499\"], [\"SearchDialog\", \"18\", \"0.059800664451827246\"], [\"BufferOptions\", \"13\", \"0.04318936877076412\"], [\"ModeProperties\", \"8\", \"0.026578073089700997\"], [\"TOCHandler\", \"5\", \"0.016611295681063124\"], [\"TipOfTheDay\", \"6\", \"0.019933554817275746\"], [\"Gutter\", \"8\", \"0.026578073089700997\"], [\"ParentDirectoryRenderer\", \"3\", \"0.009966777408637873\"], [\"BufferPrintable\", \"8\", \"0.026578073089700997\"], [\"Handler\", \"8\", \"0.026578073089700997\"], [\"Macro\", \"11\", \"0.036544850498338874\"], [\"JAR\", \"18\", \"0.059800664451827246\"], [\"BeanShellHandler\", \"4\", \"0.013289036544850499\"], [\"ComponentHandler\", \"2\", \"0.006644518272425249\"], [\"PluginManager\", \"20\", \"0.0664451827242525\"], [\"JCheckBoxList\", \"4\", \"0.013289036544850499\"], [\"FileRootsVFS\", \"8\", \"0.026578073089700997\"], [\"EnhancedDialog\", \"2\", \"0.006644518272425249\"], [\"PluginListDownloadProgress\", \"2\", \"0.006644518272425249\"], [\"Wrapper\", \"5\", \"0.016611295681063124\"], [\"Rect\", \"7\", \"0.023255813953488372\"], [\"TOCTree\", \"3\", \"0.009966777408637873\"], [\"GlobalOptions\", \"10\", \"0.03322259136212625\"], [\"DownloadThread\", \"4\", \"0.013289036544850499\"], [\"MouseWheelHandler\", \"4\", \"0.013289036544850499\"], [\"BrowserColorsOptionPane\", \"2\", \"0.006644518272425249\"], [\"PropertyChangeHandler\", \"4\", \"0.013289036544850499\"], [\"HelpIndex\", \"10\", \"0.03322259136212625\"], [\"AnimatedIcon\", \"2\", \"0.006644518272425249\"], [\"SplashScreen\", \"7\", \"0.023255813953488372\"], [\"OSTask\", \"4\", \"0.013289036544850499\"], [\"Install\", \"16\", \"0.053156146179401995\"], [\"NonInteractiveInstall\", \"2\", \"0.006644518272425249\"], [\"SwingInstall\", \"4\", \"0.013289036544850499\"], [\"ConsoleInstall\", \"2\", \"0.006644518272425249\"], [\"GenerateTocXML\", \"2\", \"0.006644518272425249\"], [\"HelpTOCPanel\", \"12\", \"0.03986710963455149\"], [\"Chunk\", \"2\", \"0.006644518272425249\"], [\"RecentFilesMenu\", \"5\", \"0.016611295681063124\"], [\"DirectoryMenu\", \"2\", \"0.006644518272425249\"], [\"EnhancedMenu\", \"8\", \"0.026578073089700997\"], [\"MarkersMenu\", \"2\", \"0.006644518272425249\"], [\"MacrosMenu\", \"8\", \"0.026578073089700997\"], [\"HistoryModel\", \"17\", \"0.05647840531561462\"], [\"BeanShellAction\", \"5\", \"0.016611295681063124\"], [\"Registers\", \"18\", \"0.059800664451827246\"], [\"PaintSelection\", \"4\", \"0.013289036544850499\"], [\"RegistersHandler\", \"4\", \"0.013289036544850499\"], [\"TextAreaOptionPane\", \"9\", \"0.029900332225913623\"], [\"ActionTextField\", \"3\", \"0.009966777408637873\"], [\"Autosave\", \"4\", \"0.013289036544850499\"], [\"ActionBar\", \"10\", \"0.03322259136212625\"], [\"ExplicitFoldHandler\", \"2\", \"0.006644518272425249\"], [\"CompletionPopup\", \"6\", \"0.019933554817275746\"], [\"LogViewer\", \"7\", \"0.023255813953488372\"], [\"PaintLineBackground\", \"2\", \"0.006644518272425249\"], [\"Anchor\", \"2\", \"0.006644518272425249\"], [\"BufferChangeListener\", \"4\", \"0.013289036544850499\"], [\"PluginInfoBox\", \"4\", \"0.013289036544850499\"], [\"ListUpdater\", \"4\", \"0.013289036544850499\"], [\"BufferChangeAdapter\", \"4\", \"0.013289036544850499\"], [\"TextRenderer\", \"6\", \"0.019933554817275746\"], [\"InstallPanel\", \"6\", \"0.019933554817275746\"], [\"SizeLabel\", \"6\", \"0.019933554817275746\"], [\"ManagePanel\", \"9\", \"0.029900332225913623\"], [\"DirectoryEntryCompare\", \"4\", \"0.013289036544850499\"], [\"ActionSet\", \"33\", \"0.10963455149501661\"], [\"FirstLine\", \"10\", \"0.03322259136212625\"], [\"StatusBarOptionPane\", \"4\", \"0.013289036544850499\"], [\"LoadSaveOptionPane\", \"2\", \"0.006644518272425249\"], [\"QuickNotepad\", \"2\", \"0.006644518272425249\"], [\"DockableListHandler\", \"14\", \"0.046511627906976744\"], [\"Factory\", \"14\", \"0.046511627906976744\"], [\"ScrollLineCount\", \"2\", \"0.006644518272425249\"], [\"VFSFileNameField\", \"8\", \"0.026578073089700997\"], [\"DisplayManager\", \"12\", \"0.03986710963455149\"], [\"VFSFileChooserDialog\", \"9\", \"0.029900332225913623\"], [\"PluginManagerOptionPane\", \"4\", \"0.013289036544850499\"], [\"MirrorModel\", \"2\", \"0.006644518272425249\"], [\"BrowserOptionPane\", \"2\", \"0.006644518272425249\"], [\"DownloadMirrorsThread\", \"2\", \"0.006644518272425249\"], [\"BrowserHandler\", \"4\", \"0.013289036544850499\"], [\"ResourceCache\", \"9\", \"0.029900332225913623\"], [\"PaintBracketHighlight\", \"2\", \"0.006644518272425249\"], [\"PaintCaret\", \"6\", \"0.019933554817275746\"], [\"PaintText\", \"4\", \"0.013289036544850499\"], [\"PaintWrapGuide\", \"2\", \"0.006644518272425249\"], [\"FoldHandler\", \"4\", \"0.013289036544850499\"], [\"PluginCacheEntry\", \"15\", \"0.04983388704318937\"], [\"ServiceManager\", \"11\", \"0.036544850498338874\"], [\"ServiceListHandler\", \"8\", \"0.026578073089700997\"], [\"EditAction\", \"7\", \"0.023255813953488372\"], [\"Model\", \"3\", \"0.009966777408637873\"], [\"VFSDirectoryEntryTable\", \"5\", \"0.016611295681063124\"], [\"Remove\", \"18\", \"0.059800664451827246\"], [\"TableMouseHandler\", \"3\", \"0.009966777408637873\"], [\"VFSDirectoryEntryTableModel\", \"1\", \"0.0033222591362126247\"], [\"Descriptor\", \"3\", \"0.009966777408637873\"], [\"Deferred\", \"5\", \"0.016611295681063124\"], [\"EnhancedButton\", \"5\", \"0.016611295681063124\"], [\"PluginJAR\", \"65\", \"0.2159468438538206\"], [\"EditPlugin\", \"8\", \"0.026578073089700997\"], [\"Plugin\", \"8\", \"0.026578073089700997\"], [\"EBMessage\", \"4\", \"0.013289036544850499\"], [\"PluginResURLConnection\", \"2\", \"0.006644518272425249\"], [\"HelpButton\", \"11\", \"0.036544850498338874\"], [\"LatestVersionPlugin\", \"2\", \"0.006644518272425249\"], [\"PluginUpdate\", \"6\", \"0.019933554817275746\"], [\"BrowserCommandsMenu\", \"5\", \"0.016611295681063124\"], [\"VariableGridLayout\", \"2\", \"0.006644518272425249\"], [\"SearchBar\", \"5\", \"0.016611295681063124\"], [\"EditBus\", \"3\", \"0.009966777408637873\"], [\"EBPlugin\", \"2\", \"0.006644518272425249\"], [\"ThreadProgress\", \"2\", \"0.006644518272425249\"], [\"MarkersProvider\", \"2\", \"0.006644518272425249\"], [\"RecentDirectoriesProvider\", \"6\", \"0.019933554817275746\"], [\"RecentFilesProvider\", \"4\", \"0.013289036544850499\"], [\"DynamicMenuProvider\", \"2\", \"0.006644518272425249\"], [\"MacrosProvider\", \"2\", \"0.006644518272425249\"], [\"PluginsProvider\", \"2\", \"0.006644518272425249\"], [\"EvalError\", \"2\", \"0.006644518272425249\"], [\"PluginOptions\", \"2\", \"0.006644518272425249\"], [\"Roster\", \"8\", \"0.026578073089700997\"], [\"ScrollLayout\", \"4\", \"0.013289036544850499\"], [\"ExtensionManager\", \"2\", \"0.006644518272425249\"], [\"KillRing\", \"17\", \"0.05647840531561462\"], [\"UndoManager\", \"8\", \"0.026578073089700997\"], [\"Operation\", \"2\", \"0.006644518272425249\"], [\"InstallButton\", \"8\", \"0.026578073089700997\"], [\"RosterThread\", \"2\", \"0.006644518272425249\"], [\"LogList\", \"2\", \"0.006644518272425249\"], [\"IntegerArray\", \"3\", \"0.009966777408637873\"], [\"GutterOptionPane\", \"8\", \"0.026578073089700997\"], [\"EditAbbrevDialog\", \"4\", \"0.013289036544850499\"], [\"AbbrevsModel\", \"4\", \"0.013289036544850499\"], [\"BoyerMooreSearchMatcher\", \"8\", \"0.026578073089700997\"], [\"BrowserIORequest\", \"6\", \"0.019933554817275746\"], [\"EntryCompare\", \"3\", \"0.009966777408637873\"], [\"HeaderMouseHandler\", \"2\", \"0.006644518272425249\"], [\"BufferPrinter1_4\", \"2\", \"0.006644518272425249\"], [\"BufferPrinter1_3\", \"2\", \"0.006644518272425249\"], [\"PrintOptionPane\", \"6\", \"0.019933554817275746\"], [\"UnixWorkaround\", \"4\", \"0.013289036544850499\"], [\"InstallThread\", \"2\", \"0.006644518272425249\"], [\"OptionGroup\", \"2\", \"0.006644518272425249\"], [\"PositionManager\", \"2\", \"0.006644518272425249\"], [\"Highlight\", \"2\", \"0.006644518272425249\"], [\"Match\", \"2\", \"0.006644518272425249\"], [\"RESearchMatcher\", \"3\", \"0.009966777408637873\"], [\"MouseActions\", \"2\", \"0.006644518272425249\"], [\"Insert\", \"2\", \"0.006644518272425249\"], [\"KillRingHandler\", \"5\", \"0.016611295681063124\"], [\"NameSpace\", \"3\", \"0.009966777408637873\"], [\"SettingsActionHandler\", \"5\", \"0.016611295681063124\"], [\"TextAreaTransferHandler\", \"8\", \"0.026578073089700997\"], [\"TextAreaDialog\", \"5\", \"0.016611295681063124\"], [\"BeanShellErrorDialog\", \"2\", \"0.006644518272425249\"], [\"FilesChangedDialog\", \"6\", \"0.019933554817275746\"], [\"Renderer\", \"8\", \"0.026578073089700997\"], [\"TreeHandler\", \"2\", \"0.006644518272425249\"], [\"ButtonActionHandler\", \"2\", \"0.006644518272425249\"], [\"SelectallButton\", \"2\", \"0.006644518272425249\"], [\"RootsEntry\", \"4\", \"0.013289036544850499\"], [\"Delegate\", \"2\", \"0.006644518272425249\"], [\"ResultCellRenderer\", \"8\", \"0.026578073089700997\"], [\"MacOSPlugin\", \"2\", \"0.006644518272425249\"], [\"ErrorListCellRenderer\", \"2\", \"0.006644518272425249\"], [\"ShortcutsModel\", \"7\", \"0.023255813953488372\"], [\"BrowserActionContext\", \"2\", \"0.006644518272425249\"], [\"MemoryStatus\", \"8\", \"0.026578073089700997\"], [\"PropertyManager\", \"2\", \"0.006644518272425249\"], [\"Clock\", \"2\", \"0.006644518272425249\"], [\"DropHandler\", \"2\", \"0.006644518272425249\"], [\"RingListModel\", \"2\", \"0.006644518272425249\"], [\"KeywordMap\", \"2\", \"0.006644518272425249\"], [\"HelpFile\", \"2\", \"0.006644518272425249\"], [\"WorkThreadPool\", \"3\", \"0.009966777408637873\"], [\"DisplayTokenHandler\", \"2\", \"0.006644518272425249\"], [\"Windows\", \"2\", \"0.006644518272425249\"], [\"FontSelectorDialog\", \"3\", \"0.009966777408637873\"], [\"StyleEditor\", \"4\", \"0.013289036544850499\"], [\"SelectLineRange\", \"2\", \"0.006644518272425249\"], [\"ErrorListDialog\", \"2\", \"0.006644518272425249\"], [\"PasteFromListDialog\", \"4\", \"0.013289036544850499\"], [\"ContextAddDialog\", \"6\", \"0.019933554817275746\"], [\"AboutDialog\", \"2\", \"0.006644518272425249\"], [\"ViewRegisters\", \"2\", \"0.006644518272425249\"], [\"AddAbbrevDialog\", \"2\", \"0.006644518272425249\"], [\"ParserRule\", \"5\", \"0.016611295681063124\"], [\"JEditMetalTheme15\", \"2\", \"0.006644518272425249\"], [\"JEditMetalTheme14\", \"2\", \"0.006644518272425249\"], [\"TextAreaDropHandler\", \"2\", \"0.006644518272425249\"], [\"MyFocusTraversalPolicy\", \"2\", \"0.006644518272425249\"], [\"Broken\", \"2\", \"0.006644518272425249\"], [\"MarkerViewer\", \"2\", \"0.006644518272425249\"], [\"RegisterChanged\", \"2\", \"0.006644518272425249\"], [\"RegisterViewer\", \"2\", \"0.006644518272425249\"], [\"GoToNodeAction\", \"2\", \"0.006644518272425249\"], [\"HyperSearchFileNode\", \"2\", \"0.006644518272425249\"], [\"HyperSearchNode\", \"2\", \"0.006644518272425249\"], [\"MutableListModel\", \"2\", \"0.006644518272425249\"], [\"BufferLoadRequest\", \"2\", \"0.006644518272425249\"], [\"OpenBracketIndentRule\", \"2\", \"0.006644518272425249\"], [\"HelpViewerDialog\", \"2\", \"0.006644518272425249\"], [\"HelpViewerInterface\", \"2\", \"0.006644518272425249\"], [\"HelpSearchPanel\", \"2\", \"0.006644518272425249\"], [\"LinkHandler\", \"3\", \"0.009966777408637873\"], [\"BufferChanging\", \"2\", \"0.006644518272425249\"], [\"JEditBuffer\", \"2\", \"0.006644518272425249\"], [\"SegmentCharSequence\", \"2\", \"0.006644518272425249\"], [\"PluginListHandler\", \"2\", \"0.006644518272425249\"], [\"AllBufferSet\", \"2\", \"0.006644518272425249\"], [\"MirrorList\", \"4\", \"0.013289036544850499\"], [\"MirrorListHandler\", \"2\", \"0.006644518272425249\"], [\"SearchMatcher\", \"2\", \"0.006644518272425249\"], [\"DirectoryLoadedAWTRequest\", \"4\", \"0.013289036544850499\"], [\"ActionListHandler\", \"2\", \"0.006644518272425249\"], [\"ModeCatalogHandler\", \"2\", \"0.006644518272425249\"], [\"TagDecl\", \"3\", \"0.009966777408637873\"], [\"ColorEntry\", \"2\", \"0.006644518272425249\"], [\"PatternSearchMatcher\", \"2\", \"0.006644518272425249\"], [\"WindowTableModel\", \"4\", \"0.013289036544850499\"], [\"IOUtilities\", \"2\", \"0.006644518272425249\"], [\"FavoritesProvider\", \"2\", \"0.006644518272425249\"], [\"Branch\", \"2\", \"0.006644518272425249\"], [\"BufferListSet\", \"2\", \"0.006644518272425249\"], [\"StringICaseCompare\", \"3\", \"0.009966777408637873\"], [\"WindowCompare\", \"3\", \"0.009966777408637873\"], [\"AbbrevCompare\", \"3\", \"0.009966777408637873\"], [\"DockableWindowCompare\", \"2\", \"0.006644518272425249\"], [\"MenuItemCompare\", \"4\", \"0.013289036544850499\"], [\"ButtonCompare\", \"4\", \"0.013289036544850499\"], [\"PluginCompare\", \"2\", \"0.006644518272425249\"], [\"Log\", \"2\", \"0.006644518272425249\"], [\"Interpreter\", \"1\", \"0.0033222591362126247\"], [\"VICaretStatus\", \"2\", \"0.006644518272425249\"], [\"WorkThread\", \"3\", \"0.009966777408637873\"], [\"ColorTableModel\", \"4\", \"0.013289036544850499\"], [\"TabbedPane\", \"1\", \"0.0033222591362126247\"], [\"TipPanel\", \"1\", \"0.0033222591362126247\"], [\"StyleRenderer\", \"1\", \"0.0033222591362126247\"], [\"WorkThreadProgressListener\", \"1\", \"0.0033222591362126247\"], [\"WorkThreadHandler\", \"1\", \"0.0033222591362126247\"], [\"TOCCellRenderer\", \"1\", \"0.0033222591362126247\"], [\"HelpNode\", \"1\", \"0.0033222591362126247\"], [\"REMatch\", \"1\", \"0.0033222591362126247\"], [\"Button\", \"2\", \"0.006644518272425249\"], [\"ButtonCellRenderer\", \"1\", \"0.0033222591362126247\"], [\"MenuItem\", \"1\", \"0.0033222591362126247\"], [\"FileCompare\", \"1\", \"0.0033222591362126247\"], [\"FoldListener\", \"1\", \"0.0033222591362126247\"], [\"FoldEventHandler\", \"1\", \"0.0033222591362126247\"], [\"ContentManager\", \"1\", \"0.0033222591362126247\"], [\"ReadWriteLock\", \"1\", \"0.0033222591362126247\"], [\"PosTopHalf\", \"1\", \"0.0033222591362126247\"], [\"AboutPanel\", \"1\", \"0.0033222591362126247\"], [\"CompoundEdit\", \"1\", \"0.0033222591362126247\"], [\"BrowserColorsModel\", \"1\", \"0.0033222591362126247\"], [\"StyleChoice\", \"1\", \"0.0033222591362126247\"], [\"ColorChoice\", \"1\", \"0.0033222591362126247\"], [\"SizeSaver\", \"2\", \"0.006644518272425249\"], [\"MarkersSaveRequest\", \"1\", \"0.0033222591362126247\"], [\"BufferSaveRequest\", \"1\", \"0.0033222591362126247\"], [\"JEditKillRing\", \"1\", \"0.0033222591362126247\"]]"
        },
        {
            "content": "Based on the co-change relationship analysis for the starting entity `jEdit.java`, several entities have a significant correlation in terms of co-changes. The confidence value indicates how often these files were modified together with `jEdit.java` across version history. Here are some notable entities that likely need to be synchronized:\n\n### High Confidence Co-Change Entities (Confidence > 0.15):\n1. **JEditTextArea.java** - Confidence: 0.2458  \n   Strong coupling suggests this file is frequently changed alongside `jEdit.java`. It's likely central to similar functionality.\n\n2. **PluginJAR.java** - Confidence: 0.2159  \n   A core part of plugin handling, which might be tightly integrated with jEdit\u2019s main logic.\n\n3. **Buffer.java** - Confidence: 0.1960  \n   This file deals with buffer management and is likely used heavily by `jEdit.java`.\n\n4. **MiscUtilities.java** - Confidence: 0.1894  \n   Contains utility functions; changes here could affect many parts of the system, including `jEdit.java`.\n\n5. **GUIUtilities.java** - Confidence: 0.1794  \n   Another utilities class dealing with GUI components, likely shared usage with `jEdit.java`.\n\n6. **DockableWindowManager.java** - Confidence: 0.1694  \n   Manages dockable windows, suggesting integration with the main application logic.\n\n### Medium Confidence Co-Change Entities (0.05 < Confidence < 0.15):\n- **ActionHandler.java** - Confidence: 0.1595\n- **View.java** - Confidence: 0.1561\n- **EditPane.java** - Confidence: 0.0963\n- **TextAreaPainter.java** - Confidence: 0.0963\n- **SearchAndReplace.java** - Confidence: 0.0631\n- **EditServer.java** - Confidence: 0.0664\n- **PanelWindowContainer.java** - Confidence: 0.0664\n- **Macros.java** - Confidence: 0.0631\n- **VFSBrowser.java** - Confidence: 0.1196\n\nThese files also show frequent co-change behavior and should be considered for synchronization depending on the nature of the change in `jEdit.java`.\n\n---\n\nTo refine the CIA further, I will check the conceptual coupling between `jEdit.java` and the top few entities from the list above. This will help determine if there is a semantic or structural dependency beyond just historical co-changes.\n\nLet's start by checking the conceptual coupling between `jEdit.java` and `JEditTextArea.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_c03ca8bb1c0d47dea282ea",
                    "function": {
                        "arguments": "{\"entity1\": \"jEdit.java\", \"entity2\": \"JEditTextArea.java\"}",
                        "name": "get_conceptual_coupling"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_conceptual_coupling",
            "content": "\"0.8465207\""
        },
        {
            "content": "The conceptual coupling between `jEdit.java` and `JEditTextArea.java` is quite high at **0.8465**, indicating a strong semantic and structural relationship. This confirms that changes in `jEdit.java` are likely to impact `JEditTextArea.java`, and vice versa. Therefore, this file should definitely be synchronized with any significant change in `jEdit.java`.\n\nLet\u2019s continue by analyzing the coupling dependencies between `jEdit.java` and `JEditTextArea.java` to understand what kind of direct code-level dependencies exist (e.g., method calls, inheritance, interface implementation, etc.).\n\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_d2ae693bb5cd46bc9e1d57",
                    "function": {
                        "arguments": "{\"entity1\": \"jEdit.java\", \"entity2\": \"JEditTextArea.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"There are no coupling dependencies between these two entities\"]"
        },
        {
            "content": "Interesting \u2014 while there is a **strong conceptual coupling** (semantic similarity) between `jEdit.java` and `JEditTextArea.java`, the **code-level coupling dependencies** are absent. This suggests that the relationship is likely *indirect* or mediated through other components such as event systems, reflection, or interfaces not explicitly tracked by static dependency analysis.\n\nThis pattern is common in GUI-based applications like jEdit, where interactions may be managed via events, listeners, or dynamic dispatch rather than direct method calls or inheritance.\n\n### Next Steps:\nTo better understand how these files interact, we can examine their **call graphs**, especially starting from `jEdit.java`, to see if any indirect references to `JEditTextArea.java` appear at runtime or through reflective usage.\n\nLet\u2019s start by retrieving the **call graph** for `jEdit.java` to identify all entities it directly interacts with.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_c253f6c380da4a78a8ab7d",
                    "function": {
                        "arguments": "{\"entity\": \"jEdit.java\"}",
                        "name": "get_call_graph"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_call_graph",
            "content": "[\"\", \"BufferIORequest\", \"PluginManager\", \"KillRing\", \"\", \"HelpViewer\", \"\", \"\", \"SearchAndReplace\", \"\", \"Log\", \"\"]"
        },
        {
            "content": "The call graph for `jEdit.java` includes the following entities it directly interacts with:\n\n- `BufferIORequest`\n- `PluginManager`\n- `KillRing`\n- `HelpViewer`\n- `SearchAndReplace`\n- `Log`\n\nInterestingly, `JEditTextArea.java` does **not** appear in this direct call graph. This reinforces the earlier observation that the coupling between `jEdit.java` and `JEditTextArea.java` is likely **indirect**, possibly through event listeners, GUI components managed elsewhere, or runtime interactions not captured by static call graph analysis.\n\n### Next Steps:\nTo better understand how `jEdit.java` might indirectly affect `JEditTextArea.java`, we should look at the **origin code** of `jEdit.java`. This will allow us to manually inspect whether there are dynamic references, event handling, or listener registrations related to text editing or GUI components (which could involve `JEditTextArea`).\n\nLet\u2019s retrieve the **source code** of `jEdit.java` for inspection.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_8fe0340c8dad4c9d857934",
                    "function": {
                        "arguments": "{\"entity\": \"jEdit.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package org.gjt.sp.jedit;\\nimport com.microstar.xml.*;\\nimport javax.swing.plaf.metal.*;\\nimport javax.swing.*;\\nimport java.awt.*;\\nimport java.io.*;\\nimport java.net.*;\\nimport java.text.MessageFormat;\\nimport java.util.*;\\nimport org.gjt.sp.jedit.buffer.BufferIORequest;\\nimport org.gjt.sp.jedit.buffer.KillRing;\\nimport org.gjt.sp.jedit.msg.*;\\nimport org.gjt.sp.jedit.gui.*;\\nimport org.gjt.sp.jedit.help.HelpViewer;\\nimport org.gjt.sp.jedit.io.*;\\nimport org.gjt.sp.jedit.pluginmgr.PluginManager;\\nimport org.gjt.sp.jedit.search.SearchAndReplace;\\nimport org.gjt.sp.jedit.syntax.*;\\nimport org.gjt.sp.jedit.textarea.*;\\nimport org.gjt.sp.util.Log;\\npublic class jEdit\\n{\\n\\tpublic static String getVersion()\\n\\t{\\n\\t\\treturn MiscUtilities.buildToVersion(getBuild());\\n\\t} \\n\\tpublic static String getBuild()\\n\\t{\\n\\t\\t\\t\\treturn \\\"04.02.03.00\\\";\\n\\t} \\n\\tpublic static void main(String[] args)\\n\\t{\\n\\t\\tmainThread = Thread.currentThread();\\n\\t\\tString javaVersion = System.getProperty(\\\"java.version\\\");\\n\\t\\tif(javaVersion.compareTo(\\\"1.3\\\") < 0)\\n\\t\\t{\\n\\t\\t\\tSystem.err.println(\\\"You are running Java version \\\"\\n\\t\\t\\t\\t+ javaVersion + \\\".\\\");\\n\\t\\t\\tSystem.err.println(\\\"jEdit requires Java 1.3 or later.\\\");\\n\\t\\t\\tSystem.exit(1);\\n\\t\\t}\\n\\t\\tsettingsDirectory = MiscUtilities.constructPath(\\n\\t\\t\\tSystem.getProperty(\\\"user.home\\\"),\\\".jedit\\\");\\n\\t\\t\\t\\t\\t\\tbackground = OperatingSystem.isMacOS();\\n\\t\\t\\t\\tboolean endOpts = false;\\n\\t\\tint level = Log.WARNING;\\n\\t\\tString portFile = \\\"server\\\";\\n\\t\\tboolean restore = true;\\n\\t\\tboolean newView = true;\\n\\t\\tboolean newPlainView = false;\\n\\t\\tboolean gui = true; \\t\\tboolean loadPlugins = true;\\n\\t\\tboolean runStartupScripts = true;\\n\\t\\tboolean quit = false;\\n\\t\\tboolean wait = false;\\n\\t\\tString userDir = System.getProperty(\\\"user.dir\\\");\\n\\t\\t\\t\\tString scriptFile = null;\\n\\t\\tfor(int i = 0; i < args.length; i++)\\n\\t\\t{\\n\\t\\t\\tString arg = args[i];\\n\\t\\t\\tif(arg == null)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\telse if(arg.length() == 0)\\n\\t\\t\\t\\targs[i] = null;\\n\\t\\t\\telse if(arg.startsWith(\\\"-\\\") && !endOpts)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(arg.equals(\\\"--\\\"))\\n\\t\\t\\t\\t\\tendOpts = true;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-usage\\\"))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tversion();\\n\\t\\t\\t\\t\\tSystem.err.println();\\n\\t\\t\\t\\t\\tusage();\\n\\t\\t\\t\\t\\tSystem.exit(1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(arg.equals(\\\"-version\\\"))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tversion();\\n\\t\\t\\t\\t\\tSystem.exit(1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(arg.startsWith(\\\"-log=\\\"))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttry\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tlevel = Integer.parseInt(arg.substring(\\\"-log=\\\".length()));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcatch(NumberFormatException nf)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tSystem.err.println(\\\"Malformed option: \\\" + arg);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(arg.equals(\\\"-nosettings\\\"))\\n\\t\\t\\t\\t\\tsettingsDirectory = null;\\n\\t\\t\\t\\telse if(arg.startsWith(\\\"-settings=\\\"))\\n\\t\\t\\t\\t\\tsettingsDirectory = arg.substring(10);\\n\\t\\t\\t\\telse if(arg.startsWith(\\\"-noserver\\\"))\\n\\t\\t\\t\\t\\tportFile = null;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-server\\\"))\\n\\t\\t\\t\\t\\tportFile = \\\"server\\\";\\n\\t\\t\\t\\telse if(arg.startsWith(\\\"-server=\\\"))\\n\\t\\t\\t\\t\\tportFile = arg.substring(8);\\n\\t\\t\\t\\telse if(arg.startsWith(\\\"-background\\\"))\\n\\t\\t\\t\\t\\tbackground = true;\\n\\t\\t\\t\\telse if(arg.startsWith(\\\"-nobackground\\\"))\\n\\t\\t\\t\\t\\tbackground = false;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-gui\\\"))\\n\\t\\t\\t\\t\\tgui = true;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-nogui\\\"))\\n\\t\\t\\t\\t\\tgui = false;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-newview\\\"))\\n\\t\\t\\t\\t\\tnewView = true;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-newplainview\\\"))\\n\\t\\t\\t\\t\\tnewPlainView = true;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-reuseview\\\"))\\n\\t\\t\\t\\t\\tnewPlainView = newView = false;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-restore\\\"))\\n\\t\\t\\t\\t\\trestore = true;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-norestore\\\"))\\n\\t\\t\\t\\t\\trestore = false;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-plugins\\\"))\\n\\t\\t\\t\\t\\tloadPlugins = true;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-noplugins\\\"))\\n\\t\\t\\t\\t\\tloadPlugins = false;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-startupscripts\\\"))\\n\\t\\t\\t\\t\\trunStartupScripts = true;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-nostartupscripts\\\"))\\n\\t\\t\\t\\t\\trunStartupScripts = false;\\n\\t\\t\\t\\telse if(arg.startsWith(\\\"-run=\\\"))\\n\\t\\t\\t\\t\\tscriptFile = arg.substring(5);\\n\\t\\t\\t\\telse if(arg.equals(\\\"-wait\\\"))\\n\\t\\t\\t\\t\\twait = true;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-quit\\\"))\\n\\t\\t\\t\\t\\tquit = true;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSystem.err.println(\\\"Unknown option: \\\"\\n\\t\\t\\t\\t\\t\\t+ arg);\\n\\t\\t\\t\\t\\tusage();\\n\\t\\t\\t\\t\\tSystem.exit(1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\targs[i] = null;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tif(settingsDirectory != null && portFile != null)\\n\\t\\t\\tportFile = MiscUtilities.constructPath(settingsDirectory,portFile);\\n\\t\\telse\\n\\t\\t\\tportFile = null;\\n\\t\\tLog.init(true,level);\\n\\t\\t\\t\\tif(portFile != null && new File(portFile).exists())\\n\\t\\t{\\n\\t\\t\\tint port, key;\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tBufferedReader in = new BufferedReader(new FileReader(portFile));\\n\\t\\t\\t\\tString check = in.readLine();\\n\\t\\t\\t\\tif(!check.equals(\\\"b\\\"))\\n\\t\\t\\t\\t\\tthrow new Exception(\\\"Wrong port file format\\\");\\n\\t\\t\\t\\tport = Integer.parseInt(in.readLine());\\n\\t\\t\\t\\tkey = Integer.parseInt(in.readLine());\\n\\t\\t\\t\\tSocket socket = new Socket(InetAddress.getByName(\\\"127.0.0.1\\\"),port);\\n\\t\\t\\t\\tDataOutputStream out = new DataOutputStream(\\n\\t\\t\\t\\t\\tsocket.getOutputStream());\\n\\t\\t\\t\\tout.writeInt(key);\\n\\t\\t\\t\\tString script;\\n\\t\\t\\t\\tif(quit)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscript = \\\"socket.close();\\\\n\\\"\\n\\t\\t\\t\\t\\t\\t+ \\\"jEdit.exit(null,true);\\\\n\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscript = makeServerScript(wait,restore,\\n\\t\\t\\t\\t\\t\\tnewView,newPlainView,args,\\n\\t\\t\\t\\t\\t\\tscriptFile);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tout.writeUTF(script);\\n\\t\\t\\t\\tLog.log(Log.DEBUG,jEdit.class,\\\"Waiting for server\\\");\\n\\t\\t\\t\\t\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsocket.getInputStream().read();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(Exception e)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tin.close();\\n\\t\\t\\t\\tout.close();\\n\\t\\t\\t\\tSystem.exit(0);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Exception e)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tLog.log(Log.NOTICE,jEdit.class,\\\"An error occurred\\\"\\n\\t\\t\\t\\t\\t+ \\\" while connecting to the jEdit server instance.\\\");\\n\\t\\t\\t\\tLog.log(Log.NOTICE,jEdit.class,\\\"This probably means that\\\"\\n\\t\\t\\t\\t\\t+ \\\" jEdit crashed and/or exited abnormally\\\");\\n\\t\\t\\t\\tLog.log(Log.NOTICE,jEdit.class,\\\"the last time it was run.\\\");\\n\\t\\t\\t\\tLog.log(Log.NOTICE,jEdit.class,\\\"If you don't\\\"\\n\\t\\t\\t\\t\\t+ \\\" know what this means, don't worry.\\\");\\n\\t\\t\\t\\tLog.log(Log.NOTICE,jEdit.class,e);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tif(quit)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tSystem.exit(0);\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(!new File(settingsDirectory,\\\"nosplash\\\").exists())\\n\\t\\t\\tGUIUtilities.showSplashScreen();\\n\\t\\t\\t\\tWriter stream;\\n\\t\\tif(settingsDirectory != null)\\n\\t\\t{\\n\\t\\t\\tFile _settingsDirectory = new File(settingsDirectory);\\n\\t\\t\\tif(!_settingsDirectory.exists())\\n\\t\\t\\t\\t_settingsDirectory.mkdirs();\\n\\t\\t\\tFile _macrosDirectory = new File(settingsDirectory,\\\"macros\\\");\\n\\t\\t\\tif(!_macrosDirectory.exists())\\n\\t\\t\\t\\t_macrosDirectory.mkdir();\\n\\t\\t\\tString logPath = MiscUtilities.constructPath(\\n\\t\\t\\t\\tsettingsDirectory,\\\"activity.log\\\");\\n\\t\\t\\tbackupSettingsFile(new File(logPath));\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tstream = new BufferedWriter(new FileWriter(logPath));\\n\\t\\t\\t\\t\\t\\t\\t\\tString lineSep = System.getProperty(\\\"line.separator\\\");\\n\\t\\t\\t\\tstream.write(\\\"Log file created on \\\" + new Date());\\n\\t\\t\\t\\tstream.write(lineSep);\\n\\t\\t\\t\\tstream.write(\\\"IMPORTANT:\\\");\\n\\t\\t\\t\\tstream.write(lineSep);\\n\\t\\t\\t\\tstream.write(\\\"Because updating this file after \\\"\\n\\t\\t\\t\\t\\t+ \\\"every log message would kill\\\");\\n\\t\\t\\t\\tstream.write(lineSep);\\n\\t\\t\\t\\tstream.write(\\\"performance, it will be *incomplete* \\\"\\n\\t\\t\\t\\t\\t+ \\\"unless you invoke the\\\");\\n\\t\\t\\t\\tstream.write(lineSep);\\n\\t\\t\\t\\tstream.write(\\\"Utilities->Troubleshooting->Update \\\"\\n\\t\\t\\t\\t\\t+ \\\"Activity Log on Disk command!\\\");\\n\\t\\t\\t\\tstream.write(lineSep);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Exception e)\\n\\t\\t\\t{\\n\\t\\t\\t\\te.printStackTrace();\\n\\t\\t\\t\\tstream = null;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstream = null;\\n\\t\\t} \\n\\t\\tLog.setLogWriter(stream);\\n\\t\\tLog.log(Log.NOTICE,jEdit.class,\\\"jEdit version \\\" + getVersion());\\n\\t\\tLog.log(Log.MESSAGE,jEdit.class,\\\"Settings directory is \\\"\\n\\t\\t\\t+ settingsDirectory);\\n\\t\\t\\t\\tif(portFile != null)\\n\\t\\t{\\n\\t\\t\\tserver = new EditServer(portFile);\\n\\t\\t\\tif(!server.isOK())\\n\\t\\t\\t\\tserver = null;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(background)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbackground = false;\\n\\t\\t\\t\\tLog.log(Log.WARNING,jEdit.class,\\\"You cannot specify both the\\\"\\n\\t\\t\\t\\t\\t+ \\\" -background and -noserver switches\\\");\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tinitMisc();\\n\\t\\tinitSystemProperties();\\n\\t\\tGUIUtilities.advanceSplashProgress();\\n\\t\\tBeanShell.init();\\n\\t\\tinitUserProperties();\\n\\t\\tinitPLAF();\\n\\t\\tif(OperatingSystem.hasJava14())\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tClassLoader loader = jEdit.class.getClassLoader();\\n\\t\\t\\t\\tClass clazz;\\n\\t\\t\\t\\tif(loader != null)\\n\\t\\t\\t\\t\\tclazz = loader.loadClass(\\\"org.gjt.sp.jedit.Java14\\\");\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tclazz = Class.forName(\\\"org.gjt.sp.jedit.Java14\\\");\\n\\t\\t\\t\\tjava.lang.reflect.Method meth = clazz\\n\\t\\t\\t\\t\\t.getMethod(\\\"init\\\",new Class[0]);\\n\\t\\t\\t\\tmeth.invoke(null,new Object[0]);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Exception e)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,jEdit.class,e);\\n\\t\\t\\t\\tSystem.exit(1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tVFSManager.init();\\n\\t\\tinitResources();\\n\\t\\tSearchAndReplace.load();\\n\\t\\tGUIUtilities.advanceSplashProgress();\\n\\t\\tif(loadPlugins)\\n\\t\\t\\tinitPlugins();\\n\\t\\tif(jEditHome != null)\\n\\t\\t\\tinitSiteProperties();\\n\\t\\tif(settingsDirectory != null)\\n\\t\\t{\\n\\t\\t\\tFile recent = new File(MiscUtilities.constructPath(\\n\\t\\t\\t\\tsettingsDirectory,\\\"recent.xml\\\"));\\n\\t\\t\\tif(recent.exists())\\n\\t\\t\\t{\\n\\t\\t\\t\\trecentModTime = recent.lastModified();\\n\\t\\t\\t\\tBufferHistory.load(recent);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tpropertiesChanged();\\n\\t\\tGUIUtilities.advanceSplashProgress();\\n\\t\\t\\t\\tsortBuffers = getBooleanProperty(\\\"sortBuffers\\\");\\n\\t\\tsortByName = getBooleanProperty(\\\"sortByName\\\");\\n\\t\\treloadModes();\\n\\t\\tGUIUtilities.advanceSplashProgress();\\n\\t\\t\\t\\tfor(int i = 0; i < jars.size(); i++)\\n\\t\\t{\\n\\t\\t\\t((PluginJAR)jars.elementAt(i)).activatePluginIfNecessary();\\n\\t\\t}\\n\\t\\t\\t\\tMacros.loadMacros();\\n\\t\\tMacros.getMacroActionSet().initKeyBindings();\\n\\t\\tif(runStartupScripts && jEditHome != null)\\n\\t\\t{\\n\\t\\t\\tString path = MiscUtilities.constructPath(jEditHome,\\\"startup\\\");\\n\\t\\t\\tFile file = new File(path);\\n\\t\\t\\tif(file.exists())\\n\\t\\t\\t\\trunStartupScripts(file);\\n\\t\\t}\\n\\t\\tif(runStartupScripts && settingsDirectory != null)\\n\\t\\t{\\n\\t\\t\\tString path = MiscUtilities.constructPath(settingsDirectory,\\\"startup\\\");\\n\\t\\t\\tFile file = new File(path);\\n\\t\\t\\tif(!file.exists())\\n\\t\\t\\t\\tfile.mkdirs();\\n\\t\\t\\telse\\n\\t\\t\\t\\trunStartupScripts(file);\\n\\t\\t} \\n\\t\\t\\t\\tif(scriptFile != null)\\n\\t\\t{\\n\\t\\t\\tscriptFile = MiscUtilities.constructPath(userDir,scriptFile);\\n\\t\\t\\tBeanShell.runScript(null,scriptFile,null,false);\\n\\t\\t} \\n\\t\\tGUIUtilities.advanceSplashProgress();\\n\\t\\t\\t\\tfinishStartup(gui,restore,userDir,args);\\n\\t} \\n\\tpublic static final Properties getProperties()\\n\\t{\\n\\t\\treturn props;\\n\\t} \\n\\tpublic static final String getProperty(String name)\\n\\t{\\n\\t\\treturn props.getProperty(name);\\n\\t} \\n\\tpublic static final String getProperty(String name, String def)\\n\\t{\\n\\t\\treturn props.getProperty(name,def);\\n\\t} \\n\\tpublic static final String getProperty(String name, Object[] args)\\n\\t{\\n\\t\\tif(name == null)\\n\\t\\t\\treturn null;\\n\\t\\tif(args == null)\\n\\t\\t\\treturn props.getProperty(name);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString value = props.getProperty(name);\\n\\t\\t\\tif(value == null)\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn MessageFormat.format(value,args);\\n\\t\\t}\\n\\t} \\n\\tpublic static final boolean getBooleanProperty(String name)\\n\\t{\\n\\t\\treturn getBooleanProperty(name,false);\\n\\t} \\n\\tpublic static final boolean getBooleanProperty(String name, boolean def)\\n\\t{\\n\\t\\tString value = getProperty(name);\\n\\t\\tif(value == null)\\n\\t\\t\\treturn def;\\n\\t\\telse if(value.equals(\\\"true\\\") || value.equals(\\\"yes\\\")\\n\\t\\t\\t|| value.equals(\\\"on\\\"))\\n\\t\\t\\treturn true;\\n\\t\\telse if(value.equals(\\\"false\\\") || value.equals(\\\"no\\\")\\n\\t\\t\\t|| value.equals(\\\"off\\\"))\\n\\t\\t\\treturn false;\\n\\t\\telse\\n\\t\\t\\treturn def;\\n\\t} \\n\\tpublic static final int getIntegerProperty(String name, int def)\\n\\t{\\n\\t\\tString value = getProperty(name);\\n\\t\\tif(value == null)\\n\\t\\t\\treturn def;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn Integer.parseInt(value.trim());\\n\\t\\t\\t}\\n\\t\\t\\tcatch(NumberFormatException nf)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn def;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tpublic static double getDoubleProperty(String name, double def)\\n\\t{\\n\\t\\tString value = getProperty(name);\\n\\t\\tif(value == null)\\n\\t\\t\\treturn def;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn Double.parseDouble(value.trim());\\n\\t\\t\\t}\\n\\t\\t\\tcatch(NumberFormatException nf)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn def;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tpublic static final Font getFontProperty(String name)\\n\\t{\\n\\t\\treturn getFontProperty(name,null);\\n\\t} \\n\\tpublic static final Font getFontProperty(String name, Font def)\\n\\t{\\n\\t\\tString family = getProperty(name);\\n\\t\\tString sizeString = getProperty(name + \\\"size\\\");\\n\\t\\tString styleString = getProperty(name + \\\"style\\\");\\n\\t\\tif(family == null || sizeString == null || styleString == null)\\n\\t\\t\\treturn def;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint size, style;\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tsize = Integer.parseInt(sizeString);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(NumberFormatException nf)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn def;\\n\\t\\t\\t}\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tstyle = Integer.parseInt(styleString);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(NumberFormatException nf)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn def;\\n\\t\\t\\t}\\n\\t\\t\\treturn new Font(family,style,size);\\n\\t\\t}\\n\\t} \\n\\tpublic static Color getColorProperty(String name)\\n\\t{\\n\\t\\treturn getColorProperty(name,Color.black);\\n\\t} \\n\\tpublic static Color getColorProperty(String name, Color def)\\n\\t{\\n\\t\\tString value = getProperty(name);\\n\\t\\tif(value == null)\\n\\t\\t\\treturn def;\\n\\t\\telse\\n\\t\\t\\treturn GUIUtilities.parseColor(value,def);\\n\\t} \\n\\tpublic static void setColorProperty(String name, Color value)\\n\\t{\\n\\t\\tsetProperty(name,GUIUtilities.getColorHexString(value));\\n\\t} \\n\\tpublic static final void setProperty(String name, String value)\\n\\t{\\n\\t\\tif(value == null)\\n\\t\\t{\\n\\t\\t\\tString prop = (String)defaultProps.get(name);\\n\\t\\t\\tif(prop == null || prop.length() == 0)\\n\\t\\t\\t\\tprops.remove(name);\\n\\t\\t\\telse\\n\\t\\t\\t\\tprops.put(name,\\\"\\\");\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString prop = (String)defaultProps.get(name);\\n\\t\\t\\tif(value.equals(prop))\\n\\t\\t\\t\\tprops.remove(name);\\n\\t\\t\\telse\\n\\t\\t\\t\\tprops.put(name,value);\\n\\t\\t}\\n\\t} \\n\\tpublic static final void setTemporaryProperty(String name, String value)\\n\\t{\\n\\t\\tprops.remove(name);\\n\\t\\tdefaultProps.put(name,value);\\n\\t} \\n\\tpublic static final void setBooleanProperty(String name, boolean value)\\n\\t{\\n\\t\\tsetProperty(name,value ? \\\"true\\\" : \\\"false\\\");\\n\\t} \\n\\tpublic static final void setIntegerProperty(String name, int value)\\n\\t{\\n\\t\\tsetProperty(name,String.valueOf(value));\\n\\t} \\n\\t\\tpublic static final void setDoubleProperty(String name, double value)\\n\\t{\\n\\t\\tsetProperty(name,String.valueOf(value));\\n\\t}\\n\\tpublic static final void setFontProperty(String name, Font value)\\n\\t{\\n\\t\\tsetProperty(name,value.getFamily());\\n\\t\\tsetIntegerProperty(name + \\\"size\\\",value.getSize());\\n\\t\\tsetIntegerProperty(name + \\\"style\\\",value.getStyle());\\n\\t} \\n\\tpublic static final void unsetProperty(String name)\\n\\t{\\n\\t\\tif(defaultProps.get(name) != null)\\n\\t\\t\\tprops.put(name,\\\"\\\");\\n\\t\\telse\\n\\t\\t\\tprops.remove(name);\\n\\t} \\n\\tpublic static final void resetProperty(String name)\\n\\t{\\n\\t\\tprops.remove(name);\\n\\t} \\n\\tpublic static void propertiesChanged()\\n\\t{\\n\\t\\tinitKeyBindings();\\n\\t\\tAutosave.setInterval(getIntegerProperty(\\\"autosave\\\",30));\\n\\t\\tsaveCaret = getBooleanProperty(\\\"saveCaret\\\");\\n\\t\\tUIDefaults defaults = UIManager.getDefaults();\\n\\t\\t\\t\\tFont font = getFontProperty(\\\"view.font\\\");\\n\\t\\t\\t\\tdefaults.put(\\\"TextArea.font\\\",font);\\n\\t\\tdefaults.put(\\\"TextPane.font\\\",font);\\n\\t\\t\\t\\tToolTipManager.sharedInstance().setEnabled(\\n\\t\\t\\tjEdit.getBooleanProperty(\\\"showTooltips\\\"));\\n\\t\\tinitProxy();\\n\\t\\t\\t\\tBuffer buffer = buffersFirst;\\n\\t\\twhile(buffer != null)\\n\\t\\t{\\n\\t\\t\\tbuffer.resetCachedProperties();\\n\\t\\t\\tbuffer.propertiesChanged();\\n\\t\\t\\tbuffer = buffer.next;\\n\\t\\t}\\n\\t\\tHistoryModel.propertiesChanged();\\n\\t\\tKillRing.propertiesChanged();\\n\\t\\tEditBus.send(new PropertiesChanged(null));\\n\\t} \\n\\tpublic static String[] getNotLoadedPluginJARs()\\n\\t{\\n\\t\\tVector returnValue = new Vector();\\n\\t\\tif(jEditHome != null)\\n\\t\\t{\\n\\t\\t\\tString systemPluginDir = MiscUtilities\\n\\t\\t\\t\\t.constructPath(jEditHome,\\\"jars\\\");\\n\\t\\t\\tString[] list = new File(systemPluginDir).list();\\n\\t\\t\\tif(list != null)\\n\\t\\t\\t\\tgetNotLoadedPluginJARs(returnValue,systemPluginDir,list);\\n\\t\\t}\\n\\t\\tif(settingsDirectory != null)\\n\\t\\t{\\n\\t\\t\\tString userPluginDir = MiscUtilities\\n\\t\\t\\t\\t.constructPath(settingsDirectory,\\\"jars\\\");\\n\\t\\t\\tString[] list = new File(userPluginDir).list();\\n\\t\\t\\tif(list != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetNotLoadedPluginJARs(returnValue,\\n\\t\\t\\t\\t\\tuserPluginDir,list);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tString[] _returnValue = new String[returnValue.size()];\\n\\t\\treturnValue.copyInto(_returnValue);\\n\\t\\treturn _returnValue;\\n\\t} \\n\\tpublic static EditPlugin getPlugin(String name)\\n\\t{\\n\\t\\tEditPlugin[] plugins = getPlugins();\\n\\t\\tfor(int i = 0; i < plugins.length; i++)\\n\\t\\t{\\n\\t\\t\\tif(plugins[i].getClassName().equals(name))\\n\\t\\t\\t\\treturn plugins[i];\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic static EditPlugin[] getPlugins()\\n\\t{\\n\\t\\tVector vector = new Vector();\\n\\t\\tfor(int i = 0; i < jars.size(); i++)\\n\\t\\t{\\n\\t\\t\\tEditPlugin plugin = ((PluginJAR)jars.elementAt(i))\\n\\t\\t\\t\\t.getPlugin();\\n\\t\\t\\tif(plugin != null)\\n\\t\\t\\t\\tvector.add(plugin);\\n\\t\\t}\\n\\t\\tEditPlugin[] array = new EditPlugin[vector.size()];\\n\\t\\tvector.copyInto(array);\\n\\t\\treturn array;\\n\\t} \\n\\tpublic static PluginJAR[] getPluginJARs()\\n\\t{\\n\\t\\tPluginJAR[] array = new PluginJAR[jars.size()];\\n\\t\\tjars.copyInto(array);\\n\\t\\treturn array;\\n\\t} \\n\\tpublic static PluginJAR getPluginJAR(String path)\\n\\t{\\n\\t\\tfor(int i = 0; i < jars.size(); i++)\\n\\t\\t{\\n\\t\\t\\tPluginJAR jar = (PluginJAR)jars.elementAt(i);\\n\\t\\t\\tif(jar.getPath().equals(path))\\n\\t\\t\\t\\treturn jar;\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic static void addPluginJAR(String path)\\n\\t{\\n\\t\\t\\t\\tPluginJAR jar = new EditPlugin.JAR(new File(path));\\n\\t\\tjars.addElement(jar);\\n\\t\\tjar.init();\\n\\t\\tEditBus.send(new PluginUpdate(jar,PluginUpdate.LOADED,false));\\n\\t\\tif(!isMainThread())\\n\\t\\t\\tEditBus.send(new DynamicMenuChanged(\\\"plugins\\\"));\\n\\t} \\n\\tprivate static void addPluginJARsFromDirectory(String directory)\\n\\t{\\n\\t\\tLog.log(Log.NOTICE,jEdit.class,\\\"Loading plugins from \\\"\\n\\t\\t\\t+ directory);\\n\\t\\tFile file = new File(directory);\\n\\t\\tif(!(file.exists() && file.isDirectory()))\\n\\t\\t\\treturn;\\n\\t\\tString[] plugins = file.list();\\n\\t\\tif(plugins == null)\\n\\t\\t\\treturn;\\n\\t\\tfor(int i = 0; i < plugins.length; i++)\\n\\t\\t{\\n\\t\\t\\tString plugin = plugins[i];\\n\\t\\t\\tif(!plugin.toLowerCase().endsWith(\\\".jar\\\"))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tString path = MiscUtilities.constructPath(directory,plugin);\\n\\t\\t\\tif(plugin.equals(\\\"EditBuddy.jar\\\")\\n\\t\\t\\t\\t|| plugin.equals(\\\"PluginManager.jar\\\")\\n\\t\\t\\t\\t|| plugin.equals(\\\"Firewall.jar\\\")\\n\\t\\t\\t\\t|| plugin.equals(\\\"Tidy.jar\\\"))\\n\\t\\t\\t{\\n\\t\\t\\t\\tpluginError(path,\\\"plugin-error.obsolete\\\",null);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\taddPluginJAR(path);\\n\\t\\t}\\n\\t} \\n\\tpublic static void removePluginJAR(PluginJAR jar, boolean exit)\\n\\t{\\n\\t\\tif(exit)\\n\\t\\t{\\n\\t\\t\\tjar.uninit(true);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tjar.uninit(false);\\n\\t\\t\\tjars.removeElement(jar);\\n\\t\\t}\\n\\t\\tEditBus.send(new PluginUpdate(jar,PluginUpdate.UNLOADED,exit));\\n\\t\\tif(!isMainThread() && !exit)\\n\\t\\t\\tEditBus.send(new DynamicMenuChanged(\\\"plugins\\\"));\\n\\t} \\n\\tpublic static ActionContext getActionContext()\\n\\t{\\n\\t\\treturn actionContext;\\n\\t} \\n\\tpublic static void addActionSet(ActionSet actionSet)\\n\\t{\\n\\t\\tactionContext.addActionSet(actionSet);\\n\\t} \\n\\tpublic static void removeActionSet(ActionSet actionSet)\\n\\t{\\n\\t\\tactionContext.removeActionSet(actionSet);\\n\\t} \\n\\tpublic static ActionSet getBuiltInActionSet()\\n\\t{\\n\\t\\treturn builtInActionSet;\\n\\t} \\n\\tpublic static ActionSet[] getActionSets()\\n\\t{\\n\\t\\treturn actionContext.getActionSets();\\n\\t} \\n\\tpublic static EditAction getAction(String name)\\n\\t{\\n\\t\\treturn actionContext.getAction(name);\\n\\t} \\n\\tpublic static ActionSet getActionSetForAction(String action)\\n\\t{\\n\\t\\treturn actionContext.getActionSetForAction(action);\\n\\t} \\n\\tpublic static ActionSet getActionSetForAction(EditAction action)\\n\\t{\\n\\t\\treturn actionContext.getActionSetForAction(action.getName());\\n\\t} \\n\\tpublic static EditAction[] getActions()\\n\\t{\\n\\t\\tString[] names = actionContext.getActionNames();\\n\\t\\tEditAction[] actions = new EditAction[names.length];\\n\\t\\tfor(int i = 0; i < actions.length; i++)\\n\\t\\t{\\n\\t\\t\\tactions[i] = actionContext.getAction(names[i]);\\n\\t\\t\\tif(actions[i] == null)\\n\\t\\t\\t\\tLog.log(Log.ERROR,jEdit.class,\\\"wtf: \\\" + names[i]);\\n\\t\\t}\\n\\t\\treturn actions;\\n\\t} \\n\\tpublic static String[] getActionNames()\\n\\t{\\n\\t\\treturn actionContext.getActionNames();\\n\\t} \\n\\tpublic static void reloadModes()\\n\\t{\\n\\t\\tmodes = new Vector(50);\\n\\t\\t\\t\\tif(jEditHome == null)\\n\\t\\t\\tloadModeCatalog(\\\"/modes/catalog\\\",true);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tloadModeCatalog(MiscUtilities.constructPath(jEditHome,\\n\\t\\t\\t\\t\\\"modes\\\",\\\"catalog\\\"),false);\\n\\t\\t} \\n\\t\\t\\t\\tif(settingsDirectory != null)\\n\\t\\t{\\n\\t\\t\\tFile userModeDir = new File(MiscUtilities.constructPath(\\n\\t\\t\\t\\tsettingsDirectory,\\\"modes\\\"));\\n\\t\\t\\tif(!userModeDir.exists())\\n\\t\\t\\t\\tuserModeDir.mkdirs();\\n\\t\\t\\tFile userCatalog = new File(MiscUtilities.constructPath(\\n\\t\\t\\t\\tsettingsDirectory,\\\"modes\\\",\\\"catalog\\\"));\\n\\t\\t\\tif(!userCatalog.exists())\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tFileWriter out = new FileWriter(userCatalog);\\n\\t\\t\\t\\t\\tout.write(jEdit.getProperty(\\\"defaultCatalog\\\"));\\n\\t\\t\\t\\t\\tout.close();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tLog.log(Log.ERROR,jEdit.class,io);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tloadModeCatalog(userCatalog.getPath(),false);\\n\\t\\t} \\n\\t\\tBuffer buffer = buffersFirst;\\n\\t\\twhile(buffer != null)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbuffer.setMode();\\n\\t\\t\\tbuffer = buffer.next;\\n\\t\\t}\\n\\t} \\n\\tpublic static Mode getMode(String name)\\n\\t{\\n\\t\\tfor(int i = 0; i < modes.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMode mode = (Mode)modes.elementAt(i);\\n\\t\\t\\tif(mode.getName().equals(name))\\n\\t\\t\\t\\treturn mode;\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic static Mode[] getModes()\\n\\t{\\n\\t\\tMode[] array = new Mode[modes.size()];\\n\\t\\tmodes.copyInto(array);\\n\\t\\treturn array;\\n\\t} \\n\\tpublic static Buffer openFiles(View view, String parent, String[] args)\\n\\t{\\n\\t\\tBuffer retVal = null;\\n\\t\\tBuffer lastBuffer = null;\\n\\t\\tfor(int i = 0; i < args.length; i++)\\n\\t\\t{\\n\\t\\t\\tString arg = args[i];\\n\\t\\t\\tif(arg == null)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\telse if(arg.startsWith(\\\"+line:\\\") || arg.startsWith(\\\"+marker:\\\"))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(lastBuffer != null)\\n\\t\\t\\t\\t\\tgotoMarker(view,lastBuffer,arg);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tlastBuffer = openFile(null,parent,arg,false,null);\\n\\t\\t\\tif(retVal == null && lastBuffer != null)\\n\\t\\t\\t\\tretVal = lastBuffer;\\n\\t\\t}\\n\\t\\tif(view != null && retVal != null)\\n\\t\\t\\tview.setBuffer(retVal);\\n\\t\\treturn retVal;\\n\\t} \\n\\tpublic static Buffer openFile(View view, String path)\\n\\t{\\n\\t\\treturn openFile(view,null,path,false,new Hashtable());\\n\\t} \\n\\tpublic static Buffer openFile(View view, String parent,\\n\\t\\tString path, boolean readOnly, boolean newFile)\\n\\t{\\n\\t\\treturn openFile(view,parent,path,newFile,new Hashtable());\\n\\t} \\n\\tpublic static Buffer openFile(View view, String parent,\\n\\t\\tString path, boolean readOnly, boolean newFile,\\n\\t\\tHashtable props)\\n\\t{\\n\\t\\treturn openFile(view,parent,path,newFile,props);\\n\\t} \\n\\tpublic static Buffer openFile(View view, String parent,\\n\\t\\tString path, boolean newFile, Hashtable props)\\n\\t{\\n\\t\\tif(view != null && parent == null)\\n\\t\\t\\tparent = view.getBuffer().getDirectory();\\n\\t\\tif(MiscUtilities.isURL(path))\\n\\t\\t{\\n\\t\\t\\tif(MiscUtilities.getProtocolOfURL(path).equals(\\\"file\\\"))\\n\\t\\t\\t\\tpath = path.substring(5);\\n\\t\\t}\\n\\t\\tpath = MiscUtilities.constructPath(parent,path);\\n\\t\\tsynchronized(bufferListLock)\\n\\t\\t{\\n\\t\\t\\tBuffer buffer = getBuffer(path);\\n\\t\\t\\tif(buffer != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(view != null)\\n\\t\\t\\t\\t\\tview.setBuffer(buffer);\\n\\t\\t\\t\\treturn buffer;\\n\\t\\t\\t}\\n\\t\\t\\tif(props == null)\\n\\t\\t\\t\\tprops = new Hashtable();\\n\\t\\t\\tBufferHistory.Entry entry = BufferHistory.getEntry(path);\\n\\t\\t\\tif(entry != null && saveCaret && props.get(Buffer.CARET) == null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tprops.put(Buffer.CARET,new Integer(entry.caret));\\n\\t\\t\\t}\\n\\t\\t\\tif(entry != null && props.get(Buffer.ENCODING) == null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(entry.encoding != null)\\n\\t\\t\\t\\t\\tprops.put(Buffer.ENCODING,entry.encoding);\\n\\t\\t\\t}\\n\\t\\t\\tBuffer newBuffer = new Buffer(path,newFile,false,props);\\n\\t\\t\\tif(!newBuffer.load(view,false))\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\taddBufferToList(newBuffer);\\n\\t\\t\\tEditBus.send(new BufferUpdate(newBuffer,view,BufferUpdate.CREATED));\\n\\t\\t\\tif(view != null)\\n\\t\\t\\t\\tview.setBuffer(newBuffer);\\n\\t\\t\\treturn newBuffer;\\n\\t\\t}\\n\\t} \\n\\tpublic static Buffer openTemporary(View view, String parent,\\n\\t\\tString path, boolean newFile)\\n\\t{\\n\\t\\tif(view != null && parent == null)\\n\\t\\t\\tparent = view.getBuffer().getDirectory();\\n\\t\\tif(MiscUtilities.isURL(path))\\n\\t\\t{\\n\\t\\t\\tif(MiscUtilities.getProtocolOfURL(path).equals(\\\"file\\\"))\\n\\t\\t\\t\\tpath = path.substring(5);\\n\\t\\t}\\n\\t\\tpath = MiscUtilities.constructPath(parent,path);\\n\\t\\tsynchronized(bufferListLock)\\n\\t\\t{\\n\\t\\t\\tBuffer buffer = getBuffer(path);\\n\\t\\t\\tif(buffer != null)\\n\\t\\t\\t\\treturn buffer;\\n\\t\\t\\tbuffer = new Buffer(path,newFile,true,new Hashtable());\\n\\t\\t\\tif(!buffer.load(view,false))\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn buffer;\\n\\t\\t}\\n\\t} \\n\\tpublic static void commitTemporary(Buffer buffer)\\n\\t{\\n\\t\\tif(!buffer.isTemporary())\\n\\t\\t\\treturn;\\n\\t\\taddBufferToList(buffer);\\n\\t\\tbuffer.commitTemporary();\\n\\t\\t\\t\\tEditBus.send(new BufferUpdate(buffer,null,BufferUpdate.CREATED));\\n\\t\\tEditBus.send(new BufferUpdate(buffer,null,BufferUpdate.LOAD_STARTED));\\n\\t\\tEditBus.send(new BufferUpdate(buffer,null,BufferUpdate.LOADED));\\n\\t} \\n\\tpublic static Buffer newFile(View view)\\n\\t{\\n\\t\\tString path;\\n\\t\\tif(view != null && view.getBuffer() != null)\\n\\t\\t{\\n\\t\\t\\tpath = view.getBuffer().getDirectory();\\n\\t\\t\\tVFS vfs = VFSManager.getVFSForPath(path);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif((vfs.getCapabilities() & VFS.WRITE_CAP) == 0)\\n\\t\\t\\t\\tpath = System.getProperty(\\\"user.home\\\");\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tpath = null;\\n\\t\\treturn newFile(view,path);\\n\\t} \\n\\tpublic static Buffer newFile(View view, String dir)\\n\\t{\\n\\t\\t\\t\\t\\t\\tif(dir != null\\n\\t\\t\\t&& buffersFirst != null\\n\\t\\t\\t&& buffersFirst == buffersLast\\n\\t\\t\\t&& buffersFirst.isUntitled()\\n\\t\\t\\t&& !buffersFirst.isDirty())\\n\\t\\t{\\n\\t\\t\\tcloseBuffer(view,buffersFirst);\\n\\t\\t\\t\\t\\t\\treturn buffersFirst;\\n\\t\\t}\\n\\t\\t\\t\\tint untitledCount = 0;\\n\\t\\tBuffer buffer = buffersFirst;\\n\\t\\twhile(buffer != null)\\n\\t\\t{\\n\\t\\t\\tif(buffer.getName().startsWith(\\\"Untitled-\\\"))\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tuntitledCount = Math.max(untitledCount,\\n\\t\\t\\t\\t\\t\\tInteger.parseInt(buffer.getName()\\n\\t\\t\\t\\t\\t\\t.substring(9)));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(NumberFormatException nf)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tbuffer = buffer.next;\\n\\t\\t}\\n\\t\\treturn openFile(view,dir,\\\"Untitled-\\\" + (untitledCount+1),true,null);\\n\\t} \\n\\tpublic static boolean closeBuffer(View view, Buffer buffer)\\n\\t{\\n\\t\\t\\t\\tif(buffer.isPerformingIO())\\n\\t\\t{\\n\\t\\t\\tVFSManager.waitForRequests();\\n\\t\\t\\tif(VFSManager.errorOccurred())\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tif(buffer.isDirty())\\n\\t\\t{\\n\\t\\t\\tObject[] args = { buffer.getName() };\\n\\t\\t\\tint result = GUIUtilities.confirm(view,\\\"notsaved\\\",args,\\n\\t\\t\\t\\tJOptionPane.YES_NO_CANCEL_OPTION,\\n\\t\\t\\t\\tJOptionPane.WARNING_MESSAGE);\\n\\t\\t\\tif(result == JOptionPane.YES_OPTION)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(!buffer.save(view,null,true))\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tVFSManager.waitForRequests();\\n\\t\\t\\t\\tif(buffer.getBooleanProperty(BufferIORequest\\n\\t\\t\\t\\t\\t.ERROR_OCCURRED))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(result != JOptionPane.NO_OPTION)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t_closeBuffer(view,buffer);\\n\\t\\treturn true;\\n\\t} \\n\\tpublic static void _closeBuffer(View view, Buffer buffer)\\n\\t{\\n\\t\\tif(buffer.isClosed())\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(!buffer.isNewFile())\\n\\t\\t{\\n\\t\\t\\tview.getEditPane().saveCaretInfo();\\n\\t\\t\\tInteger _caret = (Integer)buffer.getProperty(Buffer.CARET);\\n\\t\\t\\tint caret = (_caret == null ? 0 : _caret.intValue());\\n\\t\\t\\tBufferHistory.setEntry(buffer.getPath(),caret,\\n\\t\\t\\t\\t(Selection[])buffer.getProperty(Buffer.SELECTION),\\n\\t\\t\\t\\tbuffer.getStringProperty(Buffer.ENCODING));\\n\\t\\t}\\n\\t\\tremoveBufferFromList(buffer);\\n\\t\\tbuffer.close();\\n\\t\\tDisplayManager.bufferClosed(buffer);\\n\\t\\tEditBus.send(new BufferUpdate(buffer,view,BufferUpdate.CLOSED));\\n\\t\\t\\t\\tif(buffersFirst == null && buffersLast == null)\\n\\t\\t\\tnewFile(view);\\n\\t} \\n\\tpublic static boolean closeAllBuffers(View view)\\n\\t{\\n\\t\\treturn closeAllBuffers(view,false);\\n\\t} \\n\\tpublic static boolean closeAllBuffers(View view, boolean isExiting)\\n\\t{\\n\\t\\tboolean dirty = false;\\n\\t\\tBuffer buffer = buffersFirst;\\n\\t\\twhile(buffer != null)\\n\\t\\t{\\n\\t\\t\\tif(buffer.isDirty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tdirty = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tbuffer = buffer.next;\\n\\t\\t}\\n\\t\\tif(dirty)\\n\\t\\t{\\n\\t\\t\\tboolean ok = new CloseDialog(view).isOK();\\n\\t\\t\\tif(!ok)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\t\\tVFSManager.waitForRequests();\\n\\t\\tif(VFSManager.errorOccurred())\\n\\t\\t\\treturn false;\\n\\t\\tbuffer = buffersFirst;\\n\\t\\t\\t\\tbuffersFirst = buffersLast = null;\\n\\t\\tbufferHash.clear();\\n\\t\\tbufferCount = 0;\\n\\t\\twhile(buffer != null)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isNewFile())\\n\\t\\t\\t{\\n\\t\\t\\t\\tInteger _caret = (Integer)buffer.getProperty(Buffer.CARET);\\n\\t\\t\\t\\tint caret = (_caret == null ? 0 : _caret.intValue());\\n\\t\\t\\t\\tBufferHistory.setEntry(buffer.getPath(),caret,\\n\\t\\t\\t\\t\\t(Selection[])buffer.getProperty(Buffer.SELECTION),\\n\\t\\t\\t\\t\\tbuffer.getStringProperty(Buffer.ENCODING));\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.close();\\n\\t\\t\\tDisplayManager.bufferClosed(buffer);\\n\\t\\t\\tif(!isExiting)\\n\\t\\t\\t{\\n\\t\\t\\t\\tEditBus.send(new BufferUpdate(buffer,view,\\n\\t\\t\\t\\t\\tBufferUpdate.CLOSED));\\n\\t\\t\\t}\\n\\t\\t\\tbuffer = buffer.next;\\n\\t\\t}\\n\\t\\tif(!isExiting)\\n\\t\\t\\tnewFile(view);\\n\\t\\treturn true;\\n\\t} \\n\\tpublic static void saveAllBuffers(View view)\\n\\t{\\n\\t\\tsaveAllBuffers(view,jEdit.getBooleanProperty(\\\"confirm.save-all\\\"));\\n\\t} \\n\\tpublic static void saveAllBuffers(View view, boolean confirm)\\n\\t{\\n\\t\\tif(confirm)\\n\\t\\t{\\n\\t\\t\\tint result = GUIUtilities.confirm(view,\\\"saveall\\\",null,\\n\\t\\t\\t\\tJOptionPane.YES_NO_OPTION,\\n\\t\\t\\t\\tJOptionPane.QUESTION_MESSAGE);\\n\\t\\t\\tif(result != JOptionPane.YES_OPTION)\\n\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tBuffer current = view.getBuffer();\\n\\t\\tBuffer buffer = buffersFirst;\\n\\t\\twhile(buffer != null)\\n\\t\\t{\\n\\t\\t\\tif(buffer.isDirty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.isNewFile())\\n\\t\\t\\t\\t\\tview.setBuffer(buffer);\\n\\t\\t\\t\\tbuffer.save(view,null,true);\\n\\t\\t\\t}\\n\\t\\t\\tbuffer = buffer.next;\\n\\t\\t}\\n\\t\\tview.setBuffer(current);\\n\\t} \\n\\tpublic static void reloadAllBuffers(final View view, boolean confirm)\\n\\t{\\n\\t\\tif(confirm)\\n\\t\\t{\\n\\t\\t\\tint result = GUIUtilities.confirm(view,\\\"reload-all\\\",null,\\n\\t\\t\\t\\tJOptionPane.YES_NO_OPTION,\\n\\t\\t\\t\\tJOptionPane.QUESTION_MESSAGE);\\n\\t\\t\\tif(result != JOptionPane.YES_OPTION)\\n\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\t\\tView _view = viewsFirst;\\n\\t\\twhile(_view != null)\\n\\t\\t{\\n\\t\\t\\tEditPane[] panes = _view.getEditPanes();\\n\\t\\t\\tfor(int i = 0; i < panes.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tpanes[i].saveCaretInfo();\\n\\t\\t\\t}\\n\\t\\t\\t_view = _view.next;\\n\\t\\t}\\n\\t\\tBuffer[] buffers = jEdit.getBuffers();\\n\\t\\tfor(int i = 0; i < buffers.length; i++)\\n\\t\\t{\\n\\t\\t\\tBuffer buffer = buffers[i];\\n\\t\\t\\tbuffer.load(view,true);\\n\\t\\t}\\n\\t} \\n\\tpublic static Buffer getBuffer(String path)\\n\\t{\\n\\t\\tif(!MiscUtilities.isURL(path))\\n\\t\\t\\tpath = MiscUtilities.resolveSymlinks(path);\\n\\t\\tboolean caseInsensitiveFilesystem =\\n\\t\\t\\tOperatingSystem.isDOSDerived()\\n\\t\\t\\t|| OperatingSystem.isMacOS();\\n\\t\\tif(caseInsensitiveFilesystem)\\n\\t\\t\\tpath = path.toLowerCase();\\n\\t\\tsynchronized(bufferListLock)\\n\\t\\t{\\n\\t\\t\\treturn (Buffer)bufferHash.get(path);\\n\\t\\t}\\n\\t} \\n\\tpublic static Buffer[] getBuffers()\\n\\t{\\n\\t\\tsynchronized(bufferListLock)\\n\\t\\t{\\n\\t\\t\\tBuffer[] buffers = new Buffer[bufferCount];\\n\\t\\t\\tBuffer buffer = buffersFirst;\\n\\t\\t\\tfor(int i = 0; i < bufferCount; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffers[i] = buffer;\\n\\t\\t\\t\\tbuffer = buffer.next;\\n\\t\\t\\t}\\n\\t\\t\\treturn buffers;\\n\\t\\t}\\n\\t} \\n\\tpublic static int getBufferCount()\\n\\t{\\n\\t\\treturn bufferCount;\\n\\t} \\n\\tpublic static Buffer getFirstBuffer()\\n\\t{\\n\\t\\treturn buffersFirst;\\n\\t} \\n\\tpublic static Buffer getLastBuffer()\\n\\t{\\n\\t\\treturn buffersLast;\\n\\t} \\n\\tpublic static void checkBufferStatus(View view)\\n\\t{\\n\\t\\t\\t\\t\\t\\tboolean showDialogSetting = getBooleanProperty(\\\"view.checkModStatus\\\");\\n\\t\\tBuffer[] buffers = jEdit.getBuffers();\\n\\t\\tint[] states = new int[buffers.length];\\n\\t\\tboolean show = false;\\n\\t\\tfor(int i = 0; i < buffers.length; i++)\\n\\t\\t{\\n\\t\\t\\tBuffer buffer = buffers[i];\\n\\t\\t\\tstates[i] = buffer.checkFileStatus(view);\\n\\t\\t\\tswitch(states[i])\\n\\t\\t\\t{\\n\\t\\t\\tcase Buffer.FILE_CHANGED:\\n\\t\\t\\t\\tif(showDialogSetting && !buffer.isDirty())\\n\\t\\t\\t\\t\\tbuffer.load(view,true);\\n\\t\\t\\tcase Buffer.FILE_DELETED:\\n\\t\\t\\t\\tshow = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(show && showDialogSetting)\\n\\t\\t\\tnew FilesChangedDialog(view,states);\\n\\t} \\n\\tpublic static InputHandler getInputHandler()\\n\\t{\\n\\t\\treturn inputHandler;\\n\\t} \\n\\tpublic static View newView(View view)\\n\\t{\\n\\t\\treturn newView(view,null,false);\\n\\t} \\n\\tpublic static View newView(View view, Buffer buffer)\\n\\t{\\n\\t\\treturn newView(view,buffer,false);\\n\\t} \\n\\tpublic static View newView(View view, Buffer buffer, boolean plainView)\\n\\t{\\n\\t\\tView.ViewConfig config;\\n\\t\\tif(view != null && (plainView == view.isPlainView()))\\n\\t\\t\\tconfig = view.getViewConfig();\\n\\t\\telse\\n\\t\\t\\tconfig = new View.ViewConfig(plainView);\\n\\t\\treturn newView(view,buffer,config);\\n\\t} \\n\\tpublic static View newView(View view, Buffer buffer, View.ViewConfig config)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tif(view != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tview.showWaitCursor();\\n\\t\\t\\t\\tview.getEditPane().saveCaretInfo();\\n\\t\\t\\t}\\n\\t\\t\\tView newView = new View(buffer,config);\\n\\t\\t\\taddViewToList(newView);\\n\\t\\t\\tif(!config.plainView)\\n\\t\\t\\t{\\n\\t\\t\\t\\tDockableWindowManager wm = newView.getDockableWindowManager();\\n\\t\\t\\t\\tif(config.top != null\\n\\t\\t\\t\\t\\t&& config.top.length() != 0)\\n\\t\\t\\t\\t\\twm.showDockableWindow(config.top);\\n\\t\\t\\t\\tif(config.left != null\\n\\t\\t\\t\\t\\t&& config.left.length() != 0)\\n\\t\\t\\t\\t\\twm.showDockableWindow(config.left);\\n\\t\\t\\t\\tif(config.bottom != null\\n\\t\\t\\t\\t\\t&& config.bottom.length() != 0)\\n\\t\\t\\t\\t\\twm.showDockableWindow(config.bottom);\\n\\t\\t\\t\\tif(config.right != null\\n\\t\\t\\t\\t\\t&& config.right.length() != 0)\\n\\t\\t\\t\\t\\twm.showDockableWindow(config.right);\\n\\t\\t\\t}\\n\\t\\t\\tnewView.pack();\\n\\t\\t\\tif(config.width != 0 && config.height != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tGUIUtilities.setWindowBounds(newView,config.x,config.y,\\n\\t\\t\\t\\t\\tconfig.width,config.height,config.extState);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tnewView.setLocationRelativeTo(view);\\n\\t\\t\\tEditBus.send(new ViewUpdate(newView,ViewUpdate.CREATED));\\n\\t\\t\\tnewView.show();\\n\\t\\t\\t\\t\\t\\tif(newView == viewsFirst)\\n\\t\\t\\t{\\n\\t\\t\\t\\tnewView.getTextArea().requestFocus();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(settingsDirectory != null && getBooleanProperty(\\\"firstTime\\\"))\\n\\t\\t\\t\\t\\tnew HelpViewer();\\n\\t\\t\\t\\telse if(jEdit.getBooleanProperty(\\\"tip.show\\\"))\\n\\t\\t\\t\\t\\tnew TipOfTheDay(newView);\\n\\t\\t\\t\\tsetBooleanProperty(\\\"firstTime\\\",false);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tGUIUtilities.requestFocus(newView,newView.getTextArea());\\n\\t\\t\\treturn newView;\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tif(view != null)\\n\\t\\t\\t\\tview.hideWaitCursor();\\n\\t\\t}\\n\\t} \\n\\tpublic static void closeView(View view)\\n\\t{\\n\\t\\tcloseView(view,true);\\n\\t} \\n\\tpublic static View[] getViews()\\n\\t{\\n\\t\\tView[] views = new View[viewCount];\\n\\t\\tView view = viewsFirst;\\n\\t\\tfor(int i = 0; i < viewCount; i++)\\n\\t\\t{\\n\\t\\t\\tviews[i] = view;\\n\\t\\t\\tview = view.next;\\n\\t\\t}\\n\\t\\treturn views;\\n\\t} \\n\\tpublic static int getViewCount()\\n\\t{\\n\\t\\treturn viewCount;\\n\\t} \\n\\tpublic static View getFirstView()\\n\\t{\\n\\t\\treturn viewsFirst;\\n\\t} \\n\\tpublic static View getLastView()\\n\\t{\\n\\t\\treturn viewsLast;\\n\\t} \\n\\tpublic static View getActiveView()\\n\\t{\\n\\t\\treturn activeView;\\n\\t} \\n\\tpublic static boolean isMainThread()\\n\\t{\\n\\t\\treturn (Thread.currentThread() == mainThread);\\n\\t} \\n\\tpublic static boolean isBackgroundModeEnabled()\\n\\t{\\n\\t\\treturn background;\\n\\t} \\n\\tpublic static void showMemoryDialog(View view)\\n\\t{\\n\\t\\tRuntime rt = Runtime.getRuntime();\\n\\t\\tint before = (int) (rt.freeMemory() / 1024);\\n\\t\\tSystem.gc();\\n\\t\\tint after = (int) (rt.freeMemory() / 1024);\\n\\t\\tint total = (int) (rt.totalMemory() / 1024);\\n\\t\\tJProgressBar progress = new JProgressBar(0,total);\\n\\t\\tprogress.setValue(total - after);\\n\\t\\tprogress.setStringPainted(true);\\n\\t\\tprogress.setString(jEdit.getProperty(\\\"memory-status.use\\\",\\n\\t\\t\\tnew Object[] { new Integer(total - after),\\n\\t\\t\\tnew Integer(total) }));\\n\\t\\tObject[] message = new Object[4];\\n\\t\\tmessage[0] = getProperty(\\\"memory-status.gc\\\",\\n\\t\\t\\tnew Object[] { new Integer(after - before) });\\n\\t\\tmessage[1] = Box.createVerticalStrut(12);\\n\\t\\tmessage[2] = progress;\\n\\t\\tmessage[3] = Box.createVerticalStrut(6);\\n\\t\\tJOptionPane.showMessageDialog(view,message,\\n\\t\\t\\tjEdit.getProperty(\\\"memory-status.title\\\"),\\n\\t\\t\\tJOptionPane.INFORMATION_MESSAGE);\\n\\t} \\n\\tpublic static String getJEditHome()\\n\\t{\\n\\t\\treturn jEditHome;\\n\\t} \\n\\tpublic static String getSettingsDirectory()\\n\\t{\\n\\t\\treturn settingsDirectory;\\n\\t} \\n\\tpublic static String getJARCacheDirectory()\\n\\t{\\n\\t\\treturn jarCacheDirectory;\\n\\t} \\n\\tpublic static void backupSettingsFile(File file)\\n\\t{\\n\\t\\tif(settingsDirectory == null)\\n\\t\\t\\treturn;\\n\\t\\tString backupDir = MiscUtilities.constructPath(\\n\\t\\t\\tsettingsDirectory,\\\"settings-backup\\\");\\n\\t\\tFile dir = new File(backupDir);\\n\\t\\tif(!dir.exists())\\n\\t\\t\\tdir.mkdirs();\\n\\t\\tMiscUtilities.saveBackup(file,5,null,\\\"~\\\",backupDir);\\n\\t} \\n\\tpublic static void saveSettings()\\n\\t{\\n\\t\\tif(settingsDirectory != null)\\n\\t\\t{\\n\\t\\t\\tAbbrevs.save();\\n\\t\\t\\tFavoritesVFS.saveFavorites();\\n\\t\\t\\tHistoryModel.saveHistory();\\n\\t\\t\\tRegisters.saveRegisters();\\n\\t\\t\\tSearchAndReplace.save();\\n\\t\\t\\t\\t\\t\\tFile file1 = new File(MiscUtilities.constructPath(\\n\\t\\t\\t\\tsettingsDirectory, \\\"#recent.xml#save#\\\"));\\n\\t\\t\\tFile file2 = new File(MiscUtilities.constructPath(\\n\\t\\t\\t\\tsettingsDirectory, \\\"recent.xml\\\"));\\n\\t\\t\\tif(file2.exists() && file2.lastModified() != recentModTime)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.WARNING,jEdit.class,file2 + \\\" changed\\\"\\n\\t\\t\\t\\t\\t+ \\\" on disk; will not save recent files\\\");\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tbackupSettingsFile(file2);\\n\\t\\t\\t\\tBufferHistory.save(file1);\\n\\t\\t\\t\\tfile2.delete();\\n\\t\\t\\t\\tfile1.renameTo(file2);\\n\\t\\t\\t}\\n\\t\\t\\trecentModTime = file2.lastModified();\\n\\t\\t\\tfile1 = new File(MiscUtilities.constructPath(\\n\\t\\t\\t\\tsettingsDirectory,\\\"#properties#save#\\\"));\\n\\t\\t\\tfile2 = new File(MiscUtilities.constructPath(\\n\\t\\t\\t\\tsettingsDirectory,\\\"properties\\\"));\\n\\t\\t\\tif(file2.exists() && file2.lastModified() != propsModTime)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.WARNING,jEdit.class,file2 + \\\" changed\\\"\\n\\t\\t\\t\\t\\t+ \\\" on disk; will not save user properties\\\");\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tbackupSettingsFile(file2);\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tOutputStream out = new FileOutputStream(file1);\\n\\t\\t\\t\\t\\tprops.store(out,\\\"jEdit properties\\\");\\n\\t\\t\\t\\t\\tout.close();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tLog.log(Log.ERROR,jEdit.class,io);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfile2.delete();\\n\\t\\t\\t\\tfile1.renameTo(file2);\\n\\t\\t\\t}\\n\\t\\t\\tpropsModTime = file2.lastModified();\\n\\t\\t}\\n\\t} \\n\\tpublic static void exit(View view, boolean reallyExit)\\n\\t{\\n\\t\\t\\t\\tif(view == null)\\n\\t\\t\\tview = activeView;\\n\\t\\t\\t\\tVFSManager.waitForRequests();\\n\\t\\t\\t\\tEditBus.send(new EditorExitRequested(view));\\n\\t\\t\\t\\t\\t\\treallyExit |= !background;\\n\\t\\tPerspectiveManager.savePerspective(false);\\n\\t\\t\\t\\tif(!closeAllBuffers(view,reallyExit))\\n\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\tif(!reallyExit)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tview = viewsFirst;\\n\\t\\t\\twhile(view != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcloseView(view,false);\\n\\t\\t\\t\\tview = view.next;\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tsaveSettings();\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(view != null)\\n\\t\\t\\t\\tview.close();\\n\\t\\t\\t\\t\\t\\tAutosave.stop();\\n\\t\\t\\t\\t\\t\\tif(server != null)\\n\\t\\t\\t\\tserver.stopServer();\\n\\t\\t\\t\\t\\t\\tPluginJAR[] plugins = getPluginJARs();\\n\\t\\t\\tfor(int i = 0; i < plugins.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tremovePluginJAR(plugins[i],true);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tEditBus.send(new EditorExiting(null));\\n\\t\\t\\t\\t\\t\\tsaveSettings();\\n\\t\\t\\t\\t\\t\\tLog.closeStream();\\n\\t\\t\\t\\t\\t\\tSystem.exit(0);\\n\\t\\t}\\n\\t} \\n\\tstatic void updatePosition(String oldPath, Buffer buffer)\\n\\t{\\n\\t\\tboolean caseInsensitiveFilesystem =\\n\\t\\t\\tOperatingSystem.isDOSDerived()\\n\\t\\t\\t|| OperatingSystem.isMacOS();\\n\\t\\tif(caseInsensitiveFilesystem)\\n\\t\\t\\toldPath = oldPath.toLowerCase();\\n\\t\\tbufferHash.remove(oldPath);\\n\\t\\tString path = buffer.getPath();\\n\\t\\tif(caseInsensitiveFilesystem)\\n\\t\\t\\tpath = path.toLowerCase();\\n\\t\\tbufferHash.put(path,buffer);\\n\\t\\tif(sortBuffers)\\n\\t\\t{\\n\\t\\t\\tremoveBufferFromList(buffer);\\n\\t\\t\\taddBufferToList(buffer);\\n\\t\\t}\\n\\t} \\n\\tpublic static void addMode(Mode mode)\\n\\t{\\n\\t\\tmodes.addElement(mode);\\n\\t} \\n\\t static void loadMode(Mode mode)\\n\\t{\\n\\t\\tfinal String fileName = (String)mode.getProperty(\\\"file\\\");\\n\\t\\tLog.log(Log.NOTICE,jEdit.class,\\\"Loading edit mode \\\" + fileName);\\n\\t\\tfinal XmlParser parser = new XmlParser();\\n\\t\\tXModeHandler xmh = new XModeHandler(mode.getName())\\n\\t\\t{\\n\\t\\t\\tpublic void error(String what, Object subst)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint line = parser.getLineNumber();\\n\\t\\t\\t\\tint column = parser.getColumnNumber();\\n\\t\\t\\t\\tString msg;\\n\\t\\t\\t\\tif(subst == null)\\n\\t\\t\\t\\t\\tmsg = jEdit.getProperty(\\\"xmode-error.\\\" + what);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmsg = jEdit.getProperty(\\\"xmode-error.\\\" + what,\\n\\t\\t\\t\\t\\t\\tnew String[] { subst.toString() });\\n\\t\\t\\t\\t\\tif(subst instanceof Throwable)\\n\\t\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,subst);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tObject[] args = { fileName, new Integer(line),\\n\\t\\t\\t\\t\\tnew Integer(column), msg };\\n\\t\\t\\t\\tGUIUtilities.error(null,\\\"xmode-error\\\",args);\\n\\t\\t\\t}\\n\\t\\t\\tpublic TokenMarker getTokenMarker(String modeName)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn getMode(modeName).getTokenMarker();\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tmode.setTokenMarker(xmh.getTokenMarker());\\n\\t\\tReader grammar = null;\\n\\t\\tparser.setHandler(xmh);\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tgrammar = new BufferedReader(new FileReader(fileName));\\n\\t\\t\\tparser.parse(null, null, grammar);\\n\\t\\t\\tmode.setProperties(xmh.getModeProperties());\\n\\t\\t}\\n\\t\\tcatch (Throwable e)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.ERROR, jEdit.class, e);\\n\\t\\t\\tif (e instanceof XmlException)\\n\\t\\t\\t{\\n\\t\\t\\t\\tXmlException xe = (XmlException) e;\\n\\t\\t\\t\\tint line = xe.getLine();\\n\\t\\t\\t\\tString message = xe.getMessage();\\n\\t\\t\\t\\tObject[] args = { fileName, new Integer(line), null,\\n\\t\\t\\t\\t\\tmessage };\\n\\t\\t\\t\\tGUIUtilities.error(null,\\\"xmode-error\\\",args);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(grammar != null)\\n\\t\\t\\t\\t\\tgrammar.close();\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,jEdit.class,io);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t static void loadProps(InputStream in, boolean def)\\n\\t\\tthrows IOException\\n\\t{\\n\\t\\tif(def)\\n\\t\\t\\tdefaultProps.load(in);\\n\\t\\telse\\n\\t\\t\\tprops.load(in);\\n\\t\\tin.close();\\n\\t} \\n\\t\\t static void addProperties(Map map)\\n\\t{\\n\\t\\tIterator keys = map.keySet().iterator();\\n\\t\\twhile(keys.hasNext())\\n\\t\\t{\\n\\t\\t\\tObject key   = keys.next();\\n\\t\\t\\tObject value = map.get(key);\\n\\t\\t\\tdefaultProps.put(key,value);\\n\\t\\t}\\n\\t} \\n\\t\\tstatic void pluginError(String path, String messageProp,\\n\\t\\tObject[] args)\\n\\t{\\n\\t\\tsynchronized(pluginErrorLock)\\n\\t\\t{\\n\\t\\t\\tif(pluginErrors == null)\\n\\t\\t\\t\\tpluginErrors = new Vector();\\n\\t\\t\\tErrorListDialog.ErrorEntry newEntry =\\n\\t\\t\\t\\tnew ErrorListDialog.ErrorEntry(\\n\\t\\t\\t\\tpath,messageProp,args);\\n\\t\\t\\tfor(int i = 0; i < pluginErrors.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(pluginErrors.get(i).equals(newEntry))\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tpluginErrors.addElement(newEntry);\\n\\t\\t\\tif(startupDone)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSwingUtilities.invokeLater(new Runnable()\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tpublic void run()\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tshowPluginErrorDialog();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tstatic void setActiveView(View view)\\n\\t{\\n\\t\\tjEdit.activeView = view;\\n\\t} \\n\\t\\tprivate static String jEditHome;\\n\\tprivate static String settingsDirectory;\\n\\tprivate static String jarCacheDirectory;\\n\\tprivate static long propsModTime, recentModTime;\\n\\tprivate static Properties defaultProps;\\n\\tprivate static Properties props;\\n\\tprivate static EditServer server;\\n\\tprivate static boolean background;\\n\\tprivate static ActionContext actionContext;\\n\\tprivate static ActionSet builtInActionSet;\\n\\tprivate static Vector pluginErrors;\\n\\tprivate static Object pluginErrorLock = new Object();\\n\\tprivate static Vector jars;\\n\\tprivate static Vector modes;\\n\\tprivate static boolean saveCaret;\\n\\tprivate static InputHandler inputHandler;\\n\\tprivate static JEditMetalTheme theme;\\n\\t\\tprivate static boolean sortBuffers;\\n\\tprivate static boolean sortByName;\\n\\tprivate static int bufferCount;\\n\\tprivate static Buffer buffersFirst;\\n\\tprivate static Buffer buffersLast;\\n\\tprivate static Map bufferHash;\\n\\t\\tprivate static Object bufferListLock = new Object();\\n\\t\\tprivate static int viewCount;\\n\\tprivate static View viewsFirst;\\n\\tprivate static View viewsLast;\\n\\tprivate static View activeView;\\n\\tprivate static boolean startupDone;\\n\\tprivate static Thread mainThread;\\n\\tprivate jEdit() {}\\n\\t\\tprivate static void usage()\\n\\t{\\n\\t\\tSystem.out.println(\\\"Usage: jedit [<options>] [<files>]\\\");\\n\\t\\tSystem.out.println(\\\"\\t<file> +marker:<marker>: Positions caret\\\"\\n\\t\\t\\t+ \\\" at marker <marker>\\\");\\n\\t\\tSystem.out.println(\\\"\\t<file> +line:<line>: Positions caret\\\"\\n\\t\\t\\t+ \\\" at line number <line>\\\");\\n\\t\\tSystem.out.println(\\\"\\t--: End of options\\\");\\n\\t\\tSystem.out.println(\\\"\\t-background: Run in background mode\\\");\\n\\t\\tSystem.out.println(\\\"\\t-gui: Only if running in background mode; open initial view (default)\\\");\\n\\t\\tSystem.out.println(\\\"\\t-nogui: Only if running in background mode; don't open initial view\\\");\\n\\t\\tSystem.out.println(\\\"\\t-log=<level>: Log messages with level equal to or higher than this to\\\");\\n\\t\\tSystem.out.println(\\\"\\t standard error. <level> must be between 1 and 9. Default is 7.\\\");\\n\\t\\tSystem.out.println(\\\"\\t-newplainview: Client instance opens a new plain view\\\");\\n\\t\\tSystem.out.println(\\\"\\t-newview: Client instance opens a new view (default)\\\");\\n\\t\\tSystem.out.println(\\\"\\t-plugins: Load plugins (default)\\\");\\n\\t\\tSystem.out.println(\\\"\\t-noplugins: Don't load any plugins\\\");\\n\\t\\tSystem.out.println(\\\"\\t-restore: Restore previously open files (default)\\\");\\n\\t\\tSystem.out.println(\\\"\\t-norestore: Don't restore previously open files\\\");\\n\\t\\tSystem.out.println(\\\"\\t-reuseview: Client instance reuses existing view\\\");\\n\\t\\tSystem.out.println(\\\"\\t-quit: Quit a running instance\\\");\\n\\t\\tSystem.out.println(\\\"\\t-run=<script>: Run the specified BeanShell script\\\");\\n\\t\\tSystem.out.println(\\\"\\t-server: Read/write server info from/to $HOME/.jedit/server (default)\\\");\\n\\t\\tSystem.out.println(\\\"\\t-server=<name>: Read/write server info from/to $HOME/.jedit/<name>\\\");\\n\\t\\tSystem.out.println(\\\"\\t-noserver: Don't start edit server\\\");\\n\\t\\tSystem.out.println(\\\"\\t-settings=<path>: Load user-specific settings from <path>\\\");\\n\\t\\tSystem.out.println(\\\"\\t-nosettings: Don't load user-specific settings\\\");\\n\\t\\tSystem.out.println(\\\"\\t-startupscripts: Run startup scripts (default)\\\");\\n\\t\\tSystem.out.println(\\\"\\t-nostartupscripts: Don't run startup scripts\\\");\\n\\t\\tSystem.out.println(\\\"\\t-version: Print jEdit version and exit\\\");\\n\\t\\tSystem.out.println(\\\"\\t-usage: Print this message and exit\\\");\\n\\t\\tSystem.out.println();\\n\\t\\tSystem.out.println(\\\"Report bugs to Slava Pestov <slava@jedit.org>.\\\");\\n\\t} \\n\\t\\tprivate static void version()\\n\\t{\\n\\t\\tSystem.out.println(\\\"jEdit \\\" + getVersion());\\n\\t} \\n\\tprivate static String makeServerScript(boolean wait,\\n\\t\\tboolean restore, boolean newView,\\n\\t\\tboolean newPlainView, String[] args,\\n\\t\\tString scriptFile)\\n\\t{\\n\\t\\tStringBuffer script = new StringBuffer();\\n\\t\\tString userDir = System.getProperty(\\\"user.dir\\\");\\n\\t\\tscript.append(\\\"parent = \\\\\\\"\\\");\\n\\t\\tscript.append(MiscUtilities.charsToEscapes(userDir));\\n\\t\\tscript.append(\\\"\\\\\\\";\\\\n\\\");\\n\\t\\tscript.append(\\\"args = new String[\\\");\\n\\t\\tscript.append(args.length);\\n\\t\\tscript.append(\\\"];\\\\n\\\");\\n\\t\\tfor(int i = 0; i < args.length; i++)\\n\\t\\t{\\n\\t\\t\\tscript.append(\\\"args[\\\");\\n\\t\\t\\tscript.append(i);\\n\\t\\t\\tscript.append(\\\"] = \\\");\\n\\t\\t\\tif(args[i] == null)\\n\\t\\t\\t\\tscript.append(\\\"null\\\");\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tscript.append('\\\"');\\n\\t\\t\\t\\tscript.append(MiscUtilities.charsToEscapes(args[i]));\\n\\t\\t\\t\\tscript.append('\\\"');\\n\\t\\t\\t}\\n\\t\\t\\tscript.append(\\\";\\\\n\\\");\\n\\t\\t}\\n\\t\\tscript.append(\\\"view = jEdit.getLastView();\\\\n\\\");\\n\\t\\tscript.append(\\\"buffer = EditServer.handleClient(\\\"\\n\\t\\t\\t+ restore + \\\",\\\" + newView + \\\",\\\" + newPlainView +\\n\\t\\t\\t\\\",parent,args);\\\\n\\\");\\n\\t\\tscript.append(\\\"if(buffer != null && \\\" + wait + \\\") {\\\\n\\\");\\n\\t\\tscript.append(\\\"\\\\tbuffer.setWaitSocket(socket);\\\\n\\\");\\n\\t\\tscript.append(\\\"\\\\tdoNotCloseSocket = true;\\\\n\\\");\\n\\t\\tscript.append(\\\"}\\\\n\\\");\\n\\t\\tscript.append(\\\"if(view != jEdit.getLastView() && \\\" + wait + \\\") {\\\\n\\\");\\n\\t\\tscript.append(\\\"\\\\tjEdit.getLastView().setWaitSocket(socket);\\\\n\\\");\\n\\t\\tscript.append(\\\"\\\\tdoNotCloseSocket = true;\\\\n\\\");\\n\\t\\tscript.append(\\\"}\\\\n\\\");\\n\\t\\tscript.append(\\\"if(doNotCloseSocket == void)\\\\n\\\");\\n\\t\\tscript.append(\\\"\\\\tsocket.close();\\\\n\\\");\\n\\t\\tif(scriptFile != null)\\n\\t\\t{\\n\\t\\t\\tscriptFile = MiscUtilities.constructPath(userDir,scriptFile);\\n\\t\\t\\tscript.append(\\\"BeanShell.runScript(null,\\\\\\\"\\\"\\n\\t\\t\\t\\t+ MiscUtilities.charsToEscapes(scriptFile)\\n\\t\\t\\t\\t+ \\\"\\\\\\\",null,false);\\\\n\\\");\\n\\t\\t}\\n\\t\\treturn script.toString();\\n\\t} \\n\\tprivate static void initMisc()\\n\\t{\\n\\t\\tjars = new Vector();\\n\\t\\tactionContext = new ActionContext()\\n\\t\\t{\\n\\t\\t\\tpublic void invokeAction(EventObject evt,\\n\\t\\t\\t\\tEditAction action)\\n\\t\\t\\t{\\n\\t\\t\\t\\tView view = GUIUtilities.getView(\\n\\t\\t\\t\\t\\t(Component)evt.getSource());\\n\\t\\t\\t\\tview.getInputHandler().invokeAction(action);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tbufferHash = new HashMap();\\n\\t\\tinputHandler = new DefaultInputHandler(null);\\n\\t\\t\\t\\tSystem.getProperties().put(\\\"java.protocol.handler.pkgs\\\",\\n\\t\\t\\t\\\"org.gjt.sp.jedit.proto|\\\" +\\n\\t\\t\\tSystem.getProperty(\\\"java.protocol.handler.pkgs\\\",\\\"\\\"));\\n\\t\\t\\t\\tString userAgent = \\\"jEdit/\\\" + getVersion()\\n\\t\\t\\t+ \\\" (Java \\\" + System.getProperty(\\\"java.version\\\")\\n\\t\\t\\t+ \\\". \\\" + System.getProperty(\\\"java.vendor\\\")\\n\\t\\t\\t+ \\\"; \\\" + System.getProperty(\\\"os.arch\\\") + \\\")\\\";\\n\\t\\tSystem.getProperties().put(\\\"http.agent\\\",userAgent);\\n\\t\\tjEditHome = System.getProperty(\\\"jedit.home\\\");\\n\\t\\tif(jEditHome == null)\\n\\t\\t{\\n\\t\\t\\tString classpath = System\\n\\t\\t\\t\\t.getProperty(\\\"java.class.path\\\");\\n\\t\\t\\tint index = classpath.toLowerCase()\\n\\t\\t\\t\\t.indexOf(\\\"jedit.jar\\\");\\n\\t\\t\\tint start = classpath.lastIndexOf(File\\n\\t\\t\\t\\t.pathSeparator,index) + 1;\\n\\t\\t\\t\\t\\t\\t if(classpath.equalsIgnoreCase(\\\"jedit.jar\\\"))\\n\\t\\t\\t{\\n\\t\\t\\t\\tjEditHome = System.getProperty(\\\"user.dir\\\");\\n\\t\\t\\t}\\n\\t\\t\\telse if(index > start)\\n\\t\\t\\t{\\n\\t\\t\\t\\tjEditHome = classpath.substring(start,\\n\\t\\t\\t\\t\\tindex - 1);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tjEditHome = System.getProperty(\\\"user.dir\\\");\\n\\t\\t\\t\\t\\tLog.log(Log.WARNING,jEdit.class,\\\"jedit.jar not in class path!\\\");\\n\\t\\t\\t\\t\\tLog.log(Log.WARNING,jEdit.class,\\\"Assuming jEdit is installed in \\\"\\n\\t\\t\\t\\t\\t\\t+ jEditHome + \\\".\\\");\\n\\t\\t\\t\\t\\tLog.log(Log.WARNING,jEdit.class,\\\"Override with jedit.home \\\"\\n\\t\\t\\t\\t\\t\\t+ \\\"system property.\\\");\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tLog.log(Log.MESSAGE,jEdit.class,\\\"jEdit home directory is \\\" + jEditHome);\\n\\t\\tif(settingsDirectory != null)\\n\\t\\t{\\n\\t\\t\\tjarCacheDirectory = MiscUtilities.constructPath(\\n\\t\\t\\t\\tsettingsDirectory,\\\"jars-cache\\\");\\n\\t\\t\\tnew File(jarCacheDirectory).mkdirs();\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tEditBus.addToBus(new SettingsReloader());\\n\\t\\t\\t\\t\\t\\tSwingUtilities.invokeLater(new Runnable()\\n\\t\\t{\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\tThread.currentThread().setContextClassLoader(\\n\\t\\t\\t\\t\\tnew JARClassLoader());\\n\\t\\t\\t}\\n\\t\\t});\\n\\t} \\n\\tprivate static void initSystemProperties()\\n\\t{\\n\\t\\tdefaultProps = props = new Properties();\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tloadProps(jEdit.class.getResourceAsStream(\\n\\t\\t\\t\\t\\\"/org/gjt/sp/jedit/jedit.props\\\"),true);\\n\\t\\t\\tloadProps(jEdit.class.getResourceAsStream(\\n\\t\\t\\t\\t\\\"/org/gjt/sp/jedit/jedit_gui.props\\\"),true);\\n\\t\\t\\tloadProps(jEdit.class.getResourceAsStream(\\n\\t\\t\\t\\t\\\"/org/gjt/sp/jedit/jedit_keys.props\\\"),true);\\n\\t\\t}\\n\\t\\tcatch(Exception e)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.ERROR,jEdit.class,\\n\\t\\t\\t\\t\\\"Error while loading system properties!\\\");\\n\\t\\t\\tLog.log(Log.ERROR,jEdit.class,\\n\\t\\t\\t\\t\\\"One of the following property files could not be loaded:\\\\n\\\"\\n\\t\\t\\t\\t+ \\\"- jedit.props\\\\n\\\"\\n\\t\\t\\t\\t+ \\\"- jedit_gui.props\\\\n\\\"\\n\\t\\t\\t\\t+ \\\"- jedit_keys.props\\\\n\\\"\\n\\t\\t\\t\\t+ \\\"jedit.jar is probably corrupt.\\\");\\n\\t\\t\\tLog.log(Log.ERROR,jEdit.class,e);\\n\\t\\t\\tSystem.exit(1);\\n\\t\\t}\\n\\t} \\n\\tprivate static void initSiteProperties()\\n\\t{\\n\\t\\tString siteSettingsDirectory = MiscUtilities.constructPath(\\n\\t\\t\\tjEditHome, \\\"properties\\\");\\n\\t\\tFile siteSettings = new File(siteSettingsDirectory);\\n\\t\\tif (!(siteSettings.exists() && siteSettings.isDirectory()))\\n\\t\\t\\treturn;\\n\\t\\tString[] snippets = siteSettings.list();\\n\\t\\tif (snippets == null)\\n\\t\\t\\treturn;\\n\\t\\tMiscUtilities.quicksort(snippets,\\n\\t\\t\\tnew MiscUtilities.StringICaseCompare());\\n\\t\\tfor (int i = 0; i < snippets.length; ++i)\\n\\t\\t{\\n\\t\\t\\tString snippet = snippets[i];\\n\\t\\t\\tif(!snippet.toLowerCase().endsWith(\\\".props\\\"))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tString path = MiscUtilities.constructPath(\\n\\t\\t\\t\\t\\tsiteSettingsDirectory,snippet);\\n\\t\\t\\t\\tLog.log(Log.DEBUG,jEdit.class,\\n\\t\\t\\t\\t\\t\\\"Loading site snippet: \\\" + path);\\n\\t\\t\\t\\tloadProps(new FileInputStream(new File(path)),true);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(FileNotFoundException fnf)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,jEdit.class,fnf);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException e)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,jEdit.class,\\\"Cannot load site snippet \\\"\\n\\t\\t\\t\\t\\t+ snippet);\\n\\t\\t\\t\\tLog.log(Log.ERROR,jEdit.class,e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate static void initResources()\\n\\t{\\n\\t\\tbuiltInActionSet = new ActionSet(null,null,null,\\n\\t\\t\\tjEdit.class.getResource(\\\"actions.xml\\\"));\\n\\t\\tbuiltInActionSet.setLabel(getProperty(\\\"action-set.jEdit\\\"));\\n\\t\\tbuiltInActionSet.load();\\n\\t\\tactionContext.addActionSet(builtInActionSet);\\n\\t\\tDockableWindowManager.loadDockableWindows(null,\\n\\t\\t\\tjEdit.class.getResource(\\\"dockables.xml\\\"),\\n\\t\\t\\tnull);\\n\\t\\tServiceManager.loadServices(null,\\n\\t\\t\\tjEdit.class.getResource(\\\"services.xml\\\"),\\n\\t\\t\\tnull);\\n\\t} \\n\\tprivate static void initPlugins()\\n\\t{\\n\\t\\tif(jEditHome != null)\\n\\t\\t{\\n\\t\\t\\taddPluginJARsFromDirectory(MiscUtilities.constructPath(\\n\\t\\t\\t\\tjEditHome,\\\"jars\\\"));\\n\\t\\t}\\n\\t\\tif(settingsDirectory != null)\\n\\t\\t{\\n\\t\\t\\tFile jarsDirectory = new File(settingsDirectory,\\\"jars\\\");\\n\\t\\t\\tif(!jarsDirectory.exists())\\n\\t\\t\\t\\tjarsDirectory.mkdir();\\n\\t\\t\\taddPluginJARsFromDirectory(jarsDirectory.getPath());\\n\\t\\t}\\n\\t\\tPluginJAR[] jars = getPluginJARs();\\n\\t\\tfor(int i = 0; i < jars.length; i++)\\n\\t\\t{\\n\\t\\t\\tjars[i].checkDependencies();\\n\\t\\t}\\n\\t} \\n\\tprivate static void initUserProperties()\\n\\t{\\n\\t\\tprops = new Properties(defaultProps);\\n\\t\\tif(settingsDirectory != null)\\n\\t\\t{\\n\\t\\t\\tFile file = new File(MiscUtilities.constructPath(\\n\\t\\t\\t\\tsettingsDirectory,\\\"properties\\\"));\\n\\t\\t\\tpropsModTime = file.lastModified();\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tloadProps(new FileInputStream(file),false);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(FileNotFoundException fnf)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\tcatch(IOException e)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,jEdit.class,e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tprivate static void initPLAF()\\n\\t{\\n\\t\\ttheme = new JEditMetalTheme();\\n\\t\\ttheme.propertiesChanged();\\n\\t\\tMetalLookAndFeel.setCurrentTheme(theme);\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tString lf = getProperty(\\\"lookAndFeel\\\");\\n\\t\\t\\tif(lf != null && lf.length() != 0)\\n\\t\\t\\t\\tUIManager.setLookAndFeel(lf);\\n\\t\\t}\\n\\t\\tcatch(Exception e)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.ERROR,jEdit.class,e);\\n\\t\\t}\\n\\t\\tUIDefaults defaults = UIManager.getDefaults();\\n\\t\\t\\t\\tif(jEdit.getBooleanProperty(\\\"textColors\\\"))\\n\\t\\t{\\n\\t\\t\\tColor background = new javax.swing.plaf.ColorUIResource(\\n\\t\\t\\t\\tjEdit.getColorProperty(\\\"view.bgColor\\\"));\\n\\t\\t\\tColor foreground = new javax.swing.plaf.ColorUIResource(\\n\\t\\t\\t\\tjEdit.getColorProperty(\\\"view.fgColor\\\"));\\n\\t\\t\\tColor caretColor = new javax.swing.plaf.ColorUIResource(\\n\\t\\t\\t\\tjEdit.getColorProperty(\\\"view.caretColor\\\"));\\n\\t\\t\\tColor selectionColor = new javax.swing.plaf.ColorUIResource(\\n\\t\\t\\t\\tjEdit.getColorProperty(\\\"view.selectionColor\\\"));\\n\\t\\t\\tString[] prefixes = { \\\"TextField\\\", \\\"TextArea\\\", \\\"List\\\", \\\"Table\\\" };\\n\\t\\t\\tfor(int i = 0; i < prefixes.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tString prefix = prefixes[i];\\n\\t\\t\\t\\tdefaults.put(prefix + \\\".disabledBackground\\\",background);\\n\\t\\t\\t\\tdefaults.put(prefix + \\\".background\\\",background);\\n\\t\\t\\t\\tdefaults.put(prefix + \\\".disabledForeground\\\",foreground);\\n\\t\\t\\t\\tdefaults.put(prefix + \\\".foreground\\\",foreground);\\n\\t\\t\\t\\tdefaults.put(prefix + \\\".caretForeground\\\",caretColor);\\n\\t\\t\\t\\tdefaults.put(prefix + \\\".selectionForeground\\\",foreground);\\n\\t\\t\\t\\tdefaults.put(prefix + \\\".selectionBackground\\\",selectionColor);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\tdefaults.put(\\\"Tree.background\\\",background);\\n\\t\\t\\tdefaults.put(\\\"Tree.foreground\\\",foreground);\\n\\t\\t\\tdefaults.put(\\\"Tree.textBackground\\\",background);\\n\\t\\t\\tdefaults.put(\\\"Tree.textForeground\\\",foreground);\\n\\t\\t\\tdefaults.put(\\\"Tree.selectionForeground\\\",foreground);\\n\\t\\t\\tdefaults.put(\\\"Tree.selectionBackground\\\",selectionColor);\\n\\t\\t}\\n\\t\\tdefaults.remove(\\\"SplitPane.border\\\");\\n\\t\\tdefaults.remove(\\\"SplitPaneDivider.border\\\");\\n\\t} \\n\\tprivate static void runStartupScripts(File directory)\\n\\t{\\n\\t\\tif (!directory.isDirectory())\\n\\t\\t\\treturn;\\n\\t\\tFile[] snippets = directory.listFiles();\\n\\t\\tif (snippets == null)\\n\\t\\t\\treturn;\\n\\t\\tMiscUtilities.quicksort(snippets,\\n\\t\\t\\tnew MiscUtilities.StringICaseCompare());\\n\\t\\tfor(int i = 0; i < snippets.length; ++i)\\n\\t\\t{\\n\\t\\t\\tFile snippet = snippets[i];\\n\\t\\t\\tMacros.Handler handler = Macros.getHandlerForPathName(\\n\\t\\t\\t\\tsnippet.getPath());\\n\\t\\t\\tif(handler == null)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tMacros.Macro newMacro = handler.createMacro(\\n\\t\\t\\t\\t\\tsnippet.getName(),\\n\\t\\t\\t\\t\\tsnippet.getPath());\\n\\t\\t\\t\\thandler.runMacro(null,newMacro,false);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Exception e)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,jEdit.class,e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate static void initProxy()\\n\\t{\\n\\t\\tboolean socksEnabled = jEdit.getBooleanProperty(\\\"socks.enabled\\\");\\n\\t\\tif(!socksEnabled)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,jEdit.class,\\\"SOCKS proxy disabled\\\");\\n                        System.getProperties().remove(\\\"socksProxyHost\\\");\\n                        System.getProperties().remove(\\\"socksProxyPort\\\");\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString socksHost = jEdit.getProperty(\\\"firewall.socks.host\\\");\\n\\t\\t\\tif( socksHost != null )\\n\\t\\t\\t{\\n\\t\\t\\t\\tSystem.setProperty(\\\"socksProxyHost\\\", socksHost);\\n\\t\\t\\t\\tLog.log(Log.DEBUG, jEdit.class,\\n\\t\\t\\t\\t\\t\\\"SOCKS proxy enabled: \\\" + socksHost);\\n                        }\\n\\t\\t\\tString socksPort =  jEdit.getProperty(\\\"firewall.socks.port\\\");\\n\\t\\t\\tif(socksPort != null)\\n\\t\\t\\t\\tSystem.setProperty(\\\"socksProxyPort\\\", socksPort);\\n\\t\\t}\\n\\t\\tboolean httpEnabled = jEdit.getBooleanProperty(\\\"firewall.enabled\\\");\\n\\t\\tif (!httpEnabled)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG, jEdit.class, \\\"HTTP proxy disabled\\\");\\n\\t\\t\\tSystem.getProperties().remove(\\\"proxySet\\\");\\n\\t\\t\\tSystem.getProperties().remove(\\\"proxyHost\\\");\\n\\t\\t\\tSystem.getProperties().remove(\\\"proxyPort\\\");\\n\\t\\t\\tSystem.getProperties().remove(\\\"http.proxyHost\\\");\\n\\t\\t\\tSystem.getProperties().remove(\\\"http.proxyPort\\\");\\n\\t\\t\\tSystem.getProperties().remove(\\\"http.nonProxyHosts\\\");\\n\\t\\t\\tAuthenticator.setDefault(null);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tString host = jEdit.getProperty(\\\"firewall.host\\\");\\n\\t\\t\\tif (host == null)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tSystem.setProperty(\\\"http.proxyHost\\\", host);\\n\\t\\t\\tLog.log(Log.DEBUG, jEdit.class, \\\"HTTP proxy enabled: \\\" + host);\\n\\t\\t\\t\\t\\t\\tString port = jEdit.getProperty(\\\"firewall.port\\\");\\n\\t\\t\\tif (port != null)\\n\\t\\t\\t\\tSystem.setProperty(\\\"http.proxyPort\\\", port);\\n\\t\\t\\t\\t\\t\\tString nonProxyHosts = jEdit.getProperty(\\\"firewall.nonProxyHosts\\\");\\n\\t\\t\\tif (nonProxyHosts != null)\\n\\t\\t\\t\\tSystem.setProperty(\\\"http.nonProxyHosts\\\", nonProxyHosts);\\n\\t\\t\\t\\t\\t\\tString username = jEdit.getProperty(\\\"firewall.user\\\");\\n\\t\\t\\tString password = jEdit.getProperty(\\\"firewall.password\\\");\\n\\t\\t\\t\\t\\t\\tif(password == null)\\n\\t\\t\\t\\tpassword = \\\"\\\";\\n\\t\\t\\tif(username == null || username.length()==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG, jEdit.class, \\\"HTTP proxy without user\\\");\\n\\t\\t\\t\\tAuthenticator.setDefault(new FirewallAuthenticator(null));\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG, jEdit.class, \\\"HTTP proxy user: \\\" + username);\\n\\t\\t\\t\\tPasswordAuthentication pw = new PasswordAuthentication(\\n\\t\\t\\t\\t\\tusername,password.toCharArray()\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\tAuthenticator.setDefault(new FirewallAuthenticator(pw));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tstatic class FirewallAuthenticator extends Authenticator\\n\\t{\\n\\t\\tPasswordAuthentication pw;\\n\\t\\tpublic FirewallAuthenticator(PasswordAuthentication pw)\\n\\t\\t{\\n\\t\\t\\tthis.pw = pw;\\n\\t\\t}\\n\\t\\tprotected PasswordAuthentication getPasswordAuthentication()\\n\\t\\t{\\n\\t\\t\\treturn pw;\\n\\t\\t}\\n\\t} \\n\\t\\tprivate static void finishStartup(final boolean gui, final boolean restore,\\n\\t\\tfinal String userDir, final String[] args)\\n\\t{\\n\\t\\tSwingUtilities.invokeLater(new Runnable() {\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\tBuffer buffer = openFiles(null,userDir,args);\\n\\t\\t\\t\\tView view = null;\\n\\t\\t\\t\\tboolean restoreFiles = restore\\n\\t\\t\\t\\t\\t&& jEdit.getBooleanProperty(\\\"restore\\\")\\n\\t\\t\\t\\t\\t&& (getBufferCount() == 0\\n\\t\\t\\t\\t\\t|| jEdit.getBooleanProperty(\\\"restore.cli\\\"));\\n\\t\\t\\t\\tif(gui || getBufferCount() != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tview = PerspectiveManager.loadPerspective(restoreFiles);\\n\\t\\t\\t\\t\\tif(getBufferCount() == 0)\\n\\t\\t\\t\\t\\t\\tbuffer = newFile(null);\\n\\t\\t\\t\\t\\tif(view == null)\\n\\t\\t\\t\\t\\t\\tview = newView(null,buffer);\\n\\t\\t\\t\\t\\telse if(buffer != null)\\n\\t\\t\\t\\t\\t\\tview.setBuffer(buffer);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\tEditBus.send(new EditorStarted(null));\\n\\t\\t\\t\\tVFSManager.start();\\n\\t\\t\\t\\t\\t\\t\\t\\tif(server != null)\\n\\t\\t\\t\\t\\tserver.start();\\n\\t\\t\\t\\tGUIUtilities.hideSplashScreen();\\n\\t\\t\\t\\tLog.log(Log.MESSAGE,jEdit.class,\\\"Startup \\\"\\n\\t\\t\\t\\t\\t+ \\\"complete\\\");\\n\\t\\t\\t\\t\\t\\t\\t\\tif(pluginErrors != null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tshowPluginErrorDialog();\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tstartupDone = true;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tToolkit.getDefaultToolkit();\\n\\t\\t\\t}\\n\\t\\t});\\n\\t} \\n\\t\\tprivate static void showPluginErrorDialog()\\n\\t{\\n\\t\\tif(pluginErrors == null)\\n\\t\\t\\treturn;\\n\\t\\tString caption = getProperty(\\n\\t\\t\\t\\\"plugin-error.caption\\\" + (pluginErrors.size() == 1\\n\\t\\t\\t? \\\"-1\\\" : \\\"\\\"));\\n\\t\\tFrame frame = (PluginManager.getInstance() == null\\n\\t\\t\\t? (Frame)viewsFirst\\n\\t\\t\\t: (Frame)PluginManager.getInstance());\\n\\t\\tnew ErrorListDialog(frame,\\n\\t\\t\\tgetProperty(\\\"plugin-error.title\\\"),\\n\\t\\t\\tcaption,pluginErrors,true);\\n\\t\\tpluginErrors = null;\\n\\t} \\n\\t\\tprivate static void getNotLoadedPluginJARs(Vector returnValue,\\n\\t\\tString dir, String[] list)\\n\\t{\\nloop:\\t\\tfor(int i = 0; i < list.length; i++)\\n\\t\\t{\\n\\t\\t\\tString name = list[i];\\n\\t\\t\\tif(!name.toLowerCase().endsWith(\\\".jar\\\"))\\n\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\tString path = MiscUtilities.constructPath(dir,name);\\n\\t\\t\\tfor(int j = 0; j < jars.size(); j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tPluginJAR jar = (PluginJAR)\\n\\t\\t\\t\\t\\tjars.elementAt(j);\\n\\t\\t\\t\\tString jarPath = jar.getPath();\\n\\t\\t\\t\\tString jarName = MiscUtilities.getFileName(jarPath);\\n\\t\\t\\t\\tif(path.equals(jarPath))\\n\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\telse if(!new File(jarPath).exists()\\n\\t\\t\\t\\t\\t&& name.equals(jarName))\\n\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t}\\n\\t\\t\\treturnValue.addElement(path);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate static void gotoMarker(final View view, final Buffer buffer,\\n\\t\\tfinal String marker)\\n\\t{\\n\\t\\tVFSManager.runInAWTThread(new Runnable()\\n\\t\\t{\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\tint pos;\\n\\t\\t\\t\\t\\t\\t\\t\\tif(marker.startsWith(\\\"+line:\\\"))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttry\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint line = Integer.parseInt(marker.substring(6));\\n\\t\\t\\t\\t\\t\\tpos = buffer.getLineStartOffset(line - 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcatch(Exception e)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\telse if(marker.startsWith(\\\"+marker:\\\"))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(marker.length() != 9)\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\tMarker m = buffer.getMarker(marker.charAt(8));\\n\\t\\t\\t\\t\\tif(m == null)\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\tpos = m.getPosition();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tthrow new InternalError();\\n\\t\\t\\t\\tif(view != null && view.getBuffer() == buffer)\\n\\t\\t\\t\\t\\tview.getTextArea().setCaretPosition(pos);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbuffer.setIntegerProperty(Buffer.CARET,pos);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t} \\n\\t\\tprivate static void addBufferToList(Buffer buffer)\\n\\t{\\n\\t\\tsynchronized(bufferListLock)\\n\\t\\t{\\n\\t\\t\\tboolean caseInsensitiveFilesystem =\\n\\t\\t\\t\\tOperatingSystem.isDOSDerived()\\n\\t\\t\\t\\t|| OperatingSystem.isMacOS();\\n\\t\\t\\tString path = buffer.getPath();\\n\\t\\t\\tif(caseInsensitiveFilesystem)\\n\\t\\t\\t\\tpath = path.toLowerCase();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(viewCount <= 1 && buffersFirst != null\\n\\t\\t\\t\\t&& buffersFirst == buffersLast\\n\\t\\t\\t\\t&& buffersFirst.isUntitled()\\n\\t\\t\\t\\t&& !buffersFirst.isDirty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tBuffer oldBuffersFirst = buffersFirst;\\n\\t\\t\\t\\tbuffersFirst = buffersLast = buffer;\\n\\t\\t\\t\\tDisplayManager.bufferClosed(oldBuffersFirst);\\n\\t\\t\\t\\tEditBus.send(new BufferUpdate(oldBuffersFirst,null,\\n\\t\\t\\t\\t\\tBufferUpdate.CLOSED));\\n\\t\\t\\t\\tbufferHash.clear();\\n\\t\\t\\t\\tbufferHash.put(path,buffer);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tbufferCount++;\\n\\t\\t\\tbufferHash.put(path,buffer);\\n\\t\\t\\tif(buffersFirst == null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffersFirst = buffersLast = buffer;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if(sortBuffers)\\n\\t\\t\\t{\\n\\t\\t\\t\\tString str11, str12;\\n\\t\\t\\t\\tif(sortByName)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstr11 = buffer.getName();\\n\\t\\t\\t\\t\\tstr12 = buffer.getDirectory();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstr11 = buffer.getDirectory();\\n\\t\\t\\t\\t\\tstr12 = buffer.getName();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tBuffer _buffer = buffersFirst;\\n\\t\\t\\t\\twhile(_buffer != null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tString str21, str22;\\n\\t\\t\\t\\t\\tif(sortByName)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tstr21 = _buffer.getName();\\n\\t\\t\\t\\t\\t\\tstr22 = _buffer.getDirectory();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tstr21 = _buffer.getDirectory();\\n\\t\\t\\t\\t\\t\\tstr22 = _buffer.getName();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tint comp = MiscUtilities.compareStrings(str11,str21,true);\\n\\t\\t\\t\\t\\tif(comp < 0 || (comp == 0 && MiscUtilities.compareStrings(str12,str22,true) < 0))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.next = _buffer;\\n\\t\\t\\t\\t\\t\\tbuffer.prev = _buffer.prev;\\n\\t\\t\\t\\t\\t\\t_buffer.prev = buffer;\\n\\t\\t\\t\\t\\t\\tif(_buffer != buffersFirst)\\n\\t\\t\\t\\t\\t\\t\\tbuffer.prev.next = buffer;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tbuffersFirst = buffer;\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t_buffer = _buffer.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\tbuffer.prev = buffersLast;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbuffer.next = null;\\n\\t\\t\\tbuffersLast.next = buffer;\\n\\t\\t\\tbuffersLast = buffer;\\n\\t\\t}\\n\\t} \\n\\t\\tprivate static void removeBufferFromList(Buffer buffer)\\n\\t{\\n\\t\\tsynchronized(bufferListLock)\\n\\t\\t{\\n\\t\\t\\tbufferCount--;\\n\\t\\t\\tboolean caseInsensitiveFilesystem =\\n\\t\\t\\t\\tOperatingSystem.isDOSDerived()\\n\\t\\t\\t\\t|| OperatingSystem.isMacOS();\\n\\t\\t\\tString path = buffer.getPath();\\n\\t\\t\\tif(caseInsensitiveFilesystem)\\n\\t\\t\\t\\tpath = path.toLowerCase();\\n\\t\\t\\tbufferHash.remove(path);\\n\\t\\t\\tif(buffer == buffersFirst && buffer == buffersLast)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffersFirst = buffersLast = null;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(buffer == buffersFirst)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffersFirst = buffer.next;\\n\\t\\t\\t\\tbuffer.next.prev = null;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.prev.next = buffer.next;\\n\\t\\t\\t}\\n\\t\\t\\tif(buffer == buffersLast)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffersLast = buffersLast.prev;\\n\\t\\t\\t\\tbuffer.prev.next = null;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.next.prev = buffer.prev;\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbuffer.next = buffer.prev = null;\\n\\t\\t}\\n\\t} \\n\\t\\tprivate static void addViewToList(View view)\\n\\t{\\n\\t\\tviewCount++;\\n\\t\\tif(viewsFirst == null)\\n\\t\\t\\tviewsFirst = viewsLast = view;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tview.prev = viewsLast;\\n\\t\\t\\tviewsLast.next = view;\\n\\t\\t\\tviewsLast = view;\\n\\t\\t}\\n\\t} \\n\\t\\tprivate static void removeViewFromList(View view)\\n\\t{\\n\\t\\tviewCount--;\\n\\t\\tif(viewsFirst == viewsLast)\\n\\t\\t{\\n\\t\\t\\tviewsFirst = viewsLast = null;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(view == viewsFirst)\\n\\t\\t{\\n\\t\\t\\tviewsFirst = view.next;\\n\\t\\t\\tview.next.prev = null;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tview.prev.next = view.next;\\n\\t\\t}\\n\\t\\tif(view == viewsLast)\\n\\t\\t{\\n\\t\\t\\tviewsLast = viewsLast.prev;\\n\\t\\t\\tview.prev.next = null;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tview.next.prev = view.prev;\\n\\t\\t}\\n\\t} \\n\\tprivate static void closeView(View view, boolean callExit)\\n\\t{\\n\\t\\tif(viewsFirst == viewsLast && callExit)\\n\\t\\t\\texit(view,false); \\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tEditBus.send(new ViewUpdate(view,ViewUpdate.CLOSED));\\n\\t\\t\\tview.close();\\n\\t\\t\\tremoveViewFromList(view);\\n\\t\\t\\tif(view == activeView)\\n\\t\\t\\t\\tactiveView = null;\\n\\t\\t}\\n\\t} \\n\\tprivate static void loadModeCatalog(String path, boolean resource)\\n\\t{\\n\\t\\tLog.log(Log.MESSAGE,jEdit.class,\\\"Loading mode catalog file \\\" + path);\\n\\t\\tModeCatalogHandler handler = new ModeCatalogHandler(\\n\\t\\t\\tMiscUtilities.getParentOfPath(path),resource);\\n\\t\\tXmlParser parser = new XmlParser();\\n\\t\\tparser.setHandler(handler);\\n\\t\\tReader in = null;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tInputStream _in;\\n\\t\\t\\tif(resource)\\n\\t\\t\\t\\t_in = jEdit.class.getResourceAsStream(path);\\n\\t\\t\\telse\\n\\t\\t\\t\\t_in = new FileInputStream(path);\\n\\t\\t\\tin = new BufferedReader(new InputStreamReader(_in));\\n\\t\\t\\tparser.parse(null, null, in);\\n\\t\\t}\\n\\t\\tcatch(XmlException xe)\\n\\t\\t{\\n\\t\\t\\tint line = xe.getLine();\\n\\t\\t\\tString message = xe.getMessage();\\n\\t\\t\\tLog.log(Log.ERROR,jEdit.class,path + \\\":\\\" + line\\n\\t\\t\\t\\t+ \\\": \\\" + message);\\n\\t\\t}\\n\\t\\tcatch(Exception e)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.ERROR,jEdit.class,e);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(in != null)\\n\\t\\t\\t\\t\\tin.close();\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,jEdit.class,io);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tprivate static void initKeyBindings()\\n\\t{\\n\\t\\tinputHandler.removeAllKeyBindings();\\n\\t\\tActionSet[] actionSets = getActionSets();\\n\\t\\tfor(int i = 0; i < actionSets.length; i++)\\n\\t\\t{\\n\\t\\t\\tactionSets[i].initKeyBindings();\\n\\t\\t}\\n\\t} \\n\\t}\""
        },
        {
            "content": "The source code of `jEdit.java` reveals that it is the core class of the jEdit editor, responsible for managing:\n\n- Application lifecycle (startup/shutdown)\n- Plugin management (`PluginManager`, `PluginJAR`)\n- Buffer and view management (`Buffer`, `View`, `EditPane`)\n- Input handling (`InputHandler`)\n- Properties and settings\n- GUI initialization and configuration\n- Mode loading and syntax highlighting\n- Event bus communication (`EditBus`)\n- Dockable window and action management\n\nIt does **not** directly reference `JEditTextArea.java` in its import or direct usage. This confirms earlier findings: there's **no explicit static coupling**, but the **conceptual coupling is high**, suggesting an indirect relationship likely through:\n\n- The event system (`EditBus`)\n- Dynamic dispatch via plugins or actions\n- GUI layout managed elsewhere (e.g., `EditPane`, `View`, or `DockableWindowManager`)\n- Runtime interactions not visible in static analysis\n\n### Next Steps:\nTo better understand how `jEdit.java` might indirectly interact with `JEditTextArea.java`, let\u2019s analyze the call graph of another strongly co-changed entity: `Buffer.java`. It appears in both the co-change list and is used heavily by `jEdit.java`.\n\nWe\u2019ll retrieve the **call graph** of `Buffer.java` to see if it has a direct or indirect connection to `JEditTextArea.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_4ffe98fa0ea646f1acee9b",
                    "function": {
                        "arguments": "{\"entity\": \"Buffer.java\"}",
                        "name": "get_call_graph"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_call_graph",
            "content": "[\"RESearchMatcher\", \"VFSBrowser\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]"
        },
        {
            "content": "The call graph for `Buffer.java` appears to include only a few direct dependencies:\n\n- `RESearchMatcher`\n- `VFSBrowser`\n\nThis list is sparse and doesn't provide strong evidence of a direct link to `JEditTextArea.java`. This suggests that even if `Buffer.java` interacts with `JEditTextArea.java`, it's likely done **indirectly**, possibly through the event system, GUI components like `EditPane`, or via dynamic binding.\n\n### Observations So Far:\n- `jEdit.java` and `JEditTextArea.java` show **strong conceptual coupling** (0.8465), but **no direct code-level dependencies**.\n- `jEdit.java` does not reference `JEditTextArea.java` directly in imports or method calls.\n- `Buffer.java`, which is heavily used by `jEdit.java`, also has no clear direct connection to `JEditTextArea.java`.\n- The coupling seems **indirect**, possibly through:\n  - Event-based communication (`EditBus`)\n  - GUI component hierarchy (`EditPane`, `View`, etc.)\n  - Plugin or action systems\n\n### Next Step:\nLet\u2019s inspect the source code of `JEditTextArea.java` to see what kind of functionality it provides and whether there are any indirect references back to `jEdit.java` or shared structures like `Buffer`, `View`, or `EditBus`.\n\nI'll retrieve the origin code for `JEditTextArea.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_f87da11c81fd4c7494c6df",
                    "function": {
                        "arguments": "{\"entity\": \"JEditTextArea.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package org.gjt.sp.jedit.textarea;\\nimport java.awt.*;\\nimport java.awt.event.*;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Enumeration;\\nimport java.util.Hashtable;\\nimport java.util.Vector;\\nimport javax.swing.*;\\nimport javax.swing.border.*;\\nimport javax.swing.event.*;\\nimport javax.swing.plaf.metal.MetalLookAndFeel;\\nimport javax.swing.text.Position;\\nimport javax.swing.text.Segment;\\nimport org.gjt.sp.jedit.*;\\nimport org.gjt.sp.jedit.buffer.*;\\nimport org.gjt.sp.jedit.gui.*;\\nimport org.gjt.sp.jedit.syntax.*;\\nimport org.gjt.sp.util.Log;\\npublic class JEditTextArea extends JComponent\\n{\\n\\tpublic JEditTextArea(View view)\\n\\t{\\n\\t\\tenableEvents(AWTEvent.FOCUS_EVENT_MASK | AWTEvent.KEY_EVENT_MASK);\\n\\t\\tthis.view = view;\\n\\t\\t\\t\\tselection = new Vector();\\n\\t\\tchunkCache = new ChunkCache(this);\\n\\t\\tpainter = new TextAreaPainter(this);\\n\\t\\tgutter = new Gutter(view,this);\\n\\t\\tbufferHandler = new BufferChangeHandler();\\n\\t\\tlistenerList = new EventListenerList();\\n\\t\\tcaretEvent = new MutableCaretEvent();\\n\\t\\tbracketLine = bracketPosition = -1;\\n\\t\\tblink = true;\\n\\t\\tlineSegment = new Segment();\\n\\t\\treturnValue = new Point();\\n\\t\\trunnables = new ArrayList();\\n\\t\\t\\t\\tsetLayout(new ScrollLayout());\\n\\t\\tadd(LEFT,gutter);\\n\\t\\tadd(CENTER,painter);\\n\\t\\t\\t\\tverticalBox = new Box(BoxLayout.X_AXIS);\\n\\t\\tverticalBox.add(vertical = new JScrollBar(JScrollBar.VERTICAL));\\n\\t\\tadd(RIGHT,verticalBox);\\n\\t\\tadd(BOTTOM,horizontal = new JScrollBar(JScrollBar.HORIZONTAL));\\n\\t\\thorizontal.setValues(0,0,0,0);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(UIManager.getLookAndFeel() instanceof MetalLookAndFeel)\\n\\t\\t{\\n\\t\\t\\tsetBorder(new TextAreaBorder());\\n\\t\\t\\tvertical.putClientProperty(\\\"JScrollBar.isFreeStanding\\\",\\n\\t\\t\\t\\tBoolean.FALSE);\\n\\t\\t\\thorizontal.putClientProperty(\\\"JScrollBar.isFreeStanding\\\",\\n\\t\\t\\t\\tBoolean.FALSE);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\tvertical.addAdjustmentListener(new AdjustHandler());\\n\\t\\thorizontal.addAdjustmentListener(new AdjustHandler());\\n\\t\\tmouseHandler = new MouseHandler();\\n\\t\\tpainter.addMouseListener(mouseHandler);\\n\\t\\tpainter.addMouseMotionListener(mouseHandler);\\n\\t\\taddFocusListener(new FocusHandler());\\n\\t\\t\\t\\t\\t\\t\\t\\tfocusedComponent = this;\\n\\t} \\n\\tpublic void dispose()\\n\\t{\\n\\t\\tDisplayManager.textAreaDisposed(this);\\n\\t} \\n\\tpublic final TextAreaPainter getPainter()\\n\\t{\\n\\t\\treturn painter;\\n\\t} \\n\\tpublic final Gutter getGutter()\\n\\t{\\n\\t\\treturn gutter;\\n\\t} \\n\\tpublic DisplayManager getDisplayManager()\\n\\t{\\n\\t\\treturn displayManager;\\n\\t} \\n\\tpublic final boolean isCaretBlinkEnabled()\\n\\t{\\n\\t\\treturn caretBlinks;\\n\\t} \\n\\tpublic void setCaretBlinkEnabled(boolean caretBlinks)\\n\\t{\\n\\t\\tthis.caretBlinks = caretBlinks;\\n\\t\\tif(!caretBlinks)\\n\\t\\t\\tblink = false;\\n\\t\\tif(buffer != null)\\n\\t\\t\\tinvalidateLine(caretLine);\\n\\t} \\n\\tpublic final int getElectricScroll()\\n\\t{\\n\\t\\treturn electricScroll;\\n\\t} \\n\\tpublic final void setElectricScroll(int electricScroll)\\n\\t{\\n\\t\\tthis.electricScroll = electricScroll;\\n\\t} \\n\\tpublic final boolean isQuickCopyEnabled()\\n\\t{\\n\\t\\treturn quickCopy;\\n\\t} \\n\\tpublic final void setQuickCopyEnabled(boolean quickCopy)\\n\\t{\\n\\t\\tthis.quickCopy = quickCopy;\\n\\t} \\n\\tpublic final Buffer getBuffer()\\n\\t{\\n\\t\\treturn buffer;\\n\\t} \\n\\tpublic void setBuffer(Buffer buffer)\\n\\t{\\n\\t\\tif(this.buffer == buffer)\\n\\t\\t\\treturn;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbufferChanging = true;\\n\\t\\t\\tif(this.buffer != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\t\\tcaretLine = caret = caretScreenLine = 0;\\n\\t\\t\\t\\tbracketLine = bracketPosition = -1;\\n\\t\\t\\t\\tthis.buffer.removeBufferChangeListener(bufferHandler);\\n\\t\\t\\t}\\n\\t\\t\\tthis.buffer = buffer;\\n\\t\\t\\tbuffer.addBufferChangeListener(bufferHandler);\\n\\t\\t\\tbufferHandlerInstalled = true;\\n\\t\\t\\tchunkCache.setBuffer(buffer);\\n\\t\\t\\tpropertiesChanged();\\n\\t\\t\\tif(displayManager != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tDisplayManager.releaseDisplayManager(\\n\\t\\t\\t\\t\\tdisplayManager);\\n\\t\\t\\t}\\n\\t\\t\\tdisplayManager = DisplayManager.getDisplayManager(\\n\\t\\t\\t\\tbuffer,this);\\n\\t\\t\\tdisplayManager.init();\\n\\t\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\t\\trepaint();\\n\\t\\t\\tfireScrollEvent(true);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbufferChanging = false;\\n\\t\\t}\\n\\t} \\n\\tpublic final boolean isEditable()\\n\\t{\\n\\t\\treturn buffer.isEditable();\\n\\t} \\n\\tpublic final JPopupMenu getRightClickPopup()\\n\\t{\\n\\t\\treturn popup;\\n\\t} \\n\\tpublic final void setRightClickPopup(JPopupMenu popup)\\n\\t{\\n\\t\\tthis.popup = popup;\\n\\t} \\n\\tpublic final int getFirstLine()\\n\\t{\\n\\t\\treturn displayManager.firstLine.scrollLine\\n\\t\\t\\t+ displayManager.firstLine.skew;\\n\\t} \\n\\t\\tpublic Exception trace;\\n\\tpublic void setFirstLine(int firstLine)\\n\\t{\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"setFirstLine() from \\\"\\n\\t\\t\\t\\t+ getFirstLine() + \\\" to \\\" + firstLine);\\n\\t\\t}\\n\\t\\t\\t\\tint max = displayManager.getScrollLineCount() - visibleLines\\n\\t\\t\\t+ (lastLinePartial ? 1 : 0);\\n\\t\\tif(firstLine > max)\\n\\t\\t\\tfirstLine = max;\\n\\t\\tif(firstLine < 0)\\n\\t\\t\\tfirstLine = 0;\\n\\t\\tint oldFirstLine = getFirstLine();\\n\\t\\tif(firstLine == oldFirstLine)\\n\\t\\t\\treturn;\\n\\t\\ttrace = new Exception();\\n\\t\\tif(firstLine >= oldFirstLine + visibleLines)\\n\\t\\t{\\n\\t\\t\\tdisplayManager.firstLine.scrollDown(firstLine - oldFirstLine);\\n\\t\\t\\tchunkCache.invalidateAll();\\n\\t\\t}\\n\\t\\telse if(firstLine <= oldFirstLine - visibleLines)\\n\\t\\t{\\n\\t\\t\\tdisplayManager.firstLine.scrollUp(oldFirstLine - firstLine);\\n\\t\\t\\tchunkCache.invalidateAll();\\n\\t\\t}\\n\\t\\telse if(firstLine > oldFirstLine)\\n\\t\\t{\\n\\t\\t\\tdisplayManager.firstLine.scrollDown(firstLine - oldFirstLine);\\n\\t\\t\\tchunkCache.scrollDown(firstLine - oldFirstLine);\\n\\t\\t}\\n\\t\\telse if(firstLine < oldFirstLine)\\n\\t\\t{\\n\\t\\t\\tdisplayManager.firstLine.scrollUp(oldFirstLine - firstLine);\\n\\t\\t\\tchunkCache.scrollUp(oldFirstLine - firstLine);\\n\\t\\t}\\n\\t\\tdisplayManager.firstLine.changed();\\n\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\trepaint();\\n\\t\\tfireScrollEvent(true);\\n\\t} \\n\\tpublic final int getFirstPhysicalLine()\\n\\t{\\n\\t\\treturn displayManager.firstLine.physicalLine;\\n\\t} \\n\\tpublic void setFirstPhysicalLine(int physFirstLine)\\n\\t{\\n\\t\\tsetFirstPhysicalLine(physFirstLine,0);\\n\\t} \\n\\tpublic void setFirstPhysicalLine(int physFirstLine, int skew)\\n\\t{\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"setFirstPhysicalLine(\\\"\\n\\t\\t\\t\\t+ physFirstLine + \\\",\\\" + skew + \\\")\\\");\\n\\t\\t}\\n\\t\\tint amount = (physFirstLine - displayManager.firstLine.physicalLine);\\n\\t\\tint oldFirstLine = getFirstLine();\\n\\t\\tif(amount == 0)\\n\\t\\t{\\n\\t\\t\\tskew -= displayManager.firstLine.skew;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(skew < 0)\\n\\t\\t\\t\\tdisplayManager.firstLine.scrollUp(-skew);\\n\\t\\t\\telse if(skew > 0)\\n\\t\\t\\t\\tdisplayManager.firstLine.scrollDown(skew);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(amount > 0)\\n\\t\\t\\tdisplayManager.firstLine.physDown(amount,skew);\\n\\t\\telse if(amount < 0)\\n\\t\\t\\tdisplayManager.firstLine.physUp(-amount,skew);\\n\\t\\tint firstLine = getFirstLine();\\n\\t\\tif(firstLine == oldFirstLine)\\n\\t\\t\\t;\\n\\t\\telse if(firstLine >= oldFirstLine + visibleLines\\n\\t\\t\\t|| firstLine <= oldFirstLine - visibleLines)\\n\\t\\t{\\n\\t\\t\\tchunkCache.invalidateAll();\\n\\t\\t}\\n\\t\\telse if(firstLine > oldFirstLine)\\n\\t\\t{\\n\\t\\t\\tchunkCache.scrollDown(firstLine - oldFirstLine);\\n\\t\\t}\\n\\t\\telse if(firstLine < oldFirstLine)\\n\\t\\t{\\n\\t\\t\\tchunkCache.scrollUp(oldFirstLine - firstLine);\\n\\t\\t}\\n\\t\\tdisplayManager.firstLine.changed();\\n\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\trepaint();\\n\\t\\tfireScrollEvent(true);\\n\\t} \\n\\tpublic final int getLastPhysicalLine()\\n\\t{\\n\\t\\treturn physLastLine;\\n\\t} \\n\\tpublic final int getVisibleLines()\\n\\t{\\n\\t\\treturn visibleLines;\\n\\t} \\n\\tpublic final int getHorizontalOffset()\\n\\t{\\n\\t\\treturn horizontalOffset;\\n\\t} \\n\\tpublic void setHorizontalOffset(int horizontalOffset)\\n\\t{\\n\\t\\tif(horizontalOffset > 0)\\n\\t\\t\\thorizontalOffset = 0;\\n\\t\\tif(horizontalOffset == this.horizontalOffset)\\n\\t\\t\\treturn;\\n\\t\\tthis.horizontalOffset = horizontalOffset;\\n\\t\\tif(horizontalOffset != horizontal.getValue())\\n\\t\\t\\tupdateScrollBars();\\n\\t\\tpainter.repaint();\\n\\t\\tfireScrollEvent(false);\\n\\t} \\n\\tpublic void scrollUpLine()\\n\\t{\\n\\t\\tsetFirstLine(getFirstLine() - 1);\\n\\t} \\n\\tpublic void scrollUpPage()\\n\\t{\\n\\t\\tsetFirstLine(getFirstLine() - getVisibleLines()\\n\\t\\t\\t+ (lastLinePartial ? 1 : 0));\\n\\t} \\n\\tpublic void scrollDownLine()\\n\\t{\\n\\t\\tsetFirstLine(getFirstLine() + 1);\\n\\t} \\n\\tpublic void scrollDownPage()\\n\\t{\\n\\t\\tsetFirstLine(getFirstLine() + getVisibleLines()\\n\\t\\t\\t- (lastLinePartial ? 1 : 0));\\n\\t} \\n\\tpublic void scrollToCaret(boolean doElectricScroll)\\n\\t{\\n\\t\\tscrollTo(caretLine,caret - buffer.getLineStartOffset(caretLine),\\n\\t\\t\\tdoElectricScroll);\\n\\t} \\n\\tpublic void scrollTo(int line, int offset, boolean doElectricScroll)\\n\\t{\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"scrollTo(), lineCount=\\\"\\n\\t\\t\\t\\t+ getLineCount());\\n\\t\\t\\t\\tint extraEndVirt;\\n\\t\\tint lineLength = buffer.getLineLength(line);\\n\\t\\tif(offset > lineLength)\\n\\t\\t{\\n\\t\\t\\textraEndVirt = charWidth * (offset - lineLength);\\n\\t\\t\\toffset = lineLength;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\textraEndVirt = 0;\\n\\t\\tint _electricScroll = (doElectricScroll\\n\\t\\t\\t&& visibleLines - 1 > electricScroll * 2\\n\\t\\t\\t? electricScroll : 0); \\n\\t\\tif(visibleLines == 0)\\n\\t\\t{\\n\\t\\t\\tsetFirstPhysicalLine(line,_electricScroll);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\t\\tint firstLine = getFirstLine();\\n\\t\\tint screenLine = chunkCache.getScreenLineOfOffset(line,offset);\\n\\t\\tint visibleLines = getVisibleLines();\\n\\t\\tif(screenLine == -1)\\n\\t\\t{\\n\\t\\t\\tChunkCache.LineInfo[] infos = chunkCache\\n\\t\\t\\t\\t.getLineInfosForPhysicalLine(line);\\n\\t\\t\\tint subregion = chunkCache.getSubregionOfOffset(\\n\\t\\t\\t\\toffset,infos);\\n\\t\\t\\tint prevLine = displayManager.getPrevVisibleLine(getFirstPhysicalLine());\\n\\t\\t\\tint nextLine = displayManager.getNextVisibleLine(getLastPhysicalLine());\\n\\t\\t\\tif(line == prevLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFirstPhysicalLine(prevLine,subregion\\n\\t\\t\\t\\t\\t- _electricScroll);\\n\\t\\t\\t}\\n\\t\\t\\telse if(line == nextLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFirstPhysicalLine(nextLine,\\n\\t\\t\\t\\t\\tsubregion + electricScroll\\n\\t\\t\\t\\t\\t- visibleLines - 1);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFirstPhysicalLine(line,subregion\\n\\t\\t\\t\\t\\t- visibleLines / 2);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(screenLine < _electricScroll)\\n\\t\\t{\\n\\t\\t\\tsetFirstLine(getFirstLine() - _electricScroll + screenLine);\\n\\t\\t}\\n\\t\\telse if(screenLine > visibleLines - _electricScroll\\n\\t\\t\\t- (lastLinePartial ? 2 : 1))\\n\\t\\t{\\n\\t\\t\\tsetFirstLine(getFirstLine() + _electricScroll - visibleLines + screenLine + (lastLinePartial ? 2 : 1));\\n\\t\\t} \\n\\t\\t\\t\\tif(!displayManager.isLineVisible(line))\\n\\t\\t\\treturn;\\n\\t\\tPoint point = offsetToXY(line,offset,returnValue);\\n\\t\\tif(point == null)\\n\\t\\t\\tLog.log(Log.ERROR,this,\\\"BUG: screenLine=\\\" + screenLine\\n\\t\\t\\t\\t+ \\\",visibleLines=\\\" + visibleLines\\n\\t\\t\\t\\t+ \\\",firstPhysicalLine=\\\" + getFirstPhysicalLine()\\n\\t\\t\\t\\t+ \\\",lastPhysicalLine=\\\" + getLastPhysicalLine());\\n\\t\\tpoint.x += extraEndVirt;\\n\\t\\tif(point.x < 0)\\n\\t\\t{\\n\\t\\t\\tsetHorizontalOffset(horizontalOffset\\n\\t\\t\\t\\t- point.x + charWidth + 5);\\n\\t\\t}\\n\\t\\telse if(point.x >= painter.getWidth() - charWidth - 5)\\n\\t\\t{\\n\\t\\t\\tsetHorizontalOffset(horizontalOffset +\\n\\t\\t\\t\\t(painter.getWidth() - point.x)\\n\\t\\t\\t\\t- charWidth - 5);\\n\\t\\t} \\t} \\n\\tpublic final void addScrollListener(ScrollListener listener)\\n\\t{\\n\\t\\tlistenerList.add(ScrollListener.class,listener);\\n\\t} \\n\\tpublic final void removeScrollListener(ScrollListener listener)\\n\\t{\\n\\t\\tlistenerList.remove(ScrollListener.class,listener);\\n\\t} \\n\\tpublic int getPhysicalLineOfScreenLine(int screenLine)\\n\\t{\\n\\t\\treturn chunkCache.getLineInfo(screenLine).physicalLine;\\n\\t} \\n\\tpublic int getScreenLineOfOffset(int offset)\\n\\t{\\n\\t\\tint line = buffer.getLineOfOffset(offset);\\n\\t\\toffset -= buffer.getLineStartOffset(line);\\n\\t\\treturn chunkCache.getScreenLineOfOffset(line,offset);\\n\\t} \\n\\tpublic int getScreenLineStartOffset(int line)\\n\\t{\\n\\t\\tChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);\\n\\t\\tif(lineInfo.physicalLine == -1)\\n\\t\\t\\treturn -1;\\n\\t\\treturn buffer.getLineStartOffset(lineInfo.physicalLine)\\n\\t\\t\\t+ lineInfo.offset;\\n\\t} \\n\\tpublic int getScreenLineEndOffset(int line)\\n\\t{\\n\\t\\tChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);\\n\\t\\tif(lineInfo.physicalLine == -1)\\n\\t\\t\\treturn -1;\\n\\t\\treturn buffer.getLineStartOffset(lineInfo.physicalLine)\\n\\t\\t\\t+ lineInfo.offset + lineInfo.length;\\n\\t} \\n\\tpublic int xyToOffset(int x, int y)\\n\\t{\\n\\t\\treturn xyToOffset(x,y,true);\\n\\t} \\n\\tpublic int xyToOffset(int x, int y, boolean round)\\n\\t{\\n\\t\\tFontMetrics fm = painter.getFontMetrics();\\n\\t\\tint height = fm.getHeight();\\n\\t\\tint line = y / height;\\n\\t\\tif(line < 0 || line >= visibleLines)\\n\\t\\t\\treturn -1;\\n\\t\\treturn xToScreenLineOffset(line,x,round);\\n\\t} \\n\\tpublic int xToScreenLineOffset(int screenLine, int x, boolean round)\\n\\t{\\n\\t\\tChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(screenLine);\\n\\t\\tif(lineInfo.physicalLine == -1)\\n\\t\\t{\\n\\t\\t\\treturn getLineEndOffset(displayManager\\n\\t\\t\\t\\t.getLastVisibleLine()) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint offset = Chunk.xToOffset(lineInfo.chunks,\\n\\t\\t\\t\\tx - horizontalOffset,round);\\n\\t\\t\\tif(offset == -1 || offset == lineInfo.offset + lineInfo.length)\\n\\t\\t\\t\\toffset = lineInfo.offset + lineInfo.length - 1;\\n\\t\\t\\treturn getLineStartOffset(lineInfo.physicalLine) + offset;\\n\\t\\t}\\n\\t} \\n\\tpublic Point offsetToXY(int offset)\\n\\t{\\n\\t\\tint line = buffer.getLineOfOffset(offset);\\n\\t\\toffset -= buffer.getLineStartOffset(line);\\n\\t\\tPoint retVal = new Point();\\n\\t\\treturn offsetToXY(line,offset,retVal);\\n\\t} \\n\\tpublic Point offsetToXY(int line, int offset, Point retVal)\\n\\t{\\n\\t\\tint screenLine = chunkCache.getScreenLineOfOffset(line,offset);\\n\\t\\tif(screenLine == -1)\\n\\t\\t\\treturn null;\\n\\t\\tFontMetrics fm = painter.getFontMetrics();\\n\\t\\tretVal.y = screenLine * fm.getHeight();\\n\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(screenLine);\\n\\t\\tretVal.x = (int)(horizontalOffset + Chunk.offsetToX(\\n\\t\\t\\tinfo.chunks,offset));\\n\\t\\treturn retVal;\\n\\t} \\n\\tpublic void invalidateScreenLineRange(int start, int end)\\n\\t{\\n\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\treturn;\\n\\t\\tif(start > end)\\n\\t\\t{\\n\\t\\t\\tint tmp = end;\\n\\t\\t\\tend = start;\\n\\t\\t\\tstart = tmp;\\n\\t\\t}\\n\\t\\tif(chunkCache.needFullRepaint())\\n\\t\\t\\tend = visibleLines;\\n\\t\\tFontMetrics fm = painter.getFontMetrics();\\n\\t\\tint y = start * fm.getHeight();\\n\\t\\tint height = (end - start + 1) * fm.getHeight();\\n\\t\\tpainter.repaint(0,y,painter.getWidth(),height);\\n\\t\\tgutter.repaint(0,y,gutter.getWidth(),height);\\n\\t} \\n\\tpublic void invalidateLine(int line)\\n\\t{\\n\\t\\tif(!isShowing()\\n\\t\\t\\t|| !buffer.isLoaded()\\n\\t\\t\\t|| line < getFirstPhysicalLine()\\n\\t\\t\\t|| line > physLastLine\\n\\t\\t\\t|| !displayManager.isLineVisible(line))\\n\\t\\t\\treturn;\\n\\t\\tint startLine = -1;\\n\\t\\tint endLine = -1;\\n\\t\\tfor(int i = 0; i < visibleLines; i++)\\n\\t\\t{\\n\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(i);\\n\\t\\t\\tif((info.physicalLine >= line || info.physicalLine == -1)\\n\\t\\t\\t\\t&& startLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstartLine = i;\\n\\t\\t\\t}\\n\\t\\t\\tif((info.physicalLine >= line && info.lastSubregion)\\n\\t\\t\\t\\t|| info.physicalLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tendLine = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(chunkCache.needFullRepaint() || endLine == -1)\\n\\t\\t\\tendLine = visibleLines;\\n\\t\\tinvalidateScreenLineRange(startLine,endLine);\\n\\t} \\n\\tpublic void invalidateLineRange(int start, int end)\\n\\t{\\n\\t\\tif(!isShowing() || !buffer.isLoaded())\\n\\t\\t\\treturn;\\n\\t\\tif(end < start)\\n\\t\\t{\\n\\t\\t\\tint tmp = end;\\n\\t\\t\\tend = start;\\n\\t\\t\\tstart = tmp;\\n\\t\\t}\\n\\t\\tif(end < getFirstPhysicalLine() || start > getLastPhysicalLine())\\n\\t\\t\\treturn;\\n\\t\\tint startScreenLine = -1;\\n\\t\\tint endScreenLine = -1;\\n\\t\\tfor(int i = 0; i < visibleLines; i++)\\n\\t\\t{\\n\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(i);\\n\\t\\t\\tif((info.physicalLine >= start || info.physicalLine == -1)\\n\\t\\t\\t\\t&& startScreenLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstartScreenLine = i;\\n\\t\\t\\t}\\n\\t\\t\\tif((info.physicalLine >= end && info.lastSubregion)\\n\\t\\t\\t\\t|| info.physicalLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tendScreenLine = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(startScreenLine == -1)\\n\\t\\t\\tstartScreenLine = 0;\\n\\t\\tif(chunkCache.needFullRepaint() || endScreenLine == -1)\\n\\t\\t\\tendScreenLine = visibleLines;\\n\\t\\tinvalidateScreenLineRange(startScreenLine,endScreenLine);\\n\\t} \\n\\tpublic void invalidateSelectedLines()\\n\\t{\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tinvalidateLineRange(s.startLine,s.endLine);\\n\\t\\t}\\n\\t} \\n\\tpublic final int getBufferLength()\\n\\t{\\n\\t\\treturn buffer.getLength();\\n\\t} \\n\\tpublic final int getLineCount()\\n\\t{\\n\\t\\treturn buffer.getLineCount();\\n\\t} \\n\\tpublic final int getLineOfOffset(int offset)\\n\\t{\\n\\t\\treturn buffer.getLineOfOffset(offset);\\n\\t} \\n\\tpublic int getLineStartOffset(int line)\\n\\t{\\n\\t\\treturn buffer.getLineStartOffset(line);\\n\\t} \\n\\tpublic int getLineEndOffset(int line)\\n\\t{\\n\\t\\treturn buffer.getLineEndOffset(line);\\n\\t} \\n\\tpublic int getLineLength(int line)\\n\\t{\\n\\t\\treturn buffer.getLineLength(line);\\n\\t} \\n\\tpublic final String getText(int start, int len)\\n\\t{\\n\\t\\treturn buffer.getText(start,len);\\n\\t} \\n\\tpublic final void getText(int start, int len, Segment segment)\\n\\t{\\n\\t\\tbuffer.getText(start,len,segment);\\n\\t} \\n\\tpublic final String getLineText(int lineIndex)\\n\\t{\\n\\t\\treturn buffer.getLineText(lineIndex);\\n\\t} \\n\\tpublic final void getLineText(int lineIndex, Segment segment)\\n\\t{\\n\\t\\tbuffer.getLineText(lineIndex,segment);\\n\\t} \\n\\tpublic String getText()\\n\\t{\\n\\t\\treturn buffer.getText(0,buffer.getLength());\\n\\t} \\n\\tpublic void setText(String text)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tbuffer.remove(0,buffer.getLength());\\n\\t\\t\\tbuffer.insert(0,text);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic final void selectAll()\\n\\t{\\n\\t\\tsetSelection(new Selection.Range(0,buffer.getLength()));\\n\\t\\tmoveCaretPosition(buffer.getLength(),true);\\n\\t} \\n\\tpublic void selectLine()\\n\\t{\\n\\t\\tint caretLine = getCaretLine();\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine) - 1;\\n\\t\\tSelection s = new Selection.Range(start,end);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(end);\\n\\t} \\n\\tpublic void selectParagraph()\\n\\t{\\n\\t\\tint caretLine = getCaretLine();\\n\\t\\tif(getLineLength(caretLine) == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint start = caretLine;\\n\\t\\tint end = caretLine;\\n\\t\\twhile(start >= 0)\\n\\t\\t{\\n\\t\\t\\tif(getLineLength(start) == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\telse\\n\\t\\t\\t\\tstart--;\\n\\t\\t}\\n\\t\\twhile(end < getLineCount())\\n\\t\\t{\\n\\t\\t\\tif(getLineLength(end) == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\telse\\n\\t\\t\\t\\tend++;\\n\\t\\t}\\n\\t\\tint selectionStart = getLineStartOffset(start + 1);\\n\\t\\tint selectionEnd = getLineEndOffset(end - 1) - 1;\\n\\t\\tSelection s = new Selection.Range(selectionStart,selectionEnd);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(selectionEnd);\\n\\t} \\n\\tpublic void selectWord()\\n\\t{\\n\\t\\tint line = getCaretLine();\\n\\t\\tint lineStart = getLineStartOffset(line);\\n\\t\\tint offset = getCaretPosition() - lineStart;\\n\\t\\tif(getLineLength(line) == 0)\\n\\t\\t\\treturn;\\n\\t\\tString lineText = getLineText(line);\\n\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\tif(offset == getLineLength(line))\\n\\t\\t\\toffset--;\\n\\t\\tint wordStart = TextUtilities.findWordStart(lineText,offset,noWordSep);\\n\\t\\tint wordEnd = TextUtilities.findWordEnd(lineText,offset+1,noWordSep);\\n\\t\\tSelection s = new Selection.Range(lineStart + wordStart,\\n\\t\\t\\tlineStart + wordEnd);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(lineStart + wordEnd);\\n\\t} \\n\\tpublic Selection selectToMatchingBracket(int position,\\n\\t\\tboolean quickCopy)\\n\\t{\\n\\t\\tint positionLine = buffer.getLineOfOffset(position);\\n\\t\\tint lineOffset = position - buffer.getLineStartOffset(positionLine);\\n\\t\\tif(getLineLength(positionLine) != 0)\\n\\t\\t{\\n\\t\\t\\tint bracket = TextUtilities.findMatchingBracket(buffer,\\n\\t\\t\\t\\tpositionLine,Math.max(0,lineOffset - 1));\\n\\t\\t\\tif(bracket != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s;\\n\\t\\t\\t\\tif(bracket < position)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!quickCopy)\\n\\t\\t\\t\\t\\t\\tmoveCaretPosition(position,false);\\n\\t\\t\\t\\t\\ts = new Selection.Range(bracket,position);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!quickCopy)\\n\\t\\t\\t\\t\\t\\tmoveCaretPosition(bracket + 1,false);\\n\\t\\t\\t\\t\\ts = new Selection.Range(position - 1,bracket + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!multi && !quickCopy)\\n\\t\\t\\t\\t\\tselectNone();\\n\\t\\t\\t\\taddToSelection(s);\\n\\t\\t\\t\\treturn s;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic void selectToMatchingBracket()\\n\\t{\\n\\t\\tselectToMatchingBracket(caret,false);\\n\\t} \\n\\tpublic void narrowToMatchingBracket()\\n\\t{\\n\\t\\tnarrowToMatchingBracket(caret);\\n\\t} \\n\\tpublic void narrowToMatchingBracket(int position)\\n\\t{\\n\\t\\tint line = buffer.getLineOfOffset(position);\\n\\t\\tint offset = position - buffer.getLineStartOffset(line);\\n\\t\\tif(getLineLength(line) != 0)\\n\\t\\t{\\n\\t\\t\\tint bracket = TextUtilities.findMatchingBracket(buffer,\\n\\t\\t\\t\\tline,Math.max(0,offset - 1));\\n\\t\\t\\tif(bracket != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint start = Math.min(bracketLine,line);\\n\\t\\t\\t\\tint end = Math.max(bracketLine,line);\\n\\t\\t\\t\\tdisplayManager.narrow(start,end);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic void selectBlock()\\n\\t{\\n\\t\\tString openBrackets = \\\"([{\\\";\\n\\t\\tString closeBrackets = \\\")]}\\\";\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint start, end;\\n\\t\\tif(s == null)\\n\\t\\t\\tstart = end = caret;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstart = s.start;\\n\\t\\t\\tend = s.end;\\n\\t\\t}\\n\\t\\tString text = getText(0,buffer.getLength());\\n\\t\\t\\t\\tint count = 1;\\n\\t\\tchar openBracket = '\\\\0';\\n\\t\\tchar closeBracket = '\\\\0';\\n\\t\\t\\t\\tif(start == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\nbackward_scan:\\twhile(--start > 0)\\n\\t\\t{\\n\\t\\t\\tchar c = text.charAt(start);\\n\\t\\t\\tint index = openBrackets.indexOf(c);\\n\\t\\t\\tif(index != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(--count == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\topenBracket = c;\\n\\t\\t\\t\\t\\tcloseBracket = closeBrackets.charAt(index);\\n\\t\\t\\t\\t\\tbreak backward_scan;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(closeBrackets.indexOf(c) != -1)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\t\\t\\tcount = 1;\\n\\t\\t\\t\\tif(openBracket == '\\\\0')\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\nforward_scan:\\t\\tdo\\n\\t\\t\\t{\\n\\t\\t\\t\\tchar c = text.charAt(end);\\n\\t\\t\\t\\tif(c == closeBracket)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(--count == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend++;\\n\\t\\t\\t\\t\\t\\tbreak forward_scan;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(c == openBracket)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\twhile(++end < buffer.getLength());\\n\\t\\t}\\n\\t\\ts = new Selection.Range(start,end);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(end);\\n\\t} \\n\\tpublic boolean lineInBracketScope(int line)\\n\\t{\\n\\t\\tif(bracketPosition == -1)\\n\\t\\t\\treturn false;\\n\\t\\tif(bracketLine < caretLine)\\n\\t\\t\\treturn (line >= bracketLine && line <= caretLine);\\n\\t\\telse\\n\\t\\t\\treturn (line <= bracketLine && line >= caretLine);\\n\\t} \\n\\tpublic final void invertSelection()\\n\\t{\\n\\t\\tSelection[] newSelection = new Selection[selection.size() + 1];\\n\\t\\tint lastOffset = 0;\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tnewSelection[i] = new Selection.Range(lastOffset,\\n\\t\\t\\t\\ts.getStart());\\n\\t\\t\\tlastOffset = s.getEnd();\\n\\t\\t}\\n\\t\\tnewSelection[selection.size()] = new Selection.Range(\\n\\t\\t\\tlastOffset,buffer.getLength());\\n\\t\\tsetSelection(newSelection);\\n\\t} \\n\\tpublic int getSelectionCount()\\n\\t{\\n\\t\\treturn selection.size();\\n\\t} \\n\\tpublic Selection[] getSelection()\\n\\t{\\n\\t\\tSelection[] sel = new Selection[selection.size()];\\n\\t\\tselection.copyInto(sel);\\n\\t\\treturn sel;\\n\\t} \\n\\tpublic void selectNone()\\n\\t{\\n\\t\\tsetSelection((Selection)null);\\n\\t} \\n\\tpublic void setSelection(Selection[] selection)\\n\\t{\\n\\t\\t\\t\\tinvalidateSelectedLines();\\n\\t\\tthis.selection.removeAllElements();\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t\\t_addToSelection(selection[i]);\\n\\t\\t}\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void setSelection(Selection selection)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tthis.selection.removeAllElements();\\n\\t\\tif(selection != null)\\n\\t\\t\\t_addToSelection(selection);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void addToSelection(Selection[] selection)\\n\\t{\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t\\t_addToSelection(selection[i]);\\n\\t\\t}\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void addToSelection(Selection selection)\\n\\t{\\n\\t\\t_addToSelection(selection);\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic Selection getSelectionAtOffset(int offset)\\n\\t{\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\t\\tif(offset >= s.start && offset <= s.end)\\n\\t\\t\\t\\t\\treturn s;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic void removeFromSelection(Selection sel)\\n\\t{\\n\\t\\tselection.removeElement(sel);\\n\\t\\tinvalidateLineRange(sel.startLine,sel.endLine);\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void removeFromSelection(int offset)\\n\\t{\\n\\t\\tSelection sel = getSelectionAtOffset(offset);\\n\\t\\tif(sel == null)\\n\\t\\t\\treturn;\\n\\t\\tselection.removeElement(sel);\\n\\t\\tinvalidateLineRange(sel.startLine,sel.endLine);\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void resizeSelection(int offset, int end, int extraEndVirt,\\n\\t\\tboolean rect)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(offset);\\n\\t\\tif(s != null)\\n\\t\\t{\\n\\t\\t\\tinvalidateLineRange(s.startLine,s.endLine);\\n\\t\\t\\tselection.removeElement(s);\\n\\t\\t}\\n\\t\\tboolean reversed = false;\\n\\t\\tif(end < offset)\\n\\t\\t{\\n\\t\\t\\tint tmp = offset;\\n\\t\\t\\toffset = end;\\n\\t\\t\\tend = tmp;\\n\\t\\t\\treversed = true;\\n\\t\\t}\\n\\t\\tSelection newSel;\\n\\t\\tif(rect)\\n\\t\\t{\\n\\t\\t\\tSelection.Rect rectSel = new Selection.Rect(offset,end);\\n\\t\\t\\tif(reversed)\\n\\t\\t\\t\\trectSel.extraStartVirt = extraEndVirt;\\n\\t\\t\\telse\\n\\t\\t\\t\\trectSel.extraEndVirt = extraEndVirt;\\n\\t\\t\\tnewSel = rectSel;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tnewSel = new Selection.Range(offset,end);\\n\\t\\t_addToSelection(newSel);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void extendSelection(int offset, int end)\\n\\t{\\n\\t\\textendSelection(offset,end,0,0);\\n\\t} \\n\\tpublic void extendSelection(int offset, int end,\\n\\t\\tint extraStartVirt, int extraEndVirt)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(offset);\\n\\t\\tif(s != null)\\n\\t\\t{\\n\\t\\t\\tinvalidateLineRange(s.startLine,s.endLine);\\n\\t\\t\\tselection.removeElement(s);\\n\\t\\t\\tif(offset == s.start)\\n\\t\\t\\t{\\n\\t\\t\\t\\toffset = end;\\n\\t\\t\\t\\tend = s.end;\\n\\t\\t\\t}\\n\\t\\t\\telse if(offset == s.end)\\n\\t\\t\\t{\\n\\t\\t\\t\\toffset = s.start;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(end < offset)\\n\\t\\t{\\n\\t\\t\\tint tmp = end;\\n\\t\\t\\tend = offset;\\n\\t\\t\\toffset = tmp;\\n\\t\\t}\\n\\t\\tif(rectangularSelectionMode)\\n\\t\\t{\\n\\t\\t\\ts = new Selection.Rect(offset,end);\\n\\t\\t\\t((Selection.Rect)s).extraStartVirt = extraStartVirt;\\n\\t\\t\\t((Selection.Rect)s).extraEndVirt = extraEndVirt;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\ts = new Selection.Range(offset,end);\\n\\t\\t_addToSelection(s);\\n\\t\\tfireCaretEvent();\\n\\t\\tif(rectangularSelectionMode && extraEndVirt != 0)\\n\\t\\t{\\n\\t\\t\\tint line = getLineOfOffset(end);\\n\\t\\t\\tscrollTo(line,getLineLength(line) + extraEndVirt,false);\\n\\t\\t}\\n\\t} \\n\\tpublic String getSelectedText(Selection s)\\n\\t{\\n\\t\\tStringBuffer buf = new StringBuffer();\\n\\t\\ts.getText(buffer,buf);\\n\\t\\treturn buf.toString();\\n\\t} \\n\\tpublic String getSelectedText(String separator)\\n\\t{\\n\\t\\tif(selection.size() == 0)\\n\\t\\t\\treturn null;\\n\\t\\tStringBuffer buf = new StringBuffer();\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tif(i != 0)\\n\\t\\t\\t\\tbuf.append(separator);\\n\\t\\t\\t((Selection)selection.elementAt(i)).getText(buffer,buf);\\n\\t\\t}\\n\\t\\treturn buf.toString();\\n\\t} \\n\\tpublic String getSelectedText()\\n\\t{\\n\\t\\treturn getSelectedText(\\\"\\\\n\\\");\\n\\t} \\n\\tpublic void setSelectedText(Selection s, String selectedText)\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tthrow new InternalError(\\\"Text component\\\"\\n\\t\\t\\t\\t+ \\\" read only\\\");\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tmoveCaretPosition(s.setText(buffer,selectedText));\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\t\\t\\t\\t} \\n\\tpublic void setSelectedText(String selectedText)\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tthrow new InternalError(\\\"Text component\\\"\\n\\t\\t\\t\\t+ \\\" read only\\\");\\n\\t\\t}\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(selection.length == 0)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.insert(caret,selectedText);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tint newCaret = -1;\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnewCaret = selection[i].setText(buffer,selectedText);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic int[] getSelectedLines()\\n\\t{\\n\\t\\tif(selection.size() == 0)\\n\\t\\t\\treturn new int[] { caretLine };\\n\\t\\tInteger line;\\n\\t\\tHashtable hash = new Hashtable();\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tint endLine = (s.end == getLineStartOffset(s.endLine)\\n\\t\\t\\t\\t? s.endLine - 1\\n\\t\\t\\t\\t: s.endLine);\\n\\t\\t\\tfor(int j = s.startLine; j <= endLine; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tline = new Integer(j);\\n\\t\\t\\t\\thash.put(line,line);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint[] returnValue = new int[hash.size()];\\n\\t\\tint i = 0;\\n\\t\\tEnumeration keys = hash.keys();\\n\\t\\twhile(keys.hasMoreElements())\\n\\t\\t{\\n\\t\\t\\tline = (Integer)keys.nextElement();\\n\\t\\t\\treturnValue[i++] = line.intValue();\\n\\t\\t}\\n\\t\\tArrays.sort(returnValue);\\n\\t\\treturn returnValue;\\n\\t} \\n\\tpublic void showSelectLineRangeDialog()\\n\\t{\\n\\t\\tnew SelectLineRange(view);\\n\\t} \\n\\tpublic final void blinkCaret()\\n\\t{\\n\\t\\tif(caretBlinks)\\n\\t\\t{\\n\\t\\t\\tblink = !blink;\\n\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tblink = true;\\n\\t} \\n\\tpublic void centerCaret()\\n\\t{\\n\\t\\tint offset = getScreenLineStartOffset(visibleLines / 2);\\n\\t\\tif(offset == -1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t\\tsetCaretPosition(offset);\\n\\t} \\n\\tpublic void setCaretPosition(int newCaret)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tselection.removeAllElements();\\n\\t\\tmoveCaretPosition(newCaret,true);\\n\\t} \\n\\tpublic void setCaretPosition(int newCaret, boolean doElectricScroll)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tselection.removeAllElements();\\n\\t\\tmoveCaretPosition(newCaret,doElectricScroll);\\n\\t} \\n\\tpublic void moveCaretPosition(int newCaret)\\n\\t{\\n\\t\\tmoveCaretPosition(newCaret,true);\\n\\t} \\n\\tpublic void moveCaretPosition(int newCaret, boolean doElectricScroll)\\n\\t{\\n\\t\\tmoveCaretPosition(newCaret,doElectricScroll ? ELECTRIC_SCROLL\\n\\t\\t\\t: NORMAL_SCROLL);\\n\\t} \\n\\t\\tpublic int NO_SCROLL = 0;\\n\\tpublic int NORMAL_SCROLL = 1;\\n\\tpublic int ELECTRIC_SCROLL = 2;\\n\\tpublic void moveCaretPosition(int newCaret, int scrollMode)\\n\\t{\\n\\t\\tif(newCaret < 0 || newCaret > buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tthrow new IllegalArgumentException(\\\"caret out of bounds: \\\"\\n\\t\\t\\t\\t+ newCaret);\\n\\t\\t}\\n\\t\\tif(caret == newCaret)\\n\\t\\t{\\n\\t\\t\\tif(bracketLine != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tinvalidateLineRange(bracketLine,caretLine);\\n\\t\\t\\t\\tbracketLine = bracketPosition = -1;\\n\\t\\t\\t}\\n\\t\\t\\tif(scrollMode == NORMAL_SCROLL)\\n\\t\\t\\t\\tfinishCaretUpdate(false,false);\\n\\t\\t\\telse if(scrollMode == ELECTRIC_SCROLL)\\n\\t\\t\\t\\tfinishCaretUpdate(true,false);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint newCaretLine = getLineOfOffset(newCaret);\\n\\t\\t\\tmagicCaret = -1;\\n\\t\\t\\tif(!displayManager.isLineVisible(newCaretLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(newCaretLine < displayManager.getFirstVisibleLine()\\n\\t\\t\\t\\t\\t|| newCaretLine > displayManager.getLastVisibleLine())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint collapseFolds = buffer.getIntegerProperty(\\n\\t\\t\\t\\t\\t\\t\\\"collapseFolds\\\",0);\\n\\t\\t\\t\\t\\tif(collapseFolds != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdisplayManager.expandFolds(collapseFolds);\\n\\t\\t\\t\\t\\t\\tdisplayManager.expandFold(newCaretLine,false);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tdisplayManager.expandAllFolds();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tdisplayManager.expandFold(newCaretLine,false);\\n\\t\\t\\t}\\n\\t\\t\\tif(bracketLine != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tinvalidateLineRange(bracketLine,caretLine);\\n\\t\\t\\t\\tbracketLine = bracketPosition = -1;\\n\\t\\t\\t}\\n\\t\\t\\tif(caretLine == newCaretLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caretScreenLine != -1)\\n\\t\\t\\t\\t\\tinvalidateScreenLineRange(caretScreenLine,caretScreenLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint newCaretScreenLine = chunkCache.getScreenLineOfOffset(newCaretLine,\\n\\t\\t\\t\\t\\tnewCaret - buffer.getLineStartOffset(newCaretLine));\\n\\t\\t\\t\\tif(caretScreenLine == -1)\\n\\t\\t\\t\\t\\tinvalidateScreenLineRange(newCaretScreenLine,newCaretScreenLine);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tinvalidateScreenLineRange(caretScreenLine,newCaretScreenLine);\\n\\t\\t\\t\\tcaretScreenLine = newCaretScreenLine;\\n\\t\\t\\t}\\n\\t\\t\\tcaret = newCaret;\\n\\t\\t\\tcaretLine = newCaretLine;\\n\\t\\t\\tif(scrollMode == NORMAL_SCROLL)\\n\\t\\t\\t\\tfinishCaretUpdate(false,true);\\n\\t\\t\\telse if(scrollMode == ELECTRIC_SCROLL)\\n\\t\\t\\t\\tfinishCaretUpdate(true,true);\\n\\t\\t}\\n\\t} \\n\\tpublic int getCaretPosition()\\n\\t{\\n\\t\\treturn caret;\\n\\t} \\n\\tpublic int getCaretLine()\\n\\t{\\n\\t\\treturn caretLine;\\n\\t} \\n\\tpublic int getMagicCaretPosition()\\n\\t{\\n\\t\\tif(magicCaret == -1)\\n\\t\\t{\\n\\t\\t\\tmagicCaret = chunkCache.subregionOffsetToX(\\n\\t\\t\\t\\tcaretLine,caret - getLineStartOffset(caretLine));\\n\\t\\t}\\n\\t\\treturn magicCaret;\\n\\t} \\n\\tpublic void setMagicCaretPosition(int magicCaret)\\n\\t{\\n\\t\\tthis.magicCaret = magicCaret;\\n\\t} \\n\\tpublic final void addCaretListener(CaretListener listener)\\n\\t{\\n\\t\\tlistenerList.add(CaretListener.class,listener);\\n\\t} \\n\\tpublic final void removeCaretListener(CaretListener listener)\\n\\t{\\n\\t\\tlistenerList.remove(CaretListener.class,listener);\\n\\t} \\n\\tpublic final int getBracketPosition()\\n\\t{\\n\\t\\treturn bracketPosition;\\n\\t} \\n\\tpublic final int getBracketLine()\\n\\t{\\n\\t\\treturn bracketLine;\\n\\t} \\n\\tpublic void goToNextBracket(boolean select)\\n\\t{\\n\\t\\tString text = getText(caret,buffer.getLength() - caret - 1);\\n\\t\\tint newCaret = -1;\\nloop:\\t\\tfor(int i = 0; i < text.length(); i++)\\n\\t\\t{\\n\\t\\t\\tswitch(text.charAt(i))\\n\\t\\t\\t{\\n\\t\\t\\tcase ')': case ']': case '}':\\n\\t\\t\\t\\tnewCaret = caret + i + 1;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(newCaret == -1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(select)\\n\\t\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\t\\telse if(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t}\\n\\t} \\n\\tpublic void goToNextCharacter(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(!select && s instanceof Selection.Range)\\n\\t\\t{\\n\\t\\t\\tif(multi)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caret != s.end)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmoveCaretPosition(s.end);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetCaretPosition(s.end);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint extraStartVirt, extraEndVirt;\\n\\t\\tif(s instanceof Selection.Rect)\\n\\t\\t{\\n\\t\\t\\textraStartVirt = ((Selection.Rect)s).extraStartVirt;\\n\\t\\t\\textraEndVirt = ((Selection.Rect)s).extraEndVirt;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\textraStartVirt = 0;\\n\\t\\t\\textraEndVirt = 0;\\n\\t\\t}\\n\\t\\tint newCaret = caret;\\n\\t\\tif(select && caret == buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tif(rectangularSelectionMode || s instanceof Selection.Rect)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caret == s.start)\\n\\t\\t\\t\\t\\textraStartVirt++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\textraEndVirt++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(caret == getLineEndOffset(caretLine) - 1)\\n\\t\\t{\\n\\t\\t\\tif(rectangularSelectionMode || s instanceof Selection.Rect)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caret == s.start)\\n\\t\\t\\t\\t\\textraStartVirt++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\textraEndVirt++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint line = displayManager.getNextVisibleLine(caretLine);\\n\\t\\t\\t\\tif(line == -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tnewCaret = getLineStartOffset(line);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tnewCaret = caret + 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret,extraStartVirt,extraEndVirt);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToNextLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tboolean rectSelect = (s == null ? rectangularSelectionMode\\n\\t\\t\\t: s instanceof Selection.Rect);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = chunkCache.getBelowPosition(caretLine,\\n\\t\\t\\tcaret - buffer.getLineStartOffset(caretLine),magic + 1,\\n\\t\\t\\trectSelect && select);\\n\\t\\tif(newCaret == -1)\\n\\t\\t{\\n\\t\\t\\tint end = getLineEndOffset(caretLine) - 1;\\n\\t\\t\\tif(caret == end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tnewCaret = end;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t{\\n\\t\\t\\tRectParams params = getRectParams(caret,newCaret);\\n\\t\\t\\tint extraStartVirt;\\n\\t\\t\\tint extraEndVirt;\\n\\t\\t\\tif(params == null)\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = 0;\\n\\t\\t\\t\\textraEndVirt = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = params.extraStartVirt;\\n\\t\\t\\t\\textraEndVirt = params.extraEndVirt;\\n\\t\\t\\t\\tnewCaret = params.newCaret;\\n\\t\\t\\t}\\n\\t\\t\\textendSelection(caret,newCaret,extraStartVirt,extraEndVirt);\\n\\t\\t}\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToNextMarker(boolean select)\\n\\t{\\n\\t\\tVector markers = buffer.getMarkers();\\n\\t\\tif(markers.size() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tMarker marker = null;\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker _marker = (Marker)markers.get(i);\\n\\t\\t\\tif(_marker.getPosition() > caret)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmarker = _marker;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(marker == null)\\n\\t\\t\\tmarker = (Marker)markers.get(0);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,marker.getPosition());\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(marker.getPosition());\\n\\t} \\n\\tpublic void goToNextPage(boolean select)\\n\\t{\\n\\t\\tscrollToCaret(false);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint caretScreenLine = getScreenLineOfOffset(caret);\\n\\t\\tscrollDownPage();\\n\\t\\tint newCaret = xToScreenLineOffset(caretScreenLine,magic,true);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret,false);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToNextParagraph(boolean select)\\n\\t{\\n\\t\\tint lineNo = getCaretLine();\\n\\t\\tint newCaret = getBufferLength();\\n\\t\\tboolean foundBlank = false;\\nloop:\\t\\tfor(int i = lineNo + 1; i < getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tif(!displayManager.isLineVisible(i))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif(foundBlank)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnewCaret = getLineStartOffset(i);\\n\\t\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfoundBlank = true;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToNextWord(boolean select)\\n\\t{\\n\\t\\tgoToNextWord(select,false);\\n\\t} \\n\\tpublic void goToNextWord(boolean select, boolean stdNextPrevWord)\\n\\t{\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint newCaret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(newCaret == lineText.length())\\n\\t\\t{\\n\\t\\t\\tint nextLine = displayManager.getNextVisibleLine(caretLine);\\n\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret = getLineStartOffset(nextLine);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tnewCaret = TextUtilities.findWordEnd(lineText,newCaret + 1,\\n\\t\\t\\t\\tnoWordSep);\\n\\t\\t\\tif(stdNextPrevWord)\\n\\t\\t\\t{\\n\\t\\t\\t\\twhile((newCaret < lineText.length()) && Character.isWhitespace(lineText.charAt(newCaret)))\\n\\t\\t\\t\\t\\tnewCaret = TextUtilities.findWordEnd(lineText,newCaret + 1,\\n\\t\\t\\t\\t\\t\\tnoWordSep);\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret += lineStart;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToPrevBracket(boolean select)\\n\\t{\\n\\t\\tString text = getText(0,caret);\\n\\t\\tint newCaret = -1;\\nloop:\\t\\tfor(int i = getCaretPosition() - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tswitch(text.charAt(i))\\n\\t\\t\\t{\\n\\t\\t\\tcase '(': case '[': case '{':\\n\\t\\t\\t\\tnewCaret = i;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(newCaret == -1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(select)\\n\\t\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\t\\telse if(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t}\\n\\t} \\n\\tpublic void goToPrevCharacter(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(!select && s instanceof Selection.Range)\\n\\t\\t{\\n\\t\\t\\tif(multi)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caret != s.start)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmoveCaretPosition(s.start);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetCaretPosition(s.start);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint extraStartVirt = 0;\\n\\t\\tint extraEndVirt = 0;\\n\\t\\tint newCaret = caret;\\n\\t\\tif(select && caret == getLineEndOffset(caretLine) - 1)\\n\\t\\t{\\n\\t\\t\\tif(s instanceof Selection.Rect)\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = ((Selection.Rect)s).extraStartVirt;\\n\\t\\t\\t\\textraEndVirt = ((Selection.Rect)s).extraEndVirt;\\n\\t\\t\\t\\tif(caret == s.start)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(extraStartVirt == 0)\\n\\t\\t\\t\\t\\t\\tnewCaret = caret - 1;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\textraStartVirt--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(extraEndVirt == 0)\\n\\t\\t\\t\\t\\t\\tnewCaret = caret - 1;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\textraEndVirt--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tnewCaret = caret - 1;\\n\\t\\t}\\n\\t\\telse if(caret == getLineStartOffset(caretLine))\\n\\t\\t{\\n\\t\\t\\tint line = displayManager.getPrevVisibleLine(caretLine);\\n\\t\\t\\tif(line == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret = getLineEndOffset(line) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tnewCaret = caret - 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret,extraStartVirt,extraEndVirt);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToPrevLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tboolean rectSelect = (s == null ? rectangularSelectionMode\\n\\t\\t\\t: s instanceof Selection.Rect);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = chunkCache.getAbovePosition(caretLine,\\n\\t\\t\\tcaret - buffer.getLineStartOffset(caretLine),magic + 1,\\n\\t\\t\\trectSelect && select);\\n\\t\\tif(newCaret == -1)\\n\\t\\t{\\n\\t\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\t\\tif(caret == start)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tnewCaret = start;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t{\\n\\t\\t\\tRectParams params = getRectParams(caret,newCaret);\\n\\t\\t\\tint extraStartVirt;\\n\\t\\t\\tint extraEndVirt;\\n\\t\\t\\tif(params == null)\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = 0;\\n\\t\\t\\t\\textraEndVirt = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = params.extraStartVirt;\\n\\t\\t\\t\\textraEndVirt = params.extraEndVirt;\\n\\t\\t\\t\\tnewCaret = params.newCaret;\\n\\t\\t\\t}\\n\\t\\t\\textendSelection(caret,newCaret,extraStartVirt,extraEndVirt);\\n\\t\\t}\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToPrevMarker(boolean select)\\n\\t{\\n\\t\\tVector markers = buffer.getMarkers();\\n\\t\\tif(markers.size() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tMarker marker = null;\\n\\t\\tfor(int i = markers.size() - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tMarker _marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tif(_marker.getPosition() < caret)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmarker = _marker;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(marker == null)\\n\\t\\t\\tmarker = (Marker)markers.get(markers.size() - 1);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,marker.getPosition());\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(marker.getPosition());\\n\\t} \\n\\tpublic void goToPrevPage(boolean select)\\n\\t{\\n\\t\\tscrollToCaret(false);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint caretScreenLine = getScreenLineOfOffset(caret);\\n\\t\\tscrollUpPage();\\n\\t\\tint newCaret = xToScreenLineOffset(caretScreenLine,magic,true);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret,false);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToPrevParagraph(boolean select)\\n\\t{\\n\\t\\tint lineNo = caretLine;\\n\\t\\tint newCaret = 0;\\n\\t\\tboolean foundBlank = false;\\nloop:\\t\\tfor(int i = lineNo - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(!displayManager.isLineVisible(i))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif(foundBlank)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnewCaret = getLineEndOffset(i) - 1;\\n\\t\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfoundBlank = true;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToPrevWord(boolean select)\\n\\t{\\n\\t\\tgoToPrevWord(select,false);\\n\\t} \\n\\tpublic void goToPrevWord(boolean select, boolean stdNextPrevWord)\\n\\t{\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint newCaret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(newCaret == 0)\\n\\t\\t{\\n\\t\\t\\tif(lineStart == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint prevLine = displayManager.getPrevVisibleLine(caretLine);\\n\\t\\t\\t\\tif(prevLine == -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnewCaret = getLineEndOffset(prevLine) - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tnewCaret = TextUtilities.findWordStart(lineText,newCaret - 1,\\n\\t\\t\\t\\tnoWordSep);\\n\\t\\t\\tif(stdNextPrevWord)\\n\\t\\t\\t{\\n\\t\\t\\t\\twhile((newCaret > 0) && Character.isWhitespace(lineText.charAt(newCaret)))\\n\\t\\t\\t\\t\\tnewCaret = TextUtilities.findWordStart(lineText,newCaret - 1,\\n\\t\\t\\t\\t\\t\\tnoWordSep);\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret += lineStart;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void smartHome(boolean select)\\n\\t{\\n\\t\\tMacros.Recorder recorder = view.getMacroRecorder();\\n\\t\\tswitch(view.getInputHandler().getLastActionCount())\\n\\t\\t{\\n\\t\\tcase 1:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToStartOfWhiteSpace(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToStartOfWhiteSpace(select);\\n\\t\\t\\tbreak;\\n\\t\\tcase 2:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToStartOfLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToStartOfLine(select);\\n\\t\\t\\tbreak;\\n\\t\\tdefault: \\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToFirstVisibleLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToFirstVisibleLine(select);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t} \\n\\tpublic void smartEnd(boolean select)\\n\\t{\\n\\t\\tMacros.Recorder recorder = view.getMacroRecorder();\\n\\t\\tswitch(view.getInputHandler().getLastActionCount())\\n\\t\\t{\\n\\t\\tcase 1:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToEndOfWhiteSpace(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToEndOfWhiteSpace(select);\\n\\t\\t\\tbreak;\\n\\t\\tcase 2:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToEndOfLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToEndOfLine(select);\\n\\t\\t\\tbreak;\\n\\t\\tdefault: \\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToLastVisibleLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToLastVisibleLine(select);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t} \\n\\tpublic void goToStartOfLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line = (select || s == null\\n\\t\\t\\t? caretLine : s.startLine);\\n\\t\\tint newCaret = getLineStartOffset(line);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToEndOfLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line = (select || s == null\\n\\t\\t\\t? caretLine : s.endLine);\\n\\t\\tint newCaret = getLineEndOffset(line) - 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t\\t\\t\\t\\t\\t} \\n\\tpublic void goToStartOfWhiteSpace(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line, offset;\\n\\t\\tif(select || s == null)\\n\\t\\t{\\n\\t\\t\\tline = caretLine;\\n\\t\\t\\toffset = caret - buffer.getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tline = s.startLine;\\n\\t\\t\\toffset = s.start - buffer.getLineStartOffset(line);\\n\\t\\t}\\n\\t\\tint firstIndent = chunkCache.getSubregionStartOffset(line,offset);\\n\\t\\tif(firstIndent == getLineStartOffset(line))\\n\\t\\t{\\n\\t\\t\\tfirstIndent = MiscUtilities.getLeadingWhiteSpace(getLineText(line));\\n\\t\\t\\tif(firstIndent == getLineLength(line))\\n\\t\\t\\t\\tfirstIndent = 0;\\n\\t\\t\\tfirstIndent += getLineStartOffset(line);\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,firstIndent);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(firstIndent);\\n\\t} \\n\\tpublic void goToEndOfWhiteSpace(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line, offset;\\n\\t\\tif(select || s == null)\\n\\t\\t{\\n\\t\\t\\tline = caretLine;\\n\\t\\t\\toffset = caret - getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tline = s.endLine;\\n\\t\\t\\toffset = s.end - getLineStartOffset(line);\\n\\t\\t}\\n\\t\\tint lastIndent = chunkCache.getSubregionEndOffset(line,offset);\\n\\t\\tif(lastIndent == getLineEndOffset(line))\\n\\t\\t{\\n\\t\\t\\tlastIndent = getLineLength(line) - MiscUtilities.getTrailingWhiteSpace(getLineText(line));\\n\\t\\t\\tif(lastIndent == 0)\\n\\t\\t\\t\\tlastIndent = getLineLength(line);\\n\\t\\t\\tlastIndent += getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlastIndent--;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,lastIndent);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(lastIndent);\\n\\t} \\n\\tpublic void goToFirstVisibleLine(boolean select)\\n\\t{\\n\\t\\tint firstVisibleLine = getFirstLine() == 0 ? 0 : electricScroll;\\n\\t\\tint firstVisible = getScreenLineStartOffset(firstVisibleLine);\\n\\t\\tif(firstVisible == -1)\\n\\t\\t{\\n\\t\\t\\tfirstVisible = getLineStartOffset(displayManager\\n\\t\\t\\t\\t.getFirstVisibleLine());\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,firstVisible);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(firstVisible);\\n\\t} \\n\\tpublic void goToLastVisibleLine(boolean select)\\n\\t{\\n\\t\\tint lastVisible;\\n\\t\\tif(getFirstLine() + visibleLines >=\\n\\t\\t\\tdisplayManager.getScrollLineCount())\\n\\t\\t{\\n\\t\\t\\tlastVisible = getLineEndOffset(displayManager\\n\\t\\t\\t\\t.getLastVisibleLine()) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlastVisible = getScreenLineEndOffset(visibleLines\\n\\t\\t\\t\\t- electricScroll - 1) - 1;\\n\\t\\t\\tif(lastVisible == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlastVisible = getLineEndOffset(displayManager\\n\\t\\t\\t\\t\\t.getLastVisibleLine()) - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,lastVisible);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(lastVisible);\\n\\t} \\n\\tpublic void goToBufferStart(boolean select)\\n\\t{\\n\\t\\tint start = buffer.getLineStartOffset(\\n\\t\\t\\tdisplayManager.getFirstVisibleLine());\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,start);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(start);\\n\\t} \\n\\tpublic void goToBufferEnd(boolean select)\\n\\t{\\n\\t\\tint end = buffer.getLineEndOffset(\\n\\t\\t\\tdisplayManager.getLastVisibleLine()) - 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,end);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(end);\\n\\t} \\n\\tpublic void goToMatchingBracket()\\n\\t{\\n\\t\\tif(getLineLength(caretLine) != 0)\\n\\t\\t{\\n\\t\\t\\tint dot = caret - getLineStartOffset(caretLine);\\n\\t\\t\\tint bracket = TextUtilities.findMatchingBracket(\\n\\t\\t\\t\\tbuffer,caretLine,Math.max(0,dot - 1));\\n\\t\\t\\tif(bracket != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\t\\tmoveCaretPosition(bracket + 1,false);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tgetToolkit().beep();\\n\\t} \\n\\tpublic void showGoToLineDialog()\\n\\t{\\n\\t\\tString line = GUIUtilities.input(view,\\\"goto-line\\\",null);\\n\\t\\tif(line == null)\\n\\t\\t\\treturn;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tint lineNumber = Integer.parseInt(line) - 1;\\n\\t\\t\\tsetCaretPosition(getLineStartOffset(lineNumber));\\n\\t\\t}\\n\\t\\tcatch(Exception e)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t}\\n\\t} \\n\\tpublic void userInput(char ch)\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(ch == ' ' && Abbrevs.getExpandOnInput()\\n\\t\\t\\t&& Abbrevs.expandAbbrev(view,false))\\n\\t\\t\\treturn;\\n\\t\\telse if(ch == '\\\\t')\\n\\t\\t{\\n\\t\\t\\tif(selection.size() == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection sel = (Selection)selection.elementAt(0);\\n\\t\\t\\t\\tif(sel.startLine == sel.endLine\\n\\t\\t\\t\\t\\t&& (sel.start != buffer.getLineStartOffset(sel.startLine)\\n\\t\\t\\t\\t\\t|| sel.end != buffer.getLineEndOffset(sel.startLine) - 1))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tinsertTab();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tshiftIndentRight();\\n\\t\\t\\t}\\n\\t\\t\\telse if(selection.size() != 0)\\n\\t\\t\\t\\tshiftIndentRight();\\n\\t\\t\\telse\\n\\t\\t\\t\\tinsertTab();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tboolean indent;\\n\\t\\t\\t\\t\\t\\tString indentOpenBrackets = (String)buffer\\n\\t\\t\\t\\t.getProperty(\\\"indentOpenBrackets\\\");\\n\\t\\t\\tString indentCloseBrackets = (String)buffer\\n\\t\\t\\t\\t.getProperty(\\\"indentCloseBrackets\\\");\\n\\t\\t\\tif((indentCloseBrackets != null\\n\\t\\t\\t\\t&& indentCloseBrackets.indexOf(ch) != -1)\\n\\t\\t\\t\\t|| (indentOpenBrackets != null\\n\\t\\t\\t\\t&& indentOpenBrackets.indexOf(ch) != -1))\\n\\t\\t\\t{\\n\\t\\t\\t\\tindent = true;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tindent = false;\\n\\t\\t\\t}\\n\\t\\t\\tString str = String.valueOf(ch);\\n\\t\\t\\tSelection[] selection = getSelection();\\n\\t\\t\\tif(selection.length != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\t\\tsetSelectedText(s,str);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(ch == ' ')\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(doWordWrap(true))\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tdoWordWrap(false);\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(overwrite || indent)\\n\\t\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tif(overwrite)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint caretLineEnd = getLineEndOffset(caretLine);\\n\\t\\t\\t\\t\\tif(caretLineEnd - caret > 1)\\n\\t\\t\\t\\t\\t\\tbuffer.remove(caret,1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbuffer.insert(caret,str);\\n\\t\\t\\t\\tif(indent)\\n\\t\\t\\t\\t\\tbuffer.indentLine(caretLine,true);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(overwrite || indent)\\n\\t\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic final boolean isOverwriteEnabled()\\n\\t{\\n\\t\\treturn overwrite;\\n\\t} \\n\\tpublic final void setOverwriteEnabled(boolean overwrite)\\n\\t{\\n\\t\\tblink = true;\\n\\t\\tcaretTimer.restart();\\n\\t\\tthis.overwrite = overwrite;\\n\\t\\tinvalidateLine(caretLine);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t\\tview.getStatus().updateMiscStatus();\\n\\t} \\n\\tpublic final void toggleOverwriteEnabled()\\n\\t{\\n\\t\\tsetOverwriteEnabled(!overwrite);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t{\\n\\t\\t\\tview.getStatus().setMessageAndClear(\\n\\t\\t\\t\\tjEdit.getProperty(\\\"view.status.overwrite-changed\\\",\\n\\t\\t\\t\\tnew Integer[] { new Integer(overwrite ? 1 : 0) }));\\n\\t\\t}\\n\\t} \\n\\tpublic void backspace()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() != 0)\\n\\t\\t\\tsetSelectedText(null);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(caret == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.remove(caret - 1,1);\\n\\t\\t}\\n\\t} \\n\\tpublic void backspaceWord()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() != 0)\\n\\t\\t{\\n\\t\\t\\tsetSelectedText(\\\"\\\");\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint _caret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(_caret == 0)\\n\\t\\t{\\n\\t\\t\\tif(lineStart == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t_caret--;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\t_caret = TextUtilities.findWordStart(lineText,_caret-1,noWordSep);\\n\\t\\t}\\n\\t\\tbuffer.remove(_caret + lineStart,\\n\\t\\t\\tcaret - (_caret + lineStart));\\n\\t} \\n\\tpublic void delete()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() != 0)\\n\\t\\t\\tsetSelectedText(null);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(caret == buffer.getLength())\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.remove(caret,1);\\n\\t\\t}\\n\\t} \\n\\tpublic void deleteToEndOfLine()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.remove(caret,getLineEndOffset(caretLine)\\n\\t\\t\\t- caret - 1);\\n\\t} \\n\\tpublic void deleteLine()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine);\\n\\t\\tint x = chunkCache.subregionOffsetToX(caretLine,caret - start);\\n\\t\\t\\t\\t\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tif(end > buffer.getLength())\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(start != 0)\\n\\t\\t\\t\\t\\tstart--;\\n\\t\\t\\t\\tend--;\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tbuffer.remove(start,end - start);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\tint lastLine = displayManager.getLastVisibleLine();\\n\\t\\tif(caretLine == lastLine)\\n\\t\\t{\\n\\t\\t\\tint offset = chunkCache.xToSubregionOffset(lastLine,0,x,true);\\n\\t\\t\\tsetCaretPosition(buffer.getLineStartOffset(lastLine)\\n\\t\\t\\t\\t+ offset);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint offset = chunkCache.xToSubregionOffset(caretLine,0,x,true);\\n\\t\\t\\tsetCaretPosition(start + offset);\\n\\t\\t}\\n\\t} \\n\\tpublic void deleteParagraph()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint start = 0, end = buffer.getLength();\\nloop:\\t\\tfor(int i = caretLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tstart = getLineStartOffset(i);\\n\\t\\t\\tbreak loop;\\n\\t\\t}\\nloop:\\t\\tfor(int i = caretLine + 1; i < getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tend = getLineEndOffset(i) - 1;\\n\\t\\t\\tbreak loop;\\n\\t\\t}\\n\\t\\tbuffer.remove(start,end - start);\\n\\t} \\n\\tpublic void deleteToStartOfLine()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.remove(getLineStartOffset(caretLine),\\n\\t\\t\\tcaret - getLineStartOffset(caretLine));\\n\\t} \\n\\tpublic void deleteWord()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() != 0)\\n\\t\\t{\\n\\t\\t\\tsetSelectedText(\\\"\\\");\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint _caret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(_caret == lineText.length())\\n\\t\\t{\\n\\t\\t\\tif(lineStart + _caret == buffer.getLength())\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t_caret++;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\t_caret = TextUtilities.findWordEnd(lineText,\\n\\t\\t\\t\\t_caret+1,noWordSep);\\n\\t\\t}\\n\\t\\tbuffer.remove(caret,(_caret + lineStart) - caret);\\n\\t} \\n\\tpublic final boolean isMultipleSelectionEnabled()\\n\\t{\\n\\t\\treturn multi;\\n\\t} \\n\\tpublic final void toggleMultipleSelectionEnabled()\\n\\t{\\n\\t\\tsetMultipleSelectionEnabled(!multi);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t{\\n\\t\\t\\tview.getStatus().setMessageAndClear(\\n\\t\\t\\t\\tjEdit.getProperty(\\\"view.status.multi-changed\\\",\\n\\t\\t\\t\\tnew Integer[] { new Integer(multi ? 1 : 0) }));\\n\\t\\t}\\n\\t} \\n\\tpublic final void setMultipleSelectionEnabled(boolean multi)\\n\\t{\\n\\t\\tthis.multi = multi;\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t\\tview.getStatus().updateMiscStatus();\\n\\t\\tpainter.repaint();\\n\\t} \\n\\tpublic final boolean isRectangularSelectionEnabled()\\n\\t{\\n\\t\\treturn rectangularSelectionMode;\\n\\t} \\n\\tpublic final void toggleRectangularSelectionEnabled()\\n\\t{\\n\\t\\tsetRectangularSelectionEnabled(!rectangularSelectionMode);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t{\\n\\t\\t\\tview.getStatus().setMessageAndClear(\\n\\t\\t\\t\\tjEdit.getProperty(\\\"view.status.rect-select-changed\\\",\\n\\t\\t\\t\\tnew Integer[] { new Integer(rectangularSelectionMode ? 1 : 0) }));\\n\\t\\t}\\n\\t} \\n\\tpublic final void setRectangularSelectionEnabled(boolean rectangularSelectionMode)\\n\\t{\\n\\t\\tthis.rectangularSelectionMode = rectangularSelectionMode;\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t\\tview.getStatus().updateMiscStatus();\\n\\t\\tpainter.repaint();\\n\\t} \\n\\tpublic void goToMarker(char shortcut, boolean select)\\n\\t{\\n\\t\\tMarker marker = buffer.getMarker(shortcut);\\n\\t\\tif(marker == null)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint pos = marker.getPosition();\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,pos);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(pos);\\n\\t} \\n\\tpublic void addMarker()\\n\\t{\\n\\t\\t\\t\\tSelection[] selection = getSelection();\\n\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\tif(s.startLine != s.endLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s.startLine != caretLine)\\n\\t\\t\\t\\t\\tbuffer.addMarker('\\\\0',s.start);\\n\\t\\t\\t}\\n\\t\\t\\tif(s.endLine != caretLine)\\n\\t\\t\\t\\tbuffer.addMarker('\\\\0',s.end);\\n\\t\\t}\\n\\t\\t\\t\\tbuffer.addOrRemoveMarker('\\\\0',caret);\\n\\t} \\n\\tpublic void swapMarkerAndCaret(char shortcut)\\n\\t{\\n\\t\\tMarker marker = buffer.getMarker(shortcut);\\n\\t\\tif(marker == null)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint caret = getCaretPosition();\\n\\t\\tsetCaretPosition(marker.getPosition());\\n\\t\\tbuffer.addMarker(shortcut,caret);\\n\\t} \\n\\tpublic void goToParentFold()\\n\\t{\\n\\t\\tint line = -1;\\n\\t\\tint level = buffer.getFoldLevel(caretLine);\\n\\t\\tfor(int i = caretLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(buffer.getFoldLevel(i) < level)\\n\\t\\t\\t{\\n\\t\\t\\t\\tline = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(line == -1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = buffer.getLineStartOffset(line)\\n\\t\\t\\t+ chunkCache.xToSubregionOffset(line,0,magic + 1,true);\\n\\t\\tif(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToNextFold(boolean select)\\n\\t{\\n\\t\\tint nextFold = -1;\\n\\t\\tfor(int i = caretLine + 1; i < buffer.getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tif(buffer.isFoldStart(i)\\n\\t\\t\\t\\t&& displayManager.isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\tnextFold = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(nextFold == -1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = buffer.getLineStartOffset(nextFold)\\n\\t\\t\\t+ chunkCache.xToSubregionOffset(nextFold,0,magic + 1,true);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToPrevFold(boolean select)\\n\\t{\\n\\t\\tint prevFold = -1;\\n\\t\\tfor(int i = caretLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(buffer.isFoldStart(i)\\n\\t\\t\\t\\t&& displayManager.isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\tprevFold = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(prevFold == -1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = buffer.getLineStartOffset(prevFold)\\n\\t\\t\\t+ chunkCache.xToSubregionOffset(prevFold,0,magic + 1,true);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void collapseFold()\\n\\t{\\n\\t\\tint x = chunkCache.subregionOffsetToX(caretLine,\\n\\t\\t\\tcaret - getLineStartOffset(caretLine));\\n\\t\\tdisplayManager.collapseFold(caretLine);\\n\\t\\tif(displayManager.isLineVisible(caretLine))\\n\\t\\t\\treturn;\\n\\t\\tint line = displayManager.getPrevVisibleLine(caretLine);\\n\\t\\tif(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(buffer.getLineStartOffset(line)\\n\\t\\t\\t+ chunkCache.xToSubregionOffset(line,0,x,true));\\n\\t} \\n\\tpublic void expandFold(boolean fully)\\n\\t{\\n\\t\\tint x = chunkCache.subregionOffsetToX(caretLine,\\n\\t\\t\\tcaret - getLineStartOffset(caretLine));\\n\\t\\tint line = displayManager.expandFold(caretLine,fully);\\n\\t\\tif(!fully && line != -1)\\n\\t\\t{\\n\\t\\t\\tif(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\tmoveCaretPosition(getLineStartOffset(line)\\n\\t\\t\\t\\t+ chunkCache.xToSubregionOffset(line,0,x,true));\\n\\t\\t}\\n\\t} \\n\\tpublic void selectFold()\\n\\t{\\n\\t\\tselectFold(caretLine);\\n\\t} \\n\\tpublic void selectFold(int line)\\n\\t{\\n\\t\\tint[] lines = buffer.getFoldAtLine(line);\\n\\t\\tint newCaret = getLineEndOffset(lines[1]) - 1;\\n\\t\\tSelection s = new Selection.Range(getLineStartOffset(lines[0]),newCaret);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void narrowToFold()\\n\\t{\\n\\t\\tint[] lines = buffer.getFoldAtLine(caretLine);\\n\\t\\tif(lines[0] == 0 && lines[1] == buffer.getLineCount() - 1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t\\tdisplayManager.narrow(lines[0],lines[1]);\\n\\t} \\n\\tpublic void narrowToSelection()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tSelection sel = (Selection)selection.elementAt(0);\\n\\t\\tdisplayManager.narrow(sel.getStartLine(),sel.getEndLine());\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic void addExplicitFold()\\n\\t{\\n\\t\\tif(!buffer.getStringProperty(\\\"folding\\\").equals(\\\"explicit\\\"))\\n\\t\\t{\\n\\t\\t\\tGUIUtilities.error(view,\\\"folding-not-explicit\\\",null);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tString lineComment = buffer.getContextSensitiveProperty(caret,\\\"lineComment\\\");\\n\\t\\tString commentStart = buffer.getContextSensitiveProperty(caret,\\\"commentStart\\\");\\n\\t\\tString commentEnd = buffer.getContextSensitiveProperty(caret,\\\"commentEnd\\\");\\n\\t\\tString start, end;\\n\\t\\tif(lineComment != null)\\n\\t\\t{\\n\\t\\t\\tstart = lineComment + \\\"{{{ \\\\n\\\";\\n\\t\\t\\tend = lineComment + \\\"}}}\\\";\\n\\t\\t}\\n\\t\\telse if(commentStart != null && commentEnd != null)\\n\\t\\t{\\n\\t\\t\\tstart = commentStart + \\\"{{{  \\\" + commentEnd + \\\"\\\\n\\\";\\n\\t\\t\\tend = commentStart + \\\"}}}\\\" + commentEnd;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstart = \\\"{{{ \\\\n\\\";\\n\\t\\t\\tend = \\\"}}}\\\";\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tif(selection.size() == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tString line = buffer.getLineText(caretLine);\\n\\t\\t\\t\\tString whitespace = line.substring(0,\\n\\t\\t\\t\\t\\tMiscUtilities.getLeadingWhiteSpace(line));\\n\\t\\t\\t\\tint loc = caret + start.length() - 1;\\n\\t\\t\\t\\tstart = start + whitespace;\\n\\t\\t\\t\\tbuffer.insert(caret,start);\\n\\t\\t\\t\\t\\t\\t\\t\\tbuffer.insert(caret,end);\\n\\t\\t\\t\\tmoveCaretPosition(loc,false);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint loc = -1;\\n\\t\\t\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\t\\t\\tString line = buffer.getLineText(s.startLine);\\n\\t\\t\\t\\t\\tString whitespace = line.substring(0,\\n\\t\\t\\t\\t\\t\\tMiscUtilities.getLeadingWhiteSpace(line));\\n\\t\\t\\t\\t\\tloc = s.start + start.length() - 1;\\n\\t\\t\\t\\t\\tbuffer.insert(s.start,start + whitespace);\\n\\t\\t\\t\\t\\tbuffer.insert(s.end,\\\" \\\" + end);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsetCaretPosition(loc,false);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void lineComment()\\n\\t{\\n\\t\\tString comment = buffer.getContextSensitiveProperty(caret,\\\"lineComment\\\");\\n\\t\\tif(!buffer.isEditable() || comment == null || comment.length() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tcomment = comment + ' ';\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tint[] lines = getSelectedLines();\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < lines.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tString text = getLineText(lines[i]);\\n\\t\\t\\t\\tbuffer.insert(getLineStartOffset(lines[i])\\n\\t\\t\\t\\t\\t+ MiscUtilities.getLeadingWhiteSpace(text),\\n\\t\\t\\t\\t\\tcomment);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic void rangeComment()\\n\\t{\\n\\t\\tString commentStart = buffer.getContextSensitiveProperty(caret,\\\"commentStart\\\");\\n\\t\\tString commentEnd = buffer.getContextSensitiveProperty(caret,\\\"commentEnd\\\");\\n\\t\\tif(!buffer.isEditable() || commentStart == null || commentEnd == null\\n\\t\\t\\t|| commentStart.length() == 0 || commentEnd.length() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tcommentStart = commentStart + ' ';\\n\\t\\tcommentEnd = ' ' + commentEnd;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tSelection[] selection = getSelection();\\n\\t\\t\\tif(selection.length == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint oldCaret = caret;\\n\\t\\t\\t\\tbuffer.insert(caret,commentStart);\\n\\t\\t\\t\\tbuffer.insert(caret,commentEnd);\\n\\t\\t\\t\\tsetCaretPosition(oldCaret + commentStart.length());\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tif(s instanceof Selection.Range)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbuffer.insert(s.start,commentStart);\\n\\t\\t\\t\\t\\tbuffer.insert(s.end,commentEnd);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(s instanceof Selection.Rect)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection.Rect rect = (Selection.Rect)s;\\n\\t\\t\\t\\t\\tint start = rect.getStartColumn(buffer);\\n\\t\\t\\t\\t\\tint end = rect.getEndColumn(buffer);\\n\\t\\t\\t\\t\\tfor(int j = s.startLine; j <= s.endLine; j++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.insertAtColumn(j,end,\\n\\t\\t\\t\\t\\t\\t\\tcommentEnd);\\n\\t\\t\\t\\t\\t\\tbuffer.insertAtColumn(j,start,\\n\\t\\t\\t\\t\\t\\t\\tcommentStart);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tselectNone();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void formatParagraph()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(maxLineLen <= 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(selection.length != 0)\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tsetSelectedText(s,TextUtilities.format(\\n\\t\\t\\t\\t\\tgetSelectedText(s),maxLineLen,\\n\\t\\t\\t\\t\\tbuffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint lineNo = getCaretLine();\\n\\t\\t\\tint start = 0, end = buffer.getLength();\\nloop:\\t\\t\\tfor(int i = lineNo - 1; i >= 0; i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstart = getLineEndOffset(i);\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\nloop:\\t\\t\\tfor(int i = lineNo + 1; i < getLineCount(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tend = getLineStartOffset(i) - 1;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tString text = buffer.getText(start,end - start);\\n\\t\\t\\t\\tbuffer.remove(start,end - start);\\n\\t\\t\\t\\tbuffer.insert(start,TextUtilities.format(\\n\\t\\t\\t\\t\\ttext,maxLineLen,buffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic void spacesToTabs()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tif(selection.length == 0)\\n\\t\\t{\\n\\t\\t\\tsetText(TextUtilities.spacesToTabs(\\n\\t\\t\\t\\tgetText(), buffer.getTabSize()));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tsetSelectedText(s,TextUtilities.spacesToTabs(\\n\\t\\t\\t\\t\\tgetSelectedText(s),buffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void tabsToSpaces()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tif(selection.length == 0)\\n\\t\\t{\\n\\t\\t\\tsetText(TextUtilities.tabsToSpaces(\\n\\t\\t\\t\\tgetText(), buffer.getTabSize()));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tsetSelectedText(s,TextUtilities.tabsToSpaces(\\n\\t\\t\\t\\t\\tgetSelectedText(s),buffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void toUpperCase()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable() || selection.length == 0)\\n                {\\n                \\tgetToolkit().beep();\\n                \\treturn;\\n                }\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\tsetSelectedText(s,getSelectedText(s).toUpperCase());\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void toLowerCase()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable() || selection.length == 0)\\n                {\\n                \\tgetToolkit().beep();\\n                \\treturn;\\n                }\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\tsetSelectedText(s,getSelectedText(s).toLowerCase());\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void removeTrailingWhiteSpace()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbuffer.removeTrailingWhiteSpace(getSelectedLines());\\n\\t\\t}\\n\\t} \\n\\t\\tpublic void insertEnterAndIndent()\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tsetSelectedText(\\\"\\\\n\\\");\\n\\t\\t\\t\\tbuffer.indentLine(caretLine,true);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tpublic void insertTabAndIndent()\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() == 0)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tString text = buffer.getLineText(caretLine);\\n\\t\\t\\tint start = buffer.getLineStartOffset(caretLine);\\n\\t\\t\\tint whiteSpace = MiscUtilities.getLeadingWhiteSpace(text);\\n\\t\\t\\tif(caret - start <= whiteSpace\\n\\t\\t\\t\\t&& buffer.indentLine(caretLine,false))\\n\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tuserInput('\\\\t');\\n\\t} \\n\\tpublic void indentSelectedLines()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbuffer.indentLines(getSelectedLines());\\n\\t\\t\\tselectNone();\\n\\t\\t}\\n\\t} \\n\\tpublic void shiftIndentLeft()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbuffer.shiftIndentLeft(getSelectedLines());\\n\\t\\t}\\n\\t} \\n\\tpublic void shiftIndentRight()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t\\tbuffer.shiftIndentRight(getSelectedLines());\\n\\t} \\n\\tpublic void joinLines()\\n\\t{\\n\\t\\tint end = getLineEndOffset(caretLine);\\n\\t\\tif(end > buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.remove(end - 1,MiscUtilities.getLeadingWhiteSpace(\\n\\t\\t\\tbuffer.getLineText(caretLine + 1)) + 1);\\n\\t\\tsetCaretPosition(end - 1);\\n\\t} \\n\\tpublic void showWordCountDialog()\\n\\t{\\n\\t\\tString selection = getSelectedText();\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tdoWordCount(view,selection);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tdoWordCount(view,buffer.getText(0,buffer.getLength()));\\n\\t} \\n\\tpublic void addLeftOfScrollBar(Component comp)\\n\\t{\\n\\t\\tverticalBox.add(comp,verticalBox.getComponentCount() - 1);\\n\\t} \\n\\tpublic void removeLeftOfScrollBar(Component comp)\\n\\t{\\n\\t\\tverticalBox.remove(comp);\\n\\t} \\n\\tpublic void addNotify()\\n\\t{\\n\\t\\tsuper.addNotify();\\n\\t\\tToolTipManager.sharedInstance().registerComponent(painter);\\n\\t\\tToolTipManager.sharedInstance().registerComponent(gutter);\\n\\t\\tif(!bufferHandlerInstalled)\\n\\t\\t{\\n\\t\\t\\tbufferHandlerInstalled = true;\\n\\t\\t\\tbuffer.addBufferChangeListener(bufferHandler);\\n\\t\\t}\\n\\t\\trecalculateVisibleLines();\\n\\t\\tif(buffer.isLoaded())\\n\\t\\t\\trecalculateLastPhysicalLine();\\n\\t\\tpropertiesChanged();\\n\\t} \\n\\tpublic void removeNotify()\\n\\t{\\n\\t\\tsuper.removeNotify();\\n\\t\\tToolTipManager.sharedInstance().unregisterComponent(painter);\\n\\t\\tToolTipManager.sharedInstance().unregisterComponent(gutter);\\n\\t\\tif(focusedComponent == this)\\n\\t\\t\\tfocusedComponent = null;\\n\\t\\tif(bufferHandlerInstalled)\\n\\t\\t{\\n\\t\\t\\tbuffer.removeBufferChangeListener(bufferHandler);\\n\\t\\t\\tbufferHandlerInstalled = false;\\n\\t\\t}\\n\\t} \\n\\tpublic boolean getFocusTraversalKeysEnabled()\\n\\t{\\n\\t\\treturn false;\\n\\t} \\n\\t\\tpublic void processKeyEvent(KeyEvent evt)\\n\\t{\\n\\t\\tview.processKeyEvent(evt,true);\\n\\t\\tif(!evt.isConsumed())\\n\\t\\t\\tsuper.processKeyEvent(evt);\\n\\t} \\n\\tpublic void propertiesChanged()\\n\\t{\\n\\t\\tif(buffer == null)\\n\\t\\t\\treturn;\\n\\t\\tint _tabSize = buffer.getTabSize();\\n\\t\\tchar[] foo = new char[_tabSize];\\n\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t{\\n\\t\\t\\tfoo[i] = ' ';\\n\\t\\t}\\n\\t\\ttabSize = (float)painter.getFont().getStringBounds(foo,0,_tabSize,\\n\\t\\t\\tpainter.getFontRenderContext()).getWidth();\\n\\t\\tcharWidth = (int)Math.round(painter.getFont().getStringBounds(foo,0,1,\\n\\t\\t\\tpainter.getFontRenderContext()).getWidth());\\n\\t\\tString wrap = buffer.getStringProperty(\\\"wrap\\\");\\n\\t\\thardWrap = wrap.equals(\\\"hard\\\");\\n\\t\\tmaxLineLen = buffer.getIntegerProperty(\\\"maxLineLen\\\",0);\\n\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\tif(displayManager != null && !bufferChanging)\\n\\t\\t\\tdisplayManager.updateWrapSettings();\\n\\t\\tchunkCache.invalidateAll();\\n\\t\\tgutter.repaint();\\n\\t\\tpainter.repaint();\\n\\t} \\n\\tpublic final int getSelectionStart()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getStart();\\n\\t} \\n\\tpublic int getSelectionStart(int line)\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getStart(\\n\\t\\t\\tbuffer,line);\\n\\t} \\n\\tpublic final int getSelectionStartLine()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getStartLine();\\n\\t} \\n\\tpublic final void setSelectionStart(int selectionStart)\\n\\t{\\n\\t\\tselect(selectionStart,getSelectionEnd(),true);\\n\\t} \\n\\tpublic final int getSelectionEnd()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getEnd();\\n\\t} \\n\\tpublic int getSelectionEnd(int line)\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getEnd(\\n\\t\\t\\tbuffer,line);\\n\\t} \\n\\tpublic final int getSelectionEndLine()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getEndLine();\\n\\t} \\n\\tpublic final void setSelectionEnd(int selectionEnd)\\n\\t{\\n\\t\\tselect(getSelectionStart(),selectionEnd,true);\\n\\t} \\n\\tpublic final int getMarkPosition()\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(s == null)\\n\\t\\t\\treturn caret;\\n\\t\\tif(s.start == caret)\\n\\t\\t\\treturn s.end;\\n\\t\\telse if(s.end == caret)\\n\\t\\t\\treturn s.start;\\n\\t\\telse\\n\\t\\t\\treturn caret;\\n\\t} \\n\\tpublic final int getMarkLine()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caretLine;\\n\\t\\tSelection s = (Selection)selection.elementAt(0);\\n\\t\\tif(s.start == caret)\\n\\t\\t\\treturn s.endLine;\\n\\t\\telse if(s.end == caret)\\n\\t\\t\\treturn s.startLine;\\n\\t\\telse\\n\\t\\t\\treturn caretLine;\\n\\t} \\n\\tpublic void select(int start, int end)\\n\\t{\\n\\t\\tselect(start,end,true);\\n\\t} \\n\\tpublic void select(int start, int end, boolean doElectricScroll)\\n\\t{\\n\\t\\tselectNone();\\n\\t\\tint newStart, newEnd;\\n\\t\\tif(start < end)\\n\\t\\t{\\n\\t\\t\\tnewStart = start;\\n\\t\\t\\tnewEnd = end;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tnewStart = end;\\n\\t\\t\\tnewEnd = start;\\n\\t\\t}\\n\\t\\tsetSelection(new Selection.Range(newStart,newEnd));\\n\\t\\tmoveCaretPosition(end,doElectricScroll);\\n\\t} \\n\\tpublic boolean isSelectionRectangular()\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(s == null)\\n\\t\\t\\treturn false;\\n\\t\\telse\\n\\t\\t\\treturn (s instanceof Selection.Rect);\\n\\t} \\n\\t\\tSegment lineSegment;\\n\\tMouseHandler mouseHandler;\\n\\tChunkCache chunkCache;\\n\\tDisplayManager displayManager;\\n\\tboolean bufferChanging;\\n\\tint maxHorizontalScrollWidth;\\n\\tboolean updateMaxHorizontalScrollWidth;\\n\\tboolean hardWrap;\\n\\tfloat tabSize;\\n\\tint charWidth;\\n\\tint maxLineLen;\\n\\tboolean scrollBarsInitialized;\\n\\t\\t\\t\\t\\t\\t\\tboolean queuedScrollTo;\\n\\tboolean queuedScrollToElectric;\\n\\tboolean queuedFireCaretEvent;\\n\\tArrayList runnables;\\n\\t\\t\\tVector selection;\\n\\t\\tPoint returnValue;\\n\\tboolean lastLinePartial;\\n\\tfinal boolean isCaretVisible()\\n\\t{\\n\\t\\treturn blink && hasFocus();\\n\\t} \\n\\tfinal boolean isBracketHighlightVisible()\\n\\t{\\n\\t\\treturn bracketLine != -1\\n\\t\\t\\t&& hasFocus()\\n\\t\\t\\t&& displayManager.isLineVisible(bracketLine)\\n\\t\\t\\t&& displayManager.isLineVisible(caretLine);\\n\\t} \\n\\t\\tvoid updateMaxHorizontalScrollWidth()\\n\\t{\\n\\t\\tint max = chunkCache.getMaxHorizontalScrollWidth();\\n\\t\\tif(max != maxHorizontalScrollWidth)\\n\\t\\t{\\n\\t\\t\\tmaxHorizontalScrollWidth = max;\\n\\t\\t\\thorizontal.setValues(Math.max(0,\\n\\t\\t\\t\\tMath.min(maxHorizontalScrollWidth + charWidth\\n\\t\\t\\t\\t- painter.getWidth(),\\n\\t\\t\\t\\t-horizontalOffset)),\\n\\t\\t\\t\\tpainter.getWidth(),\\n\\t\\t\\t\\t0,maxHorizontalScrollWidth\\n\\t\\t\\t\\t+ charWidth);\\n\\t\\t}\\n\\t} \\n\\t\\tvoid recalculateVisibleLines()\\n\\t{\\n\\t\\tif(painter == null)\\n\\t\\t\\treturn;\\n\\t\\tint height = painter.getHeight();\\n\\t\\tint lineHeight = painter.getFontMetrics().getHeight();\\n\\t\\tvisibleLines = height / lineHeight;\\n\\t\\tlastLinePartial = (height % lineHeight != 0);\\n\\t\\tif(lastLinePartial)\\n\\t\\t\\tvisibleLines++;\\n\\t\\tchunkCache.recalculateVisibleLines();\\n\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\t\\t\\tif(displayManager != null && buffer != null && buffer.isLoaded())\\n\\t\\t\\tsetFirstLine(getFirstLine());\\n\\t\\tupdateScrollBars();\\n\\t} \\n\\t\\tvoid foldStructureChanged()\\n\\t{\\n\\t\\tchunkCache.invalidateAll();\\n\\t\\trecalculateLastPhysicalLine();\\n\\t\\trepaint();\\n\\t} \\n\\tvoid updateScrollBars()\\n\\t{\\n\\t\\tif(buffer == null)\\n\\t\\t\\treturn;\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"updateScrollBars()\\\");\\n\\t\\tif(vertical != null && visibleLines != 0)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"Vertical ok\\\");\\n\\t\\t\\tint lineCount = displayManager.getScrollLineCount();\\n\\t\\t\\tint firstLine = getFirstLine();\\n\\t\\t\\tint visible = visibleLines - (lastLinePartial ? 1 : 0);\\n\\t\\t\\tvertical.setValues(firstLine,visible,0,lineCount);\\n\\t\\t\\tvertical.setUnitIncrement(2);\\n\\t\\t\\tvertical.setBlockIncrement(visible);\\n\\t\\t}\\n\\t\\tint width = painter.getWidth();\\n\\t\\tif(horizontal != null && width != 0)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"Horizontal ok\\\");\\n\\t\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\t\\tpainter.repaint();\\n\\t\\t\\thorizontal.setUnitIncrement(painter.getFontMetrics()\\n\\t\\t\\t\\t.charWidth('w'));\\n\\t\\t\\thorizontal.setBlockIncrement(width / 2);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate static String CENTER = \\\"center\\\";\\n\\tprivate static String RIGHT = \\\"right\\\";\\n\\tprivate static String LEFT = \\\"left\\\";\\n\\tprivate static String BOTTOM = \\\"bottom\\\";\\n\\tprivate static Timer caretTimer;\\n\\tprivate static Timer bracketTimer;\\n\\tprivate static JEditTextArea focusedComponent;\\n\\t\\tprivate View view;\\n\\tprivate Gutter gutter;\\n\\tprivate TextAreaPainter painter;\\n\\tprivate JPopupMenu popup;\\n\\tprivate EventListenerList listenerList;\\n\\tprivate MutableCaretEvent caretEvent;\\n\\tprivate boolean caretBlinks;\\n\\tprivate boolean blink;\\n\\tprivate int physLastLine;\\n\\tprivate int screenLastLine;\\n\\tprivate int visibleLines;\\n\\tprivate int electricScroll;\\n\\tprivate int horizontalOffset;\\n\\tprivate boolean quickCopy;\\n\\t\\tprivate Box verticalBox;\\n\\tprivate JScrollBar vertical;\\n\\tprivate JScrollBar horizontal;\\n\\tprivate Buffer buffer;\\n\\tprivate BufferChangeHandler bufferHandler;\\n\\tprivate boolean bufferHandlerInstalled;\\n\\tprivate int caret;\\n\\tprivate int caretLine;\\n\\tprivate int caretScreenLine;\\n\\tprivate int bracketPosition;\\n\\tprivate int bracketLine;\\n\\tprivate int magicCaret;\\n\\tprivate boolean multi;\\n\\tprivate boolean overwrite;\\n\\tprivate boolean rectangularSelectionMode;\\n\\tprivate boolean delayedScrollTo;\\n\\t\\tprivate void _addToSelection(Selection addMe)\\n\\t{\\n\\t\\tif(addMe.start > addMe.end)\\n\\t\\t{\\n\\t\\t\\tthrow new IllegalArgumentException(addMe.start\\n\\t\\t\\t\\t+ \\\" > \\\" + addMe.end);\\n\\t\\t}\\n\\t\\telse if(addMe.start == addMe.end)\\n\\t\\t{\\n\\t\\t\\tif(addMe instanceof Selection.Range)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\telse if(addMe instanceof Selection.Rect)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(((Selection.Rect)addMe).extraEndVirt == 0)\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tif(s.overlaps(addMe))\\n\\t\\t\\t{\\n\\t\\t\\t\\taddMe.start = Math.min(s.start,addMe.start);\\n\\t\\t\\t\\taddMe.end = Math.max(s.end,addMe.end);\\n\\t\\t\\t\\tselection.removeElement(s);\\n\\t\\t\\t\\ti--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\taddMe.startLine = getLineOfOffset(addMe.start);\\n\\t\\taddMe.endLine = getLineOfOffset(addMe.end);\\n\\t\\tboolean added = false;\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tif(addMe.start < s.start)\\n\\t\\t\\t{\\n\\t\\t\\t\\tselection.insertElementAt(addMe,i);\\n\\t\\t\\t\\tadded = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(!added)\\n\\t\\t\\tselection.addElement(addMe);\\n\\t\\tinvalidateLineRange(addMe.startLine,addMe.endLine);\\n\\t} \\n\\tprivate void finishCaretUpdate(boolean doElectricScroll,\\n\\t\\tboolean fireCaretEvent)\\n\\t{\\n\\t\\tthis.queuedScrollToElectric |= doElectricScroll;\\n\\t\\tthis.queuedFireCaretEvent |= fireCaretEvent;\\n\\t\\tif(queuedScrollTo)\\n\\t\\t\\treturn;\\n\\t\\tRunnable r = new Runnable()\\n\\t\\t{\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tblink = true;\\n\\t\\t\\t\\tcaretTimer.restart();\\n\\t\\t\\t\\tscrollToCaret(queuedScrollToElectric);\\n\\t\\t\\t\\tupdateBracketHighlightWithDelay();\\n\\t\\t\\t\\tif(queuedFireCaretEvent)\\n\\t\\t\\t\\t\\tfireCaretEvent();\\n\\t\\t\\t\\tqueuedScrollTo = queuedScrollToElectric\\n\\t\\t\\t\\t\\t= queuedFireCaretEvent = false;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tif(buffer.isTransactionInProgress())\\n\\t\\t{\\n\\t\\t\\tqueuedScrollTo = true;\\n\\t\\t\\trunnables.add(r);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tr.run();\\n\\t} \\n\\t\\tprivate void fireCaretEvent()\\n\\t{\\n\\t\\tObject[] listeners = listenerList.getListenerList();\\n\\t\\tfor(int i = listeners.length - 2; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(listeners[i] == CaretListener.class)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t((CaretListener)listeners[i+1]).caretUpdate(caretEvent);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireScrollEvent(boolean vertical)\\n\\t{\\n\\t\\tObject[] listeners = listenerList.getListenerList();\\n\\t\\tfor(int i = listeners.length - 2; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(listeners[i] == ScrollListener.class)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(vertical)\\n\\t\\t\\t\\t\\t\\t((ScrollListener)listeners[i+1]).scrolledVertically(this);\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t((ScrollListener)listeners[i+1]).scrolledHorizontally(this);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void insertTab()\\n\\t{\\n\\t\\tint tabSize = buffer.getTabSize();\\n\\t\\tif(buffer.getBooleanProperty(\\\"noTabs\\\"))\\n\\t\\t{\\n\\t\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\t\\tString line = getText(lineStart,caret - lineStart);\\n\\t\\t\\tint pos = 0;\\n\\t\\t\\tfor(int i = 0; i < line.length(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(line.charAt(pos))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tpos = 0;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif(++pos >= tabSize)\\n\\t\\t\\t\\t\\t\\tpos = 0;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tsetSelectedText(MiscUtilities.createWhiteSpace(\\n\\t\\t\\t\\ttabSize - pos,0));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tsetSelectedText(\\\"\\\\t\\\");\\n\\t} \\n\\t\\tprivate boolean doWordWrap(boolean spaceInserted)\\n\\t{\\n\\t\\tif(!hardWrap || maxLineLen <= 0)\\n\\t\\t\\treturn false;\\n\\t\\tbuffer.getLineText(caretLine,lineSegment);\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine);\\n\\t\\tint len = end - start - 1;\\n\\t\\tint caretPos = caret - start;\\n\\t\\t\\t\\t\\t\\tfor(int i = caretPos; i < len; i++)\\n\\t\\t{\\n\\t\\t\\tchar ch = lineSegment.array[lineSegment.offset + i];\\n\\t\\t\\tif(ch != ' ' && ch != '\\\\t')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tboolean returnValue = false;\\n\\t\\tint tabSize = buffer.getTabSize();\\n\\t\\tString wordBreakChars = buffer.getStringProperty(\\\"wordBreakChars\\\");\\n\\t\\tint logicalLength = 0; \\t\\tint lastWordOffset = -1;\\n\\t\\tboolean lastWasSpace = true;\\n\\t\\tfor(int i = 0; i < caretPos; i++)\\n\\t\\t{\\n\\t\\t\\tchar ch = lineSegment.array[lineSegment.offset + i];\\n\\t\\t\\tif(ch == '\\\\t')\\n\\t\\t\\t{\\n\\t\\t\\t\\tlogicalLength += tabSize - (logicalLength % tabSize);\\n\\t\\t\\t\\tif(!lastWasSpace && logicalLength <= maxLineLen)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastWordOffset = i;\\n\\t\\t\\t\\t\\tlastWasSpace = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(ch == ' ')\\n\\t\\t\\t{\\n\\t\\t\\t\\tlogicalLength++;\\n\\t\\t\\t\\tif(!lastWasSpace && logicalLength <= maxLineLen)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastWordOffset = i;\\n\\t\\t\\t\\t\\tlastWasSpace = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(wordBreakChars != null && wordBreakChars.indexOf(ch) != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlogicalLength++;\\n\\t\\t\\t\\tif(!lastWasSpace && logicalLength <= maxLineLen)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastWordOffset = i;\\n\\t\\t\\t\\t\\tlastWasSpace = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tlogicalLength++;\\n\\t\\t\\t\\tlastWasSpace = false;\\n\\t\\t\\t}\\n\\t\\t\\tint insertNewLineAt;\\n\\t\\t\\tif(spaceInserted && logicalLength == maxLineLen\\n\\t\\t\\t\\t&& i == caretPos - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsertNewLineAt = caretPos;\\n\\t\\t\\t\\treturnValue = true;\\n\\t\\t\\t}\\n\\t\\t\\telse if(logicalLength >= maxLineLen && lastWordOffset != -1)\\n\\t\\t\\t\\tinsertNewLineAt = lastWordOffset;\\n\\t\\t\\telse\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tbuffer.insert(start + insertNewLineAt,\\\"\\\\n\\\");\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbuffer.indentLine(caretLine,true);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t\\treturn returnValue;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t} \\n\\t\\tprivate void doWordCount(View view, String text)\\n\\t{\\n\\t\\tchar[] chars = text.toCharArray();\\n\\t\\tint characters = chars.length;\\n\\t\\tint words;\\n\\t\\tif(characters == 0)\\n\\t\\t\\twords = 0;\\n\\t\\telse\\n\\t\\t\\twords = 1;\\n\\t\\tint lines = 1;\\n\\t\\tboolean word = false;\\n\\t\\tfor(int i = 0; i < chars.length; i++)\\n\\t\\t{\\n\\t\\t\\tswitch(chars[i])\\n\\t\\t\\t{\\n\\t\\t\\tcase '\\\\r': case '\\\\n':\\n\\t\\t\\t\\tlines++;\\n\\t\\t\\tcase ' ': case '\\\\t':\\n\\t\\t\\t\\tif(word)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twords++;\\n\\t\\t\\t\\t\\tword = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tword = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tObject[] args = { new Integer(characters), new Integer(words),\\n\\t\\t\\tnew Integer(lines) };\\n\\t\\tGUIUtilities.message(view,\\\"wordcount\\\",args);\\n\\t} \\n\\t\\tprivate void updateBracketHighlightWithDelay()\\n\\t{\\n\\t\\tbracketTimer.stop();\\n\\t\\tbracketTimer.start();\\n\\t} \\n\\t\\tprivate void updateBracketHighlight()\\n\\t{\\n\\t\\tif(!painter.isBracketHighlightEnabled()\\n\\t\\t\\t&& !gutter.isBracketHighlightEnabled())\\n\\t\\t\\treturn;\\n\\t\\tint offset = caret - getLineStartOffset(caretLine);\\n\\t\\tif(offset != 0)\\n\\t\\t{\\n\\t\\t\\tint bracketOffset = TextUtilities.findMatchingBracket(\\n\\t\\t\\t\\tbuffer,caretLine,offset - 1);\\n\\t\\t\\tif(bracketOffset != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbracketLine = getLineOfOffset(bracketOffset);\\n\\t\\t\\t\\tbracketPosition = bracketOffset\\n\\t\\t\\t\\t\\t- getLineStartOffset(bracketLine);\\n\\t\\t\\t\\tinvalidateLineRange(bracketLine,caretLine);\\n\\t\\t\\t\\tif(chunkCache.getScreenLineOfOffset(bracketLine,bracketPosition) == -1)\\n\\t\\t\\t\\t\\tshowBracketStatusMessage(bracketLine < caretLine);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbracketLine = bracketPosition = -1;\\n\\t} \\n\\t\\tprivate void showBracketStatusMessage(boolean backward)\\n\\t{\\n\\t\\tString text = buffer.getLineText(bracketLine).trim();\\n\\t\\tif(backward && bracketLine != 0 && text.length() == 1)\\n\\t\\t{\\n\\t\\t\\tswitch(text.charAt(0))\\n\\t\\t\\t{\\n\\t\\t\\tcase '{': case '}':\\n\\t\\t\\tcase '[': case ']':\\n\\t\\t\\tcase '(': case ')':\\n\\t\\t\\t\\ttext = buffer.getLineText(bracketLine - 1).trim()\\n\\t\\t\\t\\t\\t+ \\\" \\\" + text;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\ttext = text.replace('\\\\t',' ');\\n\\t\\tview.getStatus().setMessageAndClear(jEdit.getProperty(\\n\\t\\t\\t\\\"view.status.bracket\\\",new Object[] { \\n\\t\\t\\tnew Integer(bracketLine), text }));\\n\\t} \\n\\t\\tvoid recalculateLastPhysicalLine()\\n\\t{\\n\\t\\tint oldScreenLastLine = screenLastLine;\\n\\t\\tfor(int i = visibleLines - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(i);\\n\\t\\t\\tif(info.physicalLine != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tphysLastLine = info.physicalLine;\\n\\t\\t\\t\\tscreenLastLine = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tinvalidateScreenLineRange(oldScreenLastLine,screenLastLine);\\n\\t} \\n\\t\\tstatic class RectParams\\n\\t{\\n\\t\\tint extraStartVirt;\\n\\t\\tint extraEndVirt;\\n\\t\\tint newCaret;\\n\\t\\tRectParams(int extraStartVirt, int extraEndVirt, int newCaret)\\n\\t\\t{\\n\\t\\t\\tthis.extraStartVirt = extraStartVirt;\\n\\t\\t\\tthis.extraEndVirt = extraEndVirt;\\n\\t\\t\\tthis.newCaret = newCaret;\\n\\t\\t}\\n\\t}\\n\\tprivate RectParams getRectParams(int caret, int newCaret)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint virtualWidth;\\n\\t\\tif(s instanceof Selection.Rect)\\n\\t\\t{\\n\\t\\t\\tif(caret == s.end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvirtualWidth = buffer.getVirtualWidth(\\n\\t\\t\\t\\t\\ts.endLine,s.end - getLineStartOffset(\\n\\t\\t\\t\\t\\ts.endLine)) + ((Selection.Rect)s).extraEndVirt;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tvirtualWidth = buffer.getVirtualWidth(\\n\\t\\t\\t\\t\\ts.startLine,s.start - getLineStartOffset(\\n\\t\\t\\t\\t\\ts.startLine)) + ((Selection.Rect)s).extraStartVirt;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(rectangularSelectionMode)\\n\\t\\t{\\n\\t\\t\\tvirtualWidth = buffer.getVirtualWidth(\\n\\t\\t\\t\\tcaretLine,caret - buffer.getLineStartOffset(caretLine));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn null;\\n\\t\\tint newLine = getLineOfOffset(newCaret);\\n\\t\\tint[] totalVirtualWidth = new int[1];\\n\\t\\tint newOffset = buffer.getOffsetOfVirtualColumn(newLine,\\n\\t\\t\\tvirtualWidth,totalVirtualWidth);\\n\\t\\tif(newOffset == -1)\\n\\t\\t{\\n\\t\\t\\tint extraVirt = virtualWidth - totalVirtualWidth[0];\\n\\t\\t\\tnewCaret = getLineEndOffset(newLine) - 1;\\n\\t\\t\\tRectParams returnValue;\\n\\t\\t\\tboolean bias;\\n\\t\\t\\tif(s == null)\\n\\t\\t\\t\\tbias = (newCaret < caret);\\n\\t\\t\\telse if(s.start == caret)\\n\\t\\t\\t\\tbias = (newCaret <= s.end);\\n\\t\\t\\telse if(s.end == caret)\\n\\t\\t\\t\\tbias = (newCaret <= s.start);\\n\\t\\t\\telse\\n\\t\\t\\t\\tbias = false;\\n\\t\\t\\tif(bias)\\n\\t\\t\\t\\treturnValue = new RectParams(extraVirt,0,newCaret);\\n\\t\\t\\telse\\n\\t\\t\\t\\treturnValue = new RectParams(0,extraVirt,newCaret);\\n\\t\\t\\treturn returnValue;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\treturn new RectParams(0,0,getLineStartOffset(newLine)\\n\\t\\t\\t\\t+ newOffset);\\n\\t\\t}\\n\\t} \\n\\t\\tstatic class TextAreaBorder extends AbstractBorder\\n\\t{\\n\\t\\tprivate static final Insets insets = new Insets(1, 1, 2, 2);\\n\\t\\t\\t\\tpublic void paintBorder(Component c, Graphics g, int x, int y,\\n\\t\\t\\tint width, int height)\\n\\t\\t{\\n\\t\\t\\tg.translate(x,y);\\n\\t\\t\\tg.setColor(MetalLookAndFeel.getControlDarkShadow());\\n\\t\\t\\tg.drawRect(0,0,width-2,height-2);\\n\\t\\t\\tg.setColor(MetalLookAndFeel.getControlHighlight());\\n\\t\\t\\tg.drawLine(width-1,1,width-1,height-1);\\n\\t\\t\\tg.drawLine(1,height-1,width-1,height-1);\\n\\t\\t\\tg.setColor(MetalLookAndFeel.getControl());\\n\\t\\t\\tg.drawLine(width-2,2,width-2,2);\\n\\t\\t\\tg.drawLine(1,height-2,1,height-2);\\n\\t\\t\\tg.translate(-x,-y);\\n\\t\\t} \\n\\t\\t\\t\\tpublic Insets getBorderInsets(Component c)\\n\\t\\t{\\n\\t\\t\\treturn new Insets(1,1,2,2);\\n\\t\\t} \\t} \\n\\t\\tclass ScrollLayout implements LayoutManager\\n\\t{\\n\\t\\t\\t\\tpublic void addLayoutComponent(String name, Component comp)\\n\\t\\t{\\n\\t\\t\\tif(name.equals(CENTER))\\n\\t\\t\\t\\tcenter = comp;\\n\\t\\t\\telse if(name.equals(RIGHT))\\n\\t\\t\\t\\tright = comp;\\n\\t\\t\\telse if(name.equals(LEFT))\\n\\t\\t\\t\\tleft = comp;\\n\\t\\t\\telse if(name.equals(BOTTOM))\\n\\t\\t\\t\\tbottom = comp;\\n\\t\\t} \\n\\t\\t\\t\\tpublic void removeLayoutComponent(Component comp)\\n\\t\\t{\\n\\t\\t\\tif(center == comp)\\n\\t\\t\\t\\tcenter = null;\\n\\t\\t\\telse if(right == comp)\\n\\t\\t\\t\\tright = null;\\n\\t\\t\\telse if(left == comp)\\n\\t\\t\\t\\tleft = null;\\n\\t\\t\\telse if(bottom == comp)\\n\\t\\t\\t\\tbottom = null;\\n\\t\\t} \\n\\t\\t\\t\\tpublic Dimension preferredLayoutSize(Container parent)\\n\\t\\t{\\n\\t\\t\\tDimension dim = new Dimension();\\n\\t\\t\\tBorder border = getBorder();\\n\\t\\t\\tInsets insets;\\n\\t\\t\\tif(border == null)\\n\\t\\t\\t\\tinsets = new Insets(0,0,0,0);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsets = getBorder().getBorderInsets(\\n\\t\\t\\t\\t\\tJEditTextArea.this);\\n\\t\\t\\t}\\n\\t\\t\\tdim.width = insets.left + insets.right;\\n\\t\\t\\tdim.height = insets.top + insets.bottom;\\n\\t\\t\\tDimension leftPref = left.getPreferredSize();\\n\\t\\t\\tdim.width += leftPref.width;\\n\\t\\t\\tDimension centerPref = center.getPreferredSize();\\n\\t\\t\\tdim.width += centerPref.width;\\n\\t\\t\\tdim.height += centerPref.height;\\n\\t\\t\\tDimension rightPref = right.getPreferredSize();\\n\\t\\t\\tdim.width += rightPref.width;\\n\\t\\t\\tDimension bottomPref = bottom.getPreferredSize();\\n\\t\\t\\tdim.height += bottomPref.height;\\n\\t\\t\\treturn dim;\\n\\t\\t} \\n\\t\\t\\t\\tpublic Dimension minimumLayoutSize(Container parent)\\n\\t\\t{\\n\\t\\t\\tDimension dim = new Dimension();\\n\\t\\t\\tBorder border = getBorder();\\n\\t\\t\\tInsets insets;\\n\\t\\t\\tif(border == null)\\n\\t\\t\\t\\tinsets = new Insets(0,0,0,0);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsets = getBorder().getBorderInsets(\\n\\t\\t\\t\\t\\tJEditTextArea.this);\\n\\t\\t\\t}\\n\\t\\t\\tdim.width = insets.left + insets.right;\\n\\t\\t\\tdim.height = insets.top + insets.bottom;\\n\\t\\t\\tDimension leftPref = left.getMinimumSize();\\n\\t\\t\\tdim.width += leftPref.width;\\n\\t\\t\\tDimension centerPref = center.getMinimumSize();\\n\\t\\t\\tdim.width += centerPref.width; \\n\\t\\t\\tdim.height += centerPref.height;\\n\\t\\t\\tDimension rightPref = right.getMinimumSize();\\n\\t\\t\\tdim.width += rightPref.width;\\n\\t\\t\\tDimension bottomPref = bottom.getMinimumSize();\\n\\t\\t\\tdim.height += bottomPref.height;\\n\\t\\t\\treturn dim;\\n\\t\\t} \\n\\t\\t\\t\\tpublic void layoutContainer(Container parent)\\n\\t\\t{\\n\\t\\t\\tDimension size = parent.getSize();\\n\\t\\t\\tBorder border = getBorder();\\n\\t\\t\\tInsets insets;\\n\\t\\t\\tif(border == null)\\n\\t\\t\\t\\tinsets = new Insets(0,0,0,0);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsets = getBorder().getBorderInsets(\\n\\t\\t\\t\\t\\tJEditTextArea.this);\\n\\t\\t\\t}\\n\\t\\t\\tint itop = insets.top;\\n\\t\\t\\tint ileft = insets.left;\\n\\t\\t\\tint ibottom = insets.bottom;\\n\\t\\t\\tint iright = insets.right;\\n\\t\\t\\tint rightWidth = right.getPreferredSize().width;\\n\\t\\t\\tint leftWidth = left.getPreferredSize().width;\\n\\t\\t\\tint bottomHeight = bottom.getPreferredSize().height;\\n\\t\\t\\tint centerWidth = Math.max(0,size.width - leftWidth\\n\\t\\t\\t\\t- rightWidth - ileft - iright);\\n\\t\\t\\tint centerHeight = Math.max(0,size.height\\n\\t\\t\\t\\t- bottomHeight - itop - ibottom);\\n\\t\\t\\tleft.setBounds(\\n\\t\\t\\t\\tileft,\\n\\t\\t\\t\\titop,\\n\\t\\t\\t\\tleftWidth,\\n\\t\\t\\t\\tcenterHeight);\\n\\t\\t\\tcenter.setBounds(\\n\\t\\t\\t\\tileft + leftWidth,\\n\\t\\t\\t\\titop,\\n\\t\\t\\t\\tcenterWidth,\\n\\t\\t\\t\\tcenterHeight);\\n\\t\\t\\tright.setBounds(\\n\\t\\t\\t\\tileft + leftWidth + centerWidth,\\n\\t\\t\\t\\titop,\\n\\t\\t\\t\\trightWidth,\\n\\t\\t\\t\\tcenterHeight);\\n\\t\\t\\tbottom.setBounds(\\n\\t\\t\\t\\tileft,\\n\\t\\t\\t\\titop + centerHeight,\\n\\t\\t\\t\\tMath.max(0,size.width - vertical.getWidth()\\n\\t\\t\\t\\t\\t- ileft - iright),\\n\\t\\t\\t\\tbottomHeight);\\n\\t\\t} \\n\\t\\tComponent center;\\n\\t\\tComponent left;\\n\\t\\tComponent right;\\n\\t\\tComponent bottom;\\n\\t} \\n\\t\\tstatic class CaretBlinker implements ActionListener\\n\\t{\\n\\t\\t\\t\\tpublic void actionPerformed(ActionEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(focusedComponent != null && focusedComponent.hasFocus())\\n\\t\\t\\t\\tfocusedComponent.blinkCaret();\\n\\t\\t} \\t} \\n\\t\\tclass MutableCaretEvent extends CaretEvent\\n\\t{\\n\\t\\t\\t\\tMutableCaretEvent()\\n\\t\\t{\\n\\t\\t\\tsuper(JEditTextArea.this);\\n\\t\\t} \\n\\t\\t\\t\\tpublic int getDot()\\n\\t\\t{\\n\\t\\t\\treturn getCaretPosition();\\n\\t\\t} \\n\\t\\t\\t\\tpublic int getMark()\\n\\t\\t{\\n\\t\\t\\treturn getMarkPosition();\\n\\t\\t} \\t} \\n\\t\\tclass AdjustHandler implements AdjustmentListener\\n\\t{\\n\\t\\t\\t\\tpublic void adjustmentValueChanged(final AdjustmentEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(!scrollBarsInitialized)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(evt.getAdjustable() == vertical)\\n\\t\\t\\t\\tsetFirstLine(vertical.getValue());\\n\\t\\t\\telse\\n\\t\\t\\t\\tsetHorizontalOffset(-horizontal.getValue());\\n\\t\\t} \\t} \\n\\tclass BufferChangeHandler extends BufferChangeAdapter\\n\\t{\\n\\t\\tboolean delayedUpdate;\\n\\t\\tboolean delayedMultilineUpdate;\\n\\t\\tint delayedRepaintStart;\\n\\t\\tint delayedRepaintEnd;\\n\\t\\t\\t\\tpublic void foldLevelChanged(Buffer buffer, int start, int end)\\n\\t\\t{\\n\\t\\t\\tif(!bufferChanging && end != 0\\n\\t\\t\\t\\t&& buffer.isLoaded())\\n\\t\\t\\t{\\n\\t\\t\\t\\tinvalidateLineRange(start - 1,\\n\\t\\t\\t\\t\\tgetLastPhysicalLine());\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void contentInserted(Buffer buffer, int startLine, int start,\\n\\t\\t\\tint numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t\\tdelayedMultilineUpdate = true;\\n\\t\\t\\tint endLine = startLine + numLines;\\n\\t\\t\\tdelayedRepaint(startLine,endLine);\\n\\t\\t\\t\\t\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\t\\tif(s.contentInserted(buffer,startLine,start,\\n\\t\\t\\t\\t\\tnumLines,length))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdelayedRepaint(s.startLine,s.endLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(!buffer.isTransactionInProgress())\\n\\t\\t\\t\\ttransactionComplete(buffer);\\n\\t\\t\\tif(caret >= start)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint scrollMode = (hasFocus()\\n\\t\\t\\t\\t\\t? ELECTRIC_SCROLL : NO_SCROLL);\\n\\t\\t\\t\\tmoveCaretPosition(caret + length,scrollMode);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint scrollMode = (hasFocus()\\n\\t\\t\\t\\t\\t? NORMAL_SCROLL : NO_SCROLL);\\n\\t\\t\\t\\tmoveCaretPosition(caret,scrollMode);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tpublic void contentRemoved(Buffer buffer, int startLine, int start,\\n\\t\\t\\tint numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t\\tdelayedMultilineUpdate = true;\\n\\t\\t\\tdelayedRepaint(startLine,startLine);\\n\\t\\t\\t\\t\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\t\\tint oldStartLine = s.startLine;\\n\\t\\t\\t\\tint oldEndLine = s.endLine;\\n\\t\\t\\t\\tboolean changed = s.contentRemoved(buffer,\\n\\t\\t\\t\\t\\tstartLine,start,numLines,length);\\n\\t\\t\\t\\tif(s.start == s.end)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tselection.removeElement(s);\\n\\t\\t\\t\\t\\tdelayedRepaint(oldStartLine,oldEndLine);\\n\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(changed)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdelayedRepaint(s.startLine,s.endLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\tint scrollMode = (hasFocus()\\n\\t\\t\\t\\t? NORMAL_SCROLL : NO_SCROLL);\\n\\t\\t\\tif(caret > start)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caret <= start + length)\\n\\t\\t\\t\\t\\tmoveCaretPosition(start,scrollMode);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmoveCaretPosition(caret - length,scrollMode);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tmoveCaretPosition(caret,scrollMode);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(!buffer.isTransactionInProgress())\\n\\t\\t\\t\\ttransactionComplete(buffer);\\n\\t\\t}\\n\\t\\t\\t\\tpublic void transactionComplete(Buffer buffer)\\n\\t\\t{\\n\\t\\t\\tif(delayedUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(delayedMultilineUpdate)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tinvalidateScreenLineRange(chunkCache\\n\\t\\t\\t\\t\\t\\t.getScreenLineOfOffset(\\n\\t\\t\\t\\t\\t\\tdelayedRepaintStart,0),\\n\\t\\t\\t\\t\\t\\tvisibleLines);\\n\\t\\t\\t\\t\\tdelayedMultilineUpdate = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tinvalidateLineRange(delayedRepaintStart,\\n\\t\\t\\t\\t\\t\\tdelayedRepaintEnd);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdelayedUpdate = false;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < runnables.size(); i++)\\n\\t\\t\\t\\t((Runnable)runnables.get(i)).run();\\n\\t\\t\\trunnables.clear();\\n\\t\\t} \\n\\t\\t\\t\\tprivate void delayedRepaint(int startLine, int endLine)\\n\\t\\t{\\n\\t\\t\\tchunkCache.invalidateChunksFromPhys(startLine);\\n\\t\\t\\tif(!delayedUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedRepaintStart = startLine;\\n\\t\\t\\t\\tdelayedRepaintEnd = endLine;\\n\\t\\t\\t\\tdelayedUpdate = true;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedRepaintStart = Math.min(\\n\\t\\t\\t\\t\\tdelayedRepaintStart,\\n\\t\\t\\t\\t\\tstartLine);\\n\\t\\t\\t\\tdelayedRepaintEnd = Math.max(\\n\\t\\t\\t\\t\\tdelayedRepaintEnd,\\n\\t\\t\\t\\t\\tendLine);\\n\\t\\t\\t}\\n\\t\\t} \\t} \\n\\t\\tclass FocusHandler implements FocusListener\\n\\t{\\n\\t\\t\\t\\tpublic void focusGained(FocusEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(bufferChanging)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(bracketLine != -1)\\n\\t\\t\\t\\tinvalidateLineRange(bracketLine,caretLine);\\n\\t\\t\\telse\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t\\tfocusedComponent = JEditTextArea.this;\\n\\t\\t} \\n\\t\\t\\t\\tpublic void focusLost(FocusEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(!isShowing())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(bracketLine != -1)\\n\\t\\t\\t\\tinvalidateLineRange(bracketLine,caretLine);\\n\\t\\t\\telse\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t} \\t} \\n\\t\\tclass MouseHandler extends MouseInputAdapter\\n\\t{\\n\\t\\tprivate int dragStartLine;\\n\\t\\tprivate int dragStartOffset;\\n\\t\\tprivate int dragStart;\\n\\t\\tprivate int clickCount;\\n\\t\\tprivate boolean dragged;\\n\\t\\tprivate boolean quickCopyDrag;\\n\\t\\tprivate boolean clearStatus;\\n\\t\\tprivate boolean control;\\n\\t\\t\\t\\tpublic void mousePressed(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tcontrol = (OperatingSystem.isMacOS() && evt.isMetaDown())\\n\\t\\t\\t\\t|| (!OperatingSystem.isMacOS() && evt.isControlDown());\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tview.getInputHandler().resetLastActionCount();\\n\\t\\t\\tquickCopyDrag = (isQuickCopyEnabled() &&\\n\\t\\t\\t\\tGUIUtilities.isMiddleButton(evt.getModifiers()));\\n\\t\\t\\tif(!quickCopyDrag)\\n\\t\\t\\t{\\n\\t\\t\\t\\trequestFocus();\\n\\t\\t\\t\\tfocusedComponent = JEditTextArea.this;\\n\\t\\t\\t}\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tint x = evt.getX();\\n\\t\\t\\tint y = evt.getY();\\n\\t\\t\\tdragStart = xyToOffset(x,y,!(painter.isBlockCaretEnabled()\\n\\t\\t\\t\\t|| isOverwriteEnabled()));\\n\\t\\t\\tdragStartLine = getLineOfOffset(dragStart);\\n\\t\\t\\tdragStartOffset = dragStart - getLineStartOffset(dragStartLine);\\n\\t\\t\\tif(GUIUtilities.isPopupTrigger(evt) && popup != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(popup.isVisible())\\n\\t\\t\\t\\t\\tpopup.setVisible(false);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(getSelectionCount() == 0 || multi)\\n\\t\\t\\t\\t\\t\\tmoveCaretPosition(dragStart,false);\\n\\t\\t\\t\\t\\tGUIUtilities.showPopupMenu(popup,painter,\\n\\t\\t\\t\\t\\t\\tevt.getX(),evt.getY());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tdragged = false;\\n\\t\\t\\tblink = true;\\n\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t\\tclickCount = evt.getClickCount();\\n\\t\\t\\tswitch(clickCount)\\n\\t\\t\\t{\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\tdoSingleClick(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\tdoDoubleClick(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault: \\t\\t\\t\\tdoTripleClick(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doSingleClick(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tint x = evt.getX();\\n\\t\\t\\tint extraEndVirt = 0;\\n\\t\\t\\tif(chunkCache.getLineInfo(screenLastLine).lastSubregion)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfloat dragStartLineWidth = offsetToXY(\\n\\t\\t\\t\\t\\tdragStartLine,getLineLength(dragStartLine),\\n\\t\\t\\t\\t\\treturnValue).x;\\n\\t\\t\\t\\tif(x > dragStartLineWidth)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\textraEndVirt = (int)(\\n\\t\\t\\t\\t\\t\\t(x - dragStartLineWidth)\\n\\t\\t\\t\\t\\t\\t/ charWidth);\\n\\t\\t\\t\\t\\tif(!getPainter().isBlockCaretEnabled()\\n\\t\\t\\t\\t\\t\\t&& !isOverwriteEnabled()\\n\\t\\t\\t\\t\\t\\t&& (x - getHorizontalOffset()) % charWidth > charWidth / 2)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\textraEndVirt++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(control || isRectangularSelectionEnabled())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint screenLine = (evt.getY() / getPainter()\\n\\t\\t\\t\\t\\t.getFontMetrics().getHeight());\\n\\t\\t\\t\\tif(screenLine > screenLastLine)\\n\\t\\t\\t\\t\\tscreenLine = screenLastLine;\\n\\t\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(screenLine);\\n\\t\\t\\t\\tif(info.lastSubregion)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tString whitespace = MiscUtilities\\n\\t\\t\\t\\t\\t\\t.createWhiteSpace(extraEndVirt,0);\\n\\t\\t\\t\\t\\tbuffer.insert(dragStart,whitespace);\\n\\t\\t\\t\\t\\tdragStart += whitespace.length();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(evt.isShiftDown())\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tresizeSelection(getMarkPosition(),dragStart,extraEndVirt,\\n\\t\\t\\t\\t\\tisRectangularSelectionEnabled()\\n\\t\\t\\t\\t\\t|| control);\\n\\t\\t\\t\\tif(!quickCopyDrag)\\n\\t\\t\\t\\t\\tmoveCaretPosition(dragStart,false);\\n\\t\\t\\t\\t\\t\\t\\t\\tdragStartLine = getMarkLine();\\n\\t\\t\\t\\tdragStart = getMarkPosition();\\n\\t\\t\\t\\tdragStartOffset = dragStart\\n\\t\\t\\t\\t\\t- getLineStartOffset(dragStartLine);\\n\\t\\t\\t\\t\\t\\t\\t\\tdragged = true;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(!quickCopyDrag)\\n\\t\\t\\t\\tmoveCaretPosition(dragStart,false);\\n\\t\\t\\tif(!(multi || quickCopyDrag))\\n\\t\\t\\t\\tselectNone();\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doDoubleClick(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(getLineLength(dragStartLine) == 0)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tString lineText = getLineText(dragStartLine);\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tif(dragStartOffset == getLineLength(dragStartLine))\\n\\t\\t\\t\\tdragStartOffset--;\\n\\t\\t\\tboolean joinNonWordChars =\\n\\t\\t\\t\\tjEdit.getBooleanProperty(\\\"view.joinNonWordChars\\\");\\n\\t\\t\\tint wordStart = TextUtilities.findWordStart(lineText,\\n\\t\\t\\t\\tdragStartOffset,noWordSep,joinNonWordChars);\\n\\t\\t\\tint wordEnd = TextUtilities.findWordEnd(lineText,\\n\\t\\t\\t\\tdragStartOffset+1,noWordSep,joinNonWordChars);\\n\\t\\t\\tint lineStart = getLineStartOffset(dragStartLine);\\n\\t\\t\\tSelection sel = new Selection.Range(\\n\\t\\t\\t\\tlineStart + wordStart,\\n\\t\\t\\t\\tlineStart + wordEnd);\\n\\t\\t\\tif(isMultipleSelectionEnabled())\\n\\t\\t\\t\\taddToSelection(sel);\\n\\t\\t\\telse\\n\\t\\t\\t\\tsetSelection(sel);\\n\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t\\tquickCopyDrag = false;\\n\\t\\t\\tmoveCaretPosition(lineStart + wordEnd,false);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdragged = true;\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doTripleClick(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tint newCaret = getLineEndOffset(dragStartLine);\\n\\t\\t\\tif(dragStartLine == buffer.getLineCount() - 1)\\n\\t\\t\\t\\tnewCaret--;\\n\\t\\t\\tSelection sel = new Selection.Range(\\n\\t\\t\\t\\tgetLineStartOffset(dragStartLine),\\n\\t\\t\\t\\tnewCaret);\\n\\t\\t\\tif(isMultipleSelectionEnabled())\\n\\t\\t\\t\\taddToSelection(sel);\\n\\t\\t\\telse\\n\\t\\t\\t\\tsetSelection(sel);\\n\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t\\tquickCopyDrag = false;\\n\\t\\t\\tmoveCaretPosition(newCaret,false);\\n\\t\\t} \\n\\t\\t\\t\\tpublic void mouseDragged(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(GUIUtilities.isPopupTrigger(evt)\\n\\t\\t\\t\\t|| (popup != null && popup.isVisible()))\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(evt.getY() < 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint delta = Math.min(-1,evt.getY()\\n\\t\\t\\t\\t\\t/ painter.getFontMetrics()\\n\\t\\t\\t\\t\\t.getHeight());\\n\\t\\t\\t\\tsetFirstLine(getFirstLine() + delta);\\n\\t\\t\\t}\\n\\t\\t\\telse if(evt.getY() >= painter.getHeight())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint delta = Math.max(1,(evt.getY()\\n\\t\\t\\t\\t\\t- painter.getHeight()) /\\n\\t\\t\\t\\t\\tpainter.getFontMetrics()\\n\\t\\t\\t\\t\\t.getHeight());\\n\\t\\t\\t\\tif(lastLinePartial)\\n\\t\\t\\t\\t\\tdelta--;\\n\\t\\t\\t\\tsetFirstLine(getFirstLine() + delta);\\n\\t\\t\\t}\\n\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t{\\n\\t\\t\\t\\tview.getStatus().setMessage(jEdit.getProperty(\\n\\t\\t\\t\\t\\t\\\"view.status.rect-quick-copy\\\"));\\n\\t\\t\\t\\tclearStatus = true;\\n\\t\\t\\t}\\n\\t\\t\\tswitch(clickCount)\\n\\t\\t\\t{\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\tdoSingleDrag(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\tdoDoubleDrag(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault: \\t\\t\\t\\tdoTripleDrag(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doSingleDrag(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tdragged = true;\\n\\t\\t\\tint x = evt.getX();\\n\\t\\t\\tint y = evt.getY();\\n\\t\\t\\tif(y < 0)\\n\\t\\t\\t\\ty = 0;\\n\\t\\t\\telse if(y >= painter.getHeight())\\n\\t\\t\\t\\ty = painter.getHeight() - 1;\\n\\t\\t\\tint dot = xyToOffset(x,y,\\n\\t\\t\\t\\t(!painter.isBlockCaretEnabled()\\n\\t\\t\\t\\t&& !isOverwriteEnabled())\\n\\t\\t\\t\\t|| quickCopyDrag);\\n\\t\\t\\tint dotLine = buffer.getLineOfOffset(dot);\\n\\t\\t\\tint extraEndVirt = 0;\\n\\t\\t\\tif(chunkCache.getLineInfo(screenLastLine).lastSubregion)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfloat dotLineWidth = offsetToXY(dotLine,getLineLength(dotLine),\\n\\t\\t\\t\\t\\treturnValue).x;\\n\\t\\t\\t\\tif(x > dotLineWidth)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\textraEndVirt = (int)((x - dotLineWidth) / charWidth);\\n\\t\\t\\t\\t\\tif(!getPainter().isBlockCaretEnabled()\\n\\t\\t\\t\\t\\t\\t&& !isOverwriteEnabled()\\n\\t\\t\\t\\t\\t\\t&& (x - getHorizontalOffset()) % charWidth > charWidth / 2)\\n\\t\\t\\t\\t\\t\\textraEndVirt++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tresizeSelection(dragStart,dot,extraEndVirt,\\n\\t\\t\\t\\tisRectangularSelectionEnabled()\\n\\t\\t\\t\\t|| control);\\n\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tscrollTo(dotLine,dot - buffer.getLineStartOffset(dotLine),false);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(dot != caret)\\n\\t\\t\\t\\t\\tmoveCaretPosition(dot,false);\\n\\t\\t\\t\\tif(isRectangularSelectionEnabled()\\n\\t\\t\\t\\t\\t&& extraEndVirt != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscrollTo(dotLine,dot - buffer.getLineStartOffset(dotLine)\\n\\t\\t\\t\\t\\t\\t+ extraEndVirt,false);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doDoubleDrag(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tint markLineStart = getLineStartOffset(dragStartLine);\\n\\t\\t\\tint markLineLength = getLineLength(dragStartLine);\\n\\t\\t\\tint mark = dragStartOffset;\\n\\t\\t\\tint pos = xyToOffset(evt.getX(),\\n\\t\\t\\t\\tMath.max(0,Math.min(painter.getHeight(),evt.getY())),\\n\\t\\t\\t\\t!(painter.isBlockCaretEnabled() || isOverwriteEnabled()));\\n\\t\\t\\tint line = getLineOfOffset(pos);\\n\\t\\t\\tint lineStart = getLineStartOffset(line);\\n\\t\\t\\tint lineLength = getLineLength(line);\\n\\t\\t\\tint offset = pos - lineStart;\\n\\t\\t\\tString lineText = getLineText(line);\\n\\t\\t\\tString markLineText = getLineText(dragStartLine);\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tboolean joinNonWordChars =\\n\\t\\t\\t\\tjEdit.getBooleanProperty(\\\"view.joinNonWordChars\\\");\\n\\t\\t\\tif(markLineStart + dragStartOffset > lineStart + offset)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(offset != 0 && offset != lineLength)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\toffset = TextUtilities.findWordStart(\\n\\t\\t\\t\\t\\t\\tlineText,offset,noWordSep,\\n\\t\\t\\t\\t\\t\\tjoinNonWordChars);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(markLineLength != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmark = TextUtilities.findWordEnd(\\n\\t\\t\\t\\t\\t\\tmarkLineText,mark,noWordSep,\\n\\t\\t\\t\\t\\t\\tjoinNonWordChars);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(offset != 0 && lineLength != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\toffset = TextUtilities.findWordEnd(\\n\\t\\t\\t\\t\\t\\tlineText,offset,noWordSep,\\n\\t\\t\\t\\t\\t\\tjoinNonWordChars);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(mark != 0 && mark != markLineLength)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmark = TextUtilities.findWordStart(\\n\\t\\t\\t\\t\\t\\tmarkLineText,mark,noWordSep,\\n\\t\\t\\t\\t\\t\\tjoinNonWordChars);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(lineStart + offset == caret)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tresizeSelection(markLineStart + mark,lineStart + offset,\\n\\t\\t\\t\\t0,false);\\n\\t\\t\\tif(!quickCopyDrag)\\n\\t\\t\\t\\tmoveCaretPosition(lineStart + offset,false);\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doTripleDrag(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tint offset = xyToOffset(evt.getX(),\\n\\t\\t\\t\\tMath.max(0,Math.min(painter.getHeight(),evt.getY())),\\n\\t\\t\\t\\tfalse);\\n\\t\\t\\tint mouseLine = getLineOfOffset(offset);\\n\\t\\t\\tint mark;\\n\\t\\t\\tint mouse;\\n\\t\\t\\tif(dragStartLine > mouseLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmark = getLineEndOffset(dragStartLine) - 1;\\n\\t\\t\\t\\tif(offset == getLineEndOffset(mouseLine) - 1)\\n\\t\\t\\t\\t\\tmouse = offset;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmouse = getLineStartOffset(mouseLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tmark = getLineStartOffset(dragStartLine);\\n\\t\\t\\t\\tif(offset == getLineStartOffset(mouseLine))\\n\\t\\t\\t\\t\\tmouse = offset;\\n\\t\\t\\t\\telse if(offset == getLineEndOffset(mouseLine) - 1\\n\\t\\t\\t\\t\\t&& mouseLine != getBuffer().getLineCount() - 1)\\n\\t\\t\\t\\t\\tmouse = getLineEndOffset(mouseLine);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmouse = getLineEndOffset(mouseLine) - 1;\\n\\t\\t\\t}\\n\\t\\t\\tmouse = Math.min(getBuffer().getLength(),mouse);\\n\\t\\t\\tif(mouse == caret)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tdragged = true;\\n\\t\\t\\tresizeSelection(mark,mouse,0,false);\\n\\t\\t\\tmoveCaretPosition(mouse,false);\\n\\t\\t} \\n\\t\\t\\t\\tpublic void mouseReleased(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tSelection sel = getSelectionAtOffset(dragStart);\\n\\t\\t\\tif(dragged && sel != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tRegisters.setRegister('%',getSelectedText(sel));\\n\\t\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tremoveFromSelection(sel);\\n\\t\\t\\t\\t\\tRegisters.paste(focusedComponent,\\n\\t\\t\\t\\t\\t\\t'%',sel instanceof Selection.Rect);\\n\\t\\t\\t\\t\\tfocusedComponent.requestFocus();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(isQuickCopyEnabled()\\n\\t\\t\\t\\t&& GUIUtilities.isMiddleButton(evt.getModifiers()))\\n\\t\\t\\t{\\n\\t\\t\\t\\tJEditTextArea.this.requestFocus();\\n\\t\\t\\t\\tfocusedComponent = JEditTextArea.this;\\n\\t\\t\\t\\tsetCaretPosition(dragStart,false);\\n\\t\\t\\t\\tif(!isEditable())\\n\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tRegisters.paste(JEditTextArea.this,'%',control);\\n\\t\\t\\t}\\n\\t\\t\\tdragged = false;\\n\\t\\t\\tif(clearStatus)\\n\\t\\t\\t{\\n\\t\\t\\t\\tclearStatus = false;\\n\\t\\t\\t\\tview.getStatus().setMessage(null);\\n\\t\\t\\t}\\n\\t\\t} \\t} \\n\\t\\tstatic\\n\\t{\\n\\t\\tcaretTimer = new Timer(500,new CaretBlinker());\\n\\t\\tcaretTimer.setInitialDelay(500);\\n\\t\\tcaretTimer.start();\\n\\t\\tbracketTimer = new Timer(200,new ActionListener()\\n\\t\\t{\\n\\t\\t\\tpublic void actionPerformed(ActionEvent evt)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(focusedComponent != null)\\n\\t\\t\\t\\t\\tfocusedComponent.updateBracketHighlight();\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tbracketTimer.setInitialDelay(200);\\n\\t\\tbracketTimer.setRepeats(false);\\n\\t} }\""
        },
        {
            "role": "user",
            "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
        },
        {
            "content": "Title: Diagnosis of starting entity `jEdit.java`\n\nChange set: [JEditTextArea, PluginJAR, Buffer, MiscUtilities, GUIUtilities, DockableWindowManager, View, ActionContext, SearchAndReplace, KillRing, HelpViewer, VFSBrowser, TextAreaPainter, Gutter, BeanShell, Macros, PluginManager, Registers, Mode, DisplayManager, EditPane, PropertiesChanged, BufferChangeHandler, InputHandler, HistoryModel, BufferHistory, PropertyManager, DefaultInputHandler, VFS, ServiceManager, ToolBarOptionPane, GeneralOptionPane, Abbrevs, ShortcutsOptionPane, JEditActionContext, KeyHandler, OperatingSystem, Log, DockableWindowConfig, OptionsDialog, HyperSearchResults, Statusbar, PluginList, PluginUpdate, PluginError, PluginResURLConnection, JARClassLoader, TextAreaTransferHandler]\n\nDetails:\n- **JEditTextArea**: High conceptual coupling (0.8465) with jEdit; heavily used for text editing and UI interaction.\n- **PluginJAR**: Directly involved in plugin management and loading; core to startup and extension logic.\n- **Buffer**: Central to file handling; frequently co-changed with jEdit.\n- **MiscUtilities**: Widely used utility class; changes affect global behavior.\n- **GUIUtilities**: Manages UI components; tightly linked to jEdit\u2019s visual behavior.\n- **DockableWindowManager**: Controls dockable windows; co-change support indicates integration.\n- **View**: Core view container; often modified alongside jEdit.\n- **ActionContext**: Manages actions; key to command execution framework.\n- **SearchAndReplace**: Frequently used feature; shows high co-change confidence.\n- **KillRing**: Clipboard management tied to buffer operations.\n- **HelpViewer**: Invoked during startup if help is enabled.\n- **VFSBrowser**: Used in file browsing and selection workflows.\n- **TextAreaPainter**: Renders text content; interacts with buffer display.\n- **Gutter**: Part of the text area UI; displays line numbers, markers.\n- **BeanShell**: For scripting and macro execution from jEdit.\n- **Macros**: Used to manage user macros; integrates with buffers.\n- **PluginManager**: Responsible for plugin lifecycle; loaded early on.\n- **Registers**: Manages clipboard registers; related to copy/paste functionality.\n- **Mode**: Syntax mode associated with files/buffer types.\n- **DisplayManager**: Coordinates how buffers are displayed.\n- **EditPane**: Displays the edit session; closely linked to views.\n- **PropertiesChanged**: Listens to property updates initiated by jEdit.\n- **BufferChangeHandler**: Reacts to buffer state changes from jEdit.\n- **InputHandler**: Handles input events; connects to main jEdit actions.\n- **HistoryModel**: Maintains history; jEdit modifies this during usage.\n- **BufferHistory**: Tracks file access history; saved/loaded by jEdit.\n- **PropertyManager**: Central property handling mechanism.\n- **DefaultInputHandler**: Base handler for inputs driven by jEdit.\n- **VFS**: Virtual file system used across buffer and plugin interactions.\n- **ServiceManager**: Enables service lookup for plugins and extensions.\n- **ToolBarOptionPane**: Configures toolbars managed by jEdit.\n- **GeneralOptionPane**: Global settings pane for preferences.\n- **Abbrevs**: Abbreviation handling tied to text entry in jEdit.\n- **ShortcutsOptionPane**: Modifies keyboard shortcuts used by jEdit.\n- **JEditActionContext**: Context for action execution within jEdit.\n- **KeyHandler**: Processes key strokes, which may be configured via jEdit.\n- **OperatingSystem**: OS-specific behaviors influence UI and IO.\n- **Log**: Logging is extensively used by jEdit for diagnostics.\n- **DockableWindowConfig**: Configuration for dockables managed by jEdit.\n- **OptionsDialog**: Manages options that affect jEdit's behavior.\n- **HyperSearchResults**: Related to search workflows initiated from jEdit.\n- **Statusbar**: Part of the UI updated by various jEdit activities.\n- **PluginList**: Manages list of plugins; changed when plugins are added or removed.\n- **PluginUpdate**: Updates plugins dynamically; invoked by jEdit.\n- **PluginError**: Errors in plugins impact overall application behavior.\n- **PluginResURLConnection**: Handles resource connections for plugins.\n- **JARClassLoader**: Class loading mechanism for dynamic plugin loading.\n- **TextAreaTransferHandler**: Drag-and-drop/UI transfer features for text areas.\n\nThese entities were selected based on strong historical co-change data, conceptual coupling, and functional interdependence inferred through event bus communication, indirect references, and shared responsibilities in managing the editor environment.",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        }
    ],
    "interaction_records": {
        "step_histories": [
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4"
                ],
                "response_message": "m5"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6"
                ],
                "response_message": "m7"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8"
                ],
                "response_message": "m9"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10"
                ],
                "response_message": "m11"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12"
                ],
                "response_message": "m13"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14"
                ],
                "response_message": "m15"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14",
                    "m15",
                    "m16",
                    "m17"
                ],
                "response_message": "m18"
            }
        ],
        "mid_to_message": {
            "m1": {
                "role": "system",
                "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
            },
            "m2": {
                "role": "user",
                "content": "The project you need to analyze is `jEdit`, a well-known Java open source project. The starting entity you need to deal with is jEdit.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
            },
            "m3": {
                "content": "",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_ccb582a64c534f48a8b7b4",
                        "function": {
                            "arguments": "{\"entity\": \"jEdit.java\"}",
                            "name": "get_co_change_relationship"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m4": {
                "name": "get_co_change_relationship",
                "role": "tool",
                "content": "[[\"Entry\", \"16\", \"0.053156146179401995\"], [\"BufferHistory\", \"15\", \"0.04983388704318937\"], [\"EditPane\", \"29\", \"0.09634551495016612\"], [\"RecentHandler\", \"5\", \"0.016611295681063124\"], [\"Buffer\", \"59\", \"0.19601328903654486\"], [\"SearchAndReplace\", \"19\", \"0.06312292358803986\"], [\"View\", \"47\", \"0.15614617940199335\"], [\"EditServer\", \"20\", \"0.0664451827242525\"], [\"WindowHandler\", \"5\", \"0.016611295681063124\"], [\"ActionHandler\", \"48\", \"0.15946843853820597\"], [\"GeneralOptionPane\", \"11\", \"0.036544850498338874\"], [\"JEditActionContext\", \"2\", \"0.006644518272425249\"], [\"ShortcutsOptionPane\", \"7\", \"0.023255813953488372\"], [\"ToolBarEditDialog\", \"9\", \"0.029900332225913623\"], [\"ActionContext\", \"5\", \"0.016611295681063124\"], [\"JEditVisitorAdapter\", \"1\", \"0.0033222591362126247\"], [\"JEditVisitor\", \"1\", \"0.0033222591362126247\"], [\"CompleteWord\", \"17\", \"0.05647840531561462\"], [\"SaveCaretInfoVisitor\", \"1\", \"0.0033222591362126247\"], [\"SetCursorVisitor\", \"1\", \"0.0033222591362126247\"], [\"GUIUtilities\", \"54\", \"0.17940199335548174\"], [\"RolloverButton\", \"3\", \"0.009966777408637873\"], [\"HyperSearchResults\", \"17\", \"0.05647840531561462\"], [\"ExpansionToggleBorder\", \"2\", \"0.006644518272425249\"], [\"PanelWindowContainer\", \"20\", \"0.0664451827242525\"], [\"AbbrevsOptionPane\", \"8\", \"0.026578073089700997\"], [\"FloatingWindowContainer\", \"13\", \"0.04318936877076412\"], [\"ToolBarOptionPane\", \"2\", \"0.006644518272425249\"], [\"PluginsMenuButton\", \"7\", \"0.023255813953488372\"], [\"CommandsMenuButton\", \"2\", \"0.006644518272425249\"], [\"FavoritesMenuButton\", \"4\", \"0.013289036544850499\"], [\"HistoryButton\", \"1\", \"0.0033222591362126247\"], [\"SaveButton\", \"1\", \"0.0033222591362126247\"], [\"ChoosePluginSet\", \"1\", \"0.0033222591362126247\"], [\"RestoreButton\", \"1\", \"0.0033222591362126247\"], [\"ClearPluginSet\", \"1\", \"0.0033222591362126247\"], [\"MouseOverHandler\", \"1\", \"0.0033222591362126247\"], [\"AppearanceOptionPane\", \"15\", \"0.04983388704318937\"], [\"IconTheme\", \"1\", \"0.0033222591362126247\"], [\"Debug\", \"7\", \"0.023255813953488372\"], [\"GrabKeyDialog\", \"5\", \"0.016611295681063124\"], [\"InputHandler\", \"6\", \"0.019933554817275746\"], [\"KeyEventWorkaround\", \"10\", \"0.03322259136212625\"], [\"TextAreaInputHandler\", \"1\", \"0.0033222591362126247\"], [\"KeyEventTranslator\", \"8\", \"0.026578073089700997\"], [\"MyFocusManager\", \"10\", \"0.03322259136212625\"], [\"InputPane\", \"7\", \"0.023255813953488372\"], [\"BufferSet\", \"1\", \"0.0033222591362126247\"], [\"BufferSetListener\", \"1\", \"0.0033222591362126247\"], [\"BufferSetManager\", \"4\", \"0.013289036544850499\"], [\"BufferSwitcher\", \"3\", \"0.009966777408637873\"], [\"BufferSetAdapter\", \"1\", \"0.0033222591362126247\"], [\"ViewOptionPane\", \"4\", \"0.013289036544850499\"], [\"DockableWindowContainer\", \"5\", \"0.016611295681063124\"], [\"DockableWindowManager\", \"51\", \"0.16943521594684385\"], [\"DockableWindowManagerImpl\", \"1\", \"0.0033222591362126247\"], [\"DockingArea\", \"1\", \"0.0033222591362126247\"], [\"DockingLayout\", \"2\", \"0.006644518272425249\"], [\"DockableLayout\", \"8\", \"0.026578073089700997\"], [\"DockBorder\", \"1\", \"0.0033222591362126247\"], [\"ButtonLayout\", \"4\", \"0.013289036544850499\"], [\"ViewConfig\", \"5\", \"0.016611295681063124\"], [\"DockablePanel\", \"3\", \"0.009966777408637873\"], [\"PerspectiveHandler\", \"6\", \"0.019933554817275746\"], [\"DockableWindowFactory\", \"5\", \"0.016611295681063124\"], [\"DockingLayoutManager\", \"2\", \"0.006644518272425249\"], [\"DockingLayoutSetter\", \"1\", \"0.0033222591362126247\"], [\"PerspectiveManager\", \"14\", \"0.046511627906976744\"], [\"SettingsXML\", \"1\", \"0.0033222591362126247\"], [\"DockingOptionPane\", \"2\", \"0.006644518272425249\"], [\"DockableWindowManagerProvider\", \"1\", \"0.0033222591362126247\"], [\"IDockingFrameworkProvider\", \"1\", \"0.0033222591362126247\"], [\"DockableWindowConfig\", \"1\", \"0.0033222591362126247\"], [\"LoadPerspectiveAction\", \"1\", \"0.0033222591362126247\"], [\"CloseDialog\", \"3\", \"0.009966777408637873\"], [\"SaveBackupOptionPane\", \"3\", \"0.009966777408637873\"], [\"Macros\", \"19\", \"0.06312292358803986\"], [\"DraggedURLLoader\", \"1\", \"0.0033222591362126247\"], [\"StringCompare\", \"2\", \"0.006644518272425249\"], [\"VFS\", \"17\", \"0.05647840531561462\"], [\"PluginTableModel\", \"24\", \"0.07973421926910298\"], [\"TableModelHandler\", \"3\", \"0.009966777408637873\"], [\"BufferOptionPane\", \"1\", \"0.0033222591362126247\"], [\"StyleTableModel\", \"6\", \"0.019933554817275746\"], [\"EditingOptionPane\", \"13\", \"0.04318936877076412\"], [\"EncodingsOptionPane\", \"1\", \"0.0033222591362126247\"], [\"ServiceFoldHandlerProvider\", \"1\", \"0.0033222591362126247\"], [\"RemoveButton\", \"7\", \"0.023255813953488372\"], [\"DirectoryProvider\", \"5\", \"0.016611295681063124\"], [\"SendVFSUpdatesSafely\", \"1\", \"0.0033222591362126247\"], [\"Mode\", \"7\", \"0.023255813953488372\"], [\"JEditTextArea\", \"74\", \"0.24584717607973422\"], [\"ParserRuleSet\", \"6\", \"0.019933554817275746\"], [\"VFSBrowser\", \"36\", \"0.11960132890365449\"], [\"HyperSearchResult\", \"7\", \"0.023255813953488372\"], [\"XModeHandler\", \"6\", \"0.019933554817275746\"], [\"DefaultInputHandler\", \"13\", \"0.04318936877076412\"], [\"PastePrevious\", \"3\", \"0.009966777408637873\"], [\"TokenMarker\", \"15\", \"0.04983388704318937\"], [\"JARClassLoader\", \"23\", \"0.07641196013289037\"], [\"PosBottomHalf\", \"4\", \"0.013289036544850499\"], [\"HyperSearchRequest\", \"11\", \"0.036544850498338874\"], [\"TextUtilities\", \"14\", \"0.046511627906976744\"], [\"Token\", \"1\", \"0.0033222591362126247\"], [\"OffsetManager\", \"17\", \"0.05647840531561462\"], [\"ModeOptionPane\", \"4\", \"0.013289036544850499\"], [\"TokenList\", \"1\", \"0.0033222591362126247\"], [\"CurrentDirectoryMenu\", \"2\", \"0.006644518272425249\"], [\"RecentDirectoriesMenu\", \"3\", \"0.009966777408637873\"], [\"ErrorEntry\", \"3\", \"0.009966777408637873\"], [\"MiscUtilities\", \"57\", \"0.1893687707641196\"], [\"OptionsDialog\", \"14\", \"0.046511627906976744\"], [\"FirewallOptionPane\", \"4\", \"0.013289036544850499\"], [\"Dependency\", \"9\", \"0.029900332225913623\"], [\"FirewallAuthenticator\", \"2\", \"0.006644518272425249\"], [\"OverviewOptionPane\", \"6\", \"0.019933554817275746\"], [\"BrowserJTree\", \"8\", \"0.026578073089700997\"], [\"HistoryTextField\", \"4\", \"0.013289036544850499\"], [\"BrowserView\", \"15\", \"0.04983388704318937\"], [\"PluginManagerProgress\", \"12\", \"0.03986710963455149\"], [\"MouseHandler\", \"45\", \"0.14950166112956811\"], [\"OperatingSystem\", \"12\", \"0.03986710963455149\"], [\"VFSManager\", \"3\", \"0.009966777408637873\"], [\"TextAreaPainter\", \"29\", \"0.09634551495016612\"], [\"BufferChangeHandler\", \"23\", \"0.07641196013289037\"], [\"FileVFS\", \"22\", \"0.07308970099667775\"], [\"StatusBar\", \"20\", \"0.0664451827242525\"], [\"SettingsReloader\", \"4\", \"0.013289036544850499\"], [\"LineInfo\", \"4\", \"0.013289036544850499\"], [\"ChunkCache\", \"18\", \"0.059800664451827246\"], [\"KeyHandler\", \"17\", \"0.05647840531561462\"], [\"EnhancedCheckBoxMenuItem\", \"7\", \"0.023255813953488372\"], [\"MarkersMenuItem\", \"2\", \"0.006644518272425249\"], [\"EnhancedMenuItem\", \"9\", \"0.029900332225913623\"], [\"BufferIORequest\", \"28\", \"0.09302325581395349\"], [\"InstallPluginsDialog\", \"14\", \"0.046511627906976744\"], [\"FileCellRenderer\", \"7\", \"0.023255813953488372\"], [\"PaneNameRenderer\", \"2\", \"0.006644518272425249\"], [\"FocusHandler\", \"2\", \"0.006644518272425249\"], [\"FoldVisibilityManager\", \"9\", \"0.029900332225913623\"], [\"Abbrevs\", \"10\", \"0.03322259136212625\"], [\"FavoritesVFS\", \"5\", \"0.016611295681063124\"], [\"CheckBoxListModel\", \"4\", \"0.013289036544850499\"], [\"BeanShell\", \"11\", \"0.036544850498338874\"], [\"MarkerHighlight\", \"3\", \"0.009966777408637873\"], [\"ListHandler\", \"2\", \"0.006644518272425249\"], [\"PluginList\", \"12\", \"0.03986710963455149\"], [\"WrapGuide\", \"2\", \"0.006644518272425249\"], [\"HelpViewer\", \"20\", \"0.0664451827242525\"], [\"BracketHighlight\", \"2\", \"0.006644518272425249\"], [\"AbstractOptionPane\", \"4\", \"0.013289036544850499\"], [\"SearchDialog\", \"18\", \"0.059800664451827246\"], [\"BufferOptions\", \"13\", \"0.04318936877076412\"], [\"ModeProperties\", \"8\", \"0.026578073089700997\"], [\"TOCHandler\", \"5\", \"0.016611295681063124\"], [\"TipOfTheDay\", \"6\", \"0.019933554817275746\"], [\"Gutter\", \"8\", \"0.026578073089700997\"], [\"ParentDirectoryRenderer\", \"3\", \"0.009966777408637873\"], [\"BufferPrintable\", \"8\", \"0.026578073089700997\"], [\"Handler\", \"8\", \"0.026578073089700997\"], [\"Macro\", \"11\", \"0.036544850498338874\"], [\"JAR\", \"18\", \"0.059800664451827246\"], [\"BeanShellHandler\", \"4\", \"0.013289036544850499\"], [\"ComponentHandler\", \"2\", \"0.006644518272425249\"], [\"PluginManager\", \"20\", \"0.0664451827242525\"], [\"JCheckBoxList\", \"4\", \"0.013289036544850499\"], [\"FileRootsVFS\", \"8\", \"0.026578073089700997\"], [\"EnhancedDialog\", \"2\", \"0.006644518272425249\"], [\"PluginListDownloadProgress\", \"2\", \"0.006644518272425249\"], [\"Wrapper\", \"5\", \"0.016611295681063124\"], [\"Rect\", \"7\", \"0.023255813953488372\"], [\"TOCTree\", \"3\", \"0.009966777408637873\"], [\"GlobalOptions\", \"10\", \"0.03322259136212625\"], [\"DownloadThread\", \"4\", \"0.013289036544850499\"], [\"MouseWheelHandler\", \"4\", \"0.013289036544850499\"], [\"BrowserColorsOptionPane\", \"2\", \"0.006644518272425249\"], [\"PropertyChangeHandler\", \"4\", \"0.013289036544850499\"], [\"HelpIndex\", \"10\", \"0.03322259136212625\"], [\"AnimatedIcon\", \"2\", \"0.006644518272425249\"], [\"SplashScreen\", \"7\", \"0.023255813953488372\"], [\"OSTask\", \"4\", \"0.013289036544850499\"], [\"Install\", \"16\", \"0.053156146179401995\"], [\"NonInteractiveInstall\", \"2\", \"0.006644518272425249\"], [\"SwingInstall\", \"4\", \"0.013289036544850499\"], [\"ConsoleInstall\", \"2\", \"0.006644518272425249\"], [\"GenerateTocXML\", \"2\", \"0.006644518272425249\"], [\"HelpTOCPanel\", \"12\", \"0.03986710963455149\"], [\"Chunk\", \"2\", \"0.006644518272425249\"], [\"RecentFilesMenu\", \"5\", \"0.016611295681063124\"], [\"DirectoryMenu\", \"2\", \"0.006644518272425249\"], [\"EnhancedMenu\", \"8\", \"0.026578073089700997\"], [\"MarkersMenu\", \"2\", \"0.006644518272425249\"], [\"MacrosMenu\", \"8\", \"0.026578073089700997\"], [\"HistoryModel\", \"17\", \"0.05647840531561462\"], [\"BeanShellAction\", \"5\", \"0.016611295681063124\"], [\"Registers\", \"18\", \"0.059800664451827246\"], [\"PaintSelection\", \"4\", \"0.013289036544850499\"], [\"RegistersHandler\", \"4\", \"0.013289036544850499\"], [\"TextAreaOptionPane\", \"9\", \"0.029900332225913623\"], [\"ActionTextField\", \"3\", \"0.009966777408637873\"], [\"Autosave\", \"4\", \"0.013289036544850499\"], [\"ActionBar\", \"10\", \"0.03322259136212625\"], [\"ExplicitFoldHandler\", \"2\", \"0.006644518272425249\"], [\"CompletionPopup\", \"6\", \"0.019933554817275746\"], [\"LogViewer\", \"7\", \"0.023255813953488372\"], [\"PaintLineBackground\", \"2\", \"0.006644518272425249\"], [\"Anchor\", \"2\", \"0.006644518272425249\"], [\"BufferChangeListener\", \"4\", \"0.013289036544850499\"], [\"PluginInfoBox\", \"4\", \"0.013289036544850499\"], [\"ListUpdater\", \"4\", \"0.013289036544850499\"], [\"BufferChangeAdapter\", \"4\", \"0.013289036544850499\"], [\"TextRenderer\", \"6\", \"0.019933554817275746\"], [\"InstallPanel\", \"6\", \"0.019933554817275746\"], [\"SizeLabel\", \"6\", \"0.019933554817275746\"], [\"ManagePanel\", \"9\", \"0.029900332225913623\"], [\"DirectoryEntryCompare\", \"4\", \"0.013289036544850499\"], [\"ActionSet\", \"33\", \"0.10963455149501661\"], [\"FirstLine\", \"10\", \"0.03322259136212625\"], [\"StatusBarOptionPane\", \"4\", \"0.013289036544850499\"], [\"LoadSaveOptionPane\", \"2\", \"0.006644518272425249\"], [\"QuickNotepad\", \"2\", \"0.006644518272425249\"], [\"DockableListHandler\", \"14\", \"0.046511627906976744\"], [\"Factory\", \"14\", \"0.046511627906976744\"], [\"ScrollLineCount\", \"2\", \"0.006644518272425249\"], [\"VFSFileNameField\", \"8\", \"0.026578073089700997\"], [\"DisplayManager\", \"12\", \"0.03986710963455149\"], [\"VFSFileChooserDialog\", \"9\", \"0.029900332225913623\"], [\"PluginManagerOptionPane\", \"4\", \"0.013289036544850499\"], [\"MirrorModel\", \"2\", \"0.006644518272425249\"], [\"BrowserOptionPane\", \"2\", \"0.006644518272425249\"], [\"DownloadMirrorsThread\", \"2\", \"0.006644518272425249\"], [\"BrowserHandler\", \"4\", \"0.013289036544850499\"], [\"ResourceCache\", \"9\", \"0.029900332225913623\"], [\"PaintBracketHighlight\", \"2\", \"0.006644518272425249\"], [\"PaintCaret\", \"6\", \"0.019933554817275746\"], [\"PaintText\", \"4\", \"0.013289036544850499\"], [\"PaintWrapGuide\", \"2\", \"0.006644518272425249\"], [\"FoldHandler\", \"4\", \"0.013289036544850499\"], [\"PluginCacheEntry\", \"15\", \"0.04983388704318937\"], [\"ServiceManager\", \"11\", \"0.036544850498338874\"], [\"ServiceListHandler\", \"8\", \"0.026578073089700997\"], [\"EditAction\", \"7\", \"0.023255813953488372\"], [\"Model\", \"3\", \"0.009966777408637873\"], [\"VFSDirectoryEntryTable\", \"5\", \"0.016611295681063124\"], [\"Remove\", \"18\", \"0.059800664451827246\"], [\"TableMouseHandler\", \"3\", \"0.009966777408637873\"], [\"VFSDirectoryEntryTableModel\", \"1\", \"0.0033222591362126247\"], [\"Descriptor\", \"3\", \"0.009966777408637873\"], [\"Deferred\", \"5\", \"0.016611295681063124\"], [\"EnhancedButton\", \"5\", \"0.016611295681063124\"], [\"PluginJAR\", \"65\", \"0.2159468438538206\"], [\"EditPlugin\", \"8\", \"0.026578073089700997\"], [\"Plugin\", \"8\", \"0.026578073089700997\"], [\"EBMessage\", \"4\", \"0.013289036544850499\"], [\"PluginResURLConnection\", \"2\", \"0.006644518272425249\"], [\"HelpButton\", \"11\", \"0.036544850498338874\"], [\"LatestVersionPlugin\", \"2\", \"0.006644518272425249\"], [\"PluginUpdate\", \"6\", \"0.019933554817275746\"], [\"BrowserCommandsMenu\", \"5\", \"0.016611295681063124\"], [\"VariableGridLayout\", \"2\", \"0.006644518272425249\"], [\"SearchBar\", \"5\", \"0.016611295681063124\"], [\"EditBus\", \"3\", \"0.009966777408637873\"], [\"EBPlugin\", \"2\", \"0.006644518272425249\"], [\"ThreadProgress\", \"2\", \"0.006644518272425249\"], [\"MarkersProvider\", \"2\", \"0.006644518272425249\"], [\"RecentDirectoriesProvider\", \"6\", \"0.019933554817275746\"], [\"RecentFilesProvider\", \"4\", \"0.013289036544850499\"], [\"DynamicMenuProvider\", \"2\", \"0.006644518272425249\"], [\"MacrosProvider\", \"2\", \"0.006644518272425249\"], [\"PluginsProvider\", \"2\", \"0.006644518272425249\"], [\"EvalError\", \"2\", \"0.006644518272425249\"], [\"PluginOptions\", \"2\", \"0.006644518272425249\"], [\"Roster\", \"8\", \"0.026578073089700997\"], [\"ScrollLayout\", \"4\", \"0.013289036544850499\"], [\"ExtensionManager\", \"2\", \"0.006644518272425249\"], [\"KillRing\", \"17\", \"0.05647840531561462\"], [\"UndoManager\", \"8\", \"0.026578073089700997\"], [\"Operation\", \"2\", \"0.006644518272425249\"], [\"InstallButton\", \"8\", \"0.026578073089700997\"], [\"RosterThread\", \"2\", \"0.006644518272425249\"], [\"LogList\", \"2\", \"0.006644518272425249\"], [\"IntegerArray\", \"3\", \"0.009966777408637873\"], [\"GutterOptionPane\", \"8\", \"0.026578073089700997\"], [\"EditAbbrevDialog\", \"4\", \"0.013289036544850499\"], [\"AbbrevsModel\", \"4\", \"0.013289036544850499\"], [\"BoyerMooreSearchMatcher\", \"8\", \"0.026578073089700997\"], [\"BrowserIORequest\", \"6\", \"0.019933554817275746\"], [\"EntryCompare\", \"3\", \"0.009966777408637873\"], [\"HeaderMouseHandler\", \"2\", \"0.006644518272425249\"], [\"BufferPrinter1_4\", \"2\", \"0.006644518272425249\"], [\"BufferPrinter1_3\", \"2\", \"0.006644518272425249\"], [\"PrintOptionPane\", \"6\", \"0.019933554817275746\"], [\"UnixWorkaround\", \"4\", \"0.013289036544850499\"], [\"InstallThread\", \"2\", \"0.006644518272425249\"], [\"OptionGroup\", \"2\", \"0.006644518272425249\"], [\"PositionManager\", \"2\", \"0.006644518272425249\"], [\"Highlight\", \"2\", \"0.006644518272425249\"], [\"Match\", \"2\", \"0.006644518272425249\"], [\"RESearchMatcher\", \"3\", \"0.009966777408637873\"], [\"MouseActions\", \"2\", \"0.006644518272425249\"], [\"Insert\", \"2\", \"0.006644518272425249\"], [\"KillRingHandler\", \"5\", \"0.016611295681063124\"], [\"NameSpace\", \"3\", \"0.009966777408637873\"], [\"SettingsActionHandler\", \"5\", \"0.016611295681063124\"], [\"TextAreaTransferHandler\", \"8\", \"0.026578073089700997\"], [\"TextAreaDialog\", \"5\", \"0.016611295681063124\"], [\"BeanShellErrorDialog\", \"2\", \"0.006644518272425249\"], [\"FilesChangedDialog\", \"6\", \"0.019933554817275746\"], [\"Renderer\", \"8\", \"0.026578073089700997\"], [\"TreeHandler\", \"2\", \"0.006644518272425249\"], [\"ButtonActionHandler\", \"2\", \"0.006644518272425249\"], [\"SelectallButton\", \"2\", \"0.006644518272425249\"], [\"RootsEntry\", \"4\", \"0.013289036544850499\"], [\"Delegate\", \"2\", \"0.006644518272425249\"], [\"ResultCellRenderer\", \"8\", \"0.026578073089700997\"], [\"MacOSPlugin\", \"2\", \"0.006644518272425249\"], [\"ErrorListCellRenderer\", \"2\", \"0.006644518272425249\"], [\"ShortcutsModel\", \"7\", \"0.023255813953488372\"], [\"BrowserActionContext\", \"2\", \"0.006644518272425249\"], [\"MemoryStatus\", \"8\", \"0.026578073089700997\"], [\"PropertyManager\", \"2\", \"0.006644518272425249\"], [\"Clock\", \"2\", \"0.006644518272425249\"], [\"DropHandler\", \"2\", \"0.006644518272425249\"], [\"RingListModel\", \"2\", \"0.006644518272425249\"], [\"KeywordMap\", \"2\", \"0.006644518272425249\"], [\"HelpFile\", \"2\", \"0.006644518272425249\"], [\"WorkThreadPool\", \"3\", \"0.009966777408637873\"], [\"DisplayTokenHandler\", \"2\", \"0.006644518272425249\"], [\"Windows\", \"2\", \"0.006644518272425249\"], [\"FontSelectorDialog\", \"3\", \"0.009966777408637873\"], [\"StyleEditor\", \"4\", \"0.013289036544850499\"], [\"SelectLineRange\", \"2\", \"0.006644518272425249\"], [\"ErrorListDialog\", \"2\", \"0.006644518272425249\"], [\"PasteFromListDialog\", \"4\", \"0.013289036544850499\"], [\"ContextAddDialog\", \"6\", \"0.019933554817275746\"], [\"AboutDialog\", \"2\", \"0.006644518272425249\"], [\"ViewRegisters\", \"2\", \"0.006644518272425249\"], [\"AddAbbrevDialog\", \"2\", \"0.006644518272425249\"], [\"ParserRule\", \"5\", \"0.016611295681063124\"], [\"JEditMetalTheme15\", \"2\", \"0.006644518272425249\"], [\"JEditMetalTheme14\", \"2\", \"0.006644518272425249\"], [\"TextAreaDropHandler\", \"2\", \"0.006644518272425249\"], [\"MyFocusTraversalPolicy\", \"2\", \"0.006644518272425249\"], [\"Broken\", \"2\", \"0.006644518272425249\"], [\"MarkerViewer\", \"2\", \"0.006644518272425249\"], [\"RegisterChanged\", \"2\", \"0.006644518272425249\"], [\"RegisterViewer\", \"2\", \"0.006644518272425249\"], [\"GoToNodeAction\", \"2\", \"0.006644518272425249\"], [\"HyperSearchFileNode\", \"2\", \"0.006644518272425249\"], [\"HyperSearchNode\", \"2\", \"0.006644518272425249\"], [\"MutableListModel\", \"2\", \"0.006644518272425249\"], [\"BufferLoadRequest\", \"2\", \"0.006644518272425249\"], [\"OpenBracketIndentRule\", \"2\", \"0.006644518272425249\"], [\"HelpViewerDialog\", \"2\", \"0.006644518272425249\"], [\"HelpViewerInterface\", \"2\", \"0.006644518272425249\"], [\"HelpSearchPanel\", \"2\", \"0.006644518272425249\"], [\"LinkHandler\", \"3\", \"0.009966777408637873\"], [\"BufferChanging\", \"2\", \"0.006644518272425249\"], [\"JEditBuffer\", \"2\", \"0.006644518272425249\"], [\"SegmentCharSequence\", \"2\", \"0.006644518272425249\"], [\"PluginListHandler\", \"2\", \"0.006644518272425249\"], [\"AllBufferSet\", \"2\", \"0.006644518272425249\"], [\"MirrorList\", \"4\", \"0.013289036544850499\"], [\"MirrorListHandler\", \"2\", \"0.006644518272425249\"], [\"SearchMatcher\", \"2\", \"0.006644518272425249\"], [\"DirectoryLoadedAWTRequest\", \"4\", \"0.013289036544850499\"], [\"ActionListHandler\", \"2\", \"0.006644518272425249\"], [\"ModeCatalogHandler\", \"2\", \"0.006644518272425249\"], [\"TagDecl\", \"3\", \"0.009966777408637873\"], [\"ColorEntry\", \"2\", \"0.006644518272425249\"], [\"PatternSearchMatcher\", \"2\", \"0.006644518272425249\"], [\"WindowTableModel\", \"4\", \"0.013289036544850499\"], [\"IOUtilities\", \"2\", \"0.006644518272425249\"], [\"FavoritesProvider\", \"2\", \"0.006644518272425249\"], [\"Branch\", \"2\", \"0.006644518272425249\"], [\"BufferListSet\", \"2\", \"0.006644518272425249\"], [\"StringICaseCompare\", \"3\", \"0.009966777408637873\"], [\"WindowCompare\", \"3\", \"0.009966777408637873\"], [\"AbbrevCompare\", \"3\", \"0.009966777408637873\"], [\"DockableWindowCompare\", \"2\", \"0.006644518272425249\"], [\"MenuItemCompare\", \"4\", \"0.013289036544850499\"], [\"ButtonCompare\", \"4\", \"0.013289036544850499\"], [\"PluginCompare\", \"2\", \"0.006644518272425249\"], [\"Log\", \"2\", \"0.006644518272425249\"], [\"Interpreter\", \"1\", \"0.0033222591362126247\"], [\"VICaretStatus\", \"2\", \"0.006644518272425249\"], [\"WorkThread\", \"3\", \"0.009966777408637873\"], [\"ColorTableModel\", \"4\", \"0.013289036544850499\"], [\"TabbedPane\", \"1\", \"0.0033222591362126247\"], [\"TipPanel\", \"1\", \"0.0033222591362126247\"], [\"StyleRenderer\", \"1\", \"0.0033222591362126247\"], [\"WorkThreadProgressListener\", \"1\", \"0.0033222591362126247\"], [\"WorkThreadHandler\", \"1\", \"0.0033222591362126247\"], [\"TOCCellRenderer\", \"1\", \"0.0033222591362126247\"], [\"HelpNode\", \"1\", \"0.0033222591362126247\"], [\"REMatch\", \"1\", \"0.0033222591362126247\"], [\"Button\", \"2\", \"0.006644518272425249\"], [\"ButtonCellRenderer\", \"1\", \"0.0033222591362126247\"], [\"MenuItem\", \"1\", \"0.0033222591362126247\"], [\"FileCompare\", \"1\", \"0.0033222591362126247\"], [\"FoldListener\", \"1\", \"0.0033222591362126247\"], [\"FoldEventHandler\", \"1\", \"0.0033222591362126247\"], [\"ContentManager\", \"1\", \"0.0033222591362126247\"], [\"ReadWriteLock\", \"1\", \"0.0033222591362126247\"], [\"PosTopHalf\", \"1\", \"0.0033222591362126247\"], [\"AboutPanel\", \"1\", \"0.0033222591362126247\"], [\"CompoundEdit\", \"1\", \"0.0033222591362126247\"], [\"BrowserColorsModel\", \"1\", \"0.0033222591362126247\"], [\"StyleChoice\", \"1\", \"0.0033222591362126247\"], [\"ColorChoice\", \"1\", \"0.0033222591362126247\"], [\"SizeSaver\", \"2\", \"0.006644518272425249\"], [\"MarkersSaveRequest\", \"1\", \"0.0033222591362126247\"], [\"BufferSaveRequest\", \"1\", \"0.0033222591362126247\"], [\"JEditKillRing\", \"1\", \"0.0033222591362126247\"]]"
            },
            "m5": {
                "content": "Based on the co-change relationship analysis for the starting entity `jEdit.java`, several entities have a significant correlation in terms of co-changes. The confidence value indicates how often these files were modified together with `jEdit.java` across version history. Here are some notable entities that likely need to be synchronized:\n\n### High Confidence Co-Change Entities (Confidence > 0.15):\n1. **JEditTextArea.java** - Confidence: 0.2458  \n   Strong coupling suggests this file is frequently changed alongside `jEdit.java`. It's likely central to similar functionality.\n\n2. **PluginJAR.java** - Confidence: 0.2159  \n   A core part of plugin handling, which might be tightly integrated with jEdit\u2019s main logic.\n\n3. **Buffer.java** - Confidence: 0.1960  \n   This file deals with buffer management and is likely used heavily by `jEdit.java`.\n\n4. **MiscUtilities.java** - Confidence: 0.1894  \n   Contains utility functions; changes here could affect many parts of the system, including `jEdit.java`.\n\n5. **GUIUtilities.java** - Confidence: 0.1794  \n   Another utilities class dealing with GUI components, likely shared usage with `jEdit.java`.\n\n6. **DockableWindowManager.java** - Confidence: 0.1694  \n   Manages dockable windows, suggesting integration with the main application logic.\n\n### Medium Confidence Co-Change Entities (0.05 < Confidence < 0.15):\n- **ActionHandler.java** - Confidence: 0.1595\n- **View.java** - Confidence: 0.1561\n- **EditPane.java** - Confidence: 0.0963\n- **TextAreaPainter.java** - Confidence: 0.0963\n- **SearchAndReplace.java** - Confidence: 0.0631\n- **EditServer.java** - Confidence: 0.0664\n- **PanelWindowContainer.java** - Confidence: 0.0664\n- **Macros.java** - Confidence: 0.0631\n- **VFSBrowser.java** - Confidence: 0.1196\n\nThese files also show frequent co-change behavior and should be considered for synchronization depending on the nature of the change in `jEdit.java`.\n\n---\n\nTo refine the CIA further, I will check the conceptual coupling between `jEdit.java` and the top few entities from the list above. This will help determine if there is a semantic or structural dependency beyond just historical co-changes.\n\nLet's start by checking the conceptual coupling between `jEdit.java` and `JEditTextArea.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_c03ca8bb1c0d47dea282ea",
                        "function": {
                            "arguments": "{\"entity1\": \"jEdit.java\", \"entity2\": \"JEditTextArea.java\"}",
                            "name": "get_conceptual_coupling"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m6": {
                "role": "tool",
                "name": "get_conceptual_coupling",
                "content": "\"0.8465207\""
            },
            "m7": {
                "content": "The conceptual coupling between `jEdit.java` and `JEditTextArea.java` is quite high at **0.8465**, indicating a strong semantic and structural relationship. This confirms that changes in `jEdit.java` are likely to impact `JEditTextArea.java`, and vice versa. Therefore, this file should definitely be synchronized with any significant change in `jEdit.java`.\n\nLet\u2019s continue by analyzing the coupling dependencies between `jEdit.java` and `JEditTextArea.java` to understand what kind of direct code-level dependencies exist (e.g., method calls, inheritance, interface implementation, etc.).\n\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_d2ae693bb5cd46bc9e1d57",
                        "function": {
                            "arguments": "{\"entity1\": \"jEdit.java\", \"entity2\": \"JEditTextArea.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m8": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"There are no coupling dependencies between these two entities\"]"
            },
            "m9": {
                "content": "Interesting \u2014 while there is a **strong conceptual coupling** (semantic similarity) between `jEdit.java` and `JEditTextArea.java`, the **code-level coupling dependencies** are absent. This suggests that the relationship is likely *indirect* or mediated through other components such as event systems, reflection, or interfaces not explicitly tracked by static dependency analysis.\n\nThis pattern is common in GUI-based applications like jEdit, where interactions may be managed via events, listeners, or dynamic dispatch rather than direct method calls or inheritance.\n\n### Next Steps:\nTo better understand how these files interact, we can examine their **call graphs**, especially starting from `jEdit.java`, to see if any indirect references to `JEditTextArea.java` appear at runtime or through reflective usage.\n\nLet\u2019s start by retrieving the **call graph** for `jEdit.java` to identify all entities it directly interacts with.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_c253f6c380da4a78a8ab7d",
                        "function": {
                            "arguments": "{\"entity\": \"jEdit.java\"}",
                            "name": "get_call_graph"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m10": {
                "role": "tool",
                "name": "get_call_graph",
                "content": "[\"\", \"BufferIORequest\", \"PluginManager\", \"KillRing\", \"\", \"HelpViewer\", \"\", \"\", \"SearchAndReplace\", \"\", \"Log\", \"\"]"
            },
            "m11": {
                "content": "The call graph for `jEdit.java` includes the following entities it directly interacts with:\n\n- `BufferIORequest`\n- `PluginManager`\n- `KillRing`\n- `HelpViewer`\n- `SearchAndReplace`\n- `Log`\n\nInterestingly, `JEditTextArea.java` does **not** appear in this direct call graph. This reinforces the earlier observation that the coupling between `jEdit.java` and `JEditTextArea.java` is likely **indirect**, possibly through event listeners, GUI components managed elsewhere, or runtime interactions not captured by static call graph analysis.\n\n### Next Steps:\nTo better understand how `jEdit.java` might indirectly affect `JEditTextArea.java`, we should look at the **origin code** of `jEdit.java`. This will allow us to manually inspect whether there are dynamic references, event handling, or listener registrations related to text editing or GUI components (which could involve `JEditTextArea`).\n\nLet\u2019s retrieve the **source code** of `jEdit.java` for inspection.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_8fe0340c8dad4c9d857934",
                        "function": {
                            "arguments": "{\"entity\": \"jEdit.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m12": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package org.gjt.sp.jedit;\\nimport com.microstar.xml.*;\\nimport javax.swing.plaf.metal.*;\\nimport javax.swing.*;\\nimport java.awt.*;\\nimport java.io.*;\\nimport java.net.*;\\nimport java.text.MessageFormat;\\nimport java.util.*;\\nimport org.gjt.sp.jedit.buffer.BufferIORequest;\\nimport org.gjt.sp.jedit.buffer.KillRing;\\nimport org.gjt.sp.jedit.msg.*;\\nimport org.gjt.sp.jedit.gui.*;\\nimport org.gjt.sp.jedit.help.HelpViewer;\\nimport org.gjt.sp.jedit.io.*;\\nimport org.gjt.sp.jedit.pluginmgr.PluginManager;\\nimport org.gjt.sp.jedit.search.SearchAndReplace;\\nimport org.gjt.sp.jedit.syntax.*;\\nimport org.gjt.sp.jedit.textarea.*;\\nimport org.gjt.sp.util.Log;\\npublic class jEdit\\n{\\n\\tpublic static String getVersion()\\n\\t{\\n\\t\\treturn MiscUtilities.buildToVersion(getBuild());\\n\\t} \\n\\tpublic static String getBuild()\\n\\t{\\n\\t\\t\\t\\treturn \\\"04.02.03.00\\\";\\n\\t} \\n\\tpublic static void main(String[] args)\\n\\t{\\n\\t\\tmainThread = Thread.currentThread();\\n\\t\\tString javaVersion = System.getProperty(\\\"java.version\\\");\\n\\t\\tif(javaVersion.compareTo(\\\"1.3\\\") < 0)\\n\\t\\t{\\n\\t\\t\\tSystem.err.println(\\\"You are running Java version \\\"\\n\\t\\t\\t\\t+ javaVersion + \\\".\\\");\\n\\t\\t\\tSystem.err.println(\\\"jEdit requires Java 1.3 or later.\\\");\\n\\t\\t\\tSystem.exit(1);\\n\\t\\t}\\n\\t\\tsettingsDirectory = MiscUtilities.constructPath(\\n\\t\\t\\tSystem.getProperty(\\\"user.home\\\"),\\\".jedit\\\");\\n\\t\\t\\t\\t\\t\\tbackground = OperatingSystem.isMacOS();\\n\\t\\t\\t\\tboolean endOpts = false;\\n\\t\\tint level = Log.WARNING;\\n\\t\\tString portFile = \\\"server\\\";\\n\\t\\tboolean restore = true;\\n\\t\\tboolean newView = true;\\n\\t\\tboolean newPlainView = false;\\n\\t\\tboolean gui = true; \\t\\tboolean loadPlugins = true;\\n\\t\\tboolean runStartupScripts = true;\\n\\t\\tboolean quit = false;\\n\\t\\tboolean wait = false;\\n\\t\\tString userDir = System.getProperty(\\\"user.dir\\\");\\n\\t\\t\\t\\tString scriptFile = null;\\n\\t\\tfor(int i = 0; i < args.length; i++)\\n\\t\\t{\\n\\t\\t\\tString arg = args[i];\\n\\t\\t\\tif(arg == null)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\telse if(arg.length() == 0)\\n\\t\\t\\t\\targs[i] = null;\\n\\t\\t\\telse if(arg.startsWith(\\\"-\\\") && !endOpts)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(arg.equals(\\\"--\\\"))\\n\\t\\t\\t\\t\\tendOpts = true;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-usage\\\"))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tversion();\\n\\t\\t\\t\\t\\tSystem.err.println();\\n\\t\\t\\t\\t\\tusage();\\n\\t\\t\\t\\t\\tSystem.exit(1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(arg.equals(\\\"-version\\\"))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tversion();\\n\\t\\t\\t\\t\\tSystem.exit(1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(arg.startsWith(\\\"-log=\\\"))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttry\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tlevel = Integer.parseInt(arg.substring(\\\"-log=\\\".length()));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcatch(NumberFormatException nf)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tSystem.err.println(\\\"Malformed option: \\\" + arg);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(arg.equals(\\\"-nosettings\\\"))\\n\\t\\t\\t\\t\\tsettingsDirectory = null;\\n\\t\\t\\t\\telse if(arg.startsWith(\\\"-settings=\\\"))\\n\\t\\t\\t\\t\\tsettingsDirectory = arg.substring(10);\\n\\t\\t\\t\\telse if(arg.startsWith(\\\"-noserver\\\"))\\n\\t\\t\\t\\t\\tportFile = null;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-server\\\"))\\n\\t\\t\\t\\t\\tportFile = \\\"server\\\";\\n\\t\\t\\t\\telse if(arg.startsWith(\\\"-server=\\\"))\\n\\t\\t\\t\\t\\tportFile = arg.substring(8);\\n\\t\\t\\t\\telse if(arg.startsWith(\\\"-background\\\"))\\n\\t\\t\\t\\t\\tbackground = true;\\n\\t\\t\\t\\telse if(arg.startsWith(\\\"-nobackground\\\"))\\n\\t\\t\\t\\t\\tbackground = false;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-gui\\\"))\\n\\t\\t\\t\\t\\tgui = true;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-nogui\\\"))\\n\\t\\t\\t\\t\\tgui = false;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-newview\\\"))\\n\\t\\t\\t\\t\\tnewView = true;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-newplainview\\\"))\\n\\t\\t\\t\\t\\tnewPlainView = true;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-reuseview\\\"))\\n\\t\\t\\t\\t\\tnewPlainView = newView = false;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-restore\\\"))\\n\\t\\t\\t\\t\\trestore = true;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-norestore\\\"))\\n\\t\\t\\t\\t\\trestore = false;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-plugins\\\"))\\n\\t\\t\\t\\t\\tloadPlugins = true;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-noplugins\\\"))\\n\\t\\t\\t\\t\\tloadPlugins = false;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-startupscripts\\\"))\\n\\t\\t\\t\\t\\trunStartupScripts = true;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-nostartupscripts\\\"))\\n\\t\\t\\t\\t\\trunStartupScripts = false;\\n\\t\\t\\t\\telse if(arg.startsWith(\\\"-run=\\\"))\\n\\t\\t\\t\\t\\tscriptFile = arg.substring(5);\\n\\t\\t\\t\\telse if(arg.equals(\\\"-wait\\\"))\\n\\t\\t\\t\\t\\twait = true;\\n\\t\\t\\t\\telse if(arg.equals(\\\"-quit\\\"))\\n\\t\\t\\t\\t\\tquit = true;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSystem.err.println(\\\"Unknown option: \\\"\\n\\t\\t\\t\\t\\t\\t+ arg);\\n\\t\\t\\t\\t\\tusage();\\n\\t\\t\\t\\t\\tSystem.exit(1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\targs[i] = null;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tif(settingsDirectory != null && portFile != null)\\n\\t\\t\\tportFile = MiscUtilities.constructPath(settingsDirectory,portFile);\\n\\t\\telse\\n\\t\\t\\tportFile = null;\\n\\t\\tLog.init(true,level);\\n\\t\\t\\t\\tif(portFile != null && new File(portFile).exists())\\n\\t\\t{\\n\\t\\t\\tint port, key;\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tBufferedReader in = new BufferedReader(new FileReader(portFile));\\n\\t\\t\\t\\tString check = in.readLine();\\n\\t\\t\\t\\tif(!check.equals(\\\"b\\\"))\\n\\t\\t\\t\\t\\tthrow new Exception(\\\"Wrong port file format\\\");\\n\\t\\t\\t\\tport = Integer.parseInt(in.readLine());\\n\\t\\t\\t\\tkey = Integer.parseInt(in.readLine());\\n\\t\\t\\t\\tSocket socket = new Socket(InetAddress.getByName(\\\"127.0.0.1\\\"),port);\\n\\t\\t\\t\\tDataOutputStream out = new DataOutputStream(\\n\\t\\t\\t\\t\\tsocket.getOutputStream());\\n\\t\\t\\t\\tout.writeInt(key);\\n\\t\\t\\t\\tString script;\\n\\t\\t\\t\\tif(quit)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscript = \\\"socket.close();\\\\n\\\"\\n\\t\\t\\t\\t\\t\\t+ \\\"jEdit.exit(null,true);\\\\n\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscript = makeServerScript(wait,restore,\\n\\t\\t\\t\\t\\t\\tnewView,newPlainView,args,\\n\\t\\t\\t\\t\\t\\tscriptFile);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tout.writeUTF(script);\\n\\t\\t\\t\\tLog.log(Log.DEBUG,jEdit.class,\\\"Waiting for server\\\");\\n\\t\\t\\t\\t\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsocket.getInputStream().read();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(Exception e)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tin.close();\\n\\t\\t\\t\\tout.close();\\n\\t\\t\\t\\tSystem.exit(0);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Exception e)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tLog.log(Log.NOTICE,jEdit.class,\\\"An error occurred\\\"\\n\\t\\t\\t\\t\\t+ \\\" while connecting to the jEdit server instance.\\\");\\n\\t\\t\\t\\tLog.log(Log.NOTICE,jEdit.class,\\\"This probably means that\\\"\\n\\t\\t\\t\\t\\t+ \\\" jEdit crashed and/or exited abnormally\\\");\\n\\t\\t\\t\\tLog.log(Log.NOTICE,jEdit.class,\\\"the last time it was run.\\\");\\n\\t\\t\\t\\tLog.log(Log.NOTICE,jEdit.class,\\\"If you don't\\\"\\n\\t\\t\\t\\t\\t+ \\\" know what this means, don't worry.\\\");\\n\\t\\t\\t\\tLog.log(Log.NOTICE,jEdit.class,e);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tif(quit)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tSystem.exit(0);\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(!new File(settingsDirectory,\\\"nosplash\\\").exists())\\n\\t\\t\\tGUIUtilities.showSplashScreen();\\n\\t\\t\\t\\tWriter stream;\\n\\t\\tif(settingsDirectory != null)\\n\\t\\t{\\n\\t\\t\\tFile _settingsDirectory = new File(settingsDirectory);\\n\\t\\t\\tif(!_settingsDirectory.exists())\\n\\t\\t\\t\\t_settingsDirectory.mkdirs();\\n\\t\\t\\tFile _macrosDirectory = new File(settingsDirectory,\\\"macros\\\");\\n\\t\\t\\tif(!_macrosDirectory.exists())\\n\\t\\t\\t\\t_macrosDirectory.mkdir();\\n\\t\\t\\tString logPath = MiscUtilities.constructPath(\\n\\t\\t\\t\\tsettingsDirectory,\\\"activity.log\\\");\\n\\t\\t\\tbackupSettingsFile(new File(logPath));\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tstream = new BufferedWriter(new FileWriter(logPath));\\n\\t\\t\\t\\t\\t\\t\\t\\tString lineSep = System.getProperty(\\\"line.separator\\\");\\n\\t\\t\\t\\tstream.write(\\\"Log file created on \\\" + new Date());\\n\\t\\t\\t\\tstream.write(lineSep);\\n\\t\\t\\t\\tstream.write(\\\"IMPORTANT:\\\");\\n\\t\\t\\t\\tstream.write(lineSep);\\n\\t\\t\\t\\tstream.write(\\\"Because updating this file after \\\"\\n\\t\\t\\t\\t\\t+ \\\"every log message would kill\\\");\\n\\t\\t\\t\\tstream.write(lineSep);\\n\\t\\t\\t\\tstream.write(\\\"performance, it will be *incomplete* \\\"\\n\\t\\t\\t\\t\\t+ \\\"unless you invoke the\\\");\\n\\t\\t\\t\\tstream.write(lineSep);\\n\\t\\t\\t\\tstream.write(\\\"Utilities->Troubleshooting->Update \\\"\\n\\t\\t\\t\\t\\t+ \\\"Activity Log on Disk command!\\\");\\n\\t\\t\\t\\tstream.write(lineSep);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Exception e)\\n\\t\\t\\t{\\n\\t\\t\\t\\te.printStackTrace();\\n\\t\\t\\t\\tstream = null;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstream = null;\\n\\t\\t} \\n\\t\\tLog.setLogWriter(stream);\\n\\t\\tLog.log(Log.NOTICE,jEdit.class,\\\"jEdit version \\\" + getVersion());\\n\\t\\tLog.log(Log.MESSAGE,jEdit.class,\\\"Settings directory is \\\"\\n\\t\\t\\t+ settingsDirectory);\\n\\t\\t\\t\\tif(portFile != null)\\n\\t\\t{\\n\\t\\t\\tserver = new EditServer(portFile);\\n\\t\\t\\tif(!server.isOK())\\n\\t\\t\\t\\tserver = null;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(background)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbackground = false;\\n\\t\\t\\t\\tLog.log(Log.WARNING,jEdit.class,\\\"You cannot specify both the\\\"\\n\\t\\t\\t\\t\\t+ \\\" -background and -noserver switches\\\");\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tinitMisc();\\n\\t\\tinitSystemProperties();\\n\\t\\tGUIUtilities.advanceSplashProgress();\\n\\t\\tBeanShell.init();\\n\\t\\tinitUserProperties();\\n\\t\\tinitPLAF();\\n\\t\\tif(OperatingSystem.hasJava14())\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tClassLoader loader = jEdit.class.getClassLoader();\\n\\t\\t\\t\\tClass clazz;\\n\\t\\t\\t\\tif(loader != null)\\n\\t\\t\\t\\t\\tclazz = loader.loadClass(\\\"org.gjt.sp.jedit.Java14\\\");\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tclazz = Class.forName(\\\"org.gjt.sp.jedit.Java14\\\");\\n\\t\\t\\t\\tjava.lang.reflect.Method meth = clazz\\n\\t\\t\\t\\t\\t.getMethod(\\\"init\\\",new Class[0]);\\n\\t\\t\\t\\tmeth.invoke(null,new Object[0]);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Exception e)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,jEdit.class,e);\\n\\t\\t\\t\\tSystem.exit(1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tVFSManager.init();\\n\\t\\tinitResources();\\n\\t\\tSearchAndReplace.load();\\n\\t\\tGUIUtilities.advanceSplashProgress();\\n\\t\\tif(loadPlugins)\\n\\t\\t\\tinitPlugins();\\n\\t\\tif(jEditHome != null)\\n\\t\\t\\tinitSiteProperties();\\n\\t\\tif(settingsDirectory != null)\\n\\t\\t{\\n\\t\\t\\tFile recent = new File(MiscUtilities.constructPath(\\n\\t\\t\\t\\tsettingsDirectory,\\\"recent.xml\\\"));\\n\\t\\t\\tif(recent.exists())\\n\\t\\t\\t{\\n\\t\\t\\t\\trecentModTime = recent.lastModified();\\n\\t\\t\\t\\tBufferHistory.load(recent);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tpropertiesChanged();\\n\\t\\tGUIUtilities.advanceSplashProgress();\\n\\t\\t\\t\\tsortBuffers = getBooleanProperty(\\\"sortBuffers\\\");\\n\\t\\tsortByName = getBooleanProperty(\\\"sortByName\\\");\\n\\t\\treloadModes();\\n\\t\\tGUIUtilities.advanceSplashProgress();\\n\\t\\t\\t\\tfor(int i = 0; i < jars.size(); i++)\\n\\t\\t{\\n\\t\\t\\t((PluginJAR)jars.elementAt(i)).activatePluginIfNecessary();\\n\\t\\t}\\n\\t\\t\\t\\tMacros.loadMacros();\\n\\t\\tMacros.getMacroActionSet().initKeyBindings();\\n\\t\\tif(runStartupScripts && jEditHome != null)\\n\\t\\t{\\n\\t\\t\\tString path = MiscUtilities.constructPath(jEditHome,\\\"startup\\\");\\n\\t\\t\\tFile file = new File(path);\\n\\t\\t\\tif(file.exists())\\n\\t\\t\\t\\trunStartupScripts(file);\\n\\t\\t}\\n\\t\\tif(runStartupScripts && settingsDirectory != null)\\n\\t\\t{\\n\\t\\t\\tString path = MiscUtilities.constructPath(settingsDirectory,\\\"startup\\\");\\n\\t\\t\\tFile file = new File(path);\\n\\t\\t\\tif(!file.exists())\\n\\t\\t\\t\\tfile.mkdirs();\\n\\t\\t\\telse\\n\\t\\t\\t\\trunStartupScripts(file);\\n\\t\\t} \\n\\t\\t\\t\\tif(scriptFile != null)\\n\\t\\t{\\n\\t\\t\\tscriptFile = MiscUtilities.constructPath(userDir,scriptFile);\\n\\t\\t\\tBeanShell.runScript(null,scriptFile,null,false);\\n\\t\\t} \\n\\t\\tGUIUtilities.advanceSplashProgress();\\n\\t\\t\\t\\tfinishStartup(gui,restore,userDir,args);\\n\\t} \\n\\tpublic static final Properties getProperties()\\n\\t{\\n\\t\\treturn props;\\n\\t} \\n\\tpublic static final String getProperty(String name)\\n\\t{\\n\\t\\treturn props.getProperty(name);\\n\\t} \\n\\tpublic static final String getProperty(String name, String def)\\n\\t{\\n\\t\\treturn props.getProperty(name,def);\\n\\t} \\n\\tpublic static final String getProperty(String name, Object[] args)\\n\\t{\\n\\t\\tif(name == null)\\n\\t\\t\\treturn null;\\n\\t\\tif(args == null)\\n\\t\\t\\treturn props.getProperty(name);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString value = props.getProperty(name);\\n\\t\\t\\tif(value == null)\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn MessageFormat.format(value,args);\\n\\t\\t}\\n\\t} \\n\\tpublic static final boolean getBooleanProperty(String name)\\n\\t{\\n\\t\\treturn getBooleanProperty(name,false);\\n\\t} \\n\\tpublic static final boolean getBooleanProperty(String name, boolean def)\\n\\t{\\n\\t\\tString value = getProperty(name);\\n\\t\\tif(value == null)\\n\\t\\t\\treturn def;\\n\\t\\telse if(value.equals(\\\"true\\\") || value.equals(\\\"yes\\\")\\n\\t\\t\\t|| value.equals(\\\"on\\\"))\\n\\t\\t\\treturn true;\\n\\t\\telse if(value.equals(\\\"false\\\") || value.equals(\\\"no\\\")\\n\\t\\t\\t|| value.equals(\\\"off\\\"))\\n\\t\\t\\treturn false;\\n\\t\\telse\\n\\t\\t\\treturn def;\\n\\t} \\n\\tpublic static final int getIntegerProperty(String name, int def)\\n\\t{\\n\\t\\tString value = getProperty(name);\\n\\t\\tif(value == null)\\n\\t\\t\\treturn def;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn Integer.parseInt(value.trim());\\n\\t\\t\\t}\\n\\t\\t\\tcatch(NumberFormatException nf)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn def;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tpublic static double getDoubleProperty(String name, double def)\\n\\t{\\n\\t\\tString value = getProperty(name);\\n\\t\\tif(value == null)\\n\\t\\t\\treturn def;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn Double.parseDouble(value.trim());\\n\\t\\t\\t}\\n\\t\\t\\tcatch(NumberFormatException nf)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn def;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tpublic static final Font getFontProperty(String name)\\n\\t{\\n\\t\\treturn getFontProperty(name,null);\\n\\t} \\n\\tpublic static final Font getFontProperty(String name, Font def)\\n\\t{\\n\\t\\tString family = getProperty(name);\\n\\t\\tString sizeString = getProperty(name + \\\"size\\\");\\n\\t\\tString styleString = getProperty(name + \\\"style\\\");\\n\\t\\tif(family == null || sizeString == null || styleString == null)\\n\\t\\t\\treturn def;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint size, style;\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tsize = Integer.parseInt(sizeString);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(NumberFormatException nf)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn def;\\n\\t\\t\\t}\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tstyle = Integer.parseInt(styleString);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(NumberFormatException nf)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn def;\\n\\t\\t\\t}\\n\\t\\t\\treturn new Font(family,style,size);\\n\\t\\t}\\n\\t} \\n\\tpublic static Color getColorProperty(String name)\\n\\t{\\n\\t\\treturn getColorProperty(name,Color.black);\\n\\t} \\n\\tpublic static Color getColorProperty(String name, Color def)\\n\\t{\\n\\t\\tString value = getProperty(name);\\n\\t\\tif(value == null)\\n\\t\\t\\treturn def;\\n\\t\\telse\\n\\t\\t\\treturn GUIUtilities.parseColor(value,def);\\n\\t} \\n\\tpublic static void setColorProperty(String name, Color value)\\n\\t{\\n\\t\\tsetProperty(name,GUIUtilities.getColorHexString(value));\\n\\t} \\n\\tpublic static final void setProperty(String name, String value)\\n\\t{\\n\\t\\tif(value == null)\\n\\t\\t{\\n\\t\\t\\tString prop = (String)defaultProps.get(name);\\n\\t\\t\\tif(prop == null || prop.length() == 0)\\n\\t\\t\\t\\tprops.remove(name);\\n\\t\\t\\telse\\n\\t\\t\\t\\tprops.put(name,\\\"\\\");\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString prop = (String)defaultProps.get(name);\\n\\t\\t\\tif(value.equals(prop))\\n\\t\\t\\t\\tprops.remove(name);\\n\\t\\t\\telse\\n\\t\\t\\t\\tprops.put(name,value);\\n\\t\\t}\\n\\t} \\n\\tpublic static final void setTemporaryProperty(String name, String value)\\n\\t{\\n\\t\\tprops.remove(name);\\n\\t\\tdefaultProps.put(name,value);\\n\\t} \\n\\tpublic static final void setBooleanProperty(String name, boolean value)\\n\\t{\\n\\t\\tsetProperty(name,value ? \\\"true\\\" : \\\"false\\\");\\n\\t} \\n\\tpublic static final void setIntegerProperty(String name, int value)\\n\\t{\\n\\t\\tsetProperty(name,String.valueOf(value));\\n\\t} \\n\\t\\tpublic static final void setDoubleProperty(String name, double value)\\n\\t{\\n\\t\\tsetProperty(name,String.valueOf(value));\\n\\t}\\n\\tpublic static final void setFontProperty(String name, Font value)\\n\\t{\\n\\t\\tsetProperty(name,value.getFamily());\\n\\t\\tsetIntegerProperty(name + \\\"size\\\",value.getSize());\\n\\t\\tsetIntegerProperty(name + \\\"style\\\",value.getStyle());\\n\\t} \\n\\tpublic static final void unsetProperty(String name)\\n\\t{\\n\\t\\tif(defaultProps.get(name) != null)\\n\\t\\t\\tprops.put(name,\\\"\\\");\\n\\t\\telse\\n\\t\\t\\tprops.remove(name);\\n\\t} \\n\\tpublic static final void resetProperty(String name)\\n\\t{\\n\\t\\tprops.remove(name);\\n\\t} \\n\\tpublic static void propertiesChanged()\\n\\t{\\n\\t\\tinitKeyBindings();\\n\\t\\tAutosave.setInterval(getIntegerProperty(\\\"autosave\\\",30));\\n\\t\\tsaveCaret = getBooleanProperty(\\\"saveCaret\\\");\\n\\t\\tUIDefaults defaults = UIManager.getDefaults();\\n\\t\\t\\t\\tFont font = getFontProperty(\\\"view.font\\\");\\n\\t\\t\\t\\tdefaults.put(\\\"TextArea.font\\\",font);\\n\\t\\tdefaults.put(\\\"TextPane.font\\\",font);\\n\\t\\t\\t\\tToolTipManager.sharedInstance().setEnabled(\\n\\t\\t\\tjEdit.getBooleanProperty(\\\"showTooltips\\\"));\\n\\t\\tinitProxy();\\n\\t\\t\\t\\tBuffer buffer = buffersFirst;\\n\\t\\twhile(buffer != null)\\n\\t\\t{\\n\\t\\t\\tbuffer.resetCachedProperties();\\n\\t\\t\\tbuffer.propertiesChanged();\\n\\t\\t\\tbuffer = buffer.next;\\n\\t\\t}\\n\\t\\tHistoryModel.propertiesChanged();\\n\\t\\tKillRing.propertiesChanged();\\n\\t\\tEditBus.send(new PropertiesChanged(null));\\n\\t} \\n\\tpublic static String[] getNotLoadedPluginJARs()\\n\\t{\\n\\t\\tVector returnValue = new Vector();\\n\\t\\tif(jEditHome != null)\\n\\t\\t{\\n\\t\\t\\tString systemPluginDir = MiscUtilities\\n\\t\\t\\t\\t.constructPath(jEditHome,\\\"jars\\\");\\n\\t\\t\\tString[] list = new File(systemPluginDir).list();\\n\\t\\t\\tif(list != null)\\n\\t\\t\\t\\tgetNotLoadedPluginJARs(returnValue,systemPluginDir,list);\\n\\t\\t}\\n\\t\\tif(settingsDirectory != null)\\n\\t\\t{\\n\\t\\t\\tString userPluginDir = MiscUtilities\\n\\t\\t\\t\\t.constructPath(settingsDirectory,\\\"jars\\\");\\n\\t\\t\\tString[] list = new File(userPluginDir).list();\\n\\t\\t\\tif(list != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetNotLoadedPluginJARs(returnValue,\\n\\t\\t\\t\\t\\tuserPluginDir,list);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tString[] _returnValue = new String[returnValue.size()];\\n\\t\\treturnValue.copyInto(_returnValue);\\n\\t\\treturn _returnValue;\\n\\t} \\n\\tpublic static EditPlugin getPlugin(String name)\\n\\t{\\n\\t\\tEditPlugin[] plugins = getPlugins();\\n\\t\\tfor(int i = 0; i < plugins.length; i++)\\n\\t\\t{\\n\\t\\t\\tif(plugins[i].getClassName().equals(name))\\n\\t\\t\\t\\treturn plugins[i];\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic static EditPlugin[] getPlugins()\\n\\t{\\n\\t\\tVector vector = new Vector();\\n\\t\\tfor(int i = 0; i < jars.size(); i++)\\n\\t\\t{\\n\\t\\t\\tEditPlugin plugin = ((PluginJAR)jars.elementAt(i))\\n\\t\\t\\t\\t.getPlugin();\\n\\t\\t\\tif(plugin != null)\\n\\t\\t\\t\\tvector.add(plugin);\\n\\t\\t}\\n\\t\\tEditPlugin[] array = new EditPlugin[vector.size()];\\n\\t\\tvector.copyInto(array);\\n\\t\\treturn array;\\n\\t} \\n\\tpublic static PluginJAR[] getPluginJARs()\\n\\t{\\n\\t\\tPluginJAR[] array = new PluginJAR[jars.size()];\\n\\t\\tjars.copyInto(array);\\n\\t\\treturn array;\\n\\t} \\n\\tpublic static PluginJAR getPluginJAR(String path)\\n\\t{\\n\\t\\tfor(int i = 0; i < jars.size(); i++)\\n\\t\\t{\\n\\t\\t\\tPluginJAR jar = (PluginJAR)jars.elementAt(i);\\n\\t\\t\\tif(jar.getPath().equals(path))\\n\\t\\t\\t\\treturn jar;\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic static void addPluginJAR(String path)\\n\\t{\\n\\t\\t\\t\\tPluginJAR jar = new EditPlugin.JAR(new File(path));\\n\\t\\tjars.addElement(jar);\\n\\t\\tjar.init();\\n\\t\\tEditBus.send(new PluginUpdate(jar,PluginUpdate.LOADED,false));\\n\\t\\tif(!isMainThread())\\n\\t\\t\\tEditBus.send(new DynamicMenuChanged(\\\"plugins\\\"));\\n\\t} \\n\\tprivate static void addPluginJARsFromDirectory(String directory)\\n\\t{\\n\\t\\tLog.log(Log.NOTICE,jEdit.class,\\\"Loading plugins from \\\"\\n\\t\\t\\t+ directory);\\n\\t\\tFile file = new File(directory);\\n\\t\\tif(!(file.exists() && file.isDirectory()))\\n\\t\\t\\treturn;\\n\\t\\tString[] plugins = file.list();\\n\\t\\tif(plugins == null)\\n\\t\\t\\treturn;\\n\\t\\tfor(int i = 0; i < plugins.length; i++)\\n\\t\\t{\\n\\t\\t\\tString plugin = plugins[i];\\n\\t\\t\\tif(!plugin.toLowerCase().endsWith(\\\".jar\\\"))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tString path = MiscUtilities.constructPath(directory,plugin);\\n\\t\\t\\tif(plugin.equals(\\\"EditBuddy.jar\\\")\\n\\t\\t\\t\\t|| plugin.equals(\\\"PluginManager.jar\\\")\\n\\t\\t\\t\\t|| plugin.equals(\\\"Firewall.jar\\\")\\n\\t\\t\\t\\t|| plugin.equals(\\\"Tidy.jar\\\"))\\n\\t\\t\\t{\\n\\t\\t\\t\\tpluginError(path,\\\"plugin-error.obsolete\\\",null);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\taddPluginJAR(path);\\n\\t\\t}\\n\\t} \\n\\tpublic static void removePluginJAR(PluginJAR jar, boolean exit)\\n\\t{\\n\\t\\tif(exit)\\n\\t\\t{\\n\\t\\t\\tjar.uninit(true);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tjar.uninit(false);\\n\\t\\t\\tjars.removeElement(jar);\\n\\t\\t}\\n\\t\\tEditBus.send(new PluginUpdate(jar,PluginUpdate.UNLOADED,exit));\\n\\t\\tif(!isMainThread() && !exit)\\n\\t\\t\\tEditBus.send(new DynamicMenuChanged(\\\"plugins\\\"));\\n\\t} \\n\\tpublic static ActionContext getActionContext()\\n\\t{\\n\\t\\treturn actionContext;\\n\\t} \\n\\tpublic static void addActionSet(ActionSet actionSet)\\n\\t{\\n\\t\\tactionContext.addActionSet(actionSet);\\n\\t} \\n\\tpublic static void removeActionSet(ActionSet actionSet)\\n\\t{\\n\\t\\tactionContext.removeActionSet(actionSet);\\n\\t} \\n\\tpublic static ActionSet getBuiltInActionSet()\\n\\t{\\n\\t\\treturn builtInActionSet;\\n\\t} \\n\\tpublic static ActionSet[] getActionSets()\\n\\t{\\n\\t\\treturn actionContext.getActionSets();\\n\\t} \\n\\tpublic static EditAction getAction(String name)\\n\\t{\\n\\t\\treturn actionContext.getAction(name);\\n\\t} \\n\\tpublic static ActionSet getActionSetForAction(String action)\\n\\t{\\n\\t\\treturn actionContext.getActionSetForAction(action);\\n\\t} \\n\\tpublic static ActionSet getActionSetForAction(EditAction action)\\n\\t{\\n\\t\\treturn actionContext.getActionSetForAction(action.getName());\\n\\t} \\n\\tpublic static EditAction[] getActions()\\n\\t{\\n\\t\\tString[] names = actionContext.getActionNames();\\n\\t\\tEditAction[] actions = new EditAction[names.length];\\n\\t\\tfor(int i = 0; i < actions.length; i++)\\n\\t\\t{\\n\\t\\t\\tactions[i] = actionContext.getAction(names[i]);\\n\\t\\t\\tif(actions[i] == null)\\n\\t\\t\\t\\tLog.log(Log.ERROR,jEdit.class,\\\"wtf: \\\" + names[i]);\\n\\t\\t}\\n\\t\\treturn actions;\\n\\t} \\n\\tpublic static String[] getActionNames()\\n\\t{\\n\\t\\treturn actionContext.getActionNames();\\n\\t} \\n\\tpublic static void reloadModes()\\n\\t{\\n\\t\\tmodes = new Vector(50);\\n\\t\\t\\t\\tif(jEditHome == null)\\n\\t\\t\\tloadModeCatalog(\\\"/modes/catalog\\\",true);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tloadModeCatalog(MiscUtilities.constructPath(jEditHome,\\n\\t\\t\\t\\t\\\"modes\\\",\\\"catalog\\\"),false);\\n\\t\\t} \\n\\t\\t\\t\\tif(settingsDirectory != null)\\n\\t\\t{\\n\\t\\t\\tFile userModeDir = new File(MiscUtilities.constructPath(\\n\\t\\t\\t\\tsettingsDirectory,\\\"modes\\\"));\\n\\t\\t\\tif(!userModeDir.exists())\\n\\t\\t\\t\\tuserModeDir.mkdirs();\\n\\t\\t\\tFile userCatalog = new File(MiscUtilities.constructPath(\\n\\t\\t\\t\\tsettingsDirectory,\\\"modes\\\",\\\"catalog\\\"));\\n\\t\\t\\tif(!userCatalog.exists())\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tFileWriter out = new FileWriter(userCatalog);\\n\\t\\t\\t\\t\\tout.write(jEdit.getProperty(\\\"defaultCatalog\\\"));\\n\\t\\t\\t\\t\\tout.close();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tLog.log(Log.ERROR,jEdit.class,io);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tloadModeCatalog(userCatalog.getPath(),false);\\n\\t\\t} \\n\\t\\tBuffer buffer = buffersFirst;\\n\\t\\twhile(buffer != null)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbuffer.setMode();\\n\\t\\t\\tbuffer = buffer.next;\\n\\t\\t}\\n\\t} \\n\\tpublic static Mode getMode(String name)\\n\\t{\\n\\t\\tfor(int i = 0; i < modes.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMode mode = (Mode)modes.elementAt(i);\\n\\t\\t\\tif(mode.getName().equals(name))\\n\\t\\t\\t\\treturn mode;\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic static Mode[] getModes()\\n\\t{\\n\\t\\tMode[] array = new Mode[modes.size()];\\n\\t\\tmodes.copyInto(array);\\n\\t\\treturn array;\\n\\t} \\n\\tpublic static Buffer openFiles(View view, String parent, String[] args)\\n\\t{\\n\\t\\tBuffer retVal = null;\\n\\t\\tBuffer lastBuffer = null;\\n\\t\\tfor(int i = 0; i < args.length; i++)\\n\\t\\t{\\n\\t\\t\\tString arg = args[i];\\n\\t\\t\\tif(arg == null)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\telse if(arg.startsWith(\\\"+line:\\\") || arg.startsWith(\\\"+marker:\\\"))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(lastBuffer != null)\\n\\t\\t\\t\\t\\tgotoMarker(view,lastBuffer,arg);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tlastBuffer = openFile(null,parent,arg,false,null);\\n\\t\\t\\tif(retVal == null && lastBuffer != null)\\n\\t\\t\\t\\tretVal = lastBuffer;\\n\\t\\t}\\n\\t\\tif(view != null && retVal != null)\\n\\t\\t\\tview.setBuffer(retVal);\\n\\t\\treturn retVal;\\n\\t} \\n\\tpublic static Buffer openFile(View view, String path)\\n\\t{\\n\\t\\treturn openFile(view,null,path,false,new Hashtable());\\n\\t} \\n\\tpublic static Buffer openFile(View view, String parent,\\n\\t\\tString path, boolean readOnly, boolean newFile)\\n\\t{\\n\\t\\treturn openFile(view,parent,path,newFile,new Hashtable());\\n\\t} \\n\\tpublic static Buffer openFile(View view, String parent,\\n\\t\\tString path, boolean readOnly, boolean newFile,\\n\\t\\tHashtable props)\\n\\t{\\n\\t\\treturn openFile(view,parent,path,newFile,props);\\n\\t} \\n\\tpublic static Buffer openFile(View view, String parent,\\n\\t\\tString path, boolean newFile, Hashtable props)\\n\\t{\\n\\t\\tif(view != null && parent == null)\\n\\t\\t\\tparent = view.getBuffer().getDirectory();\\n\\t\\tif(MiscUtilities.isURL(path))\\n\\t\\t{\\n\\t\\t\\tif(MiscUtilities.getProtocolOfURL(path).equals(\\\"file\\\"))\\n\\t\\t\\t\\tpath = path.substring(5);\\n\\t\\t}\\n\\t\\tpath = MiscUtilities.constructPath(parent,path);\\n\\t\\tsynchronized(bufferListLock)\\n\\t\\t{\\n\\t\\t\\tBuffer buffer = getBuffer(path);\\n\\t\\t\\tif(buffer != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(view != null)\\n\\t\\t\\t\\t\\tview.setBuffer(buffer);\\n\\t\\t\\t\\treturn buffer;\\n\\t\\t\\t}\\n\\t\\t\\tif(props == null)\\n\\t\\t\\t\\tprops = new Hashtable();\\n\\t\\t\\tBufferHistory.Entry entry = BufferHistory.getEntry(path);\\n\\t\\t\\tif(entry != null && saveCaret && props.get(Buffer.CARET) == null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tprops.put(Buffer.CARET,new Integer(entry.caret));\\n\\t\\t\\t}\\n\\t\\t\\tif(entry != null && props.get(Buffer.ENCODING) == null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(entry.encoding != null)\\n\\t\\t\\t\\t\\tprops.put(Buffer.ENCODING,entry.encoding);\\n\\t\\t\\t}\\n\\t\\t\\tBuffer newBuffer = new Buffer(path,newFile,false,props);\\n\\t\\t\\tif(!newBuffer.load(view,false))\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\taddBufferToList(newBuffer);\\n\\t\\t\\tEditBus.send(new BufferUpdate(newBuffer,view,BufferUpdate.CREATED));\\n\\t\\t\\tif(view != null)\\n\\t\\t\\t\\tview.setBuffer(newBuffer);\\n\\t\\t\\treturn newBuffer;\\n\\t\\t}\\n\\t} \\n\\tpublic static Buffer openTemporary(View view, String parent,\\n\\t\\tString path, boolean newFile)\\n\\t{\\n\\t\\tif(view != null && parent == null)\\n\\t\\t\\tparent = view.getBuffer().getDirectory();\\n\\t\\tif(MiscUtilities.isURL(path))\\n\\t\\t{\\n\\t\\t\\tif(MiscUtilities.getProtocolOfURL(path).equals(\\\"file\\\"))\\n\\t\\t\\t\\tpath = path.substring(5);\\n\\t\\t}\\n\\t\\tpath = MiscUtilities.constructPath(parent,path);\\n\\t\\tsynchronized(bufferListLock)\\n\\t\\t{\\n\\t\\t\\tBuffer buffer = getBuffer(path);\\n\\t\\t\\tif(buffer != null)\\n\\t\\t\\t\\treturn buffer;\\n\\t\\t\\tbuffer = new Buffer(path,newFile,true,new Hashtable());\\n\\t\\t\\tif(!buffer.load(view,false))\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn buffer;\\n\\t\\t}\\n\\t} \\n\\tpublic static void commitTemporary(Buffer buffer)\\n\\t{\\n\\t\\tif(!buffer.isTemporary())\\n\\t\\t\\treturn;\\n\\t\\taddBufferToList(buffer);\\n\\t\\tbuffer.commitTemporary();\\n\\t\\t\\t\\tEditBus.send(new BufferUpdate(buffer,null,BufferUpdate.CREATED));\\n\\t\\tEditBus.send(new BufferUpdate(buffer,null,BufferUpdate.LOAD_STARTED));\\n\\t\\tEditBus.send(new BufferUpdate(buffer,null,BufferUpdate.LOADED));\\n\\t} \\n\\tpublic static Buffer newFile(View view)\\n\\t{\\n\\t\\tString path;\\n\\t\\tif(view != null && view.getBuffer() != null)\\n\\t\\t{\\n\\t\\t\\tpath = view.getBuffer().getDirectory();\\n\\t\\t\\tVFS vfs = VFSManager.getVFSForPath(path);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif((vfs.getCapabilities() & VFS.WRITE_CAP) == 0)\\n\\t\\t\\t\\tpath = System.getProperty(\\\"user.home\\\");\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tpath = null;\\n\\t\\treturn newFile(view,path);\\n\\t} \\n\\tpublic static Buffer newFile(View view, String dir)\\n\\t{\\n\\t\\t\\t\\t\\t\\tif(dir != null\\n\\t\\t\\t&& buffersFirst != null\\n\\t\\t\\t&& buffersFirst == buffersLast\\n\\t\\t\\t&& buffersFirst.isUntitled()\\n\\t\\t\\t&& !buffersFirst.isDirty())\\n\\t\\t{\\n\\t\\t\\tcloseBuffer(view,buffersFirst);\\n\\t\\t\\t\\t\\t\\treturn buffersFirst;\\n\\t\\t}\\n\\t\\t\\t\\tint untitledCount = 0;\\n\\t\\tBuffer buffer = buffersFirst;\\n\\t\\twhile(buffer != null)\\n\\t\\t{\\n\\t\\t\\tif(buffer.getName().startsWith(\\\"Untitled-\\\"))\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tuntitledCount = Math.max(untitledCount,\\n\\t\\t\\t\\t\\t\\tInteger.parseInt(buffer.getName()\\n\\t\\t\\t\\t\\t\\t.substring(9)));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(NumberFormatException nf)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tbuffer = buffer.next;\\n\\t\\t}\\n\\t\\treturn openFile(view,dir,\\\"Untitled-\\\" + (untitledCount+1),true,null);\\n\\t} \\n\\tpublic static boolean closeBuffer(View view, Buffer buffer)\\n\\t{\\n\\t\\t\\t\\tif(buffer.isPerformingIO())\\n\\t\\t{\\n\\t\\t\\tVFSManager.waitForRequests();\\n\\t\\t\\tif(VFSManager.errorOccurred())\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tif(buffer.isDirty())\\n\\t\\t{\\n\\t\\t\\tObject[] args = { buffer.getName() };\\n\\t\\t\\tint result = GUIUtilities.confirm(view,\\\"notsaved\\\",args,\\n\\t\\t\\t\\tJOptionPane.YES_NO_CANCEL_OPTION,\\n\\t\\t\\t\\tJOptionPane.WARNING_MESSAGE);\\n\\t\\t\\tif(result == JOptionPane.YES_OPTION)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(!buffer.save(view,null,true))\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tVFSManager.waitForRequests();\\n\\t\\t\\t\\tif(buffer.getBooleanProperty(BufferIORequest\\n\\t\\t\\t\\t\\t.ERROR_OCCURRED))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(result != JOptionPane.NO_OPTION)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t_closeBuffer(view,buffer);\\n\\t\\treturn true;\\n\\t} \\n\\tpublic static void _closeBuffer(View view, Buffer buffer)\\n\\t{\\n\\t\\tif(buffer.isClosed())\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(!buffer.isNewFile())\\n\\t\\t{\\n\\t\\t\\tview.getEditPane().saveCaretInfo();\\n\\t\\t\\tInteger _caret = (Integer)buffer.getProperty(Buffer.CARET);\\n\\t\\t\\tint caret = (_caret == null ? 0 : _caret.intValue());\\n\\t\\t\\tBufferHistory.setEntry(buffer.getPath(),caret,\\n\\t\\t\\t\\t(Selection[])buffer.getProperty(Buffer.SELECTION),\\n\\t\\t\\t\\tbuffer.getStringProperty(Buffer.ENCODING));\\n\\t\\t}\\n\\t\\tremoveBufferFromList(buffer);\\n\\t\\tbuffer.close();\\n\\t\\tDisplayManager.bufferClosed(buffer);\\n\\t\\tEditBus.send(new BufferUpdate(buffer,view,BufferUpdate.CLOSED));\\n\\t\\t\\t\\tif(buffersFirst == null && buffersLast == null)\\n\\t\\t\\tnewFile(view);\\n\\t} \\n\\tpublic static boolean closeAllBuffers(View view)\\n\\t{\\n\\t\\treturn closeAllBuffers(view,false);\\n\\t} \\n\\tpublic static boolean closeAllBuffers(View view, boolean isExiting)\\n\\t{\\n\\t\\tboolean dirty = false;\\n\\t\\tBuffer buffer = buffersFirst;\\n\\t\\twhile(buffer != null)\\n\\t\\t{\\n\\t\\t\\tif(buffer.isDirty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tdirty = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tbuffer = buffer.next;\\n\\t\\t}\\n\\t\\tif(dirty)\\n\\t\\t{\\n\\t\\t\\tboolean ok = new CloseDialog(view).isOK();\\n\\t\\t\\tif(!ok)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\t\\tVFSManager.waitForRequests();\\n\\t\\tif(VFSManager.errorOccurred())\\n\\t\\t\\treturn false;\\n\\t\\tbuffer = buffersFirst;\\n\\t\\t\\t\\tbuffersFirst = buffersLast = null;\\n\\t\\tbufferHash.clear();\\n\\t\\tbufferCount = 0;\\n\\t\\twhile(buffer != null)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isNewFile())\\n\\t\\t\\t{\\n\\t\\t\\t\\tInteger _caret = (Integer)buffer.getProperty(Buffer.CARET);\\n\\t\\t\\t\\tint caret = (_caret == null ? 0 : _caret.intValue());\\n\\t\\t\\t\\tBufferHistory.setEntry(buffer.getPath(),caret,\\n\\t\\t\\t\\t\\t(Selection[])buffer.getProperty(Buffer.SELECTION),\\n\\t\\t\\t\\t\\tbuffer.getStringProperty(Buffer.ENCODING));\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.close();\\n\\t\\t\\tDisplayManager.bufferClosed(buffer);\\n\\t\\t\\tif(!isExiting)\\n\\t\\t\\t{\\n\\t\\t\\t\\tEditBus.send(new BufferUpdate(buffer,view,\\n\\t\\t\\t\\t\\tBufferUpdate.CLOSED));\\n\\t\\t\\t}\\n\\t\\t\\tbuffer = buffer.next;\\n\\t\\t}\\n\\t\\tif(!isExiting)\\n\\t\\t\\tnewFile(view);\\n\\t\\treturn true;\\n\\t} \\n\\tpublic static void saveAllBuffers(View view)\\n\\t{\\n\\t\\tsaveAllBuffers(view,jEdit.getBooleanProperty(\\\"confirm.save-all\\\"));\\n\\t} \\n\\tpublic static void saveAllBuffers(View view, boolean confirm)\\n\\t{\\n\\t\\tif(confirm)\\n\\t\\t{\\n\\t\\t\\tint result = GUIUtilities.confirm(view,\\\"saveall\\\",null,\\n\\t\\t\\t\\tJOptionPane.YES_NO_OPTION,\\n\\t\\t\\t\\tJOptionPane.QUESTION_MESSAGE);\\n\\t\\t\\tif(result != JOptionPane.YES_OPTION)\\n\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tBuffer current = view.getBuffer();\\n\\t\\tBuffer buffer = buffersFirst;\\n\\t\\twhile(buffer != null)\\n\\t\\t{\\n\\t\\t\\tif(buffer.isDirty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.isNewFile())\\n\\t\\t\\t\\t\\tview.setBuffer(buffer);\\n\\t\\t\\t\\tbuffer.save(view,null,true);\\n\\t\\t\\t}\\n\\t\\t\\tbuffer = buffer.next;\\n\\t\\t}\\n\\t\\tview.setBuffer(current);\\n\\t} \\n\\tpublic static void reloadAllBuffers(final View view, boolean confirm)\\n\\t{\\n\\t\\tif(confirm)\\n\\t\\t{\\n\\t\\t\\tint result = GUIUtilities.confirm(view,\\\"reload-all\\\",null,\\n\\t\\t\\t\\tJOptionPane.YES_NO_OPTION,\\n\\t\\t\\t\\tJOptionPane.QUESTION_MESSAGE);\\n\\t\\t\\tif(result != JOptionPane.YES_OPTION)\\n\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\t\\tView _view = viewsFirst;\\n\\t\\twhile(_view != null)\\n\\t\\t{\\n\\t\\t\\tEditPane[] panes = _view.getEditPanes();\\n\\t\\t\\tfor(int i = 0; i < panes.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tpanes[i].saveCaretInfo();\\n\\t\\t\\t}\\n\\t\\t\\t_view = _view.next;\\n\\t\\t}\\n\\t\\tBuffer[] buffers = jEdit.getBuffers();\\n\\t\\tfor(int i = 0; i < buffers.length; i++)\\n\\t\\t{\\n\\t\\t\\tBuffer buffer = buffers[i];\\n\\t\\t\\tbuffer.load(view,true);\\n\\t\\t}\\n\\t} \\n\\tpublic static Buffer getBuffer(String path)\\n\\t{\\n\\t\\tif(!MiscUtilities.isURL(path))\\n\\t\\t\\tpath = MiscUtilities.resolveSymlinks(path);\\n\\t\\tboolean caseInsensitiveFilesystem =\\n\\t\\t\\tOperatingSystem.isDOSDerived()\\n\\t\\t\\t|| OperatingSystem.isMacOS();\\n\\t\\tif(caseInsensitiveFilesystem)\\n\\t\\t\\tpath = path.toLowerCase();\\n\\t\\tsynchronized(bufferListLock)\\n\\t\\t{\\n\\t\\t\\treturn (Buffer)bufferHash.get(path);\\n\\t\\t}\\n\\t} \\n\\tpublic static Buffer[] getBuffers()\\n\\t{\\n\\t\\tsynchronized(bufferListLock)\\n\\t\\t{\\n\\t\\t\\tBuffer[] buffers = new Buffer[bufferCount];\\n\\t\\t\\tBuffer buffer = buffersFirst;\\n\\t\\t\\tfor(int i = 0; i < bufferCount; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffers[i] = buffer;\\n\\t\\t\\t\\tbuffer = buffer.next;\\n\\t\\t\\t}\\n\\t\\t\\treturn buffers;\\n\\t\\t}\\n\\t} \\n\\tpublic static int getBufferCount()\\n\\t{\\n\\t\\treturn bufferCount;\\n\\t} \\n\\tpublic static Buffer getFirstBuffer()\\n\\t{\\n\\t\\treturn buffersFirst;\\n\\t} \\n\\tpublic static Buffer getLastBuffer()\\n\\t{\\n\\t\\treturn buffersLast;\\n\\t} \\n\\tpublic static void checkBufferStatus(View view)\\n\\t{\\n\\t\\t\\t\\t\\t\\tboolean showDialogSetting = getBooleanProperty(\\\"view.checkModStatus\\\");\\n\\t\\tBuffer[] buffers = jEdit.getBuffers();\\n\\t\\tint[] states = new int[buffers.length];\\n\\t\\tboolean show = false;\\n\\t\\tfor(int i = 0; i < buffers.length; i++)\\n\\t\\t{\\n\\t\\t\\tBuffer buffer = buffers[i];\\n\\t\\t\\tstates[i] = buffer.checkFileStatus(view);\\n\\t\\t\\tswitch(states[i])\\n\\t\\t\\t{\\n\\t\\t\\tcase Buffer.FILE_CHANGED:\\n\\t\\t\\t\\tif(showDialogSetting && !buffer.isDirty())\\n\\t\\t\\t\\t\\tbuffer.load(view,true);\\n\\t\\t\\tcase Buffer.FILE_DELETED:\\n\\t\\t\\t\\tshow = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(show && showDialogSetting)\\n\\t\\t\\tnew FilesChangedDialog(view,states);\\n\\t} \\n\\tpublic static InputHandler getInputHandler()\\n\\t{\\n\\t\\treturn inputHandler;\\n\\t} \\n\\tpublic static View newView(View view)\\n\\t{\\n\\t\\treturn newView(view,null,false);\\n\\t} \\n\\tpublic static View newView(View view, Buffer buffer)\\n\\t{\\n\\t\\treturn newView(view,buffer,false);\\n\\t} \\n\\tpublic static View newView(View view, Buffer buffer, boolean plainView)\\n\\t{\\n\\t\\tView.ViewConfig config;\\n\\t\\tif(view != null && (plainView == view.isPlainView()))\\n\\t\\t\\tconfig = view.getViewConfig();\\n\\t\\telse\\n\\t\\t\\tconfig = new View.ViewConfig(plainView);\\n\\t\\treturn newView(view,buffer,config);\\n\\t} \\n\\tpublic static View newView(View view, Buffer buffer, View.ViewConfig config)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tif(view != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tview.showWaitCursor();\\n\\t\\t\\t\\tview.getEditPane().saveCaretInfo();\\n\\t\\t\\t}\\n\\t\\t\\tView newView = new View(buffer,config);\\n\\t\\t\\taddViewToList(newView);\\n\\t\\t\\tif(!config.plainView)\\n\\t\\t\\t{\\n\\t\\t\\t\\tDockableWindowManager wm = newView.getDockableWindowManager();\\n\\t\\t\\t\\tif(config.top != null\\n\\t\\t\\t\\t\\t&& config.top.length() != 0)\\n\\t\\t\\t\\t\\twm.showDockableWindow(config.top);\\n\\t\\t\\t\\tif(config.left != null\\n\\t\\t\\t\\t\\t&& config.left.length() != 0)\\n\\t\\t\\t\\t\\twm.showDockableWindow(config.left);\\n\\t\\t\\t\\tif(config.bottom != null\\n\\t\\t\\t\\t\\t&& config.bottom.length() != 0)\\n\\t\\t\\t\\t\\twm.showDockableWindow(config.bottom);\\n\\t\\t\\t\\tif(config.right != null\\n\\t\\t\\t\\t\\t&& config.right.length() != 0)\\n\\t\\t\\t\\t\\twm.showDockableWindow(config.right);\\n\\t\\t\\t}\\n\\t\\t\\tnewView.pack();\\n\\t\\t\\tif(config.width != 0 && config.height != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tGUIUtilities.setWindowBounds(newView,config.x,config.y,\\n\\t\\t\\t\\t\\tconfig.width,config.height,config.extState);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tnewView.setLocationRelativeTo(view);\\n\\t\\t\\tEditBus.send(new ViewUpdate(newView,ViewUpdate.CREATED));\\n\\t\\t\\tnewView.show();\\n\\t\\t\\t\\t\\t\\tif(newView == viewsFirst)\\n\\t\\t\\t{\\n\\t\\t\\t\\tnewView.getTextArea().requestFocus();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(settingsDirectory != null && getBooleanProperty(\\\"firstTime\\\"))\\n\\t\\t\\t\\t\\tnew HelpViewer();\\n\\t\\t\\t\\telse if(jEdit.getBooleanProperty(\\\"tip.show\\\"))\\n\\t\\t\\t\\t\\tnew TipOfTheDay(newView);\\n\\t\\t\\t\\tsetBooleanProperty(\\\"firstTime\\\",false);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tGUIUtilities.requestFocus(newView,newView.getTextArea());\\n\\t\\t\\treturn newView;\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tif(view != null)\\n\\t\\t\\t\\tview.hideWaitCursor();\\n\\t\\t}\\n\\t} \\n\\tpublic static void closeView(View view)\\n\\t{\\n\\t\\tcloseView(view,true);\\n\\t} \\n\\tpublic static View[] getViews()\\n\\t{\\n\\t\\tView[] views = new View[viewCount];\\n\\t\\tView view = viewsFirst;\\n\\t\\tfor(int i = 0; i < viewCount; i++)\\n\\t\\t{\\n\\t\\t\\tviews[i] = view;\\n\\t\\t\\tview = view.next;\\n\\t\\t}\\n\\t\\treturn views;\\n\\t} \\n\\tpublic static int getViewCount()\\n\\t{\\n\\t\\treturn viewCount;\\n\\t} \\n\\tpublic static View getFirstView()\\n\\t{\\n\\t\\treturn viewsFirst;\\n\\t} \\n\\tpublic static View getLastView()\\n\\t{\\n\\t\\treturn viewsLast;\\n\\t} \\n\\tpublic static View getActiveView()\\n\\t{\\n\\t\\treturn activeView;\\n\\t} \\n\\tpublic static boolean isMainThread()\\n\\t{\\n\\t\\treturn (Thread.currentThread() == mainThread);\\n\\t} \\n\\tpublic static boolean isBackgroundModeEnabled()\\n\\t{\\n\\t\\treturn background;\\n\\t} \\n\\tpublic static void showMemoryDialog(View view)\\n\\t{\\n\\t\\tRuntime rt = Runtime.getRuntime();\\n\\t\\tint before = (int) (rt.freeMemory() / 1024);\\n\\t\\tSystem.gc();\\n\\t\\tint after = (int) (rt.freeMemory() / 1024);\\n\\t\\tint total = (int) (rt.totalMemory() / 1024);\\n\\t\\tJProgressBar progress = new JProgressBar(0,total);\\n\\t\\tprogress.setValue(total - after);\\n\\t\\tprogress.setStringPainted(true);\\n\\t\\tprogress.setString(jEdit.getProperty(\\\"memory-status.use\\\",\\n\\t\\t\\tnew Object[] { new Integer(total - after),\\n\\t\\t\\tnew Integer(total) }));\\n\\t\\tObject[] message = new Object[4];\\n\\t\\tmessage[0] = getProperty(\\\"memory-status.gc\\\",\\n\\t\\t\\tnew Object[] { new Integer(after - before) });\\n\\t\\tmessage[1] = Box.createVerticalStrut(12);\\n\\t\\tmessage[2] = progress;\\n\\t\\tmessage[3] = Box.createVerticalStrut(6);\\n\\t\\tJOptionPane.showMessageDialog(view,message,\\n\\t\\t\\tjEdit.getProperty(\\\"memory-status.title\\\"),\\n\\t\\t\\tJOptionPane.INFORMATION_MESSAGE);\\n\\t} \\n\\tpublic static String getJEditHome()\\n\\t{\\n\\t\\treturn jEditHome;\\n\\t} \\n\\tpublic static String getSettingsDirectory()\\n\\t{\\n\\t\\treturn settingsDirectory;\\n\\t} \\n\\tpublic static String getJARCacheDirectory()\\n\\t{\\n\\t\\treturn jarCacheDirectory;\\n\\t} \\n\\tpublic static void backupSettingsFile(File file)\\n\\t{\\n\\t\\tif(settingsDirectory == null)\\n\\t\\t\\treturn;\\n\\t\\tString backupDir = MiscUtilities.constructPath(\\n\\t\\t\\tsettingsDirectory,\\\"settings-backup\\\");\\n\\t\\tFile dir = new File(backupDir);\\n\\t\\tif(!dir.exists())\\n\\t\\t\\tdir.mkdirs();\\n\\t\\tMiscUtilities.saveBackup(file,5,null,\\\"~\\\",backupDir);\\n\\t} \\n\\tpublic static void saveSettings()\\n\\t{\\n\\t\\tif(settingsDirectory != null)\\n\\t\\t{\\n\\t\\t\\tAbbrevs.save();\\n\\t\\t\\tFavoritesVFS.saveFavorites();\\n\\t\\t\\tHistoryModel.saveHistory();\\n\\t\\t\\tRegisters.saveRegisters();\\n\\t\\t\\tSearchAndReplace.save();\\n\\t\\t\\t\\t\\t\\tFile file1 = new File(MiscUtilities.constructPath(\\n\\t\\t\\t\\tsettingsDirectory, \\\"#recent.xml#save#\\\"));\\n\\t\\t\\tFile file2 = new File(MiscUtilities.constructPath(\\n\\t\\t\\t\\tsettingsDirectory, \\\"recent.xml\\\"));\\n\\t\\t\\tif(file2.exists() && file2.lastModified() != recentModTime)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.WARNING,jEdit.class,file2 + \\\" changed\\\"\\n\\t\\t\\t\\t\\t+ \\\" on disk; will not save recent files\\\");\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tbackupSettingsFile(file2);\\n\\t\\t\\t\\tBufferHistory.save(file1);\\n\\t\\t\\t\\tfile2.delete();\\n\\t\\t\\t\\tfile1.renameTo(file2);\\n\\t\\t\\t}\\n\\t\\t\\trecentModTime = file2.lastModified();\\n\\t\\t\\tfile1 = new File(MiscUtilities.constructPath(\\n\\t\\t\\t\\tsettingsDirectory,\\\"#properties#save#\\\"));\\n\\t\\t\\tfile2 = new File(MiscUtilities.constructPath(\\n\\t\\t\\t\\tsettingsDirectory,\\\"properties\\\"));\\n\\t\\t\\tif(file2.exists() && file2.lastModified() != propsModTime)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.WARNING,jEdit.class,file2 + \\\" changed\\\"\\n\\t\\t\\t\\t\\t+ \\\" on disk; will not save user properties\\\");\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tbackupSettingsFile(file2);\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tOutputStream out = new FileOutputStream(file1);\\n\\t\\t\\t\\t\\tprops.store(out,\\\"jEdit properties\\\");\\n\\t\\t\\t\\t\\tout.close();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tLog.log(Log.ERROR,jEdit.class,io);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfile2.delete();\\n\\t\\t\\t\\tfile1.renameTo(file2);\\n\\t\\t\\t}\\n\\t\\t\\tpropsModTime = file2.lastModified();\\n\\t\\t}\\n\\t} \\n\\tpublic static void exit(View view, boolean reallyExit)\\n\\t{\\n\\t\\t\\t\\tif(view == null)\\n\\t\\t\\tview = activeView;\\n\\t\\t\\t\\tVFSManager.waitForRequests();\\n\\t\\t\\t\\tEditBus.send(new EditorExitRequested(view));\\n\\t\\t\\t\\t\\t\\treallyExit |= !background;\\n\\t\\tPerspectiveManager.savePerspective(false);\\n\\t\\t\\t\\tif(!closeAllBuffers(view,reallyExit))\\n\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\tif(!reallyExit)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tview = viewsFirst;\\n\\t\\t\\twhile(view != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcloseView(view,false);\\n\\t\\t\\t\\tview = view.next;\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tsaveSettings();\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(view != null)\\n\\t\\t\\t\\tview.close();\\n\\t\\t\\t\\t\\t\\tAutosave.stop();\\n\\t\\t\\t\\t\\t\\tif(server != null)\\n\\t\\t\\t\\tserver.stopServer();\\n\\t\\t\\t\\t\\t\\tPluginJAR[] plugins = getPluginJARs();\\n\\t\\t\\tfor(int i = 0; i < plugins.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tremovePluginJAR(plugins[i],true);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tEditBus.send(new EditorExiting(null));\\n\\t\\t\\t\\t\\t\\tsaveSettings();\\n\\t\\t\\t\\t\\t\\tLog.closeStream();\\n\\t\\t\\t\\t\\t\\tSystem.exit(0);\\n\\t\\t}\\n\\t} \\n\\tstatic void updatePosition(String oldPath, Buffer buffer)\\n\\t{\\n\\t\\tboolean caseInsensitiveFilesystem =\\n\\t\\t\\tOperatingSystem.isDOSDerived()\\n\\t\\t\\t|| OperatingSystem.isMacOS();\\n\\t\\tif(caseInsensitiveFilesystem)\\n\\t\\t\\toldPath = oldPath.toLowerCase();\\n\\t\\tbufferHash.remove(oldPath);\\n\\t\\tString path = buffer.getPath();\\n\\t\\tif(caseInsensitiveFilesystem)\\n\\t\\t\\tpath = path.toLowerCase();\\n\\t\\tbufferHash.put(path,buffer);\\n\\t\\tif(sortBuffers)\\n\\t\\t{\\n\\t\\t\\tremoveBufferFromList(buffer);\\n\\t\\t\\taddBufferToList(buffer);\\n\\t\\t}\\n\\t} \\n\\tpublic static void addMode(Mode mode)\\n\\t{\\n\\t\\tmodes.addElement(mode);\\n\\t} \\n\\t static void loadMode(Mode mode)\\n\\t{\\n\\t\\tfinal String fileName = (String)mode.getProperty(\\\"file\\\");\\n\\t\\tLog.log(Log.NOTICE,jEdit.class,\\\"Loading edit mode \\\" + fileName);\\n\\t\\tfinal XmlParser parser = new XmlParser();\\n\\t\\tXModeHandler xmh = new XModeHandler(mode.getName())\\n\\t\\t{\\n\\t\\t\\tpublic void error(String what, Object subst)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint line = parser.getLineNumber();\\n\\t\\t\\t\\tint column = parser.getColumnNumber();\\n\\t\\t\\t\\tString msg;\\n\\t\\t\\t\\tif(subst == null)\\n\\t\\t\\t\\t\\tmsg = jEdit.getProperty(\\\"xmode-error.\\\" + what);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmsg = jEdit.getProperty(\\\"xmode-error.\\\" + what,\\n\\t\\t\\t\\t\\t\\tnew String[] { subst.toString() });\\n\\t\\t\\t\\t\\tif(subst instanceof Throwable)\\n\\t\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,subst);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tObject[] args = { fileName, new Integer(line),\\n\\t\\t\\t\\t\\tnew Integer(column), msg };\\n\\t\\t\\t\\tGUIUtilities.error(null,\\\"xmode-error\\\",args);\\n\\t\\t\\t}\\n\\t\\t\\tpublic TokenMarker getTokenMarker(String modeName)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn getMode(modeName).getTokenMarker();\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tmode.setTokenMarker(xmh.getTokenMarker());\\n\\t\\tReader grammar = null;\\n\\t\\tparser.setHandler(xmh);\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tgrammar = new BufferedReader(new FileReader(fileName));\\n\\t\\t\\tparser.parse(null, null, grammar);\\n\\t\\t\\tmode.setProperties(xmh.getModeProperties());\\n\\t\\t}\\n\\t\\tcatch (Throwable e)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.ERROR, jEdit.class, e);\\n\\t\\t\\tif (e instanceof XmlException)\\n\\t\\t\\t{\\n\\t\\t\\t\\tXmlException xe = (XmlException) e;\\n\\t\\t\\t\\tint line = xe.getLine();\\n\\t\\t\\t\\tString message = xe.getMessage();\\n\\t\\t\\t\\tObject[] args = { fileName, new Integer(line), null,\\n\\t\\t\\t\\t\\tmessage };\\n\\t\\t\\t\\tGUIUtilities.error(null,\\\"xmode-error\\\",args);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(grammar != null)\\n\\t\\t\\t\\t\\tgrammar.close();\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,jEdit.class,io);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t static void loadProps(InputStream in, boolean def)\\n\\t\\tthrows IOException\\n\\t{\\n\\t\\tif(def)\\n\\t\\t\\tdefaultProps.load(in);\\n\\t\\telse\\n\\t\\t\\tprops.load(in);\\n\\t\\tin.close();\\n\\t} \\n\\t\\t static void addProperties(Map map)\\n\\t{\\n\\t\\tIterator keys = map.keySet().iterator();\\n\\t\\twhile(keys.hasNext())\\n\\t\\t{\\n\\t\\t\\tObject key   = keys.next();\\n\\t\\t\\tObject value = map.get(key);\\n\\t\\t\\tdefaultProps.put(key,value);\\n\\t\\t}\\n\\t} \\n\\t\\tstatic void pluginError(String path, String messageProp,\\n\\t\\tObject[] args)\\n\\t{\\n\\t\\tsynchronized(pluginErrorLock)\\n\\t\\t{\\n\\t\\t\\tif(pluginErrors == null)\\n\\t\\t\\t\\tpluginErrors = new Vector();\\n\\t\\t\\tErrorListDialog.ErrorEntry newEntry =\\n\\t\\t\\t\\tnew ErrorListDialog.ErrorEntry(\\n\\t\\t\\t\\tpath,messageProp,args);\\n\\t\\t\\tfor(int i = 0; i < pluginErrors.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(pluginErrors.get(i).equals(newEntry))\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tpluginErrors.addElement(newEntry);\\n\\t\\t\\tif(startupDone)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSwingUtilities.invokeLater(new Runnable()\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tpublic void run()\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tshowPluginErrorDialog();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tstatic void setActiveView(View view)\\n\\t{\\n\\t\\tjEdit.activeView = view;\\n\\t} \\n\\t\\tprivate static String jEditHome;\\n\\tprivate static String settingsDirectory;\\n\\tprivate static String jarCacheDirectory;\\n\\tprivate static long propsModTime, recentModTime;\\n\\tprivate static Properties defaultProps;\\n\\tprivate static Properties props;\\n\\tprivate static EditServer server;\\n\\tprivate static boolean background;\\n\\tprivate static ActionContext actionContext;\\n\\tprivate static ActionSet builtInActionSet;\\n\\tprivate static Vector pluginErrors;\\n\\tprivate static Object pluginErrorLock = new Object();\\n\\tprivate static Vector jars;\\n\\tprivate static Vector modes;\\n\\tprivate static boolean saveCaret;\\n\\tprivate static InputHandler inputHandler;\\n\\tprivate static JEditMetalTheme theme;\\n\\t\\tprivate static boolean sortBuffers;\\n\\tprivate static boolean sortByName;\\n\\tprivate static int bufferCount;\\n\\tprivate static Buffer buffersFirst;\\n\\tprivate static Buffer buffersLast;\\n\\tprivate static Map bufferHash;\\n\\t\\tprivate static Object bufferListLock = new Object();\\n\\t\\tprivate static int viewCount;\\n\\tprivate static View viewsFirst;\\n\\tprivate static View viewsLast;\\n\\tprivate static View activeView;\\n\\tprivate static boolean startupDone;\\n\\tprivate static Thread mainThread;\\n\\tprivate jEdit() {}\\n\\t\\tprivate static void usage()\\n\\t{\\n\\t\\tSystem.out.println(\\\"Usage: jedit [<options>] [<files>]\\\");\\n\\t\\tSystem.out.println(\\\"\\t<file> +marker:<marker>: Positions caret\\\"\\n\\t\\t\\t+ \\\" at marker <marker>\\\");\\n\\t\\tSystem.out.println(\\\"\\t<file> +line:<line>: Positions caret\\\"\\n\\t\\t\\t+ \\\" at line number <line>\\\");\\n\\t\\tSystem.out.println(\\\"\\t--: End of options\\\");\\n\\t\\tSystem.out.println(\\\"\\t-background: Run in background mode\\\");\\n\\t\\tSystem.out.println(\\\"\\t-gui: Only if running in background mode; open initial view (default)\\\");\\n\\t\\tSystem.out.println(\\\"\\t-nogui: Only if running in background mode; don't open initial view\\\");\\n\\t\\tSystem.out.println(\\\"\\t-log=<level>: Log messages with level equal to or higher than this to\\\");\\n\\t\\tSystem.out.println(\\\"\\t standard error. <level> must be between 1 and 9. Default is 7.\\\");\\n\\t\\tSystem.out.println(\\\"\\t-newplainview: Client instance opens a new plain view\\\");\\n\\t\\tSystem.out.println(\\\"\\t-newview: Client instance opens a new view (default)\\\");\\n\\t\\tSystem.out.println(\\\"\\t-plugins: Load plugins (default)\\\");\\n\\t\\tSystem.out.println(\\\"\\t-noplugins: Don't load any plugins\\\");\\n\\t\\tSystem.out.println(\\\"\\t-restore: Restore previously open files (default)\\\");\\n\\t\\tSystem.out.println(\\\"\\t-norestore: Don't restore previously open files\\\");\\n\\t\\tSystem.out.println(\\\"\\t-reuseview: Client instance reuses existing view\\\");\\n\\t\\tSystem.out.println(\\\"\\t-quit: Quit a running instance\\\");\\n\\t\\tSystem.out.println(\\\"\\t-run=<script>: Run the specified BeanShell script\\\");\\n\\t\\tSystem.out.println(\\\"\\t-server: Read/write server info from/to $HOME/.jedit/server (default)\\\");\\n\\t\\tSystem.out.println(\\\"\\t-server=<name>: Read/write server info from/to $HOME/.jedit/<name>\\\");\\n\\t\\tSystem.out.println(\\\"\\t-noserver: Don't start edit server\\\");\\n\\t\\tSystem.out.println(\\\"\\t-settings=<path>: Load user-specific settings from <path>\\\");\\n\\t\\tSystem.out.println(\\\"\\t-nosettings: Don't load user-specific settings\\\");\\n\\t\\tSystem.out.println(\\\"\\t-startupscripts: Run startup scripts (default)\\\");\\n\\t\\tSystem.out.println(\\\"\\t-nostartupscripts: Don't run startup scripts\\\");\\n\\t\\tSystem.out.println(\\\"\\t-version: Print jEdit version and exit\\\");\\n\\t\\tSystem.out.println(\\\"\\t-usage: Print this message and exit\\\");\\n\\t\\tSystem.out.println();\\n\\t\\tSystem.out.println(\\\"Report bugs to Slava Pestov <slava@jedit.org>.\\\");\\n\\t} \\n\\t\\tprivate static void version()\\n\\t{\\n\\t\\tSystem.out.println(\\\"jEdit \\\" + getVersion());\\n\\t} \\n\\tprivate static String makeServerScript(boolean wait,\\n\\t\\tboolean restore, boolean newView,\\n\\t\\tboolean newPlainView, String[] args,\\n\\t\\tString scriptFile)\\n\\t{\\n\\t\\tStringBuffer script = new StringBuffer();\\n\\t\\tString userDir = System.getProperty(\\\"user.dir\\\");\\n\\t\\tscript.append(\\\"parent = \\\\\\\"\\\");\\n\\t\\tscript.append(MiscUtilities.charsToEscapes(userDir));\\n\\t\\tscript.append(\\\"\\\\\\\";\\\\n\\\");\\n\\t\\tscript.append(\\\"args = new String[\\\");\\n\\t\\tscript.append(args.length);\\n\\t\\tscript.append(\\\"];\\\\n\\\");\\n\\t\\tfor(int i = 0; i < args.length; i++)\\n\\t\\t{\\n\\t\\t\\tscript.append(\\\"args[\\\");\\n\\t\\t\\tscript.append(i);\\n\\t\\t\\tscript.append(\\\"] = \\\");\\n\\t\\t\\tif(args[i] == null)\\n\\t\\t\\t\\tscript.append(\\\"null\\\");\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tscript.append('\\\"');\\n\\t\\t\\t\\tscript.append(MiscUtilities.charsToEscapes(args[i]));\\n\\t\\t\\t\\tscript.append('\\\"');\\n\\t\\t\\t}\\n\\t\\t\\tscript.append(\\\";\\\\n\\\");\\n\\t\\t}\\n\\t\\tscript.append(\\\"view = jEdit.getLastView();\\\\n\\\");\\n\\t\\tscript.append(\\\"buffer = EditServer.handleClient(\\\"\\n\\t\\t\\t+ restore + \\\",\\\" + newView + \\\",\\\" + newPlainView +\\n\\t\\t\\t\\\",parent,args);\\\\n\\\");\\n\\t\\tscript.append(\\\"if(buffer != null && \\\" + wait + \\\") {\\\\n\\\");\\n\\t\\tscript.append(\\\"\\\\tbuffer.setWaitSocket(socket);\\\\n\\\");\\n\\t\\tscript.append(\\\"\\\\tdoNotCloseSocket = true;\\\\n\\\");\\n\\t\\tscript.append(\\\"}\\\\n\\\");\\n\\t\\tscript.append(\\\"if(view != jEdit.getLastView() && \\\" + wait + \\\") {\\\\n\\\");\\n\\t\\tscript.append(\\\"\\\\tjEdit.getLastView().setWaitSocket(socket);\\\\n\\\");\\n\\t\\tscript.append(\\\"\\\\tdoNotCloseSocket = true;\\\\n\\\");\\n\\t\\tscript.append(\\\"}\\\\n\\\");\\n\\t\\tscript.append(\\\"if(doNotCloseSocket == void)\\\\n\\\");\\n\\t\\tscript.append(\\\"\\\\tsocket.close();\\\\n\\\");\\n\\t\\tif(scriptFile != null)\\n\\t\\t{\\n\\t\\t\\tscriptFile = MiscUtilities.constructPath(userDir,scriptFile);\\n\\t\\t\\tscript.append(\\\"BeanShell.runScript(null,\\\\\\\"\\\"\\n\\t\\t\\t\\t+ MiscUtilities.charsToEscapes(scriptFile)\\n\\t\\t\\t\\t+ \\\"\\\\\\\",null,false);\\\\n\\\");\\n\\t\\t}\\n\\t\\treturn script.toString();\\n\\t} \\n\\tprivate static void initMisc()\\n\\t{\\n\\t\\tjars = new Vector();\\n\\t\\tactionContext = new ActionContext()\\n\\t\\t{\\n\\t\\t\\tpublic void invokeAction(EventObject evt,\\n\\t\\t\\t\\tEditAction action)\\n\\t\\t\\t{\\n\\t\\t\\t\\tView view = GUIUtilities.getView(\\n\\t\\t\\t\\t\\t(Component)evt.getSource());\\n\\t\\t\\t\\tview.getInputHandler().invokeAction(action);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tbufferHash = new HashMap();\\n\\t\\tinputHandler = new DefaultInputHandler(null);\\n\\t\\t\\t\\tSystem.getProperties().put(\\\"java.protocol.handler.pkgs\\\",\\n\\t\\t\\t\\\"org.gjt.sp.jedit.proto|\\\" +\\n\\t\\t\\tSystem.getProperty(\\\"java.protocol.handler.pkgs\\\",\\\"\\\"));\\n\\t\\t\\t\\tString userAgent = \\\"jEdit/\\\" + getVersion()\\n\\t\\t\\t+ \\\" (Java \\\" + System.getProperty(\\\"java.version\\\")\\n\\t\\t\\t+ \\\". \\\" + System.getProperty(\\\"java.vendor\\\")\\n\\t\\t\\t+ \\\"; \\\" + System.getProperty(\\\"os.arch\\\") + \\\")\\\";\\n\\t\\tSystem.getProperties().put(\\\"http.agent\\\",userAgent);\\n\\t\\tjEditHome = System.getProperty(\\\"jedit.home\\\");\\n\\t\\tif(jEditHome == null)\\n\\t\\t{\\n\\t\\t\\tString classpath = System\\n\\t\\t\\t\\t.getProperty(\\\"java.class.path\\\");\\n\\t\\t\\tint index = classpath.toLowerCase()\\n\\t\\t\\t\\t.indexOf(\\\"jedit.jar\\\");\\n\\t\\t\\tint start = classpath.lastIndexOf(File\\n\\t\\t\\t\\t.pathSeparator,index) + 1;\\n\\t\\t\\t\\t\\t\\t if(classpath.equalsIgnoreCase(\\\"jedit.jar\\\"))\\n\\t\\t\\t{\\n\\t\\t\\t\\tjEditHome = System.getProperty(\\\"user.dir\\\");\\n\\t\\t\\t}\\n\\t\\t\\telse if(index > start)\\n\\t\\t\\t{\\n\\t\\t\\t\\tjEditHome = classpath.substring(start,\\n\\t\\t\\t\\t\\tindex - 1);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tjEditHome = System.getProperty(\\\"user.dir\\\");\\n\\t\\t\\t\\t\\tLog.log(Log.WARNING,jEdit.class,\\\"jedit.jar not in class path!\\\");\\n\\t\\t\\t\\t\\tLog.log(Log.WARNING,jEdit.class,\\\"Assuming jEdit is installed in \\\"\\n\\t\\t\\t\\t\\t\\t+ jEditHome + \\\".\\\");\\n\\t\\t\\t\\t\\tLog.log(Log.WARNING,jEdit.class,\\\"Override with jedit.home \\\"\\n\\t\\t\\t\\t\\t\\t+ \\\"system property.\\\");\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tLog.log(Log.MESSAGE,jEdit.class,\\\"jEdit home directory is \\\" + jEditHome);\\n\\t\\tif(settingsDirectory != null)\\n\\t\\t{\\n\\t\\t\\tjarCacheDirectory = MiscUtilities.constructPath(\\n\\t\\t\\t\\tsettingsDirectory,\\\"jars-cache\\\");\\n\\t\\t\\tnew File(jarCacheDirectory).mkdirs();\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tEditBus.addToBus(new SettingsReloader());\\n\\t\\t\\t\\t\\t\\tSwingUtilities.invokeLater(new Runnable()\\n\\t\\t{\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\tThread.currentThread().setContextClassLoader(\\n\\t\\t\\t\\t\\tnew JARClassLoader());\\n\\t\\t\\t}\\n\\t\\t});\\n\\t} \\n\\tprivate static void initSystemProperties()\\n\\t{\\n\\t\\tdefaultProps = props = new Properties();\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tloadProps(jEdit.class.getResourceAsStream(\\n\\t\\t\\t\\t\\\"/org/gjt/sp/jedit/jedit.props\\\"),true);\\n\\t\\t\\tloadProps(jEdit.class.getResourceAsStream(\\n\\t\\t\\t\\t\\\"/org/gjt/sp/jedit/jedit_gui.props\\\"),true);\\n\\t\\t\\tloadProps(jEdit.class.getResourceAsStream(\\n\\t\\t\\t\\t\\\"/org/gjt/sp/jedit/jedit_keys.props\\\"),true);\\n\\t\\t}\\n\\t\\tcatch(Exception e)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.ERROR,jEdit.class,\\n\\t\\t\\t\\t\\\"Error while loading system properties!\\\");\\n\\t\\t\\tLog.log(Log.ERROR,jEdit.class,\\n\\t\\t\\t\\t\\\"One of the following property files could not be loaded:\\\\n\\\"\\n\\t\\t\\t\\t+ \\\"- jedit.props\\\\n\\\"\\n\\t\\t\\t\\t+ \\\"- jedit_gui.props\\\\n\\\"\\n\\t\\t\\t\\t+ \\\"- jedit_keys.props\\\\n\\\"\\n\\t\\t\\t\\t+ \\\"jedit.jar is probably corrupt.\\\");\\n\\t\\t\\tLog.log(Log.ERROR,jEdit.class,e);\\n\\t\\t\\tSystem.exit(1);\\n\\t\\t}\\n\\t} \\n\\tprivate static void initSiteProperties()\\n\\t{\\n\\t\\tString siteSettingsDirectory = MiscUtilities.constructPath(\\n\\t\\t\\tjEditHome, \\\"properties\\\");\\n\\t\\tFile siteSettings = new File(siteSettingsDirectory);\\n\\t\\tif (!(siteSettings.exists() && siteSettings.isDirectory()))\\n\\t\\t\\treturn;\\n\\t\\tString[] snippets = siteSettings.list();\\n\\t\\tif (snippets == null)\\n\\t\\t\\treturn;\\n\\t\\tMiscUtilities.quicksort(snippets,\\n\\t\\t\\tnew MiscUtilities.StringICaseCompare());\\n\\t\\tfor (int i = 0; i < snippets.length; ++i)\\n\\t\\t{\\n\\t\\t\\tString snippet = snippets[i];\\n\\t\\t\\tif(!snippet.toLowerCase().endsWith(\\\".props\\\"))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tString path = MiscUtilities.constructPath(\\n\\t\\t\\t\\t\\tsiteSettingsDirectory,snippet);\\n\\t\\t\\t\\tLog.log(Log.DEBUG,jEdit.class,\\n\\t\\t\\t\\t\\t\\\"Loading site snippet: \\\" + path);\\n\\t\\t\\t\\tloadProps(new FileInputStream(new File(path)),true);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(FileNotFoundException fnf)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,jEdit.class,fnf);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException e)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,jEdit.class,\\\"Cannot load site snippet \\\"\\n\\t\\t\\t\\t\\t+ snippet);\\n\\t\\t\\t\\tLog.log(Log.ERROR,jEdit.class,e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate static void initResources()\\n\\t{\\n\\t\\tbuiltInActionSet = new ActionSet(null,null,null,\\n\\t\\t\\tjEdit.class.getResource(\\\"actions.xml\\\"));\\n\\t\\tbuiltInActionSet.setLabel(getProperty(\\\"action-set.jEdit\\\"));\\n\\t\\tbuiltInActionSet.load();\\n\\t\\tactionContext.addActionSet(builtInActionSet);\\n\\t\\tDockableWindowManager.loadDockableWindows(null,\\n\\t\\t\\tjEdit.class.getResource(\\\"dockables.xml\\\"),\\n\\t\\t\\tnull);\\n\\t\\tServiceManager.loadServices(null,\\n\\t\\t\\tjEdit.class.getResource(\\\"services.xml\\\"),\\n\\t\\t\\tnull);\\n\\t} \\n\\tprivate static void initPlugins()\\n\\t{\\n\\t\\tif(jEditHome != null)\\n\\t\\t{\\n\\t\\t\\taddPluginJARsFromDirectory(MiscUtilities.constructPath(\\n\\t\\t\\t\\tjEditHome,\\\"jars\\\"));\\n\\t\\t}\\n\\t\\tif(settingsDirectory != null)\\n\\t\\t{\\n\\t\\t\\tFile jarsDirectory = new File(settingsDirectory,\\\"jars\\\");\\n\\t\\t\\tif(!jarsDirectory.exists())\\n\\t\\t\\t\\tjarsDirectory.mkdir();\\n\\t\\t\\taddPluginJARsFromDirectory(jarsDirectory.getPath());\\n\\t\\t}\\n\\t\\tPluginJAR[] jars = getPluginJARs();\\n\\t\\tfor(int i = 0; i < jars.length; i++)\\n\\t\\t{\\n\\t\\t\\tjars[i].checkDependencies();\\n\\t\\t}\\n\\t} \\n\\tprivate static void initUserProperties()\\n\\t{\\n\\t\\tprops = new Properties(defaultProps);\\n\\t\\tif(settingsDirectory != null)\\n\\t\\t{\\n\\t\\t\\tFile file = new File(MiscUtilities.constructPath(\\n\\t\\t\\t\\tsettingsDirectory,\\\"properties\\\"));\\n\\t\\t\\tpropsModTime = file.lastModified();\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tloadProps(new FileInputStream(file),false);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(FileNotFoundException fnf)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\tcatch(IOException e)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,jEdit.class,e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tprivate static void initPLAF()\\n\\t{\\n\\t\\ttheme = new JEditMetalTheme();\\n\\t\\ttheme.propertiesChanged();\\n\\t\\tMetalLookAndFeel.setCurrentTheme(theme);\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tString lf = getProperty(\\\"lookAndFeel\\\");\\n\\t\\t\\tif(lf != null && lf.length() != 0)\\n\\t\\t\\t\\tUIManager.setLookAndFeel(lf);\\n\\t\\t}\\n\\t\\tcatch(Exception e)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.ERROR,jEdit.class,e);\\n\\t\\t}\\n\\t\\tUIDefaults defaults = UIManager.getDefaults();\\n\\t\\t\\t\\tif(jEdit.getBooleanProperty(\\\"textColors\\\"))\\n\\t\\t{\\n\\t\\t\\tColor background = new javax.swing.plaf.ColorUIResource(\\n\\t\\t\\t\\tjEdit.getColorProperty(\\\"view.bgColor\\\"));\\n\\t\\t\\tColor foreground = new javax.swing.plaf.ColorUIResource(\\n\\t\\t\\t\\tjEdit.getColorProperty(\\\"view.fgColor\\\"));\\n\\t\\t\\tColor caretColor = new javax.swing.plaf.ColorUIResource(\\n\\t\\t\\t\\tjEdit.getColorProperty(\\\"view.caretColor\\\"));\\n\\t\\t\\tColor selectionColor = new javax.swing.plaf.ColorUIResource(\\n\\t\\t\\t\\tjEdit.getColorProperty(\\\"view.selectionColor\\\"));\\n\\t\\t\\tString[] prefixes = { \\\"TextField\\\", \\\"TextArea\\\", \\\"List\\\", \\\"Table\\\" };\\n\\t\\t\\tfor(int i = 0; i < prefixes.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tString prefix = prefixes[i];\\n\\t\\t\\t\\tdefaults.put(prefix + \\\".disabledBackground\\\",background);\\n\\t\\t\\t\\tdefaults.put(prefix + \\\".background\\\",background);\\n\\t\\t\\t\\tdefaults.put(prefix + \\\".disabledForeground\\\",foreground);\\n\\t\\t\\t\\tdefaults.put(prefix + \\\".foreground\\\",foreground);\\n\\t\\t\\t\\tdefaults.put(prefix + \\\".caretForeground\\\",caretColor);\\n\\t\\t\\t\\tdefaults.put(prefix + \\\".selectionForeground\\\",foreground);\\n\\t\\t\\t\\tdefaults.put(prefix + \\\".selectionBackground\\\",selectionColor);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\tdefaults.put(\\\"Tree.background\\\",background);\\n\\t\\t\\tdefaults.put(\\\"Tree.foreground\\\",foreground);\\n\\t\\t\\tdefaults.put(\\\"Tree.textBackground\\\",background);\\n\\t\\t\\tdefaults.put(\\\"Tree.textForeground\\\",foreground);\\n\\t\\t\\tdefaults.put(\\\"Tree.selectionForeground\\\",foreground);\\n\\t\\t\\tdefaults.put(\\\"Tree.selectionBackground\\\",selectionColor);\\n\\t\\t}\\n\\t\\tdefaults.remove(\\\"SplitPane.border\\\");\\n\\t\\tdefaults.remove(\\\"SplitPaneDivider.border\\\");\\n\\t} \\n\\tprivate static void runStartupScripts(File directory)\\n\\t{\\n\\t\\tif (!directory.isDirectory())\\n\\t\\t\\treturn;\\n\\t\\tFile[] snippets = directory.listFiles();\\n\\t\\tif (snippets == null)\\n\\t\\t\\treturn;\\n\\t\\tMiscUtilities.quicksort(snippets,\\n\\t\\t\\tnew MiscUtilities.StringICaseCompare());\\n\\t\\tfor(int i = 0; i < snippets.length; ++i)\\n\\t\\t{\\n\\t\\t\\tFile snippet = snippets[i];\\n\\t\\t\\tMacros.Handler handler = Macros.getHandlerForPathName(\\n\\t\\t\\t\\tsnippet.getPath());\\n\\t\\t\\tif(handler == null)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tMacros.Macro newMacro = handler.createMacro(\\n\\t\\t\\t\\t\\tsnippet.getName(),\\n\\t\\t\\t\\t\\tsnippet.getPath());\\n\\t\\t\\t\\thandler.runMacro(null,newMacro,false);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Exception e)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,jEdit.class,e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate static void initProxy()\\n\\t{\\n\\t\\tboolean socksEnabled = jEdit.getBooleanProperty(\\\"socks.enabled\\\");\\n\\t\\tif(!socksEnabled)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,jEdit.class,\\\"SOCKS proxy disabled\\\");\\n                        System.getProperties().remove(\\\"socksProxyHost\\\");\\n                        System.getProperties().remove(\\\"socksProxyPort\\\");\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString socksHost = jEdit.getProperty(\\\"firewall.socks.host\\\");\\n\\t\\t\\tif( socksHost != null )\\n\\t\\t\\t{\\n\\t\\t\\t\\tSystem.setProperty(\\\"socksProxyHost\\\", socksHost);\\n\\t\\t\\t\\tLog.log(Log.DEBUG, jEdit.class,\\n\\t\\t\\t\\t\\t\\\"SOCKS proxy enabled: \\\" + socksHost);\\n                        }\\n\\t\\t\\tString socksPort =  jEdit.getProperty(\\\"firewall.socks.port\\\");\\n\\t\\t\\tif(socksPort != null)\\n\\t\\t\\t\\tSystem.setProperty(\\\"socksProxyPort\\\", socksPort);\\n\\t\\t}\\n\\t\\tboolean httpEnabled = jEdit.getBooleanProperty(\\\"firewall.enabled\\\");\\n\\t\\tif (!httpEnabled)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG, jEdit.class, \\\"HTTP proxy disabled\\\");\\n\\t\\t\\tSystem.getProperties().remove(\\\"proxySet\\\");\\n\\t\\t\\tSystem.getProperties().remove(\\\"proxyHost\\\");\\n\\t\\t\\tSystem.getProperties().remove(\\\"proxyPort\\\");\\n\\t\\t\\tSystem.getProperties().remove(\\\"http.proxyHost\\\");\\n\\t\\t\\tSystem.getProperties().remove(\\\"http.proxyPort\\\");\\n\\t\\t\\tSystem.getProperties().remove(\\\"http.nonProxyHosts\\\");\\n\\t\\t\\tAuthenticator.setDefault(null);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tString host = jEdit.getProperty(\\\"firewall.host\\\");\\n\\t\\t\\tif (host == null)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tSystem.setProperty(\\\"http.proxyHost\\\", host);\\n\\t\\t\\tLog.log(Log.DEBUG, jEdit.class, \\\"HTTP proxy enabled: \\\" + host);\\n\\t\\t\\t\\t\\t\\tString port = jEdit.getProperty(\\\"firewall.port\\\");\\n\\t\\t\\tif (port != null)\\n\\t\\t\\t\\tSystem.setProperty(\\\"http.proxyPort\\\", port);\\n\\t\\t\\t\\t\\t\\tString nonProxyHosts = jEdit.getProperty(\\\"firewall.nonProxyHosts\\\");\\n\\t\\t\\tif (nonProxyHosts != null)\\n\\t\\t\\t\\tSystem.setProperty(\\\"http.nonProxyHosts\\\", nonProxyHosts);\\n\\t\\t\\t\\t\\t\\tString username = jEdit.getProperty(\\\"firewall.user\\\");\\n\\t\\t\\tString password = jEdit.getProperty(\\\"firewall.password\\\");\\n\\t\\t\\t\\t\\t\\tif(password == null)\\n\\t\\t\\t\\tpassword = \\\"\\\";\\n\\t\\t\\tif(username == null || username.length()==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG, jEdit.class, \\\"HTTP proxy without user\\\");\\n\\t\\t\\t\\tAuthenticator.setDefault(new FirewallAuthenticator(null));\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG, jEdit.class, \\\"HTTP proxy user: \\\" + username);\\n\\t\\t\\t\\tPasswordAuthentication pw = new PasswordAuthentication(\\n\\t\\t\\t\\t\\tusername,password.toCharArray()\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\tAuthenticator.setDefault(new FirewallAuthenticator(pw));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tstatic class FirewallAuthenticator extends Authenticator\\n\\t{\\n\\t\\tPasswordAuthentication pw;\\n\\t\\tpublic FirewallAuthenticator(PasswordAuthentication pw)\\n\\t\\t{\\n\\t\\t\\tthis.pw = pw;\\n\\t\\t}\\n\\t\\tprotected PasswordAuthentication getPasswordAuthentication()\\n\\t\\t{\\n\\t\\t\\treturn pw;\\n\\t\\t}\\n\\t} \\n\\t\\tprivate static void finishStartup(final boolean gui, final boolean restore,\\n\\t\\tfinal String userDir, final String[] args)\\n\\t{\\n\\t\\tSwingUtilities.invokeLater(new Runnable() {\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\tBuffer buffer = openFiles(null,userDir,args);\\n\\t\\t\\t\\tView view = null;\\n\\t\\t\\t\\tboolean restoreFiles = restore\\n\\t\\t\\t\\t\\t&& jEdit.getBooleanProperty(\\\"restore\\\")\\n\\t\\t\\t\\t\\t&& (getBufferCount() == 0\\n\\t\\t\\t\\t\\t|| jEdit.getBooleanProperty(\\\"restore.cli\\\"));\\n\\t\\t\\t\\tif(gui || getBufferCount() != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tview = PerspectiveManager.loadPerspective(restoreFiles);\\n\\t\\t\\t\\t\\tif(getBufferCount() == 0)\\n\\t\\t\\t\\t\\t\\tbuffer = newFile(null);\\n\\t\\t\\t\\t\\tif(view == null)\\n\\t\\t\\t\\t\\t\\tview = newView(null,buffer);\\n\\t\\t\\t\\t\\telse if(buffer != null)\\n\\t\\t\\t\\t\\t\\tview.setBuffer(buffer);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\tEditBus.send(new EditorStarted(null));\\n\\t\\t\\t\\tVFSManager.start();\\n\\t\\t\\t\\t\\t\\t\\t\\tif(server != null)\\n\\t\\t\\t\\t\\tserver.start();\\n\\t\\t\\t\\tGUIUtilities.hideSplashScreen();\\n\\t\\t\\t\\tLog.log(Log.MESSAGE,jEdit.class,\\\"Startup \\\"\\n\\t\\t\\t\\t\\t+ \\\"complete\\\");\\n\\t\\t\\t\\t\\t\\t\\t\\tif(pluginErrors != null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tshowPluginErrorDialog();\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tstartupDone = true;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tToolkit.getDefaultToolkit();\\n\\t\\t\\t}\\n\\t\\t});\\n\\t} \\n\\t\\tprivate static void showPluginErrorDialog()\\n\\t{\\n\\t\\tif(pluginErrors == null)\\n\\t\\t\\treturn;\\n\\t\\tString caption = getProperty(\\n\\t\\t\\t\\\"plugin-error.caption\\\" + (pluginErrors.size() == 1\\n\\t\\t\\t? \\\"-1\\\" : \\\"\\\"));\\n\\t\\tFrame frame = (PluginManager.getInstance() == null\\n\\t\\t\\t? (Frame)viewsFirst\\n\\t\\t\\t: (Frame)PluginManager.getInstance());\\n\\t\\tnew ErrorListDialog(frame,\\n\\t\\t\\tgetProperty(\\\"plugin-error.title\\\"),\\n\\t\\t\\tcaption,pluginErrors,true);\\n\\t\\tpluginErrors = null;\\n\\t} \\n\\t\\tprivate static void getNotLoadedPluginJARs(Vector returnValue,\\n\\t\\tString dir, String[] list)\\n\\t{\\nloop:\\t\\tfor(int i = 0; i < list.length; i++)\\n\\t\\t{\\n\\t\\t\\tString name = list[i];\\n\\t\\t\\tif(!name.toLowerCase().endsWith(\\\".jar\\\"))\\n\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\tString path = MiscUtilities.constructPath(dir,name);\\n\\t\\t\\tfor(int j = 0; j < jars.size(); j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tPluginJAR jar = (PluginJAR)\\n\\t\\t\\t\\t\\tjars.elementAt(j);\\n\\t\\t\\t\\tString jarPath = jar.getPath();\\n\\t\\t\\t\\tString jarName = MiscUtilities.getFileName(jarPath);\\n\\t\\t\\t\\tif(path.equals(jarPath))\\n\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\telse if(!new File(jarPath).exists()\\n\\t\\t\\t\\t\\t&& name.equals(jarName))\\n\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t}\\n\\t\\t\\treturnValue.addElement(path);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate static void gotoMarker(final View view, final Buffer buffer,\\n\\t\\tfinal String marker)\\n\\t{\\n\\t\\tVFSManager.runInAWTThread(new Runnable()\\n\\t\\t{\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\tint pos;\\n\\t\\t\\t\\t\\t\\t\\t\\tif(marker.startsWith(\\\"+line:\\\"))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttry\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint line = Integer.parseInt(marker.substring(6));\\n\\t\\t\\t\\t\\t\\tpos = buffer.getLineStartOffset(line - 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcatch(Exception e)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\telse if(marker.startsWith(\\\"+marker:\\\"))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(marker.length() != 9)\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\tMarker m = buffer.getMarker(marker.charAt(8));\\n\\t\\t\\t\\t\\tif(m == null)\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\tpos = m.getPosition();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tthrow new InternalError();\\n\\t\\t\\t\\tif(view != null && view.getBuffer() == buffer)\\n\\t\\t\\t\\t\\tview.getTextArea().setCaretPosition(pos);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbuffer.setIntegerProperty(Buffer.CARET,pos);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t} \\n\\t\\tprivate static void addBufferToList(Buffer buffer)\\n\\t{\\n\\t\\tsynchronized(bufferListLock)\\n\\t\\t{\\n\\t\\t\\tboolean caseInsensitiveFilesystem =\\n\\t\\t\\t\\tOperatingSystem.isDOSDerived()\\n\\t\\t\\t\\t|| OperatingSystem.isMacOS();\\n\\t\\t\\tString path = buffer.getPath();\\n\\t\\t\\tif(caseInsensitiveFilesystem)\\n\\t\\t\\t\\tpath = path.toLowerCase();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(viewCount <= 1 && buffersFirst != null\\n\\t\\t\\t\\t&& buffersFirst == buffersLast\\n\\t\\t\\t\\t&& buffersFirst.isUntitled()\\n\\t\\t\\t\\t&& !buffersFirst.isDirty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tBuffer oldBuffersFirst = buffersFirst;\\n\\t\\t\\t\\tbuffersFirst = buffersLast = buffer;\\n\\t\\t\\t\\tDisplayManager.bufferClosed(oldBuffersFirst);\\n\\t\\t\\t\\tEditBus.send(new BufferUpdate(oldBuffersFirst,null,\\n\\t\\t\\t\\t\\tBufferUpdate.CLOSED));\\n\\t\\t\\t\\tbufferHash.clear();\\n\\t\\t\\t\\tbufferHash.put(path,buffer);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tbufferCount++;\\n\\t\\t\\tbufferHash.put(path,buffer);\\n\\t\\t\\tif(buffersFirst == null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffersFirst = buffersLast = buffer;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if(sortBuffers)\\n\\t\\t\\t{\\n\\t\\t\\t\\tString str11, str12;\\n\\t\\t\\t\\tif(sortByName)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstr11 = buffer.getName();\\n\\t\\t\\t\\t\\tstr12 = buffer.getDirectory();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstr11 = buffer.getDirectory();\\n\\t\\t\\t\\t\\tstr12 = buffer.getName();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tBuffer _buffer = buffersFirst;\\n\\t\\t\\t\\twhile(_buffer != null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tString str21, str22;\\n\\t\\t\\t\\t\\tif(sortByName)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tstr21 = _buffer.getName();\\n\\t\\t\\t\\t\\t\\tstr22 = _buffer.getDirectory();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tstr21 = _buffer.getDirectory();\\n\\t\\t\\t\\t\\t\\tstr22 = _buffer.getName();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tint comp = MiscUtilities.compareStrings(str11,str21,true);\\n\\t\\t\\t\\t\\tif(comp < 0 || (comp == 0 && MiscUtilities.compareStrings(str12,str22,true) < 0))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.next = _buffer;\\n\\t\\t\\t\\t\\t\\tbuffer.prev = _buffer.prev;\\n\\t\\t\\t\\t\\t\\t_buffer.prev = buffer;\\n\\t\\t\\t\\t\\t\\tif(_buffer != buffersFirst)\\n\\t\\t\\t\\t\\t\\t\\tbuffer.prev.next = buffer;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tbuffersFirst = buffer;\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t_buffer = _buffer.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\tbuffer.prev = buffersLast;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbuffer.next = null;\\n\\t\\t\\tbuffersLast.next = buffer;\\n\\t\\t\\tbuffersLast = buffer;\\n\\t\\t}\\n\\t} \\n\\t\\tprivate static void removeBufferFromList(Buffer buffer)\\n\\t{\\n\\t\\tsynchronized(bufferListLock)\\n\\t\\t{\\n\\t\\t\\tbufferCount--;\\n\\t\\t\\tboolean caseInsensitiveFilesystem =\\n\\t\\t\\t\\tOperatingSystem.isDOSDerived()\\n\\t\\t\\t\\t|| OperatingSystem.isMacOS();\\n\\t\\t\\tString path = buffer.getPath();\\n\\t\\t\\tif(caseInsensitiveFilesystem)\\n\\t\\t\\t\\tpath = path.toLowerCase();\\n\\t\\t\\tbufferHash.remove(path);\\n\\t\\t\\tif(buffer == buffersFirst && buffer == buffersLast)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffersFirst = buffersLast = null;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(buffer == buffersFirst)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffersFirst = buffer.next;\\n\\t\\t\\t\\tbuffer.next.prev = null;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.prev.next = buffer.next;\\n\\t\\t\\t}\\n\\t\\t\\tif(buffer == buffersLast)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffersLast = buffersLast.prev;\\n\\t\\t\\t\\tbuffer.prev.next = null;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.next.prev = buffer.prev;\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbuffer.next = buffer.prev = null;\\n\\t\\t}\\n\\t} \\n\\t\\tprivate static void addViewToList(View view)\\n\\t{\\n\\t\\tviewCount++;\\n\\t\\tif(viewsFirst == null)\\n\\t\\t\\tviewsFirst = viewsLast = view;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tview.prev = viewsLast;\\n\\t\\t\\tviewsLast.next = view;\\n\\t\\t\\tviewsLast = view;\\n\\t\\t}\\n\\t} \\n\\t\\tprivate static void removeViewFromList(View view)\\n\\t{\\n\\t\\tviewCount--;\\n\\t\\tif(viewsFirst == viewsLast)\\n\\t\\t{\\n\\t\\t\\tviewsFirst = viewsLast = null;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(view == viewsFirst)\\n\\t\\t{\\n\\t\\t\\tviewsFirst = view.next;\\n\\t\\t\\tview.next.prev = null;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tview.prev.next = view.next;\\n\\t\\t}\\n\\t\\tif(view == viewsLast)\\n\\t\\t{\\n\\t\\t\\tviewsLast = viewsLast.prev;\\n\\t\\t\\tview.prev.next = null;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tview.next.prev = view.prev;\\n\\t\\t}\\n\\t} \\n\\tprivate static void closeView(View view, boolean callExit)\\n\\t{\\n\\t\\tif(viewsFirst == viewsLast && callExit)\\n\\t\\t\\texit(view,false); \\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tEditBus.send(new ViewUpdate(view,ViewUpdate.CLOSED));\\n\\t\\t\\tview.close();\\n\\t\\t\\tremoveViewFromList(view);\\n\\t\\t\\tif(view == activeView)\\n\\t\\t\\t\\tactiveView = null;\\n\\t\\t}\\n\\t} \\n\\tprivate static void loadModeCatalog(String path, boolean resource)\\n\\t{\\n\\t\\tLog.log(Log.MESSAGE,jEdit.class,\\\"Loading mode catalog file \\\" + path);\\n\\t\\tModeCatalogHandler handler = new ModeCatalogHandler(\\n\\t\\t\\tMiscUtilities.getParentOfPath(path),resource);\\n\\t\\tXmlParser parser = new XmlParser();\\n\\t\\tparser.setHandler(handler);\\n\\t\\tReader in = null;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tInputStream _in;\\n\\t\\t\\tif(resource)\\n\\t\\t\\t\\t_in = jEdit.class.getResourceAsStream(path);\\n\\t\\t\\telse\\n\\t\\t\\t\\t_in = new FileInputStream(path);\\n\\t\\t\\tin = new BufferedReader(new InputStreamReader(_in));\\n\\t\\t\\tparser.parse(null, null, in);\\n\\t\\t}\\n\\t\\tcatch(XmlException xe)\\n\\t\\t{\\n\\t\\t\\tint line = xe.getLine();\\n\\t\\t\\tString message = xe.getMessage();\\n\\t\\t\\tLog.log(Log.ERROR,jEdit.class,path + \\\":\\\" + line\\n\\t\\t\\t\\t+ \\\": \\\" + message);\\n\\t\\t}\\n\\t\\tcatch(Exception e)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.ERROR,jEdit.class,e);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(in != null)\\n\\t\\t\\t\\t\\tin.close();\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,jEdit.class,io);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tprivate static void initKeyBindings()\\n\\t{\\n\\t\\tinputHandler.removeAllKeyBindings();\\n\\t\\tActionSet[] actionSets = getActionSets();\\n\\t\\tfor(int i = 0; i < actionSets.length; i++)\\n\\t\\t{\\n\\t\\t\\tactionSets[i].initKeyBindings();\\n\\t\\t}\\n\\t} \\n\\t}\""
            },
            "m13": {
                "content": "The source code of `jEdit.java` reveals that it is the core class of the jEdit editor, responsible for managing:\n\n- Application lifecycle (startup/shutdown)\n- Plugin management (`PluginManager`, `PluginJAR`)\n- Buffer and view management (`Buffer`, `View`, `EditPane`)\n- Input handling (`InputHandler`)\n- Properties and settings\n- GUI initialization and configuration\n- Mode loading and syntax highlighting\n- Event bus communication (`EditBus`)\n- Dockable window and action management\n\nIt does **not** directly reference `JEditTextArea.java` in its import or direct usage. This confirms earlier findings: there's **no explicit static coupling**, but the **conceptual coupling is high**, suggesting an indirect relationship likely through:\n\n- The event system (`EditBus`)\n- Dynamic dispatch via plugins or actions\n- GUI layout managed elsewhere (e.g., `EditPane`, `View`, or `DockableWindowManager`)\n- Runtime interactions not visible in static analysis\n\n### Next Steps:\nTo better understand how `jEdit.java` might indirectly interact with `JEditTextArea.java`, let\u2019s analyze the call graph of another strongly co-changed entity: `Buffer.java`. It appears in both the co-change list and is used heavily by `jEdit.java`.\n\nWe\u2019ll retrieve the **call graph** of `Buffer.java` to see if it has a direct or indirect connection to `JEditTextArea.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_4ffe98fa0ea646f1acee9b",
                        "function": {
                            "arguments": "{\"entity\": \"Buffer.java\"}",
                            "name": "get_call_graph"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m14": {
                "role": "tool",
                "name": "get_call_graph",
                "content": "[\"RESearchMatcher\", \"VFSBrowser\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]"
            },
            "m15": {
                "content": "The call graph for `Buffer.java` appears to include only a few direct dependencies:\n\n- `RESearchMatcher`\n- `VFSBrowser`\n\nThis list is sparse and doesn't provide strong evidence of a direct link to `JEditTextArea.java`. This suggests that even if `Buffer.java` interacts with `JEditTextArea.java`, it's likely done **indirectly**, possibly through the event system, GUI components like `EditPane`, or via dynamic binding.\n\n### Observations So Far:\n- `jEdit.java` and `JEditTextArea.java` show **strong conceptual coupling** (0.8465), but **no direct code-level dependencies**.\n- `jEdit.java` does not reference `JEditTextArea.java` directly in imports or method calls.\n- `Buffer.java`, which is heavily used by `jEdit.java`, also has no clear direct connection to `JEditTextArea.java`.\n- The coupling seems **indirect**, possibly through:\n  - Event-based communication (`EditBus`)\n  - GUI component hierarchy (`EditPane`, `View`, etc.)\n  - Plugin or action systems\n\n### Next Step:\nLet\u2019s inspect the source code of `JEditTextArea.java` to see what kind of functionality it provides and whether there are any indirect references back to `jEdit.java` or shared structures like `Buffer`, `View`, or `EditBus`.\n\nI'll retrieve the origin code for `JEditTextArea.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_f87da11c81fd4c7494c6df",
                        "function": {
                            "arguments": "{\"entity\": \"JEditTextArea.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m16": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package org.gjt.sp.jedit.textarea;\\nimport java.awt.*;\\nimport java.awt.event.*;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Enumeration;\\nimport java.util.Hashtable;\\nimport java.util.Vector;\\nimport javax.swing.*;\\nimport javax.swing.border.*;\\nimport javax.swing.event.*;\\nimport javax.swing.plaf.metal.MetalLookAndFeel;\\nimport javax.swing.text.Position;\\nimport javax.swing.text.Segment;\\nimport org.gjt.sp.jedit.*;\\nimport org.gjt.sp.jedit.buffer.*;\\nimport org.gjt.sp.jedit.gui.*;\\nimport org.gjt.sp.jedit.syntax.*;\\nimport org.gjt.sp.util.Log;\\npublic class JEditTextArea extends JComponent\\n{\\n\\tpublic JEditTextArea(View view)\\n\\t{\\n\\t\\tenableEvents(AWTEvent.FOCUS_EVENT_MASK | AWTEvent.KEY_EVENT_MASK);\\n\\t\\tthis.view = view;\\n\\t\\t\\t\\tselection = new Vector();\\n\\t\\tchunkCache = new ChunkCache(this);\\n\\t\\tpainter = new TextAreaPainter(this);\\n\\t\\tgutter = new Gutter(view,this);\\n\\t\\tbufferHandler = new BufferChangeHandler();\\n\\t\\tlistenerList = new EventListenerList();\\n\\t\\tcaretEvent = new MutableCaretEvent();\\n\\t\\tbracketLine = bracketPosition = -1;\\n\\t\\tblink = true;\\n\\t\\tlineSegment = new Segment();\\n\\t\\treturnValue = new Point();\\n\\t\\trunnables = new ArrayList();\\n\\t\\t\\t\\tsetLayout(new ScrollLayout());\\n\\t\\tadd(LEFT,gutter);\\n\\t\\tadd(CENTER,painter);\\n\\t\\t\\t\\tverticalBox = new Box(BoxLayout.X_AXIS);\\n\\t\\tverticalBox.add(vertical = new JScrollBar(JScrollBar.VERTICAL));\\n\\t\\tadd(RIGHT,verticalBox);\\n\\t\\tadd(BOTTOM,horizontal = new JScrollBar(JScrollBar.HORIZONTAL));\\n\\t\\thorizontal.setValues(0,0,0,0);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(UIManager.getLookAndFeel() instanceof MetalLookAndFeel)\\n\\t\\t{\\n\\t\\t\\tsetBorder(new TextAreaBorder());\\n\\t\\t\\tvertical.putClientProperty(\\\"JScrollBar.isFreeStanding\\\",\\n\\t\\t\\t\\tBoolean.FALSE);\\n\\t\\t\\thorizontal.putClientProperty(\\\"JScrollBar.isFreeStanding\\\",\\n\\t\\t\\t\\tBoolean.FALSE);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\tvertical.addAdjustmentListener(new AdjustHandler());\\n\\t\\thorizontal.addAdjustmentListener(new AdjustHandler());\\n\\t\\tmouseHandler = new MouseHandler();\\n\\t\\tpainter.addMouseListener(mouseHandler);\\n\\t\\tpainter.addMouseMotionListener(mouseHandler);\\n\\t\\taddFocusListener(new FocusHandler());\\n\\t\\t\\t\\t\\t\\t\\t\\tfocusedComponent = this;\\n\\t} \\n\\tpublic void dispose()\\n\\t{\\n\\t\\tDisplayManager.textAreaDisposed(this);\\n\\t} \\n\\tpublic final TextAreaPainter getPainter()\\n\\t{\\n\\t\\treturn painter;\\n\\t} \\n\\tpublic final Gutter getGutter()\\n\\t{\\n\\t\\treturn gutter;\\n\\t} \\n\\tpublic DisplayManager getDisplayManager()\\n\\t{\\n\\t\\treturn displayManager;\\n\\t} \\n\\tpublic final boolean isCaretBlinkEnabled()\\n\\t{\\n\\t\\treturn caretBlinks;\\n\\t} \\n\\tpublic void setCaretBlinkEnabled(boolean caretBlinks)\\n\\t{\\n\\t\\tthis.caretBlinks = caretBlinks;\\n\\t\\tif(!caretBlinks)\\n\\t\\t\\tblink = false;\\n\\t\\tif(buffer != null)\\n\\t\\t\\tinvalidateLine(caretLine);\\n\\t} \\n\\tpublic final int getElectricScroll()\\n\\t{\\n\\t\\treturn electricScroll;\\n\\t} \\n\\tpublic final void setElectricScroll(int electricScroll)\\n\\t{\\n\\t\\tthis.electricScroll = electricScroll;\\n\\t} \\n\\tpublic final boolean isQuickCopyEnabled()\\n\\t{\\n\\t\\treturn quickCopy;\\n\\t} \\n\\tpublic final void setQuickCopyEnabled(boolean quickCopy)\\n\\t{\\n\\t\\tthis.quickCopy = quickCopy;\\n\\t} \\n\\tpublic final Buffer getBuffer()\\n\\t{\\n\\t\\treturn buffer;\\n\\t} \\n\\tpublic void setBuffer(Buffer buffer)\\n\\t{\\n\\t\\tif(this.buffer == buffer)\\n\\t\\t\\treturn;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbufferChanging = true;\\n\\t\\t\\tif(this.buffer != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\t\\tcaretLine = caret = caretScreenLine = 0;\\n\\t\\t\\t\\tbracketLine = bracketPosition = -1;\\n\\t\\t\\t\\tthis.buffer.removeBufferChangeListener(bufferHandler);\\n\\t\\t\\t}\\n\\t\\t\\tthis.buffer = buffer;\\n\\t\\t\\tbuffer.addBufferChangeListener(bufferHandler);\\n\\t\\t\\tbufferHandlerInstalled = true;\\n\\t\\t\\tchunkCache.setBuffer(buffer);\\n\\t\\t\\tpropertiesChanged();\\n\\t\\t\\tif(displayManager != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tDisplayManager.releaseDisplayManager(\\n\\t\\t\\t\\t\\tdisplayManager);\\n\\t\\t\\t}\\n\\t\\t\\tdisplayManager = DisplayManager.getDisplayManager(\\n\\t\\t\\t\\tbuffer,this);\\n\\t\\t\\tdisplayManager.init();\\n\\t\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\t\\trepaint();\\n\\t\\t\\tfireScrollEvent(true);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbufferChanging = false;\\n\\t\\t}\\n\\t} \\n\\tpublic final boolean isEditable()\\n\\t{\\n\\t\\treturn buffer.isEditable();\\n\\t} \\n\\tpublic final JPopupMenu getRightClickPopup()\\n\\t{\\n\\t\\treturn popup;\\n\\t} \\n\\tpublic final void setRightClickPopup(JPopupMenu popup)\\n\\t{\\n\\t\\tthis.popup = popup;\\n\\t} \\n\\tpublic final int getFirstLine()\\n\\t{\\n\\t\\treturn displayManager.firstLine.scrollLine\\n\\t\\t\\t+ displayManager.firstLine.skew;\\n\\t} \\n\\t\\tpublic Exception trace;\\n\\tpublic void setFirstLine(int firstLine)\\n\\t{\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"setFirstLine() from \\\"\\n\\t\\t\\t\\t+ getFirstLine() + \\\" to \\\" + firstLine);\\n\\t\\t}\\n\\t\\t\\t\\tint max = displayManager.getScrollLineCount() - visibleLines\\n\\t\\t\\t+ (lastLinePartial ? 1 : 0);\\n\\t\\tif(firstLine > max)\\n\\t\\t\\tfirstLine = max;\\n\\t\\tif(firstLine < 0)\\n\\t\\t\\tfirstLine = 0;\\n\\t\\tint oldFirstLine = getFirstLine();\\n\\t\\tif(firstLine == oldFirstLine)\\n\\t\\t\\treturn;\\n\\t\\ttrace = new Exception();\\n\\t\\tif(firstLine >= oldFirstLine + visibleLines)\\n\\t\\t{\\n\\t\\t\\tdisplayManager.firstLine.scrollDown(firstLine - oldFirstLine);\\n\\t\\t\\tchunkCache.invalidateAll();\\n\\t\\t}\\n\\t\\telse if(firstLine <= oldFirstLine - visibleLines)\\n\\t\\t{\\n\\t\\t\\tdisplayManager.firstLine.scrollUp(oldFirstLine - firstLine);\\n\\t\\t\\tchunkCache.invalidateAll();\\n\\t\\t}\\n\\t\\telse if(firstLine > oldFirstLine)\\n\\t\\t{\\n\\t\\t\\tdisplayManager.firstLine.scrollDown(firstLine - oldFirstLine);\\n\\t\\t\\tchunkCache.scrollDown(firstLine - oldFirstLine);\\n\\t\\t}\\n\\t\\telse if(firstLine < oldFirstLine)\\n\\t\\t{\\n\\t\\t\\tdisplayManager.firstLine.scrollUp(oldFirstLine - firstLine);\\n\\t\\t\\tchunkCache.scrollUp(oldFirstLine - firstLine);\\n\\t\\t}\\n\\t\\tdisplayManager.firstLine.changed();\\n\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\trepaint();\\n\\t\\tfireScrollEvent(true);\\n\\t} \\n\\tpublic final int getFirstPhysicalLine()\\n\\t{\\n\\t\\treturn displayManager.firstLine.physicalLine;\\n\\t} \\n\\tpublic void setFirstPhysicalLine(int physFirstLine)\\n\\t{\\n\\t\\tsetFirstPhysicalLine(physFirstLine,0);\\n\\t} \\n\\tpublic void setFirstPhysicalLine(int physFirstLine, int skew)\\n\\t{\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"setFirstPhysicalLine(\\\"\\n\\t\\t\\t\\t+ physFirstLine + \\\",\\\" + skew + \\\")\\\");\\n\\t\\t}\\n\\t\\tint amount = (physFirstLine - displayManager.firstLine.physicalLine);\\n\\t\\tint oldFirstLine = getFirstLine();\\n\\t\\tif(amount == 0)\\n\\t\\t{\\n\\t\\t\\tskew -= displayManager.firstLine.skew;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(skew < 0)\\n\\t\\t\\t\\tdisplayManager.firstLine.scrollUp(-skew);\\n\\t\\t\\telse if(skew > 0)\\n\\t\\t\\t\\tdisplayManager.firstLine.scrollDown(skew);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(amount > 0)\\n\\t\\t\\tdisplayManager.firstLine.physDown(amount,skew);\\n\\t\\telse if(amount < 0)\\n\\t\\t\\tdisplayManager.firstLine.physUp(-amount,skew);\\n\\t\\tint firstLine = getFirstLine();\\n\\t\\tif(firstLine == oldFirstLine)\\n\\t\\t\\t;\\n\\t\\telse if(firstLine >= oldFirstLine + visibleLines\\n\\t\\t\\t|| firstLine <= oldFirstLine - visibleLines)\\n\\t\\t{\\n\\t\\t\\tchunkCache.invalidateAll();\\n\\t\\t}\\n\\t\\telse if(firstLine > oldFirstLine)\\n\\t\\t{\\n\\t\\t\\tchunkCache.scrollDown(firstLine - oldFirstLine);\\n\\t\\t}\\n\\t\\telse if(firstLine < oldFirstLine)\\n\\t\\t{\\n\\t\\t\\tchunkCache.scrollUp(oldFirstLine - firstLine);\\n\\t\\t}\\n\\t\\tdisplayManager.firstLine.changed();\\n\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\trepaint();\\n\\t\\tfireScrollEvent(true);\\n\\t} \\n\\tpublic final int getLastPhysicalLine()\\n\\t{\\n\\t\\treturn physLastLine;\\n\\t} \\n\\tpublic final int getVisibleLines()\\n\\t{\\n\\t\\treturn visibleLines;\\n\\t} \\n\\tpublic final int getHorizontalOffset()\\n\\t{\\n\\t\\treturn horizontalOffset;\\n\\t} \\n\\tpublic void setHorizontalOffset(int horizontalOffset)\\n\\t{\\n\\t\\tif(horizontalOffset > 0)\\n\\t\\t\\thorizontalOffset = 0;\\n\\t\\tif(horizontalOffset == this.horizontalOffset)\\n\\t\\t\\treturn;\\n\\t\\tthis.horizontalOffset = horizontalOffset;\\n\\t\\tif(horizontalOffset != horizontal.getValue())\\n\\t\\t\\tupdateScrollBars();\\n\\t\\tpainter.repaint();\\n\\t\\tfireScrollEvent(false);\\n\\t} \\n\\tpublic void scrollUpLine()\\n\\t{\\n\\t\\tsetFirstLine(getFirstLine() - 1);\\n\\t} \\n\\tpublic void scrollUpPage()\\n\\t{\\n\\t\\tsetFirstLine(getFirstLine() - getVisibleLines()\\n\\t\\t\\t+ (lastLinePartial ? 1 : 0));\\n\\t} \\n\\tpublic void scrollDownLine()\\n\\t{\\n\\t\\tsetFirstLine(getFirstLine() + 1);\\n\\t} \\n\\tpublic void scrollDownPage()\\n\\t{\\n\\t\\tsetFirstLine(getFirstLine() + getVisibleLines()\\n\\t\\t\\t- (lastLinePartial ? 1 : 0));\\n\\t} \\n\\tpublic void scrollToCaret(boolean doElectricScroll)\\n\\t{\\n\\t\\tscrollTo(caretLine,caret - buffer.getLineStartOffset(caretLine),\\n\\t\\t\\tdoElectricScroll);\\n\\t} \\n\\tpublic void scrollTo(int line, int offset, boolean doElectricScroll)\\n\\t{\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"scrollTo(), lineCount=\\\"\\n\\t\\t\\t\\t+ getLineCount());\\n\\t\\t\\t\\tint extraEndVirt;\\n\\t\\tint lineLength = buffer.getLineLength(line);\\n\\t\\tif(offset > lineLength)\\n\\t\\t{\\n\\t\\t\\textraEndVirt = charWidth * (offset - lineLength);\\n\\t\\t\\toffset = lineLength;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\textraEndVirt = 0;\\n\\t\\tint _electricScroll = (doElectricScroll\\n\\t\\t\\t&& visibleLines - 1 > electricScroll * 2\\n\\t\\t\\t? electricScroll : 0); \\n\\t\\tif(visibleLines == 0)\\n\\t\\t{\\n\\t\\t\\tsetFirstPhysicalLine(line,_electricScroll);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\t\\tint firstLine = getFirstLine();\\n\\t\\tint screenLine = chunkCache.getScreenLineOfOffset(line,offset);\\n\\t\\tint visibleLines = getVisibleLines();\\n\\t\\tif(screenLine == -1)\\n\\t\\t{\\n\\t\\t\\tChunkCache.LineInfo[] infos = chunkCache\\n\\t\\t\\t\\t.getLineInfosForPhysicalLine(line);\\n\\t\\t\\tint subregion = chunkCache.getSubregionOfOffset(\\n\\t\\t\\t\\toffset,infos);\\n\\t\\t\\tint prevLine = displayManager.getPrevVisibleLine(getFirstPhysicalLine());\\n\\t\\t\\tint nextLine = displayManager.getNextVisibleLine(getLastPhysicalLine());\\n\\t\\t\\tif(line == prevLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFirstPhysicalLine(prevLine,subregion\\n\\t\\t\\t\\t\\t- _electricScroll);\\n\\t\\t\\t}\\n\\t\\t\\telse if(line == nextLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFirstPhysicalLine(nextLine,\\n\\t\\t\\t\\t\\tsubregion + electricScroll\\n\\t\\t\\t\\t\\t- visibleLines - 1);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFirstPhysicalLine(line,subregion\\n\\t\\t\\t\\t\\t- visibleLines / 2);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(screenLine < _electricScroll)\\n\\t\\t{\\n\\t\\t\\tsetFirstLine(getFirstLine() - _electricScroll + screenLine);\\n\\t\\t}\\n\\t\\telse if(screenLine > visibleLines - _electricScroll\\n\\t\\t\\t- (lastLinePartial ? 2 : 1))\\n\\t\\t{\\n\\t\\t\\tsetFirstLine(getFirstLine() + _electricScroll - visibleLines + screenLine + (lastLinePartial ? 2 : 1));\\n\\t\\t} \\n\\t\\t\\t\\tif(!displayManager.isLineVisible(line))\\n\\t\\t\\treturn;\\n\\t\\tPoint point = offsetToXY(line,offset,returnValue);\\n\\t\\tif(point == null)\\n\\t\\t\\tLog.log(Log.ERROR,this,\\\"BUG: screenLine=\\\" + screenLine\\n\\t\\t\\t\\t+ \\\",visibleLines=\\\" + visibleLines\\n\\t\\t\\t\\t+ \\\",firstPhysicalLine=\\\" + getFirstPhysicalLine()\\n\\t\\t\\t\\t+ \\\",lastPhysicalLine=\\\" + getLastPhysicalLine());\\n\\t\\tpoint.x += extraEndVirt;\\n\\t\\tif(point.x < 0)\\n\\t\\t{\\n\\t\\t\\tsetHorizontalOffset(horizontalOffset\\n\\t\\t\\t\\t- point.x + charWidth + 5);\\n\\t\\t}\\n\\t\\telse if(point.x >= painter.getWidth() - charWidth - 5)\\n\\t\\t{\\n\\t\\t\\tsetHorizontalOffset(horizontalOffset +\\n\\t\\t\\t\\t(painter.getWidth() - point.x)\\n\\t\\t\\t\\t- charWidth - 5);\\n\\t\\t} \\t} \\n\\tpublic final void addScrollListener(ScrollListener listener)\\n\\t{\\n\\t\\tlistenerList.add(ScrollListener.class,listener);\\n\\t} \\n\\tpublic final void removeScrollListener(ScrollListener listener)\\n\\t{\\n\\t\\tlistenerList.remove(ScrollListener.class,listener);\\n\\t} \\n\\tpublic int getPhysicalLineOfScreenLine(int screenLine)\\n\\t{\\n\\t\\treturn chunkCache.getLineInfo(screenLine).physicalLine;\\n\\t} \\n\\tpublic int getScreenLineOfOffset(int offset)\\n\\t{\\n\\t\\tint line = buffer.getLineOfOffset(offset);\\n\\t\\toffset -= buffer.getLineStartOffset(line);\\n\\t\\treturn chunkCache.getScreenLineOfOffset(line,offset);\\n\\t} \\n\\tpublic int getScreenLineStartOffset(int line)\\n\\t{\\n\\t\\tChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);\\n\\t\\tif(lineInfo.physicalLine == -1)\\n\\t\\t\\treturn -1;\\n\\t\\treturn buffer.getLineStartOffset(lineInfo.physicalLine)\\n\\t\\t\\t+ lineInfo.offset;\\n\\t} \\n\\tpublic int getScreenLineEndOffset(int line)\\n\\t{\\n\\t\\tChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);\\n\\t\\tif(lineInfo.physicalLine == -1)\\n\\t\\t\\treturn -1;\\n\\t\\treturn buffer.getLineStartOffset(lineInfo.physicalLine)\\n\\t\\t\\t+ lineInfo.offset + lineInfo.length;\\n\\t} \\n\\tpublic int xyToOffset(int x, int y)\\n\\t{\\n\\t\\treturn xyToOffset(x,y,true);\\n\\t} \\n\\tpublic int xyToOffset(int x, int y, boolean round)\\n\\t{\\n\\t\\tFontMetrics fm = painter.getFontMetrics();\\n\\t\\tint height = fm.getHeight();\\n\\t\\tint line = y / height;\\n\\t\\tif(line < 0 || line >= visibleLines)\\n\\t\\t\\treturn -1;\\n\\t\\treturn xToScreenLineOffset(line,x,round);\\n\\t} \\n\\tpublic int xToScreenLineOffset(int screenLine, int x, boolean round)\\n\\t{\\n\\t\\tChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(screenLine);\\n\\t\\tif(lineInfo.physicalLine == -1)\\n\\t\\t{\\n\\t\\t\\treturn getLineEndOffset(displayManager\\n\\t\\t\\t\\t.getLastVisibleLine()) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint offset = Chunk.xToOffset(lineInfo.chunks,\\n\\t\\t\\t\\tx - horizontalOffset,round);\\n\\t\\t\\tif(offset == -1 || offset == lineInfo.offset + lineInfo.length)\\n\\t\\t\\t\\toffset = lineInfo.offset + lineInfo.length - 1;\\n\\t\\t\\treturn getLineStartOffset(lineInfo.physicalLine) + offset;\\n\\t\\t}\\n\\t} \\n\\tpublic Point offsetToXY(int offset)\\n\\t{\\n\\t\\tint line = buffer.getLineOfOffset(offset);\\n\\t\\toffset -= buffer.getLineStartOffset(line);\\n\\t\\tPoint retVal = new Point();\\n\\t\\treturn offsetToXY(line,offset,retVal);\\n\\t} \\n\\tpublic Point offsetToXY(int line, int offset, Point retVal)\\n\\t{\\n\\t\\tint screenLine = chunkCache.getScreenLineOfOffset(line,offset);\\n\\t\\tif(screenLine == -1)\\n\\t\\t\\treturn null;\\n\\t\\tFontMetrics fm = painter.getFontMetrics();\\n\\t\\tretVal.y = screenLine * fm.getHeight();\\n\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(screenLine);\\n\\t\\tretVal.x = (int)(horizontalOffset + Chunk.offsetToX(\\n\\t\\t\\tinfo.chunks,offset));\\n\\t\\treturn retVal;\\n\\t} \\n\\tpublic void invalidateScreenLineRange(int start, int end)\\n\\t{\\n\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\treturn;\\n\\t\\tif(start > end)\\n\\t\\t{\\n\\t\\t\\tint tmp = end;\\n\\t\\t\\tend = start;\\n\\t\\t\\tstart = tmp;\\n\\t\\t}\\n\\t\\tif(chunkCache.needFullRepaint())\\n\\t\\t\\tend = visibleLines;\\n\\t\\tFontMetrics fm = painter.getFontMetrics();\\n\\t\\tint y = start * fm.getHeight();\\n\\t\\tint height = (end - start + 1) * fm.getHeight();\\n\\t\\tpainter.repaint(0,y,painter.getWidth(),height);\\n\\t\\tgutter.repaint(0,y,gutter.getWidth(),height);\\n\\t} \\n\\tpublic void invalidateLine(int line)\\n\\t{\\n\\t\\tif(!isShowing()\\n\\t\\t\\t|| !buffer.isLoaded()\\n\\t\\t\\t|| line < getFirstPhysicalLine()\\n\\t\\t\\t|| line > physLastLine\\n\\t\\t\\t|| !displayManager.isLineVisible(line))\\n\\t\\t\\treturn;\\n\\t\\tint startLine = -1;\\n\\t\\tint endLine = -1;\\n\\t\\tfor(int i = 0; i < visibleLines; i++)\\n\\t\\t{\\n\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(i);\\n\\t\\t\\tif((info.physicalLine >= line || info.physicalLine == -1)\\n\\t\\t\\t\\t&& startLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstartLine = i;\\n\\t\\t\\t}\\n\\t\\t\\tif((info.physicalLine >= line && info.lastSubregion)\\n\\t\\t\\t\\t|| info.physicalLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tendLine = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(chunkCache.needFullRepaint() || endLine == -1)\\n\\t\\t\\tendLine = visibleLines;\\n\\t\\tinvalidateScreenLineRange(startLine,endLine);\\n\\t} \\n\\tpublic void invalidateLineRange(int start, int end)\\n\\t{\\n\\t\\tif(!isShowing() || !buffer.isLoaded())\\n\\t\\t\\treturn;\\n\\t\\tif(end < start)\\n\\t\\t{\\n\\t\\t\\tint tmp = end;\\n\\t\\t\\tend = start;\\n\\t\\t\\tstart = tmp;\\n\\t\\t}\\n\\t\\tif(end < getFirstPhysicalLine() || start > getLastPhysicalLine())\\n\\t\\t\\treturn;\\n\\t\\tint startScreenLine = -1;\\n\\t\\tint endScreenLine = -1;\\n\\t\\tfor(int i = 0; i < visibleLines; i++)\\n\\t\\t{\\n\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(i);\\n\\t\\t\\tif((info.physicalLine >= start || info.physicalLine == -1)\\n\\t\\t\\t\\t&& startScreenLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstartScreenLine = i;\\n\\t\\t\\t}\\n\\t\\t\\tif((info.physicalLine >= end && info.lastSubregion)\\n\\t\\t\\t\\t|| info.physicalLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tendScreenLine = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(startScreenLine == -1)\\n\\t\\t\\tstartScreenLine = 0;\\n\\t\\tif(chunkCache.needFullRepaint() || endScreenLine == -1)\\n\\t\\t\\tendScreenLine = visibleLines;\\n\\t\\tinvalidateScreenLineRange(startScreenLine,endScreenLine);\\n\\t} \\n\\tpublic void invalidateSelectedLines()\\n\\t{\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tinvalidateLineRange(s.startLine,s.endLine);\\n\\t\\t}\\n\\t} \\n\\tpublic final int getBufferLength()\\n\\t{\\n\\t\\treturn buffer.getLength();\\n\\t} \\n\\tpublic final int getLineCount()\\n\\t{\\n\\t\\treturn buffer.getLineCount();\\n\\t} \\n\\tpublic final int getLineOfOffset(int offset)\\n\\t{\\n\\t\\treturn buffer.getLineOfOffset(offset);\\n\\t} \\n\\tpublic int getLineStartOffset(int line)\\n\\t{\\n\\t\\treturn buffer.getLineStartOffset(line);\\n\\t} \\n\\tpublic int getLineEndOffset(int line)\\n\\t{\\n\\t\\treturn buffer.getLineEndOffset(line);\\n\\t} \\n\\tpublic int getLineLength(int line)\\n\\t{\\n\\t\\treturn buffer.getLineLength(line);\\n\\t} \\n\\tpublic final String getText(int start, int len)\\n\\t{\\n\\t\\treturn buffer.getText(start,len);\\n\\t} \\n\\tpublic final void getText(int start, int len, Segment segment)\\n\\t{\\n\\t\\tbuffer.getText(start,len,segment);\\n\\t} \\n\\tpublic final String getLineText(int lineIndex)\\n\\t{\\n\\t\\treturn buffer.getLineText(lineIndex);\\n\\t} \\n\\tpublic final void getLineText(int lineIndex, Segment segment)\\n\\t{\\n\\t\\tbuffer.getLineText(lineIndex,segment);\\n\\t} \\n\\tpublic String getText()\\n\\t{\\n\\t\\treturn buffer.getText(0,buffer.getLength());\\n\\t} \\n\\tpublic void setText(String text)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tbuffer.remove(0,buffer.getLength());\\n\\t\\t\\tbuffer.insert(0,text);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic final void selectAll()\\n\\t{\\n\\t\\tsetSelection(new Selection.Range(0,buffer.getLength()));\\n\\t\\tmoveCaretPosition(buffer.getLength(),true);\\n\\t} \\n\\tpublic void selectLine()\\n\\t{\\n\\t\\tint caretLine = getCaretLine();\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine) - 1;\\n\\t\\tSelection s = new Selection.Range(start,end);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(end);\\n\\t} \\n\\tpublic void selectParagraph()\\n\\t{\\n\\t\\tint caretLine = getCaretLine();\\n\\t\\tif(getLineLength(caretLine) == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint start = caretLine;\\n\\t\\tint end = caretLine;\\n\\t\\twhile(start >= 0)\\n\\t\\t{\\n\\t\\t\\tif(getLineLength(start) == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\telse\\n\\t\\t\\t\\tstart--;\\n\\t\\t}\\n\\t\\twhile(end < getLineCount())\\n\\t\\t{\\n\\t\\t\\tif(getLineLength(end) == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\telse\\n\\t\\t\\t\\tend++;\\n\\t\\t}\\n\\t\\tint selectionStart = getLineStartOffset(start + 1);\\n\\t\\tint selectionEnd = getLineEndOffset(end - 1) - 1;\\n\\t\\tSelection s = new Selection.Range(selectionStart,selectionEnd);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(selectionEnd);\\n\\t} \\n\\tpublic void selectWord()\\n\\t{\\n\\t\\tint line = getCaretLine();\\n\\t\\tint lineStart = getLineStartOffset(line);\\n\\t\\tint offset = getCaretPosition() - lineStart;\\n\\t\\tif(getLineLength(line) == 0)\\n\\t\\t\\treturn;\\n\\t\\tString lineText = getLineText(line);\\n\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\tif(offset == getLineLength(line))\\n\\t\\t\\toffset--;\\n\\t\\tint wordStart = TextUtilities.findWordStart(lineText,offset,noWordSep);\\n\\t\\tint wordEnd = TextUtilities.findWordEnd(lineText,offset+1,noWordSep);\\n\\t\\tSelection s = new Selection.Range(lineStart + wordStart,\\n\\t\\t\\tlineStart + wordEnd);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(lineStart + wordEnd);\\n\\t} \\n\\tpublic Selection selectToMatchingBracket(int position,\\n\\t\\tboolean quickCopy)\\n\\t{\\n\\t\\tint positionLine = buffer.getLineOfOffset(position);\\n\\t\\tint lineOffset = position - buffer.getLineStartOffset(positionLine);\\n\\t\\tif(getLineLength(positionLine) != 0)\\n\\t\\t{\\n\\t\\t\\tint bracket = TextUtilities.findMatchingBracket(buffer,\\n\\t\\t\\t\\tpositionLine,Math.max(0,lineOffset - 1));\\n\\t\\t\\tif(bracket != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s;\\n\\t\\t\\t\\tif(bracket < position)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!quickCopy)\\n\\t\\t\\t\\t\\t\\tmoveCaretPosition(position,false);\\n\\t\\t\\t\\t\\ts = new Selection.Range(bracket,position);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!quickCopy)\\n\\t\\t\\t\\t\\t\\tmoveCaretPosition(bracket + 1,false);\\n\\t\\t\\t\\t\\ts = new Selection.Range(position - 1,bracket + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!multi && !quickCopy)\\n\\t\\t\\t\\t\\tselectNone();\\n\\t\\t\\t\\taddToSelection(s);\\n\\t\\t\\t\\treturn s;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic void selectToMatchingBracket()\\n\\t{\\n\\t\\tselectToMatchingBracket(caret,false);\\n\\t} \\n\\tpublic void narrowToMatchingBracket()\\n\\t{\\n\\t\\tnarrowToMatchingBracket(caret);\\n\\t} \\n\\tpublic void narrowToMatchingBracket(int position)\\n\\t{\\n\\t\\tint line = buffer.getLineOfOffset(position);\\n\\t\\tint offset = position - buffer.getLineStartOffset(line);\\n\\t\\tif(getLineLength(line) != 0)\\n\\t\\t{\\n\\t\\t\\tint bracket = TextUtilities.findMatchingBracket(buffer,\\n\\t\\t\\t\\tline,Math.max(0,offset - 1));\\n\\t\\t\\tif(bracket != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint start = Math.min(bracketLine,line);\\n\\t\\t\\t\\tint end = Math.max(bracketLine,line);\\n\\t\\t\\t\\tdisplayManager.narrow(start,end);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic void selectBlock()\\n\\t{\\n\\t\\tString openBrackets = \\\"([{\\\";\\n\\t\\tString closeBrackets = \\\")]}\\\";\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint start, end;\\n\\t\\tif(s == null)\\n\\t\\t\\tstart = end = caret;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstart = s.start;\\n\\t\\t\\tend = s.end;\\n\\t\\t}\\n\\t\\tString text = getText(0,buffer.getLength());\\n\\t\\t\\t\\tint count = 1;\\n\\t\\tchar openBracket = '\\\\0';\\n\\t\\tchar closeBracket = '\\\\0';\\n\\t\\t\\t\\tif(start == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\nbackward_scan:\\twhile(--start > 0)\\n\\t\\t{\\n\\t\\t\\tchar c = text.charAt(start);\\n\\t\\t\\tint index = openBrackets.indexOf(c);\\n\\t\\t\\tif(index != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(--count == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\topenBracket = c;\\n\\t\\t\\t\\t\\tcloseBracket = closeBrackets.charAt(index);\\n\\t\\t\\t\\t\\tbreak backward_scan;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(closeBrackets.indexOf(c) != -1)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\t\\t\\tcount = 1;\\n\\t\\t\\t\\tif(openBracket == '\\\\0')\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\nforward_scan:\\t\\tdo\\n\\t\\t\\t{\\n\\t\\t\\t\\tchar c = text.charAt(end);\\n\\t\\t\\t\\tif(c == closeBracket)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(--count == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend++;\\n\\t\\t\\t\\t\\t\\tbreak forward_scan;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(c == openBracket)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\twhile(++end < buffer.getLength());\\n\\t\\t}\\n\\t\\ts = new Selection.Range(start,end);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(end);\\n\\t} \\n\\tpublic boolean lineInBracketScope(int line)\\n\\t{\\n\\t\\tif(bracketPosition == -1)\\n\\t\\t\\treturn false;\\n\\t\\tif(bracketLine < caretLine)\\n\\t\\t\\treturn (line >= bracketLine && line <= caretLine);\\n\\t\\telse\\n\\t\\t\\treturn (line <= bracketLine && line >= caretLine);\\n\\t} \\n\\tpublic final void invertSelection()\\n\\t{\\n\\t\\tSelection[] newSelection = new Selection[selection.size() + 1];\\n\\t\\tint lastOffset = 0;\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tnewSelection[i] = new Selection.Range(lastOffset,\\n\\t\\t\\t\\ts.getStart());\\n\\t\\t\\tlastOffset = s.getEnd();\\n\\t\\t}\\n\\t\\tnewSelection[selection.size()] = new Selection.Range(\\n\\t\\t\\tlastOffset,buffer.getLength());\\n\\t\\tsetSelection(newSelection);\\n\\t} \\n\\tpublic int getSelectionCount()\\n\\t{\\n\\t\\treturn selection.size();\\n\\t} \\n\\tpublic Selection[] getSelection()\\n\\t{\\n\\t\\tSelection[] sel = new Selection[selection.size()];\\n\\t\\tselection.copyInto(sel);\\n\\t\\treturn sel;\\n\\t} \\n\\tpublic void selectNone()\\n\\t{\\n\\t\\tsetSelection((Selection)null);\\n\\t} \\n\\tpublic void setSelection(Selection[] selection)\\n\\t{\\n\\t\\t\\t\\tinvalidateSelectedLines();\\n\\t\\tthis.selection.removeAllElements();\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t\\t_addToSelection(selection[i]);\\n\\t\\t}\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void setSelection(Selection selection)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tthis.selection.removeAllElements();\\n\\t\\tif(selection != null)\\n\\t\\t\\t_addToSelection(selection);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void addToSelection(Selection[] selection)\\n\\t{\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t\\t_addToSelection(selection[i]);\\n\\t\\t}\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void addToSelection(Selection selection)\\n\\t{\\n\\t\\t_addToSelection(selection);\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic Selection getSelectionAtOffset(int offset)\\n\\t{\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\t\\tif(offset >= s.start && offset <= s.end)\\n\\t\\t\\t\\t\\treturn s;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic void removeFromSelection(Selection sel)\\n\\t{\\n\\t\\tselection.removeElement(sel);\\n\\t\\tinvalidateLineRange(sel.startLine,sel.endLine);\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void removeFromSelection(int offset)\\n\\t{\\n\\t\\tSelection sel = getSelectionAtOffset(offset);\\n\\t\\tif(sel == null)\\n\\t\\t\\treturn;\\n\\t\\tselection.removeElement(sel);\\n\\t\\tinvalidateLineRange(sel.startLine,sel.endLine);\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void resizeSelection(int offset, int end, int extraEndVirt,\\n\\t\\tboolean rect)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(offset);\\n\\t\\tif(s != null)\\n\\t\\t{\\n\\t\\t\\tinvalidateLineRange(s.startLine,s.endLine);\\n\\t\\t\\tselection.removeElement(s);\\n\\t\\t}\\n\\t\\tboolean reversed = false;\\n\\t\\tif(end < offset)\\n\\t\\t{\\n\\t\\t\\tint tmp = offset;\\n\\t\\t\\toffset = end;\\n\\t\\t\\tend = tmp;\\n\\t\\t\\treversed = true;\\n\\t\\t}\\n\\t\\tSelection newSel;\\n\\t\\tif(rect)\\n\\t\\t{\\n\\t\\t\\tSelection.Rect rectSel = new Selection.Rect(offset,end);\\n\\t\\t\\tif(reversed)\\n\\t\\t\\t\\trectSel.extraStartVirt = extraEndVirt;\\n\\t\\t\\telse\\n\\t\\t\\t\\trectSel.extraEndVirt = extraEndVirt;\\n\\t\\t\\tnewSel = rectSel;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tnewSel = new Selection.Range(offset,end);\\n\\t\\t_addToSelection(newSel);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void extendSelection(int offset, int end)\\n\\t{\\n\\t\\textendSelection(offset,end,0,0);\\n\\t} \\n\\tpublic void extendSelection(int offset, int end,\\n\\t\\tint extraStartVirt, int extraEndVirt)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(offset);\\n\\t\\tif(s != null)\\n\\t\\t{\\n\\t\\t\\tinvalidateLineRange(s.startLine,s.endLine);\\n\\t\\t\\tselection.removeElement(s);\\n\\t\\t\\tif(offset == s.start)\\n\\t\\t\\t{\\n\\t\\t\\t\\toffset = end;\\n\\t\\t\\t\\tend = s.end;\\n\\t\\t\\t}\\n\\t\\t\\telse if(offset == s.end)\\n\\t\\t\\t{\\n\\t\\t\\t\\toffset = s.start;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(end < offset)\\n\\t\\t{\\n\\t\\t\\tint tmp = end;\\n\\t\\t\\tend = offset;\\n\\t\\t\\toffset = tmp;\\n\\t\\t}\\n\\t\\tif(rectangularSelectionMode)\\n\\t\\t{\\n\\t\\t\\ts = new Selection.Rect(offset,end);\\n\\t\\t\\t((Selection.Rect)s).extraStartVirt = extraStartVirt;\\n\\t\\t\\t((Selection.Rect)s).extraEndVirt = extraEndVirt;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\ts = new Selection.Range(offset,end);\\n\\t\\t_addToSelection(s);\\n\\t\\tfireCaretEvent();\\n\\t\\tif(rectangularSelectionMode && extraEndVirt != 0)\\n\\t\\t{\\n\\t\\t\\tint line = getLineOfOffset(end);\\n\\t\\t\\tscrollTo(line,getLineLength(line) + extraEndVirt,false);\\n\\t\\t}\\n\\t} \\n\\tpublic String getSelectedText(Selection s)\\n\\t{\\n\\t\\tStringBuffer buf = new StringBuffer();\\n\\t\\ts.getText(buffer,buf);\\n\\t\\treturn buf.toString();\\n\\t} \\n\\tpublic String getSelectedText(String separator)\\n\\t{\\n\\t\\tif(selection.size() == 0)\\n\\t\\t\\treturn null;\\n\\t\\tStringBuffer buf = new StringBuffer();\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tif(i != 0)\\n\\t\\t\\t\\tbuf.append(separator);\\n\\t\\t\\t((Selection)selection.elementAt(i)).getText(buffer,buf);\\n\\t\\t}\\n\\t\\treturn buf.toString();\\n\\t} \\n\\tpublic String getSelectedText()\\n\\t{\\n\\t\\treturn getSelectedText(\\\"\\\\n\\\");\\n\\t} \\n\\tpublic void setSelectedText(Selection s, String selectedText)\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tthrow new InternalError(\\\"Text component\\\"\\n\\t\\t\\t\\t+ \\\" read only\\\");\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tmoveCaretPosition(s.setText(buffer,selectedText));\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\t\\t\\t\\t} \\n\\tpublic void setSelectedText(String selectedText)\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tthrow new InternalError(\\\"Text component\\\"\\n\\t\\t\\t\\t+ \\\" read only\\\");\\n\\t\\t}\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(selection.length == 0)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.insert(caret,selectedText);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tint newCaret = -1;\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnewCaret = selection[i].setText(buffer,selectedText);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic int[] getSelectedLines()\\n\\t{\\n\\t\\tif(selection.size() == 0)\\n\\t\\t\\treturn new int[] { caretLine };\\n\\t\\tInteger line;\\n\\t\\tHashtable hash = new Hashtable();\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tint endLine = (s.end == getLineStartOffset(s.endLine)\\n\\t\\t\\t\\t? s.endLine - 1\\n\\t\\t\\t\\t: s.endLine);\\n\\t\\t\\tfor(int j = s.startLine; j <= endLine; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tline = new Integer(j);\\n\\t\\t\\t\\thash.put(line,line);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint[] returnValue = new int[hash.size()];\\n\\t\\tint i = 0;\\n\\t\\tEnumeration keys = hash.keys();\\n\\t\\twhile(keys.hasMoreElements())\\n\\t\\t{\\n\\t\\t\\tline = (Integer)keys.nextElement();\\n\\t\\t\\treturnValue[i++] = line.intValue();\\n\\t\\t}\\n\\t\\tArrays.sort(returnValue);\\n\\t\\treturn returnValue;\\n\\t} \\n\\tpublic void showSelectLineRangeDialog()\\n\\t{\\n\\t\\tnew SelectLineRange(view);\\n\\t} \\n\\tpublic final void blinkCaret()\\n\\t{\\n\\t\\tif(caretBlinks)\\n\\t\\t{\\n\\t\\t\\tblink = !blink;\\n\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tblink = true;\\n\\t} \\n\\tpublic void centerCaret()\\n\\t{\\n\\t\\tint offset = getScreenLineStartOffset(visibleLines / 2);\\n\\t\\tif(offset == -1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t\\tsetCaretPosition(offset);\\n\\t} \\n\\tpublic void setCaretPosition(int newCaret)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tselection.removeAllElements();\\n\\t\\tmoveCaretPosition(newCaret,true);\\n\\t} \\n\\tpublic void setCaretPosition(int newCaret, boolean doElectricScroll)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tselection.removeAllElements();\\n\\t\\tmoveCaretPosition(newCaret,doElectricScroll);\\n\\t} \\n\\tpublic void moveCaretPosition(int newCaret)\\n\\t{\\n\\t\\tmoveCaretPosition(newCaret,true);\\n\\t} \\n\\tpublic void moveCaretPosition(int newCaret, boolean doElectricScroll)\\n\\t{\\n\\t\\tmoveCaretPosition(newCaret,doElectricScroll ? ELECTRIC_SCROLL\\n\\t\\t\\t: NORMAL_SCROLL);\\n\\t} \\n\\t\\tpublic int NO_SCROLL = 0;\\n\\tpublic int NORMAL_SCROLL = 1;\\n\\tpublic int ELECTRIC_SCROLL = 2;\\n\\tpublic void moveCaretPosition(int newCaret, int scrollMode)\\n\\t{\\n\\t\\tif(newCaret < 0 || newCaret > buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tthrow new IllegalArgumentException(\\\"caret out of bounds: \\\"\\n\\t\\t\\t\\t+ newCaret);\\n\\t\\t}\\n\\t\\tif(caret == newCaret)\\n\\t\\t{\\n\\t\\t\\tif(bracketLine != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tinvalidateLineRange(bracketLine,caretLine);\\n\\t\\t\\t\\tbracketLine = bracketPosition = -1;\\n\\t\\t\\t}\\n\\t\\t\\tif(scrollMode == NORMAL_SCROLL)\\n\\t\\t\\t\\tfinishCaretUpdate(false,false);\\n\\t\\t\\telse if(scrollMode == ELECTRIC_SCROLL)\\n\\t\\t\\t\\tfinishCaretUpdate(true,false);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint newCaretLine = getLineOfOffset(newCaret);\\n\\t\\t\\tmagicCaret = -1;\\n\\t\\t\\tif(!displayManager.isLineVisible(newCaretLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(newCaretLine < displayManager.getFirstVisibleLine()\\n\\t\\t\\t\\t\\t|| newCaretLine > displayManager.getLastVisibleLine())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint collapseFolds = buffer.getIntegerProperty(\\n\\t\\t\\t\\t\\t\\t\\\"collapseFolds\\\",0);\\n\\t\\t\\t\\t\\tif(collapseFolds != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdisplayManager.expandFolds(collapseFolds);\\n\\t\\t\\t\\t\\t\\tdisplayManager.expandFold(newCaretLine,false);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tdisplayManager.expandAllFolds();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tdisplayManager.expandFold(newCaretLine,false);\\n\\t\\t\\t}\\n\\t\\t\\tif(bracketLine != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tinvalidateLineRange(bracketLine,caretLine);\\n\\t\\t\\t\\tbracketLine = bracketPosition = -1;\\n\\t\\t\\t}\\n\\t\\t\\tif(caretLine == newCaretLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caretScreenLine != -1)\\n\\t\\t\\t\\t\\tinvalidateScreenLineRange(caretScreenLine,caretScreenLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint newCaretScreenLine = chunkCache.getScreenLineOfOffset(newCaretLine,\\n\\t\\t\\t\\t\\tnewCaret - buffer.getLineStartOffset(newCaretLine));\\n\\t\\t\\t\\tif(caretScreenLine == -1)\\n\\t\\t\\t\\t\\tinvalidateScreenLineRange(newCaretScreenLine,newCaretScreenLine);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tinvalidateScreenLineRange(caretScreenLine,newCaretScreenLine);\\n\\t\\t\\t\\tcaretScreenLine = newCaretScreenLine;\\n\\t\\t\\t}\\n\\t\\t\\tcaret = newCaret;\\n\\t\\t\\tcaretLine = newCaretLine;\\n\\t\\t\\tif(scrollMode == NORMAL_SCROLL)\\n\\t\\t\\t\\tfinishCaretUpdate(false,true);\\n\\t\\t\\telse if(scrollMode == ELECTRIC_SCROLL)\\n\\t\\t\\t\\tfinishCaretUpdate(true,true);\\n\\t\\t}\\n\\t} \\n\\tpublic int getCaretPosition()\\n\\t{\\n\\t\\treturn caret;\\n\\t} \\n\\tpublic int getCaretLine()\\n\\t{\\n\\t\\treturn caretLine;\\n\\t} \\n\\tpublic int getMagicCaretPosition()\\n\\t{\\n\\t\\tif(magicCaret == -1)\\n\\t\\t{\\n\\t\\t\\tmagicCaret = chunkCache.subregionOffsetToX(\\n\\t\\t\\t\\tcaretLine,caret - getLineStartOffset(caretLine));\\n\\t\\t}\\n\\t\\treturn magicCaret;\\n\\t} \\n\\tpublic void setMagicCaretPosition(int magicCaret)\\n\\t{\\n\\t\\tthis.magicCaret = magicCaret;\\n\\t} \\n\\tpublic final void addCaretListener(CaretListener listener)\\n\\t{\\n\\t\\tlistenerList.add(CaretListener.class,listener);\\n\\t} \\n\\tpublic final void removeCaretListener(CaretListener listener)\\n\\t{\\n\\t\\tlistenerList.remove(CaretListener.class,listener);\\n\\t} \\n\\tpublic final int getBracketPosition()\\n\\t{\\n\\t\\treturn bracketPosition;\\n\\t} \\n\\tpublic final int getBracketLine()\\n\\t{\\n\\t\\treturn bracketLine;\\n\\t} \\n\\tpublic void goToNextBracket(boolean select)\\n\\t{\\n\\t\\tString text = getText(caret,buffer.getLength() - caret - 1);\\n\\t\\tint newCaret = -1;\\nloop:\\t\\tfor(int i = 0; i < text.length(); i++)\\n\\t\\t{\\n\\t\\t\\tswitch(text.charAt(i))\\n\\t\\t\\t{\\n\\t\\t\\tcase ')': case ']': case '}':\\n\\t\\t\\t\\tnewCaret = caret + i + 1;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(newCaret == -1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(select)\\n\\t\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\t\\telse if(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t}\\n\\t} \\n\\tpublic void goToNextCharacter(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(!select && s instanceof Selection.Range)\\n\\t\\t{\\n\\t\\t\\tif(multi)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caret != s.end)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmoveCaretPosition(s.end);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetCaretPosition(s.end);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint extraStartVirt, extraEndVirt;\\n\\t\\tif(s instanceof Selection.Rect)\\n\\t\\t{\\n\\t\\t\\textraStartVirt = ((Selection.Rect)s).extraStartVirt;\\n\\t\\t\\textraEndVirt = ((Selection.Rect)s).extraEndVirt;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\textraStartVirt = 0;\\n\\t\\t\\textraEndVirt = 0;\\n\\t\\t}\\n\\t\\tint newCaret = caret;\\n\\t\\tif(select && caret == buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tif(rectangularSelectionMode || s instanceof Selection.Rect)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caret == s.start)\\n\\t\\t\\t\\t\\textraStartVirt++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\textraEndVirt++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(caret == getLineEndOffset(caretLine) - 1)\\n\\t\\t{\\n\\t\\t\\tif(rectangularSelectionMode || s instanceof Selection.Rect)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caret == s.start)\\n\\t\\t\\t\\t\\textraStartVirt++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\textraEndVirt++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint line = displayManager.getNextVisibleLine(caretLine);\\n\\t\\t\\t\\tif(line == -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tnewCaret = getLineStartOffset(line);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tnewCaret = caret + 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret,extraStartVirt,extraEndVirt);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToNextLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tboolean rectSelect = (s == null ? rectangularSelectionMode\\n\\t\\t\\t: s instanceof Selection.Rect);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = chunkCache.getBelowPosition(caretLine,\\n\\t\\t\\tcaret - buffer.getLineStartOffset(caretLine),magic + 1,\\n\\t\\t\\trectSelect && select);\\n\\t\\tif(newCaret == -1)\\n\\t\\t{\\n\\t\\t\\tint end = getLineEndOffset(caretLine) - 1;\\n\\t\\t\\tif(caret == end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tnewCaret = end;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t{\\n\\t\\t\\tRectParams params = getRectParams(caret,newCaret);\\n\\t\\t\\tint extraStartVirt;\\n\\t\\t\\tint extraEndVirt;\\n\\t\\t\\tif(params == null)\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = 0;\\n\\t\\t\\t\\textraEndVirt = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = params.extraStartVirt;\\n\\t\\t\\t\\textraEndVirt = params.extraEndVirt;\\n\\t\\t\\t\\tnewCaret = params.newCaret;\\n\\t\\t\\t}\\n\\t\\t\\textendSelection(caret,newCaret,extraStartVirt,extraEndVirt);\\n\\t\\t}\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToNextMarker(boolean select)\\n\\t{\\n\\t\\tVector markers = buffer.getMarkers();\\n\\t\\tif(markers.size() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tMarker marker = null;\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker _marker = (Marker)markers.get(i);\\n\\t\\t\\tif(_marker.getPosition() > caret)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmarker = _marker;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(marker == null)\\n\\t\\t\\tmarker = (Marker)markers.get(0);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,marker.getPosition());\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(marker.getPosition());\\n\\t} \\n\\tpublic void goToNextPage(boolean select)\\n\\t{\\n\\t\\tscrollToCaret(false);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint caretScreenLine = getScreenLineOfOffset(caret);\\n\\t\\tscrollDownPage();\\n\\t\\tint newCaret = xToScreenLineOffset(caretScreenLine,magic,true);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret,false);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToNextParagraph(boolean select)\\n\\t{\\n\\t\\tint lineNo = getCaretLine();\\n\\t\\tint newCaret = getBufferLength();\\n\\t\\tboolean foundBlank = false;\\nloop:\\t\\tfor(int i = lineNo + 1; i < getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tif(!displayManager.isLineVisible(i))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif(foundBlank)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnewCaret = getLineStartOffset(i);\\n\\t\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfoundBlank = true;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToNextWord(boolean select)\\n\\t{\\n\\t\\tgoToNextWord(select,false);\\n\\t} \\n\\tpublic void goToNextWord(boolean select, boolean stdNextPrevWord)\\n\\t{\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint newCaret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(newCaret == lineText.length())\\n\\t\\t{\\n\\t\\t\\tint nextLine = displayManager.getNextVisibleLine(caretLine);\\n\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret = getLineStartOffset(nextLine);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tnewCaret = TextUtilities.findWordEnd(lineText,newCaret + 1,\\n\\t\\t\\t\\tnoWordSep);\\n\\t\\t\\tif(stdNextPrevWord)\\n\\t\\t\\t{\\n\\t\\t\\t\\twhile((newCaret < lineText.length()) && Character.isWhitespace(lineText.charAt(newCaret)))\\n\\t\\t\\t\\t\\tnewCaret = TextUtilities.findWordEnd(lineText,newCaret + 1,\\n\\t\\t\\t\\t\\t\\tnoWordSep);\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret += lineStart;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToPrevBracket(boolean select)\\n\\t{\\n\\t\\tString text = getText(0,caret);\\n\\t\\tint newCaret = -1;\\nloop:\\t\\tfor(int i = getCaretPosition() - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tswitch(text.charAt(i))\\n\\t\\t\\t{\\n\\t\\t\\tcase '(': case '[': case '{':\\n\\t\\t\\t\\tnewCaret = i;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(newCaret == -1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(select)\\n\\t\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\t\\telse if(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t}\\n\\t} \\n\\tpublic void goToPrevCharacter(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(!select && s instanceof Selection.Range)\\n\\t\\t{\\n\\t\\t\\tif(multi)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caret != s.start)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmoveCaretPosition(s.start);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetCaretPosition(s.start);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint extraStartVirt = 0;\\n\\t\\tint extraEndVirt = 0;\\n\\t\\tint newCaret = caret;\\n\\t\\tif(select && caret == getLineEndOffset(caretLine) - 1)\\n\\t\\t{\\n\\t\\t\\tif(s instanceof Selection.Rect)\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = ((Selection.Rect)s).extraStartVirt;\\n\\t\\t\\t\\textraEndVirt = ((Selection.Rect)s).extraEndVirt;\\n\\t\\t\\t\\tif(caret == s.start)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(extraStartVirt == 0)\\n\\t\\t\\t\\t\\t\\tnewCaret = caret - 1;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\textraStartVirt--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(extraEndVirt == 0)\\n\\t\\t\\t\\t\\t\\tnewCaret = caret - 1;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\textraEndVirt--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tnewCaret = caret - 1;\\n\\t\\t}\\n\\t\\telse if(caret == getLineStartOffset(caretLine))\\n\\t\\t{\\n\\t\\t\\tint line = displayManager.getPrevVisibleLine(caretLine);\\n\\t\\t\\tif(line == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret = getLineEndOffset(line) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tnewCaret = caret - 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret,extraStartVirt,extraEndVirt);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToPrevLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tboolean rectSelect = (s == null ? rectangularSelectionMode\\n\\t\\t\\t: s instanceof Selection.Rect);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = chunkCache.getAbovePosition(caretLine,\\n\\t\\t\\tcaret - buffer.getLineStartOffset(caretLine),magic + 1,\\n\\t\\t\\trectSelect && select);\\n\\t\\tif(newCaret == -1)\\n\\t\\t{\\n\\t\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\t\\tif(caret == start)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tnewCaret = start;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t{\\n\\t\\t\\tRectParams params = getRectParams(caret,newCaret);\\n\\t\\t\\tint extraStartVirt;\\n\\t\\t\\tint extraEndVirt;\\n\\t\\t\\tif(params == null)\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = 0;\\n\\t\\t\\t\\textraEndVirt = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = params.extraStartVirt;\\n\\t\\t\\t\\textraEndVirt = params.extraEndVirt;\\n\\t\\t\\t\\tnewCaret = params.newCaret;\\n\\t\\t\\t}\\n\\t\\t\\textendSelection(caret,newCaret,extraStartVirt,extraEndVirt);\\n\\t\\t}\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToPrevMarker(boolean select)\\n\\t{\\n\\t\\tVector markers = buffer.getMarkers();\\n\\t\\tif(markers.size() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tMarker marker = null;\\n\\t\\tfor(int i = markers.size() - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tMarker _marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tif(_marker.getPosition() < caret)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmarker = _marker;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(marker == null)\\n\\t\\t\\tmarker = (Marker)markers.get(markers.size() - 1);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,marker.getPosition());\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(marker.getPosition());\\n\\t} \\n\\tpublic void goToPrevPage(boolean select)\\n\\t{\\n\\t\\tscrollToCaret(false);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint caretScreenLine = getScreenLineOfOffset(caret);\\n\\t\\tscrollUpPage();\\n\\t\\tint newCaret = xToScreenLineOffset(caretScreenLine,magic,true);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret,false);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToPrevParagraph(boolean select)\\n\\t{\\n\\t\\tint lineNo = caretLine;\\n\\t\\tint newCaret = 0;\\n\\t\\tboolean foundBlank = false;\\nloop:\\t\\tfor(int i = lineNo - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(!displayManager.isLineVisible(i))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif(foundBlank)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnewCaret = getLineEndOffset(i) - 1;\\n\\t\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfoundBlank = true;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToPrevWord(boolean select)\\n\\t{\\n\\t\\tgoToPrevWord(select,false);\\n\\t} \\n\\tpublic void goToPrevWord(boolean select, boolean stdNextPrevWord)\\n\\t{\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint newCaret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(newCaret == 0)\\n\\t\\t{\\n\\t\\t\\tif(lineStart == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint prevLine = displayManager.getPrevVisibleLine(caretLine);\\n\\t\\t\\t\\tif(prevLine == -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnewCaret = getLineEndOffset(prevLine) - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tnewCaret = TextUtilities.findWordStart(lineText,newCaret - 1,\\n\\t\\t\\t\\tnoWordSep);\\n\\t\\t\\tif(stdNextPrevWord)\\n\\t\\t\\t{\\n\\t\\t\\t\\twhile((newCaret > 0) && Character.isWhitespace(lineText.charAt(newCaret)))\\n\\t\\t\\t\\t\\tnewCaret = TextUtilities.findWordStart(lineText,newCaret - 1,\\n\\t\\t\\t\\t\\t\\tnoWordSep);\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret += lineStart;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void smartHome(boolean select)\\n\\t{\\n\\t\\tMacros.Recorder recorder = view.getMacroRecorder();\\n\\t\\tswitch(view.getInputHandler().getLastActionCount())\\n\\t\\t{\\n\\t\\tcase 1:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToStartOfWhiteSpace(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToStartOfWhiteSpace(select);\\n\\t\\t\\tbreak;\\n\\t\\tcase 2:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToStartOfLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToStartOfLine(select);\\n\\t\\t\\tbreak;\\n\\t\\tdefault: \\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToFirstVisibleLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToFirstVisibleLine(select);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t} \\n\\tpublic void smartEnd(boolean select)\\n\\t{\\n\\t\\tMacros.Recorder recorder = view.getMacroRecorder();\\n\\t\\tswitch(view.getInputHandler().getLastActionCount())\\n\\t\\t{\\n\\t\\tcase 1:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToEndOfWhiteSpace(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToEndOfWhiteSpace(select);\\n\\t\\t\\tbreak;\\n\\t\\tcase 2:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToEndOfLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToEndOfLine(select);\\n\\t\\t\\tbreak;\\n\\t\\tdefault: \\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToLastVisibleLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToLastVisibleLine(select);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t} \\n\\tpublic void goToStartOfLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line = (select || s == null\\n\\t\\t\\t? caretLine : s.startLine);\\n\\t\\tint newCaret = getLineStartOffset(line);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToEndOfLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line = (select || s == null\\n\\t\\t\\t? caretLine : s.endLine);\\n\\t\\tint newCaret = getLineEndOffset(line) - 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t\\t\\t\\t\\t\\t} \\n\\tpublic void goToStartOfWhiteSpace(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line, offset;\\n\\t\\tif(select || s == null)\\n\\t\\t{\\n\\t\\t\\tline = caretLine;\\n\\t\\t\\toffset = caret - buffer.getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tline = s.startLine;\\n\\t\\t\\toffset = s.start - buffer.getLineStartOffset(line);\\n\\t\\t}\\n\\t\\tint firstIndent = chunkCache.getSubregionStartOffset(line,offset);\\n\\t\\tif(firstIndent == getLineStartOffset(line))\\n\\t\\t{\\n\\t\\t\\tfirstIndent = MiscUtilities.getLeadingWhiteSpace(getLineText(line));\\n\\t\\t\\tif(firstIndent == getLineLength(line))\\n\\t\\t\\t\\tfirstIndent = 0;\\n\\t\\t\\tfirstIndent += getLineStartOffset(line);\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,firstIndent);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(firstIndent);\\n\\t} \\n\\tpublic void goToEndOfWhiteSpace(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line, offset;\\n\\t\\tif(select || s == null)\\n\\t\\t{\\n\\t\\t\\tline = caretLine;\\n\\t\\t\\toffset = caret - getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tline = s.endLine;\\n\\t\\t\\toffset = s.end - getLineStartOffset(line);\\n\\t\\t}\\n\\t\\tint lastIndent = chunkCache.getSubregionEndOffset(line,offset);\\n\\t\\tif(lastIndent == getLineEndOffset(line))\\n\\t\\t{\\n\\t\\t\\tlastIndent = getLineLength(line) - MiscUtilities.getTrailingWhiteSpace(getLineText(line));\\n\\t\\t\\tif(lastIndent == 0)\\n\\t\\t\\t\\tlastIndent = getLineLength(line);\\n\\t\\t\\tlastIndent += getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlastIndent--;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,lastIndent);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(lastIndent);\\n\\t} \\n\\tpublic void goToFirstVisibleLine(boolean select)\\n\\t{\\n\\t\\tint firstVisibleLine = getFirstLine() == 0 ? 0 : electricScroll;\\n\\t\\tint firstVisible = getScreenLineStartOffset(firstVisibleLine);\\n\\t\\tif(firstVisible == -1)\\n\\t\\t{\\n\\t\\t\\tfirstVisible = getLineStartOffset(displayManager\\n\\t\\t\\t\\t.getFirstVisibleLine());\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,firstVisible);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(firstVisible);\\n\\t} \\n\\tpublic void goToLastVisibleLine(boolean select)\\n\\t{\\n\\t\\tint lastVisible;\\n\\t\\tif(getFirstLine() + visibleLines >=\\n\\t\\t\\tdisplayManager.getScrollLineCount())\\n\\t\\t{\\n\\t\\t\\tlastVisible = getLineEndOffset(displayManager\\n\\t\\t\\t\\t.getLastVisibleLine()) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlastVisible = getScreenLineEndOffset(visibleLines\\n\\t\\t\\t\\t- electricScroll - 1) - 1;\\n\\t\\t\\tif(lastVisible == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlastVisible = getLineEndOffset(displayManager\\n\\t\\t\\t\\t\\t.getLastVisibleLine()) - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,lastVisible);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(lastVisible);\\n\\t} \\n\\tpublic void goToBufferStart(boolean select)\\n\\t{\\n\\t\\tint start = buffer.getLineStartOffset(\\n\\t\\t\\tdisplayManager.getFirstVisibleLine());\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,start);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(start);\\n\\t} \\n\\tpublic void goToBufferEnd(boolean select)\\n\\t{\\n\\t\\tint end = buffer.getLineEndOffset(\\n\\t\\t\\tdisplayManager.getLastVisibleLine()) - 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,end);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(end);\\n\\t} \\n\\tpublic void goToMatchingBracket()\\n\\t{\\n\\t\\tif(getLineLength(caretLine) != 0)\\n\\t\\t{\\n\\t\\t\\tint dot = caret - getLineStartOffset(caretLine);\\n\\t\\t\\tint bracket = TextUtilities.findMatchingBracket(\\n\\t\\t\\t\\tbuffer,caretLine,Math.max(0,dot - 1));\\n\\t\\t\\tif(bracket != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\t\\tmoveCaretPosition(bracket + 1,false);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tgetToolkit().beep();\\n\\t} \\n\\tpublic void showGoToLineDialog()\\n\\t{\\n\\t\\tString line = GUIUtilities.input(view,\\\"goto-line\\\",null);\\n\\t\\tif(line == null)\\n\\t\\t\\treturn;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tint lineNumber = Integer.parseInt(line) - 1;\\n\\t\\t\\tsetCaretPosition(getLineStartOffset(lineNumber));\\n\\t\\t}\\n\\t\\tcatch(Exception e)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t}\\n\\t} \\n\\tpublic void userInput(char ch)\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(ch == ' ' && Abbrevs.getExpandOnInput()\\n\\t\\t\\t&& Abbrevs.expandAbbrev(view,false))\\n\\t\\t\\treturn;\\n\\t\\telse if(ch == '\\\\t')\\n\\t\\t{\\n\\t\\t\\tif(selection.size() == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection sel = (Selection)selection.elementAt(0);\\n\\t\\t\\t\\tif(sel.startLine == sel.endLine\\n\\t\\t\\t\\t\\t&& (sel.start != buffer.getLineStartOffset(sel.startLine)\\n\\t\\t\\t\\t\\t|| sel.end != buffer.getLineEndOffset(sel.startLine) - 1))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tinsertTab();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tshiftIndentRight();\\n\\t\\t\\t}\\n\\t\\t\\telse if(selection.size() != 0)\\n\\t\\t\\t\\tshiftIndentRight();\\n\\t\\t\\telse\\n\\t\\t\\t\\tinsertTab();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tboolean indent;\\n\\t\\t\\t\\t\\t\\tString indentOpenBrackets = (String)buffer\\n\\t\\t\\t\\t.getProperty(\\\"indentOpenBrackets\\\");\\n\\t\\t\\tString indentCloseBrackets = (String)buffer\\n\\t\\t\\t\\t.getProperty(\\\"indentCloseBrackets\\\");\\n\\t\\t\\tif((indentCloseBrackets != null\\n\\t\\t\\t\\t&& indentCloseBrackets.indexOf(ch) != -1)\\n\\t\\t\\t\\t|| (indentOpenBrackets != null\\n\\t\\t\\t\\t&& indentOpenBrackets.indexOf(ch) != -1))\\n\\t\\t\\t{\\n\\t\\t\\t\\tindent = true;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tindent = false;\\n\\t\\t\\t}\\n\\t\\t\\tString str = String.valueOf(ch);\\n\\t\\t\\tSelection[] selection = getSelection();\\n\\t\\t\\tif(selection.length != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\t\\tsetSelectedText(s,str);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(ch == ' ')\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(doWordWrap(true))\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tdoWordWrap(false);\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(overwrite || indent)\\n\\t\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tif(overwrite)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint caretLineEnd = getLineEndOffset(caretLine);\\n\\t\\t\\t\\t\\tif(caretLineEnd - caret > 1)\\n\\t\\t\\t\\t\\t\\tbuffer.remove(caret,1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbuffer.insert(caret,str);\\n\\t\\t\\t\\tif(indent)\\n\\t\\t\\t\\t\\tbuffer.indentLine(caretLine,true);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(overwrite || indent)\\n\\t\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic final boolean isOverwriteEnabled()\\n\\t{\\n\\t\\treturn overwrite;\\n\\t} \\n\\tpublic final void setOverwriteEnabled(boolean overwrite)\\n\\t{\\n\\t\\tblink = true;\\n\\t\\tcaretTimer.restart();\\n\\t\\tthis.overwrite = overwrite;\\n\\t\\tinvalidateLine(caretLine);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t\\tview.getStatus().updateMiscStatus();\\n\\t} \\n\\tpublic final void toggleOverwriteEnabled()\\n\\t{\\n\\t\\tsetOverwriteEnabled(!overwrite);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t{\\n\\t\\t\\tview.getStatus().setMessageAndClear(\\n\\t\\t\\t\\tjEdit.getProperty(\\\"view.status.overwrite-changed\\\",\\n\\t\\t\\t\\tnew Integer[] { new Integer(overwrite ? 1 : 0) }));\\n\\t\\t}\\n\\t} \\n\\tpublic void backspace()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() != 0)\\n\\t\\t\\tsetSelectedText(null);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(caret == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.remove(caret - 1,1);\\n\\t\\t}\\n\\t} \\n\\tpublic void backspaceWord()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() != 0)\\n\\t\\t{\\n\\t\\t\\tsetSelectedText(\\\"\\\");\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint _caret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(_caret == 0)\\n\\t\\t{\\n\\t\\t\\tif(lineStart == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t_caret--;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\t_caret = TextUtilities.findWordStart(lineText,_caret-1,noWordSep);\\n\\t\\t}\\n\\t\\tbuffer.remove(_caret + lineStart,\\n\\t\\t\\tcaret - (_caret + lineStart));\\n\\t} \\n\\tpublic void delete()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() != 0)\\n\\t\\t\\tsetSelectedText(null);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(caret == buffer.getLength())\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.remove(caret,1);\\n\\t\\t}\\n\\t} \\n\\tpublic void deleteToEndOfLine()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.remove(caret,getLineEndOffset(caretLine)\\n\\t\\t\\t- caret - 1);\\n\\t} \\n\\tpublic void deleteLine()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine);\\n\\t\\tint x = chunkCache.subregionOffsetToX(caretLine,caret - start);\\n\\t\\t\\t\\t\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tif(end > buffer.getLength())\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(start != 0)\\n\\t\\t\\t\\t\\tstart--;\\n\\t\\t\\t\\tend--;\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tbuffer.remove(start,end - start);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\tint lastLine = displayManager.getLastVisibleLine();\\n\\t\\tif(caretLine == lastLine)\\n\\t\\t{\\n\\t\\t\\tint offset = chunkCache.xToSubregionOffset(lastLine,0,x,true);\\n\\t\\t\\tsetCaretPosition(buffer.getLineStartOffset(lastLine)\\n\\t\\t\\t\\t+ offset);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint offset = chunkCache.xToSubregionOffset(caretLine,0,x,true);\\n\\t\\t\\tsetCaretPosition(start + offset);\\n\\t\\t}\\n\\t} \\n\\tpublic void deleteParagraph()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint start = 0, end = buffer.getLength();\\nloop:\\t\\tfor(int i = caretLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tstart = getLineStartOffset(i);\\n\\t\\t\\tbreak loop;\\n\\t\\t}\\nloop:\\t\\tfor(int i = caretLine + 1; i < getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tend = getLineEndOffset(i) - 1;\\n\\t\\t\\tbreak loop;\\n\\t\\t}\\n\\t\\tbuffer.remove(start,end - start);\\n\\t} \\n\\tpublic void deleteToStartOfLine()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.remove(getLineStartOffset(caretLine),\\n\\t\\t\\tcaret - getLineStartOffset(caretLine));\\n\\t} \\n\\tpublic void deleteWord()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() != 0)\\n\\t\\t{\\n\\t\\t\\tsetSelectedText(\\\"\\\");\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint _caret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(_caret == lineText.length())\\n\\t\\t{\\n\\t\\t\\tif(lineStart + _caret == buffer.getLength())\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t_caret++;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\t_caret = TextUtilities.findWordEnd(lineText,\\n\\t\\t\\t\\t_caret+1,noWordSep);\\n\\t\\t}\\n\\t\\tbuffer.remove(caret,(_caret + lineStart) - caret);\\n\\t} \\n\\tpublic final boolean isMultipleSelectionEnabled()\\n\\t{\\n\\t\\treturn multi;\\n\\t} \\n\\tpublic final void toggleMultipleSelectionEnabled()\\n\\t{\\n\\t\\tsetMultipleSelectionEnabled(!multi);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t{\\n\\t\\t\\tview.getStatus().setMessageAndClear(\\n\\t\\t\\t\\tjEdit.getProperty(\\\"view.status.multi-changed\\\",\\n\\t\\t\\t\\tnew Integer[] { new Integer(multi ? 1 : 0) }));\\n\\t\\t}\\n\\t} \\n\\tpublic final void setMultipleSelectionEnabled(boolean multi)\\n\\t{\\n\\t\\tthis.multi = multi;\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t\\tview.getStatus().updateMiscStatus();\\n\\t\\tpainter.repaint();\\n\\t} \\n\\tpublic final boolean isRectangularSelectionEnabled()\\n\\t{\\n\\t\\treturn rectangularSelectionMode;\\n\\t} \\n\\tpublic final void toggleRectangularSelectionEnabled()\\n\\t{\\n\\t\\tsetRectangularSelectionEnabled(!rectangularSelectionMode);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t{\\n\\t\\t\\tview.getStatus().setMessageAndClear(\\n\\t\\t\\t\\tjEdit.getProperty(\\\"view.status.rect-select-changed\\\",\\n\\t\\t\\t\\tnew Integer[] { new Integer(rectangularSelectionMode ? 1 : 0) }));\\n\\t\\t}\\n\\t} \\n\\tpublic final void setRectangularSelectionEnabled(boolean rectangularSelectionMode)\\n\\t{\\n\\t\\tthis.rectangularSelectionMode = rectangularSelectionMode;\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t\\tview.getStatus().updateMiscStatus();\\n\\t\\tpainter.repaint();\\n\\t} \\n\\tpublic void goToMarker(char shortcut, boolean select)\\n\\t{\\n\\t\\tMarker marker = buffer.getMarker(shortcut);\\n\\t\\tif(marker == null)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint pos = marker.getPosition();\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,pos);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(pos);\\n\\t} \\n\\tpublic void addMarker()\\n\\t{\\n\\t\\t\\t\\tSelection[] selection = getSelection();\\n\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\tif(s.startLine != s.endLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s.startLine != caretLine)\\n\\t\\t\\t\\t\\tbuffer.addMarker('\\\\0',s.start);\\n\\t\\t\\t}\\n\\t\\t\\tif(s.endLine != caretLine)\\n\\t\\t\\t\\tbuffer.addMarker('\\\\0',s.end);\\n\\t\\t}\\n\\t\\t\\t\\tbuffer.addOrRemoveMarker('\\\\0',caret);\\n\\t} \\n\\tpublic void swapMarkerAndCaret(char shortcut)\\n\\t{\\n\\t\\tMarker marker = buffer.getMarker(shortcut);\\n\\t\\tif(marker == null)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint caret = getCaretPosition();\\n\\t\\tsetCaretPosition(marker.getPosition());\\n\\t\\tbuffer.addMarker(shortcut,caret);\\n\\t} \\n\\tpublic void goToParentFold()\\n\\t{\\n\\t\\tint line = -1;\\n\\t\\tint level = buffer.getFoldLevel(caretLine);\\n\\t\\tfor(int i = caretLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(buffer.getFoldLevel(i) < level)\\n\\t\\t\\t{\\n\\t\\t\\t\\tline = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(line == -1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = buffer.getLineStartOffset(line)\\n\\t\\t\\t+ chunkCache.xToSubregionOffset(line,0,magic + 1,true);\\n\\t\\tif(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToNextFold(boolean select)\\n\\t{\\n\\t\\tint nextFold = -1;\\n\\t\\tfor(int i = caretLine + 1; i < buffer.getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tif(buffer.isFoldStart(i)\\n\\t\\t\\t\\t&& displayManager.isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\tnextFold = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(nextFold == -1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = buffer.getLineStartOffset(nextFold)\\n\\t\\t\\t+ chunkCache.xToSubregionOffset(nextFold,0,magic + 1,true);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToPrevFold(boolean select)\\n\\t{\\n\\t\\tint prevFold = -1;\\n\\t\\tfor(int i = caretLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(buffer.isFoldStart(i)\\n\\t\\t\\t\\t&& displayManager.isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\tprevFold = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(prevFold == -1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = buffer.getLineStartOffset(prevFold)\\n\\t\\t\\t+ chunkCache.xToSubregionOffset(prevFold,0,magic + 1,true);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void collapseFold()\\n\\t{\\n\\t\\tint x = chunkCache.subregionOffsetToX(caretLine,\\n\\t\\t\\tcaret - getLineStartOffset(caretLine));\\n\\t\\tdisplayManager.collapseFold(caretLine);\\n\\t\\tif(displayManager.isLineVisible(caretLine))\\n\\t\\t\\treturn;\\n\\t\\tint line = displayManager.getPrevVisibleLine(caretLine);\\n\\t\\tif(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(buffer.getLineStartOffset(line)\\n\\t\\t\\t+ chunkCache.xToSubregionOffset(line,0,x,true));\\n\\t} \\n\\tpublic void expandFold(boolean fully)\\n\\t{\\n\\t\\tint x = chunkCache.subregionOffsetToX(caretLine,\\n\\t\\t\\tcaret - getLineStartOffset(caretLine));\\n\\t\\tint line = displayManager.expandFold(caretLine,fully);\\n\\t\\tif(!fully && line != -1)\\n\\t\\t{\\n\\t\\t\\tif(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\tmoveCaretPosition(getLineStartOffset(line)\\n\\t\\t\\t\\t+ chunkCache.xToSubregionOffset(line,0,x,true));\\n\\t\\t}\\n\\t} \\n\\tpublic void selectFold()\\n\\t{\\n\\t\\tselectFold(caretLine);\\n\\t} \\n\\tpublic void selectFold(int line)\\n\\t{\\n\\t\\tint[] lines = buffer.getFoldAtLine(line);\\n\\t\\tint newCaret = getLineEndOffset(lines[1]) - 1;\\n\\t\\tSelection s = new Selection.Range(getLineStartOffset(lines[0]),newCaret);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void narrowToFold()\\n\\t{\\n\\t\\tint[] lines = buffer.getFoldAtLine(caretLine);\\n\\t\\tif(lines[0] == 0 && lines[1] == buffer.getLineCount() - 1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t\\tdisplayManager.narrow(lines[0],lines[1]);\\n\\t} \\n\\tpublic void narrowToSelection()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tSelection sel = (Selection)selection.elementAt(0);\\n\\t\\tdisplayManager.narrow(sel.getStartLine(),sel.getEndLine());\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic void addExplicitFold()\\n\\t{\\n\\t\\tif(!buffer.getStringProperty(\\\"folding\\\").equals(\\\"explicit\\\"))\\n\\t\\t{\\n\\t\\t\\tGUIUtilities.error(view,\\\"folding-not-explicit\\\",null);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tString lineComment = buffer.getContextSensitiveProperty(caret,\\\"lineComment\\\");\\n\\t\\tString commentStart = buffer.getContextSensitiveProperty(caret,\\\"commentStart\\\");\\n\\t\\tString commentEnd = buffer.getContextSensitiveProperty(caret,\\\"commentEnd\\\");\\n\\t\\tString start, end;\\n\\t\\tif(lineComment != null)\\n\\t\\t{\\n\\t\\t\\tstart = lineComment + \\\"{{{ \\\\n\\\";\\n\\t\\t\\tend = lineComment + \\\"}}}\\\";\\n\\t\\t}\\n\\t\\telse if(commentStart != null && commentEnd != null)\\n\\t\\t{\\n\\t\\t\\tstart = commentStart + \\\"{{{  \\\" + commentEnd + \\\"\\\\n\\\";\\n\\t\\t\\tend = commentStart + \\\"}}}\\\" + commentEnd;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstart = \\\"{{{ \\\\n\\\";\\n\\t\\t\\tend = \\\"}}}\\\";\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tif(selection.size() == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tString line = buffer.getLineText(caretLine);\\n\\t\\t\\t\\tString whitespace = line.substring(0,\\n\\t\\t\\t\\t\\tMiscUtilities.getLeadingWhiteSpace(line));\\n\\t\\t\\t\\tint loc = caret + start.length() - 1;\\n\\t\\t\\t\\tstart = start + whitespace;\\n\\t\\t\\t\\tbuffer.insert(caret,start);\\n\\t\\t\\t\\t\\t\\t\\t\\tbuffer.insert(caret,end);\\n\\t\\t\\t\\tmoveCaretPosition(loc,false);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint loc = -1;\\n\\t\\t\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\t\\t\\tString line = buffer.getLineText(s.startLine);\\n\\t\\t\\t\\t\\tString whitespace = line.substring(0,\\n\\t\\t\\t\\t\\t\\tMiscUtilities.getLeadingWhiteSpace(line));\\n\\t\\t\\t\\t\\tloc = s.start + start.length() - 1;\\n\\t\\t\\t\\t\\tbuffer.insert(s.start,start + whitespace);\\n\\t\\t\\t\\t\\tbuffer.insert(s.end,\\\" \\\" + end);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsetCaretPosition(loc,false);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void lineComment()\\n\\t{\\n\\t\\tString comment = buffer.getContextSensitiveProperty(caret,\\\"lineComment\\\");\\n\\t\\tif(!buffer.isEditable() || comment == null || comment.length() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tcomment = comment + ' ';\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tint[] lines = getSelectedLines();\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < lines.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tString text = getLineText(lines[i]);\\n\\t\\t\\t\\tbuffer.insert(getLineStartOffset(lines[i])\\n\\t\\t\\t\\t\\t+ MiscUtilities.getLeadingWhiteSpace(text),\\n\\t\\t\\t\\t\\tcomment);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic void rangeComment()\\n\\t{\\n\\t\\tString commentStart = buffer.getContextSensitiveProperty(caret,\\\"commentStart\\\");\\n\\t\\tString commentEnd = buffer.getContextSensitiveProperty(caret,\\\"commentEnd\\\");\\n\\t\\tif(!buffer.isEditable() || commentStart == null || commentEnd == null\\n\\t\\t\\t|| commentStart.length() == 0 || commentEnd.length() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tcommentStart = commentStart + ' ';\\n\\t\\tcommentEnd = ' ' + commentEnd;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tSelection[] selection = getSelection();\\n\\t\\t\\tif(selection.length == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint oldCaret = caret;\\n\\t\\t\\t\\tbuffer.insert(caret,commentStart);\\n\\t\\t\\t\\tbuffer.insert(caret,commentEnd);\\n\\t\\t\\t\\tsetCaretPosition(oldCaret + commentStart.length());\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tif(s instanceof Selection.Range)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbuffer.insert(s.start,commentStart);\\n\\t\\t\\t\\t\\tbuffer.insert(s.end,commentEnd);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(s instanceof Selection.Rect)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection.Rect rect = (Selection.Rect)s;\\n\\t\\t\\t\\t\\tint start = rect.getStartColumn(buffer);\\n\\t\\t\\t\\t\\tint end = rect.getEndColumn(buffer);\\n\\t\\t\\t\\t\\tfor(int j = s.startLine; j <= s.endLine; j++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.insertAtColumn(j,end,\\n\\t\\t\\t\\t\\t\\t\\tcommentEnd);\\n\\t\\t\\t\\t\\t\\tbuffer.insertAtColumn(j,start,\\n\\t\\t\\t\\t\\t\\t\\tcommentStart);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tselectNone();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void formatParagraph()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(maxLineLen <= 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(selection.length != 0)\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tsetSelectedText(s,TextUtilities.format(\\n\\t\\t\\t\\t\\tgetSelectedText(s),maxLineLen,\\n\\t\\t\\t\\t\\tbuffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint lineNo = getCaretLine();\\n\\t\\t\\tint start = 0, end = buffer.getLength();\\nloop:\\t\\t\\tfor(int i = lineNo - 1; i >= 0; i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstart = getLineEndOffset(i);\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\nloop:\\t\\t\\tfor(int i = lineNo + 1; i < getLineCount(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tend = getLineStartOffset(i) - 1;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tString text = buffer.getText(start,end - start);\\n\\t\\t\\t\\tbuffer.remove(start,end - start);\\n\\t\\t\\t\\tbuffer.insert(start,TextUtilities.format(\\n\\t\\t\\t\\t\\ttext,maxLineLen,buffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic void spacesToTabs()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tif(selection.length == 0)\\n\\t\\t{\\n\\t\\t\\tsetText(TextUtilities.spacesToTabs(\\n\\t\\t\\t\\tgetText(), buffer.getTabSize()));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tsetSelectedText(s,TextUtilities.spacesToTabs(\\n\\t\\t\\t\\t\\tgetSelectedText(s),buffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void tabsToSpaces()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tif(selection.length == 0)\\n\\t\\t{\\n\\t\\t\\tsetText(TextUtilities.tabsToSpaces(\\n\\t\\t\\t\\tgetText(), buffer.getTabSize()));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tsetSelectedText(s,TextUtilities.tabsToSpaces(\\n\\t\\t\\t\\t\\tgetSelectedText(s),buffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void toUpperCase()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable() || selection.length == 0)\\n                {\\n                \\tgetToolkit().beep();\\n                \\treturn;\\n                }\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\tsetSelectedText(s,getSelectedText(s).toUpperCase());\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void toLowerCase()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable() || selection.length == 0)\\n                {\\n                \\tgetToolkit().beep();\\n                \\treturn;\\n                }\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\tsetSelectedText(s,getSelectedText(s).toLowerCase());\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void removeTrailingWhiteSpace()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbuffer.removeTrailingWhiteSpace(getSelectedLines());\\n\\t\\t}\\n\\t} \\n\\t\\tpublic void insertEnterAndIndent()\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tsetSelectedText(\\\"\\\\n\\\");\\n\\t\\t\\t\\tbuffer.indentLine(caretLine,true);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tpublic void insertTabAndIndent()\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() == 0)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tString text = buffer.getLineText(caretLine);\\n\\t\\t\\tint start = buffer.getLineStartOffset(caretLine);\\n\\t\\t\\tint whiteSpace = MiscUtilities.getLeadingWhiteSpace(text);\\n\\t\\t\\tif(caret - start <= whiteSpace\\n\\t\\t\\t\\t&& buffer.indentLine(caretLine,false))\\n\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tuserInput('\\\\t');\\n\\t} \\n\\tpublic void indentSelectedLines()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbuffer.indentLines(getSelectedLines());\\n\\t\\t\\tselectNone();\\n\\t\\t}\\n\\t} \\n\\tpublic void shiftIndentLeft()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbuffer.shiftIndentLeft(getSelectedLines());\\n\\t\\t}\\n\\t} \\n\\tpublic void shiftIndentRight()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t\\tbuffer.shiftIndentRight(getSelectedLines());\\n\\t} \\n\\tpublic void joinLines()\\n\\t{\\n\\t\\tint end = getLineEndOffset(caretLine);\\n\\t\\tif(end > buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.remove(end - 1,MiscUtilities.getLeadingWhiteSpace(\\n\\t\\t\\tbuffer.getLineText(caretLine + 1)) + 1);\\n\\t\\tsetCaretPosition(end - 1);\\n\\t} \\n\\tpublic void showWordCountDialog()\\n\\t{\\n\\t\\tString selection = getSelectedText();\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tdoWordCount(view,selection);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tdoWordCount(view,buffer.getText(0,buffer.getLength()));\\n\\t} \\n\\tpublic void addLeftOfScrollBar(Component comp)\\n\\t{\\n\\t\\tverticalBox.add(comp,verticalBox.getComponentCount() - 1);\\n\\t} \\n\\tpublic void removeLeftOfScrollBar(Component comp)\\n\\t{\\n\\t\\tverticalBox.remove(comp);\\n\\t} \\n\\tpublic void addNotify()\\n\\t{\\n\\t\\tsuper.addNotify();\\n\\t\\tToolTipManager.sharedInstance().registerComponent(painter);\\n\\t\\tToolTipManager.sharedInstance().registerComponent(gutter);\\n\\t\\tif(!bufferHandlerInstalled)\\n\\t\\t{\\n\\t\\t\\tbufferHandlerInstalled = true;\\n\\t\\t\\tbuffer.addBufferChangeListener(bufferHandler);\\n\\t\\t}\\n\\t\\trecalculateVisibleLines();\\n\\t\\tif(buffer.isLoaded())\\n\\t\\t\\trecalculateLastPhysicalLine();\\n\\t\\tpropertiesChanged();\\n\\t} \\n\\tpublic void removeNotify()\\n\\t{\\n\\t\\tsuper.removeNotify();\\n\\t\\tToolTipManager.sharedInstance().unregisterComponent(painter);\\n\\t\\tToolTipManager.sharedInstance().unregisterComponent(gutter);\\n\\t\\tif(focusedComponent == this)\\n\\t\\t\\tfocusedComponent = null;\\n\\t\\tif(bufferHandlerInstalled)\\n\\t\\t{\\n\\t\\t\\tbuffer.removeBufferChangeListener(bufferHandler);\\n\\t\\t\\tbufferHandlerInstalled = false;\\n\\t\\t}\\n\\t} \\n\\tpublic boolean getFocusTraversalKeysEnabled()\\n\\t{\\n\\t\\treturn false;\\n\\t} \\n\\t\\tpublic void processKeyEvent(KeyEvent evt)\\n\\t{\\n\\t\\tview.processKeyEvent(evt,true);\\n\\t\\tif(!evt.isConsumed())\\n\\t\\t\\tsuper.processKeyEvent(evt);\\n\\t} \\n\\tpublic void propertiesChanged()\\n\\t{\\n\\t\\tif(buffer == null)\\n\\t\\t\\treturn;\\n\\t\\tint _tabSize = buffer.getTabSize();\\n\\t\\tchar[] foo = new char[_tabSize];\\n\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t{\\n\\t\\t\\tfoo[i] = ' ';\\n\\t\\t}\\n\\t\\ttabSize = (float)painter.getFont().getStringBounds(foo,0,_tabSize,\\n\\t\\t\\tpainter.getFontRenderContext()).getWidth();\\n\\t\\tcharWidth = (int)Math.round(painter.getFont().getStringBounds(foo,0,1,\\n\\t\\t\\tpainter.getFontRenderContext()).getWidth());\\n\\t\\tString wrap = buffer.getStringProperty(\\\"wrap\\\");\\n\\t\\thardWrap = wrap.equals(\\\"hard\\\");\\n\\t\\tmaxLineLen = buffer.getIntegerProperty(\\\"maxLineLen\\\",0);\\n\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\tif(displayManager != null && !bufferChanging)\\n\\t\\t\\tdisplayManager.updateWrapSettings();\\n\\t\\tchunkCache.invalidateAll();\\n\\t\\tgutter.repaint();\\n\\t\\tpainter.repaint();\\n\\t} \\n\\tpublic final int getSelectionStart()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getStart();\\n\\t} \\n\\tpublic int getSelectionStart(int line)\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getStart(\\n\\t\\t\\tbuffer,line);\\n\\t} \\n\\tpublic final int getSelectionStartLine()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getStartLine();\\n\\t} \\n\\tpublic final void setSelectionStart(int selectionStart)\\n\\t{\\n\\t\\tselect(selectionStart,getSelectionEnd(),true);\\n\\t} \\n\\tpublic final int getSelectionEnd()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getEnd();\\n\\t} \\n\\tpublic int getSelectionEnd(int line)\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getEnd(\\n\\t\\t\\tbuffer,line);\\n\\t} \\n\\tpublic final int getSelectionEndLine()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getEndLine();\\n\\t} \\n\\tpublic final void setSelectionEnd(int selectionEnd)\\n\\t{\\n\\t\\tselect(getSelectionStart(),selectionEnd,true);\\n\\t} \\n\\tpublic final int getMarkPosition()\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(s == null)\\n\\t\\t\\treturn caret;\\n\\t\\tif(s.start == caret)\\n\\t\\t\\treturn s.end;\\n\\t\\telse if(s.end == caret)\\n\\t\\t\\treturn s.start;\\n\\t\\telse\\n\\t\\t\\treturn caret;\\n\\t} \\n\\tpublic final int getMarkLine()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caretLine;\\n\\t\\tSelection s = (Selection)selection.elementAt(0);\\n\\t\\tif(s.start == caret)\\n\\t\\t\\treturn s.endLine;\\n\\t\\telse if(s.end == caret)\\n\\t\\t\\treturn s.startLine;\\n\\t\\telse\\n\\t\\t\\treturn caretLine;\\n\\t} \\n\\tpublic void select(int start, int end)\\n\\t{\\n\\t\\tselect(start,end,true);\\n\\t} \\n\\tpublic void select(int start, int end, boolean doElectricScroll)\\n\\t{\\n\\t\\tselectNone();\\n\\t\\tint newStart, newEnd;\\n\\t\\tif(start < end)\\n\\t\\t{\\n\\t\\t\\tnewStart = start;\\n\\t\\t\\tnewEnd = end;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tnewStart = end;\\n\\t\\t\\tnewEnd = start;\\n\\t\\t}\\n\\t\\tsetSelection(new Selection.Range(newStart,newEnd));\\n\\t\\tmoveCaretPosition(end,doElectricScroll);\\n\\t} \\n\\tpublic boolean isSelectionRectangular()\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(s == null)\\n\\t\\t\\treturn false;\\n\\t\\telse\\n\\t\\t\\treturn (s instanceof Selection.Rect);\\n\\t} \\n\\t\\tSegment lineSegment;\\n\\tMouseHandler mouseHandler;\\n\\tChunkCache chunkCache;\\n\\tDisplayManager displayManager;\\n\\tboolean bufferChanging;\\n\\tint maxHorizontalScrollWidth;\\n\\tboolean updateMaxHorizontalScrollWidth;\\n\\tboolean hardWrap;\\n\\tfloat tabSize;\\n\\tint charWidth;\\n\\tint maxLineLen;\\n\\tboolean scrollBarsInitialized;\\n\\t\\t\\t\\t\\t\\t\\tboolean queuedScrollTo;\\n\\tboolean queuedScrollToElectric;\\n\\tboolean queuedFireCaretEvent;\\n\\tArrayList runnables;\\n\\t\\t\\tVector selection;\\n\\t\\tPoint returnValue;\\n\\tboolean lastLinePartial;\\n\\tfinal boolean isCaretVisible()\\n\\t{\\n\\t\\treturn blink && hasFocus();\\n\\t} \\n\\tfinal boolean isBracketHighlightVisible()\\n\\t{\\n\\t\\treturn bracketLine != -1\\n\\t\\t\\t&& hasFocus()\\n\\t\\t\\t&& displayManager.isLineVisible(bracketLine)\\n\\t\\t\\t&& displayManager.isLineVisible(caretLine);\\n\\t} \\n\\t\\tvoid updateMaxHorizontalScrollWidth()\\n\\t{\\n\\t\\tint max = chunkCache.getMaxHorizontalScrollWidth();\\n\\t\\tif(max != maxHorizontalScrollWidth)\\n\\t\\t{\\n\\t\\t\\tmaxHorizontalScrollWidth = max;\\n\\t\\t\\thorizontal.setValues(Math.max(0,\\n\\t\\t\\t\\tMath.min(maxHorizontalScrollWidth + charWidth\\n\\t\\t\\t\\t- painter.getWidth(),\\n\\t\\t\\t\\t-horizontalOffset)),\\n\\t\\t\\t\\tpainter.getWidth(),\\n\\t\\t\\t\\t0,maxHorizontalScrollWidth\\n\\t\\t\\t\\t+ charWidth);\\n\\t\\t}\\n\\t} \\n\\t\\tvoid recalculateVisibleLines()\\n\\t{\\n\\t\\tif(painter == null)\\n\\t\\t\\treturn;\\n\\t\\tint height = painter.getHeight();\\n\\t\\tint lineHeight = painter.getFontMetrics().getHeight();\\n\\t\\tvisibleLines = height / lineHeight;\\n\\t\\tlastLinePartial = (height % lineHeight != 0);\\n\\t\\tif(lastLinePartial)\\n\\t\\t\\tvisibleLines++;\\n\\t\\tchunkCache.recalculateVisibleLines();\\n\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\t\\t\\tif(displayManager != null && buffer != null && buffer.isLoaded())\\n\\t\\t\\tsetFirstLine(getFirstLine());\\n\\t\\tupdateScrollBars();\\n\\t} \\n\\t\\tvoid foldStructureChanged()\\n\\t{\\n\\t\\tchunkCache.invalidateAll();\\n\\t\\trecalculateLastPhysicalLine();\\n\\t\\trepaint();\\n\\t} \\n\\tvoid updateScrollBars()\\n\\t{\\n\\t\\tif(buffer == null)\\n\\t\\t\\treturn;\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"updateScrollBars()\\\");\\n\\t\\tif(vertical != null && visibleLines != 0)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"Vertical ok\\\");\\n\\t\\t\\tint lineCount = displayManager.getScrollLineCount();\\n\\t\\t\\tint firstLine = getFirstLine();\\n\\t\\t\\tint visible = visibleLines - (lastLinePartial ? 1 : 0);\\n\\t\\t\\tvertical.setValues(firstLine,visible,0,lineCount);\\n\\t\\t\\tvertical.setUnitIncrement(2);\\n\\t\\t\\tvertical.setBlockIncrement(visible);\\n\\t\\t}\\n\\t\\tint width = painter.getWidth();\\n\\t\\tif(horizontal != null && width != 0)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"Horizontal ok\\\");\\n\\t\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\t\\tpainter.repaint();\\n\\t\\t\\thorizontal.setUnitIncrement(painter.getFontMetrics()\\n\\t\\t\\t\\t.charWidth('w'));\\n\\t\\t\\thorizontal.setBlockIncrement(width / 2);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate static String CENTER = \\\"center\\\";\\n\\tprivate static String RIGHT = \\\"right\\\";\\n\\tprivate static String LEFT = \\\"left\\\";\\n\\tprivate static String BOTTOM = \\\"bottom\\\";\\n\\tprivate static Timer caretTimer;\\n\\tprivate static Timer bracketTimer;\\n\\tprivate static JEditTextArea focusedComponent;\\n\\t\\tprivate View view;\\n\\tprivate Gutter gutter;\\n\\tprivate TextAreaPainter painter;\\n\\tprivate JPopupMenu popup;\\n\\tprivate EventListenerList listenerList;\\n\\tprivate MutableCaretEvent caretEvent;\\n\\tprivate boolean caretBlinks;\\n\\tprivate boolean blink;\\n\\tprivate int physLastLine;\\n\\tprivate int screenLastLine;\\n\\tprivate int visibleLines;\\n\\tprivate int electricScroll;\\n\\tprivate int horizontalOffset;\\n\\tprivate boolean quickCopy;\\n\\t\\tprivate Box verticalBox;\\n\\tprivate JScrollBar vertical;\\n\\tprivate JScrollBar horizontal;\\n\\tprivate Buffer buffer;\\n\\tprivate BufferChangeHandler bufferHandler;\\n\\tprivate boolean bufferHandlerInstalled;\\n\\tprivate int caret;\\n\\tprivate int caretLine;\\n\\tprivate int caretScreenLine;\\n\\tprivate int bracketPosition;\\n\\tprivate int bracketLine;\\n\\tprivate int magicCaret;\\n\\tprivate boolean multi;\\n\\tprivate boolean overwrite;\\n\\tprivate boolean rectangularSelectionMode;\\n\\tprivate boolean delayedScrollTo;\\n\\t\\tprivate void _addToSelection(Selection addMe)\\n\\t{\\n\\t\\tif(addMe.start > addMe.end)\\n\\t\\t{\\n\\t\\t\\tthrow new IllegalArgumentException(addMe.start\\n\\t\\t\\t\\t+ \\\" > \\\" + addMe.end);\\n\\t\\t}\\n\\t\\telse if(addMe.start == addMe.end)\\n\\t\\t{\\n\\t\\t\\tif(addMe instanceof Selection.Range)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\telse if(addMe instanceof Selection.Rect)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(((Selection.Rect)addMe).extraEndVirt == 0)\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tif(s.overlaps(addMe))\\n\\t\\t\\t{\\n\\t\\t\\t\\taddMe.start = Math.min(s.start,addMe.start);\\n\\t\\t\\t\\taddMe.end = Math.max(s.end,addMe.end);\\n\\t\\t\\t\\tselection.removeElement(s);\\n\\t\\t\\t\\ti--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\taddMe.startLine = getLineOfOffset(addMe.start);\\n\\t\\taddMe.endLine = getLineOfOffset(addMe.end);\\n\\t\\tboolean added = false;\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tif(addMe.start < s.start)\\n\\t\\t\\t{\\n\\t\\t\\t\\tselection.insertElementAt(addMe,i);\\n\\t\\t\\t\\tadded = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(!added)\\n\\t\\t\\tselection.addElement(addMe);\\n\\t\\tinvalidateLineRange(addMe.startLine,addMe.endLine);\\n\\t} \\n\\tprivate void finishCaretUpdate(boolean doElectricScroll,\\n\\t\\tboolean fireCaretEvent)\\n\\t{\\n\\t\\tthis.queuedScrollToElectric |= doElectricScroll;\\n\\t\\tthis.queuedFireCaretEvent |= fireCaretEvent;\\n\\t\\tif(queuedScrollTo)\\n\\t\\t\\treturn;\\n\\t\\tRunnable r = new Runnable()\\n\\t\\t{\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tblink = true;\\n\\t\\t\\t\\tcaretTimer.restart();\\n\\t\\t\\t\\tscrollToCaret(queuedScrollToElectric);\\n\\t\\t\\t\\tupdateBracketHighlightWithDelay();\\n\\t\\t\\t\\tif(queuedFireCaretEvent)\\n\\t\\t\\t\\t\\tfireCaretEvent();\\n\\t\\t\\t\\tqueuedScrollTo = queuedScrollToElectric\\n\\t\\t\\t\\t\\t= queuedFireCaretEvent = false;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tif(buffer.isTransactionInProgress())\\n\\t\\t{\\n\\t\\t\\tqueuedScrollTo = true;\\n\\t\\t\\trunnables.add(r);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tr.run();\\n\\t} \\n\\t\\tprivate void fireCaretEvent()\\n\\t{\\n\\t\\tObject[] listeners = listenerList.getListenerList();\\n\\t\\tfor(int i = listeners.length - 2; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(listeners[i] == CaretListener.class)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t((CaretListener)listeners[i+1]).caretUpdate(caretEvent);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireScrollEvent(boolean vertical)\\n\\t{\\n\\t\\tObject[] listeners = listenerList.getListenerList();\\n\\t\\tfor(int i = listeners.length - 2; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(listeners[i] == ScrollListener.class)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(vertical)\\n\\t\\t\\t\\t\\t\\t((ScrollListener)listeners[i+1]).scrolledVertically(this);\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t((ScrollListener)listeners[i+1]).scrolledHorizontally(this);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void insertTab()\\n\\t{\\n\\t\\tint tabSize = buffer.getTabSize();\\n\\t\\tif(buffer.getBooleanProperty(\\\"noTabs\\\"))\\n\\t\\t{\\n\\t\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\t\\tString line = getText(lineStart,caret - lineStart);\\n\\t\\t\\tint pos = 0;\\n\\t\\t\\tfor(int i = 0; i < line.length(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(line.charAt(pos))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tpos = 0;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif(++pos >= tabSize)\\n\\t\\t\\t\\t\\t\\tpos = 0;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tsetSelectedText(MiscUtilities.createWhiteSpace(\\n\\t\\t\\t\\ttabSize - pos,0));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tsetSelectedText(\\\"\\\\t\\\");\\n\\t} \\n\\t\\tprivate boolean doWordWrap(boolean spaceInserted)\\n\\t{\\n\\t\\tif(!hardWrap || maxLineLen <= 0)\\n\\t\\t\\treturn false;\\n\\t\\tbuffer.getLineText(caretLine,lineSegment);\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine);\\n\\t\\tint len = end - start - 1;\\n\\t\\tint caretPos = caret - start;\\n\\t\\t\\t\\t\\t\\tfor(int i = caretPos; i < len; i++)\\n\\t\\t{\\n\\t\\t\\tchar ch = lineSegment.array[lineSegment.offset + i];\\n\\t\\t\\tif(ch != ' ' && ch != '\\\\t')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tboolean returnValue = false;\\n\\t\\tint tabSize = buffer.getTabSize();\\n\\t\\tString wordBreakChars = buffer.getStringProperty(\\\"wordBreakChars\\\");\\n\\t\\tint logicalLength = 0; \\t\\tint lastWordOffset = -1;\\n\\t\\tboolean lastWasSpace = true;\\n\\t\\tfor(int i = 0; i < caretPos; i++)\\n\\t\\t{\\n\\t\\t\\tchar ch = lineSegment.array[lineSegment.offset + i];\\n\\t\\t\\tif(ch == '\\\\t')\\n\\t\\t\\t{\\n\\t\\t\\t\\tlogicalLength += tabSize - (logicalLength % tabSize);\\n\\t\\t\\t\\tif(!lastWasSpace && logicalLength <= maxLineLen)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastWordOffset = i;\\n\\t\\t\\t\\t\\tlastWasSpace = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(ch == ' ')\\n\\t\\t\\t{\\n\\t\\t\\t\\tlogicalLength++;\\n\\t\\t\\t\\tif(!lastWasSpace && logicalLength <= maxLineLen)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastWordOffset = i;\\n\\t\\t\\t\\t\\tlastWasSpace = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(wordBreakChars != null && wordBreakChars.indexOf(ch) != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlogicalLength++;\\n\\t\\t\\t\\tif(!lastWasSpace && logicalLength <= maxLineLen)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastWordOffset = i;\\n\\t\\t\\t\\t\\tlastWasSpace = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tlogicalLength++;\\n\\t\\t\\t\\tlastWasSpace = false;\\n\\t\\t\\t}\\n\\t\\t\\tint insertNewLineAt;\\n\\t\\t\\tif(spaceInserted && logicalLength == maxLineLen\\n\\t\\t\\t\\t&& i == caretPos - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsertNewLineAt = caretPos;\\n\\t\\t\\t\\treturnValue = true;\\n\\t\\t\\t}\\n\\t\\t\\telse if(logicalLength >= maxLineLen && lastWordOffset != -1)\\n\\t\\t\\t\\tinsertNewLineAt = lastWordOffset;\\n\\t\\t\\telse\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tbuffer.insert(start + insertNewLineAt,\\\"\\\\n\\\");\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbuffer.indentLine(caretLine,true);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t\\treturn returnValue;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t} \\n\\t\\tprivate void doWordCount(View view, String text)\\n\\t{\\n\\t\\tchar[] chars = text.toCharArray();\\n\\t\\tint characters = chars.length;\\n\\t\\tint words;\\n\\t\\tif(characters == 0)\\n\\t\\t\\twords = 0;\\n\\t\\telse\\n\\t\\t\\twords = 1;\\n\\t\\tint lines = 1;\\n\\t\\tboolean word = false;\\n\\t\\tfor(int i = 0; i < chars.length; i++)\\n\\t\\t{\\n\\t\\t\\tswitch(chars[i])\\n\\t\\t\\t{\\n\\t\\t\\tcase '\\\\r': case '\\\\n':\\n\\t\\t\\t\\tlines++;\\n\\t\\t\\tcase ' ': case '\\\\t':\\n\\t\\t\\t\\tif(word)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twords++;\\n\\t\\t\\t\\t\\tword = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tword = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tObject[] args = { new Integer(characters), new Integer(words),\\n\\t\\t\\tnew Integer(lines) };\\n\\t\\tGUIUtilities.message(view,\\\"wordcount\\\",args);\\n\\t} \\n\\t\\tprivate void updateBracketHighlightWithDelay()\\n\\t{\\n\\t\\tbracketTimer.stop();\\n\\t\\tbracketTimer.start();\\n\\t} \\n\\t\\tprivate void updateBracketHighlight()\\n\\t{\\n\\t\\tif(!painter.isBracketHighlightEnabled()\\n\\t\\t\\t&& !gutter.isBracketHighlightEnabled())\\n\\t\\t\\treturn;\\n\\t\\tint offset = caret - getLineStartOffset(caretLine);\\n\\t\\tif(offset != 0)\\n\\t\\t{\\n\\t\\t\\tint bracketOffset = TextUtilities.findMatchingBracket(\\n\\t\\t\\t\\tbuffer,caretLine,offset - 1);\\n\\t\\t\\tif(bracketOffset != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbracketLine = getLineOfOffset(bracketOffset);\\n\\t\\t\\t\\tbracketPosition = bracketOffset\\n\\t\\t\\t\\t\\t- getLineStartOffset(bracketLine);\\n\\t\\t\\t\\tinvalidateLineRange(bracketLine,caretLine);\\n\\t\\t\\t\\tif(chunkCache.getScreenLineOfOffset(bracketLine,bracketPosition) == -1)\\n\\t\\t\\t\\t\\tshowBracketStatusMessage(bracketLine < caretLine);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbracketLine = bracketPosition = -1;\\n\\t} \\n\\t\\tprivate void showBracketStatusMessage(boolean backward)\\n\\t{\\n\\t\\tString text = buffer.getLineText(bracketLine).trim();\\n\\t\\tif(backward && bracketLine != 0 && text.length() == 1)\\n\\t\\t{\\n\\t\\t\\tswitch(text.charAt(0))\\n\\t\\t\\t{\\n\\t\\t\\tcase '{': case '}':\\n\\t\\t\\tcase '[': case ']':\\n\\t\\t\\tcase '(': case ')':\\n\\t\\t\\t\\ttext = buffer.getLineText(bracketLine - 1).trim()\\n\\t\\t\\t\\t\\t+ \\\" \\\" + text;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\ttext = text.replace('\\\\t',' ');\\n\\t\\tview.getStatus().setMessageAndClear(jEdit.getProperty(\\n\\t\\t\\t\\\"view.status.bracket\\\",new Object[] { \\n\\t\\t\\tnew Integer(bracketLine), text }));\\n\\t} \\n\\t\\tvoid recalculateLastPhysicalLine()\\n\\t{\\n\\t\\tint oldScreenLastLine = screenLastLine;\\n\\t\\tfor(int i = visibleLines - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(i);\\n\\t\\t\\tif(info.physicalLine != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tphysLastLine = info.physicalLine;\\n\\t\\t\\t\\tscreenLastLine = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tinvalidateScreenLineRange(oldScreenLastLine,screenLastLine);\\n\\t} \\n\\t\\tstatic class RectParams\\n\\t{\\n\\t\\tint extraStartVirt;\\n\\t\\tint extraEndVirt;\\n\\t\\tint newCaret;\\n\\t\\tRectParams(int extraStartVirt, int extraEndVirt, int newCaret)\\n\\t\\t{\\n\\t\\t\\tthis.extraStartVirt = extraStartVirt;\\n\\t\\t\\tthis.extraEndVirt = extraEndVirt;\\n\\t\\t\\tthis.newCaret = newCaret;\\n\\t\\t}\\n\\t}\\n\\tprivate RectParams getRectParams(int caret, int newCaret)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint virtualWidth;\\n\\t\\tif(s instanceof Selection.Rect)\\n\\t\\t{\\n\\t\\t\\tif(caret == s.end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvirtualWidth = buffer.getVirtualWidth(\\n\\t\\t\\t\\t\\ts.endLine,s.end - getLineStartOffset(\\n\\t\\t\\t\\t\\ts.endLine)) + ((Selection.Rect)s).extraEndVirt;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tvirtualWidth = buffer.getVirtualWidth(\\n\\t\\t\\t\\t\\ts.startLine,s.start - getLineStartOffset(\\n\\t\\t\\t\\t\\ts.startLine)) + ((Selection.Rect)s).extraStartVirt;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(rectangularSelectionMode)\\n\\t\\t{\\n\\t\\t\\tvirtualWidth = buffer.getVirtualWidth(\\n\\t\\t\\t\\tcaretLine,caret - buffer.getLineStartOffset(caretLine));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn null;\\n\\t\\tint newLine = getLineOfOffset(newCaret);\\n\\t\\tint[] totalVirtualWidth = new int[1];\\n\\t\\tint newOffset = buffer.getOffsetOfVirtualColumn(newLine,\\n\\t\\t\\tvirtualWidth,totalVirtualWidth);\\n\\t\\tif(newOffset == -1)\\n\\t\\t{\\n\\t\\t\\tint extraVirt = virtualWidth - totalVirtualWidth[0];\\n\\t\\t\\tnewCaret = getLineEndOffset(newLine) - 1;\\n\\t\\t\\tRectParams returnValue;\\n\\t\\t\\tboolean bias;\\n\\t\\t\\tif(s == null)\\n\\t\\t\\t\\tbias = (newCaret < caret);\\n\\t\\t\\telse if(s.start == caret)\\n\\t\\t\\t\\tbias = (newCaret <= s.end);\\n\\t\\t\\telse if(s.end == caret)\\n\\t\\t\\t\\tbias = (newCaret <= s.start);\\n\\t\\t\\telse\\n\\t\\t\\t\\tbias = false;\\n\\t\\t\\tif(bias)\\n\\t\\t\\t\\treturnValue = new RectParams(extraVirt,0,newCaret);\\n\\t\\t\\telse\\n\\t\\t\\t\\treturnValue = new RectParams(0,extraVirt,newCaret);\\n\\t\\t\\treturn returnValue;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\treturn new RectParams(0,0,getLineStartOffset(newLine)\\n\\t\\t\\t\\t+ newOffset);\\n\\t\\t}\\n\\t} \\n\\t\\tstatic class TextAreaBorder extends AbstractBorder\\n\\t{\\n\\t\\tprivate static final Insets insets = new Insets(1, 1, 2, 2);\\n\\t\\t\\t\\tpublic void paintBorder(Component c, Graphics g, int x, int y,\\n\\t\\t\\tint width, int height)\\n\\t\\t{\\n\\t\\t\\tg.translate(x,y);\\n\\t\\t\\tg.setColor(MetalLookAndFeel.getControlDarkShadow());\\n\\t\\t\\tg.drawRect(0,0,width-2,height-2);\\n\\t\\t\\tg.setColor(MetalLookAndFeel.getControlHighlight());\\n\\t\\t\\tg.drawLine(width-1,1,width-1,height-1);\\n\\t\\t\\tg.drawLine(1,height-1,width-1,height-1);\\n\\t\\t\\tg.setColor(MetalLookAndFeel.getControl());\\n\\t\\t\\tg.drawLine(width-2,2,width-2,2);\\n\\t\\t\\tg.drawLine(1,height-2,1,height-2);\\n\\t\\t\\tg.translate(-x,-y);\\n\\t\\t} \\n\\t\\t\\t\\tpublic Insets getBorderInsets(Component c)\\n\\t\\t{\\n\\t\\t\\treturn new Insets(1,1,2,2);\\n\\t\\t} \\t} \\n\\t\\tclass ScrollLayout implements LayoutManager\\n\\t{\\n\\t\\t\\t\\tpublic void addLayoutComponent(String name, Component comp)\\n\\t\\t{\\n\\t\\t\\tif(name.equals(CENTER))\\n\\t\\t\\t\\tcenter = comp;\\n\\t\\t\\telse if(name.equals(RIGHT))\\n\\t\\t\\t\\tright = comp;\\n\\t\\t\\telse if(name.equals(LEFT))\\n\\t\\t\\t\\tleft = comp;\\n\\t\\t\\telse if(name.equals(BOTTOM))\\n\\t\\t\\t\\tbottom = comp;\\n\\t\\t} \\n\\t\\t\\t\\tpublic void removeLayoutComponent(Component comp)\\n\\t\\t{\\n\\t\\t\\tif(center == comp)\\n\\t\\t\\t\\tcenter = null;\\n\\t\\t\\telse if(right == comp)\\n\\t\\t\\t\\tright = null;\\n\\t\\t\\telse if(left == comp)\\n\\t\\t\\t\\tleft = null;\\n\\t\\t\\telse if(bottom == comp)\\n\\t\\t\\t\\tbottom = null;\\n\\t\\t} \\n\\t\\t\\t\\tpublic Dimension preferredLayoutSize(Container parent)\\n\\t\\t{\\n\\t\\t\\tDimension dim = new Dimension();\\n\\t\\t\\tBorder border = getBorder();\\n\\t\\t\\tInsets insets;\\n\\t\\t\\tif(border == null)\\n\\t\\t\\t\\tinsets = new Insets(0,0,0,0);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsets = getBorder().getBorderInsets(\\n\\t\\t\\t\\t\\tJEditTextArea.this);\\n\\t\\t\\t}\\n\\t\\t\\tdim.width = insets.left + insets.right;\\n\\t\\t\\tdim.height = insets.top + insets.bottom;\\n\\t\\t\\tDimension leftPref = left.getPreferredSize();\\n\\t\\t\\tdim.width += leftPref.width;\\n\\t\\t\\tDimension centerPref = center.getPreferredSize();\\n\\t\\t\\tdim.width += centerPref.width;\\n\\t\\t\\tdim.height += centerPref.height;\\n\\t\\t\\tDimension rightPref = right.getPreferredSize();\\n\\t\\t\\tdim.width += rightPref.width;\\n\\t\\t\\tDimension bottomPref = bottom.getPreferredSize();\\n\\t\\t\\tdim.height += bottomPref.height;\\n\\t\\t\\treturn dim;\\n\\t\\t} \\n\\t\\t\\t\\tpublic Dimension minimumLayoutSize(Container parent)\\n\\t\\t{\\n\\t\\t\\tDimension dim = new Dimension();\\n\\t\\t\\tBorder border = getBorder();\\n\\t\\t\\tInsets insets;\\n\\t\\t\\tif(border == null)\\n\\t\\t\\t\\tinsets = new Insets(0,0,0,0);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsets = getBorder().getBorderInsets(\\n\\t\\t\\t\\t\\tJEditTextArea.this);\\n\\t\\t\\t}\\n\\t\\t\\tdim.width = insets.left + insets.right;\\n\\t\\t\\tdim.height = insets.top + insets.bottom;\\n\\t\\t\\tDimension leftPref = left.getMinimumSize();\\n\\t\\t\\tdim.width += leftPref.width;\\n\\t\\t\\tDimension centerPref = center.getMinimumSize();\\n\\t\\t\\tdim.width += centerPref.width; \\n\\t\\t\\tdim.height += centerPref.height;\\n\\t\\t\\tDimension rightPref = right.getMinimumSize();\\n\\t\\t\\tdim.width += rightPref.width;\\n\\t\\t\\tDimension bottomPref = bottom.getMinimumSize();\\n\\t\\t\\tdim.height += bottomPref.height;\\n\\t\\t\\treturn dim;\\n\\t\\t} \\n\\t\\t\\t\\tpublic void layoutContainer(Container parent)\\n\\t\\t{\\n\\t\\t\\tDimension size = parent.getSize();\\n\\t\\t\\tBorder border = getBorder();\\n\\t\\t\\tInsets insets;\\n\\t\\t\\tif(border == null)\\n\\t\\t\\t\\tinsets = new Insets(0,0,0,0);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsets = getBorder().getBorderInsets(\\n\\t\\t\\t\\t\\tJEditTextArea.this);\\n\\t\\t\\t}\\n\\t\\t\\tint itop = insets.top;\\n\\t\\t\\tint ileft = insets.left;\\n\\t\\t\\tint ibottom = insets.bottom;\\n\\t\\t\\tint iright = insets.right;\\n\\t\\t\\tint rightWidth = right.getPreferredSize().width;\\n\\t\\t\\tint leftWidth = left.getPreferredSize().width;\\n\\t\\t\\tint bottomHeight = bottom.getPreferredSize().height;\\n\\t\\t\\tint centerWidth = Math.max(0,size.width - leftWidth\\n\\t\\t\\t\\t- rightWidth - ileft - iright);\\n\\t\\t\\tint centerHeight = Math.max(0,size.height\\n\\t\\t\\t\\t- bottomHeight - itop - ibottom);\\n\\t\\t\\tleft.setBounds(\\n\\t\\t\\t\\tileft,\\n\\t\\t\\t\\titop,\\n\\t\\t\\t\\tleftWidth,\\n\\t\\t\\t\\tcenterHeight);\\n\\t\\t\\tcenter.setBounds(\\n\\t\\t\\t\\tileft + leftWidth,\\n\\t\\t\\t\\titop,\\n\\t\\t\\t\\tcenterWidth,\\n\\t\\t\\t\\tcenterHeight);\\n\\t\\t\\tright.setBounds(\\n\\t\\t\\t\\tileft + leftWidth + centerWidth,\\n\\t\\t\\t\\titop,\\n\\t\\t\\t\\trightWidth,\\n\\t\\t\\t\\tcenterHeight);\\n\\t\\t\\tbottom.setBounds(\\n\\t\\t\\t\\tileft,\\n\\t\\t\\t\\titop + centerHeight,\\n\\t\\t\\t\\tMath.max(0,size.width - vertical.getWidth()\\n\\t\\t\\t\\t\\t- ileft - iright),\\n\\t\\t\\t\\tbottomHeight);\\n\\t\\t} \\n\\t\\tComponent center;\\n\\t\\tComponent left;\\n\\t\\tComponent right;\\n\\t\\tComponent bottom;\\n\\t} \\n\\t\\tstatic class CaretBlinker implements ActionListener\\n\\t{\\n\\t\\t\\t\\tpublic void actionPerformed(ActionEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(focusedComponent != null && focusedComponent.hasFocus())\\n\\t\\t\\t\\tfocusedComponent.blinkCaret();\\n\\t\\t} \\t} \\n\\t\\tclass MutableCaretEvent extends CaretEvent\\n\\t{\\n\\t\\t\\t\\tMutableCaretEvent()\\n\\t\\t{\\n\\t\\t\\tsuper(JEditTextArea.this);\\n\\t\\t} \\n\\t\\t\\t\\tpublic int getDot()\\n\\t\\t{\\n\\t\\t\\treturn getCaretPosition();\\n\\t\\t} \\n\\t\\t\\t\\tpublic int getMark()\\n\\t\\t{\\n\\t\\t\\treturn getMarkPosition();\\n\\t\\t} \\t} \\n\\t\\tclass AdjustHandler implements AdjustmentListener\\n\\t{\\n\\t\\t\\t\\tpublic void adjustmentValueChanged(final AdjustmentEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(!scrollBarsInitialized)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(evt.getAdjustable() == vertical)\\n\\t\\t\\t\\tsetFirstLine(vertical.getValue());\\n\\t\\t\\telse\\n\\t\\t\\t\\tsetHorizontalOffset(-horizontal.getValue());\\n\\t\\t} \\t} \\n\\tclass BufferChangeHandler extends BufferChangeAdapter\\n\\t{\\n\\t\\tboolean delayedUpdate;\\n\\t\\tboolean delayedMultilineUpdate;\\n\\t\\tint delayedRepaintStart;\\n\\t\\tint delayedRepaintEnd;\\n\\t\\t\\t\\tpublic void foldLevelChanged(Buffer buffer, int start, int end)\\n\\t\\t{\\n\\t\\t\\tif(!bufferChanging && end != 0\\n\\t\\t\\t\\t&& buffer.isLoaded())\\n\\t\\t\\t{\\n\\t\\t\\t\\tinvalidateLineRange(start - 1,\\n\\t\\t\\t\\t\\tgetLastPhysicalLine());\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void contentInserted(Buffer buffer, int startLine, int start,\\n\\t\\t\\tint numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t\\tdelayedMultilineUpdate = true;\\n\\t\\t\\tint endLine = startLine + numLines;\\n\\t\\t\\tdelayedRepaint(startLine,endLine);\\n\\t\\t\\t\\t\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\t\\tif(s.contentInserted(buffer,startLine,start,\\n\\t\\t\\t\\t\\tnumLines,length))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdelayedRepaint(s.startLine,s.endLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(!buffer.isTransactionInProgress())\\n\\t\\t\\t\\ttransactionComplete(buffer);\\n\\t\\t\\tif(caret >= start)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint scrollMode = (hasFocus()\\n\\t\\t\\t\\t\\t? ELECTRIC_SCROLL : NO_SCROLL);\\n\\t\\t\\t\\tmoveCaretPosition(caret + length,scrollMode);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint scrollMode = (hasFocus()\\n\\t\\t\\t\\t\\t? NORMAL_SCROLL : NO_SCROLL);\\n\\t\\t\\t\\tmoveCaretPosition(caret,scrollMode);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tpublic void contentRemoved(Buffer buffer, int startLine, int start,\\n\\t\\t\\tint numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t\\tdelayedMultilineUpdate = true;\\n\\t\\t\\tdelayedRepaint(startLine,startLine);\\n\\t\\t\\t\\t\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\t\\tint oldStartLine = s.startLine;\\n\\t\\t\\t\\tint oldEndLine = s.endLine;\\n\\t\\t\\t\\tboolean changed = s.contentRemoved(buffer,\\n\\t\\t\\t\\t\\tstartLine,start,numLines,length);\\n\\t\\t\\t\\tif(s.start == s.end)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tselection.removeElement(s);\\n\\t\\t\\t\\t\\tdelayedRepaint(oldStartLine,oldEndLine);\\n\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(changed)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdelayedRepaint(s.startLine,s.endLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\tint scrollMode = (hasFocus()\\n\\t\\t\\t\\t? NORMAL_SCROLL : NO_SCROLL);\\n\\t\\t\\tif(caret > start)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caret <= start + length)\\n\\t\\t\\t\\t\\tmoveCaretPosition(start,scrollMode);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmoveCaretPosition(caret - length,scrollMode);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tmoveCaretPosition(caret,scrollMode);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(!buffer.isTransactionInProgress())\\n\\t\\t\\t\\ttransactionComplete(buffer);\\n\\t\\t}\\n\\t\\t\\t\\tpublic void transactionComplete(Buffer buffer)\\n\\t\\t{\\n\\t\\t\\tif(delayedUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(delayedMultilineUpdate)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tinvalidateScreenLineRange(chunkCache\\n\\t\\t\\t\\t\\t\\t.getScreenLineOfOffset(\\n\\t\\t\\t\\t\\t\\tdelayedRepaintStart,0),\\n\\t\\t\\t\\t\\t\\tvisibleLines);\\n\\t\\t\\t\\t\\tdelayedMultilineUpdate = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tinvalidateLineRange(delayedRepaintStart,\\n\\t\\t\\t\\t\\t\\tdelayedRepaintEnd);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdelayedUpdate = false;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < runnables.size(); i++)\\n\\t\\t\\t\\t((Runnable)runnables.get(i)).run();\\n\\t\\t\\trunnables.clear();\\n\\t\\t} \\n\\t\\t\\t\\tprivate void delayedRepaint(int startLine, int endLine)\\n\\t\\t{\\n\\t\\t\\tchunkCache.invalidateChunksFromPhys(startLine);\\n\\t\\t\\tif(!delayedUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedRepaintStart = startLine;\\n\\t\\t\\t\\tdelayedRepaintEnd = endLine;\\n\\t\\t\\t\\tdelayedUpdate = true;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedRepaintStart = Math.min(\\n\\t\\t\\t\\t\\tdelayedRepaintStart,\\n\\t\\t\\t\\t\\tstartLine);\\n\\t\\t\\t\\tdelayedRepaintEnd = Math.max(\\n\\t\\t\\t\\t\\tdelayedRepaintEnd,\\n\\t\\t\\t\\t\\tendLine);\\n\\t\\t\\t}\\n\\t\\t} \\t} \\n\\t\\tclass FocusHandler implements FocusListener\\n\\t{\\n\\t\\t\\t\\tpublic void focusGained(FocusEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(bufferChanging)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(bracketLine != -1)\\n\\t\\t\\t\\tinvalidateLineRange(bracketLine,caretLine);\\n\\t\\t\\telse\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t\\tfocusedComponent = JEditTextArea.this;\\n\\t\\t} \\n\\t\\t\\t\\tpublic void focusLost(FocusEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(!isShowing())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(bracketLine != -1)\\n\\t\\t\\t\\tinvalidateLineRange(bracketLine,caretLine);\\n\\t\\t\\telse\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t} \\t} \\n\\t\\tclass MouseHandler extends MouseInputAdapter\\n\\t{\\n\\t\\tprivate int dragStartLine;\\n\\t\\tprivate int dragStartOffset;\\n\\t\\tprivate int dragStart;\\n\\t\\tprivate int clickCount;\\n\\t\\tprivate boolean dragged;\\n\\t\\tprivate boolean quickCopyDrag;\\n\\t\\tprivate boolean clearStatus;\\n\\t\\tprivate boolean control;\\n\\t\\t\\t\\tpublic void mousePressed(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tcontrol = (OperatingSystem.isMacOS() && evt.isMetaDown())\\n\\t\\t\\t\\t|| (!OperatingSystem.isMacOS() && evt.isControlDown());\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tview.getInputHandler().resetLastActionCount();\\n\\t\\t\\tquickCopyDrag = (isQuickCopyEnabled() &&\\n\\t\\t\\t\\tGUIUtilities.isMiddleButton(evt.getModifiers()));\\n\\t\\t\\tif(!quickCopyDrag)\\n\\t\\t\\t{\\n\\t\\t\\t\\trequestFocus();\\n\\t\\t\\t\\tfocusedComponent = JEditTextArea.this;\\n\\t\\t\\t}\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tint x = evt.getX();\\n\\t\\t\\tint y = evt.getY();\\n\\t\\t\\tdragStart = xyToOffset(x,y,!(painter.isBlockCaretEnabled()\\n\\t\\t\\t\\t|| isOverwriteEnabled()));\\n\\t\\t\\tdragStartLine = getLineOfOffset(dragStart);\\n\\t\\t\\tdragStartOffset = dragStart - getLineStartOffset(dragStartLine);\\n\\t\\t\\tif(GUIUtilities.isPopupTrigger(evt) && popup != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(popup.isVisible())\\n\\t\\t\\t\\t\\tpopup.setVisible(false);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(getSelectionCount() == 0 || multi)\\n\\t\\t\\t\\t\\t\\tmoveCaretPosition(dragStart,false);\\n\\t\\t\\t\\t\\tGUIUtilities.showPopupMenu(popup,painter,\\n\\t\\t\\t\\t\\t\\tevt.getX(),evt.getY());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tdragged = false;\\n\\t\\t\\tblink = true;\\n\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t\\tclickCount = evt.getClickCount();\\n\\t\\t\\tswitch(clickCount)\\n\\t\\t\\t{\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\tdoSingleClick(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\tdoDoubleClick(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault: \\t\\t\\t\\tdoTripleClick(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doSingleClick(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tint x = evt.getX();\\n\\t\\t\\tint extraEndVirt = 0;\\n\\t\\t\\tif(chunkCache.getLineInfo(screenLastLine).lastSubregion)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfloat dragStartLineWidth = offsetToXY(\\n\\t\\t\\t\\t\\tdragStartLine,getLineLength(dragStartLine),\\n\\t\\t\\t\\t\\treturnValue).x;\\n\\t\\t\\t\\tif(x > dragStartLineWidth)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\textraEndVirt = (int)(\\n\\t\\t\\t\\t\\t\\t(x - dragStartLineWidth)\\n\\t\\t\\t\\t\\t\\t/ charWidth);\\n\\t\\t\\t\\t\\tif(!getPainter().isBlockCaretEnabled()\\n\\t\\t\\t\\t\\t\\t&& !isOverwriteEnabled()\\n\\t\\t\\t\\t\\t\\t&& (x - getHorizontalOffset()) % charWidth > charWidth / 2)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\textraEndVirt++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(control || isRectangularSelectionEnabled())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint screenLine = (evt.getY() / getPainter()\\n\\t\\t\\t\\t\\t.getFontMetrics().getHeight());\\n\\t\\t\\t\\tif(screenLine > screenLastLine)\\n\\t\\t\\t\\t\\tscreenLine = screenLastLine;\\n\\t\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(screenLine);\\n\\t\\t\\t\\tif(info.lastSubregion)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tString whitespace = MiscUtilities\\n\\t\\t\\t\\t\\t\\t.createWhiteSpace(extraEndVirt,0);\\n\\t\\t\\t\\t\\tbuffer.insert(dragStart,whitespace);\\n\\t\\t\\t\\t\\tdragStart += whitespace.length();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(evt.isShiftDown())\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tresizeSelection(getMarkPosition(),dragStart,extraEndVirt,\\n\\t\\t\\t\\t\\tisRectangularSelectionEnabled()\\n\\t\\t\\t\\t\\t|| control);\\n\\t\\t\\t\\tif(!quickCopyDrag)\\n\\t\\t\\t\\t\\tmoveCaretPosition(dragStart,false);\\n\\t\\t\\t\\t\\t\\t\\t\\tdragStartLine = getMarkLine();\\n\\t\\t\\t\\tdragStart = getMarkPosition();\\n\\t\\t\\t\\tdragStartOffset = dragStart\\n\\t\\t\\t\\t\\t- getLineStartOffset(dragStartLine);\\n\\t\\t\\t\\t\\t\\t\\t\\tdragged = true;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(!quickCopyDrag)\\n\\t\\t\\t\\tmoveCaretPosition(dragStart,false);\\n\\t\\t\\tif(!(multi || quickCopyDrag))\\n\\t\\t\\t\\tselectNone();\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doDoubleClick(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(getLineLength(dragStartLine) == 0)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tString lineText = getLineText(dragStartLine);\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tif(dragStartOffset == getLineLength(dragStartLine))\\n\\t\\t\\t\\tdragStartOffset--;\\n\\t\\t\\tboolean joinNonWordChars =\\n\\t\\t\\t\\tjEdit.getBooleanProperty(\\\"view.joinNonWordChars\\\");\\n\\t\\t\\tint wordStart = TextUtilities.findWordStart(lineText,\\n\\t\\t\\t\\tdragStartOffset,noWordSep,joinNonWordChars);\\n\\t\\t\\tint wordEnd = TextUtilities.findWordEnd(lineText,\\n\\t\\t\\t\\tdragStartOffset+1,noWordSep,joinNonWordChars);\\n\\t\\t\\tint lineStart = getLineStartOffset(dragStartLine);\\n\\t\\t\\tSelection sel = new Selection.Range(\\n\\t\\t\\t\\tlineStart + wordStart,\\n\\t\\t\\t\\tlineStart + wordEnd);\\n\\t\\t\\tif(isMultipleSelectionEnabled())\\n\\t\\t\\t\\taddToSelection(sel);\\n\\t\\t\\telse\\n\\t\\t\\t\\tsetSelection(sel);\\n\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t\\tquickCopyDrag = false;\\n\\t\\t\\tmoveCaretPosition(lineStart + wordEnd,false);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdragged = true;\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doTripleClick(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tint newCaret = getLineEndOffset(dragStartLine);\\n\\t\\t\\tif(dragStartLine == buffer.getLineCount() - 1)\\n\\t\\t\\t\\tnewCaret--;\\n\\t\\t\\tSelection sel = new Selection.Range(\\n\\t\\t\\t\\tgetLineStartOffset(dragStartLine),\\n\\t\\t\\t\\tnewCaret);\\n\\t\\t\\tif(isMultipleSelectionEnabled())\\n\\t\\t\\t\\taddToSelection(sel);\\n\\t\\t\\telse\\n\\t\\t\\t\\tsetSelection(sel);\\n\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t\\tquickCopyDrag = false;\\n\\t\\t\\tmoveCaretPosition(newCaret,false);\\n\\t\\t} \\n\\t\\t\\t\\tpublic void mouseDragged(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(GUIUtilities.isPopupTrigger(evt)\\n\\t\\t\\t\\t|| (popup != null && popup.isVisible()))\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(evt.getY() < 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint delta = Math.min(-1,evt.getY()\\n\\t\\t\\t\\t\\t/ painter.getFontMetrics()\\n\\t\\t\\t\\t\\t.getHeight());\\n\\t\\t\\t\\tsetFirstLine(getFirstLine() + delta);\\n\\t\\t\\t}\\n\\t\\t\\telse if(evt.getY() >= painter.getHeight())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint delta = Math.max(1,(evt.getY()\\n\\t\\t\\t\\t\\t- painter.getHeight()) /\\n\\t\\t\\t\\t\\tpainter.getFontMetrics()\\n\\t\\t\\t\\t\\t.getHeight());\\n\\t\\t\\t\\tif(lastLinePartial)\\n\\t\\t\\t\\t\\tdelta--;\\n\\t\\t\\t\\tsetFirstLine(getFirstLine() + delta);\\n\\t\\t\\t}\\n\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t{\\n\\t\\t\\t\\tview.getStatus().setMessage(jEdit.getProperty(\\n\\t\\t\\t\\t\\t\\\"view.status.rect-quick-copy\\\"));\\n\\t\\t\\t\\tclearStatus = true;\\n\\t\\t\\t}\\n\\t\\t\\tswitch(clickCount)\\n\\t\\t\\t{\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\tdoSingleDrag(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\tdoDoubleDrag(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault: \\t\\t\\t\\tdoTripleDrag(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doSingleDrag(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tdragged = true;\\n\\t\\t\\tint x = evt.getX();\\n\\t\\t\\tint y = evt.getY();\\n\\t\\t\\tif(y < 0)\\n\\t\\t\\t\\ty = 0;\\n\\t\\t\\telse if(y >= painter.getHeight())\\n\\t\\t\\t\\ty = painter.getHeight() - 1;\\n\\t\\t\\tint dot = xyToOffset(x,y,\\n\\t\\t\\t\\t(!painter.isBlockCaretEnabled()\\n\\t\\t\\t\\t&& !isOverwriteEnabled())\\n\\t\\t\\t\\t|| quickCopyDrag);\\n\\t\\t\\tint dotLine = buffer.getLineOfOffset(dot);\\n\\t\\t\\tint extraEndVirt = 0;\\n\\t\\t\\tif(chunkCache.getLineInfo(screenLastLine).lastSubregion)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfloat dotLineWidth = offsetToXY(dotLine,getLineLength(dotLine),\\n\\t\\t\\t\\t\\treturnValue).x;\\n\\t\\t\\t\\tif(x > dotLineWidth)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\textraEndVirt = (int)((x - dotLineWidth) / charWidth);\\n\\t\\t\\t\\t\\tif(!getPainter().isBlockCaretEnabled()\\n\\t\\t\\t\\t\\t\\t&& !isOverwriteEnabled()\\n\\t\\t\\t\\t\\t\\t&& (x - getHorizontalOffset()) % charWidth > charWidth / 2)\\n\\t\\t\\t\\t\\t\\textraEndVirt++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tresizeSelection(dragStart,dot,extraEndVirt,\\n\\t\\t\\t\\tisRectangularSelectionEnabled()\\n\\t\\t\\t\\t|| control);\\n\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tscrollTo(dotLine,dot - buffer.getLineStartOffset(dotLine),false);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(dot != caret)\\n\\t\\t\\t\\t\\tmoveCaretPosition(dot,false);\\n\\t\\t\\t\\tif(isRectangularSelectionEnabled()\\n\\t\\t\\t\\t\\t&& extraEndVirt != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscrollTo(dotLine,dot - buffer.getLineStartOffset(dotLine)\\n\\t\\t\\t\\t\\t\\t+ extraEndVirt,false);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doDoubleDrag(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tint markLineStart = getLineStartOffset(dragStartLine);\\n\\t\\t\\tint markLineLength = getLineLength(dragStartLine);\\n\\t\\t\\tint mark = dragStartOffset;\\n\\t\\t\\tint pos = xyToOffset(evt.getX(),\\n\\t\\t\\t\\tMath.max(0,Math.min(painter.getHeight(),evt.getY())),\\n\\t\\t\\t\\t!(painter.isBlockCaretEnabled() || isOverwriteEnabled()));\\n\\t\\t\\tint line = getLineOfOffset(pos);\\n\\t\\t\\tint lineStart = getLineStartOffset(line);\\n\\t\\t\\tint lineLength = getLineLength(line);\\n\\t\\t\\tint offset = pos - lineStart;\\n\\t\\t\\tString lineText = getLineText(line);\\n\\t\\t\\tString markLineText = getLineText(dragStartLine);\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tboolean joinNonWordChars =\\n\\t\\t\\t\\tjEdit.getBooleanProperty(\\\"view.joinNonWordChars\\\");\\n\\t\\t\\tif(markLineStart + dragStartOffset > lineStart + offset)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(offset != 0 && offset != lineLength)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\toffset = TextUtilities.findWordStart(\\n\\t\\t\\t\\t\\t\\tlineText,offset,noWordSep,\\n\\t\\t\\t\\t\\t\\tjoinNonWordChars);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(markLineLength != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmark = TextUtilities.findWordEnd(\\n\\t\\t\\t\\t\\t\\tmarkLineText,mark,noWordSep,\\n\\t\\t\\t\\t\\t\\tjoinNonWordChars);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(offset != 0 && lineLength != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\toffset = TextUtilities.findWordEnd(\\n\\t\\t\\t\\t\\t\\tlineText,offset,noWordSep,\\n\\t\\t\\t\\t\\t\\tjoinNonWordChars);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(mark != 0 && mark != markLineLength)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmark = TextUtilities.findWordStart(\\n\\t\\t\\t\\t\\t\\tmarkLineText,mark,noWordSep,\\n\\t\\t\\t\\t\\t\\tjoinNonWordChars);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(lineStart + offset == caret)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tresizeSelection(markLineStart + mark,lineStart + offset,\\n\\t\\t\\t\\t0,false);\\n\\t\\t\\tif(!quickCopyDrag)\\n\\t\\t\\t\\tmoveCaretPosition(lineStart + offset,false);\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doTripleDrag(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tint offset = xyToOffset(evt.getX(),\\n\\t\\t\\t\\tMath.max(0,Math.min(painter.getHeight(),evt.getY())),\\n\\t\\t\\t\\tfalse);\\n\\t\\t\\tint mouseLine = getLineOfOffset(offset);\\n\\t\\t\\tint mark;\\n\\t\\t\\tint mouse;\\n\\t\\t\\tif(dragStartLine > mouseLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmark = getLineEndOffset(dragStartLine) - 1;\\n\\t\\t\\t\\tif(offset == getLineEndOffset(mouseLine) - 1)\\n\\t\\t\\t\\t\\tmouse = offset;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmouse = getLineStartOffset(mouseLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tmark = getLineStartOffset(dragStartLine);\\n\\t\\t\\t\\tif(offset == getLineStartOffset(mouseLine))\\n\\t\\t\\t\\t\\tmouse = offset;\\n\\t\\t\\t\\telse if(offset == getLineEndOffset(mouseLine) - 1\\n\\t\\t\\t\\t\\t&& mouseLine != getBuffer().getLineCount() - 1)\\n\\t\\t\\t\\t\\tmouse = getLineEndOffset(mouseLine);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmouse = getLineEndOffset(mouseLine) - 1;\\n\\t\\t\\t}\\n\\t\\t\\tmouse = Math.min(getBuffer().getLength(),mouse);\\n\\t\\t\\tif(mouse == caret)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tdragged = true;\\n\\t\\t\\tresizeSelection(mark,mouse,0,false);\\n\\t\\t\\tmoveCaretPosition(mouse,false);\\n\\t\\t} \\n\\t\\t\\t\\tpublic void mouseReleased(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tSelection sel = getSelectionAtOffset(dragStart);\\n\\t\\t\\tif(dragged && sel != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tRegisters.setRegister('%',getSelectedText(sel));\\n\\t\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tremoveFromSelection(sel);\\n\\t\\t\\t\\t\\tRegisters.paste(focusedComponent,\\n\\t\\t\\t\\t\\t\\t'%',sel instanceof Selection.Rect);\\n\\t\\t\\t\\t\\tfocusedComponent.requestFocus();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(isQuickCopyEnabled()\\n\\t\\t\\t\\t&& GUIUtilities.isMiddleButton(evt.getModifiers()))\\n\\t\\t\\t{\\n\\t\\t\\t\\tJEditTextArea.this.requestFocus();\\n\\t\\t\\t\\tfocusedComponent = JEditTextArea.this;\\n\\t\\t\\t\\tsetCaretPosition(dragStart,false);\\n\\t\\t\\t\\tif(!isEditable())\\n\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tRegisters.paste(JEditTextArea.this,'%',control);\\n\\t\\t\\t}\\n\\t\\t\\tdragged = false;\\n\\t\\t\\tif(clearStatus)\\n\\t\\t\\t{\\n\\t\\t\\t\\tclearStatus = false;\\n\\t\\t\\t\\tview.getStatus().setMessage(null);\\n\\t\\t\\t}\\n\\t\\t} \\t} \\n\\t\\tstatic\\n\\t{\\n\\t\\tcaretTimer = new Timer(500,new CaretBlinker());\\n\\t\\tcaretTimer.setInitialDelay(500);\\n\\t\\tcaretTimer.start();\\n\\t\\tbracketTimer = new Timer(200,new ActionListener()\\n\\t\\t{\\n\\t\\t\\tpublic void actionPerformed(ActionEvent evt)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(focusedComponent != null)\\n\\t\\t\\t\\t\\tfocusedComponent.updateBracketHighlight();\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tbracketTimer.setInitialDelay(200);\\n\\t\\tbracketTimer.setRepeats(false);\\n\\t} }\""
            },
            "m17": {
                "role": "user",
                "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
            },
            "m18": {
                "content": "Title: Diagnosis of starting entity `jEdit.java`\n\nChange set: [JEditTextArea, PluginJAR, Buffer, MiscUtilities, GUIUtilities, DockableWindowManager, View, ActionContext, SearchAndReplace, KillRing, HelpViewer, VFSBrowser, TextAreaPainter, Gutter, BeanShell, Macros, PluginManager, Registers, Mode, DisplayManager, EditPane, PropertiesChanged, BufferChangeHandler, InputHandler, HistoryModel, BufferHistory, PropertyManager, DefaultInputHandler, VFS, ServiceManager, ToolBarOptionPane, GeneralOptionPane, Abbrevs, ShortcutsOptionPane, JEditActionContext, KeyHandler, OperatingSystem, Log, DockableWindowConfig, OptionsDialog, HyperSearchResults, Statusbar, PluginList, PluginUpdate, PluginError, PluginResURLConnection, JARClassLoader, TextAreaTransferHandler]\n\nDetails:\n- **JEditTextArea**: High conceptual coupling (0.8465) with jEdit; heavily used for text editing and UI interaction.\n- **PluginJAR**: Directly involved in plugin management and loading; core to startup and extension logic.\n- **Buffer**: Central to file handling; frequently co-changed with jEdit.\n- **MiscUtilities**: Widely used utility class; changes affect global behavior.\n- **GUIUtilities**: Manages UI components; tightly linked to jEdit\u2019s visual behavior.\n- **DockableWindowManager**: Controls dockable windows; co-change support indicates integration.\n- **View**: Core view container; often modified alongside jEdit.\n- **ActionContext**: Manages actions; key to command execution framework.\n- **SearchAndReplace**: Frequently used feature; shows high co-change confidence.\n- **KillRing**: Clipboard management tied to buffer operations.\n- **HelpViewer**: Invoked during startup if help is enabled.\n- **VFSBrowser**: Used in file browsing and selection workflows.\n- **TextAreaPainter**: Renders text content; interacts with buffer display.\n- **Gutter**: Part of the text area UI; displays line numbers, markers.\n- **BeanShell**: For scripting and macro execution from jEdit.\n- **Macros**: Used to manage user macros; integrates with buffers.\n- **PluginManager**: Responsible for plugin lifecycle; loaded early on.\n- **Registers**: Manages clipboard registers; related to copy/paste functionality.\n- **Mode**: Syntax mode associated with files/buffer types.\n- **DisplayManager**: Coordinates how buffers are displayed.\n- **EditPane**: Displays the edit session; closely linked to views.\n- **PropertiesChanged**: Listens to property updates initiated by jEdit.\n- **BufferChangeHandler**: Reacts to buffer state changes from jEdit.\n- **InputHandler**: Handles input events; connects to main jEdit actions.\n- **HistoryModel**: Maintains history; jEdit modifies this during usage.\n- **BufferHistory**: Tracks file access history; saved/loaded by jEdit.\n- **PropertyManager**: Central property handling mechanism.\n- **DefaultInputHandler**: Base handler for inputs driven by jEdit.\n- **VFS**: Virtual file system used across buffer and plugin interactions.\n- **ServiceManager**: Enables service lookup for plugins and extensions.\n- **ToolBarOptionPane**: Configures toolbars managed by jEdit.\n- **GeneralOptionPane**: Global settings pane for preferences.\n- **Abbrevs**: Abbreviation handling tied to text entry in jEdit.\n- **ShortcutsOptionPane**: Modifies keyboard shortcuts used by jEdit.\n- **JEditActionContext**: Context for action execution within jEdit.\n- **KeyHandler**: Processes key strokes, which may be configured via jEdit.\n- **OperatingSystem**: OS-specific behaviors influence UI and IO.\n- **Log**: Logging is extensively used by jEdit for diagnostics.\n- **DockableWindowConfig**: Configuration for dockables managed by jEdit.\n- **OptionsDialog**: Manages options that affect jEdit's behavior.\n- **HyperSearchResults**: Related to search workflows initiated from jEdit.\n- **Statusbar**: Part of the UI updated by various jEdit activities.\n- **PluginList**: Manages list of plugins; changed when plugins are added or removed.\n- **PluginUpdate**: Updates plugins dynamically; invoked by jEdit.\n- **PluginError**: Errors in plugins impact overall application behavior.\n- **PluginResURLConnection**: Handles resource connections for plugins.\n- **JARClassLoader**: Class loading mechanism for dynamic plugin loading.\n- **TextAreaTransferHandler**: Drag-and-drop/UI transfer features for text areas.\n\nThese entities were selected based on strong historical co-change data, conceptual coupling, and functional interdependence inferred through event bus communication, indirect references, and shared responsibilities in managing the editor environment.",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            }
        }
    }
}