{
    "time": 1749479974.5328283,
    "messages": [
        {
            "role": "system",
            "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
        },
        {
            "role": "user",
            "content": "The project you need to analyze is `jEdit`, a well-known Java open source project. The starting entity you need to deal with is JEditTextArea.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
        },
        {
            "content": "",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_4c74cb5a5f224d2e9f6302",
                    "function": {
                        "arguments": "{\"entity\": \"JEditTextArea.java\"}",
                        "name": "get_co_change_relationship"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "name": "get_co_change_relationship",
            "role": "tool",
            "content": "[[\"MouseHandler\", \"47\", \"0.26704545454545453\"], [\"Buffer\", \"19\", \"0.10795454545454546\"], [\"FoldVisibilityManager\", \"9\", \"0.05113636363636364\"], [\"DefaultInputHandler\", \"8\", \"0.045454545454545456\"], [\"SearchAndReplace\", \"17\", \"0.09659090909090909\"], [\"View\", \"21\", \"0.11931818181818182\"], [\"CharIndexedSegment\", \"2\", \"0.011363636363636364\"], [\"SearchMatcher\", \"4\", \"0.022727272727272728\"], [\"BrowserJTree\", \"4\", \"0.022727272727272728\"], [\"BoyerMooreSearchMatcher\", \"6\", \"0.03409090909090909\"], [\"HyperSearchRequest\", \"4\", \"0.022727272727272728\"], [\"RESearchMatcher\", \"6\", \"0.03409090909090909\"], [\"TextRenderer\", \"2\", \"0.011363636363636364\"], [\"RotatedTextIcon\", \"2\", \"0.011363636363636364\"], [\"FileVFS\", \"7\", \"0.03977272727272727\"], [\"FontSelectorDialog\", \"2\", \"0.011363636363636364\"], [\"FileRootsVFS\", \"4\", \"0.022727272727272728\"], [\"PanelWindowContainer\", \"8\", \"0.045454545454545456\"], [\"FontSelector\", \"2\", \"0.011363636363636364\"], [\"TextAreaPainter\", \"40\", \"0.22727272727272727\"], [\"Chunk\", \"4\", \"0.022727272727272728\"], [\"AboutPanel\", \"2\", \"0.011363636363636364\"], [\"TextUtilities\", \"11\", \"0.0625\"], [\"OffsetManager\", \"24\", \"0.13636363636363635\"], [\"BufferPrintable\", \"10\", \"0.056818181818181816\"], [\"MyFocusManager\", \"2\", \"0.011363636363636364\"], [\"BrowserView\", \"6\", \"0.03409090909090909\"], [\"BrowserIORequest\", \"4\", \"0.022727272727272728\"], [\"VFSBrowser\", \"12\", \"0.06818181818181818\"], [\"ChunkCache\", \"51\", \"0.2897727272727273\"], [\"LineInfo\", \"6\", \"0.03409090909090909\"], [\"BufferChangeHandler\", \"50\", \"0.2840909090909091\"], [\"Gutter\", \"25\", \"0.14204545454545456\"], [\"EditPane\", \"13\", \"0.07386363636363637\"], [\"FocusHandler\", \"5\", \"0.028409090909090908\"], [\"TOCTree\", \"2\", \"0.011363636363636364\"], [\"HelpViewer\", \"6\", \"0.03409090909090909\"], [\"HyperSearchResults\", \"5\", \"0.028409090909090908\"], [\"BufferPrinter\", \"2\", \"0.011363636363636364\"], [\"SearchDialog\", \"6\", \"0.03409090909090909\"], [\"EditAction\", \"4\", \"0.022727272727272728\"], [\"Macro\", \"2\", \"0.011363636363636364\"], [\"EnhancedButton\", \"2\", \"0.011363636363636364\"], [\"EnhancedMenuItem\", \"2\", \"0.011363636363636364\"], [\"ActionListHandler\", \"2\", \"0.011363636363636364\"], [\"InputHandler\", \"5\", \"0.028409090909090908\"], [\"DockingOptionPane\", \"2\", \"0.011363636363636364\"], [\"PaintSelection\", \"8\", \"0.045454545454545456\"], [\"ActionHandler\", \"17\", \"0.09659090909090909\"], [\"CompoundEdit\", \"2\", \"0.011363636363636364\"], [\"UndoManager\", \"4\", \"0.022727272727272728\"], [\"MemoryStatus\", \"2\", \"0.011363636363636364\"], [\"KeyEventWorkaround\", \"8\", \"0.045454545454545456\"], [\"HistoryModel\", \"2\", \"0.011363636363636364\"], [\"MultiSelectStatusChanged\", \"2\", \"0.011363636363636364\"], [\"GutterOptionPane\", \"2\", \"0.011363636363636364\"], [\"AbstractOptionPane\", \"2\", \"0.011363636363636364\"], [\"OptionsDialog\", \"2\", \"0.011363636363636364\"], [\"TextAreaOptionPane\", \"2\", \"0.011363636363636364\"], [\"Renderer\", \"2\", \"0.011363636363636364\"], [\"AbbrevsOptionPane\", \"2\", \"0.011363636363636364\"], [\"ExtensionManager\", \"2\", \"0.011363636363636364\"], [\"BrowserHandler\", \"2\", \"0.011363636363636364\"], [\"VFSFileChooserDialog\", \"4\", \"0.022727272727272728\"], [\"Word\", \"2\", \"0.011363636363636364\"], [\"Result\", \"2\", \"0.011363636363636364\"], [\"ModeOptionPane\", \"4\", \"0.022727272727272728\"], [\"HelpIndex\", \"3\", \"0.017045454545454544\"], [\"ModeProperties\", \"4\", \"0.022727272727272728\"], [\"HelpSearchPanel\", \"2\", \"0.011363636363636364\"], [\"ResultRenderer\", \"2\", \"0.011363636363636364\"], [\"BufferOptions\", \"4\", \"0.022727272727272728\"], [\"EditingOptionPane\", \"4\", \"0.022727272727272728\"], [\"KeyHandler\", \"3\", \"0.017045454545454544\"], [\"CompleteWord\", \"3\", \"0.017045454545454544\"], [\"CaretHandler\", \"1\", \"0.005681818181818182\"], [\"ResultVisitor\", \"1\", \"0.005681818181818182\"], [\"MouseWheelHandler\", \"6\", \"0.03409090909090909\"], [\"BufferLoadedVisitor\", \"1\", \"0.005681818181818182\"], [\"BufferClosedVisitor\", \"1\", \"0.005681818181818182\"], [\"Operation\", \"2\", \"0.011363636363636364\"], [\"Install\", \"4\", \"0.022727272727272728\"], [\"Plugin\", \"2\", \"0.011363636363636364\"], [\"PluginManagerProgress\", \"2\", \"0.011363636363636364\"], [\"Remove\", \"2\", \"0.011363636363636364\"], [\"Roster\", \"4\", \"0.022727272727272728\"], [\"SoftWrapTokenHandler\", \"2\", \"0.011363636363636364\"], [\"PluginResURLConnection\", \"2\", \"0.011363636363636364\"], [\"SettingsReloader\", \"2\", \"0.011363636363636364\"], [\"Autosave\", \"4\", \"0.022727272727272728\"], [\"BufferIORequest\", \"8\", \"0.045454545454545456\"], [\"BeanShell\", \"4\", \"0.022727272727272728\"], [\"DisplayTokenHandler\", \"6\", \"0.03409090909090909\"], [\"Log\", \"2\", \"0.011363636363636364\"], [\"GUIUtilities\", \"7\", \"0.03977272727272727\"], [\"LogViewer\", \"6\", \"0.03409090909090909\"], [\"ListHandler\", \"2\", \"0.011363636363636364\"], [\"LogListModel\", \"2\", \"0.011363636363636364\"], [\"Anchor\", \"4\", \"0.022727272727272728\"], [\"DisplayManager\", \"24\", \"0.13636363636363635\"], [\"ScrollLineCount\", \"8\", \"0.045454545454545456\"], [\"FirstLine\", \"20\", \"0.11363636363636363\"], [\"WrapGuide\", \"4\", \"0.022727272727272728\"], [\"DockableWindowManager\", \"9\", \"0.05113636363636364\"], [\"Entry\", \"6\", \"0.03409090909090909\"], [\"EnhancedCheckBoxMenuItem\", \"2\", \"0.011363636363636364\"], [\"FileCellRenderer\", \"2\", \"0.011363636363636364\"], [\"PaneNameRenderer\", \"2\", \"0.011363636363636364\"], [\"StatusBar\", \"5\", \"0.028409090909090908\"], [\"ParentDirectoryRenderer\", \"2\", \"0.011363636363636364\"], [\"RolloverButton\", \"4\", \"0.022727272727272728\"], [\"EditPlugin\", \"2\", \"0.011363636363636364\"], [\"EnhancedMenu\", \"2\", \"0.011363636363636364\"], [\"Debug\", \"6\", \"0.03409090909090909\"], [\"PaintLineBackground\", \"4\", \"0.022727272727272728\"], [\"ButtonLayout\", \"4\", \"0.022727272727272728\"], [\"VFSDirectoryEntryTable\", \"2\", \"0.011363636363636364\"], [\"VFSFileNameField\", \"4\", \"0.022727272727272728\"], [\"DockablePanel\", \"2\", \"0.011363636363636364\"], [\"DockableWindowCompare\", \"2\", \"0.011363636363636364\"], [\"RectParams\", \"2\", \"0.011363636363636364\"], [\"VMS\", \"2\", \"0.011363636363636364\"], [\"RingListModel\", \"2\", \"0.011363636363636364\"], [\"ActionTextField\", \"2\", \"0.011363636363636364\"], [\"ActionBar\", \"2\", \"0.011363636363636364\"], [\"PluginTableModel\", \"5\", \"0.028409090909090908\"], [\"InputPane\", \"3\", \"0.017045454545454544\"], [\"GrabKeyDialog\", \"2\", \"0.011363636363636364\"], [\"ButtonActionHandler\", \"2\", \"0.011363636363636364\"], [\"TextAreaTransferHandler\", \"8\", \"0.045454545454545456\"], [\"PosBottomHalf\", \"4\", \"0.022727272727272728\"], [\"PositionManager\", \"4\", \"0.022727272727272728\"], [\"PosTopHalf\", \"2\", \"0.011363636363636364\"], [\"RootsEntry\", \"2\", \"0.011363636363636364\"], [\"ActionSet\", \"2\", \"0.011363636363636364\"], [\"PluginJAR\", \"3\", \"0.017045454545454544\"], [\"DropHandler\", \"2\", \"0.011363636363636364\"], [\"SplashScreen\", \"2\", \"0.011363636363636364\"], [\"MiscUtilities\", \"5\", \"0.028409090909090908\"], [\"PerspectiveManager\", \"2\", \"0.011363636363636364\"], [\"DockableLayout\", \"2\", \"0.011363636363636364\"], [\"InstallPanel\", \"3\", \"0.017045454545454544\"], [\"LogList\", \"2\", \"0.011363636363636364\"], [\"MarkerHighlight\", \"2\", \"0.011363636363636364\"], [\"DockableListHandler\", \"2\", \"0.011363636363636364\"], [\"CheckBoxListModel\", \"2\", \"0.011363636363636364\"], [\"jEdit\", \"2\", \"0.011363636363636364\"], [\"ScrollLayout\", \"2\", \"0.011363636363636364\"], [\"TextAreaBorder\", \"2\", \"0.011363636363636364\"], [\"PaintWrapGuide\", \"4\", \"0.022727272727272728\"], [\"SelectionManager\", \"3\", \"0.017045454545454544\"], [\"Reset\", \"2\", \"0.011363636363636364\"], [\"RegexpIndentRule\", \"4\", \"0.022727272727272728\"], [\"OpenBracketIndentRule\", \"2\", \"0.011363636363636364\"], [\"IndentRuleFactory\", \"2\", \"0.011363636363636364\"], [\"Registers\", \"2\", \"0.011363636363636364\"], [\"RegisterViewer\", \"2\", \"0.011363636363636364\"], [\"Rect\", \"2\", \"0.011363636363636364\"], [\"JEditBuffer\", \"2\", \"0.011363636363636364\"], [\"AlignBracket\", \"2\", \"0.011363636363636364\"], [\"VFS\", \"2\", \"0.011363636363636364\"], [\"MacOSPlugin\", \"1\", \"0.005681818181818182\"], [\"Macros\", \"1\", \"0.005681818181818182\"], [\"BrowserColorsModel\", \"1\", \"0.005681818181818182\"]]"
        },
        {
            "content": "From the results of `get_co_change_relationship`, we can see that several entities have a significant co-change relationship with `JEditTextArea.java`. These are files that were frequently modified together with `JEditTextArea.java` in the past. Entities with higher confidence values are more likely to be impacted by or related to changes in `JEditTextArea.java`.\n\nLet's focus on some of the most significant ones:\n\n1. **ChunkCache (0.28977)** - This has the highest number of supports and confidence, indicating a strong relationship.\n2. **BufferChangeHandler (0.28409)** - Also very high confidence, suggesting it is closely related.\n3. **MouseHandler (0.26705)** - Another file with a relatively high correlation.\n4. **TextAreaPainter (0.22727)** - Strong historical correlation.\n5. **Gutter (0.14205), DisplayManager (0.13636), OffsetManager (0.13636)** - These also show moderate-to-high levels of co-change.\n\nThese entities should be carefully reviewed for synchronization with any changes made to `JEditTextArea.java`.\n\nTo proceed, I recommend examining one of these strongly correlated files further. Let\u2019s start by analyzing the coupling dependencies between `JEditTextArea.java` and `ChunkCache.java` using the `get_coupling_dependencies` function.\n\nCall:\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_b7ff0640e38540c0bb606c",
                    "function": {
                        "arguments": "{\"entity1\": \"JEditTextArea.java\", \"entity2\": \"ChunkCache.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"ConstructorInvoking(CMI): Construction Method Invoking found: new ChunkCache(this),  \", \"ConstructorInvoking(CMAIM): Coupling found in method setBuffer, at line: 268. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method setFirstLine.  Coupling found in method _setFirstLine, at line: 347. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method setFirstLine.  Coupling found in method scrollUpPage, at line: 500. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method scrollTo, at line: 629. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method scrollTo, at line: 630. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method scrollTo, at line: 634. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method scrollTo, at line: 643. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method scrollTo, at line: 647. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method scrollTo, at line: 684. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method scrollTo, at line: 709. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method scrollTo, at line: 719. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method scrollTo, at line: 725. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method setFirstLine.  Coupling found in method getPhysicalLineOfScreenLine, at line: 804. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method getScreenLineOfOffset, at line: 817. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getScreenLineOfOffset.  Coupling found in method getScreenLineStartOffset, at line: 828. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method updateChunksUpTo.  Coupling found in method getScreenLineStartOffset, at line: 829. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method getScreenLineEndOffset, at line: 845. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method updateChunksUpTo.  Coupling found in method getScreenLineEndOffset, at line: 846. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method xyToOffset, at line: 892. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method updateChunksUpTo.  Coupling found in method xyToOffset, at line: 894. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method offsetToXY, at line: 943. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getScreenLineOfOffset.  Coupling found in method offsetToXY, at line: 968. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method updateChunksUpTo.  Coupling found in method offsetToXY, at line: 969. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method invalidateScreenLineRange, at line: 992. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method needFullRepaint.  Coupling found in method invalidateLine, at line: 1030. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method updateChunksUpTo.  Coupling found in method invalidateLine, at line: 1031. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method invalidateLine, at line: 1047. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method needFullRepaint.  Coupling found in method invalidateLineRange, at line: 1084. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method updateChunksUpTo.  Coupling found in method invalidateLineRange, at line: 1085. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method invalidateLineRange, at line: 1104. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method needFullRepaint.  Coupling found in method moveCaretPosition, at line: 2133. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getScreenLineOfOffset.  Coupling found in method goToNextLine, at line: 2325. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method goToNextLine, at line: 2363. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method goToPrevLine, at line: 2642. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method goToPrevLine, at line: 2680. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method goToStartOfWhiteSpace, at line: 3004. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method goToEndOfWhiteSpace, at line: 3049. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method propertiesChanged, at line: 4711. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method invalidateAll.  Coupling found in method offsetToX, at line: 4728. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method lineToChunkList.  Coupling found in method xToOffset, at line: 4743. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method lineToChunkList.  Coupling found in method xToOffset, at line: 4763. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method lineToChunkList.  Coupling found in method updateMaxHorizontalScrollWidth, at line: 5015. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getMaxHorizontalScrollWidth.  Coupling found in method recalculateVisibleLines, at line: 5040. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method recalculateVisibleLines.  Coupling found in method foldStructureChanged, at line: 5047. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method invalidateAll.  Coupling found in method recalculateLastPhysicalLine, at line: 5588. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method updateChunksUpTo.  Coupling found in method recalculateLastPhysicalLine, at line: 5591. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method contentInserted, at line: 5899. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method invalidateChunksFromPhys.  Coupling found in method contentRemoved, at line: 5965. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method invalidateChunksFromPhys.  Coupling found in method transactionComplete, at line: 6066. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getScreenLineOfOffset.  Coupling found in method doSingleDrag, at line: 6410. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.\"]"
        },
        {
            "content": "The coupling dependencies between `JEditTextArea.java` and `ChunkCache.java` are extensive and primarily involve method invocations and data flow. The `JEditTextArea` frequently uses the `ChunkCache` object to invoke methods related to line information, chunk updates, scrolling behavior, and invalidation logic.\n\nThis indicates that changes in `JEditTextArea.java`\u2014especially those affecting how text is displayed or scrolled\u2014are likely to impact `ChunkCache.java`, which manages the visual layout of text chunks.\n\n### Key Observations:\n- **Constructor Invoking**: `JEditTextArea` creates an instance of `ChunkCache` (`new ChunkCache(this)`), indicating tight integration.\n- **Method Invocations**: There are numerous calls from `JEditTextArea` to methods in `ChunkCache`, especially related to:\n  - Line information (`getLineInfo`)\n  - Scrolling operations (`scrollTo`, `scrollUpPage`)\n  - Chunk management (`updateChunksUpTo`, `invalidateChunksFromPhys`)\n  - Screen-line mapping (`getScreenLineOfOffset`, `offsetToXY`)\n\nGiven this strong coupling, any change in `JEditTextArea.java` that affects screen rendering, caret movement, or buffer handling will likely require a synchronized update in `ChunkCache.java`.\n\nLet\u2019s now examine another highly co-changed file: **BufferChangeHandler**. We should check its conceptual coupling with `JEditTextArea.java` using `get_conceptual_coupling`, as it may not have direct method calls but could still be semantically linked.\n\nCall:\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_7b95276b6b8049a2af9561",
                    "function": {
                        "arguments": "{\"entity1\": \"JEditTextArea.java\", \"entity2\": \"BufferChangeHandler.java\"}",
                        "name": "get_conceptual_coupling"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_conceptual_coupling",
            "content": "[\"BufferChangeHandler has been removed from the project due to project version iteration\"]"
        },
        {
            "content": "It appears that `BufferChangeHandler.java` has been removed from the project due to version updates or refactoring. This means it is no longer present in the current codebase and does not need to be synchronized.\n\nGiven this, we should shift focus to another highly co-changed file: **MouseHandler.java**, which shows a high historical correlation (`confidence = 0.267`). Since `MouseHandler` likely handles user input events related to the text area, it may have conceptual or behavioral coupling with `JEditTextArea`.\n\nLet\u2019s analyze its conceptual coupling with `JEditTextArea.java`.\n\nCall:\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_22f20a20cc584fc1ab3801",
                    "function": {
                        "arguments": "{\"entity1\": \"JEditTextArea.java\", \"entity2\": \"MouseHandler.java\"}",
                        "name": "get_conceptual_coupling"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_conceptual_coupling",
            "content": "[\"MouseHandler has been removed from the project due to project version iteration\"]"
        },
        {
            "content": "Similar to `BufferChangeHandler.java`, it appears that `MouseHandler.java` has also been removed from the project due to version iteration or refactoring. Therefore, it no longer exists in the current codebase and does not require synchronization.\n\nLet\u2019s move forward by examining another co-changed file that is likely still relevant: **TextAreaPainter.java**, which had a confidence value of `0.22727`. Given its role in rendering the text area, it may have strong conceptual or coupling dependencies with `JEditTextArea.java`.\n\nWe will now check its conceptual coupling with `JEditTextArea.java`.\n\nCall:\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_ce3dda8da9b74dbe8f1667",
                    "function": {
                        "arguments": "{\"entity1\": \"JEditTextArea.java\", \"entity2\": \"TextAreaPainter.java\"}",
                        "name": "get_conceptual_coupling"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_conceptual_coupling",
            "content": "\"0.8567677\""
        },
        {
            "content": "The conceptual coupling between `JEditTextArea.java` and `TextAreaPainter.java` is quite high, with a similarity score of **0.8568** (85.68%). This indicates that these two entities are semantically closely related, likely sharing similar concepts, responsibilities, or thematic concerns\u2014especially around the rendering and visual behavior of the text area.\n\nGiven this strong conceptual link, changes in `JEditTextArea.java`, especially those involving display logic, layout, or visual interactions, may require synchronized updates in `TextAreaPainter.java`.\n\nTo further understand how they interact at the code level, let\u2019s examine if there are direct method calls or dependencies by retrieving the call graph for `JEditTextArea.java`.\n\nCall:\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_ecc57fe4975f486b8c8a30",
                    "function": {
                        "arguments": "{\"entity\": \"JEditTextArea.java\"}",
                        "name": "get_call_graph"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_call_graph",
            "content": "[\"\", \"Log\", \"\", \"\", \"\"]"
        },
        {
            "content": "The call graph for `JEditTextArea.java` appears to be incomplete or possibly returned an error, as it mostly contains empty strings and only one entry: `\"Log\"`.\n\nThis may indicate a parsing issue or that the function did not retrieve meaningful data. Since we cannot rely on this result, we should attempt to retrieve more specific information about how `TextAreaPainter.java` is used within `JEditTextArea.java`.\n\nTo do this, let\u2019s examine the source code of `JEditTextArea.java` to identify direct references or usages of `TextAreaPainter.java`.\n\nCall:\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_dbace1441a7449519fb8e4",
                    "function": {
                        "arguments": "{\"entity\": \"JEditTextArea.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package org.gjt.sp.jedit.textarea;\\nimport java.awt.*;\\nimport java.awt.event.*;\\nimport java.awt.font.*;\\nimport java.awt.geom.*;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Enumeration;\\nimport java.util.Hashtable;\\nimport java.util.Vector;\\nimport javax.swing.*;\\nimport javax.swing.border.*;\\nimport javax.swing.event.*;\\nimport javax.swing.plaf.metal.MetalLookAndFeel;\\nimport javax.swing.text.Position;\\nimport javax.swing.text.Segment;\\nimport javax.swing.undo.*;\\nimport org.gjt.sp.jedit.*;\\nimport org.gjt.sp.jedit.buffer.*;\\nimport org.gjt.sp.jedit.gui.*;\\nimport org.gjt.sp.jedit.syntax.*;\\nimport org.gjt.sp.util.Log;\\npublic class JEditTextArea extends JComponent\\n{\\n\\tpublic JEditTextArea(View view)\\n\\t{\\n\\t\\tenableEvents(AWTEvent.FOCUS_EVENT_MASK | AWTEvent.KEY_EVENT_MASK);\\n\\t\\tthis.view = view;\\n\\t\\t\\t\\tselection = new Vector();\\n\\t\\tchunkCache = new ChunkCache(this);\\n\\t\\tpainter = new TextAreaPainter(this);\\n\\t\\tgutter = new Gutter(view,this);\\n\\t\\tbufferHandler = new BufferChangeHandler();\\n\\t\\tlistenerList = new EventListenerList();\\n\\t\\tcaretEvent = new MutableCaretEvent();\\n\\t\\tbracketLine = bracketPosition = -1;\\n\\t\\tblink = true;\\n\\t\\tlineSegment = new Segment();\\n\\t\\treturnValue = new Point();\\n\\t\\trunnables = new ArrayList();\\n\\t\\t\\t\\tsetLayout(new ScrollLayout());\\n\\t\\tadd(LEFT,gutter);\\n\\t\\tadd(CENTER,painter);\\n\\t\\tadd(RIGHT,vertical = new JScrollBar(JScrollBar.VERTICAL));\\n\\t\\tadd(BOTTOM,horizontal = new JScrollBar(JScrollBar.HORIZONTAL));\\n\\t\\thorizontal.setValues(0,0,0,0);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(UIManager.getLookAndFeel() instanceof MetalLookAndFeel)\\n\\t\\t{\\n\\t\\t\\tsetBorder(new TextAreaBorder());\\n\\t\\t\\tvertical.putClientProperty(\\\"JScrollBar.isFreeStanding\\\",\\n\\t\\t\\t\\tBoolean.FALSE);\\n\\t\\t\\thorizontal.putClientProperty(\\\"JScrollBar.isFreeStanding\\\",\\n\\t\\t\\t\\tBoolean.FALSE);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\tvertical.addAdjustmentListener(new AdjustHandler());\\n\\t\\thorizontal.addAdjustmentListener(new AdjustHandler());\\n\\t\\tmouseHandler = new MouseHandler();\\n\\t\\tpainter.addMouseListener(mouseHandler);\\n\\t\\tpainter.addMouseMotionListener(mouseHandler);\\n\\t\\taddFocusListener(new FocusHandler());\\n\\t\\t\\t\\t\\t\\t\\t\\tfocusedComponent = this;\\n\\t} \\n\\tpublic final TextAreaPainter getPainter()\\n\\t{\\n\\t\\treturn painter;\\n\\t} \\n\\tpublic final Gutter getGutter()\\n\\t{\\n\\t\\treturn gutter;\\n\\t} \\n\\tpublic FoldVisibilityManager getFoldVisibilityManager()\\n\\t{\\n\\t\\treturn foldVisibilityManager;\\n\\t} \\n\\tpublic final boolean isCaretBlinkEnabled()\\n\\t{\\n\\t\\treturn caretBlinks;\\n\\t} \\n\\tpublic void setCaretBlinkEnabled(boolean caretBlinks)\\n\\t{\\n\\t\\tthis.caretBlinks = caretBlinks;\\n\\t\\tif(!caretBlinks)\\n\\t\\t\\tblink = false;\\n\\t\\tif(buffer != null)\\n\\t\\t\\tinvalidateLine(caretLine);\\n\\t} \\n\\tpublic final int getElectricScroll()\\n\\t{\\n\\t\\treturn electricScroll;\\n\\t} \\n\\tpublic final void setElectricScroll(int electricScroll)\\n\\t{\\n\\t\\tthis.electricScroll = electricScroll;\\n\\t} \\n\\tpublic final boolean isQuickCopyEnabled()\\n\\t{\\n\\t\\treturn quickCopy;\\n\\t} \\n\\tpublic final void setQuickCopyEnabled(boolean quickCopy)\\n\\t{\\n\\t\\tthis.quickCopy = quickCopy;\\n\\t} \\n\\tpublic final Buffer getBuffer()\\n\\t{\\n\\t\\treturn buffer;\\n\\t} \\n\\tpublic void setBuffer(Buffer buffer)\\n\\t{\\n\\t\\tif(this.buffer == buffer)\\n\\t\\t\\treturn;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbufferChanging = true;\\n\\t\\t\\tif(this.buffer != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFirstLine(0);\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\t\\tcaretLine = caret = caretScreenLine = 0;\\n\\t\\t\\t\\tbracketLine = bracketPosition = -1;\\n\\t\\t\\t\\tthis.buffer._releaseFoldVisibilityManager(foldVisibilityManager);\\n\\t\\t\\t\\tthis.buffer.removeBufferChangeListener(bufferHandler);\\n\\t\\t\\t}\\n\\t\\t\\tthis.buffer = buffer;\\n\\t\\t\\tbuffer.addBufferChangeListener(bufferHandler);\\n\\t\\t\\tbufferHandlerInstalled = true;\\n\\t\\t\\tfoldVisibilityManager = buffer._getFoldVisibilityManager(this);\\n\\t\\t\\tphysFirstLine = foldVisibilityManager.getFirstVisibleLine();\\n\\t\\t\\tchunkCache.setFirstLine(0,physFirstLine);\\n\\t\\t\\tpropertiesChanged();\\n\\t\\t\\trecalculateLastPhysicalLine();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbufferChanging = false;\\n\\t\\t}\\n\\t} \\n\\tpublic final boolean isEditable()\\n\\t{\\n\\t\\treturn buffer.isEditable();\\n\\t} \\n\\tpublic final JPopupMenu getRightClickPopup()\\n\\t{\\n\\t\\treturn popup;\\n\\t} \\n\\tpublic final void setRightClickPopup(JPopupMenu popup)\\n\\t{\\n\\t\\tthis.popup = popup;\\n\\t} \\n\\tpublic final int getFirstLine()\\n\\t{\\n\\t\\treturn firstLine;\\n\\t} \\n\\tpublic void setFirstLine(int firstLine)\\n\\t{\\n\\t\\tif(firstLine == this.firstLine)\\n\\t\\t\\treturn;\\n\\t\\t_setFirstLine(firstLine);\\n\\t\\tview.synchroScrollVertical(this,firstLine);\\n\\t} \\n\\t\\tpublic void _setFirstLine(int firstLine)\\n\\t{\\n\\t\\tfirstLine = Math.max(0,Math.min(getVirtualLineCount() - 1,firstLine));\\n\\t\\tthis.firstLine = firstLine;\\n\\t\\tphysFirstLine = virtualToPhysical(firstLine);\\n\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\tchunkCache.setFirstLine(firstLine,physFirstLine);\\n\\t\\trecalculateLastPhysicalLine();\\n\\t\\tif(this.firstLine != vertical.getValue())\\n\\t\\t\\tupdateScrollBars();\\n\\t\\tpainter.repaint();\\n\\t\\tgutter.repaint();\\n\\t\\tfireScrollEvent(true);\\n\\t} \\n\\tpublic final int getVisibleLines()\\n\\t{\\n\\t\\treturn visibleLines;\\n\\t} \\n\\tpublic final int getFirstPhysicalLine()\\n\\t{\\n\\t\\treturn physFirstLine;\\n\\t} \\n\\tpublic final int getLastPhysicalLine()\\n\\t{\\n\\t\\treturn physLastLine;\\n\\t} \\n\\tpublic final int getHorizontalOffset()\\n\\t{\\n\\t\\treturn horizontalOffset;\\n\\t} \\n\\tpublic void setHorizontalOffset(int horizontalOffset)\\n\\t{\\n\\t\\tif(horizontalOffset == this.horizontalOffset)\\n\\t\\t\\treturn;\\n\\t\\t_setHorizontalOffset(horizontalOffset);\\n\\t\\tview.synchroScrollHorizontal(this,horizontalOffset);\\n\\t} \\n\\t\\tpublic void _setHorizontalOffset(int horizontalOffset)\\n\\t{\\n\\t\\tthis.horizontalOffset = horizontalOffset;\\n\\t\\tif(horizontalOffset != horizontal.getValue())\\n\\t\\t\\tupdateScrollBars();\\n\\t\\tpainter.repaint();\\n\\t\\tfireScrollEvent(false);\\n\\t} \\n\\tpublic void updateScrollBars()\\n\\t{\\n\\t\\tif(vertical != null && visibleLines != 0)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tint lineCount = getVirtualLineCount();\\n\\t\\t\\t\\t\\t\\tif(softWrap)\\n\\t\\t\\t\\tlineCount += visibleLines - 1;\\n\\t\\t\\tif(lineCount < firstLine + visibleLines)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tint newFirstLine = Math.max(0,lineCount - visibleLines);\\n\\t\\t\\t\\tif(newFirstLine != firstLine)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsetFirstLine(newFirstLine);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tvertical.setValues(firstLine,visibleLines,0,lineCount);\\n\\t\\t\\tvertical.setUnitIncrement(2);\\n\\t\\t\\tvertical.setBlockIncrement(visibleLines);\\n\\t\\t}\\n\\t\\tint width = painter.getWidth();\\n\\t\\tif(horizontal != null && width != 0)\\n\\t\\t{\\n\\t\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\t\\tpainter.repaint();\\n\\t\\t\\thorizontal.setUnitIncrement(painter.getFontMetrics()\\n\\t\\t\\t\\t.charWidth('w'));\\n\\t\\t\\thorizontal.setBlockIncrement(width / 2);\\n\\t\\t}\\n\\t} \\n\\tpublic void scrollUpLine()\\n\\t{\\n\\t\\tif(firstLine > 0)\\n\\t\\t\\tsetFirstLine(firstLine - 1);\\n\\t\\telse\\n\\t\\t\\tgetToolkit().beep();\\n\\t} \\n\\tpublic void scrollUpPage()\\n\\t{\\n\\t\\tif(firstLine > 0)\\n\\t\\t{\\n\\t\\t\\tint newFirstLine;\\n\\t\\t\\tif(softWrap)\\n\\t\\t\\t{\\n\\t\\t\\t\\tnewFirstLine = firstLine;\\n\\t\\t\\t\\tint screenLineCount = 0;\\n\\t\\t\\t\\twhile(--newFirstLine >= 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint lines = chunkCache\\n\\t\\t\\t\\t\\t\\t.getLineInfosForPhysicalLine(\\n\\t\\t\\t\\t\\t\\tnewFirstLine).length;\\n\\t\\t\\t\\t\\tif(screenLineCount + lines >= visibleLines)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tscreenLineCount += lines;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tnewFirstLine = firstLine - visibleLines;\\n\\t\\t\\t}\\n\\t\\t\\tsetFirstLine(newFirstLine);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t}\\n\\t} \\n\\tpublic void scrollDownLine()\\n\\t{\\n\\t\\tint numLines = getVirtualLineCount();\\n\\t\\tif((softWrap && firstLine + 1 < numLines) ||\\n\\t\\t\\t(firstLine + visibleLines < numLines))\\n\\t\\t\\tsetFirstLine(firstLine + 1);\\n\\t\\telse\\n\\t\\t\\tgetToolkit().beep();\\n\\t} \\n\\tpublic void scrollDownPage()\\n\\t{\\n\\t\\tint numLines = getVirtualLineCount();\\n\\t\\tif((softWrap && firstLine + 1 < numLines) ||\\n\\t\\t\\t(firstLine + visibleLines < numLines))\\n\\t\\t{\\n\\t\\t\\tsetFirstLine(physicalToVirtual(physLastLine));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tgetToolkit().beep();\\n\\t} \\n\\tpublic void scrollToCaret(boolean doElectricScroll)\\n\\t{\\n\\t\\tscrollTo(caretLine,caret - buffer.getLineStartOffset(caretLine),\\n\\t\\t\\tdoElectricScroll);\\n\\t} \\n\\tpublic void scrollTo(int line, int offset, boolean doElectricScroll)\\n\\t{\\n\\t\\tint extraEndVirt;\\n\\t\\tint lineLength = buffer.getLineLength(line);\\n\\t\\tif(offset > lineLength)\\n\\t\\t{\\n\\t\\t\\textraEndVirt = charWidth * (offset - lineLength);\\n\\t\\t\\toffset = lineLength;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\textraEndVirt = 0;\\n\\t\\tint _electricScroll = (doElectricScroll\\n\\t\\t\\t&& visibleLines > electricScroll * 2\\n\\t\\t\\t? electricScroll : 0);\\n\\t\\t\\t\\t\\t\\t\\t\\tif(visibleLines == 0)\\n\\t\\t{\\n\\t\\t\\tsetFirstLine(physicalToVirtual(\\n\\t\\t\\t\\tMath.max(0,line - _electricScroll)));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\t\\tint screenLine = getScreenLineOfOffset(buffer.getLineStartOffset(line) + offset);\\n\\t\\tPoint point;\\n\\t\\tif(screenLine != -1)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tint height = painter.getFontMetrics().getHeight();\\n\\t\\t\\tint y1 = (firstLine == 0 ? 0 : height * _electricScroll);\\n\\t\\t\\tint y2 = (visibleLines + firstLine == getVirtualLineCount()\\n\\t\\t\\t\\t? 0 : height * _electricScroll);\\n\\t\\t\\tRectangle rect = new Rectangle(0,y1,\\n\\t\\t\\t\\tpainter.getWidth() - 5,visibleLines * height\\n\\t\\t\\t\\t- y1 - y2);\\n\\t\\t\\tpoint = offsetToXY(line,offset,returnValue);\\n\\t\\t\\tpoint.x += extraEndVirt;\\n\\t\\t\\tif(rect.contains(point))\\n\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tpoint = null;\\n\\t\\t\\t\\tif(line == physLastLine + 1)\\n\\t\\t{\\n\\t\\t\\tint count = chunkCache.getLineInfosForPhysicalLine(physLastLine).length\\n\\t\\t\\t\\t+ chunkCache.getLineInfosForPhysicalLine(physLastLine + 1).length\\n\\t\\t\\t\\t+ _electricScroll;\\n\\t\\t\\twhile(count > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount -= chunkCache.getLineInfosForPhysicalLine(physFirstLine).length;\\n\\t\\t\\t\\tfirstLine++;\\n\\t\\t\\t\\tphysFirstLine = foldVisibilityManager.getNextVisibleLine(physFirstLine);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(screenLine == -1)\\n\\t\\t{\\n\\t\\t\\tif(line == physLastLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint count = chunkCache.getLineInfosForPhysicalLine(physLastLine).length\\n\\t\\t\\t\\t\\t+ _electricScroll;\\n\\t\\t\\t\\twhile(count > 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount -= chunkCache.getLineInfosForPhysicalLine(physFirstLine).length;\\n\\t\\t\\t\\t\\tfirstLine++;\\n\\t\\t\\t\\t\\tint nextLine = foldVisibilityManager.getNextVisibleLine(physFirstLine);\\n\\t\\t\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tphysFirstLine = nextLine;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint virtualLine = foldVisibilityManager.physicalToVirtual(line);\\n\\t\\t\\tif(virtualLine == firstLine - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine = Math.max(0,firstLine - _electricScroll - 1);\\n\\t\\t\\t\\tphysFirstLine = foldVisibilityManager.virtualToPhysical(firstLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tif(!softWrap && virtualLine >= foldVisibilityManager.getVirtualLineCount()\\n\\t\\t\\t\\t\\t- visibleLines / 2)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfirstLine = foldVisibilityManager.getVirtualLineCount()\\n\\t\\t\\t\\t\\t\\t- visibleLines;\\n\\t\\t\\t\\t\\tphysFirstLine = foldVisibilityManager\\n\\t\\t\\t\\t\\t\\t.virtualToPhysical(firstLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysFirstLine = line;\\n\\t\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\t\\tfor(;;)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(foldVisibilityManager.isLineVisible(physFirstLine))\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tint incr = chunkCache.getLineInfosForPhysicalLine(physFirstLine).length;\\n\\t\\t\\t\\t\\t\\t\\tif(count + incr > visibleLines / 2)\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tcount += incr;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(physFirstLine == 0)\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tphysFirstLine = foldVisibilityManager\\n\\t\\t\\t\\t\\t\\t\\t\\t.getPrevVisibleLine(physFirstLine);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfirstLine = physicalToVirtual(physFirstLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(screenLine < _electricScroll && firstLine != 0)\\n\\t\\t{\\n\\t\\t\\tint count = _electricScroll - screenLine;\\n\\t\\t\\twhile(count > 0 && firstLine > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount -= chunkCache.getLineInfosForPhysicalLine(physFirstLine).length;\\n\\t\\t\\t\\tfirstLine--;\\n\\t\\t\\t\\tphysFirstLine = foldVisibilityManager.getPrevVisibleLine(physFirstLine);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(screenLine >= visibleLines - _electricScroll)\\n\\t\\t{\\n\\t\\t\\tint count = _electricScroll - visibleLines + screenLine + 1;\\n\\t\\t\\twhile(count > 0 && firstLine <= getVirtualLineCount())\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount -= chunkCache.getLineInfosForPhysicalLine(physFirstLine).length;\\n\\t\\t\\t\\tfirstLine++;\\n\\t\\t\\t\\tphysFirstLine = foldVisibilityManager.getNextVisibleLine(physFirstLine);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tchunkCache.setFirstLine(firstLine,physFirstLine);\\n\\t\\trecalculateLastPhysicalLine();\\n\\t\\tif(point == null)\\n\\t\\t{\\n\\t\\t\\tpoint = offsetToXY(line,offset,returnValue);\\n\\t\\t\\tif(point == null)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tpoint.x += extraEndVirt;\\n\\t\\t} \\n\\t\\t\\t\\tif(point.x < 0)\\n\\t\\t{\\n\\t\\t\\thorizontalOffset = Math.min(0,horizontalOffset\\n\\t\\t\\t\\t- point.x + charWidth + 5);\\n\\t\\t}\\n\\t\\telse if(point.x >= painter.getWidth() - charWidth - 5)\\n\\t\\t{\\n\\t\\t\\thorizontalOffset = horizontalOffset +\\n\\t\\t\\t\\t(painter.getWidth() - point.x)\\n\\t\\t\\t\\t- charWidth - 5;\\n\\t\\t} \\n\\t\\t\\t\\tupdateScrollBars();\\n\\t\\tpainter.repaint();\\n\\t\\tgutter.repaint();\\n\\t\\tview.synchroScrollVertical(this,firstLine);\\n\\t\\tview.synchroScrollHorizontal(this,horizontalOffset);\\n\\t\\t\\t\\tfireScrollEvent(true);\\n\\t\\tfireScrollEvent(false);\\n\\t\\t\\t} \\n\\tpublic final void addScrollListener(ScrollListener listener)\\n\\t{\\n\\t\\tlistenerList.add(ScrollListener.class,listener);\\n\\t} \\n\\tpublic final void removeScrollListener(ScrollListener listener)\\n\\t{\\n\\t\\tlistenerList.remove(ScrollListener.class,listener);\\n\\t} \\n\\tpublic int getPhysicalLineOfScreenLine(int screenLine)\\n\\t{\\n\\t\\treturn chunkCache.getLineInfo(screenLine).physicalLine;\\n\\t} \\n\\tpublic int getScreenLineOfOffset(int offset)\\n\\t{\\n\\t\\tint line = buffer.getLineOfOffset(offset);\\n\\t\\toffset -= buffer.getLineStartOffset(line);\\n\\t\\treturn chunkCache.getScreenLineOfOffset(line,offset);\\n\\t} \\n\\tpublic int getScreenLineStartOffset(int line)\\n\\t{\\n\\t\\tchunkCache.updateChunksUpTo(line);\\n\\t\\tChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);\\n\\t\\tif(lineInfo.physicalLine == -1)\\n\\t\\t\\treturn -1;\\n\\t\\treturn buffer.getLineStartOffset(lineInfo.physicalLine)\\n\\t\\t\\t+ lineInfo.offset;\\n\\t} \\n\\tpublic int getScreenLineEndOffset(int line)\\n\\t{\\n\\t\\tchunkCache.updateChunksUpTo(line);\\n\\t\\tChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);\\n\\t\\tif(lineInfo.physicalLine == -1)\\n\\t\\t\\treturn -1;\\n\\t\\treturn buffer.getLineStartOffset(lineInfo.physicalLine)\\n\\t\\t\\t+ lineInfo.offset + lineInfo.length;\\n\\t} \\n\\tpublic int xyToOffset(int x, int y)\\n\\t{\\n\\t\\treturn xyToOffset(x,y,true);\\n\\t} \\n\\tpublic int xyToOffset(int x, int y, boolean round)\\n\\t{\\n\\t\\tFontMetrics fm = painter.getFontMetrics();\\n\\t\\tint height = fm.getHeight();\\n\\t\\tint line = y / height;\\n\\t\\tif(line < 0 || line > visibleLines)\\n\\t\\t\\treturn -1;\\n\\t\\tchunkCache.updateChunksUpTo(line);\\n\\t\\tChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);\\n\\t\\tif(!lineInfo.chunksValid)\\n\\t\\t\\tSystem.err.println(\\\"xy to offset: not valid\\\");\\n\\t\\tif(lineInfo.physicalLine == -1)\\n\\t\\t{\\n\\t\\t\\treturn getLineEndOffset(foldVisibilityManager\\n\\t\\t\\t\\t.getLastVisibleLine()) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint offset = Chunk.xToOffset(lineInfo.chunks,\\n\\t\\t\\t\\tx - horizontalOffset,round);\\n\\t\\t\\tif(offset == -1 || offset == lineInfo.offset + lineInfo.length)\\n\\t\\t\\t\\toffset = lineInfo.offset + lineInfo.length - 1;\\n\\t\\t\\treturn getLineStartOffset(lineInfo.physicalLine) + offset;\\n\\t\\t}\\n\\t} \\n\\tpublic Point offsetToXY(int offset)\\n\\t{\\n\\t\\tint line = buffer.getLineOfOffset(offset);\\n\\t\\toffset -= buffer.getLineStartOffset(line);\\n\\t\\tPoint retVal = new Point();\\n\\t\\treturn offsetToXY(line,offset,retVal);\\n\\t} \\n\\tpublic Point offsetToXY(int line, int offset, Point retVal)\\n\\t{\\n\\t\\tint screenLine = chunkCache.getScreenLineOfOffset(line,offset);\\n\\t\\tif(screenLine == -1)\\n\\t\\t{\\n\\t\\t\\tif(line < physFirstLine)\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\telse if(line >= physLastLine)\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tthrow new InternalError(\\\"line=\\\" + line\\n\\t\\t\\t\\t\\t+ \\\",offset=\\\" + offset\\n\\t\\t\\t\\t\\t+ \\\",screenLine=\\\" + screenLine\\n\\t\\t\\t\\t\\t+ \\\",physFirstLine=\\\" + physFirstLine\\n\\t\\t\\t\\t\\t+ \\\",physLastLine=\\\" + physLastLine);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tFontMetrics fm = painter.getFontMetrics();\\n\\t\\tretVal.y = screenLine * fm.getHeight();\\n\\t\\tchunkCache.updateChunksUpTo(screenLine);\\n\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(screenLine);\\n\\t\\tif(!info.chunksValid)\\n\\t\\t\\tSystem.err.println(\\\"offset to xy: not valid\\\");\\n\\t\\tretVal.x = (int)(horizontalOffset + Chunk.offsetToX(\\n\\t\\t\\tinfo.chunks,offset));\\n\\t\\treturn retVal;\\n\\t} \\n\\tpublic void invalidateScreenLineRange(int start, int end)\\n\\t{\\n\\t\\tif(chunkCache.needFullRepaint())\\n\\t\\t{\\n\\t\\t\\trecalculateLastPhysicalLine();\\n\\t\\t\\tgutter.repaint();\\n\\t\\t\\tpainter.repaint();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(start > end)\\n\\t\\t{\\n\\t\\t\\tint tmp = end;\\n\\t\\t\\tend = start;\\n\\t\\t\\tstart = tmp;\\n\\t\\t}\\n\\t\\tFontMetrics fm = painter.getFontMetrics();\\n\\t\\tint y = start * fm.getHeight();\\n\\t\\tint height = (end - start + 1) * fm.getHeight();\\n\\t\\tpainter.repaint(0,y,painter.getWidth(),height);\\n\\t\\tgutter.repaint(0,y,gutter.getWidth(),height);\\n\\t} \\n\\tpublic void invalidateLine(int line)\\n\\t{\\n\\t\\tif(line < physFirstLine || line > physLastLine\\n\\t\\t\\t|| !foldVisibilityManager.isLineVisible(line))\\n\\t\\t\\treturn;\\n\\t\\tint startLine = -1;\\n\\t\\tint endLine = -1;\\n\\t\\tfor(int i = 0; i <= visibleLines; i++)\\n\\t\\t{\\n\\t\\t\\tchunkCache.updateChunksUpTo(i);\\n\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(i);\\n\\t\\t\\tif((info.physicalLine >= line || info.physicalLine == -1)\\n\\t\\t\\t\\t&& startLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstartLine = i;\\n\\t\\t\\t}\\n\\t\\t\\tif((info.physicalLine >= line && info.lastSubregion)\\n\\t\\t\\t\\t|| info.physicalLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tendLine = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(chunkCache.needFullRepaint())\\n\\t\\t{\\n\\t\\t\\trecalculateLastPhysicalLine();\\n\\t\\t\\tendLine = visibleLines;\\n\\t\\t}\\n\\t\\telse if(endLine == -1)\\n\\t\\t\\tendLine = visibleLines;\\n\\t\\tinvalidateScreenLineRange(startLine,endLine);\\n\\t} \\n\\tpublic void invalidateLineRange(int start, int end)\\n\\t{\\n\\t\\tif(end < start)\\n\\t\\t{\\n\\t\\t\\tint tmp = end;\\n\\t\\t\\tend = start;\\n\\t\\t\\tstart = tmp;\\n\\t\\t}\\n\\t\\tif(end < physFirstLine || start > physLastLine)\\n\\t\\t\\treturn;\\n\\t\\tint startScreenLine = -1;\\n\\t\\tint endScreenLine = -1;\\n\\t\\tfor(int i = 0; i <= visibleLines; i++)\\n\\t\\t{\\n\\t\\t\\tchunkCache.updateChunksUpTo(i);\\n\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(i);\\n\\t\\t\\tif((info.physicalLine >= start || info.physicalLine == -1)\\n\\t\\t\\t\\t&& startScreenLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstartScreenLine = i;\\n\\t\\t\\t}\\n\\t\\t\\tif((info.physicalLine >= end && info.lastSubregion)\\n\\t\\t\\t\\t|| info.physicalLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tendScreenLine = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(startScreenLine == -1)\\n\\t\\t\\tstartScreenLine = 0;\\n\\t\\tif(chunkCache.needFullRepaint())\\n\\t\\t{\\n\\t\\t\\trecalculateLastPhysicalLine();\\n\\t\\t\\tendScreenLine = visibleLines;\\n\\t\\t}\\n\\t\\telse if(endScreenLine == -1)\\n\\t\\t\\tendScreenLine = visibleLines;\\n\\t\\tinvalidateScreenLineRange(startScreenLine,endScreenLine);\\n\\t} \\n\\tpublic void invalidateSelectedLines()\\n\\t{\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tinvalidateLineRange(s.startLine,s.endLine);\\n\\t\\t}\\n\\t} \\n\\tpublic int physicalToVirtual(int line)\\n\\t{\\n\\t\\treturn foldVisibilityManager.physicalToVirtual(line);\\n\\t} \\n\\tpublic int virtualToPhysical(int line)\\n\\t{\\n\\t\\treturn foldVisibilityManager.virtualToPhysical(line);\\n\\t} \\n\\tpublic final int getBufferLength()\\n\\t{\\n\\t\\treturn buffer.getLength();\\n\\t} \\n\\tpublic final int getLineCount()\\n\\t{\\n\\t\\treturn buffer.getLineCount();\\n\\t} \\n\\tpublic final int getVirtualLineCount()\\n\\t{\\n\\t\\treturn foldVisibilityManager.getVirtualLineCount();\\n\\t} \\n\\tpublic final int getLineOfOffset(int offset)\\n\\t{\\n\\t\\treturn buffer.getLineOfOffset(offset);\\n\\t} \\n\\tpublic int getLineStartOffset(int line)\\n\\t{\\n\\t\\treturn buffer.getLineStartOffset(line);\\n\\t} \\n\\tpublic int getLineEndOffset(int line)\\n\\t{\\n\\t\\treturn buffer.getLineEndOffset(line);\\n\\t} \\n\\tpublic int getLineLength(int line)\\n\\t{\\n\\t\\treturn buffer.getLineLength(line);\\n\\t} \\n\\tpublic final String getText(int start, int len)\\n\\t{\\n\\t\\treturn buffer.getText(start,len);\\n\\t} \\n\\tpublic final void getText(int start, int len, Segment segment)\\n\\t{\\n\\t\\tbuffer.getText(start,len,segment);\\n\\t} \\n\\tpublic final String getLineText(int lineIndex)\\n\\t{\\n\\t\\treturn buffer.getLineText(lineIndex);\\n\\t} \\n\\tpublic final void getLineText(int lineIndex, Segment segment)\\n\\t{\\n\\t\\tbuffer.getLineText(lineIndex,segment);\\n\\t} \\n\\tpublic String getText()\\n\\t{\\n\\t\\treturn buffer.getText(0,buffer.getLength());\\n\\t} \\n\\tpublic void setText(String text)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tbuffer.remove(0,buffer.getLength());\\n\\t\\t\\tbuffer.insert(0,text);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic final void selectAll()\\n\\t{\\n\\t\\tsetSelection(new Selection.Range(0,buffer.getLength()));\\n\\t\\tmoveCaretPosition(buffer.getLength(),true);\\n\\t} \\n\\tpublic void selectLine()\\n\\t{\\n\\t\\tint caretLine = getCaretLine();\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine) - 1;\\n\\t\\tSelection s = new Selection.Range(start,end);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(end);\\n\\t} \\n\\tpublic void selectParagraph()\\n\\t{\\n\\t\\tint caretLine = getCaretLine();\\n\\t\\tif(getLineLength(caretLine) == 0)\\n\\t\\t{\\n\\t\\t\\tview.getToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint start = caretLine;\\n\\t\\tint end = caretLine;\\n\\t\\twhile(start >= 0)\\n\\t\\t{\\n\\t\\t\\tif(getLineLength(start) == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\telse\\n\\t\\t\\t\\tstart--;\\n\\t\\t}\\n\\t\\twhile(end < getLineCount())\\n\\t\\t{\\n\\t\\t\\tif(getLineLength(end) == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\telse\\n\\t\\t\\t\\tend++;\\n\\t\\t}\\n\\t\\tint selectionStart = getLineStartOffset(start + 1);\\n\\t\\tint selectionEnd = getLineEndOffset(end - 1) - 1;\\n\\t\\tSelection s = new Selection.Range(selectionStart,selectionEnd);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(selectionEnd);\\n\\t} \\n\\tpublic void selectWord()\\n\\t{\\n\\t\\tint line = getCaretLine();\\n\\t\\tint lineStart = getLineStartOffset(line);\\n\\t\\tint offset = getCaretPosition() - lineStart;\\n\\t\\tif(getLineLength(line) == 0)\\n\\t\\t\\treturn;\\n\\t\\tString lineText = getLineText(line);\\n\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\tif(offset == getLineLength(line))\\n\\t\\t\\toffset--;\\n\\t\\tint wordStart = TextUtilities.findWordStart(lineText,offset,noWordSep);\\n\\t\\tint wordEnd = TextUtilities.findWordEnd(lineText,offset+1,noWordSep);\\n\\t\\tSelection s = new Selection.Range(lineStart + wordStart,\\n\\t\\t\\tlineStart + wordEnd);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(lineStart + wordEnd);\\n\\t} \\n\\tpublic boolean selectToMatchingBracket(int position)\\n\\t{\\n\\t\\tint positionLine = buffer.getLineOfOffset(position);\\n\\t\\tint lineOffset = position - buffer.getLineStartOffset(positionLine);\\n\\t\\tint bracket = TextUtilities.findMatchingBracket(buffer,positionLine,lineOffset);\\n\\t\\tif(bracket != -1)\\n\\t\\t{\\n\\t\\t\\tSelection s;\\n\\t\\t\\tif(bracket < position)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmoveCaretPosition(position,false);\\n\\t\\t\\t\\ts = new Selection.Range(++bracket,position);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tmoveCaretPosition(position + 1,false);\\n\\t\\t\\t\\ts = new Selection.Range(position + 1,bracket);\\n\\t\\t\\t}\\n\\t\\t\\tif(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\taddToSelection(s);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t} \\n\\tpublic void selectToMatchingBracket()\\n\\t{\\n\\t\\t\\t\\tint caret = this.caret;\\n\\t\\tint offset = caret - buffer.getLineStartOffset(caretLine);\\n\\t\\tif(buffer.getLineLength(caretLine) == 0)\\n\\t\\t\\treturn;\\n\\t\\tif(offset == buffer.getLineLength(caretLine))\\n\\t\\t\\tcaret--;\\n\\t\\tselectToMatchingBracket(caret);\\n\\t} \\n\\tpublic void selectBlock()\\n\\t{\\n\\t\\tString openBrackets = \\\"([{\\\";\\n\\t\\tString closeBrackets = \\\")]}\\\";\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint start, end;\\n\\t\\tif(s == null)\\n\\t\\t\\tstart = end = caret;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstart = s.start;\\n\\t\\t\\tend = s.end;\\n\\t\\t}\\n\\t\\tString text = getText(0,buffer.getLength());\\n\\t\\t\\t\\tint count = 1;\\n\\t\\tchar openBracket = '\\\\0';\\n\\t\\tchar closeBracket = '\\\\0';\\n\\t\\t\\t\\tif(start == 0)\\n\\t\\t{\\n\\t\\t\\tview.getToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\nbackward_scan:\\twhile(--start > 0)\\n\\t\\t{\\n\\t\\t\\tchar c = text.charAt(start);\\n\\t\\t\\tint index = openBrackets.indexOf(c);\\n\\t\\t\\tif(index != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(--count == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\topenBracket = c;\\n\\t\\t\\t\\t\\tcloseBracket = closeBrackets.charAt(index);\\n\\t\\t\\t\\t\\tbreak backward_scan;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(closeBrackets.indexOf(c) != -1)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\t\\t\\tcount = 1;\\n\\t\\t\\t\\tif(openBracket == '\\\\0')\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\nforward_scan:\\t\\tdo\\n\\t\\t\\t{\\n\\t\\t\\t\\tchar c = text.charAt(end);\\n\\t\\t\\t\\tif(c == closeBracket)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(--count == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend++;\\n\\t\\t\\t\\t\\t\\tbreak forward_scan;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(c == openBracket)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\twhile(++end < buffer.getLength());\\n\\t\\t}\\n\\t\\ts = new Selection.Range(start,end);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(end);\\n\\t} \\n\\tpublic final void invertSelection()\\n\\t{\\n\\t\\tSelection[] newSelection = new Selection[selection.size() + 1];\\n\\t\\tint lastOffset = 0;\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tnewSelection[i] = new Selection.Range(lastOffset,\\n\\t\\t\\t\\ts.getStart());\\n\\t\\t\\tlastOffset = s.getEnd();\\n\\t\\t}\\n\\t\\tnewSelection[selection.size()] = new Selection.Range(\\n\\t\\t\\tlastOffset,buffer.getLength());\\n\\t\\tsetSelection(newSelection);\\n\\t} \\n\\tpublic int getSelectionCount()\\n\\t{\\n\\t\\treturn selection.size();\\n\\t} \\n\\tpublic Selection[] getSelection()\\n\\t{\\n\\t\\tSelection[] sel = new Selection[selection.size()];\\n\\t\\tselection.copyInto(sel);\\n\\t\\treturn sel;\\n\\t} \\n\\tpublic void selectNone()\\n\\t{\\n\\t\\tsetSelection((Selection)null);\\n\\t} \\n\\tpublic void setSelection(Selection[] selection)\\n\\t{\\n\\t\\t\\t\\tinvalidateSelectedLines();\\n\\t\\tthis.selection.removeAllElements();\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t\\t_addToSelection(selection[i]);\\n\\t\\t}\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void setSelection(Selection selection)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tthis.selection.removeAllElements();\\n\\t\\tif(selection != null)\\n\\t\\t\\t_addToSelection(selection);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void addToSelection(Selection[] selection)\\n\\t{\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t\\t_addToSelection(selection[i]);\\n\\t\\t}\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void addToSelection(Selection selection)\\n\\t{\\n\\t\\t_addToSelection(selection);\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic Selection getSelectionAtOffset(int offset)\\n\\t{\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\t\\tif(offset >= s.start && offset <= s.end)\\n\\t\\t\\t\\t\\treturn s;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic void removeFromSelection(Selection sel)\\n\\t{\\n\\t\\tselection.removeElement(sel);\\n\\t\\tinvalidateLineRange(sel.startLine,sel.endLine);\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void removeFromSelection(int offset)\\n\\t{\\n\\t\\tSelection sel = getSelectionAtOffset(offset);\\n\\t\\tif(sel == null)\\n\\t\\t\\treturn;\\n\\t\\tselection.removeElement(sel);\\n\\t\\tinvalidateLineRange(sel.startLine,sel.endLine);\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void resizeSelection(int offset, int end, int extraEndVirt,\\n\\t\\tboolean rect)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(offset);\\n\\t\\tif(s != null)\\n\\t\\t{\\n\\t\\t\\tinvalidateLineRange(s.startLine,s.endLine);\\n\\t\\t\\tselection.removeElement(s);\\n\\t\\t}\\n\\t\\tboolean reversed = false;\\n\\t\\tif(end < offset)\\n\\t\\t{\\n\\t\\t\\tint tmp = offset;\\n\\t\\t\\toffset = end;\\n\\t\\t\\tend = tmp;\\n\\t\\t\\treversed = true;\\n\\t\\t}\\n\\t\\tSelection newSel;\\n\\t\\tif(rect)\\n\\t\\t{\\n\\t\\t\\tSelection.Rect rectSel = new Selection.Rect(offset,end);\\n\\t\\t\\tif(reversed)\\n\\t\\t\\t\\trectSel.extraStartVirt = extraEndVirt;\\n\\t\\t\\telse\\n\\t\\t\\t\\trectSel.extraEndVirt = extraEndVirt;\\n\\t\\t\\tnewSel = rectSel;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tnewSel = new Selection.Range(offset,end);\\n\\t\\t_addToSelection(newSel);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void extendSelection(int offset, int end)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(offset);\\n\\t\\tif(s != null)\\n\\t\\t{\\n\\t\\t\\tinvalidateLineRange(s.startLine,s.endLine);\\n\\t\\t\\tselection.removeElement(s);\\n\\t\\t\\tif(offset == s.start)\\n\\t\\t\\t{\\n\\t\\t\\t\\toffset = end;\\n\\t\\t\\t\\tend = s.end;\\n\\t\\t\\t}\\n\\t\\t\\telse if(offset == s.end)\\n\\t\\t\\t{\\n\\t\\t\\t\\toffset = s.start;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(end < offset)\\n\\t\\t{\\n\\t\\t\\tint tmp = end;\\n\\t\\t\\tend = offset;\\n\\t\\t\\toffset = tmp;\\n\\t\\t}\\n\\t\\t_addToSelection(new Selection.Range(offset,end));\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic String getSelectedText(Selection s)\\n\\t{\\n\\t\\tStringBuffer buf = new StringBuffer();\\n\\t\\ts.getText(buffer,buf);\\n\\t\\treturn buf.toString();\\n\\t} \\n\\tpublic String getSelectedText(String separator)\\n\\t{\\n\\t\\tif(selection.size() == 0)\\n\\t\\t\\treturn null;\\n\\t\\tStringBuffer buf = new StringBuffer();\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tif(i != 0)\\n\\t\\t\\t\\tbuf.append(separator);\\n\\t\\t\\t((Selection)selection.elementAt(i)).getText(buffer,buf);\\n\\t\\t}\\n\\t\\treturn buf.toString();\\n\\t} \\n\\tpublic String getSelectedText()\\n\\t{\\n\\t\\treturn getSelectedText(\\\"\\\\n\\\");\\n\\t} \\n\\tpublic void setSelectedText(Selection s, String selectedText)\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tthrow new InternalError(\\\"Text component\\\"\\n\\t\\t\\t\\t+ \\\" read only\\\");\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tmoveCaretPosition(s.setText(buffer,selectedText));\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\t\\t\\t\\t} \\n\\tpublic void setSelectedText(String selectedText)\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tthrow new InternalError(\\\"Text component\\\"\\n\\t\\t\\t\\t+ \\\" read only\\\");\\n\\t\\t}\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(selection.length == 0)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.insert(caret,selectedText);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tint newCaret = -1;\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnewCaret = selection[i].setText(buffer,selectedText);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic int[] getSelectedLines()\\n\\t{\\n\\t\\tif(selection.size() == 0)\\n\\t\\t\\treturn new int[] { caretLine };\\n\\t\\tInteger line;\\n\\t\\tHashtable hash = new Hashtable();\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tint endLine = (s.end == getLineStartOffset(s.endLine)\\n\\t\\t\\t\\t? s.endLine - 1\\n\\t\\t\\t\\t: s.endLine);\\n\\t\\t\\tfor(int j = s.startLine; j <= endLine; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tline = new Integer(j);\\n\\t\\t\\t\\thash.put(line,line);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint[] returnValue = new int[hash.size()];\\n\\t\\tint i = 0;\\n\\t\\tEnumeration keys = hash.keys();\\n\\t\\twhile(keys.hasMoreElements())\\n\\t\\t{\\n\\t\\t\\tline = (Integer)keys.nextElement();\\n\\t\\t\\treturnValue[i++] = line.intValue();\\n\\t\\t}\\n\\t\\tArrays.sort(returnValue);\\n\\t\\treturn returnValue;\\n\\t} \\n\\tpublic void showSelectLineRangeDialog()\\n\\t{\\n\\t\\tnew SelectLineRange(view);\\n\\t} \\n\\tpublic final void blinkCaret()\\n\\t{\\n\\t\\tif(caretBlinks)\\n\\t\\t{\\n\\t\\t\\tblink = !blink;\\n\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tblink = true;\\n\\t} \\n\\tpublic void centerCaret()\\n\\t{\\n\\t\\tint offset = getScreenLineStartOffset(visibleLines / 2);\\n\\t\\tif(offset == -1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t\\tsetCaretPosition(offset);\\n\\t} \\n\\tpublic void setCaretPosition(int newCaret)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tselection.removeAllElements();\\n\\t\\tmoveCaretPosition(newCaret,true);\\n\\t} \\n\\tpublic void setCaretPosition(int newCaret, boolean doElectricScroll)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tselection.removeAllElements();\\n\\t\\tmoveCaretPosition(newCaret,doElectricScroll);\\n\\t} \\n\\tpublic void moveCaretPosition(int newCaret)\\n\\t{\\n\\t\\tmoveCaretPosition(newCaret,true);\\n\\t} \\n\\tpublic void moveCaretPosition(int newCaret, boolean doElectricScroll)\\n\\t{\\n\\t\\tif(newCaret < 0 || newCaret > buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tthrow new IllegalArgumentException(\\\"caret out of bounds: \\\"\\n\\t\\t\\t\\t+ newCaret);\\n\\t\\t}\\n\\t\\tif(caret == newCaret)\\n\\t\\t{\\n\\t\\t\\tif(view.getTextArea() == this)\\n\\t\\t\\t\\tfinishCaretUpdate(doElectricScroll,false);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint newCaretLine = getLineOfOffset(newCaret);\\n\\t\\t\\tmagicCaret = -1;\\n\\t\\t\\tif(!foldVisibilityManager.isLineVisible(newCaretLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(foldVisibilityManager.isNarrowed())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint collapseFolds = buffer.getIntegerProperty(\\n\\t\\t\\t\\t\\t\\t\\\"collapseFolds\\\",0);\\n\\t\\t\\t\\t\\tif(collapseFolds != 0)\\n\\t\\t\\t\\t\\t\\tfoldVisibilityManager.expandFolds(collapseFolds);\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tfoldVisibilityManager.expandAllFolds();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tfoldVisibilityManager.expandFold(newCaretLine,false);\\n\\t\\t\\t}\\n\\t\\t\\tif(caretLine == newCaretLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caretScreenLine != -1)\\n\\t\\t\\t\\t\\tinvalidateScreenLineRange(caretScreenLine,caretScreenLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tcaretScreenLine = chunkCache.getScreenLineOfOffset(newCaretLine,\\n\\t\\t\\t\\t\\tnewCaret - buffer.getLineStartOffset(newCaretLine));\\n\\t\\t\\t\\tinvalidateLineRange(caretLine,newCaretLine);\\n\\t\\t\\t}\\n\\t\\t\\tcaret = newCaret;\\n\\t\\t\\tcaretLine = newCaretLine;\\n\\t\\t\\tif(view.getTextArea() == this)\\n\\t\\t\\t\\tfinishCaretUpdate(doElectricScroll,true);\\n\\t\\t}\\n\\t} \\n\\tpublic int getCaretPosition()\\n\\t{\\n\\t\\treturn caret;\\n\\t} \\n\\tpublic int getCaretLine()\\n\\t{\\n\\t\\treturn caretLine;\\n\\t} \\n\\tpublic final int getMagicCaretPosition()\\n\\t{\\n\\t\\tif(magicCaret == -1)\\n\\t\\t{\\n\\t\\t\\tmagicCaret = offsetToX(caretLine,caret\\n\\t\\t\\t\\t- getLineStartOffset(caretLine));\\n\\t\\t}\\n\\t\\treturn magicCaret;\\n\\t} \\n\\tpublic final void setMagicCaretPosition(int magicCaret)\\n\\t{\\n\\t\\tthis.magicCaret = magicCaret;\\n\\t} \\n\\tpublic final void addCaretListener(CaretListener listener)\\n\\t{\\n\\t\\tlistenerList.add(CaretListener.class,listener);\\n\\t} \\n\\tpublic final void removeCaretListener(CaretListener listener)\\n\\t{\\n\\t\\tlistenerList.remove(CaretListener.class,listener);\\n\\t} \\n\\tpublic final int getBracketPosition()\\n\\t{\\n\\t\\treturn bracketPosition;\\n\\t} \\n\\tpublic final int getBracketLine()\\n\\t{\\n\\t\\treturn bracketLine;\\n\\t} \\n\\tpublic void goToNextBracket(boolean select)\\n\\t{\\n\\t\\tString text = getText(caret,buffer.getLength() - caret - 1);\\n\\t\\tint newCaret = -1;\\nloop:\\t\\tfor(int i = 0; i < text.length(); i++)\\n\\t\\t{\\n\\t\\t\\tswitch(text.charAt(i))\\n\\t\\t\\t{\\n\\t\\t\\tcase ')': case ']': case '}':\\n\\t\\t\\t\\tnewCaret = caret + i + 1;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(newCaret == -1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(select)\\n\\t\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\t\\telse if(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t}\\n\\t} \\n\\tpublic void goToNextCharacter(boolean select)\\n\\t{\\n\\t\\tif(!select && selection.size() != 0)\\n\\t\\t{\\n\\t\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\t\\tif(s != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(multi)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(caret != s.end)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tmoveCaretPosition(s.end);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsetCaretPosition(s.end);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(caret == buffer.getLength())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\tint newCaret;\\n\\t\\tif(caret == getLineEndOffset(caretLine) - 1)\\n\\t\\t{\\n\\t\\t\\tint line = foldVisibilityManager.getNextVisibleLine(caretLine);\\n\\t\\t\\tif(line == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret = getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tnewCaret = caret + 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToNextLine(boolean select)\\n\\t{\\n\\t\\tChunkCache.LineInfo[] lineInfos = chunkCache.getLineInfosForPhysicalLine(caretLine);\\n\\t\\tint caretFromStartOfLine = caret - buffer.getLineStartOffset(caretLine);\\n\\t\\tint subregion = getSubregionOfOffset(caretFromStartOfLine,\\n\\t\\t\\tlineInfos);\\n\\t\\tint magic = this.magicCaret;\\n\\t\\tif(magic == -1)\\n\\t\\t{\\n\\t\\t\\tmagic = subregionOffsetToX(lineInfos[subregion],\\n\\t\\t\\t\\tcaretFromStartOfLine);\\n\\t\\t}\\n\\t\\tint newCaret;\\n\\t\\tif(subregion != lineInfos.length - 1)\\n\\t\\t{\\n\\t\\t\\tnewCaret = buffer.getLineStartOffset(caretLine)\\n\\t\\t\\t\\t+ xToSubregionOffset(lineInfos[subregion + 1],magic,\\n\\t\\t\\t\\ttrue);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint nextLine = foldVisibilityManager.getNextVisibleLine(caretLine);\\n\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint end = getLineEndOffset(caretLine) - 1;\\n\\t\\t\\t\\tif(caret == end)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tnewCaret = end;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tlineInfos = chunkCache.getLineInfosForPhysicalLine(nextLine);\\n\\t\\t\\t\\tnewCaret = getLineStartOffset(nextLine)\\n\\t\\t\\t\\t\\t+ xToSubregionOffset(lineInfos[0],magic + 1,\\n\\t\\t\\t\\t\\ttrue);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tthis.magicCaret = magic;\\n\\t} \\n\\tpublic void goToNextMarker(boolean select)\\n\\t{\\n\\t\\tVector markers = buffer.getMarkers();\\n\\t\\tif(markers.size() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tMarker marker = null;\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker _marker = (Marker)markers.get(i);\\n\\t\\t\\tif(_marker.getPosition() > caret)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmarker = _marker;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(marker == null)\\n\\t\\t\\tmarker = (Marker)markers.get(0);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,marker.getPosition());\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(marker.getPosition());\\n\\t} \\n\\tpublic void goToNextPage(boolean select)\\n\\t{\\n\\t\\tint lineCount = getVirtualLineCount();\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tif(firstLine + visibleLines * 2 >= lineCount - 1)\\n\\t\\t\\tsetFirstLine(lineCount - visibleLines);\\n\\t\\telse\\n\\t\\t\\tsetFirstLine(firstLine + visibleLines);\\n\\t\\tint newLine = virtualToPhysical(Math.min(lineCount - 1,\\n\\t\\t\\tphysicalToVirtual(caretLine) + visibleLines));\\n\\t\\tint newCaret = getLineStartOffset(newLine)\\n\\t\\t\\t+ xToOffset(newLine,magic + 1);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToNextParagraph(boolean select)\\n\\t{\\n\\t\\tint lineNo = getCaretLine();\\n\\t\\tint newCaret = getBufferLength();\\n\\t\\tboolean foundBlank = false;\\nloop:\\t\\tfor(int i = lineNo + 1; i < getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tif(!foldVisibilityManager.isLineVisible(i))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif(foundBlank)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnewCaret = getLineStartOffset(i);\\n\\t\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfoundBlank = true;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToNextWord(boolean select)\\n\\t{\\n\\t\\tgoToNextWord(select,false);\\n\\t} \\n\\tpublic void goToNextWord(boolean select, boolean stdNextPrevWord)\\n\\t{\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint newCaret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(newCaret == lineText.length())\\n\\t\\t{\\n\\t\\t\\tint nextLine = foldVisibilityManager.getNextVisibleLine(caretLine);\\n\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret = getLineStartOffset(nextLine);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tnewCaret = TextUtilities.findWordEnd(lineText,newCaret + 1,\\n\\t\\t\\t\\tnoWordSep);\\n\\t\\t\\tif(stdNextPrevWord)\\n\\t\\t\\t{\\n\\t\\t\\t\\twhile((newCaret < lineText.length()) && Character.isWhitespace(lineText.charAt(newCaret)))\\n\\t\\t\\t\\t\\tnewCaret = TextUtilities.findWordEnd(lineText,newCaret + 1,\\n\\t\\t\\t\\t\\t\\tnoWordSep);\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret += lineStart;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToPrevBracket(boolean select)\\n\\t{\\n\\t\\tString text = getText(0,caret);\\n\\t\\tint newCaret = -1;\\nloop:\\t\\tfor(int i = getCaretPosition() - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tswitch(text.charAt(i))\\n\\t\\t\\t{\\n\\t\\t\\tcase '(': case '[': case '{':\\n\\t\\t\\t\\tnewCaret = i;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(newCaret == -1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(select)\\n\\t\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\t\\telse if(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t}\\n\\t} \\n\\tpublic void goToPrevCharacter(boolean select)\\n\\t{\\n\\t\\tif(!select && selection.size() != 0)\\n\\t\\t{\\n\\t\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\t\\tif(s != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(multi)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(caret != s.start)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tmoveCaretPosition(s.start);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsetCaretPosition(s.start);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint newCaret;\\n\\t\\tif(caret == getLineStartOffset(caretLine))\\n\\t\\t{\\n\\t\\t\\tint line = foldVisibilityManager.getPrevVisibleLine(caretLine);\\n\\t\\t\\tif(line == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret = getLineEndOffset(line) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tnewCaret = caret - 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToPrevLine(boolean select)\\n\\t{\\n\\t\\tChunkCache.LineInfo[] lineInfos = chunkCache.getLineInfosForPhysicalLine(caretLine);\\n\\t\\tint caretFromStartOfLine = caret - buffer.getLineStartOffset(caretLine);\\n\\t\\tint subregion = getSubregionOfOffset(caretFromStartOfLine,\\n\\t\\t\\tlineInfos);\\n\\t\\tint magic = this.magicCaret;\\n\\t\\tif(magic == -1)\\n\\t\\t{\\n\\t\\t\\tmagic = subregionOffsetToX(lineInfos[subregion],\\n\\t\\t\\t\\tcaretFromStartOfLine);\\n\\t\\t}\\n\\t\\tint newCaret;\\n\\t\\tif(subregion != 0)\\n\\t\\t{\\n\\t\\t\\tnewCaret = buffer.getLineStartOffset(caretLine)\\n\\t\\t\\t\\t+ xToSubregionOffset(lineInfos[subregion - 1],magic,\\n\\t\\t\\t\\ttrue);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint prevLine = foldVisibilityManager.getPrevVisibleLine(caretLine);\\n\\t\\t\\tif(prevLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\t\\t\\tif(caret == start)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tnewCaret = start;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tlineInfos = chunkCache.getLineInfosForPhysicalLine(prevLine);\\n\\t\\t\\t\\tnewCaret = getLineStartOffset(prevLine)\\n\\t\\t\\t\\t\\t+ xToSubregionOffset(lineInfos[\\n\\t\\t\\t\\t\\tlineInfos.length - 1],magic + 1,\\n\\t\\t\\t\\t\\ttrue);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tthis.magicCaret = magic;\\n\\t} \\n\\tpublic void goToPrevMarker(boolean select)\\n\\t{\\n\\t\\tVector markers = buffer.getMarkers();\\n\\t\\tif(markers.size() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tMarker marker = null;\\n\\t\\tfor(int i = markers.size() - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tMarker _marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tif(_marker.getPosition() < caret)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmarker = _marker;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(marker == null)\\n\\t\\t\\tmarker = (Marker)markers.get(markers.size() - 1);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,marker.getPosition());\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(marker.getPosition());\\n\\t} \\n\\tpublic void goToPrevPage(boolean select)\\n\\t{\\n\\t\\tif(firstLine < visibleLines)\\n\\t\\t\\tsetFirstLine(0);\\n\\t\\telse\\n\\t\\t\\tsetFirstLine(firstLine - visibleLines);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newLine = virtualToPhysical(Math.max(0,\\n\\t\\t\\tphysicalToVirtual(caretLine) - visibleLines));\\n\\t\\tint newCaret = getLineStartOffset(newLine)\\n\\t\\t\\t+ xToOffset(newLine,magic + 1);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToPrevParagraph(boolean select)\\n\\t{\\n\\t\\tint lineNo = caretLine;\\n\\t\\tint newCaret = 0;\\n\\t\\tboolean foundBlank = false;\\nloop:\\t\\tfor(int i = lineNo - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(!foldVisibilityManager.isLineVisible(i))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif(foundBlank)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnewCaret = getLineEndOffset(i) - 1;\\n\\t\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfoundBlank = true;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToPrevWord(boolean select)\\n\\t{\\n\\t\\tgoToPrevWord(select,false);\\n\\t} \\n\\tpublic void goToPrevWord(boolean select, boolean stdNextPrevWord)\\n\\t{\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint newCaret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(newCaret == 0)\\n\\t\\t{\\n\\t\\t\\tif(lineStart == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tview.getToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint prevLine = foldVisibilityManager.getPrevVisibleLine(caretLine);\\n\\t\\t\\t\\tif(prevLine == -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnewCaret = getLineEndOffset(prevLine) - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tnewCaret = TextUtilities.findWordStart(lineText,newCaret - 1,\\n\\t\\t\\t\\tnoWordSep);\\n\\t\\t\\tif(stdNextPrevWord)\\n\\t\\t\\t{\\n\\t\\t\\t\\twhile((newCaret > 0) && Character.isWhitespace(lineText.charAt(newCaret)))\\n\\t\\t\\t\\t\\tnewCaret = TextUtilities.findWordStart(lineText,newCaret - 1,\\n\\t\\t\\t\\t\\t\\tnoWordSep);\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret += lineStart;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void smartHome(boolean select)\\n\\t{\\n\\t\\tMacros.Recorder recorder = view.getMacroRecorder();\\n\\t\\tswitch(view.getInputHandler().getLastActionCount())\\n\\t\\t{\\n\\t\\tcase 1:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToStartOfWhiteSpace(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToStartOfWhiteSpace(select);\\n\\t\\t\\tbreak;\\n\\t\\tcase 2:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToStartOfLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToStartOfLine(select);\\n\\t\\t\\tbreak;\\n\\t\\tdefault: \\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToFirstVisibleLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToFirstVisibleLine(select);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t} \\n\\tpublic void smartEnd(boolean select)\\n\\t{\\n\\t\\tMacros.Recorder recorder = view.getMacroRecorder();\\n\\t\\tswitch(view.getInputHandler().getLastActionCount())\\n\\t\\t{\\n\\t\\tcase 1:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToEndOfWhiteSpace(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToEndOfWhiteSpace(select);\\n\\t\\t\\tbreak;\\n\\t\\tcase 2:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToEndOfLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToEndOfLine(select);\\n\\t\\t\\tbreak;\\n\\t\\tdefault: \\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToLastVisibleLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToLastVisibleLine(select);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t} \\n\\tpublic void goToStartOfLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line = (select || s == null\\n\\t\\t\\t? caretLine : s.startLine);\\n\\t\\tint newCaret = getLineStartOffset(line);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToEndOfLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line = (select || s == null\\n\\t\\t\\t? caretLine : s.endLine);\\n\\t\\tint newCaret = getLineEndOffset(line) - 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t\\t\\t\\t\\t\\t} \\n\\tpublic void goToStartOfWhiteSpace(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line, offset;\\n\\t\\tif(select || s == null)\\n\\t\\t{\\n\\t\\t\\tline = caretLine;\\n\\t\\t\\toffset = caret - buffer.getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tline = s.startLine;\\n\\t\\t\\toffset = s.start - buffer.getLineStartOffset(line);\\n\\t\\t}\\n\\t\\tint firstIndent;\\n\\t\\tChunkCache.LineInfo[] lineInfos = chunkCache.getLineInfosForPhysicalLine(line);\\n\\t\\tint subregion = getSubregionOfOffset(offset,lineInfos);\\n\\t\\tif(subregion == 0)\\n\\t\\t{\\n\\t\\t\\tfirstIndent = MiscUtilities.getLeadingWhiteSpace(getLineText(line));\\n\\t\\t\\tif(firstIndent == getLineLength(line))\\n\\t\\t\\t\\tfirstIndent = 0;\\n\\t\\t\\tfirstIndent += getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfirstIndent = getLineStartOffset(line)\\n\\t\\t\\t\\t+ lineInfos[subregion].offset;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,firstIndent);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(firstIndent);\\n\\t} \\n\\tpublic void goToEndOfWhiteSpace(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line, offset;\\n\\t\\tif(select || s == null)\\n\\t\\t{\\n\\t\\t\\tline = caretLine;\\n\\t\\t\\toffset = caret - getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tline = s.endLine;\\n\\t\\t\\toffset = s.end - getLineStartOffset(line);\\n\\t\\t}\\n\\t\\tint lastIndent;\\n\\t\\tChunkCache.LineInfo[] lineInfos = chunkCache.getLineInfosForPhysicalLine(line);\\n\\t\\tint subregion = getSubregionOfOffset(offset,lineInfos);\\n\\t\\tif(subregion == lineInfos.length - 1)\\n\\t\\t{\\n\\t\\t\\tlastIndent = getLineLength(line) - MiscUtilities.getTrailingWhiteSpace(getLineText(line));\\n\\t\\t\\tif(lastIndent == 0)\\n\\t\\t\\t\\tlastIndent = getLineLength(line);\\n\\t\\t\\tlastIndent += getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlastIndent = getLineStartOffset(line)\\n\\t\\t\\t\\t+ lineInfos[subregion].offset\\n\\t\\t\\t\\t+ lineInfos[subregion].length - 1;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,lastIndent);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(lastIndent);\\n\\t} \\n\\tpublic void goToFirstVisibleLine(boolean select)\\n\\t{\\n\\t\\tint firstVisibleLine = firstLine == 0 ? 0 : electricScroll;\\n\\t\\tint firstVisible = getScreenLineStartOffset(firstVisibleLine);\\n\\t\\tif(firstVisible == -1)\\n\\t\\t{\\n\\t\\t\\tfirstVisible = getLineStartOffset(foldVisibilityManager\\n\\t\\t\\t\\t.getFirstVisibleLine());\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,firstVisible);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(firstVisible);\\n\\t} \\n\\tpublic void goToLastVisibleLine(boolean select)\\n\\t{\\n\\t\\tint lastVisible;\\n\\t\\tif(firstLine + visibleLines >= getVirtualLineCount())\\n\\t\\t{\\n\\t\\t\\tlastVisible = getLineEndOffset(foldVisibilityManager\\n\\t\\t\\t\\t.getLastVisibleLine()) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlastVisible = getScreenLineEndOffset(visibleLines\\n\\t\\t\\t\\t- electricScroll - 1) - 1;\\n\\t\\t\\tif(lastVisible == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlastVisible = getLineEndOffset(foldVisibilityManager\\n\\t\\t\\t\\t\\t.getLastVisibleLine()) - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,lastVisible);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(lastVisible);\\n\\t} \\n\\tpublic void goToBufferStart(boolean select)\\n\\t{\\n\\t\\tint start = buffer.getLineStartOffset(\\n\\t\\t\\tfoldVisibilityManager.getFirstVisibleLine());\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,start);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(start);\\n\\t} \\n\\tpublic void goToBufferEnd(boolean select)\\n\\t{\\n\\t\\tint end = buffer.getLineEndOffset(\\n\\t\\t\\tfoldVisibilityManager.getLastVisibleLine()) - 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,end);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(end);\\n\\t} \\n\\tpublic void goToMatchingBracket()\\n\\t{\\n\\t\\tif(getLineLength(caretLine) != 0)\\n\\t\\t{\\n\\t\\t\\tint dot = caret - getLineStartOffset(caretLine);\\n\\t\\t\\tint bracket = TextUtilities.findMatchingBracketFuzzy(\\n\\t\\t\\t\\tbuffer,caretLine,Math.max(0,dot - 1));\\n\\t\\t\\tif(bracket != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\t\\tmoveCaretPosition(bracket + 1,false);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tgetToolkit().beep();\\n\\t} \\n\\tpublic void showGoToLineDialog()\\n\\t{\\n\\t\\tString line = GUIUtilities.input(view,\\\"goto-line\\\",null);\\n\\t\\tif(line == null)\\n\\t\\t\\treturn;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tint lineNumber = Integer.parseInt(line) - 1;\\n\\t\\t\\tsetCaretPosition(getLineStartOffset(lineNumber));\\n\\t\\t}\\n\\t\\tcatch(Exception e)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t}\\n\\t} \\n\\tpublic void userInput(char ch)\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(ch == ' ' && Abbrevs.getExpandOnInput()\\n\\t\\t\\t&& Abbrevs.expandAbbrev(view,false))\\n\\t\\t\\treturn;\\n\\t\\telse if(ch == '\\\\t')\\n\\t\\t{\\n\\t\\t\\tif(selection.size() == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection sel = (Selection)selection.elementAt(0);\\n\\t\\t\\t\\tif(sel.startLine == sel.endLine\\n\\t\\t\\t\\t\\t&& sel.start != buffer.getLineStartOffset(sel.startLine)\\n\\t\\t\\t\\t\\t&& sel.end != buffer.getLineEndOffset(sel.startLine) - 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tinsertTab();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tshiftIndentRight();\\n\\t\\t\\t}\\n\\t\\t\\telse if(selection.size() != 0)\\n\\t\\t\\t\\tshiftIndentRight();\\n\\t\\t\\telse\\n\\t\\t\\t\\tinsertTab();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tboolean indent;\\n\\t\\t\\t\\t\\t\\tString indentOpenBrackets = (String)buffer\\n\\t\\t\\t\\t.getProperty(\\\"indentOpenBrackets\\\");\\n\\t\\t\\tString indentCloseBrackets = (String)buffer\\n\\t\\t\\t\\t.getProperty(\\\"indentCloseBrackets\\\");\\n\\t\\t\\tif((indentCloseBrackets != null\\n\\t\\t\\t\\t&& indentCloseBrackets.indexOf(ch) != -1)\\n\\t\\t\\t\\t|| (indentOpenBrackets != null\\n\\t\\t\\t\\t&& indentOpenBrackets.indexOf(ch) != -1))\\n\\t\\t\\t{\\n\\t\\t\\t\\tindent = true;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tindent = false;\\n\\t\\t\\t}\\n\\t\\t\\tString str = String.valueOf(ch);\\n\\t\\t\\tif(selection.size() != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetSelectedText(str);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(ch == ' ')\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(doWordWrap(true))\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tdoWordWrap(false);\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(overwrite || indent)\\n\\t\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tif(overwrite)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint caretLineEnd = getLineEndOffset(caretLine);\\n\\t\\t\\t\\t\\tif(caretLineEnd - caret > 1)\\n\\t\\t\\t\\t\\t\\tbuffer.remove(caret,1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbuffer.insert(caret,str);\\n\\t\\t\\t\\tif(indent)\\n\\t\\t\\t\\t\\tbuffer.indentLine(caretLine,false,true);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(overwrite || indent)\\n\\t\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic final boolean isOverwriteEnabled()\\n\\t{\\n\\t\\treturn overwrite;\\n\\t} \\n\\tpublic final void setOverwriteEnabled(boolean overwrite)\\n\\t{\\n\\t\\tblink = true;\\n\\t\\tcaretTimer.restart();\\n\\t\\tthis.overwrite = overwrite;\\n\\t\\tinvalidateLine(caretLine);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t\\tview.getStatus().updateMiscStatus();\\n\\t} \\n\\tpublic final void toggleOverwriteEnabled()\\n\\t{\\n\\t\\tsetOverwriteEnabled(!overwrite);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t{\\n\\t\\t\\tview.getStatus().setMessageAndClear(\\n\\t\\t\\t\\tjEdit.getProperty(\\\"view.status.overwrite-changed\\\",\\n\\t\\t\\t\\tnew Integer[] { new Integer(overwrite ? 1 : 0) }));\\n\\t\\t}\\n\\t} \\n\\tpublic void backspace()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() != 0)\\n\\t\\t\\tsetSelectedText(null);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(caret == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.remove(caret - 1,1);\\n\\t\\t}\\n\\t} \\n\\tpublic void backspaceWord()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() != 0)\\n\\t\\t{\\n\\t\\t\\tsetSelectedText(\\\"\\\");\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint _caret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(_caret == 0)\\n\\t\\t{\\n\\t\\t\\tif(lineStart == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t_caret--;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\t_caret = TextUtilities.findWordStart(lineText,_caret-1,noWordSep);\\n\\t\\t}\\n\\t\\tbuffer.remove(_caret + lineStart,\\n\\t\\t\\tcaret - (_caret + lineStart));\\n\\t} \\n\\tpublic void delete()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() != 0)\\n\\t\\t\\tsetSelectedText(null);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(caret == buffer.getLength())\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.remove(caret,1);\\n\\t\\t}\\n\\t} \\n\\tpublic void deleteToEndOfLine()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.remove(caret,getLineEndOffset(caretLine)\\n\\t\\t\\t- caret - 1);\\n\\t} \\n\\tpublic void deleteLine()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine);\\n\\t\\tif(end > buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tif(start != 0)\\n\\t\\t\\t\\tstart--;\\n\\t\\t\\tend--;\\n\\t\\t}\\n\\t\\tint x = offsetToX(caretLine,caret - start);\\n\\t\\tbuffer.remove(start,end - start);\\n\\t\\tint lastLine = buffer.getLineCount() - 1;\\n\\t\\tif(caretLine == lastLine)\\n\\t\\t{\\n\\t\\t\\tsetCaretPosition(buffer.getLineStartOffset(lastLine)\\n\\t\\t\\t\\t+ xToOffset(caretLine,x));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tsetCaretPosition(start + xToOffset(caretLine,x));\\n\\t\\t}\\n\\t} \\n\\tpublic void deleteParagraph()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint start = 0, end = buffer.getLength();\\nloop:\\t\\tfor(int i = caretLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tstart = getLineStartOffset(i);\\n\\t\\t\\tbreak loop;\\n\\t\\t}\\nloop:\\t\\tfor(int i = caretLine + 1; i < getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tend = getLineEndOffset(i) - 1;\\n\\t\\t\\tbreak loop;\\n\\t\\t}\\n\\t\\tbuffer.remove(start,end - start);\\n\\t} \\n\\tpublic void deleteToStartOfLine()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.remove(getLineStartOffset(caretLine),\\n\\t\\t\\tcaret - getLineStartOffset(caretLine));\\n\\t} \\n\\tpublic void deleteWord()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() != 0)\\n\\t\\t{\\n\\t\\t\\tsetSelectedText(\\\"\\\");\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint _caret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(_caret == lineText.length())\\n\\t\\t{\\n\\t\\t\\tif(lineStart + _caret == buffer.getLength())\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t_caret++;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\t_caret = TextUtilities.findWordEnd(lineText,\\n\\t\\t\\t\\t_caret+1,noWordSep);\\n\\t\\t}\\n\\t\\tbuffer.remove(caret,(_caret + lineStart) - caret);\\n\\t} \\n\\tpublic final boolean isMultipleSelectionEnabled()\\n\\t{\\n\\t\\treturn multi;\\n\\t} \\n\\tpublic final void toggleMultipleSelectionEnabled()\\n\\t{\\n\\t\\tsetMultipleSelectionEnabled(!multi);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t{\\n\\t\\t\\tview.getStatus().setMessageAndClear(\\n\\t\\t\\t\\tjEdit.getProperty(\\\"view.status.multi-changed\\\",\\n\\t\\t\\t\\tnew Integer[] { new Integer(multi ? 1 : 0) }));\\n\\t\\t}\\n\\t} \\n\\tpublic final void setMultipleSelectionEnabled(boolean multi)\\n\\t{\\n\\t\\tthis.multi = multi;\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t\\tview.getStatus().updateMiscStatus();\\n\\t} \\n\\tpublic void goToMarker(char shortcut, boolean select)\\n\\t{\\n\\t\\tMarker marker = buffer.getMarker(shortcut);\\n\\t\\tif(marker == null)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint pos = marker.getPosition();\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,pos);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(pos);\\n\\t} \\n\\tpublic void addMarker()\\n\\t{\\n\\t\\t\\t\\tSelection[] selection = getSelection();\\n\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\tif(s.startLine != s.endLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s.startLine != caretLine)\\n\\t\\t\\t\\t\\tbuffer.addMarker('\\\\0',s.start);\\n\\t\\t\\t}\\n\\t\\t\\tif(s.endLine != caretLine)\\n\\t\\t\\t\\tbuffer.addMarker('\\\\0',s.end);\\n\\t\\t}\\n\\t\\t\\t\\tbuffer.addOrRemoveMarker('\\\\0',caret);\\n\\t} \\n\\tpublic void swapMarkerAndCaret(char shortcut)\\n\\t{\\n\\t\\tMarker marker = buffer.getMarker(shortcut);\\n\\t\\tif(marker == null)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint caret = getCaretPosition();\\n\\t\\tsetCaretPosition(marker.getPosition());\\n\\t\\tbuffer.addMarker(shortcut,caret);\\n\\t} \\n\\tpublic void goToParentFold()\\n\\t{\\n\\t\\tint line = -1;\\n\\t\\tint level = buffer.getFoldLevel(caretLine);\\n\\t\\tfor(int i = caretLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(buffer.getFoldLevel(i) < level)\\n\\t\\t\\t{\\n\\t\\t\\t\\tline = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(line == -1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = buffer.getLineStartOffset(line)\\n\\t\\t\\t+ xToOffset(line,magic + 1);\\n\\t\\tif(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToNextFold(boolean select)\\n\\t{\\n\\t\\tint line = caretLine;\\n\\t\\tint nextFold = -1;\\n\\t\\tfor(int i = caretLine + 1; i < buffer.getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tif(buffer.isFoldStart(i)\\n\\t\\t\\t\\t&& foldVisibilityManager.isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\tnextFold = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(nextFold == -1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = buffer.getLineStartOffset(nextFold)\\n\\t\\t\\t+ xToOffset(nextFold,magic + 1);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToPrevFold(boolean select)\\n\\t{\\n\\t\\tint line = caretLine;\\n\\t\\tint prevFold = -1;\\n\\t\\tfor(int i = caretLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(buffer.isFoldStart(i)\\n\\t\\t\\t\\t&& foldVisibilityManager.isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\tprevFold = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(prevFold == -1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = buffer.getLineStartOffset(prevFold)\\n\\t\\t\\t+ xToOffset(prevFold,magic + 1);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void collapseFold()\\n\\t{\\n\\t\\tint x = offsetToX(caretLine,caret - getLineStartOffset(caretLine));\\n\\t\\tfoldVisibilityManager.collapseFold(caretLine);\\n\\t\\tif(foldVisibilityManager.isLineVisible(caretLine))\\n\\t\\t\\treturn;\\n\\t\\tint line = foldVisibilityManager.getPrevVisibleLine(caretLine);\\n\\t\\tif(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(buffer.getLineStartOffset(line) + xToOffset(line,x));\\n\\t} \\n\\tpublic void expandFold(boolean fully)\\n\\t{\\n\\t\\tint x = offsetToX(caretLine,caret - getLineStartOffset(caretLine));\\n\\t\\tint line = foldVisibilityManager.expandFold(caretLine,fully);\\n\\t\\tif(!fully && line != -1)\\n\\t\\t{\\n\\t\\t\\tif(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\tmoveCaretPosition(getLineStartOffset(line) + xToOffset(line,x));\\n\\t\\t}\\n\\t} \\n\\tpublic void selectFold()\\n\\t{\\n\\t\\tselectFold(caretLine);\\n\\t} \\n\\tpublic void selectFold(int line)\\n\\t{\\n\\t\\tint[] lines = buffer.getFoldAtLine(line);\\n\\t\\tint newCaret = getLineEndOffset(lines[1]) - 1;\\n\\t\\tSelection s = new Selection.Range(getLineStartOffset(lines[0]),newCaret);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void narrowToFold()\\n\\t{\\n\\t\\tint[] lines = buffer.getFoldAtLine(caretLine);\\n\\t\\tif(lines[0] == 0 && lines[1] == buffer.getLineCount() - 1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t\\tfoldVisibilityManager.narrow(lines[0],lines[1]);\\n\\t} \\n\\tpublic void narrowToSelection()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tSelection sel = (Selection)selection.elementAt(0);\\n\\t\\tfoldVisibilityManager.narrow(sel.getStartLine(),sel.getEndLine());\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic void addExplicitFold()\\n\\t{\\n\\t\\tif(!buffer.getStringProperty(\\\"folding\\\").equals(\\\"explicit\\\"))\\n\\t\\t{\\n\\t\\t\\tGUIUtilities.error(view,\\\"folding-not-explicit\\\",null);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tString lineComment = buffer.getContextSensitiveProperty(caret,\\\"lineComment\\\");\\n\\t\\tString commentStart = buffer.getContextSensitiveProperty(caret,\\\"commentStart\\\");\\n\\t\\tString commentEnd = buffer.getContextSensitiveProperty(caret,\\\"commentEnd\\\");\\n\\t\\tString start, end;\\n\\t\\tif(lineComment != null)\\n\\t\\t{\\n\\t\\t\\tstart = lineComment + \\\"{{{ \\\\n\\\";\\n\\t\\t\\tend = lineComment + \\\"}}}\\\";\\n\\t\\t}\\n\\t\\telse if(commentStart != null && commentEnd != null)\\n\\t\\t{\\n\\t\\t\\tstart = commentStart + \\\"{{{  \\\" + commentEnd + \\\"\\\\n\\\";\\n\\t\\t\\tend = commentStart + \\\"}}}\\\" + commentEnd;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstart = \\\"{{{ \\\\n\\\";\\n\\t\\t\\tend = \\\"}}}\\\";\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tif(selection.size() == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tString line = buffer.getLineText(caretLine);\\n\\t\\t\\t\\tString whitespace = line.substring(0,\\n\\t\\t\\t\\t\\tMiscUtilities.getLeadingWhiteSpace(line));\\n\\t\\t\\t\\tint loc = caret + start.length() - 1;\\n\\t\\t\\t\\tstart = start + whitespace;\\n\\t\\t\\t\\tbuffer.insert(caret,start);\\n\\t\\t\\t\\t\\t\\t\\t\\tbuffer.insert(caret,end);\\n\\t\\t\\t\\tmoveCaretPosition(loc,false);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint loc = -1;\\n\\t\\t\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\t\\t\\tString line = buffer.getLineText(s.startLine);\\n\\t\\t\\t\\t\\tString whitespace = line.substring(0,\\n\\t\\t\\t\\t\\t\\tMiscUtilities.getLeadingWhiteSpace(line));\\n\\t\\t\\t\\t\\tloc = s.start + start.length() - 1;\\n\\t\\t\\t\\t\\tbuffer.insert(s.start,start + whitespace);\\n\\t\\t\\t\\t\\tbuffer.insert(s.end,\\\" \\\" + end);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsetCaretPosition(loc,false);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void lineComment()\\n\\t{\\n\\t\\tString comment = buffer.getContextSensitiveProperty(caret,\\\"lineComment\\\");\\n\\t\\tif(!buffer.isEditable() || comment == null || comment.length() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tcomment = comment + ' ';\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tint[] lines = getSelectedLines();\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < lines.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tString text = getLineText(lines[i]);\\n\\t\\t\\t\\tbuffer.insert(getLineStartOffset(lines[i])\\n\\t\\t\\t\\t\\t+ MiscUtilities.getLeadingWhiteSpace(text),\\n\\t\\t\\t\\t\\tcomment);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic void rangeComment()\\n\\t{\\n\\t\\tString commentStart = buffer.getContextSensitiveProperty(caret,\\\"commentStart\\\");\\n\\t\\tString commentEnd = buffer.getContextSensitiveProperty(caret,\\\"commentEnd\\\");\\n\\t\\tif(!buffer.isEditable() || commentStart == null || commentEnd == null\\n\\t\\t\\t|| commentStart.length() == 0 || commentEnd.length() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tcommentStart = commentStart + ' ';\\n\\t\\tcommentEnd = ' ' + commentEnd;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tSelection[] selection = getSelection();\\n\\t\\t\\tif(selection.length == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint oldCaret = caret;\\n\\t\\t\\t\\tbuffer.insert(caret,commentStart);\\n\\t\\t\\t\\tbuffer.insert(caret,commentEnd);\\n\\t\\t\\t\\tsetCaretPosition(oldCaret + commentStart.length());\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tif(s instanceof Selection.Range)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbuffer.insert(s.start,commentStart);\\n\\t\\t\\t\\t\\tbuffer.insert(s.end,commentEnd);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(s instanceof Selection.Rect)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection.Rect rect = (Selection.Rect)s;\\n\\t\\t\\t\\t\\tint start = rect.getStartColumn(buffer);\\n\\t\\t\\t\\t\\tint end = rect.getEndColumn(buffer);\\n\\t\\t\\t\\t\\tfor(int j = s.startLine; j <= s.endLine; j++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.insertAtColumn(j,end,\\n\\t\\t\\t\\t\\t\\t\\tcommentEnd);\\n\\t\\t\\t\\t\\t\\tbuffer.insertAtColumn(j,start,\\n\\t\\t\\t\\t\\t\\t\\tcommentStart);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tselectNone();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void formatParagraph()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(maxLineLen <= 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(selection.length != 0)\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tsetSelectedText(s,TextUtilities.format(\\n\\t\\t\\t\\t\\tgetSelectedText(s),maxLineLen));\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint lineNo = getCaretLine();\\n\\t\\t\\tint start = 0, end = buffer.getLength();\\nloop:\\t\\t\\tfor(int i = lineNo - 1; i >= 0; i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstart = getLineStartOffset(i);\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\nloop:\\t\\t\\tfor(int i = lineNo + 1; i < getLineCount(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tend = getLineEndOffset(i) - 1;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tString text = buffer.getText(start,end - start);\\n\\t\\t\\t\\tbuffer.remove(start,end - start);\\n\\t\\t\\t\\tbuffer.insert(start,TextUtilities.format(\\n\\t\\t\\t\\t\\ttext,maxLineLen));\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic void spacesToTabs()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tif(selection.length == 0)\\n\\t\\t{\\n\\t\\t\\tsetText(TextUtilities.spacesToTabs(\\n\\t\\t\\t\\tgetText(), buffer.getTabSize()));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tsetSelectedText(s,TextUtilities.spacesToTabs(\\n\\t\\t\\t\\t\\tgetSelectedText(s),buffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void tabsToSpaces()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tif(selection.length == 0)\\n\\t\\t{\\n\\t\\t\\tsetText(TextUtilities.tabsToSpaces(\\n\\t\\t\\t\\tgetText(), buffer.getTabSize()));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tsetSelectedText(s,TextUtilities.tabsToSpaces(\\n\\t\\t\\t\\t\\tgetSelectedText(s),buffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void toUpperCase()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable() || selection.length == 0)\\n                {\\n                \\tgetToolkit().beep();\\n                \\treturn;\\n                }\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\tsetSelectedText(s,getSelectedText(s).toUpperCase());\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void toLowerCase()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable() || selection.length == 0)\\n                {\\n                \\tgetToolkit().beep();\\n                \\treturn;\\n                }\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\tsetSelectedText(s,getSelectedText(s).toLowerCase());\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void removeTrailingWhiteSpace()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbuffer.removeTrailingWhiteSpace(getSelectedLines());\\n\\t\\t}\\n\\t} \\n\\t\\tpublic void insertEnterAndIndent()\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tsetSelectedText(\\\"\\\\n\\\");\\n\\t\\t\\t\\tbuffer.indentLine(caretLine,true,false);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tpublic void insertTabAndIndent()\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() == 0)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tString text = buffer.getLineText(caretLine);\\n\\t\\t\\tint start = buffer.getLineStartOffset(caretLine);\\n\\t\\t\\tint whiteSpace = MiscUtilities.getLeadingWhiteSpace(text);\\n\\t\\t\\tif(caret - start <= whiteSpace\\n\\t\\t\\t\\t&& buffer.indentLine(caretLine,true,false))\\n\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tuserInput('\\\\t');\\n\\t} \\n\\tpublic void indentSelectedLines()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbuffer.indentLines(getSelectedLines());\\n\\t\\t\\tselectNone();\\n\\t\\t}\\n\\t} \\n\\tpublic void shiftIndentLeft()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbuffer.shiftIndentLeft(getSelectedLines());\\n\\t\\t}\\n\\t} \\n\\tpublic void shiftIndentRight()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t\\tbuffer.shiftIndentRight(getSelectedLines());\\n\\t} \\n\\tpublic void joinLines()\\n\\t{\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine);\\n\\t\\tif(end > buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.remove(end - 1,MiscUtilities.getLeadingWhiteSpace(\\n\\t\\t\\tbuffer.getLineText(caretLine + 1)) + 1);\\n\\t\\tsetCaretPosition(end - 1);\\n\\t} \\n\\tpublic void showWordCountDialog()\\n\\t{\\n\\t\\tString selection = getSelectedText();\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tdoWordCount(view,selection);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tdoWordCount(view,buffer.getText(0,buffer.getLength()));\\n\\t} \\n\\tpublic void addNotify()\\n\\t{\\n\\t\\tsuper.addNotify();\\n\\t\\tToolTipManager.sharedInstance().registerComponent(painter);\\n\\t\\tToolTipManager.sharedInstance().registerComponent(gutter);\\n\\t\\tif(!bufferHandlerInstalled)\\n\\t\\t{\\n\\t\\t\\tbufferHandlerInstalled = true;\\n\\t\\t\\tbuffer.addBufferChangeListener(bufferHandler);\\n\\t\\t}\\n\\t\\trecalculateVisibleLines();\\n\\t\\trecalculateLastPhysicalLine();\\n\\t} \\n\\tpublic void removeNotify()\\n\\t{\\n\\t\\tsuper.removeNotify();\\n\\t\\tToolTipManager.sharedInstance().unregisterComponent(painter);\\n\\t\\tToolTipManager.sharedInstance().unregisterComponent(gutter);\\n\\t\\tif(focusedComponent == this)\\n\\t\\t\\tfocusedComponent = null;\\n\\t\\tif(bufferHandlerInstalled)\\n\\t\\t{\\n\\t\\t\\tbuffer.removeBufferChangeListener(bufferHandler);\\n\\t\\t\\tbufferHandlerInstalled = false;\\n\\t\\t}\\n\\t} \\n\\tpublic boolean hasFocus()\\n\\t{\\n\\t\\tComponent c = this;\\n\\t\\twhile(!(c instanceof Window))\\n\\t\\t{\\n\\t\\t\\tif(c == null)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tc = c.getParent();\\n\\t\\t}\\n\\t\\tComponent focusOwner = ((Window)c).getFocusOwner();\\n\\t\\tboolean hasFocus = (focusOwner == this);\\n\\t\\tif(hasFocus)\\n\\t\\t\\tfocusedComponent = this;\\n\\t\\treturn hasFocus;\\n\\t} \\n\\tpublic void grabFocus()\\n\\t{\\n\\t\\tsuper.grabFocus();\\n\\t\\t\\t\\thasFocus();\\n\\t} \\n\\tpublic boolean getFocusTraversalKeysEnabled()\\n\\t{\\n\\t\\treturn false;\\n\\t} \\n\\t\\t\\tlong time;\\n\\tboolean timing;\\n\\tpublic void processKeyEvent(KeyEvent evt)\\n\\t{\\n\\t\\ttime = System.currentTimeMillis();\\n\\t\\tevt = KeyEventWorkaround.processKeyEvent(evt);\\n\\t\\tif(evt == null)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\tif(view.isClosed())\\n\\t\\t\\treturn;\\n\\t\\tInputHandler inputHandler = view.getInputHandler();\\n\\t\\tKeyListener keyEventInterceptor = view.getKeyEventInterceptor();\\n\\t\\tswitch(evt.getID())\\n\\t\\t{\\n\\t\\tcase KeyEvent.KEY_TYPED:\\n\\t\\t\\t\\t\\t\\tif(keyEventInterceptor != null)\\n\\t\\t\\t\\tkeyEventInterceptor.keyTyped(evt);\\n\\t\\t\\telse\\n\\t\\t\\t\\tinputHandler.keyTyped(evt);\\n\\t\\t\\tbreak;\\n\\t\\tcase KeyEvent.KEY_PRESSED:\\n\\t\\t\\tif(keyEventInterceptor != null)\\n\\t\\t\\t\\tkeyEventInterceptor.keyPressed(evt);\\n\\t\\t\\telse\\n\\t\\t\\t\\tinputHandler.keyPressed(evt);\\n\\t\\t\\tbreak;\\n\\t\\tcase KeyEvent.KEY_RELEASED:\\n\\t\\t\\tif(keyEventInterceptor != null)\\n\\t\\t\\t\\tkeyEventInterceptor.keyReleased(evt);\\n\\t\\t\\telse\\n\\t\\t\\t\\tinputHandler.keyReleased(evt);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tif(!evt.isConsumed())\\n\\t\\t\\tsuper.processKeyEvent(evt);\\n\\t} \\n\\tpublic void propertiesChanged()\\n\\t{\\n\\t\\tif(buffer == null)\\n\\t\\t\\treturn;\\n\\t\\tint _tabSize = buffer.getTabSize();\\n\\t\\tchar[] foo = new char[_tabSize];\\n\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t{\\n\\t\\t\\tfoo[i] = ' ';\\n\\t\\t}\\n\\t\\ttabSize = (float)painter.getFont().getStringBounds(foo,0,_tabSize,\\n\\t\\t\\tpainter.getFontRenderContext()).getWidth();\\n\\t\\tcharWidth = (int)Math.round(painter.getFont().getStringBounds(foo,0,1,\\n\\t\\t\\tpainter.getFontRenderContext()).getWidth());\\n\\t\\tString wrap = buffer.getStringProperty(\\\"wrap\\\");\\n\\t\\tsoftWrap = wrap.equals(\\\"soft\\\");\\n\\t\\thardWrap = wrap.equals(\\\"hard\\\");\\n\\t\\tmaxLineLen = buffer.getIntegerProperty(\\\"maxLineLen\\\",0);\\n\\t\\tif(maxLineLen <= 0)\\n\\t\\t{\\n\\t\\t\\tif(softWrap)\\n\\t\\t\\t{\\n\\t\\t\\t\\twrapToWidth = true;\\n\\t\\t\\t\\twrapMargin = painter.getWidth() - charWidth * 3;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\twrapToWidth = false;\\n\\t\\t\\t\\twrapMargin = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tfoo = new char[maxLineLen];\\n\\t\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfoo[i] = ' ';\\n\\t\\t\\t}\\n\\t\\t\\twrapToWidth = false;\\n\\t\\t\\twrapMargin = (int)painter.getFont().getStringBounds(\\n\\t\\t\\t\\tfoo,0,maxLineLen,painter.getFontRenderContext())\\n\\t\\t\\t\\t.getWidth();\\n\\t\\t}\\n\\t\\tmonospacedHack = jEdit.getBooleanProperty(\\\"view.monospacedHack\\\");\\n\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\tupdateScrollBars();\\n\\t\\tchunkCache.invalidateAll();\\n\\t\\tgutter.repaint();\\n\\t\\tpainter.repaint();\\n\\t} \\n\\tpublic int offsetToX(int line, int offset)\\n\\t{\\n\\t\\tChunk chunks = chunkCache.lineToChunkList(line);\\n\\t\\treturn (int)(horizontalOffset + Chunk.offsetToX(chunks,offset));\\n\\t} \\n\\tpublic int xToOffset(int line, int x)\\n\\t{\\n\\t\\tx -= horizontalOffset;\\n\\t\\tChunk chunks = chunkCache.lineToChunkList(line);\\n\\t\\tint offset = Chunk.xToOffset(chunks,x,true);\\n\\t\\tif(offset == -1)\\n\\t\\t\\toffset = getLineLength(line);\\n\\t\\treturn offset;\\n\\t} \\n\\tpublic int xToOffset(int line, int x, boolean round)\\n\\t{\\n\\t\\tx -= horizontalOffset;\\n\\t\\tChunk chunks = chunkCache.lineToChunkList(line);\\n\\t\\tint offset = Chunk.xToOffset(chunks,x,round);\\n\\t\\tif(offset == -1)\\n\\t\\t\\toffset = getLineLength(line);\\n\\t\\treturn offset;\\n\\t} \\n\\tpublic final int getSelectionStart()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getStart();\\n\\t} \\n\\tpublic int getSelectionStart(int line)\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getStart(\\n\\t\\t\\tbuffer,line);\\n\\t} \\n\\tpublic final int getSelectionStartLine()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getStartLine();\\n\\t} \\n\\tpublic final void setSelectionStart(int selectionStart)\\n\\t{\\n\\t\\tselect(selectionStart,getSelectionEnd(),true);\\n\\t} \\n\\tpublic final int getSelectionEnd()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getEnd();\\n\\t} \\n\\tpublic int getSelectionEnd(int line)\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getEnd(\\n\\t\\t\\tbuffer,line);\\n\\t} \\n\\tpublic final int getSelectionEndLine()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getEndLine();\\n\\t} \\n\\tpublic final void setSelectionEnd(int selectionEnd)\\n\\t{\\n\\t\\tselect(getSelectionStart(),selectionEnd,true);\\n\\t} \\n\\tpublic final int getMarkPosition()\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(s == null)\\n\\t\\t\\treturn caret;\\n\\t\\tif(s.start == caret)\\n\\t\\t\\treturn s.end;\\n\\t\\telse if(s.end == caret)\\n\\t\\t\\treturn s.start;\\n\\t\\telse\\n\\t\\t\\treturn caret;\\n\\t} \\n\\tpublic final int getMarkLine()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caretLine;\\n\\t\\tSelection s = (Selection)selection.elementAt(0);\\n\\t\\tif(s.start == caret)\\n\\t\\t\\treturn s.endLine;\\n\\t\\telse if(s.end == caret)\\n\\t\\t\\treturn s.startLine;\\n\\t\\telse\\n\\t\\t\\treturn caretLine;\\n\\t} \\n\\tpublic void select(int start, int end)\\n\\t{\\n\\t\\tselect(start,end,true);\\n\\t} \\n\\tpublic void select(int start, int end, boolean doElectricScroll)\\n\\t{\\n\\t\\tselectNone();\\n\\t\\tint newStart, newEnd;\\n\\t\\tif(start < end)\\n\\t\\t{\\n\\t\\t\\tnewStart = start;\\n\\t\\t\\tnewEnd = end;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tnewStart = end;\\n\\t\\t\\tnewEnd = start;\\n\\t\\t}\\n\\t\\tsetSelection(new Selection.Range(newStart,newEnd));\\n\\t\\tmoveCaretPosition(end,doElectricScroll);\\n\\t} \\n\\tpublic boolean isSelectionRectangular()\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(s == null)\\n\\t\\t\\treturn false;\\n\\t\\telse\\n\\t\\t\\treturn (s instanceof Selection.Rect);\\n\\t} \\n\\t\\tSegment lineSegment;\\n\\tMouseHandler mouseHandler;\\n\\tChunkCache chunkCache;\\n\\tint maxHorizontalScrollWidth;\\n\\tboolean softWrap;\\n\\tboolean hardWrap;\\n\\tfloat tabSize;\\n\\tint wrapMargin;\\n\\tboolean wrapToWidth;\\n\\tint charWidth;\\n\\tboolean monospacedHack;\\n\\tboolean scrollBarsInitialized;\\n\\t\\t\\t\\tboolean queuedScrollTo;\\n\\tboolean queuedScrollToElectric;\\n\\tboolean queuedFireCaretEvent;\\n\\tboolean queuedRecalculateLastPhysicalLine;\\n\\tArrayList runnables;\\n\\t\\t\\tVector selection;\\n\\t\\tPoint returnValue;\\n\\tfinal boolean isCaretVisible()\\n\\t{\\n\\t\\treturn blink && hasFocus();\\n\\t} \\n\\tfinal boolean isBracketHighlightVisible()\\n\\t{\\n\\t\\treturn bracketLine != -1\\n\\t\\t\\t&& hasFocus()\\n\\t\\t\\t&& foldVisibilityManager.isLineVisible(bracketLine)\\n\\t\\t\\t&& foldVisibilityManager.isLineVisible(caretLine);\\n\\t} \\n\\t\\tvoid updateMaxHorizontalScrollWidth()\\n\\t{\\n\\t\\tint max = chunkCache.getMaxHorizontalScrollWidth();\\n\\t\\tif(max != maxHorizontalScrollWidth)\\n\\t\\t{\\n\\t\\t\\tmaxHorizontalScrollWidth = max;\\n\\t\\t\\thorizontal.setValues(Math.max(0,\\n\\t\\t\\t\\tMath.min(maxHorizontalScrollWidth + charWidth\\n\\t\\t\\t\\t- painter.getWidth(),\\n\\t\\t\\t\\t-horizontalOffset)),\\n\\t\\t\\t\\tpainter.getWidth(),\\n\\t\\t\\t\\t0,maxHorizontalScrollWidth\\n\\t\\t\\t\\t+ charWidth);\\n\\t\\t}\\n\\t} \\n\\t\\tvoid recalculateVisibleLines()\\n\\t{\\n\\t\\tif(painter == null)\\n\\t\\t\\treturn;\\n\\t\\tint height = painter.getHeight();\\n\\t\\tint lineHeight = painter.getFontMetrics().getHeight();\\n\\t\\tvisibleLines = height / lineHeight;\\n\\t\\tlastLinePartial = (height % lineHeight != 0);\\n\\t\\tchunkCache.recalculateVisibleLines();\\n\\t\\tpropertiesChanged();\\n\\t} \\n\\t\\tvoid foldStructureChanged()\\n\\t{\\n\\t\\tchunkCache.invalidateAll();\\n\\t\\t\\t\\twhile(!foldVisibilityManager.isLineVisible(physFirstLine)\\n\\t\\t\\t&& physFirstLine != 0)\\n\\t\\t\\tphysFirstLine--;\\n\\t\\tsetFirstLine(physicalToVirtual(physFirstLine));\\n\\t\\t\\t\\t\\t\\tupdateScrollBars();\\n\\t\\trecalculateLastPhysicalLine();\\n\\t\\t\\t\\tgutter.repaint();\\n\\t\\tpainter.repaint();\\n\\t} \\n\\t\\t int getSubregionOfOffset(int offset, ChunkCache.LineInfo[] lineInfos)\\n\\t{\\n\\t\\t\\t\\tfor(int i = 0; i < lineInfos.length; i++)\\n\\t\\t{\\n\\t\\t\\tChunkCache.LineInfo info = lineInfos[i];\\n\\t\\t\\tif(offset >= info.offset && offset < info.offset + info.length)\\n\\t\\t\\t\\treturn i;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t} \\n\\t\\t int xToSubregionOffset(ChunkCache.LineInfo info, float x,\\n\\t\\tboolean round)\\n\\t{\\n\\t\\tint offset = Chunk.xToOffset(info.chunks,\\n\\t\\t\\tx - horizontalOffset,round);\\n\\t\\tif(offset == -1 || offset == info.offset + info.length)\\n\\t\\t\\toffset = info.offset + info.length - 1;\\n\\t\\treturn offset;\\n\\t} \\n\\t\\t int subregionOffsetToX(ChunkCache.LineInfo info, int offset)\\n\\t{\\n\\t\\treturn (int)(horizontalOffset + Chunk.offsetToX(\\n\\t\\t\\tinfo.chunks,offset));\\n\\t} \\n\\t\\tprivate static String CENTER = \\\"center\\\";\\n\\tprivate static String RIGHT = \\\"right\\\";\\n\\tprivate static String LEFT = \\\"left\\\";\\n\\tprivate static String BOTTOM = \\\"bottom\\\";\\n\\tprivate static Timer caretTimer;\\n\\tprivate static JEditTextArea focusedComponent;\\n\\t\\tprivate View view;\\n\\tprivate Gutter gutter;\\n\\tprivate TextAreaPainter painter;\\n\\tprivate JPopupMenu popup;\\n\\tprivate EventListenerList listenerList;\\n\\tprivate MutableCaretEvent caretEvent;\\n\\tprivate boolean caretBlinks;\\n\\tprivate boolean blink;\\n\\tprivate int firstLine;\\n\\tprivate int physFirstLine;\\n\\tprivate int physLastLine;\\n\\tprivate int screenLastLine;\\n\\tprivate boolean lastLinePartial;\\n\\tprivate int visibleLines;\\n\\tprivate int electricScroll;\\n\\tprivate int horizontalOffset;\\n\\tprivate boolean quickCopy;\\n\\tprivate JScrollBar vertical;\\n\\tprivate JScrollBar horizontal;\\n\\tprivate boolean bufferChanging;\\n\\tprivate Buffer buffer;\\n\\tprivate FoldVisibilityManager foldVisibilityManager;\\n\\tprivate BufferChangeHandler bufferHandler;\\n\\tprivate boolean bufferHandlerInstalled;\\n\\tprivate int caret;\\n\\tprivate int caretLine;\\n\\tprivate int caretScreenLine;\\n\\tprivate int bracketPosition;\\n\\tprivate int bracketLine;\\n\\tprivate int magicCaret;\\n\\tprivate boolean multi;\\n\\tprivate boolean overwrite;\\n\\tprivate int maxLineLen;\\n\\t\\tprivate void _addToSelection(Selection addMe)\\n\\t{\\n\\t\\tif(addMe.start > addMe.end)\\n\\t\\t{\\n\\t\\t\\tthrow new IllegalArgumentException(addMe.start\\n\\t\\t\\t\\t+ \\\" > \\\" + addMe.end);\\n\\t\\t}\\n\\t\\telse if(addMe.start == addMe.end)\\n\\t\\t{\\n\\t\\t\\tif(addMe instanceof Selection.Range)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\telse if(addMe instanceof Selection.Rect)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(((Selection.Rect)addMe).extraEndVirt == 0)\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tif(s.overlaps(addMe))\\n\\t\\t\\t{\\n\\t\\t\\t\\taddMe.start = Math.min(s.start,addMe.start);\\n\\t\\t\\t\\taddMe.end = Math.max(s.end,addMe.end);\\n\\t\\t\\t\\tselection.removeElement(s);\\n\\t\\t\\t\\ti--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\taddMe.startLine = getLineOfOffset(addMe.start);\\n\\t\\taddMe.endLine = getLineOfOffset(addMe.end);\\n\\t\\tboolean added = false;\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tif(addMe.start < s.start)\\n\\t\\t\\t{\\n\\t\\t\\t\\tselection.insertElementAt(addMe,i);\\n\\t\\t\\t\\tadded = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(!added)\\n\\t\\t\\tselection.addElement(addMe);\\n\\t\\tinvalidateLineRange(addMe.startLine,addMe.endLine);\\n\\t} \\n\\tprivate void finishCaretUpdate(boolean doElectricScroll,\\n\\t\\tboolean fireCaretEvent)\\n\\t{\\n\\t\\tthis.queuedScrollToElectric |= doElectricScroll;\\n\\t\\tthis.queuedFireCaretEvent |= fireCaretEvent;\\n\\t\\tRunnable r = new Runnable()\\n\\t\\t{\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tblink = true;\\n\\t\\t\\t\\tcaretTimer.restart();\\n\\t\\t\\t\\tscrollToCaret(queuedScrollToElectric);\\n\\t\\t\\t\\tupdateBracketHighlight();\\n\\t\\t\\t\\tif(queuedFireCaretEvent)\\n\\t\\t\\t\\t\\tfireCaretEvent();\\n\\t\\t\\t\\tqueuedScrollTo = queuedScrollToElectric\\n\\t\\t\\t\\t\\t= queuedFireCaretEvent = false;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tif(buffer.isTransactionInProgress())\\n\\t\\t{\\n\\t\\t\\tif(!queuedScrollTo)\\n\\t\\t\\t{\\n\\t\\t\\t\\tqueuedScrollTo = true;\\n\\t\\t\\t\\trunnables.add(r);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tr.run();\\n\\t} \\n\\t\\tprivate void fireCaretEvent()\\n\\t{\\n\\t\\tObject[] listeners = listenerList.getListenerList();\\n\\t\\tfor(int i = listeners.length - 2; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(listeners[i] == CaretListener.class)\\n\\t\\t\\t{\\n\\t\\t\\t\\t((CaretListener)listeners[i+1]).caretUpdate(caretEvent);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireScrollEvent(boolean vertical)\\n\\t{\\n\\t\\tObject[] listeners = listenerList.getListenerList();\\n\\t\\tfor(int i = listeners.length - 2; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(listeners[i] == ScrollListener.class)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(vertical)\\n\\t\\t\\t\\t\\t((ScrollListener)listeners[i+1]).scrolledVertically(this);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t((ScrollListener)listeners[i+1]).scrolledHorizontally(this);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void insertTab()\\n\\t{\\n\\t\\tint tabSize = buffer.getTabSize();\\n\\t\\tif(buffer.getBooleanProperty(\\\"noTabs\\\"))\\n\\t\\t{\\n\\t\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\t\\tString line = getText(lineStart,caret - lineStart);\\n\\t\\t\\tint pos = 0;\\n\\t\\t\\tfor(int i = 0; i < line.length(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(line.charAt(pos))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tpos = 0;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif(++pos >= tabSize)\\n\\t\\t\\t\\t\\t\\tpos = 0;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tsetSelectedText(MiscUtilities.createWhiteSpace(\\n\\t\\t\\t\\ttabSize - pos,0));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tsetSelectedText(\\\"\\\\t\\\");\\n\\t} \\n\\t\\tprivate boolean doWordWrap(boolean spaceInserted)\\n\\t{\\n\\t\\tif(!hardWrap || maxLineLen <= 0)\\n\\t\\t\\treturn false;\\n\\t\\tbuffer.getLineText(caretLine,lineSegment);\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine);\\n\\t\\tint len = end - start - 1;\\n\\t\\tint caretPos = caret - start;\\n\\t\\t\\t\\t\\t\\tfor(int i = caretPos; i < len; i++)\\n\\t\\t{\\n\\t\\t\\tchar ch = lineSegment.array[lineSegment.offset + i];\\n\\t\\t\\tif(ch != ' ' && ch != '\\\\t')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tboolean returnValue = false;\\n\\t\\tint tabSize = buffer.getTabSize();\\n\\t\\tString wordBreakChars = buffer.getStringProperty(\\\"wordBreakChars\\\");\\n\\t\\tint logicalLength = 0; \\t\\tint lastWordOffset = -1;\\n\\t\\tboolean lastWasSpace = true;\\n\\t\\tboolean initialWhiteSpace = true;\\n\\t\\tint initialWhiteSpaceLength = 0;\\n\\t\\tfor(int i = 0; i < caretPos; i++)\\n\\t\\t{\\n\\t\\t\\tchar ch = lineSegment.array[lineSegment.offset + i];\\n\\t\\t\\tif(ch == '\\\\t')\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(initialWhiteSpace)\\n\\t\\t\\t\\t\\tinitialWhiteSpaceLength = i + 1;\\n\\t\\t\\t\\tlogicalLength += tabSize - (logicalLength % tabSize);\\n\\t\\t\\t\\tif(!lastWasSpace && logicalLength <= maxLineLen)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastWordOffset = i;\\n\\t\\t\\t\\t\\tlastWasSpace = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(ch == ' ')\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(initialWhiteSpace)\\n\\t\\t\\t\\t\\tinitialWhiteSpaceLength = i + 1;\\n\\t\\t\\t\\tlogicalLength++;\\n\\t\\t\\t\\tif(!lastWasSpace && logicalLength <= maxLineLen)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastWordOffset = i;\\n\\t\\t\\t\\t\\tlastWasSpace = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(wordBreakChars != null && wordBreakChars.indexOf(ch) != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tinitialWhiteSpace = false;\\n\\t\\t\\t\\tlogicalLength++;\\n\\t\\t\\t\\tif(!lastWasSpace && logicalLength <= maxLineLen)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastWordOffset = i;\\n\\t\\t\\t\\t\\tlastWasSpace = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tinitialWhiteSpace = false;\\n\\t\\t\\t\\tlogicalLength++;\\n\\t\\t\\t\\tlastWasSpace = false;\\n\\t\\t\\t}\\n\\t\\t\\tint insertNewLineAt;\\n\\t\\t\\tif(spaceInserted && logicalLength == maxLineLen\\n\\t\\t\\t\\t&& i == caretPos - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsertNewLineAt = caretPos;\\n\\t\\t\\t\\treturnValue = true;\\n\\t\\t\\t}\\n\\t\\t\\telse if(logicalLength >= maxLineLen && lastWordOffset != -1)\\n\\t\\t\\t\\tinsertNewLineAt = lastWordOffset;\\n\\t\\t\\telse\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tbuffer.insert(start + insertNewLineAt,\\\"\\\\n\\\");\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbuffer.indentLine(caretLine,true,true);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t\\treturn returnValue;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t} \\n\\t\\tprivate void doWordCount(View view, String text)\\n\\t{\\n\\t\\tchar[] chars = text.toCharArray();\\n\\t\\tint characters = chars.length;\\n\\t\\tint words;\\n\\t\\tif(characters == 0)\\n\\t\\t\\twords = 0;\\n\\t\\telse\\n\\t\\t\\twords = 1;\\n\\t\\tint lines = 1;\\n\\t\\tboolean word = false;\\n\\t\\tfor(int i = 0; i < chars.length; i++)\\n\\t\\t{\\n\\t\\t\\tswitch(chars[i])\\n\\t\\t\\t{\\n\\t\\t\\tcase '\\\\r': case '\\\\n':\\n\\t\\t\\t\\tlines++;\\n\\t\\t\\tcase ' ': case '\\\\t':\\n\\t\\t\\t\\tif(word)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twords++;\\n\\t\\t\\t\\t\\tword = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tword = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tObject[] args = { new Integer(characters), new Integer(words),\\n\\t\\t\\tnew Integer(lines) };\\n\\t\\tGUIUtilities.message(view,\\\"wordcount\\\",args);\\n\\t} \\n\\t\\tprivate void updateBracketHighlight()\\n\\t{\\n\\t\\tif(!painter.isBracketHighlightEnabled())\\n\\t\\t\\treturn;\\n\\t\\tif(bracketLine != -1)\\n\\t\\t\\tinvalidateLineRange(bracketLine,caretLine);\\n\\t\\tint offset = caret - getLineStartOffset(caretLine);\\n\\t\\tif(offset != 0)\\n\\t\\t{\\n\\t\\t\\tint bracketOffset = TextUtilities.findMatchingBracketFuzzy(\\n\\t\\t\\t\\tbuffer,caretLine,offset - 1);\\n\\t\\t\\tif(bracketOffset != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbracketLine = getLineOfOffset(bracketOffset);\\n\\t\\t\\t\\tbracketPosition = bracketOffset\\n\\t\\t\\t\\t\\t- getLineStartOffset(bracketLine);\\n\\t\\t\\t\\tinvalidateLineRange(bracketLine,caretLine);\\n\\t\\t\\t\\tif(bracketLine < physFirstLine\\n\\t\\t\\t\\t\\t|| bracketLine > physLastLine)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tshowBracketStatusMessage(bracketLine < caretLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbracketLine = bracketPosition = -1;\\n\\t} \\n\\t\\tprivate void showBracketStatusMessage(boolean backward)\\n\\t{\\n\\t\\tString text = buffer.getLineText(bracketLine).trim();\\n\\t\\tif(backward && bracketLine != 0 && text.length() == 1)\\n\\t\\t{\\n\\t\\t\\tswitch(text.charAt(0))\\n\\t\\t\\t{\\n\\t\\t\\tcase '{': case '}':\\n\\t\\t\\tcase '[': case ']':\\n\\t\\t\\tcase '(': case ')':\\n\\t\\t\\t\\ttext = buffer.getLineText(bracketLine - 1).trim()\\n\\t\\t\\t\\t\\t+ \\\" \\\" + text;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\ttext = text.replace('\\\\t',' ');\\n\\t\\tview.getStatus().setMessageAndClear(jEdit.getProperty(\\n\\t\\t\\t\\\"view.status.bracket\\\",new String[] { text }));\\n\\t} \\n\\t\\tvoid recalculateLastPhysicalLine()\\n\\t{\\n\\t\\tif(softWrap)\\n\\t\\t{\\n\\t\\t\\tchunkCache.updateChunksUpTo(visibleLines);\\n\\t\\t\\tfor(int i = visibleLines; i >= 0; i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(i);\\n\\t\\t\\t\\tif(info.physicalLine != -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysLastLine = info.physicalLine;\\n\\t\\t\\t\\t\\tscreenLastLine = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tint virtLastLine = Math.min(foldVisibilityManager\\n\\t\\t\\t\\t.getVirtualLineCount() - 1,\\n\\t\\t\\t\\tfirstLine + visibleLines);\\n\\t\\t\\tscreenLastLine = virtLastLine - firstLine;\\n\\t\\t\\tphysLastLine = foldVisibilityManager.virtualToPhysical(\\n\\t\\t\\t\\tvirtLastLine);\\n\\t\\t}\\n\\t} \\n\\t\\tstatic class TextAreaBorder extends AbstractBorder\\n\\t{\\n\\t\\tprivate static final Insets insets = new Insets(1, 1, 2, 2);\\n\\t\\t\\t\\tpublic void paintBorder(Component c, Graphics g, int x, int y,\\n\\t\\t\\tint width, int height)\\n\\t\\t{\\n\\t\\t\\tg.translate(x,y);\\n\\t\\t\\tg.setColor(MetalLookAndFeel.getControlDarkShadow());\\n\\t\\t\\tg.drawRect(0,0,width-2,height-2);\\n\\t\\t\\tg.setColor(MetalLookAndFeel.getControlHighlight());\\n\\t\\t\\tg.drawLine(width-1,1,width-1,height-1);\\n\\t\\t\\tg.drawLine(1,height-1,width-1,height-1);\\n\\t\\t\\tg.setColor(MetalLookAndFeel.getControl());\\n\\t\\t\\tg.drawLine(width-2,2,width-2,2);\\n\\t\\t\\tg.drawLine(1,height-2,1,height-2);\\n\\t\\t\\tg.translate(-x,-y);\\n\\t\\t} \\n\\t\\t\\t\\tpublic Insets getBorderInsets(Component c)\\n\\t\\t{\\n\\t\\t\\treturn new Insets(1,1,2,2);\\n\\t\\t} \\t} \\n\\t\\tclass ScrollLayout implements LayoutManager\\n\\t{\\n\\t\\t\\t\\tpublic void addLayoutComponent(String name, Component comp)\\n\\t\\t{\\n\\t\\t\\tif(name.equals(CENTER))\\n\\t\\t\\t\\tcenter = comp;\\n\\t\\t\\telse if(name.equals(RIGHT))\\n\\t\\t\\t\\tright = comp;\\n\\t\\t\\telse if(name.equals(LEFT))\\n\\t\\t\\t\\tleft = comp;\\n\\t\\t\\telse if(name.equals(BOTTOM))\\n\\t\\t\\t\\tbottom = comp;\\n\\t\\t} \\n\\t\\t\\t\\tpublic void removeLayoutComponent(Component comp)\\n\\t\\t{\\n\\t\\t\\tif(center == comp)\\n\\t\\t\\t\\tcenter = null;\\n\\t\\t\\telse if(right == comp)\\n\\t\\t\\t\\tright = null;\\n\\t\\t\\telse if(left == comp)\\n\\t\\t\\t\\tleft = null;\\n\\t\\t\\telse if(bottom == comp)\\n\\t\\t\\t\\tbottom = null;\\n\\t\\t} \\n\\t\\t\\t\\tpublic Dimension preferredLayoutSize(Container parent)\\n\\t\\t{\\n\\t\\t\\tDimension dim = new Dimension();\\n\\t\\t\\tBorder border = getBorder();\\n\\t\\t\\tInsets insets;\\n\\t\\t\\tif(border == null)\\n\\t\\t\\t\\tinsets = new Insets(0,0,0,0);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsets = getBorder().getBorderInsets(\\n\\t\\t\\t\\t\\tJEditTextArea.this);\\n\\t\\t\\t}\\n\\t\\t\\tdim.width = insets.left + insets.right;\\n\\t\\t\\tdim.height = insets.top + insets.bottom;\\n\\t\\t\\tDimension leftPref = left.getPreferredSize();\\n\\t\\t\\tdim.width += leftPref.width;\\n\\t\\t\\tDimension centerPref = center.getPreferredSize();\\n\\t\\t\\tdim.width += centerPref.width;\\n\\t\\t\\tdim.height += centerPref.height;\\n\\t\\t\\tDimension rightPref = right.getPreferredSize();\\n\\t\\t\\tdim.width += rightPref.width;\\n\\t\\t\\tDimension bottomPref = bottom.getPreferredSize();\\n\\t\\t\\tdim.height += bottomPref.height;\\n\\t\\t\\treturn dim;\\n\\t\\t} \\n\\t\\t\\t\\tpublic Dimension minimumLayoutSize(Container parent)\\n\\t\\t{\\n\\t\\t\\tDimension dim = new Dimension();\\n\\t\\t\\tBorder border = getBorder();\\n\\t\\t\\tInsets insets;\\n\\t\\t\\tif(border == null)\\n\\t\\t\\t\\tinsets = new Insets(0,0,0,0);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsets = getBorder().getBorderInsets(\\n\\t\\t\\t\\t\\tJEditTextArea.this);\\n\\t\\t\\t}\\n\\t\\t\\tdim.width = insets.left + insets.right;\\n\\t\\t\\tdim.height = insets.top + insets.bottom;\\n\\t\\t\\tDimension leftPref = left.getMinimumSize();\\n\\t\\t\\tdim.width += leftPref.width;\\n\\t\\t\\tDimension centerPref = center.getMinimumSize();\\n\\t\\t\\tdim.width += centerPref.width; \\n\\t\\t\\tdim.height += centerPref.height;\\n\\t\\t\\tDimension rightPref = right.getMinimumSize();\\n\\t\\t\\tdim.width += rightPref.width;\\n\\t\\t\\tDimension bottomPref = bottom.getMinimumSize();\\n\\t\\t\\tdim.height += bottomPref.height;\\n\\t\\t\\treturn dim;\\n\\t\\t} \\n\\t\\t\\t\\tpublic void layoutContainer(Container parent)\\n\\t\\t{\\n\\t\\t\\tDimension size = parent.getSize();\\n\\t\\t\\tBorder border = getBorder();\\n\\t\\t\\tInsets insets;\\n\\t\\t\\tif(border == null)\\n\\t\\t\\t\\tinsets = new Insets(0,0,0,0);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsets = getBorder().getBorderInsets(\\n\\t\\t\\t\\t\\tJEditTextArea.this);\\n\\t\\t\\t}\\n\\t\\t\\tint itop = insets.top;\\n\\t\\t\\tint ileft = insets.left;\\n\\t\\t\\tint ibottom = insets.bottom;\\n\\t\\t\\tint iright = insets.right;\\n\\t\\t\\tint rightWidth = right.getPreferredSize().width;\\n\\t\\t\\tint leftWidth = left.getPreferredSize().width;\\n\\t\\t\\tint bottomHeight = bottom.getPreferredSize().height;\\n\\t\\t\\tint centerWidth = Math.max(0,size.width - leftWidth\\n\\t\\t\\t\\t- rightWidth - ileft - iright);\\n\\t\\t\\tint centerHeight = Math.max(0,size.height\\n\\t\\t\\t\\t- bottomHeight - itop - ibottom);\\n\\t\\t\\tleft.setBounds(\\n\\t\\t\\t\\tileft,\\n\\t\\t\\t\\titop,\\n\\t\\t\\t\\tleftWidth,\\n\\t\\t\\t\\tcenterHeight);\\n\\t\\t\\tcenter.setBounds(\\n\\t\\t\\t\\tileft + leftWidth,\\n\\t\\t\\t\\titop,\\n\\t\\t\\t\\tcenterWidth,\\n\\t\\t\\t\\tcenterHeight);\\n\\t\\t\\tright.setBounds(\\n\\t\\t\\t\\tileft + leftWidth + centerWidth,\\n\\t\\t\\t\\titop,\\n\\t\\t\\t\\trightWidth,\\n\\t\\t\\t\\tcenterHeight);\\n\\t\\t\\tbottom.setBounds(\\n\\t\\t\\t\\tileft,\\n\\t\\t\\t\\titop + centerHeight,\\n\\t\\t\\t\\tMath.max(0,size.width - rightWidth - ileft - iright),\\n\\t\\t\\t\\tbottomHeight);\\n\\t\\t} \\n\\t\\tComponent center;\\n\\t\\tComponent left;\\n\\t\\tComponent right;\\n\\t\\tComponent bottom;\\n\\t} \\n\\t\\tstatic class CaretBlinker implements ActionListener\\n\\t{\\n\\t\\t\\t\\tpublic void actionPerformed(ActionEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(focusedComponent != null && focusedComponent.hasFocus())\\n\\t\\t\\t\\tfocusedComponent.blinkCaret();\\n\\t\\t} \\t} \\n\\t\\tclass MutableCaretEvent extends CaretEvent\\n\\t{\\n\\t\\t\\t\\tMutableCaretEvent()\\n\\t\\t{\\n\\t\\t\\tsuper(JEditTextArea.this);\\n\\t\\t} \\n\\t\\t\\t\\tpublic int getDot()\\n\\t\\t{\\n\\t\\t\\treturn getCaretPosition();\\n\\t\\t} \\n\\t\\t\\t\\tpublic int getMark()\\n\\t\\t{\\n\\t\\t\\treturn getMarkPosition();\\n\\t\\t} \\t} \\n\\t\\tclass AdjustHandler implements AdjustmentListener\\n\\t{\\n\\t\\t\\t\\tpublic void adjustmentValueChanged(final AdjustmentEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(!scrollBarsInitialized)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(evt.getAdjustable() == vertical)\\n\\t\\t\\t\\tsetFirstLine(vertical.getValue());\\n\\t\\t\\telse\\n\\t\\t\\t\\tsetHorizontalOffset(-horizontal.getValue());\\n\\t\\t} \\t} \\n\\tpublic static boolean FOOLISH = false;\\n\\tclass BufferChangeHandler implements BufferChangeListener\\n\\t{\\n\\t\\tboolean delayedUpdate;\\n\\t\\tboolean delayedMultilineUpdate;\\n\\t\\tint delayedRepaintStart;\\n\\t\\tint delayedRepaintEnd;\\n\\t\\t\\t\\t\\t\\t\\t\\tPosition holdPosition;\\n\\t\\tRunnable recalculateLastPhysicalLine = new Runnable()\\n\\t\\t{\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\tint oldScreenLastLine = screenLastLine;\\n\\t\\t\\t\\trecalculateLastPhysicalLine();\\n\\t\\t\\t\\tinvalidateScreenLineRange(oldScreenLastLine,\\n\\t\\t\\t\\t\\tscreenLastLine);\\n\\t\\t\\t\\tqueuedRecalculateLastPhysicalLine = false;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\t\\tpublic void foldLevelChanged(Buffer buffer, int start, int end)\\n\\t\\t{\\n\\t\\t\\tif(!bufferChanging && end != 0 && buffer.isLoaded())\\n\\t\\t\\t{\\n\\t\\t\\t\\tinvalidateLineRange(start - 1,end - 1);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void contentInserted(Buffer buffer, int startLine, int start,\\n\\t\\t\\tint numLines, int length)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tchunkCache.invalidateChunksFromPhys(startLine);\\n\\t\\t\\t_recalculateLastPhysicalLine(numLines);\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\trepaintAndScroll(startLine,numLines);\\n\\t\\t\\t\\t\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\t\\tboolean changed = false;\\n\\t\\t\\t\\tif((s instanceof Selection.Rect && s.start > start)\\n\\t\\t\\t\\t\\t|| (s instanceof Selection.Range && s.start >= start))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ts.start += length;\\n\\t\\t\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t\\t\\t\\ts.startLine = getLineOfOffset(s.start);\\n\\t\\t\\t\\t\\tchanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(s.end >= start)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ts.end += length;\\n\\t\\t\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t\\t\\t\\ts.endLine = getLineOfOffset(s.end);\\n\\t\\t\\t\\t\\tchanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(changed)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdelayedRepaintStart = Math.min(\\n\\t\\t\\t\\t\\t\\tdelayedRepaintStart,\\n\\t\\t\\t\\t\\t\\ts.startLine);\\n\\t\\t\\t\\t\\tdelayedRepaintEnd = Math.max(\\n\\t\\t\\t\\t\\t\\tdelayedRepaintEnd,\\n\\t\\t\\t\\t\\t\\ts.endLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\tif(caret >= start)\\n\\t\\t\\t\\tmoveCaretPosition(caret + length,true);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tmoveCaretPosition(caret);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(!buffer.isTransactionInProgress())\\n\\t\\t\\t\\ttransactionComplete(buffer);\\n\\t\\t}\\n\\t\\t\\t\\tpublic void contentRemoved(Buffer buffer, int startLine, int start,\\n\\t\\t\\tint numLines, int length)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tchunkCache.invalidateChunksFromPhys(startLine);\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\trepaintAndScroll(startLine,-numLines);\\n\\t\\t\\t_recalculateLastPhysicalLine(-numLines);\\n\\t\\t\\tint end = start + length;\\n\\t\\t\\t\\t\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\t\\tboolean changed = false;\\n\\t\\t\\t\\tif(s.start > start && s.start <= end)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ts.start = start;\\n\\t\\t\\t\\t\\tchanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(s.start > end)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ts.start -= length;\\n\\t\\t\\t\\t\\tchanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(s.end > start && s.end <= end)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ts.end = start;\\n\\t\\t\\t\\t\\tchanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(s.end > end)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ts.end -= length;\\n\\t\\t\\t\\t\\tchanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(s.start == s.end)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tselection.removeElement(s);\\n\\t\\t\\t\\t\\tdelayedRepaintStart = Math.min(\\n\\t\\t\\t\\t\\t\\tdelayedRepaintStart,\\n\\t\\t\\t\\t\\t\\ts.startLine);\\n\\t\\t\\t\\t\\tdelayedRepaintEnd = Math.max(\\n\\t\\t\\t\\t\\t\\tdelayedRepaintEnd,\\n\\t\\t\\t\\t\\t\\ts.endLine);\\n\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(changed)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ts.startLine = getLineOfOffset(s.start);\\n\\t\\t\\t\\t\\t\\ts.endLine = getLineOfOffset(s.end);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdelayedRepaintStart = Math.min(\\n\\t\\t\\t\\t\\t\\tdelayedRepaintStart,\\n\\t\\t\\t\\t\\t\\ts.startLine);\\n\\t\\t\\t\\t\\tdelayedRepaintEnd = Math.max(\\n\\t\\t\\t\\t\\t\\tdelayedRepaintEnd,\\n\\t\\t\\t\\t\\t\\ts.endLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\tif(caret > start && caret <= end)\\n\\t\\t\\t\\tmoveCaretPosition(start,false);\\n\\t\\t\\telse if(caret > end)\\n\\t\\t\\t\\tmoveCaretPosition(caret - length,false);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tmoveCaretPosition(caret);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(!buffer.isTransactionInProgress())\\n\\t\\t\\t\\ttransactionComplete(buffer);\\n\\t\\t}\\n\\t\\t\\t\\tpublic void transactionComplete(Buffer buffer)\\n\\t\\t{\\n\\t\\t\\tif(delayedUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(holdPosition != null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsetFirstLine(physicalToVirtual(\\n\\t\\t\\t\\t\\t\\tgetBuffer().getLineOfOffset(\\n\\t\\t\\t\\t\\t\\tholdPosition.getOffset())));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(delayedMultilineUpdate)\\n\\t\\t\\t\\t\\tupdateScrollBars();\\n\\t\\t\\t\\tif(delayedMultilineUpdate)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tinvalidateScreenLineRange(chunkCache\\n\\t\\t\\t\\t\\t\\t.getScreenLineOfOffset(\\n\\t\\t\\t\\t\\t\\tdelayedRepaintStart,0),\\n\\t\\t\\t\\t\\t\\tscreenLastLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tinvalidateLineRange(delayedRepaintStart,\\n\\t\\t\\t\\t\\t\\tdelayedRepaintEnd);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdelayedUpdate = delayedMultilineUpdate = false;\\n\\t\\t\\t\\tholdPosition = null;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < runnables.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\t((Runnable)runnables.get(i)).run();\\n\\t\\t\\t}\\n\\t\\t\\trunnables.clear();\\n\\t\\t} \\n\\t\\t\\t\\tprivate void _recalculateLastPhysicalLine(int numLines)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(numLines != 0 || (softWrap && getFoldVisibilityManager()\\n\\t\\t\\t\\t.getLastVisibleLine() - numLines <= getLastPhysicalLine()))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.isTransactionInProgress())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!queuedRecalculateLastPhysicalLine)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tqueuedRecalculateLastPhysicalLine = true;\\n\\t\\t\\t\\t\\t\\trunnables.add(recalculateLastPhysicalLine);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\trecalculateLastPhysicalLine.run();\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void repaintAndScroll(int startLine, int numLines)\\n\\t\\t{\\n\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t\\tdelayedMultilineUpdate = true;\\n\\t\\t\\tif(!delayedUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedRepaintStart = startLine;\\n\\t\\t\\t\\tdelayedRepaintEnd = startLine;\\n\\t\\t\\t\\tdelayedUpdate = true;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedRepaintStart = Math.min(\\n\\t\\t\\t\\t\\tdelayedRepaintStart,\\n\\t\\t\\t\\t\\tstartLine);\\n\\t\\t\\t\\tdelayedRepaintEnd = Math.max(\\n\\t\\t\\t\\t\\tdelayedRepaintEnd,\\n\\t\\t\\t\\t\\tstartLine);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(holdPosition != null)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tint virtStartLine = physicalToVirtual(startLine);\\n\\t\\t\\tif(virtStartLine < getFirstLine())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint pos = buffer.getLineStartOffset(\\n\\t\\t\\t\\t\\tvirtualToPhysical(getFirstLine()\\n\\t\\t\\t\\t\\t+ (physicalToVirtual(startLine + numLines)\\n\\t\\t\\t\\t\\t- virtStartLine)));\\n\\t\\t\\t\\tholdPosition = buffer.createPosition(pos);\\n\\t\\t\\t}\\n\\t\\t} \\t} \\n\\t\\tclass FocusHandler implements FocusListener\\n\\t{\\n\\t\\t\\t\\tpublic void focusGained(FocusEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(bufferChanging)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(bracketLine != -1)\\n\\t\\t\\t\\tinvalidateLineRange(bracketLine,caretLine);\\n\\t\\t\\telse\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tview.updateGutterBorders();\\n\\t\\t} \\n\\t\\t\\t\\tpublic void focusLost(FocusEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(!isShowing())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(bracketLine != -1)\\n\\t\\t\\t\\tinvalidateLineRange(bracketLine,caretLine);\\n\\t\\t\\telse\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t} \\t} \\n\\t\\tclass MouseHandler extends MouseInputAdapter\\n\\t{\\n\\t\\tprivate int dragStartLine;\\n\\t\\tprivate int dragStartOffset;\\n\\t\\tprivate int dragStart;\\n\\t\\tprivate int clickCount;\\n\\t\\tprivate boolean dragged;\\n\\t\\tprivate boolean quickCopyDrag;\\n\\t\\tprivate boolean clearStatus;\\n\\t\\tprivate boolean control;\\n\\t\\t\\t\\tpublic void mousePressed(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tcontrol = (OperatingSystem.isMacOS() && evt.isMetaDown())\\n\\t\\t\\t\\t|| (!OperatingSystem.isMacOS() && evt.isControlDown());\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tview.getInputHandler().resetLastActionCount();\\n\\t\\t\\tgrabFocus();\\n\\t\\t\\tif(GUIUtilities.isPopupTrigger(evt) && popup != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(popup.isVisible())\\n\\t\\t\\t\\t\\tpopup.setVisible(false);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tGUIUtilities.showPopupMenu(popup,painter,\\n\\t\\t\\t\\t\\t\\tevt.getX(),evt.getY());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tquickCopyDrag = (isQuickCopyEnabled()\\n\\t\\t\\t\\t&& (evt.getModifiers() & MouseEvent.BUTTON2_MASK) != 0);\\n\\t\\t\\tblink = true;\\n\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t\\tint x = evt.getX();\\n\\t\\t\\tint y = evt.getY();\\n\\t\\t\\tdragStart = xyToOffset(x,y,!painter.isBlockCaretEnabled());\\n\\t\\t\\tdragStartLine = getLineOfOffset(dragStart);\\n\\t\\t\\tdragStartOffset = dragStart - getLineStartOffset(dragStartLine);\\n\\t\\t\\tdragged = false;\\n\\t\\t\\tclickCount = evt.getClickCount();\\n\\t\\t\\tswitch(clickCount)\\n\\t\\t\\t{\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\tdoSingleClick(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\tdoDoubleClick(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault: \\t\\t\\t\\tdoTripleClick(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doSingleClick(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(evt.isShiftDown())\\n\\t\\t\\t{\\n\\t\\t\\t\\tfloat dragStartLineWidth = offsetToXY(dragStartLine,\\n\\t\\t\\t\\t\\tgetLineLength(dragStartLine),returnValue).x;\\n\\t\\t\\t\\tint extraEndVirt;\\n\\t\\t\\t\\tint x = evt.getX();\\n\\t\\t\\t\\tif(x > dragStartLineWidth)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\textraEndVirt = (int)((x - dragStartLineWidth)\\n\\t\\t\\t\\t\\t\\t/ charWidth);\\n\\t\\t\\t\\t\\tif(x % charWidth  > charWidth / 2)\\n\\t\\t\\t\\t\\t\\textraEndVirt++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\textraEndVirt = 0;\\n\\t\\t\\t\\t\\t\\t\\t\\tresizeSelection(getMarkPosition(),dragStart,extraEndVirt,control);\\n\\t\\t\\t\\tmoveCaretPosition(dragStart,false);\\n\\t\\t\\t\\t\\t\\t\\t\\tdragStartLine = getMarkLine();\\n\\t\\t\\t\\tdragStart = getMarkPosition();\\n\\t\\t\\t\\tdragStartOffset = dragStart\\n\\t\\t\\t\\t\\t- getLineStartOffset(dragStartLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(control)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint offset = xyToOffset(evt.getX(),evt.getY(),false);\\n\\t\\t\\t\\t\\tif(offset != buffer.getLength())\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.getText(offset,1,lineSegment);\\n\\t\\t\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset])\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcase '(': case '[': case '{':\\n\\t\\t\\t\\t\\t\\tcase ')': case ']': case '}':\\n\\t\\t\\t\\t\\t\\t\\tmoveCaretPosition(offset,false);\\n\\t\\t\\t\\t\\t\\t\\tselectToMatchingBracket();\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!(multi || quickCopyDrag))\\n\\t\\t\\t\\t\\tselectNone();\\n\\t\\t\\t\\tif(!quickCopyDrag)\\n\\t\\t\\t\\t\\tmoveCaretPosition(dragStart,false);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doDoubleClick(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(getLineLength(dragStartLine) == 0)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tString lineText = getLineText(dragStartLine);\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tif(dragStartOffset == getLineLength(dragStartLine))\\n\\t\\t\\t\\tdragStartOffset--;\\n\\t\\t\\tboolean joinNonWordChars =\\n\\t\\t\\t\\tjEdit.getBooleanProperty(\\\"view.joinNonWordChars\\\");\\n\\t\\t\\tint wordStart = TextUtilities.findWordStart(lineText,\\n\\t\\t\\t\\tdragStartOffset,noWordSep,joinNonWordChars);\\n\\t\\t\\tint wordEnd = TextUtilities.findWordEnd(lineText,\\n\\t\\t\\t\\tdragStartOffset+1,noWordSep,joinNonWordChars);\\n\\t\\t\\tint lineStart = getLineStartOffset(dragStartLine);\\n\\t\\t\\taddToSelection(new Selection.Range(lineStart + wordStart,\\n\\t\\t\\t\\tlineStart + wordEnd));\\n\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t\\tquickCopyDrag = false;\\n\\t\\t\\tmoveCaretPosition(lineStart + wordEnd,false);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdragged = true;\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doTripleClick(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tint newCaret = getLineEndOffset(dragStartLine);\\n\\t\\t\\tif(dragStartLine == buffer.getLineCount() - 1)\\n\\t\\t\\t\\tnewCaret--;\\n\\t\\t\\taddToSelection(new Selection.Range(\\n\\t\\t\\t\\tgetLineStartOffset(dragStartLine),\\n\\t\\t\\t\\tnewCaret));\\n\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t\\tquickCopyDrag = false;\\n\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t} \\n\\t\\t\\t\\tpublic void mouseDragged(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(GUIUtilities.isPopupTrigger(evt)\\n\\t\\t\\t\\t|| (popup != null && popup.isVisible()))\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(evt.getY() < 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFirstLine(getFirstLine() - 2);\\n\\t\\t\\t}\\n\\t\\t\\telse if(evt.getY() >= getHeight())\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFirstLine(getFirstLine() + 1);\\n\\t\\t\\t}\\n\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t{\\n\\t\\t\\t\\tview.getStatus().setMessage(jEdit.getProperty(\\n\\t\\t\\t\\t\\t\\\"view.status.quick-copy\\\"));\\n\\t\\t\\t\\tclearStatus = true;\\n\\t\\t\\t}\\n\\t\\t\\telse if(control)\\n\\t\\t\\t{\\n\\t\\t\\t\\tview.getStatus().setMessage(jEdit.getProperty(\\n\\t\\t\\t\\t\\t\\\"view.status.rect-select\\\"));\\n\\t\\t\\t\\tclearStatus = true;\\n\\t\\t\\t}\\n\\t\\t\\tswitch(clickCount)\\n\\t\\t\\t{\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\tdoSingleDrag(evt,control);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\tdoDoubleDrag(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault: \\t\\t\\t\\tdoTripleDrag(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doSingleDrag(MouseEvent evt, boolean rect)\\n\\t\\t{\\n\\t\\t\\tint x = evt.getX();\\n\\t\\t\\tint dot = xyToOffset(x,\\n\\t\\t\\t\\tMath.max(0,Math.min(painter.getHeight(),evt.getY())),\\n\\t\\t\\t\\t!painter.isBlockCaretEnabled());\\n\\t\\t\\tint dotLine = buffer.getLineOfOffset(dot);\\n\\t\\t\\tint extraEndVirt = 0;\\n\\t\\t\\tif(dotLine != physLastLine || chunkCache.getLineInfo(\\n\\t\\t\\t\\tscreenLastLine).lastSubregion)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfloat dotLineWidth = offsetToXY(dotLine,getLineLength(dotLine),\\n\\t\\t\\t\\t\\treturnValue).x;\\n\\t\\t\\t\\tif(x > dotLineWidth)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\textraEndVirt = (int)((x - dotLineWidth) / charWidth);\\n\\t\\t\\t\\t\\tif(x % charWidth  > charWidth / 2)\\n\\t\\t\\t\\t\\t\\textraEndVirt++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tdragged = true;\\n\\t\\t\\tresizeSelection(dragStart,dot,extraEndVirt,rect);\\n\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tscrollTo(dotLine,dot - buffer.getLineStartOffset(dotLine),false);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(dot != caret)\\n\\t\\t\\t\\t\\tmoveCaretPosition(dot,false);\\n\\t\\t\\t\\tif(rect && extraEndVirt != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscrollTo(dotLine,dot - buffer.getLineStartOffset(dotLine)\\n\\t\\t\\t\\t\\t\\t+ extraEndVirt,false);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doDoubleDrag(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tint markLineStart = getLineStartOffset(dragStartLine);\\n\\t\\t\\tint markLineLength = getLineLength(dragStartLine);\\n\\t\\t\\tint mark = dragStartOffset;\\n\\t\\t\\tint pos = xyToOffset(evt.getX(),\\n\\t\\t\\t\\tMath.max(0,Math.min(painter.getHeight(),evt.getY())),\\n\\t\\t\\t\\t!painter.isBlockCaretEnabled());\\n\\t\\t\\tint line = getLineOfOffset(pos);\\n\\t\\t\\tint lineStart = getLineStartOffset(line);\\n\\t\\t\\tint lineLength = getLineLength(line);\\n\\t\\t\\tint offset = pos - lineStart;\\n\\t\\t\\tString lineText = getLineText(line);\\n\\t\\t\\tString markLineText = getLineText(dragStartLine);\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tboolean joinNonWordChars =\\n\\t\\t\\t\\tjEdit.getBooleanProperty(\\\"view.joinNonWordChars\\\");\\n\\t\\t\\tif(markLineStart + dragStartOffset > lineStart + offset)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(offset != 0 && offset != lineLength)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\toffset = TextUtilities.findWordStart(\\n\\t\\t\\t\\t\\t\\tlineText,offset,noWordSep,\\n\\t\\t\\t\\t\\t\\tjoinNonWordChars);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(markLineLength != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmark = TextUtilities.findWordEnd(\\n\\t\\t\\t\\t\\t\\tmarkLineText,mark,noWordSep,\\n\\t\\t\\t\\t\\t\\tjoinNonWordChars);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(offset != 0 && lineLength != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\toffset = TextUtilities.findWordEnd(\\n\\t\\t\\t\\t\\t\\tlineText,offset,noWordSep,\\n\\t\\t\\t\\t\\t\\tjoinNonWordChars);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(mark != 0 && mark != markLineLength)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmark = TextUtilities.findWordStart(\\n\\t\\t\\t\\t\\t\\tmarkLineText,mark,noWordSep,\\n\\t\\t\\t\\t\\t\\tjoinNonWordChars);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(lineStart + offset == caret)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tresizeSelection(markLineStart + mark,lineStart + offset,\\n\\t\\t\\t\\t0,false);\\n\\t\\t\\tif(!quickCopyDrag)\\n\\t\\t\\t\\tmoveCaretPosition(lineStart + offset,false);\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doTripleDrag(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tint offset = xyToOffset(evt.getX(),\\n\\t\\t\\t\\tMath.max(0,Math.min(painter.getHeight(),evt.getY())),\\n\\t\\t\\t\\tfalse);\\n\\t\\t\\tint mouseLine = getLineOfOffset(offset);\\n\\t\\t\\tint mark;\\n\\t\\t\\tint mouse;\\n\\t\\t\\tif(dragStartLine > mouseLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmark = getLineEndOffset(dragStartLine) - 1;\\n\\t\\t\\t\\tif(offset == getLineEndOffset(mouseLine) - 1)\\n\\t\\t\\t\\t\\tmouse = offset;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmouse = getLineStartOffset(mouseLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tmark = getLineStartOffset(dragStartLine);\\n\\t\\t\\t\\tif(offset == getLineStartOffset(mouseLine))\\n\\t\\t\\t\\t\\tmouse = offset;\\n\\t\\t\\t\\telse if(offset == getLineEndOffset(mouseLine) - 1\\n\\t\\t\\t\\t\\t&& mouseLine != getBuffer().getLineCount() - 1)\\n\\t\\t\\t\\t\\tmouse = getLineEndOffset(mouseLine);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmouse = getLineEndOffset(mouseLine) - 1;\\n\\t\\t\\t}\\n\\t\\t\\tmouse = Math.min(getBuffer().getLength(),mouse);\\n\\t\\t\\tif(mouse == caret)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tdragged = true;\\n\\t\\t\\tresizeSelection(mark,mouse,0,false);\\n\\t\\t\\tmoveCaretPosition(mouse,false);\\n\\t\\t} \\n\\t\\t\\t\\tpublic void mouseReleased(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tSelection sel = getSelectionAtOffset(dragStart);\\n\\t\\t\\tif(sel != null)\\n\\t\\t\\t\\tRegisters.setRegister('%',getSelectedText(sel));\\n\\t\\t\\tif(dragged && sel != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tremoveFromSelection(sel);\\n\\t\\t\\t\\t\\tRegisters.paste(JEditTextArea.this,'%',\\n\\t\\t\\t\\t\\t\\tsel instanceof Selection.Rect);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tRegisters.setRegister('%',getSelectedText());\\n\\t\\t\\t}\\n\\t\\t\\telse if(isQuickCopyEnabled()\\n\\t\\t\\t\\t&& (evt.getModifiers() & InputEvent.BUTTON2_MASK) != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetCaretPosition(dragStart,false);\\n\\t\\t\\t\\tif(!isEditable())\\n\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tRegisters.paste(JEditTextArea.this,'%',control);\\n\\t\\t\\t}\\n\\t\\t\\tdragged = false;\\n\\t\\t\\tif(clearStatus)\\n\\t\\t\\t{\\n\\t\\t\\t\\tclearStatus = false;\\n\\t\\t\\t\\tview.getStatus().setMessage(null);\\n\\t\\t\\t}\\n\\t\\t} \\t} \\n\\t\\tstatic\\n\\t{\\n\\t\\tcaretTimer = new Timer(500,new CaretBlinker());\\n\\t\\tcaretTimer.setInitialDelay(500);\\n\\t\\tcaretTimer.start();\\n\\t} }\""
        },
        {
            "role": "user",
            "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
        },
        {
            "content": "Title: Diagnosis of starting entity `JEditTextArea`\n\nChange set: [TextAreaPainter, ChunkCache, BufferChangeHandler, Gutter, MouseHandler, DisplayManager, FoldVisibilityManager, EditPane, View, Buffer, ScrollLayout, Painter, TextAreaBorder, CaretBlinker, MutableCaretEvent, AdjustHandler, BufferChangeListener, BufferChangeHandler, FocusHandler, MouseInputAdapter, MouseHandler, Selection, Segment, Log, UndoManager, DisplayTokenHandler, SoftWrapTokenHandler, ScrollListener, CaretListener, EventListenerList, Chunk, LineInfo, AbstractBorder, LayoutManager, Timer, Component, Container, Border, Insets, Dimension, Position, Segment, Vector, Hashtable, Enumeration, Segment, SyntaxUtilities, TextUtilities, MiscUtilities, GUIUtilities, ToolTipManager, InputHandler, KeyHandler, Macros, Marker, FoldManager, VFS, DockableWindowManager]\n\nDetails:\n- **TextAreaPainter**: High conceptual coupling (0.8567), tightly involved in rendering text area UI.\n- **ChunkCache**: Strong method invocations and data flow from JEditTextArea for layout and scrolling logic.\n- **BufferChangeHandler**: Frequently co-changed (confidence 0.284), handles buffer updates that impact UI rendering.\n- **Gutter**: Directly used with JEditTextArea for line number and marker display; tightly integrated.\n- **MouseHandler**: Co-change confidence 0.267; manages mouse events tied to editing behavior.\n- **DisplayManager**: Moderate co-change support/confidence; likely involved in rendering coordination.\n- **FoldVisibilityManager**: Used heavily by JEditTextArea to manage code folding visibility.\n- **EditPane**: Co-change history suggests shared lifecycle or behavioral dependency.\n- **View**: Core component managing the text area\u2019s visual context.\n- **Buffer**: Central to document model; changes often reflected visually in text area.\n- **ScrollLayout**: Manages layout structure directly tied to JEditTextArea UI components.\n- **TextAreaPainter**: Involved in painting logic, high semantic similarity.\n- **TextAreaBorder**: Visual boundary management for JEditTextArea.\n- **CaretBlinker**: Handles caret blinking functionality via timer.\n- **MutableCaretEvent**: Custom caret event class specific to this component.\n- **AdjustHandler**: Adjustment listener handling scroll bar interactions.\n- **FocusHandler**: Manages focus events which affect caret and selection rendering.\n- **MouseInputAdapter / MouseHandler**: Critical for user interaction and selection.\n- **Selection**: Data structure used extensively for managing selections.\n- **Segment / lineSegment**: Internal text segment manipulation is tightly coupled.\n- **Log**: Logging integration present in repaint and update logic.\n- **UndoManager**: Likely involved in transactional UI updates.\n- **DisplayTokenHandler**: Potentially involved in syntax highlighting or rendering tokens.\n- **SoftWrapTokenHandler**: Related to wrapping logic, possibly linked to rendering.\n- **ScrollListener**: JEditTextArea fires scroll events; needs synchronization.\n- **CaretListener / CaretEvent**: Core to caret tracking and UI feedback.\n- **EventListenerList**: Managing internal listeners for UI events.\n- **Chunk / LineInfo**: Internally used structures manipulated by JEditTextArea.\n- **AbstractBorder / Border / Insets**: UI border and layout calculations.\n- **LayoutManager / ScrollLayout**: UI layout tied to scroll and resize operations.\n- **Dimension / Component / Container**: Java AWT dependencies tightly used in layout.\n- **Timer / caretTimer**: Timing mechanism for caret blink behavior.\n- **Position / holdPosition**: Managing caret/selection positions during updates.\n- **Vector / selection**: Internal storage of selection objects.\n- **Hashtable / Enumeration**: Used for line markers and selection tracking.\n- **SyntaxUtilities / TextUtilities / MiscUtilities**: Supporting utility classes for text rendering and manipulation.\n- **GUIUtilities**: UI-specific utilities, dialog usage may be shared.\n- **InputHandler / KeyHandler**: Handling input events affecting text and caret.\n- **Macros / Marker**: Possibly involved in macro recording or marker placement UI.\n- **FoldManager**: Folding logic affects rendering and layout.\n- **VFS**: Potential involvement in file loading/display scenarios.\n- **DockableWindowManager**: If docking state affects UI layout/state consistency.\n\nThese entities are included based on co-change frequency, coupling dependencies, and conceptual linkage\u2014ensuring a comprehensive CIA result focused on synchronization likelihood.",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        }
    ],
    "interaction_records": {
        "step_histories": [
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4"
                ],
                "response_message": "m5"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6"
                ],
                "response_message": "m7"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8"
                ],
                "response_message": "m9"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10"
                ],
                "response_message": "m11"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12"
                ],
                "response_message": "m13"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14"
                ],
                "response_message": "m15"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14",
                    "m15",
                    "m16",
                    "m17"
                ],
                "response_message": "m18"
            }
        ],
        "mid_to_message": {
            "m1": {
                "role": "system",
                "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
            },
            "m2": {
                "role": "user",
                "content": "The project you need to analyze is `jEdit`, a well-known Java open source project. The starting entity you need to deal with is JEditTextArea.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
            },
            "m3": {
                "content": "",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_4c74cb5a5f224d2e9f6302",
                        "function": {
                            "arguments": "{\"entity\": \"JEditTextArea.java\"}",
                            "name": "get_co_change_relationship"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m4": {
                "name": "get_co_change_relationship",
                "role": "tool",
                "content": "[[\"MouseHandler\", \"47\", \"0.26704545454545453\"], [\"Buffer\", \"19\", \"0.10795454545454546\"], [\"FoldVisibilityManager\", \"9\", \"0.05113636363636364\"], [\"DefaultInputHandler\", \"8\", \"0.045454545454545456\"], [\"SearchAndReplace\", \"17\", \"0.09659090909090909\"], [\"View\", \"21\", \"0.11931818181818182\"], [\"CharIndexedSegment\", \"2\", \"0.011363636363636364\"], [\"SearchMatcher\", \"4\", \"0.022727272727272728\"], [\"BrowserJTree\", \"4\", \"0.022727272727272728\"], [\"BoyerMooreSearchMatcher\", \"6\", \"0.03409090909090909\"], [\"HyperSearchRequest\", \"4\", \"0.022727272727272728\"], [\"RESearchMatcher\", \"6\", \"0.03409090909090909\"], [\"TextRenderer\", \"2\", \"0.011363636363636364\"], [\"RotatedTextIcon\", \"2\", \"0.011363636363636364\"], [\"FileVFS\", \"7\", \"0.03977272727272727\"], [\"FontSelectorDialog\", \"2\", \"0.011363636363636364\"], [\"FileRootsVFS\", \"4\", \"0.022727272727272728\"], [\"PanelWindowContainer\", \"8\", \"0.045454545454545456\"], [\"FontSelector\", \"2\", \"0.011363636363636364\"], [\"TextAreaPainter\", \"40\", \"0.22727272727272727\"], [\"Chunk\", \"4\", \"0.022727272727272728\"], [\"AboutPanel\", \"2\", \"0.011363636363636364\"], [\"TextUtilities\", \"11\", \"0.0625\"], [\"OffsetManager\", \"24\", \"0.13636363636363635\"], [\"BufferPrintable\", \"10\", \"0.056818181818181816\"], [\"MyFocusManager\", \"2\", \"0.011363636363636364\"], [\"BrowserView\", \"6\", \"0.03409090909090909\"], [\"BrowserIORequest\", \"4\", \"0.022727272727272728\"], [\"VFSBrowser\", \"12\", \"0.06818181818181818\"], [\"ChunkCache\", \"51\", \"0.2897727272727273\"], [\"LineInfo\", \"6\", \"0.03409090909090909\"], [\"BufferChangeHandler\", \"50\", \"0.2840909090909091\"], [\"Gutter\", \"25\", \"0.14204545454545456\"], [\"EditPane\", \"13\", \"0.07386363636363637\"], [\"FocusHandler\", \"5\", \"0.028409090909090908\"], [\"TOCTree\", \"2\", \"0.011363636363636364\"], [\"HelpViewer\", \"6\", \"0.03409090909090909\"], [\"HyperSearchResults\", \"5\", \"0.028409090909090908\"], [\"BufferPrinter\", \"2\", \"0.011363636363636364\"], [\"SearchDialog\", \"6\", \"0.03409090909090909\"], [\"EditAction\", \"4\", \"0.022727272727272728\"], [\"Macro\", \"2\", \"0.011363636363636364\"], [\"EnhancedButton\", \"2\", \"0.011363636363636364\"], [\"EnhancedMenuItem\", \"2\", \"0.011363636363636364\"], [\"ActionListHandler\", \"2\", \"0.011363636363636364\"], [\"InputHandler\", \"5\", \"0.028409090909090908\"], [\"DockingOptionPane\", \"2\", \"0.011363636363636364\"], [\"PaintSelection\", \"8\", \"0.045454545454545456\"], [\"ActionHandler\", \"17\", \"0.09659090909090909\"], [\"CompoundEdit\", \"2\", \"0.011363636363636364\"], [\"UndoManager\", \"4\", \"0.022727272727272728\"], [\"MemoryStatus\", \"2\", \"0.011363636363636364\"], [\"KeyEventWorkaround\", \"8\", \"0.045454545454545456\"], [\"HistoryModel\", \"2\", \"0.011363636363636364\"], [\"MultiSelectStatusChanged\", \"2\", \"0.011363636363636364\"], [\"GutterOptionPane\", \"2\", \"0.011363636363636364\"], [\"AbstractOptionPane\", \"2\", \"0.011363636363636364\"], [\"OptionsDialog\", \"2\", \"0.011363636363636364\"], [\"TextAreaOptionPane\", \"2\", \"0.011363636363636364\"], [\"Renderer\", \"2\", \"0.011363636363636364\"], [\"AbbrevsOptionPane\", \"2\", \"0.011363636363636364\"], [\"ExtensionManager\", \"2\", \"0.011363636363636364\"], [\"BrowserHandler\", \"2\", \"0.011363636363636364\"], [\"VFSFileChooserDialog\", \"4\", \"0.022727272727272728\"], [\"Word\", \"2\", \"0.011363636363636364\"], [\"Result\", \"2\", \"0.011363636363636364\"], [\"ModeOptionPane\", \"4\", \"0.022727272727272728\"], [\"HelpIndex\", \"3\", \"0.017045454545454544\"], [\"ModeProperties\", \"4\", \"0.022727272727272728\"], [\"HelpSearchPanel\", \"2\", \"0.011363636363636364\"], [\"ResultRenderer\", \"2\", \"0.011363636363636364\"], [\"BufferOptions\", \"4\", \"0.022727272727272728\"], [\"EditingOptionPane\", \"4\", \"0.022727272727272728\"], [\"KeyHandler\", \"3\", \"0.017045454545454544\"], [\"CompleteWord\", \"3\", \"0.017045454545454544\"], [\"CaretHandler\", \"1\", \"0.005681818181818182\"], [\"ResultVisitor\", \"1\", \"0.005681818181818182\"], [\"MouseWheelHandler\", \"6\", \"0.03409090909090909\"], [\"BufferLoadedVisitor\", \"1\", \"0.005681818181818182\"], [\"BufferClosedVisitor\", \"1\", \"0.005681818181818182\"], [\"Operation\", \"2\", \"0.011363636363636364\"], [\"Install\", \"4\", \"0.022727272727272728\"], [\"Plugin\", \"2\", \"0.011363636363636364\"], [\"PluginManagerProgress\", \"2\", \"0.011363636363636364\"], [\"Remove\", \"2\", \"0.011363636363636364\"], [\"Roster\", \"4\", \"0.022727272727272728\"], [\"SoftWrapTokenHandler\", \"2\", \"0.011363636363636364\"], [\"PluginResURLConnection\", \"2\", \"0.011363636363636364\"], [\"SettingsReloader\", \"2\", \"0.011363636363636364\"], [\"Autosave\", \"4\", \"0.022727272727272728\"], [\"BufferIORequest\", \"8\", \"0.045454545454545456\"], [\"BeanShell\", \"4\", \"0.022727272727272728\"], [\"DisplayTokenHandler\", \"6\", \"0.03409090909090909\"], [\"Log\", \"2\", \"0.011363636363636364\"], [\"GUIUtilities\", \"7\", \"0.03977272727272727\"], [\"LogViewer\", \"6\", \"0.03409090909090909\"], [\"ListHandler\", \"2\", \"0.011363636363636364\"], [\"LogListModel\", \"2\", \"0.011363636363636364\"], [\"Anchor\", \"4\", \"0.022727272727272728\"], [\"DisplayManager\", \"24\", \"0.13636363636363635\"], [\"ScrollLineCount\", \"8\", \"0.045454545454545456\"], [\"FirstLine\", \"20\", \"0.11363636363636363\"], [\"WrapGuide\", \"4\", \"0.022727272727272728\"], [\"DockableWindowManager\", \"9\", \"0.05113636363636364\"], [\"Entry\", \"6\", \"0.03409090909090909\"], [\"EnhancedCheckBoxMenuItem\", \"2\", \"0.011363636363636364\"], [\"FileCellRenderer\", \"2\", \"0.011363636363636364\"], [\"PaneNameRenderer\", \"2\", \"0.011363636363636364\"], [\"StatusBar\", \"5\", \"0.028409090909090908\"], [\"ParentDirectoryRenderer\", \"2\", \"0.011363636363636364\"], [\"RolloverButton\", \"4\", \"0.022727272727272728\"], [\"EditPlugin\", \"2\", \"0.011363636363636364\"], [\"EnhancedMenu\", \"2\", \"0.011363636363636364\"], [\"Debug\", \"6\", \"0.03409090909090909\"], [\"PaintLineBackground\", \"4\", \"0.022727272727272728\"], [\"ButtonLayout\", \"4\", \"0.022727272727272728\"], [\"VFSDirectoryEntryTable\", \"2\", \"0.011363636363636364\"], [\"VFSFileNameField\", \"4\", \"0.022727272727272728\"], [\"DockablePanel\", \"2\", \"0.011363636363636364\"], [\"DockableWindowCompare\", \"2\", \"0.011363636363636364\"], [\"RectParams\", \"2\", \"0.011363636363636364\"], [\"VMS\", \"2\", \"0.011363636363636364\"], [\"RingListModel\", \"2\", \"0.011363636363636364\"], [\"ActionTextField\", \"2\", \"0.011363636363636364\"], [\"ActionBar\", \"2\", \"0.011363636363636364\"], [\"PluginTableModel\", \"5\", \"0.028409090909090908\"], [\"InputPane\", \"3\", \"0.017045454545454544\"], [\"GrabKeyDialog\", \"2\", \"0.011363636363636364\"], [\"ButtonActionHandler\", \"2\", \"0.011363636363636364\"], [\"TextAreaTransferHandler\", \"8\", \"0.045454545454545456\"], [\"PosBottomHalf\", \"4\", \"0.022727272727272728\"], [\"PositionManager\", \"4\", \"0.022727272727272728\"], [\"PosTopHalf\", \"2\", \"0.011363636363636364\"], [\"RootsEntry\", \"2\", \"0.011363636363636364\"], [\"ActionSet\", \"2\", \"0.011363636363636364\"], [\"PluginJAR\", \"3\", \"0.017045454545454544\"], [\"DropHandler\", \"2\", \"0.011363636363636364\"], [\"SplashScreen\", \"2\", \"0.011363636363636364\"], [\"MiscUtilities\", \"5\", \"0.028409090909090908\"], [\"PerspectiveManager\", \"2\", \"0.011363636363636364\"], [\"DockableLayout\", \"2\", \"0.011363636363636364\"], [\"InstallPanel\", \"3\", \"0.017045454545454544\"], [\"LogList\", \"2\", \"0.011363636363636364\"], [\"MarkerHighlight\", \"2\", \"0.011363636363636364\"], [\"DockableListHandler\", \"2\", \"0.011363636363636364\"], [\"CheckBoxListModel\", \"2\", \"0.011363636363636364\"], [\"jEdit\", \"2\", \"0.011363636363636364\"], [\"ScrollLayout\", \"2\", \"0.011363636363636364\"], [\"TextAreaBorder\", \"2\", \"0.011363636363636364\"], [\"PaintWrapGuide\", \"4\", \"0.022727272727272728\"], [\"SelectionManager\", \"3\", \"0.017045454545454544\"], [\"Reset\", \"2\", \"0.011363636363636364\"], [\"RegexpIndentRule\", \"4\", \"0.022727272727272728\"], [\"OpenBracketIndentRule\", \"2\", \"0.011363636363636364\"], [\"IndentRuleFactory\", \"2\", \"0.011363636363636364\"], [\"Registers\", \"2\", \"0.011363636363636364\"], [\"RegisterViewer\", \"2\", \"0.011363636363636364\"], [\"Rect\", \"2\", \"0.011363636363636364\"], [\"JEditBuffer\", \"2\", \"0.011363636363636364\"], [\"AlignBracket\", \"2\", \"0.011363636363636364\"], [\"VFS\", \"2\", \"0.011363636363636364\"], [\"MacOSPlugin\", \"1\", \"0.005681818181818182\"], [\"Macros\", \"1\", \"0.005681818181818182\"], [\"BrowserColorsModel\", \"1\", \"0.005681818181818182\"]]"
            },
            "m5": {
                "content": "From the results of `get_co_change_relationship`, we can see that several entities have a significant co-change relationship with `JEditTextArea.java`. These are files that were frequently modified together with `JEditTextArea.java` in the past. Entities with higher confidence values are more likely to be impacted by or related to changes in `JEditTextArea.java`.\n\nLet's focus on some of the most significant ones:\n\n1. **ChunkCache (0.28977)** - This has the highest number of supports and confidence, indicating a strong relationship.\n2. **BufferChangeHandler (0.28409)** - Also very high confidence, suggesting it is closely related.\n3. **MouseHandler (0.26705)** - Another file with a relatively high correlation.\n4. **TextAreaPainter (0.22727)** - Strong historical correlation.\n5. **Gutter (0.14205), DisplayManager (0.13636), OffsetManager (0.13636)** - These also show moderate-to-high levels of co-change.\n\nThese entities should be carefully reviewed for synchronization with any changes made to `JEditTextArea.java`.\n\nTo proceed, I recommend examining one of these strongly correlated files further. Let\u2019s start by analyzing the coupling dependencies between `JEditTextArea.java` and `ChunkCache.java` using the `get_coupling_dependencies` function.\n\nCall:\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_b7ff0640e38540c0bb606c",
                        "function": {
                            "arguments": "{\"entity1\": \"JEditTextArea.java\", \"entity2\": \"ChunkCache.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m6": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"ConstructorInvoking(CMI): Construction Method Invoking found: new ChunkCache(this),  \", \"ConstructorInvoking(CMAIM): Coupling found in method setBuffer, at line: 268. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method setFirstLine.  Coupling found in method _setFirstLine, at line: 347. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method setFirstLine.  Coupling found in method scrollUpPage, at line: 500. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method scrollTo, at line: 629. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method scrollTo, at line: 630. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method scrollTo, at line: 634. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method scrollTo, at line: 643. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method scrollTo, at line: 647. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method scrollTo, at line: 684. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method scrollTo, at line: 709. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method scrollTo, at line: 719. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method scrollTo, at line: 725. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method setFirstLine.  Coupling found in method getPhysicalLineOfScreenLine, at line: 804. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method getScreenLineOfOffset, at line: 817. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getScreenLineOfOffset.  Coupling found in method getScreenLineStartOffset, at line: 828. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method updateChunksUpTo.  Coupling found in method getScreenLineStartOffset, at line: 829. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method getScreenLineEndOffset, at line: 845. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method updateChunksUpTo.  Coupling found in method getScreenLineEndOffset, at line: 846. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method xyToOffset, at line: 892. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method updateChunksUpTo.  Coupling found in method xyToOffset, at line: 894. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method offsetToXY, at line: 943. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getScreenLineOfOffset.  Coupling found in method offsetToXY, at line: 968. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method updateChunksUpTo.  Coupling found in method offsetToXY, at line: 969. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method invalidateScreenLineRange, at line: 992. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method needFullRepaint.  Coupling found in method invalidateLine, at line: 1030. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method updateChunksUpTo.  Coupling found in method invalidateLine, at line: 1031. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method invalidateLine, at line: 1047. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method needFullRepaint.  Coupling found in method invalidateLineRange, at line: 1084. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method updateChunksUpTo.  Coupling found in method invalidateLineRange, at line: 1085. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method invalidateLineRange, at line: 1104. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method needFullRepaint.  Coupling found in method moveCaretPosition, at line: 2133. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getScreenLineOfOffset.  Coupling found in method goToNextLine, at line: 2325. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method goToNextLine, at line: 2363. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method goToPrevLine, at line: 2642. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method goToPrevLine, at line: 2680. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method goToStartOfWhiteSpace, at line: 3004. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method goToEndOfWhiteSpace, at line: 3049. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method propertiesChanged, at line: 4711. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method invalidateAll.  Coupling found in method offsetToX, at line: 4728. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method lineToChunkList.  Coupling found in method xToOffset, at line: 4743. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method lineToChunkList.  Coupling found in method xToOffset, at line: 4763. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method lineToChunkList.  Coupling found in method updateMaxHorizontalScrollWidth, at line: 5015. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getMaxHorizontalScrollWidth.  Coupling found in method recalculateVisibleLines, at line: 5040. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method recalculateVisibleLines.  Coupling found in method foldStructureChanged, at line: 5047. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method invalidateAll.  Coupling found in method recalculateLastPhysicalLine, at line: 5588. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method updateChunksUpTo.  Coupling found in method recalculateLastPhysicalLine, at line: 5591. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method contentInserted, at line: 5899. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method invalidateChunksFromPhys.  Coupling found in method contentRemoved, at line: 5965. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method invalidateChunksFromPhys.  Coupling found in method transactionComplete, at line: 6066. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getScreenLineOfOffset.  Coupling found in method doSingleDrag, at line: 6410. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.\"]"
            },
            "m7": {
                "content": "The coupling dependencies between `JEditTextArea.java` and `ChunkCache.java` are extensive and primarily involve method invocations and data flow. The `JEditTextArea` frequently uses the `ChunkCache` object to invoke methods related to line information, chunk updates, scrolling behavior, and invalidation logic.\n\nThis indicates that changes in `JEditTextArea.java`\u2014especially those affecting how text is displayed or scrolled\u2014are likely to impact `ChunkCache.java`, which manages the visual layout of text chunks.\n\n### Key Observations:\n- **Constructor Invoking**: `JEditTextArea` creates an instance of `ChunkCache` (`new ChunkCache(this)`), indicating tight integration.\n- **Method Invocations**: There are numerous calls from `JEditTextArea` to methods in `ChunkCache`, especially related to:\n  - Line information (`getLineInfo`)\n  - Scrolling operations (`scrollTo`, `scrollUpPage`)\n  - Chunk management (`updateChunksUpTo`, `invalidateChunksFromPhys`)\n  - Screen-line mapping (`getScreenLineOfOffset`, `offsetToXY`)\n\nGiven this strong coupling, any change in `JEditTextArea.java` that affects screen rendering, caret movement, or buffer handling will likely require a synchronized update in `ChunkCache.java`.\n\nLet\u2019s now examine another highly co-changed file: **BufferChangeHandler**. We should check its conceptual coupling with `JEditTextArea.java` using `get_conceptual_coupling`, as it may not have direct method calls but could still be semantically linked.\n\nCall:\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_7b95276b6b8049a2af9561",
                        "function": {
                            "arguments": "{\"entity1\": \"JEditTextArea.java\", \"entity2\": \"BufferChangeHandler.java\"}",
                            "name": "get_conceptual_coupling"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m8": {
                "role": "tool",
                "name": "get_conceptual_coupling",
                "content": "[\"BufferChangeHandler has been removed from the project due to project version iteration\"]"
            },
            "m9": {
                "content": "It appears that `BufferChangeHandler.java` has been removed from the project due to version updates or refactoring. This means it is no longer present in the current codebase and does not need to be synchronized.\n\nGiven this, we should shift focus to another highly co-changed file: **MouseHandler.java**, which shows a high historical correlation (`confidence = 0.267`). Since `MouseHandler` likely handles user input events related to the text area, it may have conceptual or behavioral coupling with `JEditTextArea`.\n\nLet\u2019s analyze its conceptual coupling with `JEditTextArea.java`.\n\nCall:\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_22f20a20cc584fc1ab3801",
                        "function": {
                            "arguments": "{\"entity1\": \"JEditTextArea.java\", \"entity2\": \"MouseHandler.java\"}",
                            "name": "get_conceptual_coupling"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m10": {
                "role": "tool",
                "name": "get_conceptual_coupling",
                "content": "[\"MouseHandler has been removed from the project due to project version iteration\"]"
            },
            "m11": {
                "content": "Similar to `BufferChangeHandler.java`, it appears that `MouseHandler.java` has also been removed from the project due to version iteration or refactoring. Therefore, it no longer exists in the current codebase and does not require synchronization.\n\nLet\u2019s move forward by examining another co-changed file that is likely still relevant: **TextAreaPainter.java**, which had a confidence value of `0.22727`. Given its role in rendering the text area, it may have strong conceptual or coupling dependencies with `JEditTextArea.java`.\n\nWe will now check its conceptual coupling with `JEditTextArea.java`.\n\nCall:\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_ce3dda8da9b74dbe8f1667",
                        "function": {
                            "arguments": "{\"entity1\": \"JEditTextArea.java\", \"entity2\": \"TextAreaPainter.java\"}",
                            "name": "get_conceptual_coupling"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m12": {
                "role": "tool",
                "name": "get_conceptual_coupling",
                "content": "\"0.8567677\""
            },
            "m13": {
                "content": "The conceptual coupling between `JEditTextArea.java` and `TextAreaPainter.java` is quite high, with a similarity score of **0.8568** (85.68%). This indicates that these two entities are semantically closely related, likely sharing similar concepts, responsibilities, or thematic concerns\u2014especially around the rendering and visual behavior of the text area.\n\nGiven this strong conceptual link, changes in `JEditTextArea.java`, especially those involving display logic, layout, or visual interactions, may require synchronized updates in `TextAreaPainter.java`.\n\nTo further understand how they interact at the code level, let\u2019s examine if there are direct method calls or dependencies by retrieving the call graph for `JEditTextArea.java`.\n\nCall:\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_ecc57fe4975f486b8c8a30",
                        "function": {
                            "arguments": "{\"entity\": \"JEditTextArea.java\"}",
                            "name": "get_call_graph"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m14": {
                "role": "tool",
                "name": "get_call_graph",
                "content": "[\"\", \"Log\", \"\", \"\", \"\"]"
            },
            "m15": {
                "content": "The call graph for `JEditTextArea.java` appears to be incomplete or possibly returned an error, as it mostly contains empty strings and only one entry: `\"Log\"`.\n\nThis may indicate a parsing issue or that the function did not retrieve meaningful data. Since we cannot rely on this result, we should attempt to retrieve more specific information about how `TextAreaPainter.java` is used within `JEditTextArea.java`.\n\nTo do this, let\u2019s examine the source code of `JEditTextArea.java` to identify direct references or usages of `TextAreaPainter.java`.\n\nCall:\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_dbace1441a7449519fb8e4",
                        "function": {
                            "arguments": "{\"entity\": \"JEditTextArea.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m16": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package org.gjt.sp.jedit.textarea;\\nimport java.awt.*;\\nimport java.awt.event.*;\\nimport java.awt.font.*;\\nimport java.awt.geom.*;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Enumeration;\\nimport java.util.Hashtable;\\nimport java.util.Vector;\\nimport javax.swing.*;\\nimport javax.swing.border.*;\\nimport javax.swing.event.*;\\nimport javax.swing.plaf.metal.MetalLookAndFeel;\\nimport javax.swing.text.Position;\\nimport javax.swing.text.Segment;\\nimport javax.swing.undo.*;\\nimport org.gjt.sp.jedit.*;\\nimport org.gjt.sp.jedit.buffer.*;\\nimport org.gjt.sp.jedit.gui.*;\\nimport org.gjt.sp.jedit.syntax.*;\\nimport org.gjt.sp.util.Log;\\npublic class JEditTextArea extends JComponent\\n{\\n\\tpublic JEditTextArea(View view)\\n\\t{\\n\\t\\tenableEvents(AWTEvent.FOCUS_EVENT_MASK | AWTEvent.KEY_EVENT_MASK);\\n\\t\\tthis.view = view;\\n\\t\\t\\t\\tselection = new Vector();\\n\\t\\tchunkCache = new ChunkCache(this);\\n\\t\\tpainter = new TextAreaPainter(this);\\n\\t\\tgutter = new Gutter(view,this);\\n\\t\\tbufferHandler = new BufferChangeHandler();\\n\\t\\tlistenerList = new EventListenerList();\\n\\t\\tcaretEvent = new MutableCaretEvent();\\n\\t\\tbracketLine = bracketPosition = -1;\\n\\t\\tblink = true;\\n\\t\\tlineSegment = new Segment();\\n\\t\\treturnValue = new Point();\\n\\t\\trunnables = new ArrayList();\\n\\t\\t\\t\\tsetLayout(new ScrollLayout());\\n\\t\\tadd(LEFT,gutter);\\n\\t\\tadd(CENTER,painter);\\n\\t\\tadd(RIGHT,vertical = new JScrollBar(JScrollBar.VERTICAL));\\n\\t\\tadd(BOTTOM,horizontal = new JScrollBar(JScrollBar.HORIZONTAL));\\n\\t\\thorizontal.setValues(0,0,0,0);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(UIManager.getLookAndFeel() instanceof MetalLookAndFeel)\\n\\t\\t{\\n\\t\\t\\tsetBorder(new TextAreaBorder());\\n\\t\\t\\tvertical.putClientProperty(\\\"JScrollBar.isFreeStanding\\\",\\n\\t\\t\\t\\tBoolean.FALSE);\\n\\t\\t\\thorizontal.putClientProperty(\\\"JScrollBar.isFreeStanding\\\",\\n\\t\\t\\t\\tBoolean.FALSE);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\tvertical.addAdjustmentListener(new AdjustHandler());\\n\\t\\thorizontal.addAdjustmentListener(new AdjustHandler());\\n\\t\\tmouseHandler = new MouseHandler();\\n\\t\\tpainter.addMouseListener(mouseHandler);\\n\\t\\tpainter.addMouseMotionListener(mouseHandler);\\n\\t\\taddFocusListener(new FocusHandler());\\n\\t\\t\\t\\t\\t\\t\\t\\tfocusedComponent = this;\\n\\t} \\n\\tpublic final TextAreaPainter getPainter()\\n\\t{\\n\\t\\treturn painter;\\n\\t} \\n\\tpublic final Gutter getGutter()\\n\\t{\\n\\t\\treturn gutter;\\n\\t} \\n\\tpublic FoldVisibilityManager getFoldVisibilityManager()\\n\\t{\\n\\t\\treturn foldVisibilityManager;\\n\\t} \\n\\tpublic final boolean isCaretBlinkEnabled()\\n\\t{\\n\\t\\treturn caretBlinks;\\n\\t} \\n\\tpublic void setCaretBlinkEnabled(boolean caretBlinks)\\n\\t{\\n\\t\\tthis.caretBlinks = caretBlinks;\\n\\t\\tif(!caretBlinks)\\n\\t\\t\\tblink = false;\\n\\t\\tif(buffer != null)\\n\\t\\t\\tinvalidateLine(caretLine);\\n\\t} \\n\\tpublic final int getElectricScroll()\\n\\t{\\n\\t\\treturn electricScroll;\\n\\t} \\n\\tpublic final void setElectricScroll(int electricScroll)\\n\\t{\\n\\t\\tthis.electricScroll = electricScroll;\\n\\t} \\n\\tpublic final boolean isQuickCopyEnabled()\\n\\t{\\n\\t\\treturn quickCopy;\\n\\t} \\n\\tpublic final void setQuickCopyEnabled(boolean quickCopy)\\n\\t{\\n\\t\\tthis.quickCopy = quickCopy;\\n\\t} \\n\\tpublic final Buffer getBuffer()\\n\\t{\\n\\t\\treturn buffer;\\n\\t} \\n\\tpublic void setBuffer(Buffer buffer)\\n\\t{\\n\\t\\tif(this.buffer == buffer)\\n\\t\\t\\treturn;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbufferChanging = true;\\n\\t\\t\\tif(this.buffer != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFirstLine(0);\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\t\\tcaretLine = caret = caretScreenLine = 0;\\n\\t\\t\\t\\tbracketLine = bracketPosition = -1;\\n\\t\\t\\t\\tthis.buffer._releaseFoldVisibilityManager(foldVisibilityManager);\\n\\t\\t\\t\\tthis.buffer.removeBufferChangeListener(bufferHandler);\\n\\t\\t\\t}\\n\\t\\t\\tthis.buffer = buffer;\\n\\t\\t\\tbuffer.addBufferChangeListener(bufferHandler);\\n\\t\\t\\tbufferHandlerInstalled = true;\\n\\t\\t\\tfoldVisibilityManager = buffer._getFoldVisibilityManager(this);\\n\\t\\t\\tphysFirstLine = foldVisibilityManager.getFirstVisibleLine();\\n\\t\\t\\tchunkCache.setFirstLine(0,physFirstLine);\\n\\t\\t\\tpropertiesChanged();\\n\\t\\t\\trecalculateLastPhysicalLine();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbufferChanging = false;\\n\\t\\t}\\n\\t} \\n\\tpublic final boolean isEditable()\\n\\t{\\n\\t\\treturn buffer.isEditable();\\n\\t} \\n\\tpublic final JPopupMenu getRightClickPopup()\\n\\t{\\n\\t\\treturn popup;\\n\\t} \\n\\tpublic final void setRightClickPopup(JPopupMenu popup)\\n\\t{\\n\\t\\tthis.popup = popup;\\n\\t} \\n\\tpublic final int getFirstLine()\\n\\t{\\n\\t\\treturn firstLine;\\n\\t} \\n\\tpublic void setFirstLine(int firstLine)\\n\\t{\\n\\t\\tif(firstLine == this.firstLine)\\n\\t\\t\\treturn;\\n\\t\\t_setFirstLine(firstLine);\\n\\t\\tview.synchroScrollVertical(this,firstLine);\\n\\t} \\n\\t\\tpublic void _setFirstLine(int firstLine)\\n\\t{\\n\\t\\tfirstLine = Math.max(0,Math.min(getVirtualLineCount() - 1,firstLine));\\n\\t\\tthis.firstLine = firstLine;\\n\\t\\tphysFirstLine = virtualToPhysical(firstLine);\\n\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\tchunkCache.setFirstLine(firstLine,physFirstLine);\\n\\t\\trecalculateLastPhysicalLine();\\n\\t\\tif(this.firstLine != vertical.getValue())\\n\\t\\t\\tupdateScrollBars();\\n\\t\\tpainter.repaint();\\n\\t\\tgutter.repaint();\\n\\t\\tfireScrollEvent(true);\\n\\t} \\n\\tpublic final int getVisibleLines()\\n\\t{\\n\\t\\treturn visibleLines;\\n\\t} \\n\\tpublic final int getFirstPhysicalLine()\\n\\t{\\n\\t\\treturn physFirstLine;\\n\\t} \\n\\tpublic final int getLastPhysicalLine()\\n\\t{\\n\\t\\treturn physLastLine;\\n\\t} \\n\\tpublic final int getHorizontalOffset()\\n\\t{\\n\\t\\treturn horizontalOffset;\\n\\t} \\n\\tpublic void setHorizontalOffset(int horizontalOffset)\\n\\t{\\n\\t\\tif(horizontalOffset == this.horizontalOffset)\\n\\t\\t\\treturn;\\n\\t\\t_setHorizontalOffset(horizontalOffset);\\n\\t\\tview.synchroScrollHorizontal(this,horizontalOffset);\\n\\t} \\n\\t\\tpublic void _setHorizontalOffset(int horizontalOffset)\\n\\t{\\n\\t\\tthis.horizontalOffset = horizontalOffset;\\n\\t\\tif(horizontalOffset != horizontal.getValue())\\n\\t\\t\\tupdateScrollBars();\\n\\t\\tpainter.repaint();\\n\\t\\tfireScrollEvent(false);\\n\\t} \\n\\tpublic void updateScrollBars()\\n\\t{\\n\\t\\tif(vertical != null && visibleLines != 0)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tint lineCount = getVirtualLineCount();\\n\\t\\t\\t\\t\\t\\tif(softWrap)\\n\\t\\t\\t\\tlineCount += visibleLines - 1;\\n\\t\\t\\tif(lineCount < firstLine + visibleLines)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tint newFirstLine = Math.max(0,lineCount - visibleLines);\\n\\t\\t\\t\\tif(newFirstLine != firstLine)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsetFirstLine(newFirstLine);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tvertical.setValues(firstLine,visibleLines,0,lineCount);\\n\\t\\t\\tvertical.setUnitIncrement(2);\\n\\t\\t\\tvertical.setBlockIncrement(visibleLines);\\n\\t\\t}\\n\\t\\tint width = painter.getWidth();\\n\\t\\tif(horizontal != null && width != 0)\\n\\t\\t{\\n\\t\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\t\\tpainter.repaint();\\n\\t\\t\\thorizontal.setUnitIncrement(painter.getFontMetrics()\\n\\t\\t\\t\\t.charWidth('w'));\\n\\t\\t\\thorizontal.setBlockIncrement(width / 2);\\n\\t\\t}\\n\\t} \\n\\tpublic void scrollUpLine()\\n\\t{\\n\\t\\tif(firstLine > 0)\\n\\t\\t\\tsetFirstLine(firstLine - 1);\\n\\t\\telse\\n\\t\\t\\tgetToolkit().beep();\\n\\t} \\n\\tpublic void scrollUpPage()\\n\\t{\\n\\t\\tif(firstLine > 0)\\n\\t\\t{\\n\\t\\t\\tint newFirstLine;\\n\\t\\t\\tif(softWrap)\\n\\t\\t\\t{\\n\\t\\t\\t\\tnewFirstLine = firstLine;\\n\\t\\t\\t\\tint screenLineCount = 0;\\n\\t\\t\\t\\twhile(--newFirstLine >= 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint lines = chunkCache\\n\\t\\t\\t\\t\\t\\t.getLineInfosForPhysicalLine(\\n\\t\\t\\t\\t\\t\\tnewFirstLine).length;\\n\\t\\t\\t\\t\\tif(screenLineCount + lines >= visibleLines)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tscreenLineCount += lines;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tnewFirstLine = firstLine - visibleLines;\\n\\t\\t\\t}\\n\\t\\t\\tsetFirstLine(newFirstLine);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t}\\n\\t} \\n\\tpublic void scrollDownLine()\\n\\t{\\n\\t\\tint numLines = getVirtualLineCount();\\n\\t\\tif((softWrap && firstLine + 1 < numLines) ||\\n\\t\\t\\t(firstLine + visibleLines < numLines))\\n\\t\\t\\tsetFirstLine(firstLine + 1);\\n\\t\\telse\\n\\t\\t\\tgetToolkit().beep();\\n\\t} \\n\\tpublic void scrollDownPage()\\n\\t{\\n\\t\\tint numLines = getVirtualLineCount();\\n\\t\\tif((softWrap && firstLine + 1 < numLines) ||\\n\\t\\t\\t(firstLine + visibleLines < numLines))\\n\\t\\t{\\n\\t\\t\\tsetFirstLine(physicalToVirtual(physLastLine));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tgetToolkit().beep();\\n\\t} \\n\\tpublic void scrollToCaret(boolean doElectricScroll)\\n\\t{\\n\\t\\tscrollTo(caretLine,caret - buffer.getLineStartOffset(caretLine),\\n\\t\\t\\tdoElectricScroll);\\n\\t} \\n\\tpublic void scrollTo(int line, int offset, boolean doElectricScroll)\\n\\t{\\n\\t\\tint extraEndVirt;\\n\\t\\tint lineLength = buffer.getLineLength(line);\\n\\t\\tif(offset > lineLength)\\n\\t\\t{\\n\\t\\t\\textraEndVirt = charWidth * (offset - lineLength);\\n\\t\\t\\toffset = lineLength;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\textraEndVirt = 0;\\n\\t\\tint _electricScroll = (doElectricScroll\\n\\t\\t\\t&& visibleLines > electricScroll * 2\\n\\t\\t\\t? electricScroll : 0);\\n\\t\\t\\t\\t\\t\\t\\t\\tif(visibleLines == 0)\\n\\t\\t{\\n\\t\\t\\tsetFirstLine(physicalToVirtual(\\n\\t\\t\\t\\tMath.max(0,line - _electricScroll)));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\t\\tint screenLine = getScreenLineOfOffset(buffer.getLineStartOffset(line) + offset);\\n\\t\\tPoint point;\\n\\t\\tif(screenLine != -1)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tint height = painter.getFontMetrics().getHeight();\\n\\t\\t\\tint y1 = (firstLine == 0 ? 0 : height * _electricScroll);\\n\\t\\t\\tint y2 = (visibleLines + firstLine == getVirtualLineCount()\\n\\t\\t\\t\\t? 0 : height * _electricScroll);\\n\\t\\t\\tRectangle rect = new Rectangle(0,y1,\\n\\t\\t\\t\\tpainter.getWidth() - 5,visibleLines * height\\n\\t\\t\\t\\t- y1 - y2);\\n\\t\\t\\tpoint = offsetToXY(line,offset,returnValue);\\n\\t\\t\\tpoint.x += extraEndVirt;\\n\\t\\t\\tif(rect.contains(point))\\n\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tpoint = null;\\n\\t\\t\\t\\tif(line == physLastLine + 1)\\n\\t\\t{\\n\\t\\t\\tint count = chunkCache.getLineInfosForPhysicalLine(physLastLine).length\\n\\t\\t\\t\\t+ chunkCache.getLineInfosForPhysicalLine(physLastLine + 1).length\\n\\t\\t\\t\\t+ _electricScroll;\\n\\t\\t\\twhile(count > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount -= chunkCache.getLineInfosForPhysicalLine(physFirstLine).length;\\n\\t\\t\\t\\tfirstLine++;\\n\\t\\t\\t\\tphysFirstLine = foldVisibilityManager.getNextVisibleLine(physFirstLine);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(screenLine == -1)\\n\\t\\t{\\n\\t\\t\\tif(line == physLastLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint count = chunkCache.getLineInfosForPhysicalLine(physLastLine).length\\n\\t\\t\\t\\t\\t+ _electricScroll;\\n\\t\\t\\t\\twhile(count > 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount -= chunkCache.getLineInfosForPhysicalLine(physFirstLine).length;\\n\\t\\t\\t\\t\\tfirstLine++;\\n\\t\\t\\t\\t\\tint nextLine = foldVisibilityManager.getNextVisibleLine(physFirstLine);\\n\\t\\t\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tphysFirstLine = nextLine;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint virtualLine = foldVisibilityManager.physicalToVirtual(line);\\n\\t\\t\\tif(virtualLine == firstLine - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine = Math.max(0,firstLine - _electricScroll - 1);\\n\\t\\t\\t\\tphysFirstLine = foldVisibilityManager.virtualToPhysical(firstLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tif(!softWrap && virtualLine >= foldVisibilityManager.getVirtualLineCount()\\n\\t\\t\\t\\t\\t- visibleLines / 2)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfirstLine = foldVisibilityManager.getVirtualLineCount()\\n\\t\\t\\t\\t\\t\\t- visibleLines;\\n\\t\\t\\t\\t\\tphysFirstLine = foldVisibilityManager\\n\\t\\t\\t\\t\\t\\t.virtualToPhysical(firstLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysFirstLine = line;\\n\\t\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\t\\tfor(;;)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(foldVisibilityManager.isLineVisible(physFirstLine))\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tint incr = chunkCache.getLineInfosForPhysicalLine(physFirstLine).length;\\n\\t\\t\\t\\t\\t\\t\\tif(count + incr > visibleLines / 2)\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tcount += incr;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(physFirstLine == 0)\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tphysFirstLine = foldVisibilityManager\\n\\t\\t\\t\\t\\t\\t\\t\\t.getPrevVisibleLine(physFirstLine);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfirstLine = physicalToVirtual(physFirstLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(screenLine < _electricScroll && firstLine != 0)\\n\\t\\t{\\n\\t\\t\\tint count = _electricScroll - screenLine;\\n\\t\\t\\twhile(count > 0 && firstLine > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount -= chunkCache.getLineInfosForPhysicalLine(physFirstLine).length;\\n\\t\\t\\t\\tfirstLine--;\\n\\t\\t\\t\\tphysFirstLine = foldVisibilityManager.getPrevVisibleLine(physFirstLine);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(screenLine >= visibleLines - _electricScroll)\\n\\t\\t{\\n\\t\\t\\tint count = _electricScroll - visibleLines + screenLine + 1;\\n\\t\\t\\twhile(count > 0 && firstLine <= getVirtualLineCount())\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount -= chunkCache.getLineInfosForPhysicalLine(physFirstLine).length;\\n\\t\\t\\t\\tfirstLine++;\\n\\t\\t\\t\\tphysFirstLine = foldVisibilityManager.getNextVisibleLine(physFirstLine);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tchunkCache.setFirstLine(firstLine,physFirstLine);\\n\\t\\trecalculateLastPhysicalLine();\\n\\t\\tif(point == null)\\n\\t\\t{\\n\\t\\t\\tpoint = offsetToXY(line,offset,returnValue);\\n\\t\\t\\tif(point == null)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tpoint.x += extraEndVirt;\\n\\t\\t} \\n\\t\\t\\t\\tif(point.x < 0)\\n\\t\\t{\\n\\t\\t\\thorizontalOffset = Math.min(0,horizontalOffset\\n\\t\\t\\t\\t- point.x + charWidth + 5);\\n\\t\\t}\\n\\t\\telse if(point.x >= painter.getWidth() - charWidth - 5)\\n\\t\\t{\\n\\t\\t\\thorizontalOffset = horizontalOffset +\\n\\t\\t\\t\\t(painter.getWidth() - point.x)\\n\\t\\t\\t\\t- charWidth - 5;\\n\\t\\t} \\n\\t\\t\\t\\tupdateScrollBars();\\n\\t\\tpainter.repaint();\\n\\t\\tgutter.repaint();\\n\\t\\tview.synchroScrollVertical(this,firstLine);\\n\\t\\tview.synchroScrollHorizontal(this,horizontalOffset);\\n\\t\\t\\t\\tfireScrollEvent(true);\\n\\t\\tfireScrollEvent(false);\\n\\t\\t\\t} \\n\\tpublic final void addScrollListener(ScrollListener listener)\\n\\t{\\n\\t\\tlistenerList.add(ScrollListener.class,listener);\\n\\t} \\n\\tpublic final void removeScrollListener(ScrollListener listener)\\n\\t{\\n\\t\\tlistenerList.remove(ScrollListener.class,listener);\\n\\t} \\n\\tpublic int getPhysicalLineOfScreenLine(int screenLine)\\n\\t{\\n\\t\\treturn chunkCache.getLineInfo(screenLine).physicalLine;\\n\\t} \\n\\tpublic int getScreenLineOfOffset(int offset)\\n\\t{\\n\\t\\tint line = buffer.getLineOfOffset(offset);\\n\\t\\toffset -= buffer.getLineStartOffset(line);\\n\\t\\treturn chunkCache.getScreenLineOfOffset(line,offset);\\n\\t} \\n\\tpublic int getScreenLineStartOffset(int line)\\n\\t{\\n\\t\\tchunkCache.updateChunksUpTo(line);\\n\\t\\tChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);\\n\\t\\tif(lineInfo.physicalLine == -1)\\n\\t\\t\\treturn -1;\\n\\t\\treturn buffer.getLineStartOffset(lineInfo.physicalLine)\\n\\t\\t\\t+ lineInfo.offset;\\n\\t} \\n\\tpublic int getScreenLineEndOffset(int line)\\n\\t{\\n\\t\\tchunkCache.updateChunksUpTo(line);\\n\\t\\tChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);\\n\\t\\tif(lineInfo.physicalLine == -1)\\n\\t\\t\\treturn -1;\\n\\t\\treturn buffer.getLineStartOffset(lineInfo.physicalLine)\\n\\t\\t\\t+ lineInfo.offset + lineInfo.length;\\n\\t} \\n\\tpublic int xyToOffset(int x, int y)\\n\\t{\\n\\t\\treturn xyToOffset(x,y,true);\\n\\t} \\n\\tpublic int xyToOffset(int x, int y, boolean round)\\n\\t{\\n\\t\\tFontMetrics fm = painter.getFontMetrics();\\n\\t\\tint height = fm.getHeight();\\n\\t\\tint line = y / height;\\n\\t\\tif(line < 0 || line > visibleLines)\\n\\t\\t\\treturn -1;\\n\\t\\tchunkCache.updateChunksUpTo(line);\\n\\t\\tChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);\\n\\t\\tif(!lineInfo.chunksValid)\\n\\t\\t\\tSystem.err.println(\\\"xy to offset: not valid\\\");\\n\\t\\tif(lineInfo.physicalLine == -1)\\n\\t\\t{\\n\\t\\t\\treturn getLineEndOffset(foldVisibilityManager\\n\\t\\t\\t\\t.getLastVisibleLine()) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint offset = Chunk.xToOffset(lineInfo.chunks,\\n\\t\\t\\t\\tx - horizontalOffset,round);\\n\\t\\t\\tif(offset == -1 || offset == lineInfo.offset + lineInfo.length)\\n\\t\\t\\t\\toffset = lineInfo.offset + lineInfo.length - 1;\\n\\t\\t\\treturn getLineStartOffset(lineInfo.physicalLine) + offset;\\n\\t\\t}\\n\\t} \\n\\tpublic Point offsetToXY(int offset)\\n\\t{\\n\\t\\tint line = buffer.getLineOfOffset(offset);\\n\\t\\toffset -= buffer.getLineStartOffset(line);\\n\\t\\tPoint retVal = new Point();\\n\\t\\treturn offsetToXY(line,offset,retVal);\\n\\t} \\n\\tpublic Point offsetToXY(int line, int offset, Point retVal)\\n\\t{\\n\\t\\tint screenLine = chunkCache.getScreenLineOfOffset(line,offset);\\n\\t\\tif(screenLine == -1)\\n\\t\\t{\\n\\t\\t\\tif(line < physFirstLine)\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\telse if(line >= physLastLine)\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tthrow new InternalError(\\\"line=\\\" + line\\n\\t\\t\\t\\t\\t+ \\\",offset=\\\" + offset\\n\\t\\t\\t\\t\\t+ \\\",screenLine=\\\" + screenLine\\n\\t\\t\\t\\t\\t+ \\\",physFirstLine=\\\" + physFirstLine\\n\\t\\t\\t\\t\\t+ \\\",physLastLine=\\\" + physLastLine);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tFontMetrics fm = painter.getFontMetrics();\\n\\t\\tretVal.y = screenLine * fm.getHeight();\\n\\t\\tchunkCache.updateChunksUpTo(screenLine);\\n\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(screenLine);\\n\\t\\tif(!info.chunksValid)\\n\\t\\t\\tSystem.err.println(\\\"offset to xy: not valid\\\");\\n\\t\\tretVal.x = (int)(horizontalOffset + Chunk.offsetToX(\\n\\t\\t\\tinfo.chunks,offset));\\n\\t\\treturn retVal;\\n\\t} \\n\\tpublic void invalidateScreenLineRange(int start, int end)\\n\\t{\\n\\t\\tif(chunkCache.needFullRepaint())\\n\\t\\t{\\n\\t\\t\\trecalculateLastPhysicalLine();\\n\\t\\t\\tgutter.repaint();\\n\\t\\t\\tpainter.repaint();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(start > end)\\n\\t\\t{\\n\\t\\t\\tint tmp = end;\\n\\t\\t\\tend = start;\\n\\t\\t\\tstart = tmp;\\n\\t\\t}\\n\\t\\tFontMetrics fm = painter.getFontMetrics();\\n\\t\\tint y = start * fm.getHeight();\\n\\t\\tint height = (end - start + 1) * fm.getHeight();\\n\\t\\tpainter.repaint(0,y,painter.getWidth(),height);\\n\\t\\tgutter.repaint(0,y,gutter.getWidth(),height);\\n\\t} \\n\\tpublic void invalidateLine(int line)\\n\\t{\\n\\t\\tif(line < physFirstLine || line > physLastLine\\n\\t\\t\\t|| !foldVisibilityManager.isLineVisible(line))\\n\\t\\t\\treturn;\\n\\t\\tint startLine = -1;\\n\\t\\tint endLine = -1;\\n\\t\\tfor(int i = 0; i <= visibleLines; i++)\\n\\t\\t{\\n\\t\\t\\tchunkCache.updateChunksUpTo(i);\\n\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(i);\\n\\t\\t\\tif((info.physicalLine >= line || info.physicalLine == -1)\\n\\t\\t\\t\\t&& startLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstartLine = i;\\n\\t\\t\\t}\\n\\t\\t\\tif((info.physicalLine >= line && info.lastSubregion)\\n\\t\\t\\t\\t|| info.physicalLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tendLine = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(chunkCache.needFullRepaint())\\n\\t\\t{\\n\\t\\t\\trecalculateLastPhysicalLine();\\n\\t\\t\\tendLine = visibleLines;\\n\\t\\t}\\n\\t\\telse if(endLine == -1)\\n\\t\\t\\tendLine = visibleLines;\\n\\t\\tinvalidateScreenLineRange(startLine,endLine);\\n\\t} \\n\\tpublic void invalidateLineRange(int start, int end)\\n\\t{\\n\\t\\tif(end < start)\\n\\t\\t{\\n\\t\\t\\tint tmp = end;\\n\\t\\t\\tend = start;\\n\\t\\t\\tstart = tmp;\\n\\t\\t}\\n\\t\\tif(end < physFirstLine || start > physLastLine)\\n\\t\\t\\treturn;\\n\\t\\tint startScreenLine = -1;\\n\\t\\tint endScreenLine = -1;\\n\\t\\tfor(int i = 0; i <= visibleLines; i++)\\n\\t\\t{\\n\\t\\t\\tchunkCache.updateChunksUpTo(i);\\n\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(i);\\n\\t\\t\\tif((info.physicalLine >= start || info.physicalLine == -1)\\n\\t\\t\\t\\t&& startScreenLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstartScreenLine = i;\\n\\t\\t\\t}\\n\\t\\t\\tif((info.physicalLine >= end && info.lastSubregion)\\n\\t\\t\\t\\t|| info.physicalLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tendScreenLine = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(startScreenLine == -1)\\n\\t\\t\\tstartScreenLine = 0;\\n\\t\\tif(chunkCache.needFullRepaint())\\n\\t\\t{\\n\\t\\t\\trecalculateLastPhysicalLine();\\n\\t\\t\\tendScreenLine = visibleLines;\\n\\t\\t}\\n\\t\\telse if(endScreenLine == -1)\\n\\t\\t\\tendScreenLine = visibleLines;\\n\\t\\tinvalidateScreenLineRange(startScreenLine,endScreenLine);\\n\\t} \\n\\tpublic void invalidateSelectedLines()\\n\\t{\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tinvalidateLineRange(s.startLine,s.endLine);\\n\\t\\t}\\n\\t} \\n\\tpublic int physicalToVirtual(int line)\\n\\t{\\n\\t\\treturn foldVisibilityManager.physicalToVirtual(line);\\n\\t} \\n\\tpublic int virtualToPhysical(int line)\\n\\t{\\n\\t\\treturn foldVisibilityManager.virtualToPhysical(line);\\n\\t} \\n\\tpublic final int getBufferLength()\\n\\t{\\n\\t\\treturn buffer.getLength();\\n\\t} \\n\\tpublic final int getLineCount()\\n\\t{\\n\\t\\treturn buffer.getLineCount();\\n\\t} \\n\\tpublic final int getVirtualLineCount()\\n\\t{\\n\\t\\treturn foldVisibilityManager.getVirtualLineCount();\\n\\t} \\n\\tpublic final int getLineOfOffset(int offset)\\n\\t{\\n\\t\\treturn buffer.getLineOfOffset(offset);\\n\\t} \\n\\tpublic int getLineStartOffset(int line)\\n\\t{\\n\\t\\treturn buffer.getLineStartOffset(line);\\n\\t} \\n\\tpublic int getLineEndOffset(int line)\\n\\t{\\n\\t\\treturn buffer.getLineEndOffset(line);\\n\\t} \\n\\tpublic int getLineLength(int line)\\n\\t{\\n\\t\\treturn buffer.getLineLength(line);\\n\\t} \\n\\tpublic final String getText(int start, int len)\\n\\t{\\n\\t\\treturn buffer.getText(start,len);\\n\\t} \\n\\tpublic final void getText(int start, int len, Segment segment)\\n\\t{\\n\\t\\tbuffer.getText(start,len,segment);\\n\\t} \\n\\tpublic final String getLineText(int lineIndex)\\n\\t{\\n\\t\\treturn buffer.getLineText(lineIndex);\\n\\t} \\n\\tpublic final void getLineText(int lineIndex, Segment segment)\\n\\t{\\n\\t\\tbuffer.getLineText(lineIndex,segment);\\n\\t} \\n\\tpublic String getText()\\n\\t{\\n\\t\\treturn buffer.getText(0,buffer.getLength());\\n\\t} \\n\\tpublic void setText(String text)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tbuffer.remove(0,buffer.getLength());\\n\\t\\t\\tbuffer.insert(0,text);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic final void selectAll()\\n\\t{\\n\\t\\tsetSelection(new Selection.Range(0,buffer.getLength()));\\n\\t\\tmoveCaretPosition(buffer.getLength(),true);\\n\\t} \\n\\tpublic void selectLine()\\n\\t{\\n\\t\\tint caretLine = getCaretLine();\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine) - 1;\\n\\t\\tSelection s = new Selection.Range(start,end);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(end);\\n\\t} \\n\\tpublic void selectParagraph()\\n\\t{\\n\\t\\tint caretLine = getCaretLine();\\n\\t\\tif(getLineLength(caretLine) == 0)\\n\\t\\t{\\n\\t\\t\\tview.getToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint start = caretLine;\\n\\t\\tint end = caretLine;\\n\\t\\twhile(start >= 0)\\n\\t\\t{\\n\\t\\t\\tif(getLineLength(start) == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\telse\\n\\t\\t\\t\\tstart--;\\n\\t\\t}\\n\\t\\twhile(end < getLineCount())\\n\\t\\t{\\n\\t\\t\\tif(getLineLength(end) == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\telse\\n\\t\\t\\t\\tend++;\\n\\t\\t}\\n\\t\\tint selectionStart = getLineStartOffset(start + 1);\\n\\t\\tint selectionEnd = getLineEndOffset(end - 1) - 1;\\n\\t\\tSelection s = new Selection.Range(selectionStart,selectionEnd);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(selectionEnd);\\n\\t} \\n\\tpublic void selectWord()\\n\\t{\\n\\t\\tint line = getCaretLine();\\n\\t\\tint lineStart = getLineStartOffset(line);\\n\\t\\tint offset = getCaretPosition() - lineStart;\\n\\t\\tif(getLineLength(line) == 0)\\n\\t\\t\\treturn;\\n\\t\\tString lineText = getLineText(line);\\n\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\tif(offset == getLineLength(line))\\n\\t\\t\\toffset--;\\n\\t\\tint wordStart = TextUtilities.findWordStart(lineText,offset,noWordSep);\\n\\t\\tint wordEnd = TextUtilities.findWordEnd(lineText,offset+1,noWordSep);\\n\\t\\tSelection s = new Selection.Range(lineStart + wordStart,\\n\\t\\t\\tlineStart + wordEnd);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(lineStart + wordEnd);\\n\\t} \\n\\tpublic boolean selectToMatchingBracket(int position)\\n\\t{\\n\\t\\tint positionLine = buffer.getLineOfOffset(position);\\n\\t\\tint lineOffset = position - buffer.getLineStartOffset(positionLine);\\n\\t\\tint bracket = TextUtilities.findMatchingBracket(buffer,positionLine,lineOffset);\\n\\t\\tif(bracket != -1)\\n\\t\\t{\\n\\t\\t\\tSelection s;\\n\\t\\t\\tif(bracket < position)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmoveCaretPosition(position,false);\\n\\t\\t\\t\\ts = new Selection.Range(++bracket,position);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tmoveCaretPosition(position + 1,false);\\n\\t\\t\\t\\ts = new Selection.Range(position + 1,bracket);\\n\\t\\t\\t}\\n\\t\\t\\tif(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\taddToSelection(s);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t} \\n\\tpublic void selectToMatchingBracket()\\n\\t{\\n\\t\\t\\t\\tint caret = this.caret;\\n\\t\\tint offset = caret - buffer.getLineStartOffset(caretLine);\\n\\t\\tif(buffer.getLineLength(caretLine) == 0)\\n\\t\\t\\treturn;\\n\\t\\tif(offset == buffer.getLineLength(caretLine))\\n\\t\\t\\tcaret--;\\n\\t\\tselectToMatchingBracket(caret);\\n\\t} \\n\\tpublic void selectBlock()\\n\\t{\\n\\t\\tString openBrackets = \\\"([{\\\";\\n\\t\\tString closeBrackets = \\\")]}\\\";\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint start, end;\\n\\t\\tif(s == null)\\n\\t\\t\\tstart = end = caret;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstart = s.start;\\n\\t\\t\\tend = s.end;\\n\\t\\t}\\n\\t\\tString text = getText(0,buffer.getLength());\\n\\t\\t\\t\\tint count = 1;\\n\\t\\tchar openBracket = '\\\\0';\\n\\t\\tchar closeBracket = '\\\\0';\\n\\t\\t\\t\\tif(start == 0)\\n\\t\\t{\\n\\t\\t\\tview.getToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\nbackward_scan:\\twhile(--start > 0)\\n\\t\\t{\\n\\t\\t\\tchar c = text.charAt(start);\\n\\t\\t\\tint index = openBrackets.indexOf(c);\\n\\t\\t\\tif(index != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(--count == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\topenBracket = c;\\n\\t\\t\\t\\t\\tcloseBracket = closeBrackets.charAt(index);\\n\\t\\t\\t\\t\\tbreak backward_scan;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(closeBrackets.indexOf(c) != -1)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\t\\t\\tcount = 1;\\n\\t\\t\\t\\tif(openBracket == '\\\\0')\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\nforward_scan:\\t\\tdo\\n\\t\\t\\t{\\n\\t\\t\\t\\tchar c = text.charAt(end);\\n\\t\\t\\t\\tif(c == closeBracket)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(--count == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend++;\\n\\t\\t\\t\\t\\t\\tbreak forward_scan;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(c == openBracket)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\twhile(++end < buffer.getLength());\\n\\t\\t}\\n\\t\\ts = new Selection.Range(start,end);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(end);\\n\\t} \\n\\tpublic final void invertSelection()\\n\\t{\\n\\t\\tSelection[] newSelection = new Selection[selection.size() + 1];\\n\\t\\tint lastOffset = 0;\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tnewSelection[i] = new Selection.Range(lastOffset,\\n\\t\\t\\t\\ts.getStart());\\n\\t\\t\\tlastOffset = s.getEnd();\\n\\t\\t}\\n\\t\\tnewSelection[selection.size()] = new Selection.Range(\\n\\t\\t\\tlastOffset,buffer.getLength());\\n\\t\\tsetSelection(newSelection);\\n\\t} \\n\\tpublic int getSelectionCount()\\n\\t{\\n\\t\\treturn selection.size();\\n\\t} \\n\\tpublic Selection[] getSelection()\\n\\t{\\n\\t\\tSelection[] sel = new Selection[selection.size()];\\n\\t\\tselection.copyInto(sel);\\n\\t\\treturn sel;\\n\\t} \\n\\tpublic void selectNone()\\n\\t{\\n\\t\\tsetSelection((Selection)null);\\n\\t} \\n\\tpublic void setSelection(Selection[] selection)\\n\\t{\\n\\t\\t\\t\\tinvalidateSelectedLines();\\n\\t\\tthis.selection.removeAllElements();\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t\\t_addToSelection(selection[i]);\\n\\t\\t}\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void setSelection(Selection selection)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tthis.selection.removeAllElements();\\n\\t\\tif(selection != null)\\n\\t\\t\\t_addToSelection(selection);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void addToSelection(Selection[] selection)\\n\\t{\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t\\t_addToSelection(selection[i]);\\n\\t\\t}\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void addToSelection(Selection selection)\\n\\t{\\n\\t\\t_addToSelection(selection);\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic Selection getSelectionAtOffset(int offset)\\n\\t{\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\t\\tif(offset >= s.start && offset <= s.end)\\n\\t\\t\\t\\t\\treturn s;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic void removeFromSelection(Selection sel)\\n\\t{\\n\\t\\tselection.removeElement(sel);\\n\\t\\tinvalidateLineRange(sel.startLine,sel.endLine);\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void removeFromSelection(int offset)\\n\\t{\\n\\t\\tSelection sel = getSelectionAtOffset(offset);\\n\\t\\tif(sel == null)\\n\\t\\t\\treturn;\\n\\t\\tselection.removeElement(sel);\\n\\t\\tinvalidateLineRange(sel.startLine,sel.endLine);\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void resizeSelection(int offset, int end, int extraEndVirt,\\n\\t\\tboolean rect)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(offset);\\n\\t\\tif(s != null)\\n\\t\\t{\\n\\t\\t\\tinvalidateLineRange(s.startLine,s.endLine);\\n\\t\\t\\tselection.removeElement(s);\\n\\t\\t}\\n\\t\\tboolean reversed = false;\\n\\t\\tif(end < offset)\\n\\t\\t{\\n\\t\\t\\tint tmp = offset;\\n\\t\\t\\toffset = end;\\n\\t\\t\\tend = tmp;\\n\\t\\t\\treversed = true;\\n\\t\\t}\\n\\t\\tSelection newSel;\\n\\t\\tif(rect)\\n\\t\\t{\\n\\t\\t\\tSelection.Rect rectSel = new Selection.Rect(offset,end);\\n\\t\\t\\tif(reversed)\\n\\t\\t\\t\\trectSel.extraStartVirt = extraEndVirt;\\n\\t\\t\\telse\\n\\t\\t\\t\\trectSel.extraEndVirt = extraEndVirt;\\n\\t\\t\\tnewSel = rectSel;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tnewSel = new Selection.Range(offset,end);\\n\\t\\t_addToSelection(newSel);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void extendSelection(int offset, int end)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(offset);\\n\\t\\tif(s != null)\\n\\t\\t{\\n\\t\\t\\tinvalidateLineRange(s.startLine,s.endLine);\\n\\t\\t\\tselection.removeElement(s);\\n\\t\\t\\tif(offset == s.start)\\n\\t\\t\\t{\\n\\t\\t\\t\\toffset = end;\\n\\t\\t\\t\\tend = s.end;\\n\\t\\t\\t}\\n\\t\\t\\telse if(offset == s.end)\\n\\t\\t\\t{\\n\\t\\t\\t\\toffset = s.start;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(end < offset)\\n\\t\\t{\\n\\t\\t\\tint tmp = end;\\n\\t\\t\\tend = offset;\\n\\t\\t\\toffset = tmp;\\n\\t\\t}\\n\\t\\t_addToSelection(new Selection.Range(offset,end));\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic String getSelectedText(Selection s)\\n\\t{\\n\\t\\tStringBuffer buf = new StringBuffer();\\n\\t\\ts.getText(buffer,buf);\\n\\t\\treturn buf.toString();\\n\\t} \\n\\tpublic String getSelectedText(String separator)\\n\\t{\\n\\t\\tif(selection.size() == 0)\\n\\t\\t\\treturn null;\\n\\t\\tStringBuffer buf = new StringBuffer();\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tif(i != 0)\\n\\t\\t\\t\\tbuf.append(separator);\\n\\t\\t\\t((Selection)selection.elementAt(i)).getText(buffer,buf);\\n\\t\\t}\\n\\t\\treturn buf.toString();\\n\\t} \\n\\tpublic String getSelectedText()\\n\\t{\\n\\t\\treturn getSelectedText(\\\"\\\\n\\\");\\n\\t} \\n\\tpublic void setSelectedText(Selection s, String selectedText)\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tthrow new InternalError(\\\"Text component\\\"\\n\\t\\t\\t\\t+ \\\" read only\\\");\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tmoveCaretPosition(s.setText(buffer,selectedText));\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\t\\t\\t\\t} \\n\\tpublic void setSelectedText(String selectedText)\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tthrow new InternalError(\\\"Text component\\\"\\n\\t\\t\\t\\t+ \\\" read only\\\");\\n\\t\\t}\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(selection.length == 0)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.insert(caret,selectedText);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tint newCaret = -1;\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnewCaret = selection[i].setText(buffer,selectedText);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic int[] getSelectedLines()\\n\\t{\\n\\t\\tif(selection.size() == 0)\\n\\t\\t\\treturn new int[] { caretLine };\\n\\t\\tInteger line;\\n\\t\\tHashtable hash = new Hashtable();\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tint endLine = (s.end == getLineStartOffset(s.endLine)\\n\\t\\t\\t\\t? s.endLine - 1\\n\\t\\t\\t\\t: s.endLine);\\n\\t\\t\\tfor(int j = s.startLine; j <= endLine; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tline = new Integer(j);\\n\\t\\t\\t\\thash.put(line,line);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint[] returnValue = new int[hash.size()];\\n\\t\\tint i = 0;\\n\\t\\tEnumeration keys = hash.keys();\\n\\t\\twhile(keys.hasMoreElements())\\n\\t\\t{\\n\\t\\t\\tline = (Integer)keys.nextElement();\\n\\t\\t\\treturnValue[i++] = line.intValue();\\n\\t\\t}\\n\\t\\tArrays.sort(returnValue);\\n\\t\\treturn returnValue;\\n\\t} \\n\\tpublic void showSelectLineRangeDialog()\\n\\t{\\n\\t\\tnew SelectLineRange(view);\\n\\t} \\n\\tpublic final void blinkCaret()\\n\\t{\\n\\t\\tif(caretBlinks)\\n\\t\\t{\\n\\t\\t\\tblink = !blink;\\n\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tblink = true;\\n\\t} \\n\\tpublic void centerCaret()\\n\\t{\\n\\t\\tint offset = getScreenLineStartOffset(visibleLines / 2);\\n\\t\\tif(offset == -1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t\\tsetCaretPosition(offset);\\n\\t} \\n\\tpublic void setCaretPosition(int newCaret)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tselection.removeAllElements();\\n\\t\\tmoveCaretPosition(newCaret,true);\\n\\t} \\n\\tpublic void setCaretPosition(int newCaret, boolean doElectricScroll)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tselection.removeAllElements();\\n\\t\\tmoveCaretPosition(newCaret,doElectricScroll);\\n\\t} \\n\\tpublic void moveCaretPosition(int newCaret)\\n\\t{\\n\\t\\tmoveCaretPosition(newCaret,true);\\n\\t} \\n\\tpublic void moveCaretPosition(int newCaret, boolean doElectricScroll)\\n\\t{\\n\\t\\tif(newCaret < 0 || newCaret > buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tthrow new IllegalArgumentException(\\\"caret out of bounds: \\\"\\n\\t\\t\\t\\t+ newCaret);\\n\\t\\t}\\n\\t\\tif(caret == newCaret)\\n\\t\\t{\\n\\t\\t\\tif(view.getTextArea() == this)\\n\\t\\t\\t\\tfinishCaretUpdate(doElectricScroll,false);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint newCaretLine = getLineOfOffset(newCaret);\\n\\t\\t\\tmagicCaret = -1;\\n\\t\\t\\tif(!foldVisibilityManager.isLineVisible(newCaretLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(foldVisibilityManager.isNarrowed())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint collapseFolds = buffer.getIntegerProperty(\\n\\t\\t\\t\\t\\t\\t\\\"collapseFolds\\\",0);\\n\\t\\t\\t\\t\\tif(collapseFolds != 0)\\n\\t\\t\\t\\t\\t\\tfoldVisibilityManager.expandFolds(collapseFolds);\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tfoldVisibilityManager.expandAllFolds();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tfoldVisibilityManager.expandFold(newCaretLine,false);\\n\\t\\t\\t}\\n\\t\\t\\tif(caretLine == newCaretLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caretScreenLine != -1)\\n\\t\\t\\t\\t\\tinvalidateScreenLineRange(caretScreenLine,caretScreenLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tcaretScreenLine = chunkCache.getScreenLineOfOffset(newCaretLine,\\n\\t\\t\\t\\t\\tnewCaret - buffer.getLineStartOffset(newCaretLine));\\n\\t\\t\\t\\tinvalidateLineRange(caretLine,newCaretLine);\\n\\t\\t\\t}\\n\\t\\t\\tcaret = newCaret;\\n\\t\\t\\tcaretLine = newCaretLine;\\n\\t\\t\\tif(view.getTextArea() == this)\\n\\t\\t\\t\\tfinishCaretUpdate(doElectricScroll,true);\\n\\t\\t}\\n\\t} \\n\\tpublic int getCaretPosition()\\n\\t{\\n\\t\\treturn caret;\\n\\t} \\n\\tpublic int getCaretLine()\\n\\t{\\n\\t\\treturn caretLine;\\n\\t} \\n\\tpublic final int getMagicCaretPosition()\\n\\t{\\n\\t\\tif(magicCaret == -1)\\n\\t\\t{\\n\\t\\t\\tmagicCaret = offsetToX(caretLine,caret\\n\\t\\t\\t\\t- getLineStartOffset(caretLine));\\n\\t\\t}\\n\\t\\treturn magicCaret;\\n\\t} \\n\\tpublic final void setMagicCaretPosition(int magicCaret)\\n\\t{\\n\\t\\tthis.magicCaret = magicCaret;\\n\\t} \\n\\tpublic final void addCaretListener(CaretListener listener)\\n\\t{\\n\\t\\tlistenerList.add(CaretListener.class,listener);\\n\\t} \\n\\tpublic final void removeCaretListener(CaretListener listener)\\n\\t{\\n\\t\\tlistenerList.remove(CaretListener.class,listener);\\n\\t} \\n\\tpublic final int getBracketPosition()\\n\\t{\\n\\t\\treturn bracketPosition;\\n\\t} \\n\\tpublic final int getBracketLine()\\n\\t{\\n\\t\\treturn bracketLine;\\n\\t} \\n\\tpublic void goToNextBracket(boolean select)\\n\\t{\\n\\t\\tString text = getText(caret,buffer.getLength() - caret - 1);\\n\\t\\tint newCaret = -1;\\nloop:\\t\\tfor(int i = 0; i < text.length(); i++)\\n\\t\\t{\\n\\t\\t\\tswitch(text.charAt(i))\\n\\t\\t\\t{\\n\\t\\t\\tcase ')': case ']': case '}':\\n\\t\\t\\t\\tnewCaret = caret + i + 1;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(newCaret == -1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(select)\\n\\t\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\t\\telse if(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t}\\n\\t} \\n\\tpublic void goToNextCharacter(boolean select)\\n\\t{\\n\\t\\tif(!select && selection.size() != 0)\\n\\t\\t{\\n\\t\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\t\\tif(s != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(multi)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(caret != s.end)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tmoveCaretPosition(s.end);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsetCaretPosition(s.end);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(caret == buffer.getLength())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\tint newCaret;\\n\\t\\tif(caret == getLineEndOffset(caretLine) - 1)\\n\\t\\t{\\n\\t\\t\\tint line = foldVisibilityManager.getNextVisibleLine(caretLine);\\n\\t\\t\\tif(line == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret = getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tnewCaret = caret + 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToNextLine(boolean select)\\n\\t{\\n\\t\\tChunkCache.LineInfo[] lineInfos = chunkCache.getLineInfosForPhysicalLine(caretLine);\\n\\t\\tint caretFromStartOfLine = caret - buffer.getLineStartOffset(caretLine);\\n\\t\\tint subregion = getSubregionOfOffset(caretFromStartOfLine,\\n\\t\\t\\tlineInfos);\\n\\t\\tint magic = this.magicCaret;\\n\\t\\tif(magic == -1)\\n\\t\\t{\\n\\t\\t\\tmagic = subregionOffsetToX(lineInfos[subregion],\\n\\t\\t\\t\\tcaretFromStartOfLine);\\n\\t\\t}\\n\\t\\tint newCaret;\\n\\t\\tif(subregion != lineInfos.length - 1)\\n\\t\\t{\\n\\t\\t\\tnewCaret = buffer.getLineStartOffset(caretLine)\\n\\t\\t\\t\\t+ xToSubregionOffset(lineInfos[subregion + 1],magic,\\n\\t\\t\\t\\ttrue);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint nextLine = foldVisibilityManager.getNextVisibleLine(caretLine);\\n\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint end = getLineEndOffset(caretLine) - 1;\\n\\t\\t\\t\\tif(caret == end)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tnewCaret = end;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tlineInfos = chunkCache.getLineInfosForPhysicalLine(nextLine);\\n\\t\\t\\t\\tnewCaret = getLineStartOffset(nextLine)\\n\\t\\t\\t\\t\\t+ xToSubregionOffset(lineInfos[0],magic + 1,\\n\\t\\t\\t\\t\\ttrue);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tthis.magicCaret = magic;\\n\\t} \\n\\tpublic void goToNextMarker(boolean select)\\n\\t{\\n\\t\\tVector markers = buffer.getMarkers();\\n\\t\\tif(markers.size() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tMarker marker = null;\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker _marker = (Marker)markers.get(i);\\n\\t\\t\\tif(_marker.getPosition() > caret)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmarker = _marker;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(marker == null)\\n\\t\\t\\tmarker = (Marker)markers.get(0);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,marker.getPosition());\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(marker.getPosition());\\n\\t} \\n\\tpublic void goToNextPage(boolean select)\\n\\t{\\n\\t\\tint lineCount = getVirtualLineCount();\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tif(firstLine + visibleLines * 2 >= lineCount - 1)\\n\\t\\t\\tsetFirstLine(lineCount - visibleLines);\\n\\t\\telse\\n\\t\\t\\tsetFirstLine(firstLine + visibleLines);\\n\\t\\tint newLine = virtualToPhysical(Math.min(lineCount - 1,\\n\\t\\t\\tphysicalToVirtual(caretLine) + visibleLines));\\n\\t\\tint newCaret = getLineStartOffset(newLine)\\n\\t\\t\\t+ xToOffset(newLine,magic + 1);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToNextParagraph(boolean select)\\n\\t{\\n\\t\\tint lineNo = getCaretLine();\\n\\t\\tint newCaret = getBufferLength();\\n\\t\\tboolean foundBlank = false;\\nloop:\\t\\tfor(int i = lineNo + 1; i < getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tif(!foldVisibilityManager.isLineVisible(i))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif(foundBlank)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnewCaret = getLineStartOffset(i);\\n\\t\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfoundBlank = true;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToNextWord(boolean select)\\n\\t{\\n\\t\\tgoToNextWord(select,false);\\n\\t} \\n\\tpublic void goToNextWord(boolean select, boolean stdNextPrevWord)\\n\\t{\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint newCaret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(newCaret == lineText.length())\\n\\t\\t{\\n\\t\\t\\tint nextLine = foldVisibilityManager.getNextVisibleLine(caretLine);\\n\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret = getLineStartOffset(nextLine);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tnewCaret = TextUtilities.findWordEnd(lineText,newCaret + 1,\\n\\t\\t\\t\\tnoWordSep);\\n\\t\\t\\tif(stdNextPrevWord)\\n\\t\\t\\t{\\n\\t\\t\\t\\twhile((newCaret < lineText.length()) && Character.isWhitespace(lineText.charAt(newCaret)))\\n\\t\\t\\t\\t\\tnewCaret = TextUtilities.findWordEnd(lineText,newCaret + 1,\\n\\t\\t\\t\\t\\t\\tnoWordSep);\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret += lineStart;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToPrevBracket(boolean select)\\n\\t{\\n\\t\\tString text = getText(0,caret);\\n\\t\\tint newCaret = -1;\\nloop:\\t\\tfor(int i = getCaretPosition() - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tswitch(text.charAt(i))\\n\\t\\t\\t{\\n\\t\\t\\tcase '(': case '[': case '{':\\n\\t\\t\\t\\tnewCaret = i;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(newCaret == -1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(select)\\n\\t\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\t\\telse if(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t}\\n\\t} \\n\\tpublic void goToPrevCharacter(boolean select)\\n\\t{\\n\\t\\tif(!select && selection.size() != 0)\\n\\t\\t{\\n\\t\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\t\\tif(s != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(multi)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(caret != s.start)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tmoveCaretPosition(s.start);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsetCaretPosition(s.start);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint newCaret;\\n\\t\\tif(caret == getLineStartOffset(caretLine))\\n\\t\\t{\\n\\t\\t\\tint line = foldVisibilityManager.getPrevVisibleLine(caretLine);\\n\\t\\t\\tif(line == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret = getLineEndOffset(line) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tnewCaret = caret - 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToPrevLine(boolean select)\\n\\t{\\n\\t\\tChunkCache.LineInfo[] lineInfos = chunkCache.getLineInfosForPhysicalLine(caretLine);\\n\\t\\tint caretFromStartOfLine = caret - buffer.getLineStartOffset(caretLine);\\n\\t\\tint subregion = getSubregionOfOffset(caretFromStartOfLine,\\n\\t\\t\\tlineInfos);\\n\\t\\tint magic = this.magicCaret;\\n\\t\\tif(magic == -1)\\n\\t\\t{\\n\\t\\t\\tmagic = subregionOffsetToX(lineInfos[subregion],\\n\\t\\t\\t\\tcaretFromStartOfLine);\\n\\t\\t}\\n\\t\\tint newCaret;\\n\\t\\tif(subregion != 0)\\n\\t\\t{\\n\\t\\t\\tnewCaret = buffer.getLineStartOffset(caretLine)\\n\\t\\t\\t\\t+ xToSubregionOffset(lineInfos[subregion - 1],magic,\\n\\t\\t\\t\\ttrue);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint prevLine = foldVisibilityManager.getPrevVisibleLine(caretLine);\\n\\t\\t\\tif(prevLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\t\\t\\tif(caret == start)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tnewCaret = start;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tlineInfos = chunkCache.getLineInfosForPhysicalLine(prevLine);\\n\\t\\t\\t\\tnewCaret = getLineStartOffset(prevLine)\\n\\t\\t\\t\\t\\t+ xToSubregionOffset(lineInfos[\\n\\t\\t\\t\\t\\tlineInfos.length - 1],magic + 1,\\n\\t\\t\\t\\t\\ttrue);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tthis.magicCaret = magic;\\n\\t} \\n\\tpublic void goToPrevMarker(boolean select)\\n\\t{\\n\\t\\tVector markers = buffer.getMarkers();\\n\\t\\tif(markers.size() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tMarker marker = null;\\n\\t\\tfor(int i = markers.size() - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tMarker _marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tif(_marker.getPosition() < caret)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmarker = _marker;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(marker == null)\\n\\t\\t\\tmarker = (Marker)markers.get(markers.size() - 1);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,marker.getPosition());\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(marker.getPosition());\\n\\t} \\n\\tpublic void goToPrevPage(boolean select)\\n\\t{\\n\\t\\tif(firstLine < visibleLines)\\n\\t\\t\\tsetFirstLine(0);\\n\\t\\telse\\n\\t\\t\\tsetFirstLine(firstLine - visibleLines);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newLine = virtualToPhysical(Math.max(0,\\n\\t\\t\\tphysicalToVirtual(caretLine) - visibleLines));\\n\\t\\tint newCaret = getLineStartOffset(newLine)\\n\\t\\t\\t+ xToOffset(newLine,magic + 1);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToPrevParagraph(boolean select)\\n\\t{\\n\\t\\tint lineNo = caretLine;\\n\\t\\tint newCaret = 0;\\n\\t\\tboolean foundBlank = false;\\nloop:\\t\\tfor(int i = lineNo - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(!foldVisibilityManager.isLineVisible(i))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif(foundBlank)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnewCaret = getLineEndOffset(i) - 1;\\n\\t\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfoundBlank = true;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToPrevWord(boolean select)\\n\\t{\\n\\t\\tgoToPrevWord(select,false);\\n\\t} \\n\\tpublic void goToPrevWord(boolean select, boolean stdNextPrevWord)\\n\\t{\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint newCaret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(newCaret == 0)\\n\\t\\t{\\n\\t\\t\\tif(lineStart == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tview.getToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint prevLine = foldVisibilityManager.getPrevVisibleLine(caretLine);\\n\\t\\t\\t\\tif(prevLine == -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnewCaret = getLineEndOffset(prevLine) - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tnewCaret = TextUtilities.findWordStart(lineText,newCaret - 1,\\n\\t\\t\\t\\tnoWordSep);\\n\\t\\t\\tif(stdNextPrevWord)\\n\\t\\t\\t{\\n\\t\\t\\t\\twhile((newCaret > 0) && Character.isWhitespace(lineText.charAt(newCaret)))\\n\\t\\t\\t\\t\\tnewCaret = TextUtilities.findWordStart(lineText,newCaret - 1,\\n\\t\\t\\t\\t\\t\\tnoWordSep);\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret += lineStart;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void smartHome(boolean select)\\n\\t{\\n\\t\\tMacros.Recorder recorder = view.getMacroRecorder();\\n\\t\\tswitch(view.getInputHandler().getLastActionCount())\\n\\t\\t{\\n\\t\\tcase 1:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToStartOfWhiteSpace(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToStartOfWhiteSpace(select);\\n\\t\\t\\tbreak;\\n\\t\\tcase 2:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToStartOfLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToStartOfLine(select);\\n\\t\\t\\tbreak;\\n\\t\\tdefault: \\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToFirstVisibleLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToFirstVisibleLine(select);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t} \\n\\tpublic void smartEnd(boolean select)\\n\\t{\\n\\t\\tMacros.Recorder recorder = view.getMacroRecorder();\\n\\t\\tswitch(view.getInputHandler().getLastActionCount())\\n\\t\\t{\\n\\t\\tcase 1:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToEndOfWhiteSpace(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToEndOfWhiteSpace(select);\\n\\t\\t\\tbreak;\\n\\t\\tcase 2:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToEndOfLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToEndOfLine(select);\\n\\t\\t\\tbreak;\\n\\t\\tdefault: \\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToLastVisibleLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToLastVisibleLine(select);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t} \\n\\tpublic void goToStartOfLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line = (select || s == null\\n\\t\\t\\t? caretLine : s.startLine);\\n\\t\\tint newCaret = getLineStartOffset(line);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToEndOfLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line = (select || s == null\\n\\t\\t\\t? caretLine : s.endLine);\\n\\t\\tint newCaret = getLineEndOffset(line) - 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t\\t\\t\\t\\t\\t} \\n\\tpublic void goToStartOfWhiteSpace(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line, offset;\\n\\t\\tif(select || s == null)\\n\\t\\t{\\n\\t\\t\\tline = caretLine;\\n\\t\\t\\toffset = caret - buffer.getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tline = s.startLine;\\n\\t\\t\\toffset = s.start - buffer.getLineStartOffset(line);\\n\\t\\t}\\n\\t\\tint firstIndent;\\n\\t\\tChunkCache.LineInfo[] lineInfos = chunkCache.getLineInfosForPhysicalLine(line);\\n\\t\\tint subregion = getSubregionOfOffset(offset,lineInfos);\\n\\t\\tif(subregion == 0)\\n\\t\\t{\\n\\t\\t\\tfirstIndent = MiscUtilities.getLeadingWhiteSpace(getLineText(line));\\n\\t\\t\\tif(firstIndent == getLineLength(line))\\n\\t\\t\\t\\tfirstIndent = 0;\\n\\t\\t\\tfirstIndent += getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfirstIndent = getLineStartOffset(line)\\n\\t\\t\\t\\t+ lineInfos[subregion].offset;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,firstIndent);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(firstIndent);\\n\\t} \\n\\tpublic void goToEndOfWhiteSpace(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line, offset;\\n\\t\\tif(select || s == null)\\n\\t\\t{\\n\\t\\t\\tline = caretLine;\\n\\t\\t\\toffset = caret - getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tline = s.endLine;\\n\\t\\t\\toffset = s.end - getLineStartOffset(line);\\n\\t\\t}\\n\\t\\tint lastIndent;\\n\\t\\tChunkCache.LineInfo[] lineInfos = chunkCache.getLineInfosForPhysicalLine(line);\\n\\t\\tint subregion = getSubregionOfOffset(offset,lineInfos);\\n\\t\\tif(subregion == lineInfos.length - 1)\\n\\t\\t{\\n\\t\\t\\tlastIndent = getLineLength(line) - MiscUtilities.getTrailingWhiteSpace(getLineText(line));\\n\\t\\t\\tif(lastIndent == 0)\\n\\t\\t\\t\\tlastIndent = getLineLength(line);\\n\\t\\t\\tlastIndent += getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlastIndent = getLineStartOffset(line)\\n\\t\\t\\t\\t+ lineInfos[subregion].offset\\n\\t\\t\\t\\t+ lineInfos[subregion].length - 1;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,lastIndent);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(lastIndent);\\n\\t} \\n\\tpublic void goToFirstVisibleLine(boolean select)\\n\\t{\\n\\t\\tint firstVisibleLine = firstLine == 0 ? 0 : electricScroll;\\n\\t\\tint firstVisible = getScreenLineStartOffset(firstVisibleLine);\\n\\t\\tif(firstVisible == -1)\\n\\t\\t{\\n\\t\\t\\tfirstVisible = getLineStartOffset(foldVisibilityManager\\n\\t\\t\\t\\t.getFirstVisibleLine());\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,firstVisible);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(firstVisible);\\n\\t} \\n\\tpublic void goToLastVisibleLine(boolean select)\\n\\t{\\n\\t\\tint lastVisible;\\n\\t\\tif(firstLine + visibleLines >= getVirtualLineCount())\\n\\t\\t{\\n\\t\\t\\tlastVisible = getLineEndOffset(foldVisibilityManager\\n\\t\\t\\t\\t.getLastVisibleLine()) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlastVisible = getScreenLineEndOffset(visibleLines\\n\\t\\t\\t\\t- electricScroll - 1) - 1;\\n\\t\\t\\tif(lastVisible == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlastVisible = getLineEndOffset(foldVisibilityManager\\n\\t\\t\\t\\t\\t.getLastVisibleLine()) - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,lastVisible);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(lastVisible);\\n\\t} \\n\\tpublic void goToBufferStart(boolean select)\\n\\t{\\n\\t\\tint start = buffer.getLineStartOffset(\\n\\t\\t\\tfoldVisibilityManager.getFirstVisibleLine());\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,start);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(start);\\n\\t} \\n\\tpublic void goToBufferEnd(boolean select)\\n\\t{\\n\\t\\tint end = buffer.getLineEndOffset(\\n\\t\\t\\tfoldVisibilityManager.getLastVisibleLine()) - 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,end);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(end);\\n\\t} \\n\\tpublic void goToMatchingBracket()\\n\\t{\\n\\t\\tif(getLineLength(caretLine) != 0)\\n\\t\\t{\\n\\t\\t\\tint dot = caret - getLineStartOffset(caretLine);\\n\\t\\t\\tint bracket = TextUtilities.findMatchingBracketFuzzy(\\n\\t\\t\\t\\tbuffer,caretLine,Math.max(0,dot - 1));\\n\\t\\t\\tif(bracket != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\t\\tmoveCaretPosition(bracket + 1,false);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tgetToolkit().beep();\\n\\t} \\n\\tpublic void showGoToLineDialog()\\n\\t{\\n\\t\\tString line = GUIUtilities.input(view,\\\"goto-line\\\",null);\\n\\t\\tif(line == null)\\n\\t\\t\\treturn;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tint lineNumber = Integer.parseInt(line) - 1;\\n\\t\\t\\tsetCaretPosition(getLineStartOffset(lineNumber));\\n\\t\\t}\\n\\t\\tcatch(Exception e)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t}\\n\\t} \\n\\tpublic void userInput(char ch)\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(ch == ' ' && Abbrevs.getExpandOnInput()\\n\\t\\t\\t&& Abbrevs.expandAbbrev(view,false))\\n\\t\\t\\treturn;\\n\\t\\telse if(ch == '\\\\t')\\n\\t\\t{\\n\\t\\t\\tif(selection.size() == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection sel = (Selection)selection.elementAt(0);\\n\\t\\t\\t\\tif(sel.startLine == sel.endLine\\n\\t\\t\\t\\t\\t&& sel.start != buffer.getLineStartOffset(sel.startLine)\\n\\t\\t\\t\\t\\t&& sel.end != buffer.getLineEndOffset(sel.startLine) - 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tinsertTab();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tshiftIndentRight();\\n\\t\\t\\t}\\n\\t\\t\\telse if(selection.size() != 0)\\n\\t\\t\\t\\tshiftIndentRight();\\n\\t\\t\\telse\\n\\t\\t\\t\\tinsertTab();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tboolean indent;\\n\\t\\t\\t\\t\\t\\tString indentOpenBrackets = (String)buffer\\n\\t\\t\\t\\t.getProperty(\\\"indentOpenBrackets\\\");\\n\\t\\t\\tString indentCloseBrackets = (String)buffer\\n\\t\\t\\t\\t.getProperty(\\\"indentCloseBrackets\\\");\\n\\t\\t\\tif((indentCloseBrackets != null\\n\\t\\t\\t\\t&& indentCloseBrackets.indexOf(ch) != -1)\\n\\t\\t\\t\\t|| (indentOpenBrackets != null\\n\\t\\t\\t\\t&& indentOpenBrackets.indexOf(ch) != -1))\\n\\t\\t\\t{\\n\\t\\t\\t\\tindent = true;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tindent = false;\\n\\t\\t\\t}\\n\\t\\t\\tString str = String.valueOf(ch);\\n\\t\\t\\tif(selection.size() != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetSelectedText(str);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(ch == ' ')\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(doWordWrap(true))\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tdoWordWrap(false);\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(overwrite || indent)\\n\\t\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tif(overwrite)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint caretLineEnd = getLineEndOffset(caretLine);\\n\\t\\t\\t\\t\\tif(caretLineEnd - caret > 1)\\n\\t\\t\\t\\t\\t\\tbuffer.remove(caret,1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbuffer.insert(caret,str);\\n\\t\\t\\t\\tif(indent)\\n\\t\\t\\t\\t\\tbuffer.indentLine(caretLine,false,true);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(overwrite || indent)\\n\\t\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic final boolean isOverwriteEnabled()\\n\\t{\\n\\t\\treturn overwrite;\\n\\t} \\n\\tpublic final void setOverwriteEnabled(boolean overwrite)\\n\\t{\\n\\t\\tblink = true;\\n\\t\\tcaretTimer.restart();\\n\\t\\tthis.overwrite = overwrite;\\n\\t\\tinvalidateLine(caretLine);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t\\tview.getStatus().updateMiscStatus();\\n\\t} \\n\\tpublic final void toggleOverwriteEnabled()\\n\\t{\\n\\t\\tsetOverwriteEnabled(!overwrite);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t{\\n\\t\\t\\tview.getStatus().setMessageAndClear(\\n\\t\\t\\t\\tjEdit.getProperty(\\\"view.status.overwrite-changed\\\",\\n\\t\\t\\t\\tnew Integer[] { new Integer(overwrite ? 1 : 0) }));\\n\\t\\t}\\n\\t} \\n\\tpublic void backspace()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() != 0)\\n\\t\\t\\tsetSelectedText(null);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(caret == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.remove(caret - 1,1);\\n\\t\\t}\\n\\t} \\n\\tpublic void backspaceWord()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() != 0)\\n\\t\\t{\\n\\t\\t\\tsetSelectedText(\\\"\\\");\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint _caret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(_caret == 0)\\n\\t\\t{\\n\\t\\t\\tif(lineStart == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t_caret--;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\t_caret = TextUtilities.findWordStart(lineText,_caret-1,noWordSep);\\n\\t\\t}\\n\\t\\tbuffer.remove(_caret + lineStart,\\n\\t\\t\\tcaret - (_caret + lineStart));\\n\\t} \\n\\tpublic void delete()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() != 0)\\n\\t\\t\\tsetSelectedText(null);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(caret == buffer.getLength())\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.remove(caret,1);\\n\\t\\t}\\n\\t} \\n\\tpublic void deleteToEndOfLine()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.remove(caret,getLineEndOffset(caretLine)\\n\\t\\t\\t- caret - 1);\\n\\t} \\n\\tpublic void deleteLine()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine);\\n\\t\\tif(end > buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tif(start != 0)\\n\\t\\t\\t\\tstart--;\\n\\t\\t\\tend--;\\n\\t\\t}\\n\\t\\tint x = offsetToX(caretLine,caret - start);\\n\\t\\tbuffer.remove(start,end - start);\\n\\t\\tint lastLine = buffer.getLineCount() - 1;\\n\\t\\tif(caretLine == lastLine)\\n\\t\\t{\\n\\t\\t\\tsetCaretPosition(buffer.getLineStartOffset(lastLine)\\n\\t\\t\\t\\t+ xToOffset(caretLine,x));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tsetCaretPosition(start + xToOffset(caretLine,x));\\n\\t\\t}\\n\\t} \\n\\tpublic void deleteParagraph()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint start = 0, end = buffer.getLength();\\nloop:\\t\\tfor(int i = caretLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tstart = getLineStartOffset(i);\\n\\t\\t\\tbreak loop;\\n\\t\\t}\\nloop:\\t\\tfor(int i = caretLine + 1; i < getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tend = getLineEndOffset(i) - 1;\\n\\t\\t\\tbreak loop;\\n\\t\\t}\\n\\t\\tbuffer.remove(start,end - start);\\n\\t} \\n\\tpublic void deleteToStartOfLine()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.remove(getLineStartOffset(caretLine),\\n\\t\\t\\tcaret - getLineStartOffset(caretLine));\\n\\t} \\n\\tpublic void deleteWord()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() != 0)\\n\\t\\t{\\n\\t\\t\\tsetSelectedText(\\\"\\\");\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint _caret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(_caret == lineText.length())\\n\\t\\t{\\n\\t\\t\\tif(lineStart + _caret == buffer.getLength())\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t_caret++;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\t_caret = TextUtilities.findWordEnd(lineText,\\n\\t\\t\\t\\t_caret+1,noWordSep);\\n\\t\\t}\\n\\t\\tbuffer.remove(caret,(_caret + lineStart) - caret);\\n\\t} \\n\\tpublic final boolean isMultipleSelectionEnabled()\\n\\t{\\n\\t\\treturn multi;\\n\\t} \\n\\tpublic final void toggleMultipleSelectionEnabled()\\n\\t{\\n\\t\\tsetMultipleSelectionEnabled(!multi);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t{\\n\\t\\t\\tview.getStatus().setMessageAndClear(\\n\\t\\t\\t\\tjEdit.getProperty(\\\"view.status.multi-changed\\\",\\n\\t\\t\\t\\tnew Integer[] { new Integer(multi ? 1 : 0) }));\\n\\t\\t}\\n\\t} \\n\\tpublic final void setMultipleSelectionEnabled(boolean multi)\\n\\t{\\n\\t\\tthis.multi = multi;\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t\\tview.getStatus().updateMiscStatus();\\n\\t} \\n\\tpublic void goToMarker(char shortcut, boolean select)\\n\\t{\\n\\t\\tMarker marker = buffer.getMarker(shortcut);\\n\\t\\tif(marker == null)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint pos = marker.getPosition();\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,pos);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(pos);\\n\\t} \\n\\tpublic void addMarker()\\n\\t{\\n\\t\\t\\t\\tSelection[] selection = getSelection();\\n\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\tif(s.startLine != s.endLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s.startLine != caretLine)\\n\\t\\t\\t\\t\\tbuffer.addMarker('\\\\0',s.start);\\n\\t\\t\\t}\\n\\t\\t\\tif(s.endLine != caretLine)\\n\\t\\t\\t\\tbuffer.addMarker('\\\\0',s.end);\\n\\t\\t}\\n\\t\\t\\t\\tbuffer.addOrRemoveMarker('\\\\0',caret);\\n\\t} \\n\\tpublic void swapMarkerAndCaret(char shortcut)\\n\\t{\\n\\t\\tMarker marker = buffer.getMarker(shortcut);\\n\\t\\tif(marker == null)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint caret = getCaretPosition();\\n\\t\\tsetCaretPosition(marker.getPosition());\\n\\t\\tbuffer.addMarker(shortcut,caret);\\n\\t} \\n\\tpublic void goToParentFold()\\n\\t{\\n\\t\\tint line = -1;\\n\\t\\tint level = buffer.getFoldLevel(caretLine);\\n\\t\\tfor(int i = caretLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(buffer.getFoldLevel(i) < level)\\n\\t\\t\\t{\\n\\t\\t\\t\\tline = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(line == -1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = buffer.getLineStartOffset(line)\\n\\t\\t\\t+ xToOffset(line,magic + 1);\\n\\t\\tif(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToNextFold(boolean select)\\n\\t{\\n\\t\\tint line = caretLine;\\n\\t\\tint nextFold = -1;\\n\\t\\tfor(int i = caretLine + 1; i < buffer.getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tif(buffer.isFoldStart(i)\\n\\t\\t\\t\\t&& foldVisibilityManager.isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\tnextFold = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(nextFold == -1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = buffer.getLineStartOffset(nextFold)\\n\\t\\t\\t+ xToOffset(nextFold,magic + 1);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToPrevFold(boolean select)\\n\\t{\\n\\t\\tint line = caretLine;\\n\\t\\tint prevFold = -1;\\n\\t\\tfor(int i = caretLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(buffer.isFoldStart(i)\\n\\t\\t\\t\\t&& foldVisibilityManager.isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\tprevFold = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(prevFold == -1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = buffer.getLineStartOffset(prevFold)\\n\\t\\t\\t+ xToOffset(prevFold,magic + 1);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void collapseFold()\\n\\t{\\n\\t\\tint x = offsetToX(caretLine,caret - getLineStartOffset(caretLine));\\n\\t\\tfoldVisibilityManager.collapseFold(caretLine);\\n\\t\\tif(foldVisibilityManager.isLineVisible(caretLine))\\n\\t\\t\\treturn;\\n\\t\\tint line = foldVisibilityManager.getPrevVisibleLine(caretLine);\\n\\t\\tif(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(buffer.getLineStartOffset(line) + xToOffset(line,x));\\n\\t} \\n\\tpublic void expandFold(boolean fully)\\n\\t{\\n\\t\\tint x = offsetToX(caretLine,caret - getLineStartOffset(caretLine));\\n\\t\\tint line = foldVisibilityManager.expandFold(caretLine,fully);\\n\\t\\tif(!fully && line != -1)\\n\\t\\t{\\n\\t\\t\\tif(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\tmoveCaretPosition(getLineStartOffset(line) + xToOffset(line,x));\\n\\t\\t}\\n\\t} \\n\\tpublic void selectFold()\\n\\t{\\n\\t\\tselectFold(caretLine);\\n\\t} \\n\\tpublic void selectFold(int line)\\n\\t{\\n\\t\\tint[] lines = buffer.getFoldAtLine(line);\\n\\t\\tint newCaret = getLineEndOffset(lines[1]) - 1;\\n\\t\\tSelection s = new Selection.Range(getLineStartOffset(lines[0]),newCaret);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void narrowToFold()\\n\\t{\\n\\t\\tint[] lines = buffer.getFoldAtLine(caretLine);\\n\\t\\tif(lines[0] == 0 && lines[1] == buffer.getLineCount() - 1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t\\tfoldVisibilityManager.narrow(lines[0],lines[1]);\\n\\t} \\n\\tpublic void narrowToSelection()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tSelection sel = (Selection)selection.elementAt(0);\\n\\t\\tfoldVisibilityManager.narrow(sel.getStartLine(),sel.getEndLine());\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic void addExplicitFold()\\n\\t{\\n\\t\\tif(!buffer.getStringProperty(\\\"folding\\\").equals(\\\"explicit\\\"))\\n\\t\\t{\\n\\t\\t\\tGUIUtilities.error(view,\\\"folding-not-explicit\\\",null);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tString lineComment = buffer.getContextSensitiveProperty(caret,\\\"lineComment\\\");\\n\\t\\tString commentStart = buffer.getContextSensitiveProperty(caret,\\\"commentStart\\\");\\n\\t\\tString commentEnd = buffer.getContextSensitiveProperty(caret,\\\"commentEnd\\\");\\n\\t\\tString start, end;\\n\\t\\tif(lineComment != null)\\n\\t\\t{\\n\\t\\t\\tstart = lineComment + \\\"{{{ \\\\n\\\";\\n\\t\\t\\tend = lineComment + \\\"}}}\\\";\\n\\t\\t}\\n\\t\\telse if(commentStart != null && commentEnd != null)\\n\\t\\t{\\n\\t\\t\\tstart = commentStart + \\\"{{{  \\\" + commentEnd + \\\"\\\\n\\\";\\n\\t\\t\\tend = commentStart + \\\"}}}\\\" + commentEnd;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstart = \\\"{{{ \\\\n\\\";\\n\\t\\t\\tend = \\\"}}}\\\";\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tif(selection.size() == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tString line = buffer.getLineText(caretLine);\\n\\t\\t\\t\\tString whitespace = line.substring(0,\\n\\t\\t\\t\\t\\tMiscUtilities.getLeadingWhiteSpace(line));\\n\\t\\t\\t\\tint loc = caret + start.length() - 1;\\n\\t\\t\\t\\tstart = start + whitespace;\\n\\t\\t\\t\\tbuffer.insert(caret,start);\\n\\t\\t\\t\\t\\t\\t\\t\\tbuffer.insert(caret,end);\\n\\t\\t\\t\\tmoveCaretPosition(loc,false);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint loc = -1;\\n\\t\\t\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\t\\t\\tString line = buffer.getLineText(s.startLine);\\n\\t\\t\\t\\t\\tString whitespace = line.substring(0,\\n\\t\\t\\t\\t\\t\\tMiscUtilities.getLeadingWhiteSpace(line));\\n\\t\\t\\t\\t\\tloc = s.start + start.length() - 1;\\n\\t\\t\\t\\t\\tbuffer.insert(s.start,start + whitespace);\\n\\t\\t\\t\\t\\tbuffer.insert(s.end,\\\" \\\" + end);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsetCaretPosition(loc,false);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void lineComment()\\n\\t{\\n\\t\\tString comment = buffer.getContextSensitiveProperty(caret,\\\"lineComment\\\");\\n\\t\\tif(!buffer.isEditable() || comment == null || comment.length() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tcomment = comment + ' ';\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tint[] lines = getSelectedLines();\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < lines.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tString text = getLineText(lines[i]);\\n\\t\\t\\t\\tbuffer.insert(getLineStartOffset(lines[i])\\n\\t\\t\\t\\t\\t+ MiscUtilities.getLeadingWhiteSpace(text),\\n\\t\\t\\t\\t\\tcomment);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic void rangeComment()\\n\\t{\\n\\t\\tString commentStart = buffer.getContextSensitiveProperty(caret,\\\"commentStart\\\");\\n\\t\\tString commentEnd = buffer.getContextSensitiveProperty(caret,\\\"commentEnd\\\");\\n\\t\\tif(!buffer.isEditable() || commentStart == null || commentEnd == null\\n\\t\\t\\t|| commentStart.length() == 0 || commentEnd.length() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tcommentStart = commentStart + ' ';\\n\\t\\tcommentEnd = ' ' + commentEnd;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tSelection[] selection = getSelection();\\n\\t\\t\\tif(selection.length == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint oldCaret = caret;\\n\\t\\t\\t\\tbuffer.insert(caret,commentStart);\\n\\t\\t\\t\\tbuffer.insert(caret,commentEnd);\\n\\t\\t\\t\\tsetCaretPosition(oldCaret + commentStart.length());\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tif(s instanceof Selection.Range)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbuffer.insert(s.start,commentStart);\\n\\t\\t\\t\\t\\tbuffer.insert(s.end,commentEnd);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(s instanceof Selection.Rect)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection.Rect rect = (Selection.Rect)s;\\n\\t\\t\\t\\t\\tint start = rect.getStartColumn(buffer);\\n\\t\\t\\t\\t\\tint end = rect.getEndColumn(buffer);\\n\\t\\t\\t\\t\\tfor(int j = s.startLine; j <= s.endLine; j++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.insertAtColumn(j,end,\\n\\t\\t\\t\\t\\t\\t\\tcommentEnd);\\n\\t\\t\\t\\t\\t\\tbuffer.insertAtColumn(j,start,\\n\\t\\t\\t\\t\\t\\t\\tcommentStart);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tselectNone();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void formatParagraph()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(maxLineLen <= 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(selection.length != 0)\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tsetSelectedText(s,TextUtilities.format(\\n\\t\\t\\t\\t\\tgetSelectedText(s),maxLineLen));\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint lineNo = getCaretLine();\\n\\t\\t\\tint start = 0, end = buffer.getLength();\\nloop:\\t\\t\\tfor(int i = lineNo - 1; i >= 0; i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstart = getLineStartOffset(i);\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\nloop:\\t\\t\\tfor(int i = lineNo + 1; i < getLineCount(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tend = getLineEndOffset(i) - 1;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tString text = buffer.getText(start,end - start);\\n\\t\\t\\t\\tbuffer.remove(start,end - start);\\n\\t\\t\\t\\tbuffer.insert(start,TextUtilities.format(\\n\\t\\t\\t\\t\\ttext,maxLineLen));\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic void spacesToTabs()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tif(selection.length == 0)\\n\\t\\t{\\n\\t\\t\\tsetText(TextUtilities.spacesToTabs(\\n\\t\\t\\t\\tgetText(), buffer.getTabSize()));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tsetSelectedText(s,TextUtilities.spacesToTabs(\\n\\t\\t\\t\\t\\tgetSelectedText(s),buffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void tabsToSpaces()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tif(selection.length == 0)\\n\\t\\t{\\n\\t\\t\\tsetText(TextUtilities.tabsToSpaces(\\n\\t\\t\\t\\tgetText(), buffer.getTabSize()));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tsetSelectedText(s,TextUtilities.tabsToSpaces(\\n\\t\\t\\t\\t\\tgetSelectedText(s),buffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void toUpperCase()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable() || selection.length == 0)\\n                {\\n                \\tgetToolkit().beep();\\n                \\treturn;\\n                }\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\tsetSelectedText(s,getSelectedText(s).toUpperCase());\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void toLowerCase()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable() || selection.length == 0)\\n                {\\n                \\tgetToolkit().beep();\\n                \\treturn;\\n                }\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\tsetSelectedText(s,getSelectedText(s).toLowerCase());\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void removeTrailingWhiteSpace()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbuffer.removeTrailingWhiteSpace(getSelectedLines());\\n\\t\\t}\\n\\t} \\n\\t\\tpublic void insertEnterAndIndent()\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tsetSelectedText(\\\"\\\\n\\\");\\n\\t\\t\\t\\tbuffer.indentLine(caretLine,true,false);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tpublic void insertTabAndIndent()\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() == 0)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tString text = buffer.getLineText(caretLine);\\n\\t\\t\\tint start = buffer.getLineStartOffset(caretLine);\\n\\t\\t\\tint whiteSpace = MiscUtilities.getLeadingWhiteSpace(text);\\n\\t\\t\\tif(caret - start <= whiteSpace\\n\\t\\t\\t\\t&& buffer.indentLine(caretLine,true,false))\\n\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tuserInput('\\\\t');\\n\\t} \\n\\tpublic void indentSelectedLines()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbuffer.indentLines(getSelectedLines());\\n\\t\\t\\tselectNone();\\n\\t\\t}\\n\\t} \\n\\tpublic void shiftIndentLeft()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbuffer.shiftIndentLeft(getSelectedLines());\\n\\t\\t}\\n\\t} \\n\\tpublic void shiftIndentRight()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t\\tbuffer.shiftIndentRight(getSelectedLines());\\n\\t} \\n\\tpublic void joinLines()\\n\\t{\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine);\\n\\t\\tif(end > buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.remove(end - 1,MiscUtilities.getLeadingWhiteSpace(\\n\\t\\t\\tbuffer.getLineText(caretLine + 1)) + 1);\\n\\t\\tsetCaretPosition(end - 1);\\n\\t} \\n\\tpublic void showWordCountDialog()\\n\\t{\\n\\t\\tString selection = getSelectedText();\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tdoWordCount(view,selection);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tdoWordCount(view,buffer.getText(0,buffer.getLength()));\\n\\t} \\n\\tpublic void addNotify()\\n\\t{\\n\\t\\tsuper.addNotify();\\n\\t\\tToolTipManager.sharedInstance().registerComponent(painter);\\n\\t\\tToolTipManager.sharedInstance().registerComponent(gutter);\\n\\t\\tif(!bufferHandlerInstalled)\\n\\t\\t{\\n\\t\\t\\tbufferHandlerInstalled = true;\\n\\t\\t\\tbuffer.addBufferChangeListener(bufferHandler);\\n\\t\\t}\\n\\t\\trecalculateVisibleLines();\\n\\t\\trecalculateLastPhysicalLine();\\n\\t} \\n\\tpublic void removeNotify()\\n\\t{\\n\\t\\tsuper.removeNotify();\\n\\t\\tToolTipManager.sharedInstance().unregisterComponent(painter);\\n\\t\\tToolTipManager.sharedInstance().unregisterComponent(gutter);\\n\\t\\tif(focusedComponent == this)\\n\\t\\t\\tfocusedComponent = null;\\n\\t\\tif(bufferHandlerInstalled)\\n\\t\\t{\\n\\t\\t\\tbuffer.removeBufferChangeListener(bufferHandler);\\n\\t\\t\\tbufferHandlerInstalled = false;\\n\\t\\t}\\n\\t} \\n\\tpublic boolean hasFocus()\\n\\t{\\n\\t\\tComponent c = this;\\n\\t\\twhile(!(c instanceof Window))\\n\\t\\t{\\n\\t\\t\\tif(c == null)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tc = c.getParent();\\n\\t\\t}\\n\\t\\tComponent focusOwner = ((Window)c).getFocusOwner();\\n\\t\\tboolean hasFocus = (focusOwner == this);\\n\\t\\tif(hasFocus)\\n\\t\\t\\tfocusedComponent = this;\\n\\t\\treturn hasFocus;\\n\\t} \\n\\tpublic void grabFocus()\\n\\t{\\n\\t\\tsuper.grabFocus();\\n\\t\\t\\t\\thasFocus();\\n\\t} \\n\\tpublic boolean getFocusTraversalKeysEnabled()\\n\\t{\\n\\t\\treturn false;\\n\\t} \\n\\t\\t\\tlong time;\\n\\tboolean timing;\\n\\tpublic void processKeyEvent(KeyEvent evt)\\n\\t{\\n\\t\\ttime = System.currentTimeMillis();\\n\\t\\tevt = KeyEventWorkaround.processKeyEvent(evt);\\n\\t\\tif(evt == null)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\tif(view.isClosed())\\n\\t\\t\\treturn;\\n\\t\\tInputHandler inputHandler = view.getInputHandler();\\n\\t\\tKeyListener keyEventInterceptor = view.getKeyEventInterceptor();\\n\\t\\tswitch(evt.getID())\\n\\t\\t{\\n\\t\\tcase KeyEvent.KEY_TYPED:\\n\\t\\t\\t\\t\\t\\tif(keyEventInterceptor != null)\\n\\t\\t\\t\\tkeyEventInterceptor.keyTyped(evt);\\n\\t\\t\\telse\\n\\t\\t\\t\\tinputHandler.keyTyped(evt);\\n\\t\\t\\tbreak;\\n\\t\\tcase KeyEvent.KEY_PRESSED:\\n\\t\\t\\tif(keyEventInterceptor != null)\\n\\t\\t\\t\\tkeyEventInterceptor.keyPressed(evt);\\n\\t\\t\\telse\\n\\t\\t\\t\\tinputHandler.keyPressed(evt);\\n\\t\\t\\tbreak;\\n\\t\\tcase KeyEvent.KEY_RELEASED:\\n\\t\\t\\tif(keyEventInterceptor != null)\\n\\t\\t\\t\\tkeyEventInterceptor.keyReleased(evt);\\n\\t\\t\\telse\\n\\t\\t\\t\\tinputHandler.keyReleased(evt);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tif(!evt.isConsumed())\\n\\t\\t\\tsuper.processKeyEvent(evt);\\n\\t} \\n\\tpublic void propertiesChanged()\\n\\t{\\n\\t\\tif(buffer == null)\\n\\t\\t\\treturn;\\n\\t\\tint _tabSize = buffer.getTabSize();\\n\\t\\tchar[] foo = new char[_tabSize];\\n\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t{\\n\\t\\t\\tfoo[i] = ' ';\\n\\t\\t}\\n\\t\\ttabSize = (float)painter.getFont().getStringBounds(foo,0,_tabSize,\\n\\t\\t\\tpainter.getFontRenderContext()).getWidth();\\n\\t\\tcharWidth = (int)Math.round(painter.getFont().getStringBounds(foo,0,1,\\n\\t\\t\\tpainter.getFontRenderContext()).getWidth());\\n\\t\\tString wrap = buffer.getStringProperty(\\\"wrap\\\");\\n\\t\\tsoftWrap = wrap.equals(\\\"soft\\\");\\n\\t\\thardWrap = wrap.equals(\\\"hard\\\");\\n\\t\\tmaxLineLen = buffer.getIntegerProperty(\\\"maxLineLen\\\",0);\\n\\t\\tif(maxLineLen <= 0)\\n\\t\\t{\\n\\t\\t\\tif(softWrap)\\n\\t\\t\\t{\\n\\t\\t\\t\\twrapToWidth = true;\\n\\t\\t\\t\\twrapMargin = painter.getWidth() - charWidth * 3;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\twrapToWidth = false;\\n\\t\\t\\t\\twrapMargin = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tfoo = new char[maxLineLen];\\n\\t\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfoo[i] = ' ';\\n\\t\\t\\t}\\n\\t\\t\\twrapToWidth = false;\\n\\t\\t\\twrapMargin = (int)painter.getFont().getStringBounds(\\n\\t\\t\\t\\tfoo,0,maxLineLen,painter.getFontRenderContext())\\n\\t\\t\\t\\t.getWidth();\\n\\t\\t}\\n\\t\\tmonospacedHack = jEdit.getBooleanProperty(\\\"view.monospacedHack\\\");\\n\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\tupdateScrollBars();\\n\\t\\tchunkCache.invalidateAll();\\n\\t\\tgutter.repaint();\\n\\t\\tpainter.repaint();\\n\\t} \\n\\tpublic int offsetToX(int line, int offset)\\n\\t{\\n\\t\\tChunk chunks = chunkCache.lineToChunkList(line);\\n\\t\\treturn (int)(horizontalOffset + Chunk.offsetToX(chunks,offset));\\n\\t} \\n\\tpublic int xToOffset(int line, int x)\\n\\t{\\n\\t\\tx -= horizontalOffset;\\n\\t\\tChunk chunks = chunkCache.lineToChunkList(line);\\n\\t\\tint offset = Chunk.xToOffset(chunks,x,true);\\n\\t\\tif(offset == -1)\\n\\t\\t\\toffset = getLineLength(line);\\n\\t\\treturn offset;\\n\\t} \\n\\tpublic int xToOffset(int line, int x, boolean round)\\n\\t{\\n\\t\\tx -= horizontalOffset;\\n\\t\\tChunk chunks = chunkCache.lineToChunkList(line);\\n\\t\\tint offset = Chunk.xToOffset(chunks,x,round);\\n\\t\\tif(offset == -1)\\n\\t\\t\\toffset = getLineLength(line);\\n\\t\\treturn offset;\\n\\t} \\n\\tpublic final int getSelectionStart()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getStart();\\n\\t} \\n\\tpublic int getSelectionStart(int line)\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getStart(\\n\\t\\t\\tbuffer,line);\\n\\t} \\n\\tpublic final int getSelectionStartLine()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getStartLine();\\n\\t} \\n\\tpublic final void setSelectionStart(int selectionStart)\\n\\t{\\n\\t\\tselect(selectionStart,getSelectionEnd(),true);\\n\\t} \\n\\tpublic final int getSelectionEnd()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getEnd();\\n\\t} \\n\\tpublic int getSelectionEnd(int line)\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getEnd(\\n\\t\\t\\tbuffer,line);\\n\\t} \\n\\tpublic final int getSelectionEndLine()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getEndLine();\\n\\t} \\n\\tpublic final void setSelectionEnd(int selectionEnd)\\n\\t{\\n\\t\\tselect(getSelectionStart(),selectionEnd,true);\\n\\t} \\n\\tpublic final int getMarkPosition()\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(s == null)\\n\\t\\t\\treturn caret;\\n\\t\\tif(s.start == caret)\\n\\t\\t\\treturn s.end;\\n\\t\\telse if(s.end == caret)\\n\\t\\t\\treturn s.start;\\n\\t\\telse\\n\\t\\t\\treturn caret;\\n\\t} \\n\\tpublic final int getMarkLine()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caretLine;\\n\\t\\tSelection s = (Selection)selection.elementAt(0);\\n\\t\\tif(s.start == caret)\\n\\t\\t\\treturn s.endLine;\\n\\t\\telse if(s.end == caret)\\n\\t\\t\\treturn s.startLine;\\n\\t\\telse\\n\\t\\t\\treturn caretLine;\\n\\t} \\n\\tpublic void select(int start, int end)\\n\\t{\\n\\t\\tselect(start,end,true);\\n\\t} \\n\\tpublic void select(int start, int end, boolean doElectricScroll)\\n\\t{\\n\\t\\tselectNone();\\n\\t\\tint newStart, newEnd;\\n\\t\\tif(start < end)\\n\\t\\t{\\n\\t\\t\\tnewStart = start;\\n\\t\\t\\tnewEnd = end;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tnewStart = end;\\n\\t\\t\\tnewEnd = start;\\n\\t\\t}\\n\\t\\tsetSelection(new Selection.Range(newStart,newEnd));\\n\\t\\tmoveCaretPosition(end,doElectricScroll);\\n\\t} \\n\\tpublic boolean isSelectionRectangular()\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(s == null)\\n\\t\\t\\treturn false;\\n\\t\\telse\\n\\t\\t\\treturn (s instanceof Selection.Rect);\\n\\t} \\n\\t\\tSegment lineSegment;\\n\\tMouseHandler mouseHandler;\\n\\tChunkCache chunkCache;\\n\\tint maxHorizontalScrollWidth;\\n\\tboolean softWrap;\\n\\tboolean hardWrap;\\n\\tfloat tabSize;\\n\\tint wrapMargin;\\n\\tboolean wrapToWidth;\\n\\tint charWidth;\\n\\tboolean monospacedHack;\\n\\tboolean scrollBarsInitialized;\\n\\t\\t\\t\\tboolean queuedScrollTo;\\n\\tboolean queuedScrollToElectric;\\n\\tboolean queuedFireCaretEvent;\\n\\tboolean queuedRecalculateLastPhysicalLine;\\n\\tArrayList runnables;\\n\\t\\t\\tVector selection;\\n\\t\\tPoint returnValue;\\n\\tfinal boolean isCaretVisible()\\n\\t{\\n\\t\\treturn blink && hasFocus();\\n\\t} \\n\\tfinal boolean isBracketHighlightVisible()\\n\\t{\\n\\t\\treturn bracketLine != -1\\n\\t\\t\\t&& hasFocus()\\n\\t\\t\\t&& foldVisibilityManager.isLineVisible(bracketLine)\\n\\t\\t\\t&& foldVisibilityManager.isLineVisible(caretLine);\\n\\t} \\n\\t\\tvoid updateMaxHorizontalScrollWidth()\\n\\t{\\n\\t\\tint max = chunkCache.getMaxHorizontalScrollWidth();\\n\\t\\tif(max != maxHorizontalScrollWidth)\\n\\t\\t{\\n\\t\\t\\tmaxHorizontalScrollWidth = max;\\n\\t\\t\\thorizontal.setValues(Math.max(0,\\n\\t\\t\\t\\tMath.min(maxHorizontalScrollWidth + charWidth\\n\\t\\t\\t\\t- painter.getWidth(),\\n\\t\\t\\t\\t-horizontalOffset)),\\n\\t\\t\\t\\tpainter.getWidth(),\\n\\t\\t\\t\\t0,maxHorizontalScrollWidth\\n\\t\\t\\t\\t+ charWidth);\\n\\t\\t}\\n\\t} \\n\\t\\tvoid recalculateVisibleLines()\\n\\t{\\n\\t\\tif(painter == null)\\n\\t\\t\\treturn;\\n\\t\\tint height = painter.getHeight();\\n\\t\\tint lineHeight = painter.getFontMetrics().getHeight();\\n\\t\\tvisibleLines = height / lineHeight;\\n\\t\\tlastLinePartial = (height % lineHeight != 0);\\n\\t\\tchunkCache.recalculateVisibleLines();\\n\\t\\tpropertiesChanged();\\n\\t} \\n\\t\\tvoid foldStructureChanged()\\n\\t{\\n\\t\\tchunkCache.invalidateAll();\\n\\t\\t\\t\\twhile(!foldVisibilityManager.isLineVisible(physFirstLine)\\n\\t\\t\\t&& physFirstLine != 0)\\n\\t\\t\\tphysFirstLine--;\\n\\t\\tsetFirstLine(physicalToVirtual(physFirstLine));\\n\\t\\t\\t\\t\\t\\tupdateScrollBars();\\n\\t\\trecalculateLastPhysicalLine();\\n\\t\\t\\t\\tgutter.repaint();\\n\\t\\tpainter.repaint();\\n\\t} \\n\\t\\t int getSubregionOfOffset(int offset, ChunkCache.LineInfo[] lineInfos)\\n\\t{\\n\\t\\t\\t\\tfor(int i = 0; i < lineInfos.length; i++)\\n\\t\\t{\\n\\t\\t\\tChunkCache.LineInfo info = lineInfos[i];\\n\\t\\t\\tif(offset >= info.offset && offset < info.offset + info.length)\\n\\t\\t\\t\\treturn i;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t} \\n\\t\\t int xToSubregionOffset(ChunkCache.LineInfo info, float x,\\n\\t\\tboolean round)\\n\\t{\\n\\t\\tint offset = Chunk.xToOffset(info.chunks,\\n\\t\\t\\tx - horizontalOffset,round);\\n\\t\\tif(offset == -1 || offset == info.offset + info.length)\\n\\t\\t\\toffset = info.offset + info.length - 1;\\n\\t\\treturn offset;\\n\\t} \\n\\t\\t int subregionOffsetToX(ChunkCache.LineInfo info, int offset)\\n\\t{\\n\\t\\treturn (int)(horizontalOffset + Chunk.offsetToX(\\n\\t\\t\\tinfo.chunks,offset));\\n\\t} \\n\\t\\tprivate static String CENTER = \\\"center\\\";\\n\\tprivate static String RIGHT = \\\"right\\\";\\n\\tprivate static String LEFT = \\\"left\\\";\\n\\tprivate static String BOTTOM = \\\"bottom\\\";\\n\\tprivate static Timer caretTimer;\\n\\tprivate static JEditTextArea focusedComponent;\\n\\t\\tprivate View view;\\n\\tprivate Gutter gutter;\\n\\tprivate TextAreaPainter painter;\\n\\tprivate JPopupMenu popup;\\n\\tprivate EventListenerList listenerList;\\n\\tprivate MutableCaretEvent caretEvent;\\n\\tprivate boolean caretBlinks;\\n\\tprivate boolean blink;\\n\\tprivate int firstLine;\\n\\tprivate int physFirstLine;\\n\\tprivate int physLastLine;\\n\\tprivate int screenLastLine;\\n\\tprivate boolean lastLinePartial;\\n\\tprivate int visibleLines;\\n\\tprivate int electricScroll;\\n\\tprivate int horizontalOffset;\\n\\tprivate boolean quickCopy;\\n\\tprivate JScrollBar vertical;\\n\\tprivate JScrollBar horizontal;\\n\\tprivate boolean bufferChanging;\\n\\tprivate Buffer buffer;\\n\\tprivate FoldVisibilityManager foldVisibilityManager;\\n\\tprivate BufferChangeHandler bufferHandler;\\n\\tprivate boolean bufferHandlerInstalled;\\n\\tprivate int caret;\\n\\tprivate int caretLine;\\n\\tprivate int caretScreenLine;\\n\\tprivate int bracketPosition;\\n\\tprivate int bracketLine;\\n\\tprivate int magicCaret;\\n\\tprivate boolean multi;\\n\\tprivate boolean overwrite;\\n\\tprivate int maxLineLen;\\n\\t\\tprivate void _addToSelection(Selection addMe)\\n\\t{\\n\\t\\tif(addMe.start > addMe.end)\\n\\t\\t{\\n\\t\\t\\tthrow new IllegalArgumentException(addMe.start\\n\\t\\t\\t\\t+ \\\" > \\\" + addMe.end);\\n\\t\\t}\\n\\t\\telse if(addMe.start == addMe.end)\\n\\t\\t{\\n\\t\\t\\tif(addMe instanceof Selection.Range)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\telse if(addMe instanceof Selection.Rect)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(((Selection.Rect)addMe).extraEndVirt == 0)\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tif(s.overlaps(addMe))\\n\\t\\t\\t{\\n\\t\\t\\t\\taddMe.start = Math.min(s.start,addMe.start);\\n\\t\\t\\t\\taddMe.end = Math.max(s.end,addMe.end);\\n\\t\\t\\t\\tselection.removeElement(s);\\n\\t\\t\\t\\ti--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\taddMe.startLine = getLineOfOffset(addMe.start);\\n\\t\\taddMe.endLine = getLineOfOffset(addMe.end);\\n\\t\\tboolean added = false;\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tif(addMe.start < s.start)\\n\\t\\t\\t{\\n\\t\\t\\t\\tselection.insertElementAt(addMe,i);\\n\\t\\t\\t\\tadded = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(!added)\\n\\t\\t\\tselection.addElement(addMe);\\n\\t\\tinvalidateLineRange(addMe.startLine,addMe.endLine);\\n\\t} \\n\\tprivate void finishCaretUpdate(boolean doElectricScroll,\\n\\t\\tboolean fireCaretEvent)\\n\\t{\\n\\t\\tthis.queuedScrollToElectric |= doElectricScroll;\\n\\t\\tthis.queuedFireCaretEvent |= fireCaretEvent;\\n\\t\\tRunnable r = new Runnable()\\n\\t\\t{\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tblink = true;\\n\\t\\t\\t\\tcaretTimer.restart();\\n\\t\\t\\t\\tscrollToCaret(queuedScrollToElectric);\\n\\t\\t\\t\\tupdateBracketHighlight();\\n\\t\\t\\t\\tif(queuedFireCaretEvent)\\n\\t\\t\\t\\t\\tfireCaretEvent();\\n\\t\\t\\t\\tqueuedScrollTo = queuedScrollToElectric\\n\\t\\t\\t\\t\\t= queuedFireCaretEvent = false;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tif(buffer.isTransactionInProgress())\\n\\t\\t{\\n\\t\\t\\tif(!queuedScrollTo)\\n\\t\\t\\t{\\n\\t\\t\\t\\tqueuedScrollTo = true;\\n\\t\\t\\t\\trunnables.add(r);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tr.run();\\n\\t} \\n\\t\\tprivate void fireCaretEvent()\\n\\t{\\n\\t\\tObject[] listeners = listenerList.getListenerList();\\n\\t\\tfor(int i = listeners.length - 2; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(listeners[i] == CaretListener.class)\\n\\t\\t\\t{\\n\\t\\t\\t\\t((CaretListener)listeners[i+1]).caretUpdate(caretEvent);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireScrollEvent(boolean vertical)\\n\\t{\\n\\t\\tObject[] listeners = listenerList.getListenerList();\\n\\t\\tfor(int i = listeners.length - 2; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(listeners[i] == ScrollListener.class)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(vertical)\\n\\t\\t\\t\\t\\t((ScrollListener)listeners[i+1]).scrolledVertically(this);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t((ScrollListener)listeners[i+1]).scrolledHorizontally(this);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void insertTab()\\n\\t{\\n\\t\\tint tabSize = buffer.getTabSize();\\n\\t\\tif(buffer.getBooleanProperty(\\\"noTabs\\\"))\\n\\t\\t{\\n\\t\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\t\\tString line = getText(lineStart,caret - lineStart);\\n\\t\\t\\tint pos = 0;\\n\\t\\t\\tfor(int i = 0; i < line.length(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(line.charAt(pos))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tpos = 0;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif(++pos >= tabSize)\\n\\t\\t\\t\\t\\t\\tpos = 0;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tsetSelectedText(MiscUtilities.createWhiteSpace(\\n\\t\\t\\t\\ttabSize - pos,0));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tsetSelectedText(\\\"\\\\t\\\");\\n\\t} \\n\\t\\tprivate boolean doWordWrap(boolean spaceInserted)\\n\\t{\\n\\t\\tif(!hardWrap || maxLineLen <= 0)\\n\\t\\t\\treturn false;\\n\\t\\tbuffer.getLineText(caretLine,lineSegment);\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine);\\n\\t\\tint len = end - start - 1;\\n\\t\\tint caretPos = caret - start;\\n\\t\\t\\t\\t\\t\\tfor(int i = caretPos; i < len; i++)\\n\\t\\t{\\n\\t\\t\\tchar ch = lineSegment.array[lineSegment.offset + i];\\n\\t\\t\\tif(ch != ' ' && ch != '\\\\t')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tboolean returnValue = false;\\n\\t\\tint tabSize = buffer.getTabSize();\\n\\t\\tString wordBreakChars = buffer.getStringProperty(\\\"wordBreakChars\\\");\\n\\t\\tint logicalLength = 0; \\t\\tint lastWordOffset = -1;\\n\\t\\tboolean lastWasSpace = true;\\n\\t\\tboolean initialWhiteSpace = true;\\n\\t\\tint initialWhiteSpaceLength = 0;\\n\\t\\tfor(int i = 0; i < caretPos; i++)\\n\\t\\t{\\n\\t\\t\\tchar ch = lineSegment.array[lineSegment.offset + i];\\n\\t\\t\\tif(ch == '\\\\t')\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(initialWhiteSpace)\\n\\t\\t\\t\\t\\tinitialWhiteSpaceLength = i + 1;\\n\\t\\t\\t\\tlogicalLength += tabSize - (logicalLength % tabSize);\\n\\t\\t\\t\\tif(!lastWasSpace && logicalLength <= maxLineLen)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastWordOffset = i;\\n\\t\\t\\t\\t\\tlastWasSpace = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(ch == ' ')\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(initialWhiteSpace)\\n\\t\\t\\t\\t\\tinitialWhiteSpaceLength = i + 1;\\n\\t\\t\\t\\tlogicalLength++;\\n\\t\\t\\t\\tif(!lastWasSpace && logicalLength <= maxLineLen)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastWordOffset = i;\\n\\t\\t\\t\\t\\tlastWasSpace = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(wordBreakChars != null && wordBreakChars.indexOf(ch) != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tinitialWhiteSpace = false;\\n\\t\\t\\t\\tlogicalLength++;\\n\\t\\t\\t\\tif(!lastWasSpace && logicalLength <= maxLineLen)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastWordOffset = i;\\n\\t\\t\\t\\t\\tlastWasSpace = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tinitialWhiteSpace = false;\\n\\t\\t\\t\\tlogicalLength++;\\n\\t\\t\\t\\tlastWasSpace = false;\\n\\t\\t\\t}\\n\\t\\t\\tint insertNewLineAt;\\n\\t\\t\\tif(spaceInserted && logicalLength == maxLineLen\\n\\t\\t\\t\\t&& i == caretPos - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsertNewLineAt = caretPos;\\n\\t\\t\\t\\treturnValue = true;\\n\\t\\t\\t}\\n\\t\\t\\telse if(logicalLength >= maxLineLen && lastWordOffset != -1)\\n\\t\\t\\t\\tinsertNewLineAt = lastWordOffset;\\n\\t\\t\\telse\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tbuffer.insert(start + insertNewLineAt,\\\"\\\\n\\\");\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbuffer.indentLine(caretLine,true,true);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t\\treturn returnValue;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t} \\n\\t\\tprivate void doWordCount(View view, String text)\\n\\t{\\n\\t\\tchar[] chars = text.toCharArray();\\n\\t\\tint characters = chars.length;\\n\\t\\tint words;\\n\\t\\tif(characters == 0)\\n\\t\\t\\twords = 0;\\n\\t\\telse\\n\\t\\t\\twords = 1;\\n\\t\\tint lines = 1;\\n\\t\\tboolean word = false;\\n\\t\\tfor(int i = 0; i < chars.length; i++)\\n\\t\\t{\\n\\t\\t\\tswitch(chars[i])\\n\\t\\t\\t{\\n\\t\\t\\tcase '\\\\r': case '\\\\n':\\n\\t\\t\\t\\tlines++;\\n\\t\\t\\tcase ' ': case '\\\\t':\\n\\t\\t\\t\\tif(word)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twords++;\\n\\t\\t\\t\\t\\tword = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tword = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tObject[] args = { new Integer(characters), new Integer(words),\\n\\t\\t\\tnew Integer(lines) };\\n\\t\\tGUIUtilities.message(view,\\\"wordcount\\\",args);\\n\\t} \\n\\t\\tprivate void updateBracketHighlight()\\n\\t{\\n\\t\\tif(!painter.isBracketHighlightEnabled())\\n\\t\\t\\treturn;\\n\\t\\tif(bracketLine != -1)\\n\\t\\t\\tinvalidateLineRange(bracketLine,caretLine);\\n\\t\\tint offset = caret - getLineStartOffset(caretLine);\\n\\t\\tif(offset != 0)\\n\\t\\t{\\n\\t\\t\\tint bracketOffset = TextUtilities.findMatchingBracketFuzzy(\\n\\t\\t\\t\\tbuffer,caretLine,offset - 1);\\n\\t\\t\\tif(bracketOffset != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbracketLine = getLineOfOffset(bracketOffset);\\n\\t\\t\\t\\tbracketPosition = bracketOffset\\n\\t\\t\\t\\t\\t- getLineStartOffset(bracketLine);\\n\\t\\t\\t\\tinvalidateLineRange(bracketLine,caretLine);\\n\\t\\t\\t\\tif(bracketLine < physFirstLine\\n\\t\\t\\t\\t\\t|| bracketLine > physLastLine)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tshowBracketStatusMessage(bracketLine < caretLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbracketLine = bracketPosition = -1;\\n\\t} \\n\\t\\tprivate void showBracketStatusMessage(boolean backward)\\n\\t{\\n\\t\\tString text = buffer.getLineText(bracketLine).trim();\\n\\t\\tif(backward && bracketLine != 0 && text.length() == 1)\\n\\t\\t{\\n\\t\\t\\tswitch(text.charAt(0))\\n\\t\\t\\t{\\n\\t\\t\\tcase '{': case '}':\\n\\t\\t\\tcase '[': case ']':\\n\\t\\t\\tcase '(': case ')':\\n\\t\\t\\t\\ttext = buffer.getLineText(bracketLine - 1).trim()\\n\\t\\t\\t\\t\\t+ \\\" \\\" + text;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\ttext = text.replace('\\\\t',' ');\\n\\t\\tview.getStatus().setMessageAndClear(jEdit.getProperty(\\n\\t\\t\\t\\\"view.status.bracket\\\",new String[] { text }));\\n\\t} \\n\\t\\tvoid recalculateLastPhysicalLine()\\n\\t{\\n\\t\\tif(softWrap)\\n\\t\\t{\\n\\t\\t\\tchunkCache.updateChunksUpTo(visibleLines);\\n\\t\\t\\tfor(int i = visibleLines; i >= 0; i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(i);\\n\\t\\t\\t\\tif(info.physicalLine != -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysLastLine = info.physicalLine;\\n\\t\\t\\t\\t\\tscreenLastLine = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tint virtLastLine = Math.min(foldVisibilityManager\\n\\t\\t\\t\\t.getVirtualLineCount() - 1,\\n\\t\\t\\t\\tfirstLine + visibleLines);\\n\\t\\t\\tscreenLastLine = virtLastLine - firstLine;\\n\\t\\t\\tphysLastLine = foldVisibilityManager.virtualToPhysical(\\n\\t\\t\\t\\tvirtLastLine);\\n\\t\\t}\\n\\t} \\n\\t\\tstatic class TextAreaBorder extends AbstractBorder\\n\\t{\\n\\t\\tprivate static final Insets insets = new Insets(1, 1, 2, 2);\\n\\t\\t\\t\\tpublic void paintBorder(Component c, Graphics g, int x, int y,\\n\\t\\t\\tint width, int height)\\n\\t\\t{\\n\\t\\t\\tg.translate(x,y);\\n\\t\\t\\tg.setColor(MetalLookAndFeel.getControlDarkShadow());\\n\\t\\t\\tg.drawRect(0,0,width-2,height-2);\\n\\t\\t\\tg.setColor(MetalLookAndFeel.getControlHighlight());\\n\\t\\t\\tg.drawLine(width-1,1,width-1,height-1);\\n\\t\\t\\tg.drawLine(1,height-1,width-1,height-1);\\n\\t\\t\\tg.setColor(MetalLookAndFeel.getControl());\\n\\t\\t\\tg.drawLine(width-2,2,width-2,2);\\n\\t\\t\\tg.drawLine(1,height-2,1,height-2);\\n\\t\\t\\tg.translate(-x,-y);\\n\\t\\t} \\n\\t\\t\\t\\tpublic Insets getBorderInsets(Component c)\\n\\t\\t{\\n\\t\\t\\treturn new Insets(1,1,2,2);\\n\\t\\t} \\t} \\n\\t\\tclass ScrollLayout implements LayoutManager\\n\\t{\\n\\t\\t\\t\\tpublic void addLayoutComponent(String name, Component comp)\\n\\t\\t{\\n\\t\\t\\tif(name.equals(CENTER))\\n\\t\\t\\t\\tcenter = comp;\\n\\t\\t\\telse if(name.equals(RIGHT))\\n\\t\\t\\t\\tright = comp;\\n\\t\\t\\telse if(name.equals(LEFT))\\n\\t\\t\\t\\tleft = comp;\\n\\t\\t\\telse if(name.equals(BOTTOM))\\n\\t\\t\\t\\tbottom = comp;\\n\\t\\t} \\n\\t\\t\\t\\tpublic void removeLayoutComponent(Component comp)\\n\\t\\t{\\n\\t\\t\\tif(center == comp)\\n\\t\\t\\t\\tcenter = null;\\n\\t\\t\\telse if(right == comp)\\n\\t\\t\\t\\tright = null;\\n\\t\\t\\telse if(left == comp)\\n\\t\\t\\t\\tleft = null;\\n\\t\\t\\telse if(bottom == comp)\\n\\t\\t\\t\\tbottom = null;\\n\\t\\t} \\n\\t\\t\\t\\tpublic Dimension preferredLayoutSize(Container parent)\\n\\t\\t{\\n\\t\\t\\tDimension dim = new Dimension();\\n\\t\\t\\tBorder border = getBorder();\\n\\t\\t\\tInsets insets;\\n\\t\\t\\tif(border == null)\\n\\t\\t\\t\\tinsets = new Insets(0,0,0,0);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsets = getBorder().getBorderInsets(\\n\\t\\t\\t\\t\\tJEditTextArea.this);\\n\\t\\t\\t}\\n\\t\\t\\tdim.width = insets.left + insets.right;\\n\\t\\t\\tdim.height = insets.top + insets.bottom;\\n\\t\\t\\tDimension leftPref = left.getPreferredSize();\\n\\t\\t\\tdim.width += leftPref.width;\\n\\t\\t\\tDimension centerPref = center.getPreferredSize();\\n\\t\\t\\tdim.width += centerPref.width;\\n\\t\\t\\tdim.height += centerPref.height;\\n\\t\\t\\tDimension rightPref = right.getPreferredSize();\\n\\t\\t\\tdim.width += rightPref.width;\\n\\t\\t\\tDimension bottomPref = bottom.getPreferredSize();\\n\\t\\t\\tdim.height += bottomPref.height;\\n\\t\\t\\treturn dim;\\n\\t\\t} \\n\\t\\t\\t\\tpublic Dimension minimumLayoutSize(Container parent)\\n\\t\\t{\\n\\t\\t\\tDimension dim = new Dimension();\\n\\t\\t\\tBorder border = getBorder();\\n\\t\\t\\tInsets insets;\\n\\t\\t\\tif(border == null)\\n\\t\\t\\t\\tinsets = new Insets(0,0,0,0);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsets = getBorder().getBorderInsets(\\n\\t\\t\\t\\t\\tJEditTextArea.this);\\n\\t\\t\\t}\\n\\t\\t\\tdim.width = insets.left + insets.right;\\n\\t\\t\\tdim.height = insets.top + insets.bottom;\\n\\t\\t\\tDimension leftPref = left.getMinimumSize();\\n\\t\\t\\tdim.width += leftPref.width;\\n\\t\\t\\tDimension centerPref = center.getMinimumSize();\\n\\t\\t\\tdim.width += centerPref.width; \\n\\t\\t\\tdim.height += centerPref.height;\\n\\t\\t\\tDimension rightPref = right.getMinimumSize();\\n\\t\\t\\tdim.width += rightPref.width;\\n\\t\\t\\tDimension bottomPref = bottom.getMinimumSize();\\n\\t\\t\\tdim.height += bottomPref.height;\\n\\t\\t\\treturn dim;\\n\\t\\t} \\n\\t\\t\\t\\tpublic void layoutContainer(Container parent)\\n\\t\\t{\\n\\t\\t\\tDimension size = parent.getSize();\\n\\t\\t\\tBorder border = getBorder();\\n\\t\\t\\tInsets insets;\\n\\t\\t\\tif(border == null)\\n\\t\\t\\t\\tinsets = new Insets(0,0,0,0);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsets = getBorder().getBorderInsets(\\n\\t\\t\\t\\t\\tJEditTextArea.this);\\n\\t\\t\\t}\\n\\t\\t\\tint itop = insets.top;\\n\\t\\t\\tint ileft = insets.left;\\n\\t\\t\\tint ibottom = insets.bottom;\\n\\t\\t\\tint iright = insets.right;\\n\\t\\t\\tint rightWidth = right.getPreferredSize().width;\\n\\t\\t\\tint leftWidth = left.getPreferredSize().width;\\n\\t\\t\\tint bottomHeight = bottom.getPreferredSize().height;\\n\\t\\t\\tint centerWidth = Math.max(0,size.width - leftWidth\\n\\t\\t\\t\\t- rightWidth - ileft - iright);\\n\\t\\t\\tint centerHeight = Math.max(0,size.height\\n\\t\\t\\t\\t- bottomHeight - itop - ibottom);\\n\\t\\t\\tleft.setBounds(\\n\\t\\t\\t\\tileft,\\n\\t\\t\\t\\titop,\\n\\t\\t\\t\\tleftWidth,\\n\\t\\t\\t\\tcenterHeight);\\n\\t\\t\\tcenter.setBounds(\\n\\t\\t\\t\\tileft + leftWidth,\\n\\t\\t\\t\\titop,\\n\\t\\t\\t\\tcenterWidth,\\n\\t\\t\\t\\tcenterHeight);\\n\\t\\t\\tright.setBounds(\\n\\t\\t\\t\\tileft + leftWidth + centerWidth,\\n\\t\\t\\t\\titop,\\n\\t\\t\\t\\trightWidth,\\n\\t\\t\\t\\tcenterHeight);\\n\\t\\t\\tbottom.setBounds(\\n\\t\\t\\t\\tileft,\\n\\t\\t\\t\\titop + centerHeight,\\n\\t\\t\\t\\tMath.max(0,size.width - rightWidth - ileft - iright),\\n\\t\\t\\t\\tbottomHeight);\\n\\t\\t} \\n\\t\\tComponent center;\\n\\t\\tComponent left;\\n\\t\\tComponent right;\\n\\t\\tComponent bottom;\\n\\t} \\n\\t\\tstatic class CaretBlinker implements ActionListener\\n\\t{\\n\\t\\t\\t\\tpublic void actionPerformed(ActionEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(focusedComponent != null && focusedComponent.hasFocus())\\n\\t\\t\\t\\tfocusedComponent.blinkCaret();\\n\\t\\t} \\t} \\n\\t\\tclass MutableCaretEvent extends CaretEvent\\n\\t{\\n\\t\\t\\t\\tMutableCaretEvent()\\n\\t\\t{\\n\\t\\t\\tsuper(JEditTextArea.this);\\n\\t\\t} \\n\\t\\t\\t\\tpublic int getDot()\\n\\t\\t{\\n\\t\\t\\treturn getCaretPosition();\\n\\t\\t} \\n\\t\\t\\t\\tpublic int getMark()\\n\\t\\t{\\n\\t\\t\\treturn getMarkPosition();\\n\\t\\t} \\t} \\n\\t\\tclass AdjustHandler implements AdjustmentListener\\n\\t{\\n\\t\\t\\t\\tpublic void adjustmentValueChanged(final AdjustmentEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(!scrollBarsInitialized)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(evt.getAdjustable() == vertical)\\n\\t\\t\\t\\tsetFirstLine(vertical.getValue());\\n\\t\\t\\telse\\n\\t\\t\\t\\tsetHorizontalOffset(-horizontal.getValue());\\n\\t\\t} \\t} \\n\\tpublic static boolean FOOLISH = false;\\n\\tclass BufferChangeHandler implements BufferChangeListener\\n\\t{\\n\\t\\tboolean delayedUpdate;\\n\\t\\tboolean delayedMultilineUpdate;\\n\\t\\tint delayedRepaintStart;\\n\\t\\tint delayedRepaintEnd;\\n\\t\\t\\t\\t\\t\\t\\t\\tPosition holdPosition;\\n\\t\\tRunnable recalculateLastPhysicalLine = new Runnable()\\n\\t\\t{\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\tint oldScreenLastLine = screenLastLine;\\n\\t\\t\\t\\trecalculateLastPhysicalLine();\\n\\t\\t\\t\\tinvalidateScreenLineRange(oldScreenLastLine,\\n\\t\\t\\t\\t\\tscreenLastLine);\\n\\t\\t\\t\\tqueuedRecalculateLastPhysicalLine = false;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\t\\tpublic void foldLevelChanged(Buffer buffer, int start, int end)\\n\\t\\t{\\n\\t\\t\\tif(!bufferChanging && end != 0 && buffer.isLoaded())\\n\\t\\t\\t{\\n\\t\\t\\t\\tinvalidateLineRange(start - 1,end - 1);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void contentInserted(Buffer buffer, int startLine, int start,\\n\\t\\t\\tint numLines, int length)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tchunkCache.invalidateChunksFromPhys(startLine);\\n\\t\\t\\t_recalculateLastPhysicalLine(numLines);\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\trepaintAndScroll(startLine,numLines);\\n\\t\\t\\t\\t\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\t\\tboolean changed = false;\\n\\t\\t\\t\\tif((s instanceof Selection.Rect && s.start > start)\\n\\t\\t\\t\\t\\t|| (s instanceof Selection.Range && s.start >= start))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ts.start += length;\\n\\t\\t\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t\\t\\t\\ts.startLine = getLineOfOffset(s.start);\\n\\t\\t\\t\\t\\tchanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(s.end >= start)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ts.end += length;\\n\\t\\t\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t\\t\\t\\ts.endLine = getLineOfOffset(s.end);\\n\\t\\t\\t\\t\\tchanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(changed)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdelayedRepaintStart = Math.min(\\n\\t\\t\\t\\t\\t\\tdelayedRepaintStart,\\n\\t\\t\\t\\t\\t\\ts.startLine);\\n\\t\\t\\t\\t\\tdelayedRepaintEnd = Math.max(\\n\\t\\t\\t\\t\\t\\tdelayedRepaintEnd,\\n\\t\\t\\t\\t\\t\\ts.endLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\tif(caret >= start)\\n\\t\\t\\t\\tmoveCaretPosition(caret + length,true);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tmoveCaretPosition(caret);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(!buffer.isTransactionInProgress())\\n\\t\\t\\t\\ttransactionComplete(buffer);\\n\\t\\t}\\n\\t\\t\\t\\tpublic void contentRemoved(Buffer buffer, int startLine, int start,\\n\\t\\t\\tint numLines, int length)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tchunkCache.invalidateChunksFromPhys(startLine);\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\trepaintAndScroll(startLine,-numLines);\\n\\t\\t\\t_recalculateLastPhysicalLine(-numLines);\\n\\t\\t\\tint end = start + length;\\n\\t\\t\\t\\t\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\t\\tboolean changed = false;\\n\\t\\t\\t\\tif(s.start > start && s.start <= end)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ts.start = start;\\n\\t\\t\\t\\t\\tchanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(s.start > end)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ts.start -= length;\\n\\t\\t\\t\\t\\tchanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(s.end > start && s.end <= end)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ts.end = start;\\n\\t\\t\\t\\t\\tchanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(s.end > end)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ts.end -= length;\\n\\t\\t\\t\\t\\tchanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(s.start == s.end)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tselection.removeElement(s);\\n\\t\\t\\t\\t\\tdelayedRepaintStart = Math.min(\\n\\t\\t\\t\\t\\t\\tdelayedRepaintStart,\\n\\t\\t\\t\\t\\t\\ts.startLine);\\n\\t\\t\\t\\t\\tdelayedRepaintEnd = Math.max(\\n\\t\\t\\t\\t\\t\\tdelayedRepaintEnd,\\n\\t\\t\\t\\t\\t\\ts.endLine);\\n\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(changed)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ts.startLine = getLineOfOffset(s.start);\\n\\t\\t\\t\\t\\t\\ts.endLine = getLineOfOffset(s.end);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdelayedRepaintStart = Math.min(\\n\\t\\t\\t\\t\\t\\tdelayedRepaintStart,\\n\\t\\t\\t\\t\\t\\ts.startLine);\\n\\t\\t\\t\\t\\tdelayedRepaintEnd = Math.max(\\n\\t\\t\\t\\t\\t\\tdelayedRepaintEnd,\\n\\t\\t\\t\\t\\t\\ts.endLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\tif(caret > start && caret <= end)\\n\\t\\t\\t\\tmoveCaretPosition(start,false);\\n\\t\\t\\telse if(caret > end)\\n\\t\\t\\t\\tmoveCaretPosition(caret - length,false);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tmoveCaretPosition(caret);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(!buffer.isTransactionInProgress())\\n\\t\\t\\t\\ttransactionComplete(buffer);\\n\\t\\t}\\n\\t\\t\\t\\tpublic void transactionComplete(Buffer buffer)\\n\\t\\t{\\n\\t\\t\\tif(delayedUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(holdPosition != null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsetFirstLine(physicalToVirtual(\\n\\t\\t\\t\\t\\t\\tgetBuffer().getLineOfOffset(\\n\\t\\t\\t\\t\\t\\tholdPosition.getOffset())));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(delayedMultilineUpdate)\\n\\t\\t\\t\\t\\tupdateScrollBars();\\n\\t\\t\\t\\tif(delayedMultilineUpdate)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tinvalidateScreenLineRange(chunkCache\\n\\t\\t\\t\\t\\t\\t.getScreenLineOfOffset(\\n\\t\\t\\t\\t\\t\\tdelayedRepaintStart,0),\\n\\t\\t\\t\\t\\t\\tscreenLastLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tinvalidateLineRange(delayedRepaintStart,\\n\\t\\t\\t\\t\\t\\tdelayedRepaintEnd);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdelayedUpdate = delayedMultilineUpdate = false;\\n\\t\\t\\t\\tholdPosition = null;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < runnables.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\t((Runnable)runnables.get(i)).run();\\n\\t\\t\\t}\\n\\t\\t\\trunnables.clear();\\n\\t\\t} \\n\\t\\t\\t\\tprivate void _recalculateLastPhysicalLine(int numLines)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(numLines != 0 || (softWrap && getFoldVisibilityManager()\\n\\t\\t\\t\\t.getLastVisibleLine() - numLines <= getLastPhysicalLine()))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.isTransactionInProgress())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!queuedRecalculateLastPhysicalLine)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tqueuedRecalculateLastPhysicalLine = true;\\n\\t\\t\\t\\t\\t\\trunnables.add(recalculateLastPhysicalLine);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\trecalculateLastPhysicalLine.run();\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void repaintAndScroll(int startLine, int numLines)\\n\\t\\t{\\n\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t\\tdelayedMultilineUpdate = true;\\n\\t\\t\\tif(!delayedUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedRepaintStart = startLine;\\n\\t\\t\\t\\tdelayedRepaintEnd = startLine;\\n\\t\\t\\t\\tdelayedUpdate = true;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedRepaintStart = Math.min(\\n\\t\\t\\t\\t\\tdelayedRepaintStart,\\n\\t\\t\\t\\t\\tstartLine);\\n\\t\\t\\t\\tdelayedRepaintEnd = Math.max(\\n\\t\\t\\t\\t\\tdelayedRepaintEnd,\\n\\t\\t\\t\\t\\tstartLine);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(holdPosition != null)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tint virtStartLine = physicalToVirtual(startLine);\\n\\t\\t\\tif(virtStartLine < getFirstLine())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint pos = buffer.getLineStartOffset(\\n\\t\\t\\t\\t\\tvirtualToPhysical(getFirstLine()\\n\\t\\t\\t\\t\\t+ (physicalToVirtual(startLine + numLines)\\n\\t\\t\\t\\t\\t- virtStartLine)));\\n\\t\\t\\t\\tholdPosition = buffer.createPosition(pos);\\n\\t\\t\\t}\\n\\t\\t} \\t} \\n\\t\\tclass FocusHandler implements FocusListener\\n\\t{\\n\\t\\t\\t\\tpublic void focusGained(FocusEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(bufferChanging)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(bracketLine != -1)\\n\\t\\t\\t\\tinvalidateLineRange(bracketLine,caretLine);\\n\\t\\t\\telse\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tview.updateGutterBorders();\\n\\t\\t} \\n\\t\\t\\t\\tpublic void focusLost(FocusEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(!isShowing())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(bracketLine != -1)\\n\\t\\t\\t\\tinvalidateLineRange(bracketLine,caretLine);\\n\\t\\t\\telse\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t} \\t} \\n\\t\\tclass MouseHandler extends MouseInputAdapter\\n\\t{\\n\\t\\tprivate int dragStartLine;\\n\\t\\tprivate int dragStartOffset;\\n\\t\\tprivate int dragStart;\\n\\t\\tprivate int clickCount;\\n\\t\\tprivate boolean dragged;\\n\\t\\tprivate boolean quickCopyDrag;\\n\\t\\tprivate boolean clearStatus;\\n\\t\\tprivate boolean control;\\n\\t\\t\\t\\tpublic void mousePressed(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tcontrol = (OperatingSystem.isMacOS() && evt.isMetaDown())\\n\\t\\t\\t\\t|| (!OperatingSystem.isMacOS() && evt.isControlDown());\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tview.getInputHandler().resetLastActionCount();\\n\\t\\t\\tgrabFocus();\\n\\t\\t\\tif(GUIUtilities.isPopupTrigger(evt) && popup != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(popup.isVisible())\\n\\t\\t\\t\\t\\tpopup.setVisible(false);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tGUIUtilities.showPopupMenu(popup,painter,\\n\\t\\t\\t\\t\\t\\tevt.getX(),evt.getY());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tquickCopyDrag = (isQuickCopyEnabled()\\n\\t\\t\\t\\t&& (evt.getModifiers() & MouseEvent.BUTTON2_MASK) != 0);\\n\\t\\t\\tblink = true;\\n\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t\\tint x = evt.getX();\\n\\t\\t\\tint y = evt.getY();\\n\\t\\t\\tdragStart = xyToOffset(x,y,!painter.isBlockCaretEnabled());\\n\\t\\t\\tdragStartLine = getLineOfOffset(dragStart);\\n\\t\\t\\tdragStartOffset = dragStart - getLineStartOffset(dragStartLine);\\n\\t\\t\\tdragged = false;\\n\\t\\t\\tclickCount = evt.getClickCount();\\n\\t\\t\\tswitch(clickCount)\\n\\t\\t\\t{\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\tdoSingleClick(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\tdoDoubleClick(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault: \\t\\t\\t\\tdoTripleClick(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doSingleClick(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(evt.isShiftDown())\\n\\t\\t\\t{\\n\\t\\t\\t\\tfloat dragStartLineWidth = offsetToXY(dragStartLine,\\n\\t\\t\\t\\t\\tgetLineLength(dragStartLine),returnValue).x;\\n\\t\\t\\t\\tint extraEndVirt;\\n\\t\\t\\t\\tint x = evt.getX();\\n\\t\\t\\t\\tif(x > dragStartLineWidth)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\textraEndVirt = (int)((x - dragStartLineWidth)\\n\\t\\t\\t\\t\\t\\t/ charWidth);\\n\\t\\t\\t\\t\\tif(x % charWidth  > charWidth / 2)\\n\\t\\t\\t\\t\\t\\textraEndVirt++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\textraEndVirt = 0;\\n\\t\\t\\t\\t\\t\\t\\t\\tresizeSelection(getMarkPosition(),dragStart,extraEndVirt,control);\\n\\t\\t\\t\\tmoveCaretPosition(dragStart,false);\\n\\t\\t\\t\\t\\t\\t\\t\\tdragStartLine = getMarkLine();\\n\\t\\t\\t\\tdragStart = getMarkPosition();\\n\\t\\t\\t\\tdragStartOffset = dragStart\\n\\t\\t\\t\\t\\t- getLineStartOffset(dragStartLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(control)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint offset = xyToOffset(evt.getX(),evt.getY(),false);\\n\\t\\t\\t\\t\\tif(offset != buffer.getLength())\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.getText(offset,1,lineSegment);\\n\\t\\t\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset])\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcase '(': case '[': case '{':\\n\\t\\t\\t\\t\\t\\tcase ')': case ']': case '}':\\n\\t\\t\\t\\t\\t\\t\\tmoveCaretPosition(offset,false);\\n\\t\\t\\t\\t\\t\\t\\tselectToMatchingBracket();\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!(multi || quickCopyDrag))\\n\\t\\t\\t\\t\\tselectNone();\\n\\t\\t\\t\\tif(!quickCopyDrag)\\n\\t\\t\\t\\t\\tmoveCaretPosition(dragStart,false);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doDoubleClick(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(getLineLength(dragStartLine) == 0)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tString lineText = getLineText(dragStartLine);\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tif(dragStartOffset == getLineLength(dragStartLine))\\n\\t\\t\\t\\tdragStartOffset--;\\n\\t\\t\\tboolean joinNonWordChars =\\n\\t\\t\\t\\tjEdit.getBooleanProperty(\\\"view.joinNonWordChars\\\");\\n\\t\\t\\tint wordStart = TextUtilities.findWordStart(lineText,\\n\\t\\t\\t\\tdragStartOffset,noWordSep,joinNonWordChars);\\n\\t\\t\\tint wordEnd = TextUtilities.findWordEnd(lineText,\\n\\t\\t\\t\\tdragStartOffset+1,noWordSep,joinNonWordChars);\\n\\t\\t\\tint lineStart = getLineStartOffset(dragStartLine);\\n\\t\\t\\taddToSelection(new Selection.Range(lineStart + wordStart,\\n\\t\\t\\t\\tlineStart + wordEnd));\\n\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t\\tquickCopyDrag = false;\\n\\t\\t\\tmoveCaretPosition(lineStart + wordEnd,false);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdragged = true;\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doTripleClick(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tint newCaret = getLineEndOffset(dragStartLine);\\n\\t\\t\\tif(dragStartLine == buffer.getLineCount() - 1)\\n\\t\\t\\t\\tnewCaret--;\\n\\t\\t\\taddToSelection(new Selection.Range(\\n\\t\\t\\t\\tgetLineStartOffset(dragStartLine),\\n\\t\\t\\t\\tnewCaret));\\n\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t\\tquickCopyDrag = false;\\n\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t} \\n\\t\\t\\t\\tpublic void mouseDragged(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(GUIUtilities.isPopupTrigger(evt)\\n\\t\\t\\t\\t|| (popup != null && popup.isVisible()))\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(evt.getY() < 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFirstLine(getFirstLine() - 2);\\n\\t\\t\\t}\\n\\t\\t\\telse if(evt.getY() >= getHeight())\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFirstLine(getFirstLine() + 1);\\n\\t\\t\\t}\\n\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t{\\n\\t\\t\\t\\tview.getStatus().setMessage(jEdit.getProperty(\\n\\t\\t\\t\\t\\t\\\"view.status.quick-copy\\\"));\\n\\t\\t\\t\\tclearStatus = true;\\n\\t\\t\\t}\\n\\t\\t\\telse if(control)\\n\\t\\t\\t{\\n\\t\\t\\t\\tview.getStatus().setMessage(jEdit.getProperty(\\n\\t\\t\\t\\t\\t\\\"view.status.rect-select\\\"));\\n\\t\\t\\t\\tclearStatus = true;\\n\\t\\t\\t}\\n\\t\\t\\tswitch(clickCount)\\n\\t\\t\\t{\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\tdoSingleDrag(evt,control);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\tdoDoubleDrag(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault: \\t\\t\\t\\tdoTripleDrag(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doSingleDrag(MouseEvent evt, boolean rect)\\n\\t\\t{\\n\\t\\t\\tint x = evt.getX();\\n\\t\\t\\tint dot = xyToOffset(x,\\n\\t\\t\\t\\tMath.max(0,Math.min(painter.getHeight(),evt.getY())),\\n\\t\\t\\t\\t!painter.isBlockCaretEnabled());\\n\\t\\t\\tint dotLine = buffer.getLineOfOffset(dot);\\n\\t\\t\\tint extraEndVirt = 0;\\n\\t\\t\\tif(dotLine != physLastLine || chunkCache.getLineInfo(\\n\\t\\t\\t\\tscreenLastLine).lastSubregion)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfloat dotLineWidth = offsetToXY(dotLine,getLineLength(dotLine),\\n\\t\\t\\t\\t\\treturnValue).x;\\n\\t\\t\\t\\tif(x > dotLineWidth)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\textraEndVirt = (int)((x - dotLineWidth) / charWidth);\\n\\t\\t\\t\\t\\tif(x % charWidth  > charWidth / 2)\\n\\t\\t\\t\\t\\t\\textraEndVirt++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tdragged = true;\\n\\t\\t\\tresizeSelection(dragStart,dot,extraEndVirt,rect);\\n\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tscrollTo(dotLine,dot - buffer.getLineStartOffset(dotLine),false);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(dot != caret)\\n\\t\\t\\t\\t\\tmoveCaretPosition(dot,false);\\n\\t\\t\\t\\tif(rect && extraEndVirt != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscrollTo(dotLine,dot - buffer.getLineStartOffset(dotLine)\\n\\t\\t\\t\\t\\t\\t+ extraEndVirt,false);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doDoubleDrag(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tint markLineStart = getLineStartOffset(dragStartLine);\\n\\t\\t\\tint markLineLength = getLineLength(dragStartLine);\\n\\t\\t\\tint mark = dragStartOffset;\\n\\t\\t\\tint pos = xyToOffset(evt.getX(),\\n\\t\\t\\t\\tMath.max(0,Math.min(painter.getHeight(),evt.getY())),\\n\\t\\t\\t\\t!painter.isBlockCaretEnabled());\\n\\t\\t\\tint line = getLineOfOffset(pos);\\n\\t\\t\\tint lineStart = getLineStartOffset(line);\\n\\t\\t\\tint lineLength = getLineLength(line);\\n\\t\\t\\tint offset = pos - lineStart;\\n\\t\\t\\tString lineText = getLineText(line);\\n\\t\\t\\tString markLineText = getLineText(dragStartLine);\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tboolean joinNonWordChars =\\n\\t\\t\\t\\tjEdit.getBooleanProperty(\\\"view.joinNonWordChars\\\");\\n\\t\\t\\tif(markLineStart + dragStartOffset > lineStart + offset)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(offset != 0 && offset != lineLength)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\toffset = TextUtilities.findWordStart(\\n\\t\\t\\t\\t\\t\\tlineText,offset,noWordSep,\\n\\t\\t\\t\\t\\t\\tjoinNonWordChars);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(markLineLength != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmark = TextUtilities.findWordEnd(\\n\\t\\t\\t\\t\\t\\tmarkLineText,mark,noWordSep,\\n\\t\\t\\t\\t\\t\\tjoinNonWordChars);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(offset != 0 && lineLength != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\toffset = TextUtilities.findWordEnd(\\n\\t\\t\\t\\t\\t\\tlineText,offset,noWordSep,\\n\\t\\t\\t\\t\\t\\tjoinNonWordChars);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(mark != 0 && mark != markLineLength)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmark = TextUtilities.findWordStart(\\n\\t\\t\\t\\t\\t\\tmarkLineText,mark,noWordSep,\\n\\t\\t\\t\\t\\t\\tjoinNonWordChars);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(lineStart + offset == caret)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tresizeSelection(markLineStart + mark,lineStart + offset,\\n\\t\\t\\t\\t0,false);\\n\\t\\t\\tif(!quickCopyDrag)\\n\\t\\t\\t\\tmoveCaretPosition(lineStart + offset,false);\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doTripleDrag(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tint offset = xyToOffset(evt.getX(),\\n\\t\\t\\t\\tMath.max(0,Math.min(painter.getHeight(),evt.getY())),\\n\\t\\t\\t\\tfalse);\\n\\t\\t\\tint mouseLine = getLineOfOffset(offset);\\n\\t\\t\\tint mark;\\n\\t\\t\\tint mouse;\\n\\t\\t\\tif(dragStartLine > mouseLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmark = getLineEndOffset(dragStartLine) - 1;\\n\\t\\t\\t\\tif(offset == getLineEndOffset(mouseLine) - 1)\\n\\t\\t\\t\\t\\tmouse = offset;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmouse = getLineStartOffset(mouseLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tmark = getLineStartOffset(dragStartLine);\\n\\t\\t\\t\\tif(offset == getLineStartOffset(mouseLine))\\n\\t\\t\\t\\t\\tmouse = offset;\\n\\t\\t\\t\\telse if(offset == getLineEndOffset(mouseLine) - 1\\n\\t\\t\\t\\t\\t&& mouseLine != getBuffer().getLineCount() - 1)\\n\\t\\t\\t\\t\\tmouse = getLineEndOffset(mouseLine);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmouse = getLineEndOffset(mouseLine) - 1;\\n\\t\\t\\t}\\n\\t\\t\\tmouse = Math.min(getBuffer().getLength(),mouse);\\n\\t\\t\\tif(mouse == caret)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tdragged = true;\\n\\t\\t\\tresizeSelection(mark,mouse,0,false);\\n\\t\\t\\tmoveCaretPosition(mouse,false);\\n\\t\\t} \\n\\t\\t\\t\\tpublic void mouseReleased(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tSelection sel = getSelectionAtOffset(dragStart);\\n\\t\\t\\tif(sel != null)\\n\\t\\t\\t\\tRegisters.setRegister('%',getSelectedText(sel));\\n\\t\\t\\tif(dragged && sel != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tremoveFromSelection(sel);\\n\\t\\t\\t\\t\\tRegisters.paste(JEditTextArea.this,'%',\\n\\t\\t\\t\\t\\t\\tsel instanceof Selection.Rect);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tRegisters.setRegister('%',getSelectedText());\\n\\t\\t\\t}\\n\\t\\t\\telse if(isQuickCopyEnabled()\\n\\t\\t\\t\\t&& (evt.getModifiers() & InputEvent.BUTTON2_MASK) != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetCaretPosition(dragStart,false);\\n\\t\\t\\t\\tif(!isEditable())\\n\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tRegisters.paste(JEditTextArea.this,'%',control);\\n\\t\\t\\t}\\n\\t\\t\\tdragged = false;\\n\\t\\t\\tif(clearStatus)\\n\\t\\t\\t{\\n\\t\\t\\t\\tclearStatus = false;\\n\\t\\t\\t\\tview.getStatus().setMessage(null);\\n\\t\\t\\t}\\n\\t\\t} \\t} \\n\\t\\tstatic\\n\\t{\\n\\t\\tcaretTimer = new Timer(500,new CaretBlinker());\\n\\t\\tcaretTimer.setInitialDelay(500);\\n\\t\\tcaretTimer.start();\\n\\t} }\""
            },
            "m17": {
                "role": "user",
                "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
            },
            "m18": {
                "content": "Title: Diagnosis of starting entity `JEditTextArea`\n\nChange set: [TextAreaPainter, ChunkCache, BufferChangeHandler, Gutter, MouseHandler, DisplayManager, FoldVisibilityManager, EditPane, View, Buffer, ScrollLayout, Painter, TextAreaBorder, CaretBlinker, MutableCaretEvent, AdjustHandler, BufferChangeListener, BufferChangeHandler, FocusHandler, MouseInputAdapter, MouseHandler, Selection, Segment, Log, UndoManager, DisplayTokenHandler, SoftWrapTokenHandler, ScrollListener, CaretListener, EventListenerList, Chunk, LineInfo, AbstractBorder, LayoutManager, Timer, Component, Container, Border, Insets, Dimension, Position, Segment, Vector, Hashtable, Enumeration, Segment, SyntaxUtilities, TextUtilities, MiscUtilities, GUIUtilities, ToolTipManager, InputHandler, KeyHandler, Macros, Marker, FoldManager, VFS, DockableWindowManager]\n\nDetails:\n- **TextAreaPainter**: High conceptual coupling (0.8567), tightly involved in rendering text area UI.\n- **ChunkCache**: Strong method invocations and data flow from JEditTextArea for layout and scrolling logic.\n- **BufferChangeHandler**: Frequently co-changed (confidence 0.284), handles buffer updates that impact UI rendering.\n- **Gutter**: Directly used with JEditTextArea for line number and marker display; tightly integrated.\n- **MouseHandler**: Co-change confidence 0.267; manages mouse events tied to editing behavior.\n- **DisplayManager**: Moderate co-change support/confidence; likely involved in rendering coordination.\n- **FoldVisibilityManager**: Used heavily by JEditTextArea to manage code folding visibility.\n- **EditPane**: Co-change history suggests shared lifecycle or behavioral dependency.\n- **View**: Core component managing the text area\u2019s visual context.\n- **Buffer**: Central to document model; changes often reflected visually in text area.\n- **ScrollLayout**: Manages layout structure directly tied to JEditTextArea UI components.\n- **TextAreaPainter**: Involved in painting logic, high semantic similarity.\n- **TextAreaBorder**: Visual boundary management for JEditTextArea.\n- **CaretBlinker**: Handles caret blinking functionality via timer.\n- **MutableCaretEvent**: Custom caret event class specific to this component.\n- **AdjustHandler**: Adjustment listener handling scroll bar interactions.\n- **FocusHandler**: Manages focus events which affect caret and selection rendering.\n- **MouseInputAdapter / MouseHandler**: Critical for user interaction and selection.\n- **Selection**: Data structure used extensively for managing selections.\n- **Segment / lineSegment**: Internal text segment manipulation is tightly coupled.\n- **Log**: Logging integration present in repaint and update logic.\n- **UndoManager**: Likely involved in transactional UI updates.\n- **DisplayTokenHandler**: Potentially involved in syntax highlighting or rendering tokens.\n- **SoftWrapTokenHandler**: Related to wrapping logic, possibly linked to rendering.\n- **ScrollListener**: JEditTextArea fires scroll events; needs synchronization.\n- **CaretListener / CaretEvent**: Core to caret tracking and UI feedback.\n- **EventListenerList**: Managing internal listeners for UI events.\n- **Chunk / LineInfo**: Internally used structures manipulated by JEditTextArea.\n- **AbstractBorder / Border / Insets**: UI border and layout calculations.\n- **LayoutManager / ScrollLayout**: UI layout tied to scroll and resize operations.\n- **Dimension / Component / Container**: Java AWT dependencies tightly used in layout.\n- **Timer / caretTimer**: Timing mechanism for caret blink behavior.\n- **Position / holdPosition**: Managing caret/selection positions during updates.\n- **Vector / selection**: Internal storage of selection objects.\n- **Hashtable / Enumeration**: Used for line markers and selection tracking.\n- **SyntaxUtilities / TextUtilities / MiscUtilities**: Supporting utility classes for text rendering and manipulation.\n- **GUIUtilities**: UI-specific utilities, dialog usage may be shared.\n- **InputHandler / KeyHandler**: Handling input events affecting text and caret.\n- **Macros / Marker**: Possibly involved in macro recording or marker placement UI.\n- **FoldManager**: Folding logic affects rendering and layout.\n- **VFS**: Potential involvement in file loading/display scenarios.\n- **DockableWindowManager**: If docking state affects UI layout/state consistency.\n\nThese entities are included based on co-change frequency, coupling dependencies, and conceptual linkage\u2014ensuring a comprehensive CIA result focused on synchronization likelihood.",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            }
        }
    }
}