{
    "time": 1749472503.190782,
    "messages": [
        {
            "role": "system",
            "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
        },
        {
            "role": "user",
            "content": "The project you need to analyze is `jEdit`, a well-known Java open source project. The starting entity you need to deal with is SimpleNode.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
        },
        {
            "content": "",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_8b1ec228d44340e8ae557f",
                    "function": {
                        "arguments": "{\"entity\": \"SimpleNode.java\"}",
                        "name": "get_co_change_relationship"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "name": "get_co_change_relationship",
            "role": "tool",
            "content": "[[\"Parser\", \"2\", \"1.0\"], [\"Primitive\", \"2\", \"1.0\"], [\"NameSpace\", \"2\", \"1.0\"], [\"Interpreter\", \"2\", \"1.0\"], [\"Reflect\", \"2\", \"1.0\"], [\"EvalError\", \"2\", \"1.0\"], [\"CallStack\", \"2\", \"1.0\"], [\"Name\", \"2\", \"1.0\"], [\"TargetError\", \"2\", \"1.0\"], [\"BshClassManager\", \"2\", \"1.0\"], [\"StringUtil\", \"2\", \"1.0\"], [\"This\", \"2\", \"1.0\"], [\"UtilEvalError\", \"2\", \"1.0\"], [\"LHS\", \"2\", \"1.0\"], [\"BSHAmbiguousName\", \"2\", \"1.0\"], [\"JThis\", \"2\", \"1.0\"], [\"ParseException\", \"2\", \"1.0\"], [\"BSHType\", \"2\", \"1.0\"], [\"ReflectManager\", \"2\", \"1.0\"], [\"BSHCastExpression\", \"2\", \"1.0\"], [\"BSHAllocationExpression\", \"2\", \"1.0\"], [\"BSHArrayDimensions\", \"2\", \"1.0\"], [\"TypedVariable\", \"2\", \"1.0\"], [\"BSHPrimarySuffix\", \"2\", \"1.0\"], [\"BSHIfStatement\", \"2\", \"1.0\"], [\"BshMethod\", \"2\", \"1.0\"], [\"Handler\", \"2\", \"1.0\"], [\"UtilTargetError\", \"2\", \"1.0\"], [\"BSHLHSPrimarySuffix\", \"2\", \"1.0\"], [\"BSHBinaryExpression\", \"2\", \"1.0\"], [\"BSHThrowStatement\", \"2\", \"1.0\"], [\"BSHImportDeclaration\", \"2\", \"1.0\"], [\"XThis\", \"2\", \"1.0\"], [\"BSHUnaryExpression\", \"2\", \"1.0\"], [\"BSHArrayInitializer\", \"2\", \"1.0\"], [\"BSHReturnStatement\", \"2\", \"1.0\"], [\"BSHTypedVariableDeclaration\", \"2\", \"1.0\"], [\"BSHSwitchStatement\", \"2\", \"1.0\"], [\"BlockNameSpace\", \"2\", \"1.0\"], [\"BSHFormalParameter\", \"2\", \"1.0\"], [\"BSHMethodInvocation\", \"2\", \"1.0\"], [\"BSHTryStatement\", \"2\", \"1.0\"], [\"ReturnControl\", \"2\", \"1.0\"], [\"BSHReturnType\", \"2\", \"1.0\"], [\"BSHAssignment\", \"2\", \"1.0\"], [\"BSHFormalParameters\", \"2\", \"1.0\"], [\"SignatureKey\", \"2\", \"1.0\"], [\"BSHLHSPrimaryExpression\", \"2\", \"1.0\"], [\"BSHMethodDeclaration\", \"2\", \"1.0\"]]"
        },
        {
            "content": "The `get_co_change_relationship` function has returned a list of entities that are frequently modified together with `SimpleNode.java`. These entities have a co-change relationship with `SimpleNode.java` with a confidence level of 100% (i.e., every time this file was modified, those files were also modified). \n\nThis is a strong indicator that these files might be impacted by any changes made to `SimpleNode.java`.\n\nHere are some initial observations:\n\n- There are 48 entities listed, which suggests a high degree of interdependence with `SimpleNode.java`.\n- Many of the names suggest they are related to parsing, evaluation, and handling expressions (e.g., `Parser`, `Primitive`, `Interpreter`, `EvalError`, `BSHMethodDeclaration`, etc.).\n- This implies that `SimpleNode.java` likely plays a central role in expression parsing or abstract syntax tree (AST) management within the system.\n\nTo better understand why these files are connected and determine which ones truly need synchronization, we can dig deeper into their relationships. A good next step would be to analyze the coupling dependencies between `SimpleNode.java` and some of these co-changed files (especially key ones like `Parser.java`, `Interpreter.java`, or `EvalError.java`) using the `get_coupling_dependencies` function.\n\nLet me start by analyzing the coupling dependencies between `SimpleNode.java` and `Parser.java`.\n\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_f0d29bb86dc345ca8967ed",
                    "function": {
                        "arguments": "{\"entity1\": \"SimpleNode.java\", \"entity2\": \"Parser.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"There are no coupling dependencies between these two entities\"]"
        },
        {
            "content": "It appears that there are no direct coupling dependencies between `SimpleNode.java` and `Parser.java`. This suggests that the co-change relationship might be due to higher-level architectural or functional dependencies rather than direct code-level couplings.\n\nTo explore further, let's consider another entity from the co-change list that might have a more direct relationship with `SimpleNode.java`. `BshMethodDeclaration.java` is a good candidate because it likely involves node structures or method parsing, which could be closely related to `SimpleNode.java`.\n\nLet me analyze the coupling dependencies between `SimpleNode.java` and `BshMethodDeclaration.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_dbdce350f923447ab51a81",
                    "function": {
                        "arguments": "{\"entity1\": \"SimpleNode.java\", \"entity2\": \"BshMethodDeclaration.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"BshMethodDeclaration has been removed from the project due to project version iteration\"]"
        },
        {
            "content": "It seems that `BshMethodDeclaration.java` is no longer present in the current version of the project, likely due to refactoring or architectural changes over time. This complicates our analysis since we can't directly examine its coupling with `SimpleNode.java`.\n\nLet's pivot strategy slightly. Since many co-changed entities are related to parsing and evaluation, another meaningful approach would be to inspect the **call graph** for `SimpleNode.java`. This will help us understand which entities are directly invoked or referenced by `SimpleNode.java`, potentially shedding light on why certain files are frequently co-changed.\n\nLet me retrieve the call graph for `SimpleNode.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_d3f5d9a461b8452fbc91d7",
                    "function": {
                        "arguments": "{\"entity\": \"SimpleNode.java\"}",
                        "name": "get_call_graph"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_call_graph",
            "content": "[]"
        },
        {
            "content": "The call graph for `SimpleNode.java` is empty, which indicates that no other entities are directly invoked or referenced by `SimpleNode.java` based on the current analysis. This further suggests that the co-change relationships we observed earlier may not be due to direct method calls or references.\n\nGiven this information, a useful next step would be to examine the **source code** of `SimpleNode.java` itself. By reviewing its structure and functionality, we can gain insights into its role in the system and potentially identify indirect dependencies or design patterns that explain its extensive co-change relationships.\n\nLet me retrieve the source code of `SimpleNode.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_2f3da4682ffe4797be45f6",
                    "function": {
                        "arguments": "{\"entity\": \"SimpleNode.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package bsh;\\nclass SimpleNode implements Node \\n{\\n\\tpublic static SimpleNode JAVACODE =\\n\\t\\tnew SimpleNode( -1 ) {\\n\\t\\t\\tpublic String getSourceFile() {\\n\\t\\t\\t\\treturn \\\"<Called from Java Code>\\\";\\n\\t\\t\\t}\\n\\t\\t\\tpublic int getLineNumber() {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\tpublic String getText()  {\\n\\t\\t\\t\\treturn \\\"<Compiled Java Code>\\\";\\n\\t\\t\\t}\\n\\t\\t};\\n\\tprotected Node parent;\\n\\tprotected Node[] children;\\n\\tprotected int id;\\n\\tToken firstToken, lastToken;\\n\\tString sourceFile;\\n\\tpublic SimpleNode(int i) {\\n\\t\\tid = i;\\n\\t}\\n\\tpublic void jjtOpen() { }\\n\\tpublic void jjtClose() { }\\n\\tpublic void jjtSetParent(Node n) { parent = n; }\\n\\tpublic Node jjtGetParent() { return parent; }\\n\\tpublic void jjtAddChild(Node n, int i)\\n\\t{\\n\\t\\tif (children == null)\\n\\t\\t\\tchildren = new Node[i + 1];\\n\\t\\telse\\n\\t\\t\\tif (i >= children.length)\\n\\t\\t\\t{\\n\\t\\t\\t\\tNode c[] = new Node[i + 1];\\n\\t\\t\\t\\tSystem.arraycopy(children, 0, c, 0, children.length);\\n\\t\\t\\t\\tchildren = c;\\n\\t\\t\\t}\\n\\t\\tchildren[i] = n;\\n\\t}\\n\\tpublic Node jjtGetChild(int i) { \\n\\t\\treturn children[i]; \\n\\t}\\n\\tpublic SimpleNode getChild( int i ) {\\n\\t\\treturn (SimpleNode)jjtGetChild(i);\\n\\t}\\n\\tpublic int jjtGetNumChildren() {\\n\\t\\treturn (children == null) ? 0 : children.length;\\n\\t}\\n\\tpublic String toString() { return ParserTreeConstants.jjtNodeName[id]; }\\n\\tpublic String toString(String prefix) { return prefix + toString(); }\\n\\tpublic void dump(String prefix)\\n\\t{\\n\\t\\tSystem.out.println(toString(prefix));\\n\\t\\tif(children != null)\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < children.length; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSimpleNode n = (SimpleNode)children[i];\\n\\t\\t\\t\\tif (n != null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tn.dump(prefix + \\\" \\\");\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tpublic void prune() {\\n\\t\\tjjtSetParent( null );\\n\\t}\\n\\tpublic Object eval( CallStack callstack, Interpreter interpreter ) \\n\\t\\tthrows EvalError\\n\\t{\\n\\t\\tthrow new InterpreterError(\\n\\t\\t\\t\\\"Unimplemented or inappropriate for \\\" + getClass().getName() );\\n\\t}\\n\\tpublic void setSourceFile( String sourceFile ) {\\n\\t\\tthis.sourceFile = sourceFile;\\n\\t}\\n\\tpublic String getSourceFile() {\\n\\t\\tif ( sourceFile == null )\\n\\t\\t\\tif ( parent != null )\\n\\t\\t\\t\\treturn ((SimpleNode)parent).getSourceFile();\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn \\\"<unknown file>\\\";\\n\\t\\telse\\n\\t\\t\\treturn sourceFile;\\n\\t}\\n\\tpublic int getLineNumber() {\\n\\t\\treturn firstToken.beginLine;\\n\\t}\\n\\tpublic String getText() \\n\\t{\\n\\t\\tStringBuffer text = new StringBuffer();\\n\\t\\tToken t = firstToken;\\n\\t\\twhile ( t!=null ) {\\n\\t\\t\\ttext.append(t.image);\\n\\t\\t\\tif ( !t.image.equals(\\\".\\\") )\\n\\t\\t\\t\\ttext.append(\\\" \\\");\\n\\t\\t\\tif ( t==lastToken ||\\n\\t\\t\\t\\tt.image.equals(\\\"{\\\") || t.image.equals(\\\";\\\") )\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tt=t.next;\\n\\t\\t}\\n\\t\\treturn text.toString();\\n\\t}\\n}\""
        },
        {
            "content": "From the source code of `SimpleNode.java`, we can derive several key insights:\n\n### Overview:\n- **`SimpleNode`** is a class that implements the `Node` interface.\n- It appears to be part of a structure for building and managing an Abstract Syntax Tree (AST), which is common in parsers and interpreters.\n\n### Key Features:\n1. **AST Node Structure**:\n   - Maintains parent and children references (`parent`, `children[]`).\n   - Provides methods like `jjtSetParent()`, `jjtGetChild()`, `jjtAddChild()` for tree navigation and manipulation.\n   - Has an `id` associated with node types, likely mapped via `ParserTreeConstants.jjtNodeName`.\n\n2. **Token Management**:\n   - References `Token` objects (`firstToken`, `lastToken`) and retrieves line numbers and source text using them.\n   - This implies it's tightly involved with parsing source code into tokens and reconstructing source segments from tokens.\n\n3. **Evaluation Framework**:\n   - Contains an `eval()` method that throws an `EvalError`. This suggests it's meant to be extended by classes that implement actual evaluation logic.\n   - The default implementation throws an `InterpreterError`, indicating this is a placeholder or abstract behavior.\n\n4. **Source Context**:\n   - Keeps track of the source file (`sourceFile`) and uses token information to retrieve line numbers and textual representation of the code segment.\n\n5. **Utility Methods**:\n   - Includes a `dump()` method for printing the AST structure, useful for debugging.\n   - `prune()` method helps in cleaning up parent references, possibly for memory management or optimization.\n\n---\n\n### Why Is It Co-Changed Frequently?\n\nGiven its role as a foundational AST node class:\n- **Extensibility and Inheritance**: Many other node types (like method declarations, expressions, etc.) likely extend or use `SimpleNode`, even if not directly visible through coupling dependencies.\n- **Parsing & Evaluation**: Its involvement in parsing and evaluation logic explains its relationship with files like `Parser.java`, `Interpreter.java`, `EvalError.java`, etc.\n- **Token Handling**: Since it works closely with tokens and source code reconstruction, changes to how tokens are handled might necessitate synchronized updates across related classes.\n\n---\n\n### Next Steps\n\nTo better understand indirect relationships and confirm our observations, we could:\n1. Check conceptual coupling (semantic similarity) between `SimpleNode.java` and some co-changed entities (e.g., `Parser.java`, `EvalError.java`) using `get_conceptual_coupling`.\n2. Retrieve source code of one of the frequently co-changed files (e.g., `Parser.java`) and compare its usage of `SimpleNode`.\n\nLet\u2019s start by analyzing the conceptual coupling between `SimpleNode.java` and `Parser.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_55914de1f6e44f7d91d10c",
                    "function": {
                        "arguments": "{\"entity1\": \"SimpleNode.java\", \"entity2\": \"Parser.java\"}",
                        "name": "get_conceptual_coupling"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_conceptual_coupling",
            "content": "\"0.69306767\""
        },
        {
            "content": "The conceptual coupling (semantic similarity) between `SimpleNode.java` and `Parser.java` is approximately **0.693**, or 69.3%. This indicates a moderate to high level of semantic overlap between the two files, reinforcing the idea that they are functionally related despite lacking direct code-level coupling.\n\nThis aligns with our earlier understanding: `SimpleNode` serves as a foundational class in AST management, while `Parser.java` likely uses or manipulates such nodes during parsing operations.\n\n### Next Steps:\n\nTo further validate their relationship:\n- We can retrieve and inspect the source code of `Parser.java` to see how it interacts with `SimpleNode.java`.\n- Similarly, we could analyze the usage of `SimpleNode` in other co-changed files (e.g., checking if they extend or manipulate `SimpleNode` indirectly).\n\nLet's retrieve the source code for `Parser.java` to explore its connection with `SimpleNode.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_631c40ef9e17440693efda",
                    "function": {
                        "arguments": "{\"entity\": \"Parser.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package bsh;\\nimport java.io.*;\\npublic class Parserimplements ParserTreeConstants, ParserConstants {\\n  protected JJTParserState jjtree = new JJTParserState();boolean retainComments = false;\\n        public void setRetainComments( boolean b ) {\\n                retainComments = b;\\n        }\\n        void jjtreeOpenNodeScope(Node n) {\\n                ((SimpleNode)n).firstToken = getToken(1);\\n        }\\n        void jjtreeCloseNodeScope(Node n) {\\n                ((SimpleNode)n).lastToken = getToken(0);\\n        }\\n        void reInitInput( Reader in ) {\\n                ReInit(in);\\n        }\\n        public SimpleNode popNode()\\n        {\\n                if ( jjtree.nodeArity() > 0)                          return (SimpleNode)jjtree.popNode();\\n                else\\n                        return null;\\n        }\\n        void reInitTokenInput( Reader in ) {\\n                jj_input_stream.ReInit( in,\\n                        jj_input_stream.getEndLine(),\\n                        jj_input_stream.getEndColumn() );\\n        }\\n        public static void main( String [] args )\\n                throws IOException, ParseException\\n        {\\n                boolean print = false;\\n                int i=0;\\n                if ( args[0].equals(\\\"-p\\\") ) {\\n                        i++;\\n                        print=true;\\n                }\\n                for(; i< args.length; i++) {\\n                        Reader in = new FileReader(args[i]);\\n                        Parser parser = new Parser(in);\\n                        parser.setRetainComments(true);\\n                        while( !parser.Line() )\\n                                if ( print )\\n                                        System.out.println( parser.popNode() );\\n                }\\n        }\\n  final public boolean Line() throws ParseException {\\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n    case 0:\\n      jj_consume_token(0);\\n        Interpreter.debug(\\\"End of File!\\\");\\n        {if (true) return true;}\\n      break;\\n    case BOOLEAN:\\n    case BREAK:\\n    case BYTE:\\n    case CHAR:\\n    case CONTINUE:\\n    case DO:\\n    case DOUBLE:\\n    case FALSE:\\n    case FINAL:\\n    case FLOAT:\\n    case FOR:\\n    case IF:\\n    case IMPORT:\\n    case INT:\\n    case LONG:\\n    case NEW:\\n    case NULL:\\n    case RETURN:\\n    case SHORT:\\n    case SWITCH:\\n    case THROW:\\n    case TRUE:\\n    case TRY:\\n    case VOID:\\n    case WHILE:\\n    case INTEGER_LITERAL:\\n    case FLOATING_POINT_LITERAL:\\n    case CHARACTER_LITERAL:\\n    case STRING_LITERAL:\\n    case FORMAL_COMMENT:\\n    case IDENTIFIER:\\n    case LPAREN:\\n    case LBRACE:\\n    case SEMICOLON:\\n    case BANG:\\n    case TILDE:\\n    case INCR:\\n    case DECR:\\n    case PLUS:\\n    case MINUS:\\n      if (jj_2_1(2147483647)) {\\n        Expression();\\n        jj_consume_token(SEMICOLON);\\n      } else {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case BOOLEAN:\\n        case BREAK:\\n        case BYTE:\\n        case CHAR:\\n        case CONTINUE:\\n        case DO:\\n        case DOUBLE:\\n        case FALSE:\\n        case FINAL:\\n        case FLOAT:\\n        case FOR:\\n        case IF:\\n        case IMPORT:\\n        case INT:\\n        case LONG:\\n        case NEW:\\n        case NULL:\\n        case RETURN:\\n        case SHORT:\\n        case SWITCH:\\n        case THROW:\\n        case TRUE:\\n        case TRY:\\n        case VOID:\\n        case WHILE:\\n        case INTEGER_LITERAL:\\n        case FLOATING_POINT_LITERAL:\\n        case CHARACTER_LITERAL:\\n        case STRING_LITERAL:\\n        case FORMAL_COMMENT:\\n        case IDENTIFIER:\\n        case LPAREN:\\n        case LBRACE:\\n        case SEMICOLON:\\n        case INCR:\\n        case DECR:\\n          BlockStatement();\\n          break;\\n        default:\\n          jj_la1[0] = jj_gen;\\n          jj_consume_token(-1);\\n          throw new ParseException();\\n        }\\n      }\\n                {if (true) return false;}\\n      break;\\n    default:\\n      jj_la1[1] = jj_gen;\\n      jj_consume_token(-1);\\n      throw new ParseException();\\n    }\\n    throw new Error(\\\"Missing return statement in function\\\");\\n  }\\n  final public void MethodDeclaration() throws ParseException {\\n  BSHMethodDeclaration jjtn000 = new BSHMethodDeclaration(JJTMETHODDECLARATION);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);Token t = null;\\n    try {\\n      if (jj_2_2(2147483647)) {\\n        ReturnType();\\n        t = jj_consume_token(IDENTIFIER);\\n                                    jjtn000.name = t.image;\\n        FormalParameters();\\n        Block();\\n      } else {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case IDENTIFIER:\\n          t = jj_consume_token(IDENTIFIER);\\n                       jjtn000.name = t.image;\\n          FormalParameters();\\n          Block();\\n          break;\\n        default:\\n          jj_la1[2] = jj_gen;\\n          jj_consume_token(-1);\\n          throw new ParseException();\\n        }\\n      }\\n    } catch (Throwable jjte000) {\\n      if (jjtc000) {\\n        jjtree.clearNodeScope(jjtn000);\\n        jjtc000 = false;\\n      } else {\\n        jjtree.popNode();\\n      }\\n      if (jjte000 instanceof RuntimeException) {\\n        {if (true) throw (RuntimeException)jjte000;}\\n      }\\n      if (jjte000 instanceof ParseException) {\\n        {if (true) throw (ParseException)jjte000;}\\n      }\\n      {if (true) throw (Error)jjte000;}\\n    } finally {\\n      if (jjtc000) {\\n        jjtree.closeNodeScope(jjtn000, true);\\n        jjtreeCloseNodeScope(jjtn000);\\n      }\\n    }\\n  }\\n  final public void MethodDeclarationLookahead() throws ParseException {\\n    if (jj_2_3(2147483647)) {\\n      ReturnType();\\n      jj_consume_token(IDENTIFIER);\\n      FormalParameters();\\n      jj_consume_token(LBRACE);\\n    } else {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case IDENTIFIER:\\n        jj_consume_token(IDENTIFIER);\\n        FormalParameters();\\n        jj_consume_token(LBRACE);\\n        break;\\n      default:\\n        jj_la1[3] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n    }\\n  }\\n  final public void MethodDeclarationTypeLookahead() throws ParseException {\\n    ReturnType();\\n    jj_consume_token(IDENTIFIER);\\n    jj_consume_token(LPAREN);\\n  }\\n  final public void ImportDeclaration() throws ParseException {\\n    BSHImportDeclaration jjtn000 = new BSHImportDeclaration(JJTIMPORTDECLARATION);\\n    boolean jjtc000 = true;\\n    jjtree.openNodeScope(jjtn000);\\n    jjtreeOpenNodeScope(jjtn000);Token t = null;\\n    try {\\n      if (jj_2_4(2)) {\\n        jj_consume_token(IMPORT);\\n        AmbiguousName();\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case DOT:\\n          t = jj_consume_token(DOT);\\n          jj_consume_token(STAR);\\n          break;\\n        default:\\n          jj_la1[4] = jj_gen;\\n          ;\\n        }\\n        jj_consume_token(SEMICOLON);\\n                                                 jjtree.closeNodeScope(jjtn000, true);\\n                                                 jjtc000 = false;\\n                                                 jjtreeCloseNodeScope(jjtn000);\\n    if ( t != null )\\n        jjtn000.importPackage = true;\\n      } else {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case IMPORT:\\n          jj_consume_token(IMPORT);\\n          jj_consume_token(STAR);\\n          jj_consume_token(SEMICOLON);\\n                     jjtree.closeNodeScope(jjtn000, true);\\n                     jjtc000 = false;\\n                     jjtreeCloseNodeScope(jjtn000);\\n                jjtn000.superImport = true;\\n          break;\\n        default:\\n          jj_la1[5] = jj_gen;\\n          jj_consume_token(-1);\\n          throw new ParseException();\\n        }\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void VariableDeclarator() throws ParseException {\\n  BSHVariableDeclarator jjtn000 = new BSHVariableDeclarator(JJTVARIABLEDECLARATOR);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);Token t;\\n    try {\\n      t = jj_consume_token(IDENTIFIER);\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case ASSIGN:\\n        jj_consume_token(ASSIGN);\\n        VariableInitializer();\\n        break;\\n      default:\\n        jj_la1[6] = jj_gen;\\n        ;\\n      }\\n                                                 jjtree.closeNodeScope(jjtn000, true);\\n                                                 jjtc000 = false;\\n                                                 jjtreeCloseNodeScope(jjtn000);\\n                                                 jjtn000.name = t.image;\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void VariableInitializer() throws ParseException {\\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n    case LBRACE:\\n      ArrayInitializer();\\n      break;\\n    case BOOLEAN:\\n    case BYTE:\\n    case CHAR:\\n    case DOUBLE:\\n    case FALSE:\\n    case FLOAT:\\n    case INT:\\n    case LONG:\\n    case NEW:\\n    case NULL:\\n    case SHORT:\\n    case TRUE:\\n    case VOID:\\n    case INTEGER_LITERAL:\\n    case FLOATING_POINT_LITERAL:\\n    case CHARACTER_LITERAL:\\n    case STRING_LITERAL:\\n    case IDENTIFIER:\\n    case LPAREN:\\n    case BANG:\\n    case TILDE:\\n    case INCR:\\n    case DECR:\\n    case PLUS:\\n    case MINUS:\\n      Expression();\\n      break;\\n    default:\\n      jj_la1[7] = jj_gen;\\n      jj_consume_token(-1);\\n      throw new ParseException();\\n    }\\n  }\\n  final public void ArrayInitializer() throws ParseException {\\n  BSHArrayInitializer jjtn000 = new BSHArrayInitializer(JJTARRAYINITIALIZER);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(LBRACE);\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FALSE:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case NEW:\\n      case NULL:\\n      case SHORT:\\n      case TRUE:\\n      case VOID:\\n      case INTEGER_LITERAL:\\n      case FLOATING_POINT_LITERAL:\\n      case CHARACTER_LITERAL:\\n      case STRING_LITERAL:\\n      case IDENTIFIER:\\n      case LPAREN:\\n      case LBRACE:\\n      case BANG:\\n      case TILDE:\\n      case INCR:\\n      case DECR:\\n      case PLUS:\\n      case MINUS:\\n        VariableInitializer();\\n        label_1:\\n        while (true) {\\n          if (jj_2_5(2)) {\\n            ;\\n          } else {\\n            break label_1;\\n          }\\n          jj_consume_token(COMMA);\\n          VariableInitializer();\\n        }\\n        break;\\n      default:\\n        jj_la1[8] = jj_gen;\\n        ;\\n      }\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case COMMA:\\n        jj_consume_token(COMMA);\\n        break;\\n      default:\\n        jj_la1[9] = jj_gen;\\n        ;\\n      }\\n      jj_consume_token(RBRACE);\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void FormalParameters() throws ParseException {\\n  BSHFormalParameters jjtn000 = new BSHFormalParameters(JJTFORMALPARAMETERS);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(LPAREN);\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case SHORT:\\n      case IDENTIFIER:\\n        FormalParameter();\\n        label_2:\\n        while (true) {\\n          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n          case COMMA:\\n            ;\\n            break;\\n          default:\\n            jj_la1[10] = jj_gen;\\n            break label_2;\\n          }\\n          jj_consume_token(COMMA);\\n          FormalParameter();\\n        }\\n        break;\\n      default:\\n        jj_la1[11] = jj_gen;\\n        ;\\n      }\\n      jj_consume_token(RPAREN);\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void FormalParameter() throws ParseException {\\n  BSHFormalParameter jjtn000 = new BSHFormalParameter(JJTFORMALPARAMETER);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);Token t;\\n    try {\\n      if (jj_2_6(2)) {\\n        Type();\\n        t = jj_consume_token(IDENTIFIER);\\n                                       jjtree.closeNodeScope(jjtn000, true);\\n                                       jjtc000 = false;\\n                                       jjtreeCloseNodeScope(jjtn000);\\n                                       jjtn000.name = t.image;\\n      } else {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case IDENTIFIER:\\n          t = jj_consume_token(IDENTIFIER);\\n                   jjtree.closeNodeScope(jjtn000, true);\\n                   jjtc000 = false;\\n                   jjtreeCloseNodeScope(jjtn000);\\n                   jjtn000.name = t.image;\\n          break;\\n        default:\\n          jj_la1[12] = jj_gen;\\n          jj_consume_token(-1);\\n          throw new ParseException();\\n        }\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void Type() throws ParseException {\\n  BSHType jjtn000 = new BSHType(JJTTYPE);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case SHORT:\\n        PrimitiveType();\\n        break;\\n      case IDENTIFIER:\\n        AmbiguousName();\\n        break;\\n      default:\\n        jj_la1[13] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n      label_3:\\n      while (true) {\\n        if (jj_2_7(2)) {\\n          ;\\n        } else {\\n          break label_3;\\n        }\\n        jj_consume_token(LBRACKET);\\n        jj_consume_token(RBRACKET);\\n                                 jjtn000.addArrayDimension();\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void ReturnType() throws ParseException {\\n  BSHReturnType jjtn000 = new BSHReturnType(JJTRETURNTYPE);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case VOID:\\n        jj_consume_token(VOID);\\n           jjtree.closeNodeScope(jjtn000, true);\\n           jjtc000 = false;\\n           jjtreeCloseNodeScope(jjtn000);\\n           jjtn000.isVoid = true;\\n        break;\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case SHORT:\\n      case IDENTIFIER:\\n        Type();\\n        break;\\n      default:\\n        jj_la1[14] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void PrimitiveType() throws ParseException {\\n  BSHPrimitiveType jjtn000 = new BSHPrimitiveType(JJTPRIMITIVETYPE);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n        jj_consume_token(BOOLEAN);\\n            jjtree.closeNodeScope(jjtn000, true);\\n            jjtc000 = false;\\n            jjtreeCloseNodeScope(jjtn000);\\n            jjtn000.type = Boolean.TYPE;\\n        break;\\n      case CHAR:\\n        jj_consume_token(CHAR);\\n           jjtree.closeNodeScope(jjtn000, true);\\n           jjtc000 = false;\\n           jjtreeCloseNodeScope(jjtn000);\\n           jjtn000.type =  Character.TYPE;\\n        break;\\n      case BYTE:\\n        jj_consume_token(BYTE);\\n           jjtree.closeNodeScope(jjtn000, true);\\n           jjtc000 = false;\\n           jjtreeCloseNodeScope(jjtn000);\\n           jjtn000.type =  Byte.TYPE;\\n        break;\\n      case SHORT:\\n        jj_consume_token(SHORT);\\n            jjtree.closeNodeScope(jjtn000, true);\\n            jjtc000 = false;\\n            jjtreeCloseNodeScope(jjtn000);\\n            jjtn000.type =  Short.TYPE;\\n        break;\\n      case INT:\\n        jj_consume_token(INT);\\n          jjtree.closeNodeScope(jjtn000, true);\\n          jjtc000 = false;\\n          jjtreeCloseNodeScope(jjtn000);\\n          jjtn000.type =  Integer.TYPE;\\n        break;\\n      case LONG:\\n        jj_consume_token(LONG);\\n           jjtree.closeNodeScope(jjtn000, true);\\n           jjtc000 = false;\\n           jjtreeCloseNodeScope(jjtn000);\\n           jjtn000.type =  Long.TYPE;\\n        break;\\n      case FLOAT:\\n        jj_consume_token(FLOAT);\\n            jjtree.closeNodeScope(jjtn000, true);\\n            jjtc000 = false;\\n            jjtreeCloseNodeScope(jjtn000);\\n            jjtn000.type =  Float.TYPE;\\n        break;\\n      case DOUBLE:\\n        jj_consume_token(DOUBLE);\\n             jjtree.closeNodeScope(jjtn000, true);\\n             jjtc000 = false;\\n             jjtreeCloseNodeScope(jjtn000);\\n             jjtn000.type =  Double.TYPE;\\n        break;\\n      default:\\n        jj_la1[15] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n    } finally {\\n  if (jjtc000) {\\n    jjtree.closeNodeScope(jjtn000, true);\\n    jjtreeCloseNodeScope(jjtn000);\\n  }\\n    }\\n  }\\n  final public void AmbiguousName() throws ParseException {\\n    BSHAmbiguousName jjtn000 = new BSHAmbiguousName(JJTAMBIGUOUSNAME);\\n    boolean jjtc000 = true;\\n    jjtree.openNodeScope(jjtn000);\\n    jjtreeOpenNodeScope(jjtn000);Token t;\\n    StringBuffer s;\\n    try {\\n      t = jj_consume_token(IDENTIFIER);\\n        s = new StringBuffer(t.image);\\n      label_4:\\n      while (true) {\\n        if (jj_2_8(2)) {\\n          ;\\n        } else {\\n          break label_4;\\n        }\\n        jj_consume_token(DOT);\\n        t = jj_consume_token(IDENTIFIER);\\n        s.append(\\\".\\\"+t.image);\\n      }\\n       jjtree.closeNodeScope(jjtn000, true);\\n       jjtc000 = false;\\n       jjtreeCloseNodeScope(jjtn000);\\n        jjtn000.text = s.toString();\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void Expression() throws ParseException {\\n    if (jj_2_9(2147483647)) {\\n      Assignment();\\n    } else {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FALSE:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case NEW:\\n      case NULL:\\n      case SHORT:\\n      case TRUE:\\n      case VOID:\\n      case INTEGER_LITERAL:\\n      case FLOATING_POINT_LITERAL:\\n      case CHARACTER_LITERAL:\\n      case STRING_LITERAL:\\n      case IDENTIFIER:\\n      case LPAREN:\\n      case BANG:\\n      case TILDE:\\n      case INCR:\\n      case DECR:\\n      case PLUS:\\n      case MINUS:\\n        ConditionalExpression();\\n        break;\\n      default:\\n        jj_la1[16] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n    }\\n  }\\n  final public void Assignment() throws ParseException {\\n  BSHAssignment jjtn000 = new BSHAssignment(JJTASSIGNMENT);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);int op ;\\n    try {\\n      LHSPrimaryExpression();\\n      op = AssignmentOperator();\\n    jjtn000.operator = op;\\n      Expression();\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public int AssignmentOperator() throws ParseException {\\n  Token t;\\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n    case ASSIGN:\\n      jj_consume_token(ASSIGN);\\n      break;\\n    case STARASSIGN:\\n      jj_consume_token(STARASSIGN);\\n      break;\\n    case SLASHASSIGN:\\n      jj_consume_token(SLASHASSIGN);\\n      break;\\n    case MODASSIGN:\\n      jj_consume_token(MODASSIGN);\\n      break;\\n    case PLUSASSIGN:\\n      jj_consume_token(PLUSASSIGN);\\n      break;\\n    case MINUSASSIGN:\\n      jj_consume_token(MINUSASSIGN);\\n      break;\\n    case ANDASSIGN:\\n      jj_consume_token(ANDASSIGN);\\n      break;\\n    case XORASSIGN:\\n      jj_consume_token(XORASSIGN);\\n      break;\\n    case ORASSIGN:\\n      jj_consume_token(ORASSIGN);\\n      break;\\n    case LSHIFTASSIGN:\\n      jj_consume_token(LSHIFTASSIGN);\\n      break;\\n    case LSHIFTASSIGNX:\\n      jj_consume_token(LSHIFTASSIGNX);\\n      break;\\n    case RSIGNEDSHIFTASSIGN:\\n      jj_consume_token(RSIGNEDSHIFTASSIGN);\\n      break;\\n    case RSIGNEDSHIFTASSIGNX:\\n      jj_consume_token(RSIGNEDSHIFTASSIGNX);\\n      break;\\n    case RUNSIGNEDSHIFTASSIGN:\\n      jj_consume_token(RUNSIGNEDSHIFTASSIGN);\\n      break;\\n    case RUNSIGNEDSHIFTASSIGNX:\\n      jj_consume_token(RUNSIGNEDSHIFTASSIGNX);\\n      break;\\n    default:\\n      jj_la1[17] = jj_gen;\\n      jj_consume_token(-1);\\n      throw new ParseException();\\n    }\\n        t = getToken(0);\\n        {if (true) return t.kind;}\\n    throw new Error(\\\"Missing return statement in function\\\");\\n  }\\n  final public void ConditionalExpression() throws ParseException {\\n    ConditionalOrExpression();\\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n    case HOOK:\\n      jj_consume_token(HOOK);\\n      Expression();\\n      jj_consume_token(COLON);\\n                                                     BSHTernaryExpression jjtn001 = new BSHTernaryExpression(JJTTERNARYEXPRESSION);\\n                                                     boolean jjtc001 = true;\\n                                                     jjtree.openNodeScope(jjtn001);\\n                                                     jjtreeOpenNodeScope(jjtn001);\\n      try {\\n        ConditionalExpression();\\n      } catch (Throwable jjte001) {\\n                                                     if (jjtc001) {\\n                                                       jjtree.clearNodeScope(jjtn001);\\n                                                       jjtc001 = false;\\n                                                     } else {\\n                                                       jjtree.popNode();\\n                                                     }\\n                                                     if (jjte001 instanceof RuntimeException) {\\n                                                       {if (true) throw (RuntimeException)jjte001;}\\n                                                     }\\n                                                     if (jjte001 instanceof ParseException) {\\n                                                       {if (true) throw (ParseException)jjte001;}\\n                                                     }\\n                                                     {if (true) throw (Error)jjte001;}\\n      } finally {\\n                                                     if (jjtc001) {\\n                                                       jjtree.closeNodeScope(jjtn001,  3);\\n                                                       jjtreeCloseNodeScope(jjtn001);\\n                                                     }\\n      }\\n      break;\\n    default:\\n      jj_la1[18] = jj_gen;\\n      ;\\n    }\\n  }\\n  final public void ConditionalOrExpression() throws ParseException {\\n  Token t=null;\\n    ConditionalAndExpression();\\n    label_5:\\n    while (true) {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOL_OR:\\n      case BOOL_ORX:\\n        ;\\n        break;\\n      default:\\n        jj_la1[19] = jj_gen;\\n        break label_5;\\n      }\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOL_OR:\\n        t = jj_consume_token(BOOL_OR);\\n        break;\\n      case BOOL_ORX:\\n        t = jj_consume_token(BOOL_ORX);\\n        break;\\n      default:\\n        jj_la1[20] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n      ConditionalAndExpression();\\n      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);\\n      boolean jjtc001 = true;\\n      jjtree.openNodeScope(jjtn001);\\n      jjtreeOpenNodeScope(jjtn001);\\n      try {\\n      jjtree.closeNodeScope(jjtn001,  2);\\n      jjtc001 = false;\\n      jjtreeCloseNodeScope(jjtn001);\\n      jjtn001.kind = t.kind;\\n      } finally {\\n      if (jjtc001) {\\n        jjtree.closeNodeScope(jjtn001,  2);\\n        jjtreeCloseNodeScope(jjtn001);\\n      }\\n      }\\n    }\\n  }\\n  final public void ConditionalAndExpression() throws ParseException {\\n  Token t=null;\\n    InclusiveOrExpression();\\n    label_6:\\n    while (true) {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOL_AND:\\n      case BOOL_ANDX:\\n        ;\\n        break;\\n      default:\\n        jj_la1[21] = jj_gen;\\n        break label_6;\\n      }\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOL_AND:\\n        t = jj_consume_token(BOOL_AND);\\n        break;\\n      case BOOL_ANDX:\\n        t = jj_consume_token(BOOL_ANDX);\\n        break;\\n      default:\\n        jj_la1[22] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n      InclusiveOrExpression();\\n      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);\\n      boolean jjtc001 = true;\\n      jjtree.openNodeScope(jjtn001);\\n      jjtreeOpenNodeScope(jjtn001);\\n      try {\\n      jjtree.closeNodeScope(jjtn001,  2);\\n      jjtc001 = false;\\n      jjtreeCloseNodeScope(jjtn001);\\n      jjtn001.kind = t.kind;\\n      } finally {\\n      if (jjtc001) {\\n        jjtree.closeNodeScope(jjtn001,  2);\\n        jjtreeCloseNodeScope(jjtn001);\\n      }\\n      }\\n    }\\n  }\\n  final public void InclusiveOrExpression() throws ParseException {\\n  Token t=null;\\n    ExclusiveOrExpression();\\n    label_7:\\n    while (true) {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BIT_OR:\\n      case BIT_ORX:\\n        ;\\n        break;\\n      default:\\n        jj_la1[23] = jj_gen;\\n        break label_7;\\n      }\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BIT_OR:\\n        t = jj_consume_token(BIT_OR);\\n        break;\\n      case BIT_ORX:\\n        t = jj_consume_token(BIT_ORX);\\n        break;\\n      default:\\n        jj_la1[24] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n      ExclusiveOrExpression();\\n      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);\\n      boolean jjtc001 = true;\\n      jjtree.openNodeScope(jjtn001);\\n      jjtreeOpenNodeScope(jjtn001);\\n      try {\\n      jjtree.closeNodeScope(jjtn001,  2);\\n      jjtc001 = false;\\n      jjtreeCloseNodeScope(jjtn001);\\n      jjtn001.kind = t.kind;\\n      } finally {\\n      if (jjtc001) {\\n        jjtree.closeNodeScope(jjtn001,  2);\\n        jjtreeCloseNodeScope(jjtn001);\\n      }\\n      }\\n    }\\n  }\\n  final public void ExclusiveOrExpression() throws ParseException {\\n  Token t=null;\\n    AndExpression();\\n    label_8:\\n    while (true) {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case XOR:\\n        ;\\n        break;\\n      default:\\n        jj_la1[25] = jj_gen;\\n        break label_8;\\n      }\\n      t = jj_consume_token(XOR);\\n      AndExpression();\\n      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);\\n      boolean jjtc001 = true;\\n      jjtree.openNodeScope(jjtn001);\\n      jjtreeOpenNodeScope(jjtn001);\\n      try {\\n      jjtree.closeNodeScope(jjtn001,  2);\\n      jjtc001 = false;\\n      jjtreeCloseNodeScope(jjtn001);\\n      jjtn001.kind = t.kind;\\n      } finally {\\n      if (jjtc001) {\\n        jjtree.closeNodeScope(jjtn001,  2);\\n        jjtreeCloseNodeScope(jjtn001);\\n      }\\n      }\\n    }\\n  }\\n  final public void AndExpression() throws ParseException {\\n  Token t=null;\\n    EqualityExpression();\\n    label_9:\\n    while (true) {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BIT_AND:\\n      case BIT_ANDX:\\n        ;\\n        break;\\n      default:\\n        jj_la1[26] = jj_gen;\\n        break label_9;\\n      }\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BIT_AND:\\n        t = jj_consume_token(BIT_AND);\\n        break;\\n      case BIT_ANDX:\\n        t = jj_consume_token(BIT_ANDX);\\n        break;\\n      default:\\n        jj_la1[27] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n      EqualityExpression();\\n      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);\\n      boolean jjtc001 = true;\\n      jjtree.openNodeScope(jjtn001);\\n      jjtreeOpenNodeScope(jjtn001);\\n      try {\\n      jjtree.closeNodeScope(jjtn001,  2);\\n      jjtc001 = false;\\n      jjtreeCloseNodeScope(jjtn001);\\n      jjtn001.kind = t.kind;\\n      } finally {\\n      if (jjtc001) {\\n        jjtree.closeNodeScope(jjtn001,  2);\\n        jjtreeCloseNodeScope(jjtn001);\\n      }\\n      }\\n    }\\n  }\\n  final public void EqualityExpression() throws ParseException {\\n  Token t = null;\\n    InstanceOfExpression();\\n    label_10:\\n    while (true) {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case EQ:\\n      case NE:\\n        ;\\n        break;\\n      default:\\n        jj_la1[28] = jj_gen;\\n        break label_10;\\n      }\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case EQ:\\n        t = jj_consume_token(EQ);\\n        break;\\n      case NE:\\n        t = jj_consume_token(NE);\\n        break;\\n      default:\\n        jj_la1[29] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n      InstanceOfExpression();\\n      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);\\n      boolean jjtc001 = true;\\n      jjtree.openNodeScope(jjtn001);\\n      jjtreeOpenNodeScope(jjtn001);\\n      try {\\n      jjtree.closeNodeScope(jjtn001,  2);\\n      jjtc001 = false;\\n      jjtreeCloseNodeScope(jjtn001);\\n      jjtn001.kind = t.kind;\\n      } finally {\\n      if (jjtc001) {\\n        jjtree.closeNodeScope(jjtn001,  2);\\n        jjtreeCloseNodeScope(jjtn001);\\n      }\\n      }\\n    }\\n  }\\n  final public void InstanceOfExpression() throws ParseException {\\n  Token t = null;\\n    RelationalExpression();\\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n    case INSTANCEOF:\\n      t = jj_consume_token(INSTANCEOF);\\n      Type();\\n                              BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);\\n                              boolean jjtc001 = true;\\n                              jjtree.openNodeScope(jjtn001);\\n                              jjtreeOpenNodeScope(jjtn001);\\n      try {\\n                              jjtree.closeNodeScope(jjtn001,  2);\\n                              jjtc001 = false;\\n                              jjtreeCloseNodeScope(jjtn001);\\n                              jjtn001.kind = t.kind;\\n      } finally {\\n                              if (jjtc001) {\\n                                jjtree.closeNodeScope(jjtn001,  2);\\n                                jjtreeCloseNodeScope(jjtn001);\\n                              }\\n      }\\n      break;\\n    default:\\n      jj_la1[30] = jj_gen;\\n      ;\\n    }\\n  }\\n  final public void RelationalExpression() throws ParseException {\\n  Token t = null;\\n    ShiftExpression();\\n    label_11:\\n    while (true) {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case GT:\\n      case GTX:\\n      case LT:\\n      case LTX:\\n      case LE:\\n      case LEX:\\n      case GE:\\n      case GEX:\\n        ;\\n        break;\\n      default:\\n        jj_la1[31] = jj_gen;\\n        break label_11;\\n      }\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case LT:\\n        t = jj_consume_token(LT);\\n        break;\\n      case LTX:\\n        t = jj_consume_token(LTX);\\n        break;\\n      case GT:\\n        t = jj_consume_token(GT);\\n        break;\\n      case GTX:\\n        t = jj_consume_token(GTX);\\n        break;\\n      case LE:\\n        t = jj_consume_token(LE);\\n        break;\\n      case LEX:\\n        t = jj_consume_token(LEX);\\n        break;\\n      case GE:\\n        t = jj_consume_token(GE);\\n        break;\\n      case GEX:\\n        t = jj_consume_token(GEX);\\n        break;\\n      default:\\n        jj_la1[32] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n      ShiftExpression();\\n    BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);\\n    boolean jjtc001 = true;\\n    jjtree.openNodeScope(jjtn001);\\n    jjtreeOpenNodeScope(jjtn001);\\n      try {\\n    jjtree.closeNodeScope(jjtn001,  2);\\n    jjtc001 = false;\\n    jjtreeCloseNodeScope(jjtn001);\\n    jjtn001.kind = t.kind;\\n      } finally {\\n    if (jjtc001) {\\n      jjtree.closeNodeScope(jjtn001,  2);\\n      jjtreeCloseNodeScope(jjtn001);\\n    }\\n      }\\n    }\\n  }\\n  final public void ShiftExpression() throws ParseException {\\n  Token t = null;\\n    AdditiveExpression();\\n    label_12:\\n    while (true) {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case LSHIFT:\\n      case LSHIFTX:\\n      case RSIGNEDSHIFT:\\n      case RSIGNEDSHIFTX:\\n      case RUNSIGNEDSHIFT:\\n      case RUNSIGNEDSHIFTX:\\n        ;\\n        break;\\n      default:\\n        jj_la1[33] = jj_gen;\\n        break label_12;\\n      }\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case LSHIFT:\\n        t = jj_consume_token(LSHIFT);\\n        break;\\n      case LSHIFTX:\\n        t = jj_consume_token(LSHIFTX);\\n        break;\\n      case RSIGNEDSHIFT:\\n        t = jj_consume_token(RSIGNEDSHIFT);\\n        break;\\n      case RSIGNEDSHIFTX:\\n        t = jj_consume_token(RSIGNEDSHIFTX);\\n        break;\\n      case RUNSIGNEDSHIFT:\\n        t = jj_consume_token(RUNSIGNEDSHIFT);\\n        break;\\n      case RUNSIGNEDSHIFTX:\\n        t = jj_consume_token(RUNSIGNEDSHIFTX);\\n        break;\\n      default:\\n        jj_la1[34] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n      AdditiveExpression();\\n    BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);\\n    boolean jjtc001 = true;\\n    jjtree.openNodeScope(jjtn001);\\n    jjtreeOpenNodeScope(jjtn001);\\n      try {\\n    jjtree.closeNodeScope(jjtn001,  2);\\n    jjtc001 = false;\\n    jjtreeCloseNodeScope(jjtn001);\\n    jjtn001.kind = t.kind;\\n      } finally {\\n    if (jjtc001) {\\n      jjtree.closeNodeScope(jjtn001,  2);\\n      jjtreeCloseNodeScope(jjtn001);\\n    }\\n      }\\n    }\\n  }\\n  final public void AdditiveExpression() throws ParseException {\\n  Token t = null;\\n    MultiplicativeExpression();\\n    label_13:\\n    while (true) {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case PLUS:\\n      case MINUS:\\n        ;\\n        break;\\n      default:\\n        jj_la1[35] = jj_gen;\\n        break label_13;\\n      }\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case PLUS:\\n        t = jj_consume_token(PLUS);\\n        break;\\n      case MINUS:\\n        t = jj_consume_token(MINUS);\\n        break;\\n      default:\\n        jj_la1[36] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n      MultiplicativeExpression();\\n                                                     BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);\\n                                                     boolean jjtc001 = true;\\n                                                     jjtree.openNodeScope(jjtn001);\\n                                                     jjtreeOpenNodeScope(jjtn001);\\n      try {\\n                                                     jjtree.closeNodeScope(jjtn001,  2);\\n                                                     jjtc001 = false;\\n                                                     jjtreeCloseNodeScope(jjtn001);\\n                                                     jjtn001.kind = t.kind;\\n      } finally {\\n                                                     if (jjtc001) {\\n                                                       jjtree.closeNodeScope(jjtn001,  2);\\n                                                       jjtreeCloseNodeScope(jjtn001);\\n                                                     }\\n      }\\n    }\\n  }\\n  final public void MultiplicativeExpression() throws ParseException {\\n  Token t = null;\\n    UnaryExpression();\\n    label_14:\\n    while (true) {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case STAR:\\n      case SLASH:\\n      case MOD:\\n        ;\\n        break;\\n      default:\\n        jj_la1[37] = jj_gen;\\n        break label_14;\\n      }\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case STAR:\\n        t = jj_consume_token(STAR);\\n        break;\\n      case SLASH:\\n        t = jj_consume_token(SLASH);\\n        break;\\n      case MOD:\\n        t = jj_consume_token(MOD);\\n        break;\\n      default:\\n        jj_la1[38] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n      UnaryExpression();\\n                      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);\\n                      boolean jjtc001 = true;\\n                      jjtree.openNodeScope(jjtn001);\\n                      jjtreeOpenNodeScope(jjtn001);\\n      try {\\n                      jjtree.closeNodeScope(jjtn001,  2);\\n                      jjtc001 = false;\\n                      jjtreeCloseNodeScope(jjtn001);\\n                      jjtn001.kind = t.kind;\\n      } finally {\\n                      if (jjtc001) {\\n                        jjtree.closeNodeScope(jjtn001,  2);\\n                        jjtreeCloseNodeScope(jjtn001);\\n                      }\\n      }\\n    }\\n  }\\n  final public void UnaryExpression() throws ParseException {\\n  Token t = null;\\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n    case PLUS:\\n    case MINUS:\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case PLUS:\\n        t = jj_consume_token(PLUS);\\n        break;\\n      case MINUS:\\n        t = jj_consume_token(MINUS);\\n        break;\\n      default:\\n        jj_la1[39] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n      UnaryExpression();\\n      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);\\n      boolean jjtc001 = true;\\n      jjtree.openNodeScope(jjtn001);\\n      jjtreeOpenNodeScope(jjtn001);\\n      try {\\n      jjtree.closeNodeScope(jjtn001,  1);\\n      jjtc001 = false;\\n      jjtreeCloseNodeScope(jjtn001);\\n      jjtn001.kind = t.kind;\\n      } finally {\\n      if (jjtc001) {\\n        jjtree.closeNodeScope(jjtn001,  1);\\n        jjtreeCloseNodeScope(jjtn001);\\n      }\\n      }\\n      break;\\n    case INCR:\\n      PreIncrementExpression();\\n      break;\\n    case DECR:\\n      PreDecrementExpression();\\n      break;\\n    case BOOLEAN:\\n    case BYTE:\\n    case CHAR:\\n    case DOUBLE:\\n    case FALSE:\\n    case FLOAT:\\n    case INT:\\n    case LONG:\\n    case NEW:\\n    case NULL:\\n    case SHORT:\\n    case TRUE:\\n    case VOID:\\n    case INTEGER_LITERAL:\\n    case FLOATING_POINT_LITERAL:\\n    case CHARACTER_LITERAL:\\n    case STRING_LITERAL:\\n    case IDENTIFIER:\\n    case LPAREN:\\n    case BANG:\\n    case TILDE:\\n      UnaryExpressionNotPlusMinus();\\n      break;\\n    default:\\n      jj_la1[40] = jj_gen;\\n      jj_consume_token(-1);\\n      throw new ParseException();\\n    }\\n  }\\n  final public void PreIncrementExpression() throws ParseException {\\n  Token t = null;\\n    t = jj_consume_token(INCR);\\n    LHSPrimaryExpression();\\n      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);\\n      boolean jjtc001 = true;\\n      jjtree.openNodeScope(jjtn001);\\n      jjtreeOpenNodeScope(jjtn001);\\n    try {\\n      jjtree.closeNodeScope(jjtn001,  1);\\n      jjtc001 = false;\\n      jjtreeCloseNodeScope(jjtn001);\\n      jjtn001.kind = t.kind;\\n    } finally {\\n      if (jjtc001) {\\n        jjtree.closeNodeScope(jjtn001,  1);\\n        jjtreeCloseNodeScope(jjtn001);\\n      }\\n    }\\n  }\\n  final public void PreDecrementExpression() throws ParseException {\\n  Token t = null;\\n    t = jj_consume_token(DECR);\\n    LHSPrimaryExpression();\\n      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);\\n      boolean jjtc001 = true;\\n      jjtree.openNodeScope(jjtn001);\\n      jjtreeOpenNodeScope(jjtn001);\\n    try {\\n      jjtree.closeNodeScope(jjtn001,  1);\\n      jjtc001 = false;\\n      jjtreeCloseNodeScope(jjtn001);\\n      jjtn001.kind = t.kind;\\n    } finally {\\n      if (jjtc001) {\\n        jjtree.closeNodeScope(jjtn001,  1);\\n        jjtreeCloseNodeScope(jjtn001);\\n      }\\n    }\\n  }\\n  final public void UnaryExpressionNotPlusMinus() throws ParseException {\\n  Token t = null;\\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n    case BANG:\\n    case TILDE:\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case TILDE:\\n        t = jj_consume_token(TILDE);\\n        break;\\n      case BANG:\\n        t = jj_consume_token(BANG);\\n        break;\\n      default:\\n        jj_la1[41] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n      UnaryExpression();\\n      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);\\n      boolean jjtc001 = true;\\n      jjtree.openNodeScope(jjtn001);\\n      jjtreeOpenNodeScope(jjtn001);\\n      try {\\n      jjtree.closeNodeScope(jjtn001,  1);\\n      jjtc001 = false;\\n      jjtreeCloseNodeScope(jjtn001);\\n      jjtn001.kind = t.kind;\\n      } finally {\\n      if (jjtc001) {\\n        jjtree.closeNodeScope(jjtn001,  1);\\n        jjtreeCloseNodeScope(jjtn001);\\n      }\\n      }\\n      break;\\n    default:\\n      jj_la1[42] = jj_gen;\\n      if (jj_2_10(2147483647)) {\\n        CastExpression();\\n      } else {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case BOOLEAN:\\n        case BYTE:\\n        case CHAR:\\n        case DOUBLE:\\n        case FALSE:\\n        case FLOAT:\\n        case INT:\\n        case LONG:\\n        case NEW:\\n        case NULL:\\n        case SHORT:\\n        case TRUE:\\n        case VOID:\\n        case INTEGER_LITERAL:\\n        case FLOATING_POINT_LITERAL:\\n        case CHARACTER_LITERAL:\\n        case STRING_LITERAL:\\n        case IDENTIFIER:\\n        case LPAREN:\\n          PostfixExpression();\\n          break;\\n        default:\\n          jj_la1[43] = jj_gen;\\n          jj_consume_token(-1);\\n          throw new ParseException();\\n        }\\n      }\\n    }\\n  }\\n  final public void CastLookahead() throws ParseException {\\n    if (jj_2_11(2)) {\\n      jj_consume_token(LPAREN);\\n      PrimitiveType();\\n    } else if (jj_2_12(2147483647)) {\\n      jj_consume_token(LPAREN);\\n      AmbiguousName();\\n      jj_consume_token(LBRACKET);\\n      jj_consume_token(RBRACKET);\\n    } else {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case LPAREN:\\n        jj_consume_token(LPAREN);\\n        AmbiguousName();\\n        jj_consume_token(RPAREN);\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case TILDE:\\n          jj_consume_token(TILDE);\\n          break;\\n        case BANG:\\n          jj_consume_token(BANG);\\n          break;\\n        case LPAREN:\\n          jj_consume_token(LPAREN);\\n          break;\\n        case IDENTIFIER:\\n          jj_consume_token(IDENTIFIER);\\n          break;\\n        case NEW:\\n          jj_consume_token(NEW);\\n          break;\\n        case FALSE:\\n        case NULL:\\n        case TRUE:\\n        case VOID:\\n        case INTEGER_LITERAL:\\n        case FLOATING_POINT_LITERAL:\\n        case CHARACTER_LITERAL:\\n        case STRING_LITERAL:\\n          Literal();\\n          break;\\n        default:\\n          jj_la1[44] = jj_gen;\\n          jj_consume_token(-1);\\n          throw new ParseException();\\n        }\\n        break;\\n      default:\\n        jj_la1[45] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n    }\\n  }\\n  final public void PostfixExpression() throws ParseException {\\n  Token t = null;\\n    if (jj_2_13(2147483647)) {\\n      LHSPrimaryExpression();\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case INCR:\\n        t = jj_consume_token(INCR);\\n        break;\\n      case DECR:\\n        t = jj_consume_token(DECR);\\n        break;\\n      default:\\n        jj_la1[46] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n                                BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);\\n                                boolean jjtc001 = true;\\n                                jjtree.openNodeScope(jjtn001);\\n                                jjtreeOpenNodeScope(jjtn001);\\n      try {\\n                                jjtree.closeNodeScope(jjtn001,  1);\\n                                jjtc001 = false;\\n                                jjtreeCloseNodeScope(jjtn001);\\n                jjtn001.kind = t.kind; jjtn001.postfix = true;\\n      } finally {\\n                                if (jjtc001) {\\n                                  jjtree.closeNodeScope(jjtn001,  1);\\n                                  jjtreeCloseNodeScope(jjtn001);\\n                                }\\n      }\\n    } else {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FALSE:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case NEW:\\n      case NULL:\\n      case SHORT:\\n      case TRUE:\\n      case VOID:\\n      case INTEGER_LITERAL:\\n      case FLOATING_POINT_LITERAL:\\n      case CHARACTER_LITERAL:\\n      case STRING_LITERAL:\\n      case IDENTIFIER:\\n      case LPAREN:\\n        PrimaryExpression();\\n        break;\\n      default:\\n        jj_la1[47] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n    }\\n  }\\n  final public void CastExpression() throws ParseException {\\n  BSHCastExpression jjtn000 = new BSHCastExpression(JJTCASTEXPRESSION);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      if (jj_2_14(2147483647)) {\\n        jj_consume_token(LPAREN);\\n        Type();\\n        jj_consume_token(RPAREN);\\n        UnaryExpression();\\n      } else {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case LPAREN:\\n          jj_consume_token(LPAREN);\\n          Type();\\n          jj_consume_token(RPAREN);\\n          UnaryExpressionNotPlusMinus();\\n          break;\\n        default:\\n          jj_la1[48] = jj_gen;\\n          jj_consume_token(-1);\\n          throw new ParseException();\\n        }\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void PrimaryExpression() throws ParseException {\\n  BSHPrimaryExpression jjtn000 = new BSHPrimaryExpression(JJTPRIMARYEXPRESSION);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      PrimaryPrefix();\\n      label_15:\\n      while (true) {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case LBRACE:\\n        case LBRACKET:\\n        case DOT:\\n          ;\\n          break;\\n        default:\\n          jj_la1[49] = jj_gen;\\n          break label_15;\\n        }\\n        PrimarySuffix();\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void MethodInvocation() throws ParseException {\\n  BSHMethodInvocation jjtn000 = new BSHMethodInvocation(JJTMETHODINVOCATION);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      AmbiguousName();\\n      Arguments();\\n    } catch (Throwable jjte000) {\\n     if (jjtc000) {\\n       jjtree.clearNodeScope(jjtn000);\\n       jjtc000 = false;\\n     } else {\\n       jjtree.popNode();\\n     }\\n     if (jjte000 instanceof RuntimeException) {\\n       {if (true) throw (RuntimeException)jjte000;}\\n     }\\n     if (jjte000 instanceof ParseException) {\\n       {if (true) throw (ParseException)jjte000;}\\n     }\\n     {if (true) throw (Error)jjte000;}\\n    } finally {\\n     if (jjtc000) {\\n       jjtree.closeNodeScope(jjtn000, true);\\n       jjtreeCloseNodeScope(jjtn000);\\n     }\\n    }\\n  }\\n  final public void PrimaryPrefix() throws ParseException {\\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n    case FALSE:\\n    case NULL:\\n    case TRUE:\\n    case VOID:\\n    case INTEGER_LITERAL:\\n    case FLOATING_POINT_LITERAL:\\n    case CHARACTER_LITERAL:\\n    case STRING_LITERAL:\\n      Literal();\\n      break;\\n    case LPAREN:\\n      jj_consume_token(LPAREN);\\n      Expression();\\n      jj_consume_token(RPAREN);\\n      break;\\n    case NEW:\\n      AllocationExpression();\\n      break;\\n    default:\\n      jj_la1[50] = jj_gen;\\n      if (jj_2_15(2147483647)) {\\n        MethodInvocation();\\n      } else if (jj_2_16(2147483647)) {\\n        Type();\\n      } else {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case IDENTIFIER:\\n          AmbiguousName();\\n          break;\\n        default:\\n          jj_la1[51] = jj_gen;\\n          jj_consume_token(-1);\\n          throw new ParseException();\\n        }\\n      }\\n    }\\n  }\\n  final public void PrimarySuffix() throws ParseException {\\n    BSHPrimarySuffix jjtn000 = new BSHPrimarySuffix(JJTPRIMARYSUFFIX);\\n    boolean jjtc000 = true;\\n    jjtree.openNodeScope(jjtn000);\\n    jjtreeOpenNodeScope(jjtn000);Token t = null;\\n    try {\\n      if (jj_2_17(2)) {\\n        jj_consume_token(DOT);\\n        jj_consume_token(CLASS);\\n                jjtree.closeNodeScope(jjtn000, true);\\n                jjtc000 = false;\\n                jjtreeCloseNodeScope(jjtn000);\\n        jjtn000.operation = BSHPrimarySuffix.CLASS;\\n      } else {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case LBRACKET:\\n          jj_consume_token(LBRACKET);\\n          Expression();\\n          jj_consume_token(RBRACKET);\\n                         jjtree.closeNodeScope(jjtn000, true);\\n                         jjtc000 = false;\\n                         jjtreeCloseNodeScope(jjtn000);\\n        jjtn000.operation = BSHPrimarySuffix.INDEX;\\n          break;\\n        case DOT:\\n          jj_consume_token(DOT);\\n          t = jj_consume_token(IDENTIFIER);\\n          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n          case LPAREN:\\n            Arguments();\\n            break;\\n          default:\\n            jj_la1[52] = jj_gen;\\n            ;\\n          }\\n                                         jjtree.closeNodeScope(jjtn000, true);\\n                                         jjtc000 = false;\\n                                         jjtreeCloseNodeScope(jjtn000);\\n        jjtn000.operation = BSHPrimarySuffix.NAME;\\n        jjtn000.field = t.image;\\n          break;\\n        case LBRACE:\\n          jj_consume_token(LBRACE);\\n          Expression();\\n          jj_consume_token(RBRACE);\\n                         jjtree.closeNodeScope(jjtn000, true);\\n                         jjtc000 = false;\\n                         jjtreeCloseNodeScope(jjtn000);\\n        jjtn000.operation = BSHPrimarySuffix.PROPERTY;\\n          break;\\n        default:\\n          jj_la1[53] = jj_gen;\\n          jj_consume_token(-1);\\n          throw new ParseException();\\n        }\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void LHSPrimaryPrefix() throws ParseException {\\n    AmbiguousName();\\n  }\\n  final public void LHSPrimaryExpression() throws ParseException {\\n  BSHLHSPrimaryExpression jjtn000 = new BSHLHSPrimaryExpression(JJTLHSPRIMARYEXPRESSION);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      LHSPrimaryPrefix();\\n      label_16:\\n      while (true) {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case LBRACE:\\n        case LBRACKET:\\n        case DOT:\\n          ;\\n          break;\\n        default:\\n          jj_la1[54] = jj_gen;\\n          break label_16;\\n        }\\n        LHSPrimarySuffix();\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void LHSPrimarySuffix() throws ParseException {\\n    BSHLHSPrimarySuffix jjtn000 = new BSHLHSPrimarySuffix(JJTLHSPRIMARYSUFFIX);\\n    boolean jjtc000 = true;\\n    jjtree.openNodeScope(jjtn000);\\n    jjtreeOpenNodeScope(jjtn000);Token t=null, t1, t2 = null;\\n    try {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case LBRACKET:\\n        jj_consume_token(LBRACKET);\\n        Expression();\\n        jj_consume_token(RBRACKET);\\n                         jjtree.closeNodeScope(jjtn000, true);\\n                         jjtc000 = false;\\n                         jjtreeCloseNodeScope(jjtn000);\\n        jjtn000.operation = BSHLHSPrimarySuffix.INDEX;\\n        break;\\n      case DOT:\\n        jj_consume_token(DOT);\\n        t1 = jj_consume_token(IDENTIFIER);\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case LPAREN:\\n          Arguments();\\n          jj_consume_token(DOT);\\n          t2 = jj_consume_token(IDENTIFIER);\\n          break;\\n        default:\\n          jj_la1[55] = jj_gen;\\n          ;\\n        }\\n                                                                jjtree.closeNodeScope(jjtn000, true);\\n                                                                jjtc000 = false;\\n                                                                jjtreeCloseNodeScope(jjtn000);\\n        jjtn000.operation = BSHLHSPrimarySuffix.NAME;\\n        if ( t2 == null )\\n            jjtn000.field = t1.image;\\n        else {\\n            jjtn000.method = t1.image;\\n            jjtn000.field = t2.image;\\n        }\\n        break;\\n      case LBRACE:\\n        jj_consume_token(LBRACE);\\n        Expression();\\n        jj_consume_token(RBRACE);\\n                         jjtree.closeNodeScope(jjtn000, true);\\n                         jjtc000 = false;\\n                         jjtreeCloseNodeScope(jjtn000);\\n        jjtn000.operation = BSHLHSPrimarySuffix.PROPERTY;\\n        break;\\n      default:\\n        jj_la1[56] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void Literal() throws ParseException {\\n    BSHLiteral jjtn000 = new BSHLiteral(JJTLITERAL);\\n    boolean jjtc000 = true;\\n    jjtree.openNodeScope(jjtn000);\\n    jjtreeOpenNodeScope(jjtn000);Token x;\\n    boolean b;\\n    String literal;\\n    char ch;\\n    try {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case INTEGER_LITERAL:\\n        x = jj_consume_token(INTEGER_LITERAL);\\n    jjtree.closeNodeScope(jjtn000, true);\\n    jjtc000 = false;\\n    jjtreeCloseNodeScope(jjtn000);\\n    literal = x.image;\\n    ch = literal.charAt(literal.length()-1);\\n    if(ch == 'l' || ch == 'L')\\n    {\\n        literal = literal.substring(0,literal.length()-1);\\n                        jjtn000.value = new Primitive( new Long( literal ) );\\n    }\\n    else\\n        jjtn000.value = new Primitive( Integer.decode( literal ) );\\n        break;\\n      case FLOATING_POINT_LITERAL:\\n        x = jj_consume_token(FLOATING_POINT_LITERAL);\\n    jjtree.closeNodeScope(jjtn000, true);\\n    jjtc000 = false;\\n    jjtreeCloseNodeScope(jjtn000);\\n    literal = x.image;\\n    ch = literal.charAt(literal.length()-1);\\n    if(ch == 'f' || ch == 'F')\\n    {\\n        literal = literal.substring(0,literal.length()-1);\\n        jjtn000.value = new Primitive( new Float( literal ) );\\n    }\\n    else\\n    {\\n        if(ch == 'd' || ch == 'D')\\n            literal = literal.substring(0,literal.length()-1);\\n        jjtn000.value = new Primitive( new Double( literal ) );\\n    }\\n        break;\\n      case CHARACTER_LITERAL:\\n        x = jj_consume_token(CHARACTER_LITERAL);\\n                            jjtree.closeNodeScope(jjtn000, true);\\n                            jjtc000 = false;\\n                            jjtreeCloseNodeScope(jjtn000);\\n                try {\\n                jjtn000.charSetup( x.image.substring(1, x.image.length() - 1) );\\n                } catch ( Exception e ) {\\n                        {if (true) throw new ParseException(\\\"Error parsing character: \\\"+x.image);}\\n                }\\n        break;\\n      case STRING_LITERAL:\\n        x = jj_consume_token(STRING_LITERAL);\\n                         jjtree.closeNodeScope(jjtn000, true);\\n                         jjtc000 = false;\\n                         jjtreeCloseNodeScope(jjtn000);\\n                try {\\n                        jjtn000.stringSetup( x.image.substring(1, x.image.length() - 1) );\\n                } catch ( Exception e ) {\\n                        {if (true) throw new ParseException(\\\"Error parsing string: \\\"+x.image);}\\n                }\\n        break;\\n      case FALSE:\\n      case TRUE:\\n        b = BooleanLiteral();\\n                          jjtree.closeNodeScope(jjtn000, true);\\n                          jjtc000 = false;\\n                          jjtreeCloseNodeScope(jjtn000);\\n    jjtn000.value = new Primitive( new Boolean(b) );\\n        break;\\n      case NULL:\\n        NullLiteral();\\n                  jjtree.closeNodeScope(jjtn000, true);\\n                  jjtc000 = false;\\n                  jjtreeCloseNodeScope(jjtn000);\\n    jjtn000.value = Primitive.NULL;\\n        break;\\n      case VOID:\\n        VoidLiteral();\\n                 jjtree.closeNodeScope(jjtn000, true);\\n                 jjtc000 = false;\\n                 jjtreeCloseNodeScope(jjtn000);\\n    jjtn000.value = Primitive.VOID;\\n        break;\\n      default:\\n        jj_la1[57] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public boolean BooleanLiteral() throws ParseException {\\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n    case TRUE:\\n      jj_consume_token(TRUE);\\n           {if (true) return true;}\\n      break;\\n    case FALSE:\\n      jj_consume_token(FALSE);\\n            {if (true) return false;}\\n      break;\\n    default:\\n      jj_la1[58] = jj_gen;\\n      jj_consume_token(-1);\\n      throw new ParseException();\\n    }\\n    throw new Error(\\\"Missing return statement in function\\\");\\n  }\\n  final public void NullLiteral() throws ParseException {\\n    jj_consume_token(NULL);\\n  }\\n  final public void VoidLiteral() throws ParseException {\\n    jj_consume_token(VOID);\\n  }\\n  final public void Arguments() throws ParseException {\\n  BSHArguments jjtn000 = new BSHArguments(JJTARGUMENTS);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(LPAREN);\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FALSE:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case NEW:\\n      case NULL:\\n      case SHORT:\\n      case TRUE:\\n      case VOID:\\n      case INTEGER_LITERAL:\\n      case FLOATING_POINT_LITERAL:\\n      case CHARACTER_LITERAL:\\n      case STRING_LITERAL:\\n      case IDENTIFIER:\\n      case LPAREN:\\n      case BANG:\\n      case TILDE:\\n      case INCR:\\n      case DECR:\\n      case PLUS:\\n      case MINUS:\\n        ArgumentList();\\n        break;\\n      default:\\n        jj_la1[59] = jj_gen;\\n        ;\\n      }\\n      jj_consume_token(RPAREN);\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void ArgumentList() throws ParseException {\\n    Expression();\\n    label_17:\\n    while (true) {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case COMMA:\\n        ;\\n        break;\\n      default:\\n        jj_la1[60] = jj_gen;\\n        break label_17;\\n      }\\n      jj_consume_token(COMMA);\\n      Expression();\\n    }\\n  }\\n  final public void AllocationExpression() throws ParseException {\\n  BSHAllocationExpression jjtn000 = new BSHAllocationExpression(JJTALLOCATIONEXPRESSION);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      if (jj_2_19(2)) {\\n        jj_consume_token(NEW);\\n        PrimitiveType();\\n        ArrayDimensions();\\n      } else {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case NEW:\\n          jj_consume_token(NEW);\\n          AmbiguousName();\\n          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n          case LBRACKET:\\n            ArrayDimensions();\\n            break;\\n          case LPAREN:\\n            Arguments();\\n            if (jj_2_18(2)) {\\n              Block();\\n            } else {\\n              ;\\n            }\\n            break;\\n          default:\\n            jj_la1[61] = jj_gen;\\n            jj_consume_token(-1);\\n            throw new ParseException();\\n          }\\n          break;\\n        default:\\n          jj_la1[62] = jj_gen;\\n          jj_consume_token(-1);\\n          throw new ParseException();\\n        }\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void ArrayDimensions() throws ParseException {\\n  BSHArrayDimensions jjtn000 = new BSHArrayDimensions(JJTARRAYDIMENSIONS);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      if (jj_2_21(2)) {\\n        label_18:\\n        while (true) {\\n          jj_consume_token(LBRACKET);\\n          Expression();\\n          jj_consume_token(RBRACKET);\\n                                        jjtn000.addArrayDimension();\\n          if (jj_2_20(2)) {\\n            ;\\n          } else {\\n            break label_18;\\n          }\\n        }\\n      } else {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case LBRACKET:\\n          label_19:\\n          while (true) {\\n            jj_consume_token(LBRACKET);\\n            jj_consume_token(RBRACKET);\\n              jjtn000.addArrayDimension();\\n            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n            case LBRACKET:\\n              ;\\n              break;\\n            default:\\n              jj_la1[63] = jj_gen;\\n              break label_19;\\n            }\\n          }\\n          ArrayInitializer();\\n          break;\\n        default:\\n          jj_la1[64] = jj_gen;\\n          jj_consume_token(-1);\\n          throw new ParseException();\\n        }\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void Statement() throws ParseException {\\n    if (jj_2_22(2)) {\\n      LabeledStatement();\\n    } else {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case LBRACE:\\n        Block();\\n        break;\\n      case SEMICOLON:\\n        EmptyStatement();\\n        break;\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FALSE:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case NEW:\\n      case NULL:\\n      case SHORT:\\n      case TRUE:\\n      case VOID:\\n      case INTEGER_LITERAL:\\n      case FLOATING_POINT_LITERAL:\\n      case CHARACTER_LITERAL:\\n      case STRING_LITERAL:\\n      case IDENTIFIER:\\n      case LPAREN:\\n      case INCR:\\n      case DECR:\\n        StatementExpression();\\n        jj_consume_token(SEMICOLON);\\n        break;\\n      case SWITCH:\\n        SwitchStatement();\\n        break;\\n      case IF:\\n        IfStatement();\\n        break;\\n      case WHILE:\\n        WhileStatement();\\n        break;\\n      case DO:\\n        DoStatement();\\n        break;\\n      case FOR:\\n        ForStatement();\\n        break;\\n      case BREAK:\\n        BreakStatement();\\n        break;\\n      case CONTINUE:\\n        ContinueStatement();\\n        break;\\n      case RETURN:\\n        ReturnStatement();\\n        break;\\n      case THROW:\\n        ThrowStatement();\\n        break;\\n      case TRY:\\n        TryStatement();\\n        break;\\n      default:\\n        jj_la1[65] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n    }\\n  }\\n  final public void LabeledStatement() throws ParseException {\\n    jj_consume_token(IDENTIFIER);\\n    jj_consume_token(COLON);\\n    Statement();\\n  }\\n  final public void Block() throws ParseException {\\n  BSHBlock jjtn000 = new BSHBlock(JJTBLOCK);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(LBRACE);\\n      label_20:\\n      while (true) {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case BOOLEAN:\\n        case BREAK:\\n        case BYTE:\\n        case CHAR:\\n        case CONTINUE:\\n        case DO:\\n        case DOUBLE:\\n        case FALSE:\\n        case FINAL:\\n        case FLOAT:\\n        case FOR:\\n        case IF:\\n        case IMPORT:\\n        case INT:\\n        case LONG:\\n        case NEW:\\n        case NULL:\\n        case RETURN:\\n        case SHORT:\\n        case SWITCH:\\n        case THROW:\\n        case TRUE:\\n        case TRY:\\n        case VOID:\\n        case WHILE:\\n        case INTEGER_LITERAL:\\n        case FLOATING_POINT_LITERAL:\\n        case CHARACTER_LITERAL:\\n        case STRING_LITERAL:\\n        case FORMAL_COMMENT:\\n        case IDENTIFIER:\\n        case LPAREN:\\n        case LBRACE:\\n        case SEMICOLON:\\n        case INCR:\\n        case DECR:\\n          ;\\n          break;\\n        default:\\n          jj_la1[66] = jj_gen;\\n          break label_20;\\n        }\\n        BlockStatement();\\n      }\\n      jj_consume_token(RBRACE);\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void BlockStatement() throws ParseException {\\n    if (jj_2_23(2147483647)) {\\n      MethodDeclaration();\\n    } else if (jj_2_24(2147483647)) {\\n      TypedVariableDeclaration();\\n      jj_consume_token(SEMICOLON);\\n    } else {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n      case BREAK:\\n      case BYTE:\\n      case CHAR:\\n      case CONTINUE:\\n      case DO:\\n      case DOUBLE:\\n      case FALSE:\\n      case FLOAT:\\n      case FOR:\\n      case IF:\\n      case INT:\\n      case LONG:\\n      case NEW:\\n      case NULL:\\n      case RETURN:\\n      case SHORT:\\n      case SWITCH:\\n      case THROW:\\n      case TRUE:\\n      case TRY:\\n      case VOID:\\n      case WHILE:\\n      case INTEGER_LITERAL:\\n      case FLOATING_POINT_LITERAL:\\n      case CHARACTER_LITERAL:\\n      case STRING_LITERAL:\\n      case IDENTIFIER:\\n      case LPAREN:\\n      case LBRACE:\\n      case SEMICOLON:\\n      case INCR:\\n      case DECR:\\n        Statement();\\n        break;\\n      case IMPORT:\\n        ImportDeclaration();\\n        break;\\n      case FORMAL_COMMENT:\\n        FormalComment();\\n        break;\\n      default:\\n        jj_la1[67] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n    }\\n  }\\n  final public void FormalComment() throws ParseException {\\n        BSHFormalComment jjtn000 = new BSHFormalComment(JJTFORMALCOMMENT);\\n        boolean jjtc000 = true;\\n        jjtree.openNodeScope(jjtn000);\\n        jjtreeOpenNodeScope(jjtn000);Token t;\\n    try {\\n      t = jj_consume_token(FORMAL_COMMENT);\\n                              jjtree.closeNodeScope(jjtn000,  retainComments);\\n                              jjtc000 = false;\\n                              jjtreeCloseNodeScope(jjtn000);\\n                jjtn000.text=t.image;\\n    } finally {\\n          if (jjtc000) {\\n            jjtree.closeNodeScope(jjtn000,  retainComments);\\n            jjtreeCloseNodeScope(jjtn000);\\n          }\\n    }\\n  }\\n  final public void EmptyStatement() throws ParseException {\\n    jj_consume_token(SEMICOLON);\\n  }\\n  final public void StatementExpression() throws ParseException {\\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n    case INCR:\\n      PreIncrementExpression();\\n      break;\\n    case DECR:\\n      PreDecrementExpression();\\n      break;\\n    default:\\n      jj_la1[68] = jj_gen;\\n      if (jj_2_25(2147483647)) {\\n        Assignment();\\n      } else {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case BOOLEAN:\\n        case BYTE:\\n        case CHAR:\\n        case DOUBLE:\\n        case FALSE:\\n        case FLOAT:\\n        case INT:\\n        case LONG:\\n        case NEW:\\n        case NULL:\\n        case SHORT:\\n        case TRUE:\\n        case VOID:\\n        case INTEGER_LITERAL:\\n        case FLOATING_POINT_LITERAL:\\n        case CHARACTER_LITERAL:\\n        case STRING_LITERAL:\\n        case IDENTIFIER:\\n        case LPAREN:\\n          PostfixExpression();\\n          break;\\n        default:\\n          jj_la1[69] = jj_gen;\\n          jj_consume_token(-1);\\n          throw new ParseException();\\n        }\\n      }\\n    }\\n  }\\n  final public void SwitchStatement() throws ParseException {\\n  BSHSwitchStatement jjtn000 = new BSHSwitchStatement(JJTSWITCHSTATEMENT);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(SWITCH);\\n      jj_consume_token(LPAREN);\\n      Expression();\\n      jj_consume_token(RPAREN);\\n      jj_consume_token(LBRACE);\\n      label_21:\\n      while (true) {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case CASE:\\n        case _DEFAULT:\\n          ;\\n          break;\\n        default:\\n          jj_la1[70] = jj_gen;\\n          break label_21;\\n        }\\n        SwitchLabel();\\n        label_22:\\n        while (true) {\\n          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n          case BOOLEAN:\\n          case BREAK:\\n          case BYTE:\\n          case CHAR:\\n          case CONTINUE:\\n          case DO:\\n          case DOUBLE:\\n          case FALSE:\\n          case FINAL:\\n          case FLOAT:\\n          case FOR:\\n          case IF:\\n          case IMPORT:\\n          case INT:\\n          case LONG:\\n          case NEW:\\n          case NULL:\\n          case RETURN:\\n          case SHORT:\\n          case SWITCH:\\n          case THROW:\\n          case TRUE:\\n          case TRY:\\n          case VOID:\\n          case WHILE:\\n          case INTEGER_LITERAL:\\n          case FLOATING_POINT_LITERAL:\\n          case CHARACTER_LITERAL:\\n          case STRING_LITERAL:\\n          case FORMAL_COMMENT:\\n          case IDENTIFIER:\\n          case LPAREN:\\n          case LBRACE:\\n          case SEMICOLON:\\n          case INCR:\\n          case DECR:\\n            ;\\n            break;\\n          default:\\n            jj_la1[71] = jj_gen;\\n            break label_22;\\n          }\\n          BlockStatement();\\n        }\\n      }\\n      jj_consume_token(RBRACE);\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void SwitchLabel() throws ParseException {\\n  BSHSwitchLabel jjtn000 = new BSHSwitchLabel(JJTSWITCHLABEL);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case CASE:\\n        jj_consume_token(CASE);\\n        Expression();\\n        jj_consume_token(COLON);\\n        break;\\n      case _DEFAULT:\\n        jj_consume_token(_DEFAULT);\\n        jj_consume_token(COLON);\\n                  jjtree.closeNodeScope(jjtn000, true);\\n                  jjtc000 = false;\\n                  jjtreeCloseNodeScope(jjtn000);\\n                  jjtn000.isDefault = true;\\n        break;\\n      default:\\n        jj_la1[72] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void IfStatement() throws ParseException {\\n  BSHIfStatement jjtn000 = new BSHIfStatement(JJTIFSTATEMENT);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(IF);\\n      jj_consume_token(LPAREN);\\n      Expression();\\n      jj_consume_token(RPAREN);\\n      Statement();\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case ELSE:\\n        jj_consume_token(ELSE);\\n        Statement();\\n        break;\\n      default:\\n        jj_la1[73] = jj_gen;\\n        ;\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void WhileStatement() throws ParseException {\\n  BSHWhileStatement jjtn000 = new BSHWhileStatement(JJTWHILESTATEMENT);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(WHILE);\\n      jj_consume_token(LPAREN);\\n      Expression();\\n      jj_consume_token(RPAREN);\\n      Statement();\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void DoStatement() throws ParseException {\\n  BSHWhileStatement jjtn000 = new BSHWhileStatement(JJTWHILESTATEMENT);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(DO);\\n      Statement();\\n      jj_consume_token(WHILE);\\n      jj_consume_token(LPAREN);\\n      Expression();\\n      jj_consume_token(RPAREN);\\n      jj_consume_token(SEMICOLON);\\n          jjtree.closeNodeScope(jjtn000, true);\\n          jjtc000 = false;\\n          jjtreeCloseNodeScope(jjtn000);\\n          jjtn000.isDoStatement=true;\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void ForStatement() throws ParseException {\\n  BSHForStatement jjtn000 = new BSHForStatement(JJTFORSTATEMENT);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(FOR);\\n      jj_consume_token(LPAREN);\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FALSE:\\n      case FINAL:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case NEW:\\n      case NULL:\\n      case SHORT:\\n      case TRUE:\\n      case VOID:\\n      case INTEGER_LITERAL:\\n      case FLOATING_POINT_LITERAL:\\n      case CHARACTER_LITERAL:\\n      case STRING_LITERAL:\\n      case IDENTIFIER:\\n      case LPAREN:\\n      case INCR:\\n      case DECR:\\n        ForInit();\\n                          jjtn000.hasForInit=true;\\n        break;\\n      default:\\n        jj_la1[74] = jj_gen;\\n        ;\\n      }\\n      jj_consume_token(SEMICOLON);\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FALSE:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case NEW:\\n      case NULL:\\n      case SHORT:\\n      case TRUE:\\n      case VOID:\\n      case INTEGER_LITERAL:\\n      case FLOATING_POINT_LITERAL:\\n      case CHARACTER_LITERAL:\\n      case STRING_LITERAL:\\n      case IDENTIFIER:\\n      case LPAREN:\\n      case BANG:\\n      case TILDE:\\n      case INCR:\\n      case DECR:\\n      case PLUS:\\n      case MINUS:\\n        Expression();\\n                         jjtn000.hasExpression=true;\\n        break;\\n      default:\\n        jj_la1[75] = jj_gen;\\n        ;\\n      }\\n      jj_consume_token(SEMICOLON);\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FALSE:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case NEW:\\n      case NULL:\\n      case SHORT:\\n      case TRUE:\\n      case VOID:\\n      case INTEGER_LITERAL:\\n      case FLOATING_POINT_LITERAL:\\n      case CHARACTER_LITERAL:\\n      case STRING_LITERAL:\\n      case IDENTIFIER:\\n      case LPAREN:\\n      case INCR:\\n      case DECR:\\n        ForUpdate();\\n                        jjtn000.hasForUpdate=true;\\n        break;\\n      default:\\n        jj_la1[76] = jj_gen;\\n        ;\\n      }\\n      jj_consume_token(RPAREN);\\n      Statement();\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void ForInit() throws ParseException {\\n  Token t = null;\\n    if (jj_2_26(2147483647)) {\\n      TypedVariableDeclaration();\\n    } else {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FALSE:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case NEW:\\n      case NULL:\\n      case SHORT:\\n      case TRUE:\\n      case VOID:\\n      case INTEGER_LITERAL:\\n      case FLOATING_POINT_LITERAL:\\n      case CHARACTER_LITERAL:\\n      case STRING_LITERAL:\\n      case IDENTIFIER:\\n      case LPAREN:\\n      case INCR:\\n      case DECR:\\n        StatementExpressionList();\\n        break;\\n      default:\\n        jj_la1[77] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n    }\\n  }\\n  final public void TypedVariableDeclaration() throws ParseException {\\n        BSHTypedVariableDeclaration jjtn000 = new BSHTypedVariableDeclaration(JJTTYPEDVARIABLEDECLARATION);\\n        boolean jjtc000 = true;\\n        jjtree.openNodeScope(jjtn000);\\n        jjtreeOpenNodeScope(jjtn000);Token t = null;\\n    try {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case FINAL:\\n        t = jj_consume_token(FINAL);\\n        break;\\n      default:\\n        jj_la1[78] = jj_gen;\\n        ;\\n      }\\n      Type();\\n      VariableDeclarator();\\n      label_23:\\n      while (true) {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case COMMA:\\n          ;\\n          break;\\n        default:\\n          jj_la1[79] = jj_gen;\\n          break label_23;\\n        }\\n        jj_consume_token(COMMA);\\n        VariableDeclarator();\\n      }\\n          jjtree.closeNodeScope(jjtn000, true);\\n          jjtc000 = false;\\n          jjtreeCloseNodeScope(jjtn000);\\n        jjtn000.isFinal = (t!=null);\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void StatementExpressionList() throws ParseException {\\n  BSHStatementExpressionList jjtn000 = new BSHStatementExpressionList(JJTSTATEMENTEXPRESSIONLIST);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      StatementExpression();\\n      label_24:\\n      while (true) {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case COMMA:\\n          ;\\n          break;\\n        default:\\n          jj_la1[80] = jj_gen;\\n          break label_24;\\n        }\\n        jj_consume_token(COMMA);\\n        StatementExpression();\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void ForUpdate() throws ParseException {\\n    StatementExpressionList();\\n  }\\n  final public void BreakStatement() throws ParseException {\\n  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(BREAK);\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case IDENTIFIER:\\n        jj_consume_token(IDENTIFIER);\\n        break;\\n      default:\\n        jj_la1[81] = jj_gen;\\n        ;\\n      }\\n      jj_consume_token(SEMICOLON);\\n                                 jjtree.closeNodeScope(jjtn000, true);\\n                                 jjtc000 = false;\\n                                 jjtreeCloseNodeScope(jjtn000);\\n                                 jjtn000.kind = BREAK;\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void ContinueStatement() throws ParseException {\\n  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(CONTINUE);\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case IDENTIFIER:\\n        jj_consume_token(IDENTIFIER);\\n        break;\\n      default:\\n        jj_la1[82] = jj_gen;\\n        ;\\n      }\\n      jj_consume_token(SEMICOLON);\\n                                    jjtree.closeNodeScope(jjtn000, true);\\n                                    jjtc000 = false;\\n                                    jjtreeCloseNodeScope(jjtn000);\\n                                    jjtn000.kind = CONTINUE;\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void ReturnStatement() throws ParseException {\\n  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(RETURN);\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FALSE:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case NEW:\\n      case NULL:\\n      case SHORT:\\n      case TRUE:\\n      case VOID:\\n      case INTEGER_LITERAL:\\n      case FLOATING_POINT_LITERAL:\\n      case CHARACTER_LITERAL:\\n      case STRING_LITERAL:\\n      case IDENTIFIER:\\n      case LPAREN:\\n      case BANG:\\n      case TILDE:\\n      case INCR:\\n      case DECR:\\n      case PLUS:\\n      case MINUS:\\n        Expression();\\n        break;\\n      default:\\n        jj_la1[83] = jj_gen;\\n        ;\\n      }\\n      jj_consume_token(SEMICOLON);\\n                                  jjtree.closeNodeScope(jjtn000, true);\\n                                  jjtc000 = false;\\n                                  jjtreeCloseNodeScope(jjtn000);\\n                                  jjtn000.kind = RETURN;\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void ThrowStatement() throws ParseException {\\n  BSHThrowStatement jjtn000 = new BSHThrowStatement(JJTTHROWSTATEMENT);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(THROW);\\n      Expression();\\n      jj_consume_token(SEMICOLON);\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void TryStatement() throws ParseException {\\n  BSHTryStatement jjtn000 = new BSHTryStatement(JJTTRYSTATEMENT);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);boolean closed = false;\\n    try {\\n      jj_consume_token(TRY);\\n      Block();\\n      label_25:\\n      while (true) {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case CATCH:\\n          ;\\n          break;\\n        default:\\n          jj_la1[84] = jj_gen;\\n          break label_25;\\n        }\\n        jj_consume_token(CATCH);\\n        jj_consume_token(LPAREN);\\n        FormalParameter();\\n        jj_consume_token(RPAREN);\\n        Block();\\n                                                      closed = true;\\n      }\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case FINALLY:\\n        jj_consume_token(FINALLY);\\n        Block();\\n                              closed = true;\\n        break;\\n      default:\\n        jj_la1[85] = jj_gen;\\n        ;\\n      }\\n          jjtree.closeNodeScope(jjtn000, true);\\n          jjtc000 = false;\\n          jjtreeCloseNodeScope(jjtn000);\\n                if ( !closed ) {if (true) throw generateParseException();}\\n    } catch (Throwable jjte000) {\\n          if (jjtc000) {\\n            jjtree.clearNodeScope(jjtn000);\\n            jjtc000 = false;\\n          } else {\\n            jjtree.popNode();\\n          }\\n          if (jjte000 instanceof RuntimeException) {\\n            {if (true) throw (RuntimeException)jjte000;}\\n          }\\n          if (jjte000 instanceof ParseException) {\\n            {if (true) throw (ParseException)jjte000;}\\n          }\\n          {if (true) throw (Error)jjte000;}\\n    } finally {\\n          if (jjtc000) {\\n            jjtree.closeNodeScope(jjtn000, true);\\n            jjtreeCloseNodeScope(jjtn000);\\n          }\\n    }\\n  }\\n  final private boolean jj_2_1(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_1();\\n    jj_save(0, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_2(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_2();\\n    jj_save(1, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_3(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_3();\\n    jj_save(2, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_4(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_4();\\n    jj_save(3, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_5(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_5();\\n    jj_save(4, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_6(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_6();\\n    jj_save(5, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_7(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_7();\\n    jj_save(6, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_8(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_8();\\n    jj_save(7, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_9(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_9();\\n    jj_save(8, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_10(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_10();\\n    jj_save(9, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_11(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_11();\\n    jj_save(10, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_12(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_12();\\n    jj_save(11, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_13(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_13();\\n    jj_save(12, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_14(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_14();\\n    jj_save(13, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_15(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_15();\\n    jj_save(14, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_16(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_16();\\n    jj_save(15, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_17(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_17();\\n    jj_save(16, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_18(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_18();\\n    jj_save(17, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_19(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_19();\\n    jj_save(18, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_20(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_20();\\n    jj_save(19, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_21(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_21();\\n    jj_save(20, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_22(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_22();\\n    jj_save(21, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_23(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_23();\\n    jj_save(22, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_24(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_24();\\n    jj_save(23, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_25(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_25();\\n    jj_save(24, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_26(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_26();\\n    jj_save(25, xla);\\n    return retval;\\n  }\\n  final private boolean jj_3R_196() {\\n    if (jj_3R_84()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_11() {\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_34()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_33() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3_11()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_68()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_69()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_280() {\\n    if (jj_scan_token(BANG)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_195() {\\n    if (jj_3R_202()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_194() {\\n    if (jj_3R_201()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_178() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_194()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_195()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_196()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_197()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_275() {\\n    if (jj_3R_203()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_260() {\\n    if (jj_scan_token(MOD)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_274() {\\n    if (jj_3R_281()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_279() {\\n    if (jj_scan_token(TILDE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_273() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_279()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_280()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_240()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_267() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_273()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_274()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_275()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_259() {\\n    if (jj_scan_token(SLASH)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_177() {\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_235() {\\n    if (jj_scan_token(RSIGNEDSHIFTX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_138() {\\n    if (jj_scan_token(FORMAL_COMMENT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_202() {\\n    if (jj_scan_token(DECR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_31()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_258() {\\n    if (jj_scan_token(STAR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_241() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_258()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_259()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_260()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_240()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_201() {\\n    if (jj_scan_token(INCR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_31()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_234() {\\n    if (jj_scan_token(RSIGNEDSHIFT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_266() {\\n    if (jj_scan_token(MINUS)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_41() {\\n    if (jj_scan_token(FINAL)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_117() {\\n    if (jj_3R_138()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_257() {\\n    if (jj_3R_267()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_227() {\\n    if (jj_scan_token(GEX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_24() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_41()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_30()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_116() {\\n    if (jj_3R_137()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_256() {\\n    if (jj_3R_202()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_23() {\\n    if (jj_3R_40()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_255() {\\n    if (jj_3R_201()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_265() {\\n    if (jj_scan_token(PLUS)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_223() {\\n    if (jj_scan_token(GTX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_254() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_265()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_266()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_240()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_240() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_254()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_255()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_256()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_257()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_115() {\\n    if (jj_3R_136()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_243() {\\n    if (jj_scan_token(MINUS)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_114() {\\n    if (jj_3R_135()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_226() {\\n    if (jj_scan_token(GE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_97() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_113()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_114()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_115()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_116()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_117()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_113() {\\n    if (jj_3R_134()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_237() {\\n    if (jj_scan_token(RUNSIGNEDSHIFTX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_230() {\\n    if (jj_3R_240()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_241()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_222() {\\n    if (jj_scan_token(GT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_79() {\\n    if (jj_3R_97()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_233() {\\n    if (jj_scan_token(LSHIFTX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_242() {\\n    if (jj_scan_token(PLUS)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_231() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_242()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_243()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_230()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_215() {\\n    if (jj_scan_token(NE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_38() {\\n    if (jj_scan_token(LBRACE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_79()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    if (jj_scan_token(RBRACE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_218() {\\n    if (jj_3R_230()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_231()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_225() {\\n    if (jj_scan_token(LEX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_236() {\\n    if (jj_scan_token(RUNSIGNEDSHIFT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_232() {\\n    if (jj_scan_token(LSHIFT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_221() {\\n    if (jj_scan_token(LTX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_39() {\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(COLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_136()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_219() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_232()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_233()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_234()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_235()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_236()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_237()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_218()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_214() {\\n    if (jj_scan_token(EQ)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_216() {\\n    if (jj_3R_218()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_219()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_207() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_214()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_215()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_206()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_165() {\\n    if (jj_3R_188()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_164() {\\n    if (jj_3R_187()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_224() {\\n    if (jj_scan_token(LE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_220() {\\n    if (jj_scan_token(LT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_163() {\\n    if (jj_3R_186()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_217() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_220()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_221()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_222()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_223()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_224()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_225()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_226()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_227()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_216()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_162() {\\n    if (jj_3R_185()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_161() {\\n    if (jj_3R_184()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_212() {\\n    if (jj_3R_216()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_217()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_160() {\\n    if (jj_3R_183()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_159() {\\n    if (jj_3R_182()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_213() {\\n    if (jj_scan_token(INSTANCEOF)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_30()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_158() {\\n    if (jj_3R_181()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_206() {\\n    if (jj_3R_212()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_213()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_157() {\\n    if (jj_3R_180()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_209() {\\n    if (jj_scan_token(BIT_ANDX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_156() {\\n    if (jj_3R_179()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_155() {\\n    if (jj_3R_178()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_18() {\\n    if (jj_3R_38()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_191() {\\n    if (jj_scan_token(XOR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_190()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_154() {\\n    if (jj_3R_177()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_199() {\\n    if (jj_3R_206()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_207()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_153() {\\n    if (jj_3R_38()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_61() {\\n    if (jj_scan_token(ORASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_22() {\\n    if (jj_3R_39()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_136() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3_22()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_153()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_154()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_155()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_156()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_157()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_158()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_159()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_160()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_161()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_162()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_163()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_164()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_165()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_208() {\\n    if (jj_scan_token(BIT_AND)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_200() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_208()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_209()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_199()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_190() {\\n    if (jj_3R_199()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_200()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_60() {\\n    if (jj_scan_token(XORASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_193() {\\n    if (jj_scan_token(BIT_ORX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_170() {\\n    if (jj_3R_78()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3_18()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_198() {\\n    if (jj_scan_token(LBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_189() {\\n    Token xsp;\\n    if (jj_3R_198()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_198()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    if (jj_3R_88()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_169() {\\n    if (jj_3R_168()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_20() {\\n    if (jj_scan_token(LBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_171() {\\n    if (jj_3R_190()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_191()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_59() {\\n    if (jj_scan_token(ANDASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_168() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3_21()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_189()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_65() {\\n    if (jj_scan_token(RSIGNEDSHIFTASSIGNX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_21() {\\n    Token xsp;\\n    if (jj_3_20()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3_20()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_174() {\\n    if (jj_scan_token(BOOL_ANDX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_192() {\\n    if (jj_scan_token(BIT_OR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_107() {\\n    if (jj_scan_token(HOOK)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(COLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_85()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_172() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_192()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_193()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_171()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_58() {\\n    if (jj_scan_token(MINUSASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_143() {\\n    if (jj_3R_171()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_172()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_64() {\\n    if (jj_scan_token(RSIGNEDSHIFTASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_146() {\\n    if (jj_scan_token(BOOL_ORX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_173() {\\n    if (jj_scan_token(BOOL_AND)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_141() {\\n    if (jj_scan_token(NEW)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_28()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_169()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_170()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_57() {\\n    if (jj_scan_token(PLUSASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_144() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_173()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_174()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_143()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_19() {\\n    if (jj_scan_token(NEW)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_34()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_168()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_119() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3_19()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_141()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_123() {\\n    if (jj_3R_143()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_144()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_133() {\\n    if (jj_scan_token(COMMA)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_56() {\\n    if (jj_scan_token(MODASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_145() {\\n    if (jj_scan_token(BOOL_OR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_112() {\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_133()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_124() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_145()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_146()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_123()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_96() {\\n    if (jj_3R_112()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_106() {\\n    if (jj_3R_123()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_124()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_55() {\\n    if (jj_scan_token(SLASHASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_67() {\\n    if (jj_scan_token(RUNSIGNEDSHIFTASSIGNX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_78() {\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_96()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_63() {\\n    if (jj_scan_token(LSHIFTASSIGNX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_85() {\\n    if (jj_3R_106()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_107()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_54() {\\n    if (jj_scan_token(STARASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_149() {\\n    if (jj_scan_token(VOID)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_66() {\\n    if (jj_scan_token(RUNSIGNEDSHIFTASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_62() {\\n    if (jj_scan_token(LSHIFTASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_53() {\\n    if (jj_scan_token(ASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_148() {\\n    if (jj_scan_token(NULL)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_32() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_53()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_54()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_55()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_56()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_57()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_58()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_59()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_60()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_61()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_62()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_63()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_64()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_65()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_66()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_67()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_176() {\\n    if (jj_scan_token(FALSE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_175() {\\n    if (jj_scan_token(TRUE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_147() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_175()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_176()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_9() {\\n    if (jj_3R_31()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_32()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_84() {\\n    if (jj_3R_31()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_32()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_132() {\\n    if (jj_3R_149()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_45() {\\n    if (jj_3R_85()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_131() {\\n    if (jj_3R_148()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_44() {\\n    if (jj_3R_84()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_26() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_44()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_45()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_130() {\\n    if (jj_3R_147()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_129() {\\n    if (jj_scan_token(STRING_LITERAL)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_8() {\\n    if (jj_scan_token(DOT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_128() {\\n    if (jj_scan_token(CHARACTER_LITERAL)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_28() {\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3_8()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_205() {\\n    if (jj_scan_token(COMMA)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_77() {\\n    if (jj_scan_token(DOUBLE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_127() {\\n    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_76() {\\n    if (jj_scan_token(FLOAT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_75() {\\n    if (jj_scan_token(LONG)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_74() {\\n    if (jj_scan_token(INT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_50() {\\n    if (jj_3R_28()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_73() {\\n    if (jj_scan_token(SHORT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_72() {\\n    if (jj_scan_token(BYTE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_71() {\\n    if (jj_scan_token(CHAR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_70() {\\n    if (jj_scan_token(BOOLEAN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_34() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_70()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_71()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_72()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_73()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_74()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_75()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_76()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_77()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_87() {\\n    if (jj_3R_30()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_46() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_86()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_87()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_86() {\\n    if (jj_scan_token(VOID)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_7() {\\n    if (jj_scan_token(LBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_111() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_126()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_127()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_128()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_129()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_130()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_131()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_132()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_126() {\\n    if (jj_scan_token(INTEGER_LITERAL)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_125() {\\n    if (jj_3R_78()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(DOT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_49() {\\n    if (jj_3R_34()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_30() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_49()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_50()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3_7()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_140() {\\n    if (jj_scan_token(COMMA)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_139()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_110() {\\n    if (jj_scan_token(LBRACE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RBRACE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_167() {\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_253() {\\n    if (jj_scan_token(FINALLY)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_38()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_6() {\\n    if (jj_3R_30()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_52() {\\n    if (jj_3R_89()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_252() {\\n    if (jj_scan_token(CATCH)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_139()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_38()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_139() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3_6()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_167()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_109() {\\n    if (jj_scan_token(DOT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_125()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_188() {\\n    if (jj_scan_token(TRY)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_38()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_252()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    xsp = jj_scanpos;\\n    if (jj_3R_253()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_5() {\\n    if (jj_scan_token(COMMA)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_29()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_118() {\\n    if (jj_3R_139()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_140()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_108() {\\n    if (jj_scan_token(LBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_89() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_108()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_109()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_110()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_251() {\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_98() {\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_118()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_204() {\\n    if (jj_3R_29()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3_5()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_250() {\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_187() {\\n    if (jj_scan_token(THROW)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_31() {\\n    if (jj_3R_51()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_52()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_229() {\\n    if (jj_scan_token(COMMA)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_228()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_88() {\\n    if (jj_scan_token(LBRACE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_204()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    xsp = jj_scanpos;\\n    if (jj_3R_205()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RBRACE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_278() {\\n    if (jj_scan_token(COMMA)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_178()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_186() {\\n    if (jj_scan_token(RETURN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_251()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_51() {\\n    if (jj_3R_28()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_249() {\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_48() {\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_47() {\\n    if (jj_3R_88()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_29() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_47()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_48()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_238() {\\n    if (jj_scan_token(ASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_29()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_185() {\\n    if (jj_scan_token(CONTINUE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_250()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_239() {\\n    if (jj_scan_token(DOT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(STAR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_184() {\\n    if (jj_scan_token(BREAK)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_249()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_142() {\\n    if (jj_3R_78()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_95() {\\n    if (jj_3R_111()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_264() {\\n    if (jj_3R_272()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_228() {\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_238()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_272() {\\n    if (jj_3R_178()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_278()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_94() {\\n    if (jj_scan_token(NEW)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_166() {\\n    if (jj_scan_token(IMPORT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(STAR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_152() {\\n    if (jj_scan_token(FINAL)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_122() {\\n    if (jj_scan_token(LBRACE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RBRACE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_135() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_152()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_30()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_228()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_229()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_121() {\\n    if (jj_scan_token(DOT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_142()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_43() {\\n    if (jj_scan_token(FINAL)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_4() {\\n    if (jj_scan_token(IMPORT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_28()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_239()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_137() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3_4()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_166()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_26() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_43()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_30()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_3() {\\n    if (jj_3R_27()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_120() {\\n    if (jj_scan_token(LBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_245() {\\n    if (jj_scan_token(ELSE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_136()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_27() {\\n    if (jj_3R_46()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_271() {\\n    if (jj_3R_272()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_17() {\\n    if (jj_scan_token(DOT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(CLASS)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_105() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3_17()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_120()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_121()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_122()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_246() {\\n    if (jj_3R_263()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_81() {\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_98()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(LBRACE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_270() {\\n    if (jj_3R_135()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_263() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_270()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_271()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_248() {\\n    if (jj_3R_264()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_247() {\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_16() {\\n    if (jj_3R_30()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(DOT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(CLASS)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_40() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_80()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_81()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_80() {\\n    if (jj_3R_46()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_98()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(LBRACE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_2() {\\n    if (jj_3R_27()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_15() {\\n    if (jj_3R_37()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_183() {\\n    if (jj_scan_token(FOR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_246()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    xsp = jj_scanpos;\\n    if (jj_3R_247()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    xsp = jj_scanpos;\\n    if (jj_3R_248()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_136()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_151() {\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_98()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_38()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_104() {\\n    if (jj_3R_28()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_36() {\\n    if (jj_scan_token(DECR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_103() {\\n    if (jj_3R_30()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_150() {\\n    if (jj_3R_46()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_98()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_38()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_83() {\\n    if (jj_3R_105()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_93() {\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_134() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_150()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_151()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_35() {\\n    if (jj_scan_token(INCR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_102() {\\n    if (jj_3R_37()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_182() {\\n    if (jj_scan_token(DO)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_136()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(WHILE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_101() {\\n    if (jj_3R_119()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_92() {\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_100() {\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_82() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_99()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_100()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_101()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_102()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_103()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_104()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_99() {\\n    if (jj_3R_111()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_1() {\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_37() {\\n    if (jj_3R_28()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_78()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_91() {\\n    if (jj_scan_token(BANG)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_181() {\\n    if (jj_scan_token(WHILE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_136()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_14() {\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_34()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_277() {\\n    if (jj_scan_token(DECR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_42() {\\n    if (jj_3R_82()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_83()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_90() {\\n    if (jj_scan_token(TILDE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_262() {\\n    if (jj_3R_97()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_180() {\\n    if (jj_scan_token(IF)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_136()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_245()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_283() {\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_30()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_267()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_282() {\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_30()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_240()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_276() {\\n    if (jj_scan_token(INCR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_281() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_282()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_283()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_13() {\\n    if (jj_3R_31()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_35()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_36()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_269() {\\n    if (jj_scan_token(_DEFAULT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(COLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_268() {\\n    if (jj_scan_token(CASE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(COLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_261() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_268()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_269()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_211() {\\n    if (jj_3R_42()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_244() {\\n    if (jj_3R_261()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_262()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3_12() {\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_28()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(LBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_210() {\\n    if (jj_3R_31()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_276()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_277()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_203() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_210()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_211()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_25() {\\n    if (jj_3R_42()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_32()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_179() {\\n    if (jj_scan_token(SWITCH)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(LBRACE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_244()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    if (jj_scan_token(RBRACE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_69() {\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_28()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_90()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_91()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_92()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_93()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_94()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_95()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_197() {\\n    if (jj_3R_203()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_68() {\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_28()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(LBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_10() {\\n    if (jj_3R_33()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  public ParserTokenManager token_source;\\n  ASCII_UCodeESC_CharStream jj_input_stream;\\n  public Token token, jj_nt;\\n  private int jj_ntk;\\n  private Token jj_scanpos, jj_lastpos;\\n  private int jj_la;\\n  public boolean lookingAhead = false;\\n  private boolean jj_semLA;\\n  private int jj_gen;\\n  final private int[] jj_la1 = new int[86];\\n  final private int[] jj_la1_0 = {0x6db52c00,0x6db52c01,0x0,0x0,0x0,0x40000000,0x0,0x4a12400,0x4a12400,0x0,0x0,0x4212400,0x0,0x4212400,0x4212400,0x4212400,0x4a12400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4a12400,0x0,0x0,0x4a12400,0x800000,0x0,0x0,0x4a12400,0x0,0x0,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x800000,0x4a12400,0x0,0x0,0x0,0x0,0x0,0x2cb52c00,0x6db52c00,0x6cb52c00,0x0,0x4a12400,0x84000,0x6db52c00,0x84000,0x400000,0x5a12400,0x4a12400,0x4a12400,0x4a12400,0x1000000,0x0,0x0,0x0,0x0,0x4a12400,0x8000,0x2000000,};\\n  final private int[] jj_la1_1 = {0xa7a3fb1d,0xa7a3fb1d,0x4000000,0x4000000,0x0,0x0,0x0,0xa5a2a21d,0xa5a2a21d,0x0,0x0,0x4000205,0x4000000,0x4000205,0x4008205,0x205,0x25a2a21d,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x25a2a21d,0x0,0x0,0x25a2a21d,0x25a2a018,0x20000000,0x0,0x25a2a21d,0x20000000,0x80000000,0x21a2a018,0x4000000,0x20000000,0x80000000,0x80000000,0x20000000,0x80000000,0x1a2a010,0x2000,0x25a2a21d,0x0,0x20000000,0x8,0x0,0x0,0xa5a3fb1d,0xa7a3fb1d,0xa7a3fb1d,0x0,0x25a2a21d,0x0,0xa7a3fb1d,0x0,0x0,0x25a2a21d,0x25a2a21d,0x25a2a21d,0x25a2a21d,0x0,0x0,0x0,0x4000000,0x4000000,0x25a2a21d,0x0,0x0,};\\n  final private int[] jj_la1_2 = {0x6000008,0x1e001808,0x0,0x0,0x20,0x0,0x40,0x1e001800,0x1e001800,0x10,0x10,0x0,0x0,0x0,0x0,0x0,0x1e001800,0x40,0x2000,0x600000,0x600000,0x1800000,0x1800000,0x0,0x0,0x0,0x80000000,0x80000000,0x108000,0x108000,0x0,0xf0780,0xf0780,0x0,0x0,0x18000000,0x18000000,0x60000000,0x60000000,0x18000000,0x1e001800,0x1800,0x1800,0x0,0x1800,0x0,0x6000000,0x0,0x0,0x22,0x0,0x0,0x0,0x22,0x22,0x0,0x22,0x0,0x0,0x1e001800,0x10,0x2,0x0,0x2,0x2,0x6000008,0x6000008,0x6000008,0x6000000,0x0,0x0,0x6000008,0x0,0x0,0x6000000,0x1e001800,0x6000000,0x6000000,0x0,0x10,0x10,0x0,0x0,0x1e001800,0x0,0x0,};\\n  final private int[] jj_la1_3 = {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7faf800,0x0,0x0,0x0,0x0,0x0,0x6,0x6,0x8,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x7e0,0x7e0,0x0,0x0,0x10,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};\\n  final private JJCalls[] jj_2_rtns = new JJCalls[26];\\n  private boolean jj_rescan = false;\\n  private int jj_gc = 0;\\n  public Parser(java.io.InputStream stream) {\\n    jj_input_stream = new ASCII_UCodeESC_CharStream(stream, 1, 1);\\n    token_source = new ParserTokenManager(jj_input_stream);\\n    token = new Token();\\n    jj_ntk = -1;\\n    jj_gen = 0;\\n    for (int i = 0; i < 86; i++) jj_la1[i] = -1;\\n    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\\n  }\\n  public void ReInit(java.io.InputStream stream) {\\n    jj_input_stream.ReInit(stream, 1, 1);\\n    token_source.ReInit(jj_input_stream);\\n    token = new Token();\\n    jj_ntk = -1;\\n    jjtree.reset();\\n    jj_gen = 0;\\n    for (int i = 0; i < 86; i++) jj_la1[i] = -1;\\n    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\\n  }\\n  public Parser(java.io.Reader stream) {\\n    jj_input_stream = new ASCII_UCodeESC_CharStream(stream, 1, 1);\\n    token_source = new ParserTokenManager(jj_input_stream);\\n    token = new Token();\\n    jj_ntk = -1;\\n    jj_gen = 0;\\n    for (int i = 0; i < 86; i++) jj_la1[i] = -1;\\n    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\\n  }\\n  public void ReInit(java.io.Reader stream) {\\n    jj_input_stream.ReInit(stream, 1, 1);\\n    token_source.ReInit(jj_input_stream);\\n    token = new Token();\\n    jj_ntk = -1;\\n    jjtree.reset();\\n    jj_gen = 0;\\n    for (int i = 0; i < 86; i++) jj_la1[i] = -1;\\n    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\\n  }\\n  public Parser(ParserTokenManager tm) {\\n    token_source = tm;\\n    token = new Token();\\n    jj_ntk = -1;\\n    jj_gen = 0;\\n    for (int i = 0; i < 86; i++) jj_la1[i] = -1;\\n    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\\n  }\\n  public void ReInit(ParserTokenManager tm) {\\n    token_source = tm;\\n    token = new Token();\\n    jj_ntk = -1;\\n    jjtree.reset();\\n    jj_gen = 0;\\n    for (int i = 0; i < 86; i++) jj_la1[i] = -1;\\n    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\\n  }\\n  final private Token jj_consume_token(int kind) throws ParseException {\\n    Token oldToken;\\n    if ((oldToken = token).next != null) token = token.next;\\n    else token = token.next = token_source.getNextToken();\\n    jj_ntk = -1;\\n    if (token.kind == kind) {\\n      jj_gen++;\\n      if (++jj_gc > 100) {\\n        jj_gc = 0;\\n        for (int i = 0; i < jj_2_rtns.length; i++) {\\n          JJCalls c = jj_2_rtns[i];\\n          while (c != null) {\\n            if (c.gen < jj_gen) c.first = null;\\n            c = c.next;\\n          }\\n        }\\n      }\\n      return token;\\n    }\\n    token = oldToken;\\n    jj_kind = kind;\\n    throw generateParseException();\\n  }\\n  final private boolean jj_scan_token(int kind) {\\n    if (jj_scanpos == jj_lastpos) {\\n      jj_la--;\\n      if (jj_scanpos.next == null) {\\n        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();\\n      } else {\\n        jj_lastpos = jj_scanpos = jj_scanpos.next;\\n      }\\n    } else {\\n      jj_scanpos = jj_scanpos.next;\\n    }\\n    if (jj_rescan) {\\n      int i = 0; Token tok = token;\\n      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }\\n      if (tok != null) jj_add_error_token(kind, i);\\n    }\\n    return (jj_scanpos.kind != kind);\\n  }\\n  final public Token getNextToken() {\\n    if (token.next != null) token = token.next;\\n    else token = token.next = token_source.getNextToken();\\n    jj_ntk = -1;\\n    jj_gen++;\\n    return token;\\n  }\\n  final public Token getToken(int index) {\\n    Token t = lookingAhead ? jj_scanpos : token;\\n    for (int i = 0; i < index; i++) {\\n      if (t.next != null) t = t.next;\\n      else t = t.next = token_source.getNextToken();\\n    }\\n    return t;\\n  }\\n  final private int jj_ntk() {\\n    if ((jj_nt=token.next) == null)\\n      return (jj_ntk = (token.next=token_source.getNextToken()).kind);\\n    else\\n      return (jj_ntk = jj_nt.kind);\\n  }\\n  private java.util.Vector jj_expentries = new java.util.Vector();\\n  private int[] jj_expentry;\\n  private int jj_kind = -1;\\n  private int[] jj_lasttokens = new int[100];\\n  private int jj_endpos;\\n  private void jj_add_error_token(int kind, int pos) {\\n    if (pos >= 100) return;\\n    if (pos == jj_endpos + 1) {\\n      jj_lasttokens[jj_endpos++] = kind;\\n    } else if (jj_endpos != 0) {\\n      jj_expentry = new int[jj_endpos];\\n      for (int i = 0; i < jj_endpos; i++) {\\n        jj_expentry[i] = jj_lasttokens[i];\\n      }\\n      boolean exists = false;\\n      for (java.util.Enumeration enum = jj_expentries.elements(); enum.hasMoreElements();) {\\n        int[] oldentry = (int[])(enum.nextElement());\\n        if (oldentry.length == jj_expentry.length) {\\n          exists = true;\\n          for (int i = 0; i < jj_expentry.length; i++) {\\n            if (oldentry[i] != jj_expentry[i]) {\\n              exists = false;\\n              break;\\n            }\\n          }\\n          if (exists) break;\\n        }\\n      }\\n      if (!exists) jj_expentries.addElement(jj_expentry);\\n      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;\\n    }\\n  }\\n  final public ParseException generateParseException() {\\n    jj_expentries.removeAllElements();\\n    boolean[] la1tokens = new boolean[123];\\n    for (int i = 0; i < 123; i++) {\\n      la1tokens[i] = false;\\n    }\\n    if (jj_kind >= 0) {\\n      la1tokens[jj_kind] = true;\\n      jj_kind = -1;\\n    }\\n    for (int i = 0; i < 86; i++) {\\n      if (jj_la1[i] == jj_gen) {\\n        for (int j = 0; j < 32; j++) {\\n          if ((jj_la1_0[i] & (1<<j)) != 0) {\\n            la1tokens[j] = true;\\n          }\\n          if ((jj_la1_1[i] & (1<<j)) != 0) {\\n            la1tokens[32+j] = true;\\n          }\\n          if ((jj_la1_2[i] & (1<<j)) != 0) {\\n            la1tokens[64+j] = true;\\n          }\\n          if ((jj_la1_3[i] & (1<<j)) != 0) {\\n            la1tokens[96+j] = true;\\n          }\\n        }\\n      }\\n    }\\n    for (int i = 0; i < 123; i++) {\\n      if (la1tokens[i]) {\\n        jj_expentry = new int[1];\\n        jj_expentry[0] = i;\\n        jj_expentries.addElement(jj_expentry);\\n      }\\n    }\\n    jj_endpos = 0;\\n    jj_rescan_token();\\n    jj_add_error_token(0, 0);\\n    int[][] exptokseq = new int[jj_expentries.size()][];\\n    for (int i = 0; i < jj_expentries.size(); i++) {\\n      exptokseq[i] = (int[])jj_expentries.elementAt(i);\\n    }\\n    return new ParseException(token, exptokseq, tokenImage);\\n  }\\n  final public void enable_tracing() {\\n  }\\n  final public void disable_tracing() {\\n  }\\n  final private void jj_rescan_token() {\\n    jj_rescan = true;\\n    for (int i = 0; i < 26; i++) {\\n      JJCalls p = jj_2_rtns[i];\\n      do {\\n        if (p.gen > jj_gen) {\\n          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;\\n          switch (i) {\\n            case 0: jj_3_1(); break;\\n            case 1: jj_3_2(); break;\\n            case 2: jj_3_3(); break;\\n            case 3: jj_3_4(); break;\\n            case 4: jj_3_5(); break;\\n            case 5: jj_3_6(); break;\\n            case 6: jj_3_7(); break;\\n            case 7: jj_3_8(); break;\\n            case 8: jj_3_9(); break;\\n            case 9: jj_3_10(); break;\\n            case 10: jj_3_11(); break;\\n            case 11: jj_3_12(); break;\\n            case 12: jj_3_13(); break;\\n            case 13: jj_3_14(); break;\\n            case 14: jj_3_15(); break;\\n            case 15: jj_3_16(); break;\\n            case 16: jj_3_17(); break;\\n            case 17: jj_3_18(); break;\\n            case 18: jj_3_19(); break;\\n            case 19: jj_3_20(); break;\\n            case 20: jj_3_21(); break;\\n            case 21: jj_3_22(); break;\\n            case 22: jj_3_23(); break;\\n            case 23: jj_3_24(); break;\\n            case 24: jj_3_25(); break;\\n            case 25: jj_3_26(); break;\\n          }\\n        }\\n        p = p.next;\\n      } while (p != null);\\n    }\\n    jj_rescan = false;\\n  }\\n  final private void jj_save(int index, int xla) {\\n    JJCalls p = jj_2_rtns[index];\\n    while (p.gen > jj_gen) {\\n      if (p.next == null) { p = p.next = new JJCalls(); break; }\\n      p = p.next;\\n    }\\n    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;\\n  }\\n  static final class JJCalls {\\n    int gen;\\n    Token first;\\n    int arg;\\n    JJCalls next;\\n  }\\n}\""
        },
        {
            "role": "user",
            "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
        },
        {
            "content": "Title: Diagnosis of starting entity `SimpleNode.java`\n\nChange set: [Parser, Interpreter, BSHMethodDeclaration, BSHAmbiguousName, CallStack, EvalError, Name, BSHCastExpression, BSHAllocationExpression, BSHArrayDimensions, BSHPrimarySuffix, BSHIfStatement, BshMethod, Handler, UtilTargetError, BSHLHSPrimarySuffix, BSHBinaryExpression, BSHThrowStatement, BSHImportDeclaration, XThis, BSHUnaryExpression, BSHArrayInitializer, BSHReturnStatement, BSHTypedVariableDeclaration, BSHSwitchStatement, BlockNameSpace, BSHFormalParameter, BSHMethodInvocation, BSHTryStatement, ReturnControl, BSHReturnType, BSHAssignment, BSHFormalParameters, SignatureKey, LHS, StringUtil, ReflectManager, NameSpace, Primitive, This, JThis, TypedVariable, BSHBlock, BSHTernaryExpression]\n\nDetails:\n- `Parser.java`: Directly uses SimpleNode for AST construction and parsing operations. There's a semantic similarity of 69.3%, and it is part of the core parser that manipulates nodes frequently.\n- `Interpreter.java`: Interacts with SimpleNode during evaluation processes (e.g., error handling or interpreting node structures).\n- `BSHMethodDeclaration.java`: Likely extends or interacts with SimpleNode as part of the Abstract Syntax Tree (AST) structure to represent method declarations.\n- `BSHAmbiguousName.java`: Related to name resolution within the AST, which depends on node functionality provided by SimpleNode.\n- `CallStack.java`: Used in managing execution context during evaluations involving AST nodes.\n- `EvalError.java`: Thrown or caught during node evaluation; tightly related through exception handling logic.\n- `Name.java`: Could be involved in resolving identifiers/names within the AST managed by nodes.\n- `BSHCastExpression.java`, `BSHAllocationExpression.java`, `BSHArrayDimensions.java`, `BSHPrimarySuffix.java`, `BSHIfStatement.java`, `BSHBinaryExpression.java`, `BSHThrowStatement.java`, `BSHImportDeclaration.java`, `BSHUnaryExpression.java`, `BSHArrayInitializer.java`, `BSHReturnStatement.java`, `BSHTypedVariableDeclaration.java`, `BSHSwitchStatement.java`, `BlockNameSpace.java`, `BSHFormalParameter.java`, `BSHMethodInvocation.java`, `BSHTryStatement.java`, `BSHReturnType.java`, `BSHAssignment.java`, `BSHFormalParameters.java`, `SignatureKey.java`, `LHS.java`, `BSHBlock.java`, `BSHTernaryExpression.java`: All are likely subclasses or components interacting with SimpleNode in building and evaluating expressions, statements, blocks, and other syntactic elements.\n- `NameSpace.java`, `Primitive.java`, `This.java`, `JThis.java`, `TypedVariable.java`, `StringUtil.java`, `ReflectManager.java`, `Handler.java`, `UtilTargetError.java`, `ReturnControl.java`: These entities are conceptually or structurally tied to the parsing, scoping, or evaluation framework where SimpleNode plays a central role.\n\nThese files are included due to their high co-change frequency, conceptual coupling, and involvement in AST management or related frameworks like parsing, interpretation, or error handling. They should be synchronized to ensure consistency in structural or behavioral changes propagated from SimpleNode.java.",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        }
    ],
    "interaction_records": {
        "step_histories": [
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4"
                ],
                "response_message": "m5"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6"
                ],
                "response_message": "m7"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8"
                ],
                "response_message": "m9"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10"
                ],
                "response_message": "m11"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12"
                ],
                "response_message": "m13"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14"
                ],
                "response_message": "m15"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14",
                    "m15",
                    "m16",
                    "m17"
                ],
                "response_message": "m18"
            }
        ],
        "mid_to_message": {
            "m1": {
                "role": "system",
                "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
            },
            "m2": {
                "role": "user",
                "content": "The project you need to analyze is `jEdit`, a well-known Java open source project. The starting entity you need to deal with is SimpleNode.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
            },
            "m3": {
                "content": "",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_8b1ec228d44340e8ae557f",
                        "function": {
                            "arguments": "{\"entity\": \"SimpleNode.java\"}",
                            "name": "get_co_change_relationship"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m4": {
                "name": "get_co_change_relationship",
                "role": "tool",
                "content": "[[\"Parser\", \"2\", \"1.0\"], [\"Primitive\", \"2\", \"1.0\"], [\"NameSpace\", \"2\", \"1.0\"], [\"Interpreter\", \"2\", \"1.0\"], [\"Reflect\", \"2\", \"1.0\"], [\"EvalError\", \"2\", \"1.0\"], [\"CallStack\", \"2\", \"1.0\"], [\"Name\", \"2\", \"1.0\"], [\"TargetError\", \"2\", \"1.0\"], [\"BshClassManager\", \"2\", \"1.0\"], [\"StringUtil\", \"2\", \"1.0\"], [\"This\", \"2\", \"1.0\"], [\"UtilEvalError\", \"2\", \"1.0\"], [\"LHS\", \"2\", \"1.0\"], [\"BSHAmbiguousName\", \"2\", \"1.0\"], [\"JThis\", \"2\", \"1.0\"], [\"ParseException\", \"2\", \"1.0\"], [\"BSHType\", \"2\", \"1.0\"], [\"ReflectManager\", \"2\", \"1.0\"], [\"BSHCastExpression\", \"2\", \"1.0\"], [\"BSHAllocationExpression\", \"2\", \"1.0\"], [\"BSHArrayDimensions\", \"2\", \"1.0\"], [\"TypedVariable\", \"2\", \"1.0\"], [\"BSHPrimarySuffix\", \"2\", \"1.0\"], [\"BSHIfStatement\", \"2\", \"1.0\"], [\"BshMethod\", \"2\", \"1.0\"], [\"Handler\", \"2\", \"1.0\"], [\"UtilTargetError\", \"2\", \"1.0\"], [\"BSHLHSPrimarySuffix\", \"2\", \"1.0\"], [\"BSHBinaryExpression\", \"2\", \"1.0\"], [\"BSHThrowStatement\", \"2\", \"1.0\"], [\"BSHImportDeclaration\", \"2\", \"1.0\"], [\"XThis\", \"2\", \"1.0\"], [\"BSHUnaryExpression\", \"2\", \"1.0\"], [\"BSHArrayInitializer\", \"2\", \"1.0\"], [\"BSHReturnStatement\", \"2\", \"1.0\"], [\"BSHTypedVariableDeclaration\", \"2\", \"1.0\"], [\"BSHSwitchStatement\", \"2\", \"1.0\"], [\"BlockNameSpace\", \"2\", \"1.0\"], [\"BSHFormalParameter\", \"2\", \"1.0\"], [\"BSHMethodInvocation\", \"2\", \"1.0\"], [\"BSHTryStatement\", \"2\", \"1.0\"], [\"ReturnControl\", \"2\", \"1.0\"], [\"BSHReturnType\", \"2\", \"1.0\"], [\"BSHAssignment\", \"2\", \"1.0\"], [\"BSHFormalParameters\", \"2\", \"1.0\"], [\"SignatureKey\", \"2\", \"1.0\"], [\"BSHLHSPrimaryExpression\", \"2\", \"1.0\"], [\"BSHMethodDeclaration\", \"2\", \"1.0\"]]"
            },
            "m5": {
                "content": "The `get_co_change_relationship` function has returned a list of entities that are frequently modified together with `SimpleNode.java`. These entities have a co-change relationship with `SimpleNode.java` with a confidence level of 100% (i.e., every time this file was modified, those files were also modified). \n\nThis is a strong indicator that these files might be impacted by any changes made to `SimpleNode.java`.\n\nHere are some initial observations:\n\n- There are 48 entities listed, which suggests a high degree of interdependence with `SimpleNode.java`.\n- Many of the names suggest they are related to parsing, evaluation, and handling expressions (e.g., `Parser`, `Primitive`, `Interpreter`, `EvalError`, `BSHMethodDeclaration`, etc.).\n- This implies that `SimpleNode.java` likely plays a central role in expression parsing or abstract syntax tree (AST) management within the system.\n\nTo better understand why these files are connected and determine which ones truly need synchronization, we can dig deeper into their relationships. A good next step would be to analyze the coupling dependencies between `SimpleNode.java` and some of these co-changed files (especially key ones like `Parser.java`, `Interpreter.java`, or `EvalError.java`) using the `get_coupling_dependencies` function.\n\nLet me start by analyzing the coupling dependencies between `SimpleNode.java` and `Parser.java`.\n\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_f0d29bb86dc345ca8967ed",
                        "function": {
                            "arguments": "{\"entity1\": \"SimpleNode.java\", \"entity2\": \"Parser.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m6": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"There are no coupling dependencies between these two entities\"]"
            },
            "m7": {
                "content": "It appears that there are no direct coupling dependencies between `SimpleNode.java` and `Parser.java`. This suggests that the co-change relationship might be due to higher-level architectural or functional dependencies rather than direct code-level couplings.\n\nTo explore further, let's consider another entity from the co-change list that might have a more direct relationship with `SimpleNode.java`. `BshMethodDeclaration.java` is a good candidate because it likely involves node structures or method parsing, which could be closely related to `SimpleNode.java`.\n\nLet me analyze the coupling dependencies between `SimpleNode.java` and `BshMethodDeclaration.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_dbdce350f923447ab51a81",
                        "function": {
                            "arguments": "{\"entity1\": \"SimpleNode.java\", \"entity2\": \"BshMethodDeclaration.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m8": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"BshMethodDeclaration has been removed from the project due to project version iteration\"]"
            },
            "m9": {
                "content": "It seems that `BshMethodDeclaration.java` is no longer present in the current version of the project, likely due to refactoring or architectural changes over time. This complicates our analysis since we can't directly examine its coupling with `SimpleNode.java`.\n\nLet's pivot strategy slightly. Since many co-changed entities are related to parsing and evaluation, another meaningful approach would be to inspect the **call graph** for `SimpleNode.java`. This will help us understand which entities are directly invoked or referenced by `SimpleNode.java`, potentially shedding light on why certain files are frequently co-changed.\n\nLet me retrieve the call graph for `SimpleNode.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_d3f5d9a461b8452fbc91d7",
                        "function": {
                            "arguments": "{\"entity\": \"SimpleNode.java\"}",
                            "name": "get_call_graph"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m10": {
                "role": "tool",
                "name": "get_call_graph",
                "content": "[]"
            },
            "m11": {
                "content": "The call graph for `SimpleNode.java` is empty, which indicates that no other entities are directly invoked or referenced by `SimpleNode.java` based on the current analysis. This further suggests that the co-change relationships we observed earlier may not be due to direct method calls or references.\n\nGiven this information, a useful next step would be to examine the **source code** of `SimpleNode.java` itself. By reviewing its structure and functionality, we can gain insights into its role in the system and potentially identify indirect dependencies or design patterns that explain its extensive co-change relationships.\n\nLet me retrieve the source code of `SimpleNode.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_2f3da4682ffe4797be45f6",
                        "function": {
                            "arguments": "{\"entity\": \"SimpleNode.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m12": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package bsh;\\nclass SimpleNode implements Node \\n{\\n\\tpublic static SimpleNode JAVACODE =\\n\\t\\tnew SimpleNode( -1 ) {\\n\\t\\t\\tpublic String getSourceFile() {\\n\\t\\t\\t\\treturn \\\"<Called from Java Code>\\\";\\n\\t\\t\\t}\\n\\t\\t\\tpublic int getLineNumber() {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\tpublic String getText()  {\\n\\t\\t\\t\\treturn \\\"<Compiled Java Code>\\\";\\n\\t\\t\\t}\\n\\t\\t};\\n\\tprotected Node parent;\\n\\tprotected Node[] children;\\n\\tprotected int id;\\n\\tToken firstToken, lastToken;\\n\\tString sourceFile;\\n\\tpublic SimpleNode(int i) {\\n\\t\\tid = i;\\n\\t}\\n\\tpublic void jjtOpen() { }\\n\\tpublic void jjtClose() { }\\n\\tpublic void jjtSetParent(Node n) { parent = n; }\\n\\tpublic Node jjtGetParent() { return parent; }\\n\\tpublic void jjtAddChild(Node n, int i)\\n\\t{\\n\\t\\tif (children == null)\\n\\t\\t\\tchildren = new Node[i + 1];\\n\\t\\telse\\n\\t\\t\\tif (i >= children.length)\\n\\t\\t\\t{\\n\\t\\t\\t\\tNode c[] = new Node[i + 1];\\n\\t\\t\\t\\tSystem.arraycopy(children, 0, c, 0, children.length);\\n\\t\\t\\t\\tchildren = c;\\n\\t\\t\\t}\\n\\t\\tchildren[i] = n;\\n\\t}\\n\\tpublic Node jjtGetChild(int i) { \\n\\t\\treturn children[i]; \\n\\t}\\n\\tpublic SimpleNode getChild( int i ) {\\n\\t\\treturn (SimpleNode)jjtGetChild(i);\\n\\t}\\n\\tpublic int jjtGetNumChildren() {\\n\\t\\treturn (children == null) ? 0 : children.length;\\n\\t}\\n\\tpublic String toString() { return ParserTreeConstants.jjtNodeName[id]; }\\n\\tpublic String toString(String prefix) { return prefix + toString(); }\\n\\tpublic void dump(String prefix)\\n\\t{\\n\\t\\tSystem.out.println(toString(prefix));\\n\\t\\tif(children != null)\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < children.length; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSimpleNode n = (SimpleNode)children[i];\\n\\t\\t\\t\\tif (n != null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tn.dump(prefix + \\\" \\\");\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tpublic void prune() {\\n\\t\\tjjtSetParent( null );\\n\\t}\\n\\tpublic Object eval( CallStack callstack, Interpreter interpreter ) \\n\\t\\tthrows EvalError\\n\\t{\\n\\t\\tthrow new InterpreterError(\\n\\t\\t\\t\\\"Unimplemented or inappropriate for \\\" + getClass().getName() );\\n\\t}\\n\\tpublic void setSourceFile( String sourceFile ) {\\n\\t\\tthis.sourceFile = sourceFile;\\n\\t}\\n\\tpublic String getSourceFile() {\\n\\t\\tif ( sourceFile == null )\\n\\t\\t\\tif ( parent != null )\\n\\t\\t\\t\\treturn ((SimpleNode)parent).getSourceFile();\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn \\\"<unknown file>\\\";\\n\\t\\telse\\n\\t\\t\\treturn sourceFile;\\n\\t}\\n\\tpublic int getLineNumber() {\\n\\t\\treturn firstToken.beginLine;\\n\\t}\\n\\tpublic String getText() \\n\\t{\\n\\t\\tStringBuffer text = new StringBuffer();\\n\\t\\tToken t = firstToken;\\n\\t\\twhile ( t!=null ) {\\n\\t\\t\\ttext.append(t.image);\\n\\t\\t\\tif ( !t.image.equals(\\\".\\\") )\\n\\t\\t\\t\\ttext.append(\\\" \\\");\\n\\t\\t\\tif ( t==lastToken ||\\n\\t\\t\\t\\tt.image.equals(\\\"{\\\") || t.image.equals(\\\";\\\") )\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tt=t.next;\\n\\t\\t}\\n\\t\\treturn text.toString();\\n\\t}\\n}\""
            },
            "m13": {
                "content": "From the source code of `SimpleNode.java`, we can derive several key insights:\n\n### Overview:\n- **`SimpleNode`** is a class that implements the `Node` interface.\n- It appears to be part of a structure for building and managing an Abstract Syntax Tree (AST), which is common in parsers and interpreters.\n\n### Key Features:\n1. **AST Node Structure**:\n   - Maintains parent and children references (`parent`, `children[]`).\n   - Provides methods like `jjtSetParent()`, `jjtGetChild()`, `jjtAddChild()` for tree navigation and manipulation.\n   - Has an `id` associated with node types, likely mapped via `ParserTreeConstants.jjtNodeName`.\n\n2. **Token Management**:\n   - References `Token` objects (`firstToken`, `lastToken`) and retrieves line numbers and source text using them.\n   - This implies it's tightly involved with parsing source code into tokens and reconstructing source segments from tokens.\n\n3. **Evaluation Framework**:\n   - Contains an `eval()` method that throws an `EvalError`. This suggests it's meant to be extended by classes that implement actual evaluation logic.\n   - The default implementation throws an `InterpreterError`, indicating this is a placeholder or abstract behavior.\n\n4. **Source Context**:\n   - Keeps track of the source file (`sourceFile`) and uses token information to retrieve line numbers and textual representation of the code segment.\n\n5. **Utility Methods**:\n   - Includes a `dump()` method for printing the AST structure, useful for debugging.\n   - `prune()` method helps in cleaning up parent references, possibly for memory management or optimization.\n\n---\n\n### Why Is It Co-Changed Frequently?\n\nGiven its role as a foundational AST node class:\n- **Extensibility and Inheritance**: Many other node types (like method declarations, expressions, etc.) likely extend or use `SimpleNode`, even if not directly visible through coupling dependencies.\n- **Parsing & Evaluation**: Its involvement in parsing and evaluation logic explains its relationship with files like `Parser.java`, `Interpreter.java`, `EvalError.java`, etc.\n- **Token Handling**: Since it works closely with tokens and source code reconstruction, changes to how tokens are handled might necessitate synchronized updates across related classes.\n\n---\n\n### Next Steps\n\nTo better understand indirect relationships and confirm our observations, we could:\n1. Check conceptual coupling (semantic similarity) between `SimpleNode.java` and some co-changed entities (e.g., `Parser.java`, `EvalError.java`) using `get_conceptual_coupling`.\n2. Retrieve source code of one of the frequently co-changed files (e.g., `Parser.java`) and compare its usage of `SimpleNode`.\n\nLet\u2019s start by analyzing the conceptual coupling between `SimpleNode.java` and `Parser.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_55914de1f6e44f7d91d10c",
                        "function": {
                            "arguments": "{\"entity1\": \"SimpleNode.java\", \"entity2\": \"Parser.java\"}",
                            "name": "get_conceptual_coupling"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m14": {
                "role": "tool",
                "name": "get_conceptual_coupling",
                "content": "\"0.69306767\""
            },
            "m15": {
                "content": "The conceptual coupling (semantic similarity) between `SimpleNode.java` and `Parser.java` is approximately **0.693**, or 69.3%. This indicates a moderate to high level of semantic overlap between the two files, reinforcing the idea that they are functionally related despite lacking direct code-level coupling.\n\nThis aligns with our earlier understanding: `SimpleNode` serves as a foundational class in AST management, while `Parser.java` likely uses or manipulates such nodes during parsing operations.\n\n### Next Steps:\n\nTo further validate their relationship:\n- We can retrieve and inspect the source code of `Parser.java` to see how it interacts with `SimpleNode.java`.\n- Similarly, we could analyze the usage of `SimpleNode` in other co-changed files (e.g., checking if they extend or manipulate `SimpleNode` indirectly).\n\nLet's retrieve the source code for `Parser.java` to explore its connection with `SimpleNode.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_631c40ef9e17440693efda",
                        "function": {
                            "arguments": "{\"entity\": \"Parser.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m16": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package bsh;\\nimport java.io.*;\\npublic class Parserimplements ParserTreeConstants, ParserConstants {\\n  protected JJTParserState jjtree = new JJTParserState();boolean retainComments = false;\\n        public void setRetainComments( boolean b ) {\\n                retainComments = b;\\n        }\\n        void jjtreeOpenNodeScope(Node n) {\\n                ((SimpleNode)n).firstToken = getToken(1);\\n        }\\n        void jjtreeCloseNodeScope(Node n) {\\n                ((SimpleNode)n).lastToken = getToken(0);\\n        }\\n        void reInitInput( Reader in ) {\\n                ReInit(in);\\n        }\\n        public SimpleNode popNode()\\n        {\\n                if ( jjtree.nodeArity() > 0)                          return (SimpleNode)jjtree.popNode();\\n                else\\n                        return null;\\n        }\\n        void reInitTokenInput( Reader in ) {\\n                jj_input_stream.ReInit( in,\\n                        jj_input_stream.getEndLine(),\\n                        jj_input_stream.getEndColumn() );\\n        }\\n        public static void main( String [] args )\\n                throws IOException, ParseException\\n        {\\n                boolean print = false;\\n                int i=0;\\n                if ( args[0].equals(\\\"-p\\\") ) {\\n                        i++;\\n                        print=true;\\n                }\\n                for(; i< args.length; i++) {\\n                        Reader in = new FileReader(args[i]);\\n                        Parser parser = new Parser(in);\\n                        parser.setRetainComments(true);\\n                        while( !parser.Line() )\\n                                if ( print )\\n                                        System.out.println( parser.popNode() );\\n                }\\n        }\\n  final public boolean Line() throws ParseException {\\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n    case 0:\\n      jj_consume_token(0);\\n        Interpreter.debug(\\\"End of File!\\\");\\n        {if (true) return true;}\\n      break;\\n    case BOOLEAN:\\n    case BREAK:\\n    case BYTE:\\n    case CHAR:\\n    case CONTINUE:\\n    case DO:\\n    case DOUBLE:\\n    case FALSE:\\n    case FINAL:\\n    case FLOAT:\\n    case FOR:\\n    case IF:\\n    case IMPORT:\\n    case INT:\\n    case LONG:\\n    case NEW:\\n    case NULL:\\n    case RETURN:\\n    case SHORT:\\n    case SWITCH:\\n    case THROW:\\n    case TRUE:\\n    case TRY:\\n    case VOID:\\n    case WHILE:\\n    case INTEGER_LITERAL:\\n    case FLOATING_POINT_LITERAL:\\n    case CHARACTER_LITERAL:\\n    case STRING_LITERAL:\\n    case FORMAL_COMMENT:\\n    case IDENTIFIER:\\n    case LPAREN:\\n    case LBRACE:\\n    case SEMICOLON:\\n    case BANG:\\n    case TILDE:\\n    case INCR:\\n    case DECR:\\n    case PLUS:\\n    case MINUS:\\n      if (jj_2_1(2147483647)) {\\n        Expression();\\n        jj_consume_token(SEMICOLON);\\n      } else {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case BOOLEAN:\\n        case BREAK:\\n        case BYTE:\\n        case CHAR:\\n        case CONTINUE:\\n        case DO:\\n        case DOUBLE:\\n        case FALSE:\\n        case FINAL:\\n        case FLOAT:\\n        case FOR:\\n        case IF:\\n        case IMPORT:\\n        case INT:\\n        case LONG:\\n        case NEW:\\n        case NULL:\\n        case RETURN:\\n        case SHORT:\\n        case SWITCH:\\n        case THROW:\\n        case TRUE:\\n        case TRY:\\n        case VOID:\\n        case WHILE:\\n        case INTEGER_LITERAL:\\n        case FLOATING_POINT_LITERAL:\\n        case CHARACTER_LITERAL:\\n        case STRING_LITERAL:\\n        case FORMAL_COMMENT:\\n        case IDENTIFIER:\\n        case LPAREN:\\n        case LBRACE:\\n        case SEMICOLON:\\n        case INCR:\\n        case DECR:\\n          BlockStatement();\\n          break;\\n        default:\\n          jj_la1[0] = jj_gen;\\n          jj_consume_token(-1);\\n          throw new ParseException();\\n        }\\n      }\\n                {if (true) return false;}\\n      break;\\n    default:\\n      jj_la1[1] = jj_gen;\\n      jj_consume_token(-1);\\n      throw new ParseException();\\n    }\\n    throw new Error(\\\"Missing return statement in function\\\");\\n  }\\n  final public void MethodDeclaration() throws ParseException {\\n  BSHMethodDeclaration jjtn000 = new BSHMethodDeclaration(JJTMETHODDECLARATION);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);Token t = null;\\n    try {\\n      if (jj_2_2(2147483647)) {\\n        ReturnType();\\n        t = jj_consume_token(IDENTIFIER);\\n                                    jjtn000.name = t.image;\\n        FormalParameters();\\n        Block();\\n      } else {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case IDENTIFIER:\\n          t = jj_consume_token(IDENTIFIER);\\n                       jjtn000.name = t.image;\\n          FormalParameters();\\n          Block();\\n          break;\\n        default:\\n          jj_la1[2] = jj_gen;\\n          jj_consume_token(-1);\\n          throw new ParseException();\\n        }\\n      }\\n    } catch (Throwable jjte000) {\\n      if (jjtc000) {\\n        jjtree.clearNodeScope(jjtn000);\\n        jjtc000 = false;\\n      } else {\\n        jjtree.popNode();\\n      }\\n      if (jjte000 instanceof RuntimeException) {\\n        {if (true) throw (RuntimeException)jjte000;}\\n      }\\n      if (jjte000 instanceof ParseException) {\\n        {if (true) throw (ParseException)jjte000;}\\n      }\\n      {if (true) throw (Error)jjte000;}\\n    } finally {\\n      if (jjtc000) {\\n        jjtree.closeNodeScope(jjtn000, true);\\n        jjtreeCloseNodeScope(jjtn000);\\n      }\\n    }\\n  }\\n  final public void MethodDeclarationLookahead() throws ParseException {\\n    if (jj_2_3(2147483647)) {\\n      ReturnType();\\n      jj_consume_token(IDENTIFIER);\\n      FormalParameters();\\n      jj_consume_token(LBRACE);\\n    } else {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case IDENTIFIER:\\n        jj_consume_token(IDENTIFIER);\\n        FormalParameters();\\n        jj_consume_token(LBRACE);\\n        break;\\n      default:\\n        jj_la1[3] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n    }\\n  }\\n  final public void MethodDeclarationTypeLookahead() throws ParseException {\\n    ReturnType();\\n    jj_consume_token(IDENTIFIER);\\n    jj_consume_token(LPAREN);\\n  }\\n  final public void ImportDeclaration() throws ParseException {\\n    BSHImportDeclaration jjtn000 = new BSHImportDeclaration(JJTIMPORTDECLARATION);\\n    boolean jjtc000 = true;\\n    jjtree.openNodeScope(jjtn000);\\n    jjtreeOpenNodeScope(jjtn000);Token t = null;\\n    try {\\n      if (jj_2_4(2)) {\\n        jj_consume_token(IMPORT);\\n        AmbiguousName();\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case DOT:\\n          t = jj_consume_token(DOT);\\n          jj_consume_token(STAR);\\n          break;\\n        default:\\n          jj_la1[4] = jj_gen;\\n          ;\\n        }\\n        jj_consume_token(SEMICOLON);\\n                                                 jjtree.closeNodeScope(jjtn000, true);\\n                                                 jjtc000 = false;\\n                                                 jjtreeCloseNodeScope(jjtn000);\\n    if ( t != null )\\n        jjtn000.importPackage = true;\\n      } else {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case IMPORT:\\n          jj_consume_token(IMPORT);\\n          jj_consume_token(STAR);\\n          jj_consume_token(SEMICOLON);\\n                     jjtree.closeNodeScope(jjtn000, true);\\n                     jjtc000 = false;\\n                     jjtreeCloseNodeScope(jjtn000);\\n                jjtn000.superImport = true;\\n          break;\\n        default:\\n          jj_la1[5] = jj_gen;\\n          jj_consume_token(-1);\\n          throw new ParseException();\\n        }\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void VariableDeclarator() throws ParseException {\\n  BSHVariableDeclarator jjtn000 = new BSHVariableDeclarator(JJTVARIABLEDECLARATOR);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);Token t;\\n    try {\\n      t = jj_consume_token(IDENTIFIER);\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case ASSIGN:\\n        jj_consume_token(ASSIGN);\\n        VariableInitializer();\\n        break;\\n      default:\\n        jj_la1[6] = jj_gen;\\n        ;\\n      }\\n                                                 jjtree.closeNodeScope(jjtn000, true);\\n                                                 jjtc000 = false;\\n                                                 jjtreeCloseNodeScope(jjtn000);\\n                                                 jjtn000.name = t.image;\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void VariableInitializer() throws ParseException {\\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n    case LBRACE:\\n      ArrayInitializer();\\n      break;\\n    case BOOLEAN:\\n    case BYTE:\\n    case CHAR:\\n    case DOUBLE:\\n    case FALSE:\\n    case FLOAT:\\n    case INT:\\n    case LONG:\\n    case NEW:\\n    case NULL:\\n    case SHORT:\\n    case TRUE:\\n    case VOID:\\n    case INTEGER_LITERAL:\\n    case FLOATING_POINT_LITERAL:\\n    case CHARACTER_LITERAL:\\n    case STRING_LITERAL:\\n    case IDENTIFIER:\\n    case LPAREN:\\n    case BANG:\\n    case TILDE:\\n    case INCR:\\n    case DECR:\\n    case PLUS:\\n    case MINUS:\\n      Expression();\\n      break;\\n    default:\\n      jj_la1[7] = jj_gen;\\n      jj_consume_token(-1);\\n      throw new ParseException();\\n    }\\n  }\\n  final public void ArrayInitializer() throws ParseException {\\n  BSHArrayInitializer jjtn000 = new BSHArrayInitializer(JJTARRAYINITIALIZER);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(LBRACE);\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FALSE:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case NEW:\\n      case NULL:\\n      case SHORT:\\n      case TRUE:\\n      case VOID:\\n      case INTEGER_LITERAL:\\n      case FLOATING_POINT_LITERAL:\\n      case CHARACTER_LITERAL:\\n      case STRING_LITERAL:\\n      case IDENTIFIER:\\n      case LPAREN:\\n      case LBRACE:\\n      case BANG:\\n      case TILDE:\\n      case INCR:\\n      case DECR:\\n      case PLUS:\\n      case MINUS:\\n        VariableInitializer();\\n        label_1:\\n        while (true) {\\n          if (jj_2_5(2)) {\\n            ;\\n          } else {\\n            break label_1;\\n          }\\n          jj_consume_token(COMMA);\\n          VariableInitializer();\\n        }\\n        break;\\n      default:\\n        jj_la1[8] = jj_gen;\\n        ;\\n      }\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case COMMA:\\n        jj_consume_token(COMMA);\\n        break;\\n      default:\\n        jj_la1[9] = jj_gen;\\n        ;\\n      }\\n      jj_consume_token(RBRACE);\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void FormalParameters() throws ParseException {\\n  BSHFormalParameters jjtn000 = new BSHFormalParameters(JJTFORMALPARAMETERS);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(LPAREN);\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case SHORT:\\n      case IDENTIFIER:\\n        FormalParameter();\\n        label_2:\\n        while (true) {\\n          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n          case COMMA:\\n            ;\\n            break;\\n          default:\\n            jj_la1[10] = jj_gen;\\n            break label_2;\\n          }\\n          jj_consume_token(COMMA);\\n          FormalParameter();\\n        }\\n        break;\\n      default:\\n        jj_la1[11] = jj_gen;\\n        ;\\n      }\\n      jj_consume_token(RPAREN);\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void FormalParameter() throws ParseException {\\n  BSHFormalParameter jjtn000 = new BSHFormalParameter(JJTFORMALPARAMETER);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);Token t;\\n    try {\\n      if (jj_2_6(2)) {\\n        Type();\\n        t = jj_consume_token(IDENTIFIER);\\n                                       jjtree.closeNodeScope(jjtn000, true);\\n                                       jjtc000 = false;\\n                                       jjtreeCloseNodeScope(jjtn000);\\n                                       jjtn000.name = t.image;\\n      } else {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case IDENTIFIER:\\n          t = jj_consume_token(IDENTIFIER);\\n                   jjtree.closeNodeScope(jjtn000, true);\\n                   jjtc000 = false;\\n                   jjtreeCloseNodeScope(jjtn000);\\n                   jjtn000.name = t.image;\\n          break;\\n        default:\\n          jj_la1[12] = jj_gen;\\n          jj_consume_token(-1);\\n          throw new ParseException();\\n        }\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void Type() throws ParseException {\\n  BSHType jjtn000 = new BSHType(JJTTYPE);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case SHORT:\\n        PrimitiveType();\\n        break;\\n      case IDENTIFIER:\\n        AmbiguousName();\\n        break;\\n      default:\\n        jj_la1[13] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n      label_3:\\n      while (true) {\\n        if (jj_2_7(2)) {\\n          ;\\n        } else {\\n          break label_3;\\n        }\\n        jj_consume_token(LBRACKET);\\n        jj_consume_token(RBRACKET);\\n                                 jjtn000.addArrayDimension();\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void ReturnType() throws ParseException {\\n  BSHReturnType jjtn000 = new BSHReturnType(JJTRETURNTYPE);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case VOID:\\n        jj_consume_token(VOID);\\n           jjtree.closeNodeScope(jjtn000, true);\\n           jjtc000 = false;\\n           jjtreeCloseNodeScope(jjtn000);\\n           jjtn000.isVoid = true;\\n        break;\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case SHORT:\\n      case IDENTIFIER:\\n        Type();\\n        break;\\n      default:\\n        jj_la1[14] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void PrimitiveType() throws ParseException {\\n  BSHPrimitiveType jjtn000 = new BSHPrimitiveType(JJTPRIMITIVETYPE);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n        jj_consume_token(BOOLEAN);\\n            jjtree.closeNodeScope(jjtn000, true);\\n            jjtc000 = false;\\n            jjtreeCloseNodeScope(jjtn000);\\n            jjtn000.type = Boolean.TYPE;\\n        break;\\n      case CHAR:\\n        jj_consume_token(CHAR);\\n           jjtree.closeNodeScope(jjtn000, true);\\n           jjtc000 = false;\\n           jjtreeCloseNodeScope(jjtn000);\\n           jjtn000.type =  Character.TYPE;\\n        break;\\n      case BYTE:\\n        jj_consume_token(BYTE);\\n           jjtree.closeNodeScope(jjtn000, true);\\n           jjtc000 = false;\\n           jjtreeCloseNodeScope(jjtn000);\\n           jjtn000.type =  Byte.TYPE;\\n        break;\\n      case SHORT:\\n        jj_consume_token(SHORT);\\n            jjtree.closeNodeScope(jjtn000, true);\\n            jjtc000 = false;\\n            jjtreeCloseNodeScope(jjtn000);\\n            jjtn000.type =  Short.TYPE;\\n        break;\\n      case INT:\\n        jj_consume_token(INT);\\n          jjtree.closeNodeScope(jjtn000, true);\\n          jjtc000 = false;\\n          jjtreeCloseNodeScope(jjtn000);\\n          jjtn000.type =  Integer.TYPE;\\n        break;\\n      case LONG:\\n        jj_consume_token(LONG);\\n           jjtree.closeNodeScope(jjtn000, true);\\n           jjtc000 = false;\\n           jjtreeCloseNodeScope(jjtn000);\\n           jjtn000.type =  Long.TYPE;\\n        break;\\n      case FLOAT:\\n        jj_consume_token(FLOAT);\\n            jjtree.closeNodeScope(jjtn000, true);\\n            jjtc000 = false;\\n            jjtreeCloseNodeScope(jjtn000);\\n            jjtn000.type =  Float.TYPE;\\n        break;\\n      case DOUBLE:\\n        jj_consume_token(DOUBLE);\\n             jjtree.closeNodeScope(jjtn000, true);\\n             jjtc000 = false;\\n             jjtreeCloseNodeScope(jjtn000);\\n             jjtn000.type =  Double.TYPE;\\n        break;\\n      default:\\n        jj_la1[15] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n    } finally {\\n  if (jjtc000) {\\n    jjtree.closeNodeScope(jjtn000, true);\\n    jjtreeCloseNodeScope(jjtn000);\\n  }\\n    }\\n  }\\n  final public void AmbiguousName() throws ParseException {\\n    BSHAmbiguousName jjtn000 = new BSHAmbiguousName(JJTAMBIGUOUSNAME);\\n    boolean jjtc000 = true;\\n    jjtree.openNodeScope(jjtn000);\\n    jjtreeOpenNodeScope(jjtn000);Token t;\\n    StringBuffer s;\\n    try {\\n      t = jj_consume_token(IDENTIFIER);\\n        s = new StringBuffer(t.image);\\n      label_4:\\n      while (true) {\\n        if (jj_2_8(2)) {\\n          ;\\n        } else {\\n          break label_4;\\n        }\\n        jj_consume_token(DOT);\\n        t = jj_consume_token(IDENTIFIER);\\n        s.append(\\\".\\\"+t.image);\\n      }\\n       jjtree.closeNodeScope(jjtn000, true);\\n       jjtc000 = false;\\n       jjtreeCloseNodeScope(jjtn000);\\n        jjtn000.text = s.toString();\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void Expression() throws ParseException {\\n    if (jj_2_9(2147483647)) {\\n      Assignment();\\n    } else {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FALSE:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case NEW:\\n      case NULL:\\n      case SHORT:\\n      case TRUE:\\n      case VOID:\\n      case INTEGER_LITERAL:\\n      case FLOATING_POINT_LITERAL:\\n      case CHARACTER_LITERAL:\\n      case STRING_LITERAL:\\n      case IDENTIFIER:\\n      case LPAREN:\\n      case BANG:\\n      case TILDE:\\n      case INCR:\\n      case DECR:\\n      case PLUS:\\n      case MINUS:\\n        ConditionalExpression();\\n        break;\\n      default:\\n        jj_la1[16] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n    }\\n  }\\n  final public void Assignment() throws ParseException {\\n  BSHAssignment jjtn000 = new BSHAssignment(JJTASSIGNMENT);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);int op ;\\n    try {\\n      LHSPrimaryExpression();\\n      op = AssignmentOperator();\\n    jjtn000.operator = op;\\n      Expression();\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public int AssignmentOperator() throws ParseException {\\n  Token t;\\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n    case ASSIGN:\\n      jj_consume_token(ASSIGN);\\n      break;\\n    case STARASSIGN:\\n      jj_consume_token(STARASSIGN);\\n      break;\\n    case SLASHASSIGN:\\n      jj_consume_token(SLASHASSIGN);\\n      break;\\n    case MODASSIGN:\\n      jj_consume_token(MODASSIGN);\\n      break;\\n    case PLUSASSIGN:\\n      jj_consume_token(PLUSASSIGN);\\n      break;\\n    case MINUSASSIGN:\\n      jj_consume_token(MINUSASSIGN);\\n      break;\\n    case ANDASSIGN:\\n      jj_consume_token(ANDASSIGN);\\n      break;\\n    case XORASSIGN:\\n      jj_consume_token(XORASSIGN);\\n      break;\\n    case ORASSIGN:\\n      jj_consume_token(ORASSIGN);\\n      break;\\n    case LSHIFTASSIGN:\\n      jj_consume_token(LSHIFTASSIGN);\\n      break;\\n    case LSHIFTASSIGNX:\\n      jj_consume_token(LSHIFTASSIGNX);\\n      break;\\n    case RSIGNEDSHIFTASSIGN:\\n      jj_consume_token(RSIGNEDSHIFTASSIGN);\\n      break;\\n    case RSIGNEDSHIFTASSIGNX:\\n      jj_consume_token(RSIGNEDSHIFTASSIGNX);\\n      break;\\n    case RUNSIGNEDSHIFTASSIGN:\\n      jj_consume_token(RUNSIGNEDSHIFTASSIGN);\\n      break;\\n    case RUNSIGNEDSHIFTASSIGNX:\\n      jj_consume_token(RUNSIGNEDSHIFTASSIGNX);\\n      break;\\n    default:\\n      jj_la1[17] = jj_gen;\\n      jj_consume_token(-1);\\n      throw new ParseException();\\n    }\\n        t = getToken(0);\\n        {if (true) return t.kind;}\\n    throw new Error(\\\"Missing return statement in function\\\");\\n  }\\n  final public void ConditionalExpression() throws ParseException {\\n    ConditionalOrExpression();\\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n    case HOOK:\\n      jj_consume_token(HOOK);\\n      Expression();\\n      jj_consume_token(COLON);\\n                                                     BSHTernaryExpression jjtn001 = new BSHTernaryExpression(JJTTERNARYEXPRESSION);\\n                                                     boolean jjtc001 = true;\\n                                                     jjtree.openNodeScope(jjtn001);\\n                                                     jjtreeOpenNodeScope(jjtn001);\\n      try {\\n        ConditionalExpression();\\n      } catch (Throwable jjte001) {\\n                                                     if (jjtc001) {\\n                                                       jjtree.clearNodeScope(jjtn001);\\n                                                       jjtc001 = false;\\n                                                     } else {\\n                                                       jjtree.popNode();\\n                                                     }\\n                                                     if (jjte001 instanceof RuntimeException) {\\n                                                       {if (true) throw (RuntimeException)jjte001;}\\n                                                     }\\n                                                     if (jjte001 instanceof ParseException) {\\n                                                       {if (true) throw (ParseException)jjte001;}\\n                                                     }\\n                                                     {if (true) throw (Error)jjte001;}\\n      } finally {\\n                                                     if (jjtc001) {\\n                                                       jjtree.closeNodeScope(jjtn001,  3);\\n                                                       jjtreeCloseNodeScope(jjtn001);\\n                                                     }\\n      }\\n      break;\\n    default:\\n      jj_la1[18] = jj_gen;\\n      ;\\n    }\\n  }\\n  final public void ConditionalOrExpression() throws ParseException {\\n  Token t=null;\\n    ConditionalAndExpression();\\n    label_5:\\n    while (true) {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOL_OR:\\n      case BOOL_ORX:\\n        ;\\n        break;\\n      default:\\n        jj_la1[19] = jj_gen;\\n        break label_5;\\n      }\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOL_OR:\\n        t = jj_consume_token(BOOL_OR);\\n        break;\\n      case BOOL_ORX:\\n        t = jj_consume_token(BOOL_ORX);\\n        break;\\n      default:\\n        jj_la1[20] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n      ConditionalAndExpression();\\n      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);\\n      boolean jjtc001 = true;\\n      jjtree.openNodeScope(jjtn001);\\n      jjtreeOpenNodeScope(jjtn001);\\n      try {\\n      jjtree.closeNodeScope(jjtn001,  2);\\n      jjtc001 = false;\\n      jjtreeCloseNodeScope(jjtn001);\\n      jjtn001.kind = t.kind;\\n      } finally {\\n      if (jjtc001) {\\n        jjtree.closeNodeScope(jjtn001,  2);\\n        jjtreeCloseNodeScope(jjtn001);\\n      }\\n      }\\n    }\\n  }\\n  final public void ConditionalAndExpression() throws ParseException {\\n  Token t=null;\\n    InclusiveOrExpression();\\n    label_6:\\n    while (true) {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOL_AND:\\n      case BOOL_ANDX:\\n        ;\\n        break;\\n      default:\\n        jj_la1[21] = jj_gen;\\n        break label_6;\\n      }\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOL_AND:\\n        t = jj_consume_token(BOOL_AND);\\n        break;\\n      case BOOL_ANDX:\\n        t = jj_consume_token(BOOL_ANDX);\\n        break;\\n      default:\\n        jj_la1[22] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n      InclusiveOrExpression();\\n      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);\\n      boolean jjtc001 = true;\\n      jjtree.openNodeScope(jjtn001);\\n      jjtreeOpenNodeScope(jjtn001);\\n      try {\\n      jjtree.closeNodeScope(jjtn001,  2);\\n      jjtc001 = false;\\n      jjtreeCloseNodeScope(jjtn001);\\n      jjtn001.kind = t.kind;\\n      } finally {\\n      if (jjtc001) {\\n        jjtree.closeNodeScope(jjtn001,  2);\\n        jjtreeCloseNodeScope(jjtn001);\\n      }\\n      }\\n    }\\n  }\\n  final public void InclusiveOrExpression() throws ParseException {\\n  Token t=null;\\n    ExclusiveOrExpression();\\n    label_7:\\n    while (true) {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BIT_OR:\\n      case BIT_ORX:\\n        ;\\n        break;\\n      default:\\n        jj_la1[23] = jj_gen;\\n        break label_7;\\n      }\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BIT_OR:\\n        t = jj_consume_token(BIT_OR);\\n        break;\\n      case BIT_ORX:\\n        t = jj_consume_token(BIT_ORX);\\n        break;\\n      default:\\n        jj_la1[24] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n      ExclusiveOrExpression();\\n      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);\\n      boolean jjtc001 = true;\\n      jjtree.openNodeScope(jjtn001);\\n      jjtreeOpenNodeScope(jjtn001);\\n      try {\\n      jjtree.closeNodeScope(jjtn001,  2);\\n      jjtc001 = false;\\n      jjtreeCloseNodeScope(jjtn001);\\n      jjtn001.kind = t.kind;\\n      } finally {\\n      if (jjtc001) {\\n        jjtree.closeNodeScope(jjtn001,  2);\\n        jjtreeCloseNodeScope(jjtn001);\\n      }\\n      }\\n    }\\n  }\\n  final public void ExclusiveOrExpression() throws ParseException {\\n  Token t=null;\\n    AndExpression();\\n    label_8:\\n    while (true) {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case XOR:\\n        ;\\n        break;\\n      default:\\n        jj_la1[25] = jj_gen;\\n        break label_8;\\n      }\\n      t = jj_consume_token(XOR);\\n      AndExpression();\\n      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);\\n      boolean jjtc001 = true;\\n      jjtree.openNodeScope(jjtn001);\\n      jjtreeOpenNodeScope(jjtn001);\\n      try {\\n      jjtree.closeNodeScope(jjtn001,  2);\\n      jjtc001 = false;\\n      jjtreeCloseNodeScope(jjtn001);\\n      jjtn001.kind = t.kind;\\n      } finally {\\n      if (jjtc001) {\\n        jjtree.closeNodeScope(jjtn001,  2);\\n        jjtreeCloseNodeScope(jjtn001);\\n      }\\n      }\\n    }\\n  }\\n  final public void AndExpression() throws ParseException {\\n  Token t=null;\\n    EqualityExpression();\\n    label_9:\\n    while (true) {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BIT_AND:\\n      case BIT_ANDX:\\n        ;\\n        break;\\n      default:\\n        jj_la1[26] = jj_gen;\\n        break label_9;\\n      }\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BIT_AND:\\n        t = jj_consume_token(BIT_AND);\\n        break;\\n      case BIT_ANDX:\\n        t = jj_consume_token(BIT_ANDX);\\n        break;\\n      default:\\n        jj_la1[27] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n      EqualityExpression();\\n      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);\\n      boolean jjtc001 = true;\\n      jjtree.openNodeScope(jjtn001);\\n      jjtreeOpenNodeScope(jjtn001);\\n      try {\\n      jjtree.closeNodeScope(jjtn001,  2);\\n      jjtc001 = false;\\n      jjtreeCloseNodeScope(jjtn001);\\n      jjtn001.kind = t.kind;\\n      } finally {\\n      if (jjtc001) {\\n        jjtree.closeNodeScope(jjtn001,  2);\\n        jjtreeCloseNodeScope(jjtn001);\\n      }\\n      }\\n    }\\n  }\\n  final public void EqualityExpression() throws ParseException {\\n  Token t = null;\\n    InstanceOfExpression();\\n    label_10:\\n    while (true) {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case EQ:\\n      case NE:\\n        ;\\n        break;\\n      default:\\n        jj_la1[28] = jj_gen;\\n        break label_10;\\n      }\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case EQ:\\n        t = jj_consume_token(EQ);\\n        break;\\n      case NE:\\n        t = jj_consume_token(NE);\\n        break;\\n      default:\\n        jj_la1[29] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n      InstanceOfExpression();\\n      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);\\n      boolean jjtc001 = true;\\n      jjtree.openNodeScope(jjtn001);\\n      jjtreeOpenNodeScope(jjtn001);\\n      try {\\n      jjtree.closeNodeScope(jjtn001,  2);\\n      jjtc001 = false;\\n      jjtreeCloseNodeScope(jjtn001);\\n      jjtn001.kind = t.kind;\\n      } finally {\\n      if (jjtc001) {\\n        jjtree.closeNodeScope(jjtn001,  2);\\n        jjtreeCloseNodeScope(jjtn001);\\n      }\\n      }\\n    }\\n  }\\n  final public void InstanceOfExpression() throws ParseException {\\n  Token t = null;\\n    RelationalExpression();\\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n    case INSTANCEOF:\\n      t = jj_consume_token(INSTANCEOF);\\n      Type();\\n                              BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);\\n                              boolean jjtc001 = true;\\n                              jjtree.openNodeScope(jjtn001);\\n                              jjtreeOpenNodeScope(jjtn001);\\n      try {\\n                              jjtree.closeNodeScope(jjtn001,  2);\\n                              jjtc001 = false;\\n                              jjtreeCloseNodeScope(jjtn001);\\n                              jjtn001.kind = t.kind;\\n      } finally {\\n                              if (jjtc001) {\\n                                jjtree.closeNodeScope(jjtn001,  2);\\n                                jjtreeCloseNodeScope(jjtn001);\\n                              }\\n      }\\n      break;\\n    default:\\n      jj_la1[30] = jj_gen;\\n      ;\\n    }\\n  }\\n  final public void RelationalExpression() throws ParseException {\\n  Token t = null;\\n    ShiftExpression();\\n    label_11:\\n    while (true) {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case GT:\\n      case GTX:\\n      case LT:\\n      case LTX:\\n      case LE:\\n      case LEX:\\n      case GE:\\n      case GEX:\\n        ;\\n        break;\\n      default:\\n        jj_la1[31] = jj_gen;\\n        break label_11;\\n      }\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case LT:\\n        t = jj_consume_token(LT);\\n        break;\\n      case LTX:\\n        t = jj_consume_token(LTX);\\n        break;\\n      case GT:\\n        t = jj_consume_token(GT);\\n        break;\\n      case GTX:\\n        t = jj_consume_token(GTX);\\n        break;\\n      case LE:\\n        t = jj_consume_token(LE);\\n        break;\\n      case LEX:\\n        t = jj_consume_token(LEX);\\n        break;\\n      case GE:\\n        t = jj_consume_token(GE);\\n        break;\\n      case GEX:\\n        t = jj_consume_token(GEX);\\n        break;\\n      default:\\n        jj_la1[32] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n      ShiftExpression();\\n    BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);\\n    boolean jjtc001 = true;\\n    jjtree.openNodeScope(jjtn001);\\n    jjtreeOpenNodeScope(jjtn001);\\n      try {\\n    jjtree.closeNodeScope(jjtn001,  2);\\n    jjtc001 = false;\\n    jjtreeCloseNodeScope(jjtn001);\\n    jjtn001.kind = t.kind;\\n      } finally {\\n    if (jjtc001) {\\n      jjtree.closeNodeScope(jjtn001,  2);\\n      jjtreeCloseNodeScope(jjtn001);\\n    }\\n      }\\n    }\\n  }\\n  final public void ShiftExpression() throws ParseException {\\n  Token t = null;\\n    AdditiveExpression();\\n    label_12:\\n    while (true) {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case LSHIFT:\\n      case LSHIFTX:\\n      case RSIGNEDSHIFT:\\n      case RSIGNEDSHIFTX:\\n      case RUNSIGNEDSHIFT:\\n      case RUNSIGNEDSHIFTX:\\n        ;\\n        break;\\n      default:\\n        jj_la1[33] = jj_gen;\\n        break label_12;\\n      }\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case LSHIFT:\\n        t = jj_consume_token(LSHIFT);\\n        break;\\n      case LSHIFTX:\\n        t = jj_consume_token(LSHIFTX);\\n        break;\\n      case RSIGNEDSHIFT:\\n        t = jj_consume_token(RSIGNEDSHIFT);\\n        break;\\n      case RSIGNEDSHIFTX:\\n        t = jj_consume_token(RSIGNEDSHIFTX);\\n        break;\\n      case RUNSIGNEDSHIFT:\\n        t = jj_consume_token(RUNSIGNEDSHIFT);\\n        break;\\n      case RUNSIGNEDSHIFTX:\\n        t = jj_consume_token(RUNSIGNEDSHIFTX);\\n        break;\\n      default:\\n        jj_la1[34] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n      AdditiveExpression();\\n    BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);\\n    boolean jjtc001 = true;\\n    jjtree.openNodeScope(jjtn001);\\n    jjtreeOpenNodeScope(jjtn001);\\n      try {\\n    jjtree.closeNodeScope(jjtn001,  2);\\n    jjtc001 = false;\\n    jjtreeCloseNodeScope(jjtn001);\\n    jjtn001.kind = t.kind;\\n      } finally {\\n    if (jjtc001) {\\n      jjtree.closeNodeScope(jjtn001,  2);\\n      jjtreeCloseNodeScope(jjtn001);\\n    }\\n      }\\n    }\\n  }\\n  final public void AdditiveExpression() throws ParseException {\\n  Token t = null;\\n    MultiplicativeExpression();\\n    label_13:\\n    while (true) {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case PLUS:\\n      case MINUS:\\n        ;\\n        break;\\n      default:\\n        jj_la1[35] = jj_gen;\\n        break label_13;\\n      }\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case PLUS:\\n        t = jj_consume_token(PLUS);\\n        break;\\n      case MINUS:\\n        t = jj_consume_token(MINUS);\\n        break;\\n      default:\\n        jj_la1[36] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n      MultiplicativeExpression();\\n                                                     BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);\\n                                                     boolean jjtc001 = true;\\n                                                     jjtree.openNodeScope(jjtn001);\\n                                                     jjtreeOpenNodeScope(jjtn001);\\n      try {\\n                                                     jjtree.closeNodeScope(jjtn001,  2);\\n                                                     jjtc001 = false;\\n                                                     jjtreeCloseNodeScope(jjtn001);\\n                                                     jjtn001.kind = t.kind;\\n      } finally {\\n                                                     if (jjtc001) {\\n                                                       jjtree.closeNodeScope(jjtn001,  2);\\n                                                       jjtreeCloseNodeScope(jjtn001);\\n                                                     }\\n      }\\n    }\\n  }\\n  final public void MultiplicativeExpression() throws ParseException {\\n  Token t = null;\\n    UnaryExpression();\\n    label_14:\\n    while (true) {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case STAR:\\n      case SLASH:\\n      case MOD:\\n        ;\\n        break;\\n      default:\\n        jj_la1[37] = jj_gen;\\n        break label_14;\\n      }\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case STAR:\\n        t = jj_consume_token(STAR);\\n        break;\\n      case SLASH:\\n        t = jj_consume_token(SLASH);\\n        break;\\n      case MOD:\\n        t = jj_consume_token(MOD);\\n        break;\\n      default:\\n        jj_la1[38] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n      UnaryExpression();\\n                      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);\\n                      boolean jjtc001 = true;\\n                      jjtree.openNodeScope(jjtn001);\\n                      jjtreeOpenNodeScope(jjtn001);\\n      try {\\n                      jjtree.closeNodeScope(jjtn001,  2);\\n                      jjtc001 = false;\\n                      jjtreeCloseNodeScope(jjtn001);\\n                      jjtn001.kind = t.kind;\\n      } finally {\\n                      if (jjtc001) {\\n                        jjtree.closeNodeScope(jjtn001,  2);\\n                        jjtreeCloseNodeScope(jjtn001);\\n                      }\\n      }\\n    }\\n  }\\n  final public void UnaryExpression() throws ParseException {\\n  Token t = null;\\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n    case PLUS:\\n    case MINUS:\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case PLUS:\\n        t = jj_consume_token(PLUS);\\n        break;\\n      case MINUS:\\n        t = jj_consume_token(MINUS);\\n        break;\\n      default:\\n        jj_la1[39] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n      UnaryExpression();\\n      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);\\n      boolean jjtc001 = true;\\n      jjtree.openNodeScope(jjtn001);\\n      jjtreeOpenNodeScope(jjtn001);\\n      try {\\n      jjtree.closeNodeScope(jjtn001,  1);\\n      jjtc001 = false;\\n      jjtreeCloseNodeScope(jjtn001);\\n      jjtn001.kind = t.kind;\\n      } finally {\\n      if (jjtc001) {\\n        jjtree.closeNodeScope(jjtn001,  1);\\n        jjtreeCloseNodeScope(jjtn001);\\n      }\\n      }\\n      break;\\n    case INCR:\\n      PreIncrementExpression();\\n      break;\\n    case DECR:\\n      PreDecrementExpression();\\n      break;\\n    case BOOLEAN:\\n    case BYTE:\\n    case CHAR:\\n    case DOUBLE:\\n    case FALSE:\\n    case FLOAT:\\n    case INT:\\n    case LONG:\\n    case NEW:\\n    case NULL:\\n    case SHORT:\\n    case TRUE:\\n    case VOID:\\n    case INTEGER_LITERAL:\\n    case FLOATING_POINT_LITERAL:\\n    case CHARACTER_LITERAL:\\n    case STRING_LITERAL:\\n    case IDENTIFIER:\\n    case LPAREN:\\n    case BANG:\\n    case TILDE:\\n      UnaryExpressionNotPlusMinus();\\n      break;\\n    default:\\n      jj_la1[40] = jj_gen;\\n      jj_consume_token(-1);\\n      throw new ParseException();\\n    }\\n  }\\n  final public void PreIncrementExpression() throws ParseException {\\n  Token t = null;\\n    t = jj_consume_token(INCR);\\n    LHSPrimaryExpression();\\n      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);\\n      boolean jjtc001 = true;\\n      jjtree.openNodeScope(jjtn001);\\n      jjtreeOpenNodeScope(jjtn001);\\n    try {\\n      jjtree.closeNodeScope(jjtn001,  1);\\n      jjtc001 = false;\\n      jjtreeCloseNodeScope(jjtn001);\\n      jjtn001.kind = t.kind;\\n    } finally {\\n      if (jjtc001) {\\n        jjtree.closeNodeScope(jjtn001,  1);\\n        jjtreeCloseNodeScope(jjtn001);\\n      }\\n    }\\n  }\\n  final public void PreDecrementExpression() throws ParseException {\\n  Token t = null;\\n    t = jj_consume_token(DECR);\\n    LHSPrimaryExpression();\\n      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);\\n      boolean jjtc001 = true;\\n      jjtree.openNodeScope(jjtn001);\\n      jjtreeOpenNodeScope(jjtn001);\\n    try {\\n      jjtree.closeNodeScope(jjtn001,  1);\\n      jjtc001 = false;\\n      jjtreeCloseNodeScope(jjtn001);\\n      jjtn001.kind = t.kind;\\n    } finally {\\n      if (jjtc001) {\\n        jjtree.closeNodeScope(jjtn001,  1);\\n        jjtreeCloseNodeScope(jjtn001);\\n      }\\n    }\\n  }\\n  final public void UnaryExpressionNotPlusMinus() throws ParseException {\\n  Token t = null;\\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n    case BANG:\\n    case TILDE:\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case TILDE:\\n        t = jj_consume_token(TILDE);\\n        break;\\n      case BANG:\\n        t = jj_consume_token(BANG);\\n        break;\\n      default:\\n        jj_la1[41] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n      UnaryExpression();\\n      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);\\n      boolean jjtc001 = true;\\n      jjtree.openNodeScope(jjtn001);\\n      jjtreeOpenNodeScope(jjtn001);\\n      try {\\n      jjtree.closeNodeScope(jjtn001,  1);\\n      jjtc001 = false;\\n      jjtreeCloseNodeScope(jjtn001);\\n      jjtn001.kind = t.kind;\\n      } finally {\\n      if (jjtc001) {\\n        jjtree.closeNodeScope(jjtn001,  1);\\n        jjtreeCloseNodeScope(jjtn001);\\n      }\\n      }\\n      break;\\n    default:\\n      jj_la1[42] = jj_gen;\\n      if (jj_2_10(2147483647)) {\\n        CastExpression();\\n      } else {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case BOOLEAN:\\n        case BYTE:\\n        case CHAR:\\n        case DOUBLE:\\n        case FALSE:\\n        case FLOAT:\\n        case INT:\\n        case LONG:\\n        case NEW:\\n        case NULL:\\n        case SHORT:\\n        case TRUE:\\n        case VOID:\\n        case INTEGER_LITERAL:\\n        case FLOATING_POINT_LITERAL:\\n        case CHARACTER_LITERAL:\\n        case STRING_LITERAL:\\n        case IDENTIFIER:\\n        case LPAREN:\\n          PostfixExpression();\\n          break;\\n        default:\\n          jj_la1[43] = jj_gen;\\n          jj_consume_token(-1);\\n          throw new ParseException();\\n        }\\n      }\\n    }\\n  }\\n  final public void CastLookahead() throws ParseException {\\n    if (jj_2_11(2)) {\\n      jj_consume_token(LPAREN);\\n      PrimitiveType();\\n    } else if (jj_2_12(2147483647)) {\\n      jj_consume_token(LPAREN);\\n      AmbiguousName();\\n      jj_consume_token(LBRACKET);\\n      jj_consume_token(RBRACKET);\\n    } else {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case LPAREN:\\n        jj_consume_token(LPAREN);\\n        AmbiguousName();\\n        jj_consume_token(RPAREN);\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case TILDE:\\n          jj_consume_token(TILDE);\\n          break;\\n        case BANG:\\n          jj_consume_token(BANG);\\n          break;\\n        case LPAREN:\\n          jj_consume_token(LPAREN);\\n          break;\\n        case IDENTIFIER:\\n          jj_consume_token(IDENTIFIER);\\n          break;\\n        case NEW:\\n          jj_consume_token(NEW);\\n          break;\\n        case FALSE:\\n        case NULL:\\n        case TRUE:\\n        case VOID:\\n        case INTEGER_LITERAL:\\n        case FLOATING_POINT_LITERAL:\\n        case CHARACTER_LITERAL:\\n        case STRING_LITERAL:\\n          Literal();\\n          break;\\n        default:\\n          jj_la1[44] = jj_gen;\\n          jj_consume_token(-1);\\n          throw new ParseException();\\n        }\\n        break;\\n      default:\\n        jj_la1[45] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n    }\\n  }\\n  final public void PostfixExpression() throws ParseException {\\n  Token t = null;\\n    if (jj_2_13(2147483647)) {\\n      LHSPrimaryExpression();\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case INCR:\\n        t = jj_consume_token(INCR);\\n        break;\\n      case DECR:\\n        t = jj_consume_token(DECR);\\n        break;\\n      default:\\n        jj_la1[46] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n                                BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);\\n                                boolean jjtc001 = true;\\n                                jjtree.openNodeScope(jjtn001);\\n                                jjtreeOpenNodeScope(jjtn001);\\n      try {\\n                                jjtree.closeNodeScope(jjtn001,  1);\\n                                jjtc001 = false;\\n                                jjtreeCloseNodeScope(jjtn001);\\n                jjtn001.kind = t.kind; jjtn001.postfix = true;\\n      } finally {\\n                                if (jjtc001) {\\n                                  jjtree.closeNodeScope(jjtn001,  1);\\n                                  jjtreeCloseNodeScope(jjtn001);\\n                                }\\n      }\\n    } else {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FALSE:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case NEW:\\n      case NULL:\\n      case SHORT:\\n      case TRUE:\\n      case VOID:\\n      case INTEGER_LITERAL:\\n      case FLOATING_POINT_LITERAL:\\n      case CHARACTER_LITERAL:\\n      case STRING_LITERAL:\\n      case IDENTIFIER:\\n      case LPAREN:\\n        PrimaryExpression();\\n        break;\\n      default:\\n        jj_la1[47] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n    }\\n  }\\n  final public void CastExpression() throws ParseException {\\n  BSHCastExpression jjtn000 = new BSHCastExpression(JJTCASTEXPRESSION);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      if (jj_2_14(2147483647)) {\\n        jj_consume_token(LPAREN);\\n        Type();\\n        jj_consume_token(RPAREN);\\n        UnaryExpression();\\n      } else {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case LPAREN:\\n          jj_consume_token(LPAREN);\\n          Type();\\n          jj_consume_token(RPAREN);\\n          UnaryExpressionNotPlusMinus();\\n          break;\\n        default:\\n          jj_la1[48] = jj_gen;\\n          jj_consume_token(-1);\\n          throw new ParseException();\\n        }\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void PrimaryExpression() throws ParseException {\\n  BSHPrimaryExpression jjtn000 = new BSHPrimaryExpression(JJTPRIMARYEXPRESSION);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      PrimaryPrefix();\\n      label_15:\\n      while (true) {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case LBRACE:\\n        case LBRACKET:\\n        case DOT:\\n          ;\\n          break;\\n        default:\\n          jj_la1[49] = jj_gen;\\n          break label_15;\\n        }\\n        PrimarySuffix();\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void MethodInvocation() throws ParseException {\\n  BSHMethodInvocation jjtn000 = new BSHMethodInvocation(JJTMETHODINVOCATION);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      AmbiguousName();\\n      Arguments();\\n    } catch (Throwable jjte000) {\\n     if (jjtc000) {\\n       jjtree.clearNodeScope(jjtn000);\\n       jjtc000 = false;\\n     } else {\\n       jjtree.popNode();\\n     }\\n     if (jjte000 instanceof RuntimeException) {\\n       {if (true) throw (RuntimeException)jjte000;}\\n     }\\n     if (jjte000 instanceof ParseException) {\\n       {if (true) throw (ParseException)jjte000;}\\n     }\\n     {if (true) throw (Error)jjte000;}\\n    } finally {\\n     if (jjtc000) {\\n       jjtree.closeNodeScope(jjtn000, true);\\n       jjtreeCloseNodeScope(jjtn000);\\n     }\\n    }\\n  }\\n  final public void PrimaryPrefix() throws ParseException {\\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n    case FALSE:\\n    case NULL:\\n    case TRUE:\\n    case VOID:\\n    case INTEGER_LITERAL:\\n    case FLOATING_POINT_LITERAL:\\n    case CHARACTER_LITERAL:\\n    case STRING_LITERAL:\\n      Literal();\\n      break;\\n    case LPAREN:\\n      jj_consume_token(LPAREN);\\n      Expression();\\n      jj_consume_token(RPAREN);\\n      break;\\n    case NEW:\\n      AllocationExpression();\\n      break;\\n    default:\\n      jj_la1[50] = jj_gen;\\n      if (jj_2_15(2147483647)) {\\n        MethodInvocation();\\n      } else if (jj_2_16(2147483647)) {\\n        Type();\\n      } else {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case IDENTIFIER:\\n          AmbiguousName();\\n          break;\\n        default:\\n          jj_la1[51] = jj_gen;\\n          jj_consume_token(-1);\\n          throw new ParseException();\\n        }\\n      }\\n    }\\n  }\\n  final public void PrimarySuffix() throws ParseException {\\n    BSHPrimarySuffix jjtn000 = new BSHPrimarySuffix(JJTPRIMARYSUFFIX);\\n    boolean jjtc000 = true;\\n    jjtree.openNodeScope(jjtn000);\\n    jjtreeOpenNodeScope(jjtn000);Token t = null;\\n    try {\\n      if (jj_2_17(2)) {\\n        jj_consume_token(DOT);\\n        jj_consume_token(CLASS);\\n                jjtree.closeNodeScope(jjtn000, true);\\n                jjtc000 = false;\\n                jjtreeCloseNodeScope(jjtn000);\\n        jjtn000.operation = BSHPrimarySuffix.CLASS;\\n      } else {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case LBRACKET:\\n          jj_consume_token(LBRACKET);\\n          Expression();\\n          jj_consume_token(RBRACKET);\\n                         jjtree.closeNodeScope(jjtn000, true);\\n                         jjtc000 = false;\\n                         jjtreeCloseNodeScope(jjtn000);\\n        jjtn000.operation = BSHPrimarySuffix.INDEX;\\n          break;\\n        case DOT:\\n          jj_consume_token(DOT);\\n          t = jj_consume_token(IDENTIFIER);\\n          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n          case LPAREN:\\n            Arguments();\\n            break;\\n          default:\\n            jj_la1[52] = jj_gen;\\n            ;\\n          }\\n                                         jjtree.closeNodeScope(jjtn000, true);\\n                                         jjtc000 = false;\\n                                         jjtreeCloseNodeScope(jjtn000);\\n        jjtn000.operation = BSHPrimarySuffix.NAME;\\n        jjtn000.field = t.image;\\n          break;\\n        case LBRACE:\\n          jj_consume_token(LBRACE);\\n          Expression();\\n          jj_consume_token(RBRACE);\\n                         jjtree.closeNodeScope(jjtn000, true);\\n                         jjtc000 = false;\\n                         jjtreeCloseNodeScope(jjtn000);\\n        jjtn000.operation = BSHPrimarySuffix.PROPERTY;\\n          break;\\n        default:\\n          jj_la1[53] = jj_gen;\\n          jj_consume_token(-1);\\n          throw new ParseException();\\n        }\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void LHSPrimaryPrefix() throws ParseException {\\n    AmbiguousName();\\n  }\\n  final public void LHSPrimaryExpression() throws ParseException {\\n  BSHLHSPrimaryExpression jjtn000 = new BSHLHSPrimaryExpression(JJTLHSPRIMARYEXPRESSION);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      LHSPrimaryPrefix();\\n      label_16:\\n      while (true) {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case LBRACE:\\n        case LBRACKET:\\n        case DOT:\\n          ;\\n          break;\\n        default:\\n          jj_la1[54] = jj_gen;\\n          break label_16;\\n        }\\n        LHSPrimarySuffix();\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void LHSPrimarySuffix() throws ParseException {\\n    BSHLHSPrimarySuffix jjtn000 = new BSHLHSPrimarySuffix(JJTLHSPRIMARYSUFFIX);\\n    boolean jjtc000 = true;\\n    jjtree.openNodeScope(jjtn000);\\n    jjtreeOpenNodeScope(jjtn000);Token t=null, t1, t2 = null;\\n    try {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case LBRACKET:\\n        jj_consume_token(LBRACKET);\\n        Expression();\\n        jj_consume_token(RBRACKET);\\n                         jjtree.closeNodeScope(jjtn000, true);\\n                         jjtc000 = false;\\n                         jjtreeCloseNodeScope(jjtn000);\\n        jjtn000.operation = BSHLHSPrimarySuffix.INDEX;\\n        break;\\n      case DOT:\\n        jj_consume_token(DOT);\\n        t1 = jj_consume_token(IDENTIFIER);\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case LPAREN:\\n          Arguments();\\n          jj_consume_token(DOT);\\n          t2 = jj_consume_token(IDENTIFIER);\\n          break;\\n        default:\\n          jj_la1[55] = jj_gen;\\n          ;\\n        }\\n                                                                jjtree.closeNodeScope(jjtn000, true);\\n                                                                jjtc000 = false;\\n                                                                jjtreeCloseNodeScope(jjtn000);\\n        jjtn000.operation = BSHLHSPrimarySuffix.NAME;\\n        if ( t2 == null )\\n            jjtn000.field = t1.image;\\n        else {\\n            jjtn000.method = t1.image;\\n            jjtn000.field = t2.image;\\n        }\\n        break;\\n      case LBRACE:\\n        jj_consume_token(LBRACE);\\n        Expression();\\n        jj_consume_token(RBRACE);\\n                         jjtree.closeNodeScope(jjtn000, true);\\n                         jjtc000 = false;\\n                         jjtreeCloseNodeScope(jjtn000);\\n        jjtn000.operation = BSHLHSPrimarySuffix.PROPERTY;\\n        break;\\n      default:\\n        jj_la1[56] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void Literal() throws ParseException {\\n    BSHLiteral jjtn000 = new BSHLiteral(JJTLITERAL);\\n    boolean jjtc000 = true;\\n    jjtree.openNodeScope(jjtn000);\\n    jjtreeOpenNodeScope(jjtn000);Token x;\\n    boolean b;\\n    String literal;\\n    char ch;\\n    try {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case INTEGER_LITERAL:\\n        x = jj_consume_token(INTEGER_LITERAL);\\n    jjtree.closeNodeScope(jjtn000, true);\\n    jjtc000 = false;\\n    jjtreeCloseNodeScope(jjtn000);\\n    literal = x.image;\\n    ch = literal.charAt(literal.length()-1);\\n    if(ch == 'l' || ch == 'L')\\n    {\\n        literal = literal.substring(0,literal.length()-1);\\n                        jjtn000.value = new Primitive( new Long( literal ) );\\n    }\\n    else\\n        jjtn000.value = new Primitive( Integer.decode( literal ) );\\n        break;\\n      case FLOATING_POINT_LITERAL:\\n        x = jj_consume_token(FLOATING_POINT_LITERAL);\\n    jjtree.closeNodeScope(jjtn000, true);\\n    jjtc000 = false;\\n    jjtreeCloseNodeScope(jjtn000);\\n    literal = x.image;\\n    ch = literal.charAt(literal.length()-1);\\n    if(ch == 'f' || ch == 'F')\\n    {\\n        literal = literal.substring(0,literal.length()-1);\\n        jjtn000.value = new Primitive( new Float( literal ) );\\n    }\\n    else\\n    {\\n        if(ch == 'd' || ch == 'D')\\n            literal = literal.substring(0,literal.length()-1);\\n        jjtn000.value = new Primitive( new Double( literal ) );\\n    }\\n        break;\\n      case CHARACTER_LITERAL:\\n        x = jj_consume_token(CHARACTER_LITERAL);\\n                            jjtree.closeNodeScope(jjtn000, true);\\n                            jjtc000 = false;\\n                            jjtreeCloseNodeScope(jjtn000);\\n                try {\\n                jjtn000.charSetup( x.image.substring(1, x.image.length() - 1) );\\n                } catch ( Exception e ) {\\n                        {if (true) throw new ParseException(\\\"Error parsing character: \\\"+x.image);}\\n                }\\n        break;\\n      case STRING_LITERAL:\\n        x = jj_consume_token(STRING_LITERAL);\\n                         jjtree.closeNodeScope(jjtn000, true);\\n                         jjtc000 = false;\\n                         jjtreeCloseNodeScope(jjtn000);\\n                try {\\n                        jjtn000.stringSetup( x.image.substring(1, x.image.length() - 1) );\\n                } catch ( Exception e ) {\\n                        {if (true) throw new ParseException(\\\"Error parsing string: \\\"+x.image);}\\n                }\\n        break;\\n      case FALSE:\\n      case TRUE:\\n        b = BooleanLiteral();\\n                          jjtree.closeNodeScope(jjtn000, true);\\n                          jjtc000 = false;\\n                          jjtreeCloseNodeScope(jjtn000);\\n    jjtn000.value = new Primitive( new Boolean(b) );\\n        break;\\n      case NULL:\\n        NullLiteral();\\n                  jjtree.closeNodeScope(jjtn000, true);\\n                  jjtc000 = false;\\n                  jjtreeCloseNodeScope(jjtn000);\\n    jjtn000.value = Primitive.NULL;\\n        break;\\n      case VOID:\\n        VoidLiteral();\\n                 jjtree.closeNodeScope(jjtn000, true);\\n                 jjtc000 = false;\\n                 jjtreeCloseNodeScope(jjtn000);\\n    jjtn000.value = Primitive.VOID;\\n        break;\\n      default:\\n        jj_la1[57] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public boolean BooleanLiteral() throws ParseException {\\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n    case TRUE:\\n      jj_consume_token(TRUE);\\n           {if (true) return true;}\\n      break;\\n    case FALSE:\\n      jj_consume_token(FALSE);\\n            {if (true) return false;}\\n      break;\\n    default:\\n      jj_la1[58] = jj_gen;\\n      jj_consume_token(-1);\\n      throw new ParseException();\\n    }\\n    throw new Error(\\\"Missing return statement in function\\\");\\n  }\\n  final public void NullLiteral() throws ParseException {\\n    jj_consume_token(NULL);\\n  }\\n  final public void VoidLiteral() throws ParseException {\\n    jj_consume_token(VOID);\\n  }\\n  final public void Arguments() throws ParseException {\\n  BSHArguments jjtn000 = new BSHArguments(JJTARGUMENTS);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(LPAREN);\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FALSE:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case NEW:\\n      case NULL:\\n      case SHORT:\\n      case TRUE:\\n      case VOID:\\n      case INTEGER_LITERAL:\\n      case FLOATING_POINT_LITERAL:\\n      case CHARACTER_LITERAL:\\n      case STRING_LITERAL:\\n      case IDENTIFIER:\\n      case LPAREN:\\n      case BANG:\\n      case TILDE:\\n      case INCR:\\n      case DECR:\\n      case PLUS:\\n      case MINUS:\\n        ArgumentList();\\n        break;\\n      default:\\n        jj_la1[59] = jj_gen;\\n        ;\\n      }\\n      jj_consume_token(RPAREN);\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void ArgumentList() throws ParseException {\\n    Expression();\\n    label_17:\\n    while (true) {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case COMMA:\\n        ;\\n        break;\\n      default:\\n        jj_la1[60] = jj_gen;\\n        break label_17;\\n      }\\n      jj_consume_token(COMMA);\\n      Expression();\\n    }\\n  }\\n  final public void AllocationExpression() throws ParseException {\\n  BSHAllocationExpression jjtn000 = new BSHAllocationExpression(JJTALLOCATIONEXPRESSION);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      if (jj_2_19(2)) {\\n        jj_consume_token(NEW);\\n        PrimitiveType();\\n        ArrayDimensions();\\n      } else {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case NEW:\\n          jj_consume_token(NEW);\\n          AmbiguousName();\\n          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n          case LBRACKET:\\n            ArrayDimensions();\\n            break;\\n          case LPAREN:\\n            Arguments();\\n            if (jj_2_18(2)) {\\n              Block();\\n            } else {\\n              ;\\n            }\\n            break;\\n          default:\\n            jj_la1[61] = jj_gen;\\n            jj_consume_token(-1);\\n            throw new ParseException();\\n          }\\n          break;\\n        default:\\n          jj_la1[62] = jj_gen;\\n          jj_consume_token(-1);\\n          throw new ParseException();\\n        }\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void ArrayDimensions() throws ParseException {\\n  BSHArrayDimensions jjtn000 = new BSHArrayDimensions(JJTARRAYDIMENSIONS);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      if (jj_2_21(2)) {\\n        label_18:\\n        while (true) {\\n          jj_consume_token(LBRACKET);\\n          Expression();\\n          jj_consume_token(RBRACKET);\\n                                        jjtn000.addArrayDimension();\\n          if (jj_2_20(2)) {\\n            ;\\n          } else {\\n            break label_18;\\n          }\\n        }\\n      } else {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case LBRACKET:\\n          label_19:\\n          while (true) {\\n            jj_consume_token(LBRACKET);\\n            jj_consume_token(RBRACKET);\\n              jjtn000.addArrayDimension();\\n            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n            case LBRACKET:\\n              ;\\n              break;\\n            default:\\n              jj_la1[63] = jj_gen;\\n              break label_19;\\n            }\\n          }\\n          ArrayInitializer();\\n          break;\\n        default:\\n          jj_la1[64] = jj_gen;\\n          jj_consume_token(-1);\\n          throw new ParseException();\\n        }\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void Statement() throws ParseException {\\n    if (jj_2_22(2)) {\\n      LabeledStatement();\\n    } else {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case LBRACE:\\n        Block();\\n        break;\\n      case SEMICOLON:\\n        EmptyStatement();\\n        break;\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FALSE:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case NEW:\\n      case NULL:\\n      case SHORT:\\n      case TRUE:\\n      case VOID:\\n      case INTEGER_LITERAL:\\n      case FLOATING_POINT_LITERAL:\\n      case CHARACTER_LITERAL:\\n      case STRING_LITERAL:\\n      case IDENTIFIER:\\n      case LPAREN:\\n      case INCR:\\n      case DECR:\\n        StatementExpression();\\n        jj_consume_token(SEMICOLON);\\n        break;\\n      case SWITCH:\\n        SwitchStatement();\\n        break;\\n      case IF:\\n        IfStatement();\\n        break;\\n      case WHILE:\\n        WhileStatement();\\n        break;\\n      case DO:\\n        DoStatement();\\n        break;\\n      case FOR:\\n        ForStatement();\\n        break;\\n      case BREAK:\\n        BreakStatement();\\n        break;\\n      case CONTINUE:\\n        ContinueStatement();\\n        break;\\n      case RETURN:\\n        ReturnStatement();\\n        break;\\n      case THROW:\\n        ThrowStatement();\\n        break;\\n      case TRY:\\n        TryStatement();\\n        break;\\n      default:\\n        jj_la1[65] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n    }\\n  }\\n  final public void LabeledStatement() throws ParseException {\\n    jj_consume_token(IDENTIFIER);\\n    jj_consume_token(COLON);\\n    Statement();\\n  }\\n  final public void Block() throws ParseException {\\n  BSHBlock jjtn000 = new BSHBlock(JJTBLOCK);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(LBRACE);\\n      label_20:\\n      while (true) {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case BOOLEAN:\\n        case BREAK:\\n        case BYTE:\\n        case CHAR:\\n        case CONTINUE:\\n        case DO:\\n        case DOUBLE:\\n        case FALSE:\\n        case FINAL:\\n        case FLOAT:\\n        case FOR:\\n        case IF:\\n        case IMPORT:\\n        case INT:\\n        case LONG:\\n        case NEW:\\n        case NULL:\\n        case RETURN:\\n        case SHORT:\\n        case SWITCH:\\n        case THROW:\\n        case TRUE:\\n        case TRY:\\n        case VOID:\\n        case WHILE:\\n        case INTEGER_LITERAL:\\n        case FLOATING_POINT_LITERAL:\\n        case CHARACTER_LITERAL:\\n        case STRING_LITERAL:\\n        case FORMAL_COMMENT:\\n        case IDENTIFIER:\\n        case LPAREN:\\n        case LBRACE:\\n        case SEMICOLON:\\n        case INCR:\\n        case DECR:\\n          ;\\n          break;\\n        default:\\n          jj_la1[66] = jj_gen;\\n          break label_20;\\n        }\\n        BlockStatement();\\n      }\\n      jj_consume_token(RBRACE);\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void BlockStatement() throws ParseException {\\n    if (jj_2_23(2147483647)) {\\n      MethodDeclaration();\\n    } else if (jj_2_24(2147483647)) {\\n      TypedVariableDeclaration();\\n      jj_consume_token(SEMICOLON);\\n    } else {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n      case BREAK:\\n      case BYTE:\\n      case CHAR:\\n      case CONTINUE:\\n      case DO:\\n      case DOUBLE:\\n      case FALSE:\\n      case FLOAT:\\n      case FOR:\\n      case IF:\\n      case INT:\\n      case LONG:\\n      case NEW:\\n      case NULL:\\n      case RETURN:\\n      case SHORT:\\n      case SWITCH:\\n      case THROW:\\n      case TRUE:\\n      case TRY:\\n      case VOID:\\n      case WHILE:\\n      case INTEGER_LITERAL:\\n      case FLOATING_POINT_LITERAL:\\n      case CHARACTER_LITERAL:\\n      case STRING_LITERAL:\\n      case IDENTIFIER:\\n      case LPAREN:\\n      case LBRACE:\\n      case SEMICOLON:\\n      case INCR:\\n      case DECR:\\n        Statement();\\n        break;\\n      case IMPORT:\\n        ImportDeclaration();\\n        break;\\n      case FORMAL_COMMENT:\\n        FormalComment();\\n        break;\\n      default:\\n        jj_la1[67] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n    }\\n  }\\n  final public void FormalComment() throws ParseException {\\n        BSHFormalComment jjtn000 = new BSHFormalComment(JJTFORMALCOMMENT);\\n        boolean jjtc000 = true;\\n        jjtree.openNodeScope(jjtn000);\\n        jjtreeOpenNodeScope(jjtn000);Token t;\\n    try {\\n      t = jj_consume_token(FORMAL_COMMENT);\\n                              jjtree.closeNodeScope(jjtn000,  retainComments);\\n                              jjtc000 = false;\\n                              jjtreeCloseNodeScope(jjtn000);\\n                jjtn000.text=t.image;\\n    } finally {\\n          if (jjtc000) {\\n            jjtree.closeNodeScope(jjtn000,  retainComments);\\n            jjtreeCloseNodeScope(jjtn000);\\n          }\\n    }\\n  }\\n  final public void EmptyStatement() throws ParseException {\\n    jj_consume_token(SEMICOLON);\\n  }\\n  final public void StatementExpression() throws ParseException {\\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n    case INCR:\\n      PreIncrementExpression();\\n      break;\\n    case DECR:\\n      PreDecrementExpression();\\n      break;\\n    default:\\n      jj_la1[68] = jj_gen;\\n      if (jj_2_25(2147483647)) {\\n        Assignment();\\n      } else {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case BOOLEAN:\\n        case BYTE:\\n        case CHAR:\\n        case DOUBLE:\\n        case FALSE:\\n        case FLOAT:\\n        case INT:\\n        case LONG:\\n        case NEW:\\n        case NULL:\\n        case SHORT:\\n        case TRUE:\\n        case VOID:\\n        case INTEGER_LITERAL:\\n        case FLOATING_POINT_LITERAL:\\n        case CHARACTER_LITERAL:\\n        case STRING_LITERAL:\\n        case IDENTIFIER:\\n        case LPAREN:\\n          PostfixExpression();\\n          break;\\n        default:\\n          jj_la1[69] = jj_gen;\\n          jj_consume_token(-1);\\n          throw new ParseException();\\n        }\\n      }\\n    }\\n  }\\n  final public void SwitchStatement() throws ParseException {\\n  BSHSwitchStatement jjtn000 = new BSHSwitchStatement(JJTSWITCHSTATEMENT);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(SWITCH);\\n      jj_consume_token(LPAREN);\\n      Expression();\\n      jj_consume_token(RPAREN);\\n      jj_consume_token(LBRACE);\\n      label_21:\\n      while (true) {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case CASE:\\n        case _DEFAULT:\\n          ;\\n          break;\\n        default:\\n          jj_la1[70] = jj_gen;\\n          break label_21;\\n        }\\n        SwitchLabel();\\n        label_22:\\n        while (true) {\\n          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n          case BOOLEAN:\\n          case BREAK:\\n          case BYTE:\\n          case CHAR:\\n          case CONTINUE:\\n          case DO:\\n          case DOUBLE:\\n          case FALSE:\\n          case FINAL:\\n          case FLOAT:\\n          case FOR:\\n          case IF:\\n          case IMPORT:\\n          case INT:\\n          case LONG:\\n          case NEW:\\n          case NULL:\\n          case RETURN:\\n          case SHORT:\\n          case SWITCH:\\n          case THROW:\\n          case TRUE:\\n          case TRY:\\n          case VOID:\\n          case WHILE:\\n          case INTEGER_LITERAL:\\n          case FLOATING_POINT_LITERAL:\\n          case CHARACTER_LITERAL:\\n          case STRING_LITERAL:\\n          case FORMAL_COMMENT:\\n          case IDENTIFIER:\\n          case LPAREN:\\n          case LBRACE:\\n          case SEMICOLON:\\n          case INCR:\\n          case DECR:\\n            ;\\n            break;\\n          default:\\n            jj_la1[71] = jj_gen;\\n            break label_22;\\n          }\\n          BlockStatement();\\n        }\\n      }\\n      jj_consume_token(RBRACE);\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void SwitchLabel() throws ParseException {\\n  BSHSwitchLabel jjtn000 = new BSHSwitchLabel(JJTSWITCHLABEL);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case CASE:\\n        jj_consume_token(CASE);\\n        Expression();\\n        jj_consume_token(COLON);\\n        break;\\n      case _DEFAULT:\\n        jj_consume_token(_DEFAULT);\\n        jj_consume_token(COLON);\\n                  jjtree.closeNodeScope(jjtn000, true);\\n                  jjtc000 = false;\\n                  jjtreeCloseNodeScope(jjtn000);\\n                  jjtn000.isDefault = true;\\n        break;\\n      default:\\n        jj_la1[72] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void IfStatement() throws ParseException {\\n  BSHIfStatement jjtn000 = new BSHIfStatement(JJTIFSTATEMENT);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(IF);\\n      jj_consume_token(LPAREN);\\n      Expression();\\n      jj_consume_token(RPAREN);\\n      Statement();\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case ELSE:\\n        jj_consume_token(ELSE);\\n        Statement();\\n        break;\\n      default:\\n        jj_la1[73] = jj_gen;\\n        ;\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void WhileStatement() throws ParseException {\\n  BSHWhileStatement jjtn000 = new BSHWhileStatement(JJTWHILESTATEMENT);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(WHILE);\\n      jj_consume_token(LPAREN);\\n      Expression();\\n      jj_consume_token(RPAREN);\\n      Statement();\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void DoStatement() throws ParseException {\\n  BSHWhileStatement jjtn000 = new BSHWhileStatement(JJTWHILESTATEMENT);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(DO);\\n      Statement();\\n      jj_consume_token(WHILE);\\n      jj_consume_token(LPAREN);\\n      Expression();\\n      jj_consume_token(RPAREN);\\n      jj_consume_token(SEMICOLON);\\n          jjtree.closeNodeScope(jjtn000, true);\\n          jjtc000 = false;\\n          jjtreeCloseNodeScope(jjtn000);\\n          jjtn000.isDoStatement=true;\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void ForStatement() throws ParseException {\\n  BSHForStatement jjtn000 = new BSHForStatement(JJTFORSTATEMENT);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(FOR);\\n      jj_consume_token(LPAREN);\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FALSE:\\n      case FINAL:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case NEW:\\n      case NULL:\\n      case SHORT:\\n      case TRUE:\\n      case VOID:\\n      case INTEGER_LITERAL:\\n      case FLOATING_POINT_LITERAL:\\n      case CHARACTER_LITERAL:\\n      case STRING_LITERAL:\\n      case IDENTIFIER:\\n      case LPAREN:\\n      case INCR:\\n      case DECR:\\n        ForInit();\\n                          jjtn000.hasForInit=true;\\n        break;\\n      default:\\n        jj_la1[74] = jj_gen;\\n        ;\\n      }\\n      jj_consume_token(SEMICOLON);\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FALSE:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case NEW:\\n      case NULL:\\n      case SHORT:\\n      case TRUE:\\n      case VOID:\\n      case INTEGER_LITERAL:\\n      case FLOATING_POINT_LITERAL:\\n      case CHARACTER_LITERAL:\\n      case STRING_LITERAL:\\n      case IDENTIFIER:\\n      case LPAREN:\\n      case BANG:\\n      case TILDE:\\n      case INCR:\\n      case DECR:\\n      case PLUS:\\n      case MINUS:\\n        Expression();\\n                         jjtn000.hasExpression=true;\\n        break;\\n      default:\\n        jj_la1[75] = jj_gen;\\n        ;\\n      }\\n      jj_consume_token(SEMICOLON);\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FALSE:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case NEW:\\n      case NULL:\\n      case SHORT:\\n      case TRUE:\\n      case VOID:\\n      case INTEGER_LITERAL:\\n      case FLOATING_POINT_LITERAL:\\n      case CHARACTER_LITERAL:\\n      case STRING_LITERAL:\\n      case IDENTIFIER:\\n      case LPAREN:\\n      case INCR:\\n      case DECR:\\n        ForUpdate();\\n                        jjtn000.hasForUpdate=true;\\n        break;\\n      default:\\n        jj_la1[76] = jj_gen;\\n        ;\\n      }\\n      jj_consume_token(RPAREN);\\n      Statement();\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void ForInit() throws ParseException {\\n  Token t = null;\\n    if (jj_2_26(2147483647)) {\\n      TypedVariableDeclaration();\\n    } else {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FALSE:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case NEW:\\n      case NULL:\\n      case SHORT:\\n      case TRUE:\\n      case VOID:\\n      case INTEGER_LITERAL:\\n      case FLOATING_POINT_LITERAL:\\n      case CHARACTER_LITERAL:\\n      case STRING_LITERAL:\\n      case IDENTIFIER:\\n      case LPAREN:\\n      case INCR:\\n      case DECR:\\n        StatementExpressionList();\\n        break;\\n      default:\\n        jj_la1[77] = jj_gen;\\n        jj_consume_token(-1);\\n        throw new ParseException();\\n      }\\n    }\\n  }\\n  final public void TypedVariableDeclaration() throws ParseException {\\n        BSHTypedVariableDeclaration jjtn000 = new BSHTypedVariableDeclaration(JJTTYPEDVARIABLEDECLARATION);\\n        boolean jjtc000 = true;\\n        jjtree.openNodeScope(jjtn000);\\n        jjtreeOpenNodeScope(jjtn000);Token t = null;\\n    try {\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case FINAL:\\n        t = jj_consume_token(FINAL);\\n        break;\\n      default:\\n        jj_la1[78] = jj_gen;\\n        ;\\n      }\\n      Type();\\n      VariableDeclarator();\\n      label_23:\\n      while (true) {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case COMMA:\\n          ;\\n          break;\\n        default:\\n          jj_la1[79] = jj_gen;\\n          break label_23;\\n        }\\n        jj_consume_token(COMMA);\\n        VariableDeclarator();\\n      }\\n          jjtree.closeNodeScope(jjtn000, true);\\n          jjtc000 = false;\\n          jjtreeCloseNodeScope(jjtn000);\\n        jjtn000.isFinal = (t!=null);\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void StatementExpressionList() throws ParseException {\\n  BSHStatementExpressionList jjtn000 = new BSHStatementExpressionList(JJTSTATEMENTEXPRESSIONLIST);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      StatementExpression();\\n      label_24:\\n      while (true) {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case COMMA:\\n          ;\\n          break;\\n        default:\\n          jj_la1[80] = jj_gen;\\n          break label_24;\\n        }\\n        jj_consume_token(COMMA);\\n        StatementExpression();\\n      }\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void ForUpdate() throws ParseException {\\n    StatementExpressionList();\\n  }\\n  final public void BreakStatement() throws ParseException {\\n  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(BREAK);\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case IDENTIFIER:\\n        jj_consume_token(IDENTIFIER);\\n        break;\\n      default:\\n        jj_la1[81] = jj_gen;\\n        ;\\n      }\\n      jj_consume_token(SEMICOLON);\\n                                 jjtree.closeNodeScope(jjtn000, true);\\n                                 jjtc000 = false;\\n                                 jjtreeCloseNodeScope(jjtn000);\\n                                 jjtn000.kind = BREAK;\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void ContinueStatement() throws ParseException {\\n  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(CONTINUE);\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case IDENTIFIER:\\n        jj_consume_token(IDENTIFIER);\\n        break;\\n      default:\\n        jj_la1[82] = jj_gen;\\n        ;\\n      }\\n      jj_consume_token(SEMICOLON);\\n                                    jjtree.closeNodeScope(jjtn000, true);\\n                                    jjtc000 = false;\\n                                    jjtreeCloseNodeScope(jjtn000);\\n                                    jjtn000.kind = CONTINUE;\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void ReturnStatement() throws ParseException {\\n  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(RETURN);\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case BOOLEAN:\\n      case BYTE:\\n      case CHAR:\\n      case DOUBLE:\\n      case FALSE:\\n      case FLOAT:\\n      case INT:\\n      case LONG:\\n      case NEW:\\n      case NULL:\\n      case SHORT:\\n      case TRUE:\\n      case VOID:\\n      case INTEGER_LITERAL:\\n      case FLOATING_POINT_LITERAL:\\n      case CHARACTER_LITERAL:\\n      case STRING_LITERAL:\\n      case IDENTIFIER:\\n      case LPAREN:\\n      case BANG:\\n      case TILDE:\\n      case INCR:\\n      case DECR:\\n      case PLUS:\\n      case MINUS:\\n        Expression();\\n        break;\\n      default:\\n        jj_la1[83] = jj_gen;\\n        ;\\n      }\\n      jj_consume_token(SEMICOLON);\\n                                  jjtree.closeNodeScope(jjtn000, true);\\n                                  jjtc000 = false;\\n                                  jjtreeCloseNodeScope(jjtn000);\\n                                  jjtn000.kind = RETURN;\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void ThrowStatement() throws ParseException {\\n  BSHThrowStatement jjtn000 = new BSHThrowStatement(JJTTHROWSTATEMENT);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);\\n    try {\\n      jj_consume_token(THROW);\\n      Expression();\\n      jj_consume_token(SEMICOLON);\\n    } catch (Throwable jjte000) {\\n    if (jjtc000) {\\n      jjtree.clearNodeScope(jjtn000);\\n      jjtc000 = false;\\n    } else {\\n      jjtree.popNode();\\n    }\\n    if (jjte000 instanceof RuntimeException) {\\n      {if (true) throw (RuntimeException)jjte000;}\\n    }\\n    if (jjte000 instanceof ParseException) {\\n      {if (true) throw (ParseException)jjte000;}\\n    }\\n    {if (true) throw (Error)jjte000;}\\n    } finally {\\n    if (jjtc000) {\\n      jjtree.closeNodeScope(jjtn000, true);\\n      jjtreeCloseNodeScope(jjtn000);\\n    }\\n    }\\n  }\\n  final public void TryStatement() throws ParseException {\\n  BSHTryStatement jjtn000 = new BSHTryStatement(JJTTRYSTATEMENT);\\n  boolean jjtc000 = true;\\n  jjtree.openNodeScope(jjtn000);\\n  jjtreeOpenNodeScope(jjtn000);boolean closed = false;\\n    try {\\n      jj_consume_token(TRY);\\n      Block();\\n      label_25:\\n      while (true) {\\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n        case CATCH:\\n          ;\\n          break;\\n        default:\\n          jj_la1[84] = jj_gen;\\n          break label_25;\\n        }\\n        jj_consume_token(CATCH);\\n        jj_consume_token(LPAREN);\\n        FormalParameter();\\n        jj_consume_token(RPAREN);\\n        Block();\\n                                                      closed = true;\\n      }\\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\\n      case FINALLY:\\n        jj_consume_token(FINALLY);\\n        Block();\\n                              closed = true;\\n        break;\\n      default:\\n        jj_la1[85] = jj_gen;\\n        ;\\n      }\\n          jjtree.closeNodeScope(jjtn000, true);\\n          jjtc000 = false;\\n          jjtreeCloseNodeScope(jjtn000);\\n                if ( !closed ) {if (true) throw generateParseException();}\\n    } catch (Throwable jjte000) {\\n          if (jjtc000) {\\n            jjtree.clearNodeScope(jjtn000);\\n            jjtc000 = false;\\n          } else {\\n            jjtree.popNode();\\n          }\\n          if (jjte000 instanceof RuntimeException) {\\n            {if (true) throw (RuntimeException)jjte000;}\\n          }\\n          if (jjte000 instanceof ParseException) {\\n            {if (true) throw (ParseException)jjte000;}\\n          }\\n          {if (true) throw (Error)jjte000;}\\n    } finally {\\n          if (jjtc000) {\\n            jjtree.closeNodeScope(jjtn000, true);\\n            jjtreeCloseNodeScope(jjtn000);\\n          }\\n    }\\n  }\\n  final private boolean jj_2_1(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_1();\\n    jj_save(0, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_2(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_2();\\n    jj_save(1, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_3(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_3();\\n    jj_save(2, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_4(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_4();\\n    jj_save(3, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_5(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_5();\\n    jj_save(4, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_6(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_6();\\n    jj_save(5, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_7(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_7();\\n    jj_save(6, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_8(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_8();\\n    jj_save(7, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_9(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_9();\\n    jj_save(8, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_10(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_10();\\n    jj_save(9, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_11(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_11();\\n    jj_save(10, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_12(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_12();\\n    jj_save(11, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_13(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_13();\\n    jj_save(12, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_14(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_14();\\n    jj_save(13, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_15(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_15();\\n    jj_save(14, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_16(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_16();\\n    jj_save(15, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_17(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_17();\\n    jj_save(16, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_18(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_18();\\n    jj_save(17, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_19(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_19();\\n    jj_save(18, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_20(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_20();\\n    jj_save(19, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_21(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_21();\\n    jj_save(20, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_22(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_22();\\n    jj_save(21, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_23(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_23();\\n    jj_save(22, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_24(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_24();\\n    jj_save(23, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_25(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_25();\\n    jj_save(24, xla);\\n    return retval;\\n  }\\n  final private boolean jj_2_26(int xla) {\\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\\n    boolean retval = !jj_3_26();\\n    jj_save(25, xla);\\n    return retval;\\n  }\\n  final private boolean jj_3R_196() {\\n    if (jj_3R_84()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_11() {\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_34()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_33() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3_11()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_68()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_69()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_280() {\\n    if (jj_scan_token(BANG)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_195() {\\n    if (jj_3R_202()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_194() {\\n    if (jj_3R_201()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_178() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_194()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_195()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_196()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_197()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_275() {\\n    if (jj_3R_203()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_260() {\\n    if (jj_scan_token(MOD)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_274() {\\n    if (jj_3R_281()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_279() {\\n    if (jj_scan_token(TILDE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_273() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_279()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_280()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_240()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_267() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_273()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_274()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_275()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_259() {\\n    if (jj_scan_token(SLASH)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_177() {\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_235() {\\n    if (jj_scan_token(RSIGNEDSHIFTX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_138() {\\n    if (jj_scan_token(FORMAL_COMMENT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_202() {\\n    if (jj_scan_token(DECR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_31()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_258() {\\n    if (jj_scan_token(STAR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_241() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_258()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_259()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_260()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_240()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_201() {\\n    if (jj_scan_token(INCR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_31()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_234() {\\n    if (jj_scan_token(RSIGNEDSHIFT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_266() {\\n    if (jj_scan_token(MINUS)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_41() {\\n    if (jj_scan_token(FINAL)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_117() {\\n    if (jj_3R_138()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_257() {\\n    if (jj_3R_267()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_227() {\\n    if (jj_scan_token(GEX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_24() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_41()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_30()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_116() {\\n    if (jj_3R_137()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_256() {\\n    if (jj_3R_202()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_23() {\\n    if (jj_3R_40()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_255() {\\n    if (jj_3R_201()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_265() {\\n    if (jj_scan_token(PLUS)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_223() {\\n    if (jj_scan_token(GTX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_254() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_265()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_266()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_240()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_240() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_254()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_255()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_256()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_257()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_115() {\\n    if (jj_3R_136()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_243() {\\n    if (jj_scan_token(MINUS)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_114() {\\n    if (jj_3R_135()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_226() {\\n    if (jj_scan_token(GE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_97() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_113()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_114()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_115()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_116()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_117()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_113() {\\n    if (jj_3R_134()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_237() {\\n    if (jj_scan_token(RUNSIGNEDSHIFTX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_230() {\\n    if (jj_3R_240()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_241()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_222() {\\n    if (jj_scan_token(GT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_79() {\\n    if (jj_3R_97()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_233() {\\n    if (jj_scan_token(LSHIFTX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_242() {\\n    if (jj_scan_token(PLUS)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_231() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_242()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_243()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_230()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_215() {\\n    if (jj_scan_token(NE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_38() {\\n    if (jj_scan_token(LBRACE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_79()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    if (jj_scan_token(RBRACE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_218() {\\n    if (jj_3R_230()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_231()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_225() {\\n    if (jj_scan_token(LEX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_236() {\\n    if (jj_scan_token(RUNSIGNEDSHIFT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_232() {\\n    if (jj_scan_token(LSHIFT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_221() {\\n    if (jj_scan_token(LTX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_39() {\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(COLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_136()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_219() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_232()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_233()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_234()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_235()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_236()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_237()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_218()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_214() {\\n    if (jj_scan_token(EQ)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_216() {\\n    if (jj_3R_218()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_219()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_207() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_214()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_215()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_206()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_165() {\\n    if (jj_3R_188()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_164() {\\n    if (jj_3R_187()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_224() {\\n    if (jj_scan_token(LE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_220() {\\n    if (jj_scan_token(LT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_163() {\\n    if (jj_3R_186()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_217() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_220()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_221()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_222()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_223()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_224()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_225()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_226()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_227()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_216()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_162() {\\n    if (jj_3R_185()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_161() {\\n    if (jj_3R_184()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_212() {\\n    if (jj_3R_216()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_217()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_160() {\\n    if (jj_3R_183()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_159() {\\n    if (jj_3R_182()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_213() {\\n    if (jj_scan_token(INSTANCEOF)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_30()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_158() {\\n    if (jj_3R_181()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_206() {\\n    if (jj_3R_212()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_213()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_157() {\\n    if (jj_3R_180()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_209() {\\n    if (jj_scan_token(BIT_ANDX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_156() {\\n    if (jj_3R_179()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_155() {\\n    if (jj_3R_178()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_18() {\\n    if (jj_3R_38()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_191() {\\n    if (jj_scan_token(XOR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_190()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_154() {\\n    if (jj_3R_177()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_199() {\\n    if (jj_3R_206()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_207()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_153() {\\n    if (jj_3R_38()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_61() {\\n    if (jj_scan_token(ORASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_22() {\\n    if (jj_3R_39()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_136() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3_22()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_153()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_154()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_155()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_156()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_157()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_158()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_159()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_160()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_161()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_162()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_163()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_164()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_165()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_208() {\\n    if (jj_scan_token(BIT_AND)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_200() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_208()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_209()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_199()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_190() {\\n    if (jj_3R_199()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_200()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_60() {\\n    if (jj_scan_token(XORASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_193() {\\n    if (jj_scan_token(BIT_ORX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_170() {\\n    if (jj_3R_78()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3_18()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_198() {\\n    if (jj_scan_token(LBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_189() {\\n    Token xsp;\\n    if (jj_3R_198()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_198()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    if (jj_3R_88()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_169() {\\n    if (jj_3R_168()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_20() {\\n    if (jj_scan_token(LBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_171() {\\n    if (jj_3R_190()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_191()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_59() {\\n    if (jj_scan_token(ANDASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_168() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3_21()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_189()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_65() {\\n    if (jj_scan_token(RSIGNEDSHIFTASSIGNX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_21() {\\n    Token xsp;\\n    if (jj_3_20()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3_20()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_174() {\\n    if (jj_scan_token(BOOL_ANDX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_192() {\\n    if (jj_scan_token(BIT_OR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_107() {\\n    if (jj_scan_token(HOOK)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(COLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_85()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_172() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_192()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_193()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_171()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_58() {\\n    if (jj_scan_token(MINUSASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_143() {\\n    if (jj_3R_171()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_172()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_64() {\\n    if (jj_scan_token(RSIGNEDSHIFTASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_146() {\\n    if (jj_scan_token(BOOL_ORX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_173() {\\n    if (jj_scan_token(BOOL_AND)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_141() {\\n    if (jj_scan_token(NEW)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_28()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_169()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_170()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_57() {\\n    if (jj_scan_token(PLUSASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_144() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_173()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_174()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_143()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_19() {\\n    if (jj_scan_token(NEW)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_34()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_168()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_119() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3_19()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_141()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_123() {\\n    if (jj_3R_143()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_144()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_133() {\\n    if (jj_scan_token(COMMA)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_56() {\\n    if (jj_scan_token(MODASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_145() {\\n    if (jj_scan_token(BOOL_OR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_112() {\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_133()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_124() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_145()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_146()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_123()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_96() {\\n    if (jj_3R_112()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_106() {\\n    if (jj_3R_123()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_124()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_55() {\\n    if (jj_scan_token(SLASHASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_67() {\\n    if (jj_scan_token(RUNSIGNEDSHIFTASSIGNX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_78() {\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_96()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_63() {\\n    if (jj_scan_token(LSHIFTASSIGNX)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_85() {\\n    if (jj_3R_106()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_107()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_54() {\\n    if (jj_scan_token(STARASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_149() {\\n    if (jj_scan_token(VOID)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_66() {\\n    if (jj_scan_token(RUNSIGNEDSHIFTASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_62() {\\n    if (jj_scan_token(LSHIFTASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_53() {\\n    if (jj_scan_token(ASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_148() {\\n    if (jj_scan_token(NULL)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_32() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_53()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_54()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_55()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_56()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_57()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_58()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_59()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_60()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_61()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_62()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_63()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_64()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_65()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_66()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_67()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_176() {\\n    if (jj_scan_token(FALSE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_175() {\\n    if (jj_scan_token(TRUE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_147() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_175()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_176()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_9() {\\n    if (jj_3R_31()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_32()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_84() {\\n    if (jj_3R_31()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_32()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_132() {\\n    if (jj_3R_149()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_45() {\\n    if (jj_3R_85()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_131() {\\n    if (jj_3R_148()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_44() {\\n    if (jj_3R_84()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_26() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_44()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_45()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_130() {\\n    if (jj_3R_147()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_129() {\\n    if (jj_scan_token(STRING_LITERAL)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_8() {\\n    if (jj_scan_token(DOT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_128() {\\n    if (jj_scan_token(CHARACTER_LITERAL)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_28() {\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3_8()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_205() {\\n    if (jj_scan_token(COMMA)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_77() {\\n    if (jj_scan_token(DOUBLE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_127() {\\n    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_76() {\\n    if (jj_scan_token(FLOAT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_75() {\\n    if (jj_scan_token(LONG)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_74() {\\n    if (jj_scan_token(INT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_50() {\\n    if (jj_3R_28()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_73() {\\n    if (jj_scan_token(SHORT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_72() {\\n    if (jj_scan_token(BYTE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_71() {\\n    if (jj_scan_token(CHAR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_70() {\\n    if (jj_scan_token(BOOLEAN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_34() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_70()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_71()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_72()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_73()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_74()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_75()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_76()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_77()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_87() {\\n    if (jj_3R_30()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_46() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_86()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_87()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_86() {\\n    if (jj_scan_token(VOID)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_7() {\\n    if (jj_scan_token(LBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_111() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_126()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_127()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_128()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_129()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_130()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_131()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_132()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_126() {\\n    if (jj_scan_token(INTEGER_LITERAL)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_125() {\\n    if (jj_3R_78()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(DOT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_49() {\\n    if (jj_3R_34()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_30() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_49()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_50()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3_7()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_140() {\\n    if (jj_scan_token(COMMA)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_139()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_110() {\\n    if (jj_scan_token(LBRACE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RBRACE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_167() {\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_253() {\\n    if (jj_scan_token(FINALLY)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_38()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_6() {\\n    if (jj_3R_30()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_52() {\\n    if (jj_3R_89()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_252() {\\n    if (jj_scan_token(CATCH)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_139()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_38()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_139() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3_6()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_167()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_109() {\\n    if (jj_scan_token(DOT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_125()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_188() {\\n    if (jj_scan_token(TRY)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_38()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_252()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    xsp = jj_scanpos;\\n    if (jj_3R_253()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_5() {\\n    if (jj_scan_token(COMMA)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_29()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_118() {\\n    if (jj_3R_139()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_140()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_108() {\\n    if (jj_scan_token(LBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_89() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_108()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_109()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_110()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_251() {\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_98() {\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_118()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_204() {\\n    if (jj_3R_29()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3_5()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_250() {\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_187() {\\n    if (jj_scan_token(THROW)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_31() {\\n    if (jj_3R_51()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_52()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_229() {\\n    if (jj_scan_token(COMMA)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_228()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_88() {\\n    if (jj_scan_token(LBRACE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_204()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    xsp = jj_scanpos;\\n    if (jj_3R_205()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RBRACE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_278() {\\n    if (jj_scan_token(COMMA)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_178()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_186() {\\n    if (jj_scan_token(RETURN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_251()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_51() {\\n    if (jj_3R_28()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_249() {\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_48() {\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_47() {\\n    if (jj_3R_88()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_29() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_47()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_48()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_238() {\\n    if (jj_scan_token(ASSIGN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_29()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_185() {\\n    if (jj_scan_token(CONTINUE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_250()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_239() {\\n    if (jj_scan_token(DOT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(STAR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_184() {\\n    if (jj_scan_token(BREAK)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_249()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_142() {\\n    if (jj_3R_78()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_95() {\\n    if (jj_3R_111()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_264() {\\n    if (jj_3R_272()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_228() {\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_238()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_272() {\\n    if (jj_3R_178()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_278()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_94() {\\n    if (jj_scan_token(NEW)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_166() {\\n    if (jj_scan_token(IMPORT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(STAR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_152() {\\n    if (jj_scan_token(FINAL)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_122() {\\n    if (jj_scan_token(LBRACE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RBRACE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_135() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_152()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_30()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_228()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_229()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_121() {\\n    if (jj_scan_token(DOT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_142()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_43() {\\n    if (jj_scan_token(FINAL)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_4() {\\n    if (jj_scan_token(IMPORT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_28()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_239()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_137() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3_4()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_166()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_26() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_43()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_30()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_3() {\\n    if (jj_3R_27()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_120() {\\n    if (jj_scan_token(LBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_245() {\\n    if (jj_scan_token(ELSE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_136()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_27() {\\n    if (jj_3R_46()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_271() {\\n    if (jj_3R_272()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_17() {\\n    if (jj_scan_token(DOT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(CLASS)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_105() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3_17()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_120()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_121()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_122()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_246() {\\n    if (jj_3R_263()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_81() {\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_98()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(LBRACE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_270() {\\n    if (jj_3R_135()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_263() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_270()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_271()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_248() {\\n    if (jj_3R_264()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_247() {\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_16() {\\n    if (jj_3R_30()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(DOT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(CLASS)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_40() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_80()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_81()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_80() {\\n    if (jj_3R_46()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_98()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(LBRACE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_2() {\\n    if (jj_3R_27()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_15() {\\n    if (jj_3R_37()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_183() {\\n    if (jj_scan_token(FOR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_246()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    xsp = jj_scanpos;\\n    if (jj_3R_247()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    xsp = jj_scanpos;\\n    if (jj_3R_248()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_136()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_151() {\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_98()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_38()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_104() {\\n    if (jj_3R_28()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_36() {\\n    if (jj_scan_token(DECR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_103() {\\n    if (jj_3R_30()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_150() {\\n    if (jj_3R_46()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_98()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_38()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_83() {\\n    if (jj_3R_105()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_93() {\\n    if (jj_scan_token(IDENTIFIER)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_134() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_150()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_151()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_35() {\\n    if (jj_scan_token(INCR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_102() {\\n    if (jj_3R_37()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_182() {\\n    if (jj_scan_token(DO)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_136()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(WHILE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_101() {\\n    if (jj_3R_119()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_92() {\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_100() {\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_82() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_99()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_100()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_101()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_102()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_103()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_104()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_99() {\\n    if (jj_3R_111()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_1() {\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(SEMICOLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_37() {\\n    if (jj_3R_28()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_78()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_91() {\\n    if (jj_scan_token(BANG)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_181() {\\n    if (jj_scan_token(WHILE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_136()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_14() {\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_34()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_277() {\\n    if (jj_scan_token(DECR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_42() {\\n    if (jj_3R_82()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_83()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3R_90() {\\n    if (jj_scan_token(TILDE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_262() {\\n    if (jj_3R_97()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_180() {\\n    if (jj_scan_token(IF)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_136()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_245()) jj_scanpos = xsp;\\n    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_283() {\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_30()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_267()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_282() {\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_30()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_240()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_276() {\\n    if (jj_scan_token(INCR)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_281() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_282()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_283()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_13() {\\n    if (jj_3R_31()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_35()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_36()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_269() {\\n    if (jj_scan_token(_DEFAULT)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(COLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_268() {\\n    if (jj_scan_token(CASE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(COLON)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_261() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_268()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_269()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_211() {\\n    if (jj_3R_42()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_244() {\\n    if (jj_3R_261()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_262()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    return false;\\n  }\\n  final private boolean jj_3_12() {\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_28()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(LBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_210() {\\n    if (jj_3R_31()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_276()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_277()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_203() {\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_210()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_211()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_25() {\\n    if (jj_3R_42()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_32()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_179() {\\n    if (jj_scan_token(SWITCH)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_26()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(LBRACE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    while (true) {\\n      xsp = jj_scanpos;\\n      if (jj_3R_244()) { jj_scanpos = xsp; break; }\\n      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    }\\n    if (jj_scan_token(RBRACE)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_69() {\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_28()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    Token xsp;\\n    xsp = jj_scanpos;\\n    if (jj_3R_90()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_91()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_92()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_93()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_94()) {\\n    jj_scanpos = xsp;\\n    if (jj_3R_95()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_197() {\\n    if (jj_3R_203()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3R_68() {\\n    if (jj_scan_token(LPAREN)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_3R_28()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(LBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    if (jj_scan_token(RBRACKET)) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  final private boolean jj_3_10() {\\n    if (jj_3R_33()) return true;\\n    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\\n    return false;\\n  }\\n  public ParserTokenManager token_source;\\n  ASCII_UCodeESC_CharStream jj_input_stream;\\n  public Token token, jj_nt;\\n  private int jj_ntk;\\n  private Token jj_scanpos, jj_lastpos;\\n  private int jj_la;\\n  public boolean lookingAhead = false;\\n  private boolean jj_semLA;\\n  private int jj_gen;\\n  final private int[] jj_la1 = new int[86];\\n  final private int[] jj_la1_0 = {0x6db52c00,0x6db52c01,0x0,0x0,0x0,0x40000000,0x0,0x4a12400,0x4a12400,0x0,0x0,0x4212400,0x0,0x4212400,0x4212400,0x4212400,0x4a12400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4a12400,0x0,0x0,0x4a12400,0x800000,0x0,0x0,0x4a12400,0x0,0x0,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x800000,0x4a12400,0x0,0x0,0x0,0x0,0x0,0x2cb52c00,0x6db52c00,0x6cb52c00,0x0,0x4a12400,0x84000,0x6db52c00,0x84000,0x400000,0x5a12400,0x4a12400,0x4a12400,0x4a12400,0x1000000,0x0,0x0,0x0,0x0,0x4a12400,0x8000,0x2000000,};\\n  final private int[] jj_la1_1 = {0xa7a3fb1d,0xa7a3fb1d,0x4000000,0x4000000,0x0,0x0,0x0,0xa5a2a21d,0xa5a2a21d,0x0,0x0,0x4000205,0x4000000,0x4000205,0x4008205,0x205,0x25a2a21d,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x25a2a21d,0x0,0x0,0x25a2a21d,0x25a2a018,0x20000000,0x0,0x25a2a21d,0x20000000,0x80000000,0x21a2a018,0x4000000,0x20000000,0x80000000,0x80000000,0x20000000,0x80000000,0x1a2a010,0x2000,0x25a2a21d,0x0,0x20000000,0x8,0x0,0x0,0xa5a3fb1d,0xa7a3fb1d,0xa7a3fb1d,0x0,0x25a2a21d,0x0,0xa7a3fb1d,0x0,0x0,0x25a2a21d,0x25a2a21d,0x25a2a21d,0x25a2a21d,0x0,0x0,0x0,0x4000000,0x4000000,0x25a2a21d,0x0,0x0,};\\n  final private int[] jj_la1_2 = {0x6000008,0x1e001808,0x0,0x0,0x20,0x0,0x40,0x1e001800,0x1e001800,0x10,0x10,0x0,0x0,0x0,0x0,0x0,0x1e001800,0x40,0x2000,0x600000,0x600000,0x1800000,0x1800000,0x0,0x0,0x0,0x80000000,0x80000000,0x108000,0x108000,0x0,0xf0780,0xf0780,0x0,0x0,0x18000000,0x18000000,0x60000000,0x60000000,0x18000000,0x1e001800,0x1800,0x1800,0x0,0x1800,0x0,0x6000000,0x0,0x0,0x22,0x0,0x0,0x0,0x22,0x22,0x0,0x22,0x0,0x0,0x1e001800,0x10,0x2,0x0,0x2,0x2,0x6000008,0x6000008,0x6000008,0x6000000,0x0,0x0,0x6000008,0x0,0x0,0x6000000,0x1e001800,0x6000000,0x6000000,0x0,0x10,0x10,0x0,0x0,0x1e001800,0x0,0x0,};\\n  final private int[] jj_la1_3 = {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7faf800,0x0,0x0,0x0,0x0,0x0,0x6,0x6,0x8,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x7e0,0x7e0,0x0,0x0,0x10,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};\\n  final private JJCalls[] jj_2_rtns = new JJCalls[26];\\n  private boolean jj_rescan = false;\\n  private int jj_gc = 0;\\n  public Parser(java.io.InputStream stream) {\\n    jj_input_stream = new ASCII_UCodeESC_CharStream(stream, 1, 1);\\n    token_source = new ParserTokenManager(jj_input_stream);\\n    token = new Token();\\n    jj_ntk = -1;\\n    jj_gen = 0;\\n    for (int i = 0; i < 86; i++) jj_la1[i] = -1;\\n    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\\n  }\\n  public void ReInit(java.io.InputStream stream) {\\n    jj_input_stream.ReInit(stream, 1, 1);\\n    token_source.ReInit(jj_input_stream);\\n    token = new Token();\\n    jj_ntk = -1;\\n    jjtree.reset();\\n    jj_gen = 0;\\n    for (int i = 0; i < 86; i++) jj_la1[i] = -1;\\n    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\\n  }\\n  public Parser(java.io.Reader stream) {\\n    jj_input_stream = new ASCII_UCodeESC_CharStream(stream, 1, 1);\\n    token_source = new ParserTokenManager(jj_input_stream);\\n    token = new Token();\\n    jj_ntk = -1;\\n    jj_gen = 0;\\n    for (int i = 0; i < 86; i++) jj_la1[i] = -1;\\n    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\\n  }\\n  public void ReInit(java.io.Reader stream) {\\n    jj_input_stream.ReInit(stream, 1, 1);\\n    token_source.ReInit(jj_input_stream);\\n    token = new Token();\\n    jj_ntk = -1;\\n    jjtree.reset();\\n    jj_gen = 0;\\n    for (int i = 0; i < 86; i++) jj_la1[i] = -1;\\n    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\\n  }\\n  public Parser(ParserTokenManager tm) {\\n    token_source = tm;\\n    token = new Token();\\n    jj_ntk = -1;\\n    jj_gen = 0;\\n    for (int i = 0; i < 86; i++) jj_la1[i] = -1;\\n    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\\n  }\\n  public void ReInit(ParserTokenManager tm) {\\n    token_source = tm;\\n    token = new Token();\\n    jj_ntk = -1;\\n    jjtree.reset();\\n    jj_gen = 0;\\n    for (int i = 0; i < 86; i++) jj_la1[i] = -1;\\n    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\\n  }\\n  final private Token jj_consume_token(int kind) throws ParseException {\\n    Token oldToken;\\n    if ((oldToken = token).next != null) token = token.next;\\n    else token = token.next = token_source.getNextToken();\\n    jj_ntk = -1;\\n    if (token.kind == kind) {\\n      jj_gen++;\\n      if (++jj_gc > 100) {\\n        jj_gc = 0;\\n        for (int i = 0; i < jj_2_rtns.length; i++) {\\n          JJCalls c = jj_2_rtns[i];\\n          while (c != null) {\\n            if (c.gen < jj_gen) c.first = null;\\n            c = c.next;\\n          }\\n        }\\n      }\\n      return token;\\n    }\\n    token = oldToken;\\n    jj_kind = kind;\\n    throw generateParseException();\\n  }\\n  final private boolean jj_scan_token(int kind) {\\n    if (jj_scanpos == jj_lastpos) {\\n      jj_la--;\\n      if (jj_scanpos.next == null) {\\n        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();\\n      } else {\\n        jj_lastpos = jj_scanpos = jj_scanpos.next;\\n      }\\n    } else {\\n      jj_scanpos = jj_scanpos.next;\\n    }\\n    if (jj_rescan) {\\n      int i = 0; Token tok = token;\\n      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }\\n      if (tok != null) jj_add_error_token(kind, i);\\n    }\\n    return (jj_scanpos.kind != kind);\\n  }\\n  final public Token getNextToken() {\\n    if (token.next != null) token = token.next;\\n    else token = token.next = token_source.getNextToken();\\n    jj_ntk = -1;\\n    jj_gen++;\\n    return token;\\n  }\\n  final public Token getToken(int index) {\\n    Token t = lookingAhead ? jj_scanpos : token;\\n    for (int i = 0; i < index; i++) {\\n      if (t.next != null) t = t.next;\\n      else t = t.next = token_source.getNextToken();\\n    }\\n    return t;\\n  }\\n  final private int jj_ntk() {\\n    if ((jj_nt=token.next) == null)\\n      return (jj_ntk = (token.next=token_source.getNextToken()).kind);\\n    else\\n      return (jj_ntk = jj_nt.kind);\\n  }\\n  private java.util.Vector jj_expentries = new java.util.Vector();\\n  private int[] jj_expentry;\\n  private int jj_kind = -1;\\n  private int[] jj_lasttokens = new int[100];\\n  private int jj_endpos;\\n  private void jj_add_error_token(int kind, int pos) {\\n    if (pos >= 100) return;\\n    if (pos == jj_endpos + 1) {\\n      jj_lasttokens[jj_endpos++] = kind;\\n    } else if (jj_endpos != 0) {\\n      jj_expentry = new int[jj_endpos];\\n      for (int i = 0; i < jj_endpos; i++) {\\n        jj_expentry[i] = jj_lasttokens[i];\\n      }\\n      boolean exists = false;\\n      for (java.util.Enumeration enum = jj_expentries.elements(); enum.hasMoreElements();) {\\n        int[] oldentry = (int[])(enum.nextElement());\\n        if (oldentry.length == jj_expentry.length) {\\n          exists = true;\\n          for (int i = 0; i < jj_expentry.length; i++) {\\n            if (oldentry[i] != jj_expentry[i]) {\\n              exists = false;\\n              break;\\n            }\\n          }\\n          if (exists) break;\\n        }\\n      }\\n      if (!exists) jj_expentries.addElement(jj_expentry);\\n      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;\\n    }\\n  }\\n  final public ParseException generateParseException() {\\n    jj_expentries.removeAllElements();\\n    boolean[] la1tokens = new boolean[123];\\n    for (int i = 0; i < 123; i++) {\\n      la1tokens[i] = false;\\n    }\\n    if (jj_kind >= 0) {\\n      la1tokens[jj_kind] = true;\\n      jj_kind = -1;\\n    }\\n    for (int i = 0; i < 86; i++) {\\n      if (jj_la1[i] == jj_gen) {\\n        for (int j = 0; j < 32; j++) {\\n          if ((jj_la1_0[i] & (1<<j)) != 0) {\\n            la1tokens[j] = true;\\n          }\\n          if ((jj_la1_1[i] & (1<<j)) != 0) {\\n            la1tokens[32+j] = true;\\n          }\\n          if ((jj_la1_2[i] & (1<<j)) != 0) {\\n            la1tokens[64+j] = true;\\n          }\\n          if ((jj_la1_3[i] & (1<<j)) != 0) {\\n            la1tokens[96+j] = true;\\n          }\\n        }\\n      }\\n    }\\n    for (int i = 0; i < 123; i++) {\\n      if (la1tokens[i]) {\\n        jj_expentry = new int[1];\\n        jj_expentry[0] = i;\\n        jj_expentries.addElement(jj_expentry);\\n      }\\n    }\\n    jj_endpos = 0;\\n    jj_rescan_token();\\n    jj_add_error_token(0, 0);\\n    int[][] exptokseq = new int[jj_expentries.size()][];\\n    for (int i = 0; i < jj_expentries.size(); i++) {\\n      exptokseq[i] = (int[])jj_expentries.elementAt(i);\\n    }\\n    return new ParseException(token, exptokseq, tokenImage);\\n  }\\n  final public void enable_tracing() {\\n  }\\n  final public void disable_tracing() {\\n  }\\n  final private void jj_rescan_token() {\\n    jj_rescan = true;\\n    for (int i = 0; i < 26; i++) {\\n      JJCalls p = jj_2_rtns[i];\\n      do {\\n        if (p.gen > jj_gen) {\\n          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;\\n          switch (i) {\\n            case 0: jj_3_1(); break;\\n            case 1: jj_3_2(); break;\\n            case 2: jj_3_3(); break;\\n            case 3: jj_3_4(); break;\\n            case 4: jj_3_5(); break;\\n            case 5: jj_3_6(); break;\\n            case 6: jj_3_7(); break;\\n            case 7: jj_3_8(); break;\\n            case 8: jj_3_9(); break;\\n            case 9: jj_3_10(); break;\\n            case 10: jj_3_11(); break;\\n            case 11: jj_3_12(); break;\\n            case 12: jj_3_13(); break;\\n            case 13: jj_3_14(); break;\\n            case 14: jj_3_15(); break;\\n            case 15: jj_3_16(); break;\\n            case 16: jj_3_17(); break;\\n            case 17: jj_3_18(); break;\\n            case 18: jj_3_19(); break;\\n            case 19: jj_3_20(); break;\\n            case 20: jj_3_21(); break;\\n            case 21: jj_3_22(); break;\\n            case 22: jj_3_23(); break;\\n            case 23: jj_3_24(); break;\\n            case 24: jj_3_25(); break;\\n            case 25: jj_3_26(); break;\\n          }\\n        }\\n        p = p.next;\\n      } while (p != null);\\n    }\\n    jj_rescan = false;\\n  }\\n  final private void jj_save(int index, int xla) {\\n    JJCalls p = jj_2_rtns[index];\\n    while (p.gen > jj_gen) {\\n      if (p.next == null) { p = p.next = new JJCalls(); break; }\\n      p = p.next;\\n    }\\n    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;\\n  }\\n  static final class JJCalls {\\n    int gen;\\n    Token first;\\n    int arg;\\n    JJCalls next;\\n  }\\n}\""
            },
            "m17": {
                "role": "user",
                "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
            },
            "m18": {
                "content": "Title: Diagnosis of starting entity `SimpleNode.java`\n\nChange set: [Parser, Interpreter, BSHMethodDeclaration, BSHAmbiguousName, CallStack, EvalError, Name, BSHCastExpression, BSHAllocationExpression, BSHArrayDimensions, BSHPrimarySuffix, BSHIfStatement, BshMethod, Handler, UtilTargetError, BSHLHSPrimarySuffix, BSHBinaryExpression, BSHThrowStatement, BSHImportDeclaration, XThis, BSHUnaryExpression, BSHArrayInitializer, BSHReturnStatement, BSHTypedVariableDeclaration, BSHSwitchStatement, BlockNameSpace, BSHFormalParameter, BSHMethodInvocation, BSHTryStatement, ReturnControl, BSHReturnType, BSHAssignment, BSHFormalParameters, SignatureKey, LHS, StringUtil, ReflectManager, NameSpace, Primitive, This, JThis, TypedVariable, BSHBlock, BSHTernaryExpression]\n\nDetails:\n- `Parser.java`: Directly uses SimpleNode for AST construction and parsing operations. There's a semantic similarity of 69.3%, and it is part of the core parser that manipulates nodes frequently.\n- `Interpreter.java`: Interacts with SimpleNode during evaluation processes (e.g., error handling or interpreting node structures).\n- `BSHMethodDeclaration.java`: Likely extends or interacts with SimpleNode as part of the Abstract Syntax Tree (AST) structure to represent method declarations.\n- `BSHAmbiguousName.java`: Related to name resolution within the AST, which depends on node functionality provided by SimpleNode.\n- `CallStack.java`: Used in managing execution context during evaluations involving AST nodes.\n- `EvalError.java`: Thrown or caught during node evaluation; tightly related through exception handling logic.\n- `Name.java`: Could be involved in resolving identifiers/names within the AST managed by nodes.\n- `BSHCastExpression.java`, `BSHAllocationExpression.java`, `BSHArrayDimensions.java`, `BSHPrimarySuffix.java`, `BSHIfStatement.java`, `BSHBinaryExpression.java`, `BSHThrowStatement.java`, `BSHImportDeclaration.java`, `BSHUnaryExpression.java`, `BSHArrayInitializer.java`, `BSHReturnStatement.java`, `BSHTypedVariableDeclaration.java`, `BSHSwitchStatement.java`, `BlockNameSpace.java`, `BSHFormalParameter.java`, `BSHMethodInvocation.java`, `BSHTryStatement.java`, `BSHReturnType.java`, `BSHAssignment.java`, `BSHFormalParameters.java`, `SignatureKey.java`, `LHS.java`, `BSHBlock.java`, `BSHTernaryExpression.java`: All are likely subclasses or components interacting with SimpleNode in building and evaluating expressions, statements, blocks, and other syntactic elements.\n- `NameSpace.java`, `Primitive.java`, `This.java`, `JThis.java`, `TypedVariable.java`, `StringUtil.java`, `ReflectManager.java`, `Handler.java`, `UtilTargetError.java`, `ReturnControl.java`: These entities are conceptually or structurally tied to the parsing, scoping, or evaluation framework where SimpleNode plays a central role.\n\nThese files are included due to their high co-change frequency, conceptual coupling, and involvement in AST management or related frameworks like parsing, interpretation, or error handling. They should be synchronized to ensure consistency in structural or behavioral changes propagated from SimpleNode.java.",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            }
        }
    }
}