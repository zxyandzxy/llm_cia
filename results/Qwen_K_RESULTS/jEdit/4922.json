{
    "time": 1749456383.7101188,
    "messages": [
        {
            "role": "system",
            "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
        },
        {
            "role": "user",
            "content": "The project you need to analyze is `jEdit`, a well-known Java open source project. The starting entity you need to deal with is DisplayManager.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
        },
        {
            "content": "",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_c7740f9ca71a492c97d33a",
                    "function": {
                        "arguments": "{\"entity\": \"DisplayManager.java\"}",
                        "name": "get_co_change_relationship"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "name": "get_co_change_relationship",
            "role": "tool",
            "content": "[[\"FirstLine\", \"6\", \"0.375\"], [\"ScrollLineCount\", \"6\", \"0.375\"], [\"ChunkCache\", \"6\", \"0.375\"], [\"HelpIndex\", \"2\", \"0.125\"], [\"HelpTOCPanel\", \"2\", \"0.125\"], [\"View\", \"2\", \"0.125\"], [\"BufferChangeHandler\", \"9\", \"0.5625\"], [\"BufferIORequest\", \"4\", \"0.25\"], [\"RingListModel\", \"2\", \"0.125\"], [\"OffsetManager\", \"2\", \"0.125\"], [\"PosBottomHalf\", \"2\", \"0.125\"], [\"PositionManager\", \"2\", \"0.125\"], [\"PasteFromListDialog\", \"2\", \"0.125\"], [\"ListHandler\", \"2\", \"0.125\"], [\"KeyHandler\", \"2\", \"0.125\"], [\"FontSelector\", \"2\", \"0.125\"], [\"FontSelectorDialog\", \"2\", \"0.125\"], [\"TextAreaOptionPane\", \"2\", \"0.125\"], [\"ActionHandler\", \"2\", \"0.125\"], [\"JEditTextArea\", \"3\", \"0.1875\"], [\"TextAreaPainter\", \"2\", \"0.125\"], [\"EditPane\", \"2\", \"0.125\"], [\"BeanShell\", \"2\", \"0.125\"], [\"MouseHandler\", \"1\", \"0.0625\"], [\"Anchor\", \"1\", \"0.0625\"], [\"RangeMap\", \"1\", \"0.0625\"]]"
        },
        {
            "content": "From the co-change relationship results, we can see that several files have a history of being modified alongside `DisplayManager.java`. These entities may need to be synchronized due to their frequent co-changes. Here's how we interpret the data:\n\n- **High Co-Change Significance**: Entities with high support and confidence values indicate a stronger historical correlation with changes in `DisplayManager.java`.\n  - `BufferChangeHandler` (Support: 9, Confidence: 0.5625)\n  - `FirstLine`, `ScrollLineCount`, and `ChunkCache` (Support: 6, Confidence: 0.375)\n  \n- **Moderate Co-Change Relationship**:\n  - Several other files like `JEditTextArea`, `HelpIndex`, `View`, etc., show lower but notable correlations.\n\n### Recommended Next Steps:\n1. To further investigate the relationships between these files and `DisplayManager.java`, I suggest analyzing their **coupling dependencies** using the `get_coupling_dependencies` function. This will help us understand if there are direct or indirect technical dependencies between them.\n   \n2. Additionally, I'll use the `get_call_graph` function on `DisplayManager.java` to determine which files it directly calls or references.\n\nLet me start by checking the call graph for `DisplayManager.java`.\n\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_1651298d77b24bb0a338b5",
                    "function": {
                        "arguments": "{\"entity\": \"DisplayManager.java\"}",
                        "name": "get_call_graph"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_call_graph",
            "content": "[\"\", \"\", \"Log\"]"
        },
        {
            "content": "The call graph for `DisplayManager.java` reveals that it directly interacts with the following entities:\n\n- **Log** (likely referring to `Log.java`): This suggests that `DisplayManager.java` uses logging functionality, possibly for debugging or tracking events.\n\nThis result seems limited in scope, so I suspect there might be more dependencies not captured here. However, based on this initial insight, `Log.java` could be a file worth considering for synchronization if changes in `DisplayManager.java` affect logging behavior.\n\n### Next Steps:\nTo get a clearer understanding of how `DisplayManager.java` is coupled with other files such as `BufferChangeHandler.java`, `FirstLine.java`, and `ScrollLineCount.java` (which showed high co-change significance), I will now use the `get_coupling_dependencies` function to analyze the coupling between these files and `DisplayManager.java`.\n\nLet me start by checking the coupling between `DisplayManager.java` and `BufferChangeHandler.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_800ea372f87f4e8c8cbc04",
                    "function": {
                        "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"BufferChangeHandler.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"BufferChangeHandler has been removed from the project due to project version iteration\"]"
        },
        {
            "content": "It appears that `BufferChangeHandler.java` has been removed from the project due to changes in the project's version iteration. This explains why we didn't see it in the call graph and suggests that, although it historically had a high co-change relationship with `DisplayManager.java`, it may no longer be relevant for synchronization.\n\n### Adjusted Plan:\nSince `BufferChangeHandler.java` is no longer part of the project, I will focus on other files with high co-change relationships, such as:\n- `FirstLine.java`\n- `ScrollLineCount.java`\n- `ChunkCache.java`\n\nI will check the coupling dependencies between `DisplayManager.java` and these files, starting with `FirstLine.java`.\n\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_e85cae8620bc464299c710",
                    "function": {
                        "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"FirstLine.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"FirstLine has been removed from the project due to project version iteration\"]"
        },
        {
            "content": "Similar to `BufferChangeHandler.java`, it appears that `FirstLine.java` has also been removed from the project due to version iteration. This suggests that, while it had a significant co-change history with `DisplayManager.java`, it is no longer present in the current codebase and thus does not need to be synchronized.\n\n### Moving Forward:\nI will now check the status of another highly correlated file: **`ScrollLineCount.java`**. I'll begin by checking if it still exists in the project and whether it has any coupling dependencies with `DisplayManager.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_d40c8b20142a4771af2632",
                    "function": {
                        "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"ScrollLineCount.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"ScrollLineCount has been removed from the project due to project version iteration\"]"
        },
        {
            "content": "It seems that `ScrollLineCount.java` has also been removed from the project due to version iteration, similar to `BufferChangeHandler.java` and `FirstLine.java`.\n\n### Observation:\nThis indicates that many of the files that historically had strong co-change relationships with `DisplayManager.java` have since been removed or refactored out of the project. As a result, they no longer need to be considered for synchronization.\n\n### Next Steps:\nI will now investigate the coupling between `DisplayManager.java` and `ChunkCache.java`, the next file in our list with high co-change support.\n\nLet me check the coupling dependencies between `DisplayManager.java` and `ChunkCache.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_b07fc0a1d26240e299f8f3",
                    "function": {
                        "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"ChunkCache.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"There are no coupling dependencies between these two entities\"]"
        },
        {
            "content": "The result shows that there are **no coupling dependencies** between `DisplayManager.java` and `ChunkCache.java`, despite their historical co-change relationship.\n\n### Interpretation:\nThis suggests that although these two files were often modified together in the past, there is **no direct technical dependency** between them in the current version of the project. This could indicate that:\n- The co-changes may have been due to **logical or functional alignment** rather than code-level dependencies.\n- The functionality might now be handled differently, or the dependencies might have been refactored or removed.\n\n### Updated Strategy:\nSince many of the historically co-changed files have either been removed or show no current coupling, I will now:\n1. Examine the **current source code** of `DisplayManager.java` to understand its structure and potential relationships.\n2. Investigate whether any other co-changed files (with moderate support) still exist and exhibit coupling.\n\nLet me begin by retrieving the source code for `DisplayManager.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_98772150d3bd4ab6a196fc",
                    "function": {
                        "arguments": "{\"entity\": \"DisplayManager.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package org.gjt.sp.jedit.textarea;\\nimport java.awt.Toolkit;\\nimport java.util.*;\\nimport org.gjt.sp.jedit.buffer.*;\\nimport org.gjt.sp.jedit.*;\\nimport org.gjt.sp.util.Log;\\npublic class DisplayManager\\n{\\n\\tpublic static long scanCount, scannedLines;\\n\\t\\tstatic DisplayManager getDisplayManager(Buffer buffer,\\n\\t\\tJEditTextArea textArea)\\n\\t{\\n\\t\\tList l = (List)bufferMap.get(buffer);\\n\\t\\tDisplayManager dmgr;\\n\\t\\tif(l == null)\\n\\t\\t{\\n\\t\\t\\tl = new LinkedList();\\n\\t\\t\\tbufferMap.put(buffer,l);\\n\\t\\t}\\n\\t\\tIterator liter = l.iterator();\\n\\t\\twhile(liter.hasNext())\\n\\t\\t{\\n\\t\\t\\tdmgr = (DisplayManager)liter.next();\\n\\t\\t\\tif(!dmgr.inUse && dmgr.textArea == textArea)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdmgr.inUse = true;\\n\\t\\t\\t\\treturn dmgr;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tdmgr = new DisplayManager(buffer,textArea);\\n\\t\\tdmgr.inUse = true;\\n\\t\\tl.add(dmgr);\\n\\t\\treturn dmgr;\\n\\t} \\n\\t\\tstatic void releaseDisplayManager(DisplayManager dmgr)\\n\\t{\\n\\t\\tdmgr.inUse = false;\\n\\t} \\n\\t\\tpublic static void bufferClosed(Buffer buffer)\\n\\t{\\n\\t\\tbufferMap.remove(buffer);\\n\\t} \\n\\t\\tstatic void textAreaDisposed(JEditTextArea textArea)\\n\\t{\\n\\t\\tIterator biter = bufferMap.values().iterator();\\n\\t\\twhile(biter.hasNext())\\n\\t\\t{\\n\\t\\t\\tList l = (List)biter.next();\\n\\t\\t\\tIterator liter = l.iterator();\\n\\t\\t\\twhile(liter.hasNext())\\n\\t\\t\\t{\\n\\t\\t\\t\\tDisplayManager dmgr = (DisplayManager)\\n\\t\\t\\t\\t\\tliter.next();\\n\\t\\t\\t\\tif(dmgr.textArea == textArea)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdmgr.dispose();\\n\\t\\t\\t\\t\\tliter.remove();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tprivate static Map bufferMap = new HashMap();\\n\\tpublic final boolean isLineVisible(int line)\\n\\t{\\n\\t\\treturn fvmget(line) % 2 == 0;\\n\\t} \\n\\tpublic int getFirstVisibleLine()\\n\\t{\\n\\t\\treturn fvm[0];\\n\\t} \\n\\tpublic int getLastVisibleLine()\\n\\t{\\n\\t\\treturn fvm[fvmcount - 1] - 1;\\n\\t} \\n\\tpublic int getNextVisibleLine(int line)\\n\\t{\\n\\t\\tint index = fvmget(line);\\n\\t\\tif(index % 2 != 0)\\n\\t\\t{\\n\\t\\t\\tif(fvmcount == index + 1)\\n\\t\\t\\t\\treturn - 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn fvm[index + 1];\\n\\t\\t}\\n\\t\\telse if(line == fvm[index + 1] - 1)\\n\\t\\t{\\n\\t\\t\\tif(fvmcount == index + 2)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn fvm[index + 2];\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn line + 1;\\n\\t} \\n\\tpublic int getPrevVisibleLine(int line)\\n\\t{\\n\\t\\tint index = fvmget(line);\\n\\t\\tif(index == -1)\\n\\t\\t\\treturn -1;\\n\\t\\telse if(index % 2 == 1)\\n\\t\\t{\\n\\t\\t\\treturn fvm[index] - 1;\\n\\t\\t}\\n\\t\\telse if(line == fvm[index])\\n\\t\\t{\\n\\t\\t\\tif(index == 0)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn fvm[index - 1] - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn line - 1;\\n\\t} \\n\\t\\tpublic final int getScreenLineCount(int line)\\n\\t{\\n\\t\\tif(lineMgr.isScreenLineCountValid(line))\\n\\t\\t\\treturn lineMgr.getScreenLineCount(line);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint newCount = textArea.chunkCache\\n\\t\\t\\t\\t.getLineSubregionCount(line);\\n\\t\\t\\tsetScreenLineCount(line,newCount);\\n\\t\\t\\treturn newCount;\\n\\t\\t}\\n\\t} \\n\\t\\tpublic final int getScrollLineCount()\\n\\t{\\n\\t\\treturn scrollLineCount.scrollLine;\\n\\t} \\n\\tpublic void collapseFold(int line)\\n\\t{\\n\\t\\tint lineCount = buffer.getLineCount();\\n\\t\\tint start = 0;\\n\\t\\tint end = lineCount - 1;\\n\\t\\t\\t\\t\\t\\tif(line != 0\\n\\t\\t\\t&& line != buffer.getLineCount() - 1\\n\\t\\t\\t&& buffer.isFoldStart(line)\\n\\t\\t\\t&& !isLineVisible(line + 1))\\n\\t\\t{\\n\\t\\t\\tline--;\\n\\t\\t}\\n\\t\\tint initialFoldLevel = buffer.getFoldLevel(line);\\n\\t\\t\\t\\tif(line != lineCount - 1\\n\\t\\t\\t&& buffer.getFoldLevel(line + 1) > initialFoldLevel)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tstart = line + 1;\\n\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.getFoldLevel(i) <= initialFoldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tboolean ok = false;\\n\\t\\t\\t\\t\\t\\tfor(int i = line - 1; i >= 0; i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstart = i + 1;\\n\\t\\t\\t\\t\\tok = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(!ok)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\thideLineRange(start,end);\\n\\t\\t_notifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic int expandFold(int line, boolean fully)\\n\\t{\\n\\t\\t\\t\\tint returnValue = -1;\\n\\t\\tint lineCount = buffer.getLineCount();\\n\\t\\tint start = 0;\\n\\t\\tint end = lineCount - 1;\\n\\t\\tint initialFoldLevel = buffer.getFoldLevel(line);\\n\\t\\t\\t\\tif(line != lineCount - 1\\n\\t\\t\\t&& isLineVisible(line)\\n\\t\\t\\t&& !isLineVisible(line + 1)\\n\\t\\t\\t&& buffer.getFoldLevel(line + 1) > initialFoldLevel)\\n\\t\\t{\\n\\t\\t\\tint index = fvmget(line + 1);\\n\\t\\t\\tstart = fvm[index];\\n\\t\\t\\tif(index != fvmcount - 1)\\n\\t\\t\\t\\tend = fvm[index + 1] - 1;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart = line + 1;\\n\\t\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(\\n\\t\\t\\t\\t\\t\\tbuffer.getFoldLevel(i) <= initialFoldLevel)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint index = fvmget(line);\\n\\t\\t\\tstart = fvm[index];\\n\\t\\t\\tif(index != fvmcount - 1)\\n\\t\\t\\t\\tend = fvm[index + 1] - 1;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif((isLineVisible(i) &&\\n\\t\\t\\t\\t\\t\\tbuffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t\\t\\t|| i == getLastVisibleLine())\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tif(fully)\\n\\t\\t{\\n\\t\\t\\tshowLineRange(start,end);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tinitialFoldLevel = buffer.getFoldLevel(start);\\n\\t\\t\\tint firstVisible = start;\\n\\t\\t\\tfor(int i = start; i <= end; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.getFoldLevel(i) > initialFoldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(returnValue == -1\\n\\t\\t\\t\\t\\t\\t&& i != 0\\n\\t\\t\\t\\t\\t\\t&& buffer.isFoldStart(i - 1))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturnValue = i - 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(firstVisible != i)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tshowLineRange(firstVisible,i - 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfirstVisible = i + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(firstVisible != end + 1)\\n\\t\\t\\t\\tshowLineRange(firstVisible,end);\\n\\t\\t\\tif(!isLineVisible(line))\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\texpandFold(line,false);\\n\\t\\t\\t\\treturn returnValue;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t_notifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t\\treturn returnValue;\\n\\t} \\n\\tpublic void expandAllFolds()\\n\\t{\\n\\t\\tshowLineRange(0,buffer.getLineCount() - 1);\\n\\t\\t_notifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic void expandFolds(char digit)\\n\\t{\\n\\t\\tif(digit < '1' || digit > '9')\\n\\t\\t{\\n\\t\\t\\tToolkit.getDefaultToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\texpandFolds((int)(digit - '1') + 1);\\n\\t} \\n\\tpublic void expandFolds(int foldLevel)\\n\\t{\\n\\t\\tif(buffer.getFoldHandler() instanceof IndentFoldHandler)\\n\\t\\t\\tfoldLevel = (foldLevel - 1) * buffer.getIndentSize() + 1;\\n\\t\\tshowLineRange(0,buffer.getLineCount() - 1);\\n\\t\\tboolean seenVisibleLine = false;\\n\\t\\tint firstInvisible = 0;\\n\\t\\tfor(int i = 0; i < buffer.getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tif(!seenVisibleLine || buffer.getFoldLevel(i) < foldLevel)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(firstInvisible != i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\thideLineRange(firstInvisible,\\n\\t\\t\\t\\t\\t\\ti - 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfirstInvisible = i + 1;\\n\\t\\t\\t\\tseenVisibleLine = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(firstInvisible != buffer.getLineCount())\\n\\t\\t\\thideLineRange(firstInvisible,buffer.getLineCount() - 1);\\n\\t\\t_notifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic void narrow(int start, int end)\\n\\t{\\n\\t\\tif(start > end || start < 0 || end >= buffer.getLineCount())\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(start + \\\", \\\" + end);\\n\\t\\tif(start < getFirstVisibleLine() || end > getLastVisibleLine())\\n\\t\\t\\texpandAllFolds();\\n\\t\\tif(start != 0)\\n\\t\\t\\thideLineRange(0,start - 1);\\n\\t\\tif(end != buffer.getLineCount() - 1)\\n\\t\\t\\thideLineRange(end + 1,buffer.getLineCount() - 1);\\n\\t\\t\\t\\tif(start != buffer.getLineCount() - 1\\n\\t\\t\\t&& !isLineVisible(start + 1))\\n\\t\\t\\texpandFold(start,false);\\n\\t\\t\\t\\t\\t\\tGUIUtilities.getView(textArea).getStatus().setMessageAndClear(\\n\\t\\t\\tjEdit.getProperty(\\\"view.status.narrow\\\"));\\n\\t\\t_notifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\t\\tboolean softWrap;\\n\\tint wrapMargin;\\n\\tFirstLine firstLine;\\n\\tScrollLineCount scrollLineCount;\\n\\t\\tvoid init()\\n\\t{\\n\\t\\tif(!initialized)\\n\\t\\t{\\n\\t\\t\\tinitialized = true;\\n\\t\\t\\tfvm = new int[2];\\n\\t\\t\\tif(buffer.isLoaded())\\n\\t\\t\\t\\tbufferChangeHandler.foldHandlerChanged(buffer);\\n\\t\\t\\telse\\n\\t\\t\\t\\tfvmreset();\\n\\t\\t\\t_notifyScreenLineChanges();\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tupdateWrapSettings();\\n\\t\\t\\t_notifyScreenLineChanges();\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t}\\n\\t} \\n\\tvoid setScreenLineCount(int line, int count)\\n\\t{\\n\\t\\tint oldCount = lineMgr.getScreenLineCount(line);\\n\\t\\t\\t\\t\\t\\t\\t\\tlineMgr.setScreenLineCount(line,count);\\n\\t\\t\\t\\t\\t\\tif(count != oldCount)\\n\\t\\t{\\n\\t\\t\\tIterator iter = ((List)bufferMap.get(buffer))\\n\\t\\t\\t\\t.iterator();\\n\\t\\t\\twhile(iter.hasNext())\\n\\t\\t\\t{\\n\\t\\t\\t\\t((DisplayManager)iter.next())._setScreenLineCount(\\n\\t\\t\\t\\t\\tline,oldCount,count);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tvoid updateWrapSettings()\\n\\t{\\n\\t\\tString wrap = buffer.getStringProperty(\\\"wrap\\\");\\n\\t\\tsoftWrap = wrap.equals(\\\"soft\\\");\\n\\t\\tif(textArea.maxLineLen <= 0)\\n\\t\\t{\\n\\t\\t\\tsoftWrap = false;\\n\\t\\t\\twrapMargin = 0;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tchar[] foo = new char[textArea.maxLineLen];\\n\\t\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfoo[i] = ' ';\\n\\t\\t\\t}\\n\\t\\t\\tTextAreaPainter painter = textArea.getPainter();\\n\\t\\t\\twrapMargin = (int)painter.getFont().getStringBounds(\\n\\t\\t\\t\\tfoo,0,foo.length,\\n\\t\\t\\t\\tpainter.getFontRenderContext())\\n\\t\\t\\t\\t.getWidth();\\n\\t\\t}\\n\\t} \\n\\t\\tvoid _notifyScreenLineChanges()\\n\\t{\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"_notifyScreenLineChanges()\\\");\\n\\t\\t\\t\\t\\t\\tif(textArea.getDisplayManager() == this)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(firstLine.callReset)\\n\\t\\t\\t\\t\\tfirstLine.reset();\\n\\t\\t\\t\\telse if(firstLine.callChanged)\\n\\t\\t\\t\\t\\tfirstLine.changed();\\n\\t\\t\\t\\tif(scrollLineCount.callReset)\\n\\t\\t\\t\\t\\tscrollLineCount.reset();\\n\\t\\t\\t\\telse if(scrollLineCount.callChanged)\\n\\t\\t\\t\\t\\tscrollLineCount.changed();\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.callReset = firstLine.callChanged = false;\\n\\t\\t\\t\\tscrollLineCount.callReset = scrollLineCount.callChanged = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate boolean initialized;\\n\\tprivate boolean inUse;\\n\\tprivate Buffer buffer;\\n\\tprivate LineManager lineMgr;\\n\\tprivate JEditTextArea textArea;\\n\\tprivate BufferChangeHandler bufferChangeHandler;\\n\\tprivate int[] fvm;\\n\\tprivate int fvmcount;\\n\\tprivate int lastfvmget = -1;\\n\\t\\tprivate DisplayManager(Buffer buffer, JEditTextArea textArea)\\n\\t{\\n\\t\\tthis.buffer = buffer;\\n\\t\\tthis.lineMgr = buffer._getLineManager();\\n\\t\\tthis.textArea = textArea;\\n\\t\\tscrollLineCount = new ScrollLineCount();\\n\\t\\tfirstLine = new FirstLine();\\n\\t\\tbufferChangeHandler = new BufferChangeHandler();\\n\\t\\t\\t\\tbuffer.addBufferChangeListener(bufferChangeHandler,\\n\\t\\t\\tBuffer.HIGH_PRIORITY);\\n\\t} \\n\\t\\tprivate void dispose()\\n\\t{\\n\\t\\tbuffer.removeBufferChangeListener(bufferChangeHandler);\\n\\t} \\n\\t\\tprivate void fvmreset()\\n\\t{\\n\\t\\tlastfvmget = -1;\\n\\t\\tfvmcount = 2;\\n\\t\\tfvm[0] = 0;\\n\\t\\tfvm[1] = buffer.getLineCount();\\n\\t} \\n\\tprivate int fvmget(int line)\\n\\t{\\n\\t\\tscanCount++;\\n\\t\\tif(line < fvm[0])\\n\\t\\t\\treturn -1;\\n\\t\\tif(line >= fvm[fvmcount - 1])\\n\\t\\t\\treturn fvmcount - 1;\\n\\t\\tif(lastfvmget != -1)\\n\\t\\t{\\n\\t\\t\\tif(line >= fvm[lastfvmget])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(lastfvmget == fvmcount - 1\\n\\t\\t\\t\\t\\t|| line < fvm[lastfvmget + 1])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn lastfvmget;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint start = 0;\\n\\t\\tint end = fvmcount - 1;\\nloop:\\t\\tfor(;;)\\n\\t\\t{\\n\\t\\t\\tscannedLines++;\\n\\t\\t\\tswitch(end - start)\\n\\t\\t\\t{\\n\\t\\t\\tcase 0:\\n\\t\\t\\t\\tlastfvmget = start;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\tint value = fvm[end];\\n\\t\\t\\t\\tif(value <= line)\\n\\t\\t\\t\\t\\tlastfvmget = end;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tlastfvmget = start;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tint pivot = (end + start) / 2;\\n\\t\\t\\t\\tvalue = fvm[pivot];\\n\\t\\t\\t\\tif(value == line)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastfvmget = pivot;\\n\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(value < line)\\n\\t\\t\\t\\t\\tstart = pivot;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tend = pivot - 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn lastfvmget;\\n\\t} \\n\\tprivate void fvmput(int start, int end, int[] put)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tStringBuffer buf = new StringBuffer(\\\"{\\\");\\n\\t\\t\\tif(put != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i = 0; i < put.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(i != 0)\\n\\t\\t\\t\\t\\t\\tbuf.append(',');\\n\\t\\t\\t\\t\\tbuf.append(put[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tbuf.append(\\\"}\\\");\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"fvmput(\\\" + start + \\\",\\\"\\n\\t\\t\\t\\t+ end + \\\",\\\" + buf + \\\")\\\");\\n\\t\\t}\\n\\t\\tint putl = (put == null ? 0 : put.length);\\n\\t\\tint delta = putl - (end - start);\\n\\t\\tif(fvmcount + delta > fvm.length)\\n\\t\\t{\\n\\t\\t\\tint[] newfvm = new int[fvm.length * 2 + 1];\\n\\t\\t\\tSystem.arraycopy(fvm,0,newfvm,0,fvmcount);\\n\\t\\t\\tfvm = newfvm;\\n\\t\\t}\\n\\t\\tif(delta != 0)\\n\\t\\t{\\n\\t\\t\\tSystem.arraycopy(fvm,end,fvm,start + putl,\\n\\t\\t\\t\\tfvmcount - end);\\n\\t\\t}\\n\\t\\tif(putl != 0)\\n\\t\\t{\\n\\t\\t\\tSystem.arraycopy(put,0,fvm,start,put.length);\\n\\t\\t}\\n\\t\\tfvmcount += delta;\\n\\t\\tfvmdump();\\n\\t\\tif(fvmcount == 0)\\n\\t\\t\\tthrow new InternalError();\\n\\t} \\n\\tprivate void fvmput2(int starti, int endi, int start, int end)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"*fvmput2(\\\" + starti + \\\",\\\"\\n\\t\\t\\t\\t+ endi + \\\",\\\" + start + \\\",\\\" + end + \\\")\\\");\\n\\t\\t}\\n\\t\\tif(starti != -1 && fvm[starti] == start)\\n\\t\\t{\\n\\t\\t\\tif(endi <= fvmcount - 2 && fvm[endi + 1]\\n\\t\\t\\t\\t== end + 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti,endi + 2,null);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti,endi + 1,\\n\\t\\t\\t\\t\\tnew int[] { end + 1 });\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(endi != fvmcount - 1 && fvm[endi + 1]\\n\\t\\t\\t\\t== end + 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 2,\\n\\t\\t\\t\\t\\tnew int[] { start });\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 1,\\n\\t\\t\\t\\t\\tnew int[] { start,\\n\\t\\t\\t\\t\\tend + 1 });\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fvmdump()\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tStringBuffer buf = new StringBuffer(\\\"{\\\");\\n\\t\\t\\tfor(int i = 0; i < fvmcount; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i != 0)\\n\\t\\t\\t\\t\\tbuf.append(',');\\n\\t\\t\\t\\tbuf.append(fvm[i]);\\n\\t\\t\\t}\\n\\t\\t\\tbuf.append(\\\"}\\\");\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"fvm = \\\" + buf);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void showLineRange(int start, int end)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"showLineRange(\\\" + start\\n\\t\\t\\t\\t+ \\\",\\\" + end + \\\")\\\");\\n\\t\\t}\\n\\t\\tfor(int i = start; i <= end; i++)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(!isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tint screenLines = getScreenLineCount(i);\\n\\t\\t\\t\\tif(firstLine.physicalLine >= i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfirstLine.scrollLine += screenLines;\\n\\t\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tscrollLineCount.scrollLine += screenLines;\\n\\t\\t\\t\\tscrollLineCount.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint starti = fvmget(start);\\n\\t\\tint endi = fvmget(end);\\n\\t\\tif(starti % 2 == 0)\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 1,null);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(endi != fvmcount - 1\\n\\t\\t\\t\\t\\t&& fvm[endi + 1] == end + 1)\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi + 2,null);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\t\\tfvm[starti + 1] = end + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(starti != -1 && fvm[starti] == start)\\n\\t\\t\\t\\t\\tfvmput(starti,endi + 1,null);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\t\\tfvm[starti + 1] = start;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tfvmput2(starti,endi,start,end);\\n\\t\\t}\\n\\t\\tlastfvmget = -1;\\n\\t} \\n\\t\\tprivate void hideLineRange(int start, int end)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"hideLineRange(\\\" + start\\n\\t\\t\\t\\t+ \\\",\\\" + end + \\\")\\\");\\n\\t\\t}\\n\\t\\tfor(int i = start; i <= end; i++)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint screenLines = lineMgr\\n\\t\\t\\t\\t\\t.getScreenLineCount(i);\\n\\t\\t\\t\\tif(firstLine.physicalLine >= i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfirstLine.scrollLine -= screenLines;\\n\\t\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tscrollLineCount.scrollLine -= screenLines;\\n\\t\\t\\t\\tscrollLineCount.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint starti = fvmget(start);\\n\\t\\tint endi = fvmget(end);\\n\\t\\tif(starti % 2 == 0)\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t\\tfvmput2(starti,endi,start,end);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\tfvm[starti + 1] = start;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\tfvm[starti + 1] = end + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 1,null);\\n\\t\\t}\\n\\t\\tlastfvmget = -1;\\n\\t} \\n\\t\\tprivate void _setScreenLineCount(int line, int oldCount, int count)\\n\\t{\\n\\t\\tif(!isLineVisible(line))\\n\\t\\t\\treturn;\\n\\t\\tif(firstLine.physicalLine >= line)\\n\\t\\t{\\n\\t\\t\\tif(firstLine.physicalLine == line)\\n\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.scrollLine += (count - oldCount);\\n\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tscrollLineCount.scrollLine += (count - oldCount);\\n\\t\\tscrollLineCount.callChanged = true;\\n\\t} \\n\\t\\tstatic abstract class Anchor\\n\\t{\\n\\t\\tint physicalLine;\\n\\t\\tint scrollLine;\\n\\t\\tboolean callChanged;\\n\\t\\tboolean callReset;\\n\\t\\tabstract void reset();\\n\\t\\tabstract void changed();\\n\\t} \\n\\t\\tclass ScrollLineCount extends Anchor\\n\\t{\\n\\t\\t\\t\\tpublic void changed()\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"changed()\\\");\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t} \\n\\t\\t\\t\\tpublic void reset()\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"reset()\\\");\\n\\t\\t\\tphysicalLine = getFirstVisibleLine();\\n\\t\\t\\tscrollLine = 0;\\n\\t\\t\\twhile(physicalLine != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\tphysicalLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t}\\n\\t\\t\\tphysicalLine = buffer.getLineCount();\\n\\t\\t\\tfirstLine.ensurePhysicalLineIsVisible();\\n\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t} \\t} \\n\\t\\tclass FirstLine extends Anchor\\n\\t{\\n\\t\\tint skew;\\n\\t\\t\\t\\tpublic void changed()\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"changed() before: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t} \\n\\t\\t\\tensurePhysicalLineIsVisible();\\n\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\tif(skew >= screenLines)\\n\\t\\t\\t\\tskew = screenLines - 1;\\n\\t\\t\\t\\t\\t\\tif(Debug.SCROLL_VERIFY)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint verifyScrollLine = 0;\\n\\t\\t\\t\\tfor(int i = 0; i < buffer.getLineCount(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!isLineVisible(i))\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\tif(i >= physicalLine)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tverifyScrollLine += getScreenLineCount(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(verifyScrollLine != scrollLine)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tException ex = new Exception(scrollLine + \\\":\\\" + verifyScrollLine);\\n\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,ex);\\n\\t\\t\\t\\t\\tnew org.gjt.sp.jedit.gui.BeanShellErrorDialog(null,ex);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"changed() after: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t} \\n\\t\\t\\tif(!scrollLineCount.callChanged\\n\\t\\t\\t\\t&& !scrollLineCount.callReset)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void reset()\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"reset()\\\");\\n\\t\\t\\tString wrap = buffer.getStringProperty(\\\"wrap\\\");\\n\\t\\t\\tsoftWrap = wrap.equals(\\\"soft\\\");\\n\\t\\t\\tif(textArea.maxLineLen <= 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsoftWrap = false;\\n\\t\\t\\t\\twrapMargin = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tchar[] foo = new char[textArea.maxLineLen];\\n\\t\\t\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfoo[i] = ' ';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tTextAreaPainter painter = textArea.getPainter();\\n\\t\\t\\t\\twrapMargin = (int)painter.getFont().getStringBounds(\\n\\t\\t\\t\\t\\tfoo,0,foo.length,\\n\\t\\t\\t\\t\\tpainter.getFontRenderContext())\\n\\t\\t\\t\\t\\t.getWidth();\\n\\t\\t\\t}\\n\\t\\t\\tscrollLine = 0;\\n\\t\\t\\tint i = getFirstVisibleLine();\\n\\t\\t\\tfor(;;)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i >= physicalLine)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tscrollLine += getScreenLineCount(i);\\n\\t\\t\\t\\tint nextLine = getNextVisibleLine(i);\\n\\t\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\ti = nextLine;\\n\\t\\t\\t}\\n\\t\\t\\tphysicalLine = i;\\n\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\tif(skew >= screenLines)\\n\\t\\t\\t\\tskew = screenLines - 1;\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid physDown(int amount, int screenAmount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physDown() start: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tskew = 0;\\n\\t\\t\\tif(!isLineVisible(physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint lastVisibleLine = getLastVisibleLine();\\n\\t\\t\\t\\tif(physicalLine > lastVisibleLine)\\n\\t\\t\\t\\t\\tphysicalLine = lastVisibleLine;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint nextPhysicalLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tamount -= (nextPhysicalLine - physicalLine);\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = nextPhysicalLine;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(;;)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint nextPhysicalLine = getNextVisibleLine(\\n\\t\\t\\t\\t\\tphysicalLine);\\n\\t\\t\\t\\tif(nextPhysicalLine == -1)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse if(nextPhysicalLine > physicalLine + amount)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t\\tamount -= (nextPhysicalLine - physicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = nextPhysicalLine;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physDown() end: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tcallChanged = true;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(screenAmount < 0)\\n\\t\\t\\t\\tscrollUp(-screenAmount);\\n\\t\\t\\telse if(screenAmount > 0)\\n\\t\\t\\t\\tscrollDown(screenAmount);\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid physUp(int amount, int screenAmount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physUp() start: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tskew = 0;\\n\\t\\t\\tif(!isLineVisible(physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint firstVisibleLine = getFirstVisibleLine();\\n\\t\\t\\t\\tif(physicalLine < firstVisibleLine)\\n\\t\\t\\t\\t\\tphysicalLine = firstVisibleLine;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint prevPhysicalLine = getPrevVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tamount -= (physicalLine - prevPhysicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(;;)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint prevPhysicalLine = getPrevVisibleLine(\\n\\t\\t\\t\\t\\tphysicalLine);\\n\\t\\t\\t\\tif(prevPhysicalLine == -1)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse if(prevPhysicalLine < physicalLine - amount)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tamount -= (physicalLine - prevPhysicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = prevPhysicalLine;\\n\\t\\t\\t\\t\\tscrollLine -= getScreenLineCount(\\n\\t\\t\\t\\t\\t\\tprevPhysicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physUp() end: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tcallChanged = true;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(screenAmount < 0)\\n\\t\\t\\t\\tscrollUp(-screenAmount);\\n\\t\\t\\telse if(screenAmount > 0)\\n\\t\\t\\t\\tscrollDown(screenAmount);\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid scrollDown(int amount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"scrollDown()\\\");\\n\\t\\t\\tensurePhysicalLineIsVisible();\\n\\t\\t\\tamount += skew;\\n\\t\\t\\tskew = 0;\\n\\t\\t\\twhile(amount > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\t\\tif(amount < screenLines)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tskew = amount;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint nextLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tboolean visible = isLineVisible(physicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = nextLine;\\n\\t\\t\\t\\t\\tif(visible)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tamount -= screenLines;\\n\\t\\t\\t\\t\\t\\tscrollLine += screenLines;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcallChanged = true;\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid scrollUp(int amount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"scrollUp()\\\");\\n\\t\\t\\tensurePhysicalLineIsVisible();\\n\\t\\t\\tif(amount <= skew)\\n\\t\\t\\t{\\n\\t\\t\\t\\tskew -= amount;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tamount -= skew;\\n\\t\\t\\t\\tskew = 0;\\n\\t\\t\\t\\twhile(amount > 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint prevLine = getPrevVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tif(prevLine == -1)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tphysicalLine = prevLine;\\n\\t\\t\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t\\tscrollLine -= screenLines;\\n\\t\\t\\t\\t\\tif(amount < screenLines)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tskew = screenLines - amount;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tamount -= screenLines;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcallChanged = true;\\n\\t\\t} \\n\\t\\t\\t\\tprivate void ensurePhysicalLineIsVisible()\\n\\t\\t{\\n\\t\\t\\tif(!isLineVisible(physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(physicalLine > getLastVisibleLine())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysicalLine = getLastVisibleLine();\\n\\t\\t\\t\\t\\tscrollLine = getScrollLineCount() - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(physicalLine < getFirstVisibleLine())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysicalLine = getFirstVisibleLine();\\n\\t\\t\\t\\t\\tscrollLine = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysicalLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\t} \\n\\tclass BufferChangeHandler extends BufferChangeAdapter\\n\\t{\\n\\t\\tboolean delayedUpdate;\\n\\t\\tboolean delayedMultilineUpdate;\\n\\t\\tint delayedUpdateStart;\\n\\t\\tint delayedUpdateEnd;\\n\\t\\t\\t\\tpublic void foldHandlerChanged(Buffer buffer)\\n\\t\\t{\\n\\t\\t\\tfvmreset();\\n\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\tint collapseFolds = buffer.getIntegerProperty(\\n\\t\\t\\t\\t\\\"collapseFolds\\\",0);\\n\\t\\t\\tif(collapseFolds != 0)\\n\\t\\t\\t\\texpandFolds(collapseFolds);\\n\\t\\t\\t_notifyScreenLineChanges();\\n\\t\\t} \\n\\t\\t\\t\\tpublic void foldLevelChanged(Buffer buffer, int start, int end)\\n\\t\\t{\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this\\n\\t\\t\\t\\t&& end != 0 && buffer.isLoaded())\\n\\t\\t\\t{\\n\\t\\t\\t\\ttextArea.invalidateLineRange(start - 1,\\n\\t\\t\\t\\t\\ttextArea.getLastPhysicalLine());\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void contentInserted(Buffer buffer, int startLine,\\n\\t\\t\\tint offset, int numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tint endLine = startLine + numLines;\\n\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedMultilineUpdate = true;\\n\\t\\t\\t\\tint index = fvmget(startLine);\\n\\t\\t\\t\\tint start = index + 1;\\n\\t\\t\\t\\tfor(int i = start; i < fvmcount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvm[i] += numLines;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlastfvmget = -1;\\n\\t\\t\\t\\tfvmdump();\\n\\t\\t\\t}\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontentInserted(firstLine,startLine,numLines);\\n\\t\\t\\t\\tcontentInserted(scrollLineCount,startLine,numLines);\\n\\t\\t\\t\\tif(delayedUpdateEnd >= startLine)\\n\\t\\t\\t\\t\\tdelayedUpdateEnd += numLines;\\n\\t\\t\\t\\tdelayedUpdate(startLine,endLine);\\n\\t\\t\\t\\t\\t\\t\\t\\tfor(int i = 0; i < textArea.selection.size(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection s = (Selection)textArea\\n\\t\\t\\t\\t\\t\\t.selection.elementAt(i);\\n\\t\\t\\t\\t\\tif(s.contentInserted(buffer,startLine,offset,\\n\\t\\t\\t\\t\\t\\tnumLines,length))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdelayedUpdate(s.startLine,s.endLine);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tint caret = textArea.getCaretPosition();\\n\\t\\t\\t\\tif(caret >= offset)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.ELECTRIC_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(\\n\\t\\t\\t\\t\\t\\tcaret + length,scrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.NORMAL_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(\\n\\t\\t\\t\\t\\t\\tcaret,scrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void preContentRemoved(Buffer buffer, int startLine,\\n\\t\\t\\tint offset, int numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this)\\n\\t\\t\\t{\\n\\t\\t\\t\\tpreContentRemoved(firstLine,startLine,numLines);\\n\\t\\t\\t\\tpreContentRemoved(scrollLineCount,startLine,numLines);\\n\\t\\t\\t\\tif(delayedUpdateEnd >= startLine)\\n\\t\\t\\t\\t\\tdelayedUpdateEnd -= numLines;\\n\\t\\t\\t\\tdelayedUpdate(startLine,startLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\t}\\n\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedMultilineUpdate = true;\\n\\t\\t\\t\\tint endLine = startLine + numLines;\\n\\t\\t\\t\\tint starti = fvmget(startLine);\\n\\t\\t\\t\\tint endi = fvmget(endLine);\\n\\t\\t\\t\\tif(Math.abs(starti % 2) == Math.abs(endi % 2))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(endi - starti == fvmcount)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfvmreset();\\n\\t\\t\\t\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\t\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tfvmput(starti + 1,endi + 1,null);\\n\\t\\t\\t\\t\\t\\tstarti++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(starti != -1 && fvm[starti] == startLine)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfvmput(starti,endi + 1,null);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\t\\tfvm[starti + 1] = startLine;\\n\\t\\t\\t\\t\\tstarti += 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int i = starti; i < fvmcount; i++)\\n\\t\\t\\t\\t\\tfvm[i] -= numLines;\\n\\t\\t\\t\\tif(firstLine.physicalLine\\n\\t\\t\\t\\t\\t> getLastVisibleLine()\\n\\t\\t\\t\\t\\t|| firstLine.physicalLine\\n\\t\\t\\t\\t\\t< getFirstVisibleLine())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\telse if(!isLineVisible(\\n\\t\\t\\t\\t\\tfirstLine.physicalLine))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfirstLine.physicalLine =\\n\\t\\t\\t\\t\\t\\tgetNextVisibleLine(\\n\\t\\t\\t\\t\\t\\tfirstLine.physicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlastfvmget = -1;\\n\\t\\t\\t\\tfvmdump();\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void contentRemoved(Buffer buffer, int startLine,\\n\\t\\t\\tint start, int numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint endLine = startLine + numLines;\\n\\t\\t\\t\\t\\t\\t\\t\\tfor(int i = 0; i < textArea.selection.size(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection s = (Selection)textArea\\n\\t\\t\\t\\t\\t\\t.selection.elementAt(i);\\n\\t\\t\\t\\t\\tif(s.contentRemoved(buffer,startLine,\\n\\t\\t\\t\\t\\t\\tstart,numLines,length))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdelayedUpdate(s.startLine,s.endLine);\\n\\t\\t\\t\\t\\t\\tif(s.start == s.end)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\ttextArea.selection.removeElementAt(i);\\n\\t\\t\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tint caret = textArea.getCaretPosition();\\n\\t\\t\\t\\tif(caret >= start + length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.ELECTRIC_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(\\n\\t\\t\\t\\t\\t\\tcaret - length,\\n\\t\\t\\t\\t\\t\\tscrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(caret >= start)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.ELECTRIC_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(\\n\\t\\t\\t\\t\\t\\tstart,scrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.NORMAL_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(caret,scrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tpublic void transactionComplete(Buffer buffer)\\n\\t\\t{\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(delayedUpdate)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t_notifyScreenLineChanges();\\n\\t\\t\\t\\t\\tif(delayedMultilineUpdate)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ttextArea.invalidateScreenLineRange(\\n\\t\\t\\t\\t\\t\\t\\ttextArea.chunkCache\\n\\t\\t\\t\\t\\t\\t\\t.getScreenLineOfOffset(\\n\\t\\t\\t\\t\\t\\t\\tdelayedUpdateStart,0),\\n\\t\\t\\t\\t\\t\\t\\ttextArea.getVisibleLines());\\n\\t\\t\\t\\t\\t\\tdelayedMultilineUpdate = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ttextArea.invalidateLineRange(\\n\\t\\t\\t\\t\\t\\t\\tdelayedUpdateStart,\\n\\t\\t\\t\\t\\t\\t\\tdelayedUpdateEnd);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tint _firstLine = textArea.getFirstPhysicalLine();\\n\\t\\t\\t\\t\\tint _lastLine = textArea.getLastPhysicalLine();\\n\\t\\t\\t\\t\\tint line = delayedUpdateStart;\\n\\t\\t\\t\\t\\tif(!isLineVisible(line))\\n\\t\\t\\t\\t\\t\\tline = getNextVisibleLine(line);\\n\\t\\t\\t\\t\\twhile(line != -1 && line <= delayedUpdateEnd)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(line < _firstLine\\n\\t\\t\\t\\t\\t\\t\\t|| line > _lastLine)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tgetScreenLineCount(line);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tline = getNextVisibleLine(line);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tint visibleLines = textArea\\n\\t\\t\\t\\t\\t\\t.getVisibleLines();\\n\\t\\t\\t\\t\\tif(visibleLines != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ttextArea.chunkCache.getLineInfo(\\n\\t\\t\\t\\t\\t\\t\\tvisibleLines - 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttextArea._finishCaretUpdate();\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(Debug.SCROLL_VERIFY)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint scrollLineCount = 0;\\n\\t\\t\\t\\tfor(int i = 0; i < textArea.getLineCount(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(isLineVisible(i))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tscrollLineCount +=\\n\\t\\t\\t\\t\\t\\t\\tgetScreenLineCount(i);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(scrollLineCount != getScrollLineCount())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tthrow new InternalError(scrollLineCount\\n\\t\\t\\t\\t\\t\\t+ \\\" != \\\"\\n\\t\\t\\t\\t\\t\\t+ getScrollLineCount());\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\tdelayedUpdate = false;\\n\\t\\t} \\n\\t\\t\\t\\tprivate void contentInserted(Anchor anchor, int startLine,\\n\\t\\t\\tint numLines)\\n\\t\\t{\\n\\t\\t\\tif(anchor.physicalLine >= startLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(anchor.physicalLine != startLine)\\n\\t\\t\\t\\t\\tanchor.physicalLine += numLines;\\n\\t\\t\\t\\tanchor.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void preContentRemoved(Anchor anchor, int startLine,\\n\\t\\t\\tint numLines)\\n\\t\\t{\\n\\t\\t\\tif(anchor.physicalLine >= startLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(anchor.physicalLine == startLine)\\n\\t\\t\\t\\t\\tanchor.callChanged = true;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint end = Math.min(startLine + numLines,\\n\\t\\t\\t\\t\\t\\tanchor.physicalLine);\\n\\t\\t\\t\\t\\tfor(int i = startLine; i < end; i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(isLineVisible(i))\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tanchor.scrollLine -=\\n\\t\\t\\t\\t\\t\\t\\t\\tlineMgr\\n\\t\\t\\t\\t\\t\\t\\t\\t.getScreenLineCount(i);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tanchor.physicalLine -= (end - startLine);\\n\\t\\t\\t\\t\\tanchor.callChanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void delayedUpdate(int startLine, int endLine)\\n\\t\\t{\\n\\t\\t\\ttextArea.chunkCache.invalidateChunksFromPhys(startLine);\\n\\t\\t\\tif(!delayedUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedUpdateStart = startLine;\\n\\t\\t\\t\\tdelayedUpdateEnd = endLine;\\n\\t\\t\\t\\tdelayedUpdate = true;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedUpdateStart = Math.min(\\n\\t\\t\\t\\t\\tdelayedUpdateStart,\\n\\t\\t\\t\\t\\tstartLine);\\n\\t\\t\\t\\tdelayedUpdateEnd = Math.max(\\n\\t\\t\\t\\t\\tdelayedUpdateEnd,\\n\\t\\t\\t\\t\\tendLine);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tprivate boolean caretAutoScroll()\\n\\t\\t{\\n\\t\\t\\tView view = textArea.getView();\\n\\t\\t\\treturn view == jEdit.getActiveView()\\n\\t\\t\\t\\t&& view.getTextArea() == textArea;\\n\\t\\t} \\t} }\""
        },
        {
            "role": "user",
            "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
        },
        {
            "content": "Title: Diagnosis of starting entity `DisplayManager`\n\nChange set: [Log, ChunkCache, JEditTextArea, TextAreaPainter, BufferChangeHandler, FirstLine, ScrollLineCount, HelpIndex, HelpTOCPanel, View, RingListModel, OffsetManager, PosBottomHalf, PositionManager, PasteFromListDialog, ListHandler, KeyHandler, FontSelector, FontSelectorDialog, TextAreaOptionPane, ActionHandler, BeanShell, MouseHandler, Anchor, RangeMap]\n\nDetails:\n- **Log**: Directly referenced in the call graph of `DisplayManager.java`, indicating logging functionality is used.\n- **ChunkCache**: Historically co-changed with high support and although no coupling found, it may still be logically related to rendering or layout management.\n- **JEditTextArea**: A core component used by `DisplayManager` for text display and interaction, likely tightly integrated.\n- **TextAreaPainter**: Related to rendering visible lines, possibly called from DisplayManager during painting operations.\n- **BufferChangeHandler**: Instantiated and used directly by `DisplayManager`, making it integral to buffer change handling.\n- **FirstLine**/**ScrollLineCount**: Though removed in current versions, they were frequently co-changed with DisplayManager historically and used internally for scroll and line tracking.\n- **HelpIndex**/**HelpTOCPanel**: Part of UI components that might interact with DisplayManager for help-related views.\n- **View**: Central UI class in jEdit; likely used by DisplayManager for view updates or synchronization.\n- **RingListModel**/**OffsetManager**/**PosBottomHalf**/**PositionManager**: Possibly involved in managing visible content positions or scrolling states.\n- **PasteFromListDialog**/**ListHandler**/**KeyHandler**: UI or event handlers that may synchronize visual changes with DisplayManager.\n- **FontSelector**/**FontSelectorDialog**: May affect display rendering and thus could require synchronization.\n- **TextAreaOptionPane**/**ActionHandler**: Configuration/UI components potentially linked to display behavior.\n- **BeanShell**/**MouseHandler**/**Anchor**/**RangeMap**: Ancillary classes that might influence or react to display state changes.\n\nEven though some files like `FirstLine` and `ScrollLineCount` are now removed, their historical co-change relationship suggests past relevance. Based on CIA principles, we include entities with notable historical correlation, conceptual or indirect usage, or direct coupling.",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        }
    ],
    "interaction_records": {
        "step_histories": [
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4"
                ],
                "response_message": "m5"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6"
                ],
                "response_message": "m7"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8"
                ],
                "response_message": "m9"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10"
                ],
                "response_message": "m11"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12"
                ],
                "response_message": "m13"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14"
                ],
                "response_message": "m15"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14",
                    "m15",
                    "m16",
                    "m17"
                ],
                "response_message": "m18"
            }
        ],
        "mid_to_message": {
            "m1": {
                "role": "system",
                "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
            },
            "m2": {
                "role": "user",
                "content": "The project you need to analyze is `jEdit`, a well-known Java open source project. The starting entity you need to deal with is DisplayManager.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
            },
            "m3": {
                "content": "",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_c7740f9ca71a492c97d33a",
                        "function": {
                            "arguments": "{\"entity\": \"DisplayManager.java\"}",
                            "name": "get_co_change_relationship"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m4": {
                "name": "get_co_change_relationship",
                "role": "tool",
                "content": "[[\"FirstLine\", \"6\", \"0.375\"], [\"ScrollLineCount\", \"6\", \"0.375\"], [\"ChunkCache\", \"6\", \"0.375\"], [\"HelpIndex\", \"2\", \"0.125\"], [\"HelpTOCPanel\", \"2\", \"0.125\"], [\"View\", \"2\", \"0.125\"], [\"BufferChangeHandler\", \"9\", \"0.5625\"], [\"BufferIORequest\", \"4\", \"0.25\"], [\"RingListModel\", \"2\", \"0.125\"], [\"OffsetManager\", \"2\", \"0.125\"], [\"PosBottomHalf\", \"2\", \"0.125\"], [\"PositionManager\", \"2\", \"0.125\"], [\"PasteFromListDialog\", \"2\", \"0.125\"], [\"ListHandler\", \"2\", \"0.125\"], [\"KeyHandler\", \"2\", \"0.125\"], [\"FontSelector\", \"2\", \"0.125\"], [\"FontSelectorDialog\", \"2\", \"0.125\"], [\"TextAreaOptionPane\", \"2\", \"0.125\"], [\"ActionHandler\", \"2\", \"0.125\"], [\"JEditTextArea\", \"3\", \"0.1875\"], [\"TextAreaPainter\", \"2\", \"0.125\"], [\"EditPane\", \"2\", \"0.125\"], [\"BeanShell\", \"2\", \"0.125\"], [\"MouseHandler\", \"1\", \"0.0625\"], [\"Anchor\", \"1\", \"0.0625\"], [\"RangeMap\", \"1\", \"0.0625\"]]"
            },
            "m5": {
                "content": "From the co-change relationship results, we can see that several files have a history of being modified alongside `DisplayManager.java`. These entities may need to be synchronized due to their frequent co-changes. Here's how we interpret the data:\n\n- **High Co-Change Significance**: Entities with high support and confidence values indicate a stronger historical correlation with changes in `DisplayManager.java`.\n  - `BufferChangeHandler` (Support: 9, Confidence: 0.5625)\n  - `FirstLine`, `ScrollLineCount`, and `ChunkCache` (Support: 6, Confidence: 0.375)\n  \n- **Moderate Co-Change Relationship**:\n  - Several other files like `JEditTextArea`, `HelpIndex`, `View`, etc., show lower but notable correlations.\n\n### Recommended Next Steps:\n1. To further investigate the relationships between these files and `DisplayManager.java`, I suggest analyzing their **coupling dependencies** using the `get_coupling_dependencies` function. This will help us understand if there are direct or indirect technical dependencies between them.\n   \n2. Additionally, I'll use the `get_call_graph` function on `DisplayManager.java` to determine which files it directly calls or references.\n\nLet me start by checking the call graph for `DisplayManager.java`.\n\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_1651298d77b24bb0a338b5",
                        "function": {
                            "arguments": "{\"entity\": \"DisplayManager.java\"}",
                            "name": "get_call_graph"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m6": {
                "role": "tool",
                "name": "get_call_graph",
                "content": "[\"\", \"\", \"Log\"]"
            },
            "m7": {
                "content": "The call graph for `DisplayManager.java` reveals that it directly interacts with the following entities:\n\n- **Log** (likely referring to `Log.java`): This suggests that `DisplayManager.java` uses logging functionality, possibly for debugging or tracking events.\n\nThis result seems limited in scope, so I suspect there might be more dependencies not captured here. However, based on this initial insight, `Log.java` could be a file worth considering for synchronization if changes in `DisplayManager.java` affect logging behavior.\n\n### Next Steps:\nTo get a clearer understanding of how `DisplayManager.java` is coupled with other files such as `BufferChangeHandler.java`, `FirstLine.java`, and `ScrollLineCount.java` (which showed high co-change significance), I will now use the `get_coupling_dependencies` function to analyze the coupling between these files and `DisplayManager.java`.\n\nLet me start by checking the coupling between `DisplayManager.java` and `BufferChangeHandler.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_800ea372f87f4e8c8cbc04",
                        "function": {
                            "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"BufferChangeHandler.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m8": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"BufferChangeHandler has been removed from the project due to project version iteration\"]"
            },
            "m9": {
                "content": "It appears that `BufferChangeHandler.java` has been removed from the project due to changes in the project's version iteration. This explains why we didn't see it in the call graph and suggests that, although it historically had a high co-change relationship with `DisplayManager.java`, it may no longer be relevant for synchronization.\n\n### Adjusted Plan:\nSince `BufferChangeHandler.java` is no longer part of the project, I will focus on other files with high co-change relationships, such as:\n- `FirstLine.java`\n- `ScrollLineCount.java`\n- `ChunkCache.java`\n\nI will check the coupling dependencies between `DisplayManager.java` and these files, starting with `FirstLine.java`.\n\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_e85cae8620bc464299c710",
                        "function": {
                            "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"FirstLine.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m10": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"FirstLine has been removed from the project due to project version iteration\"]"
            },
            "m11": {
                "content": "Similar to `BufferChangeHandler.java`, it appears that `FirstLine.java` has also been removed from the project due to version iteration. This suggests that, while it had a significant co-change history with `DisplayManager.java`, it is no longer present in the current codebase and thus does not need to be synchronized.\n\n### Moving Forward:\nI will now check the status of another highly correlated file: **`ScrollLineCount.java`**. I'll begin by checking if it still exists in the project and whether it has any coupling dependencies with `DisplayManager.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_d40c8b20142a4771af2632",
                        "function": {
                            "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"ScrollLineCount.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m12": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"ScrollLineCount has been removed from the project due to project version iteration\"]"
            },
            "m13": {
                "content": "It seems that `ScrollLineCount.java` has also been removed from the project due to version iteration, similar to `BufferChangeHandler.java` and `FirstLine.java`.\n\n### Observation:\nThis indicates that many of the files that historically had strong co-change relationships with `DisplayManager.java` have since been removed or refactored out of the project. As a result, they no longer need to be considered for synchronization.\n\n### Next Steps:\nI will now investigate the coupling between `DisplayManager.java` and `ChunkCache.java`, the next file in our list with high co-change support.\n\nLet me check the coupling dependencies between `DisplayManager.java` and `ChunkCache.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_b07fc0a1d26240e299f8f3",
                        "function": {
                            "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"ChunkCache.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m14": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"There are no coupling dependencies between these two entities\"]"
            },
            "m15": {
                "content": "The result shows that there are **no coupling dependencies** between `DisplayManager.java` and `ChunkCache.java`, despite their historical co-change relationship.\n\n### Interpretation:\nThis suggests that although these two files were often modified together in the past, there is **no direct technical dependency** between them in the current version of the project. This could indicate that:\n- The co-changes may have been due to **logical or functional alignment** rather than code-level dependencies.\n- The functionality might now be handled differently, or the dependencies might have been refactored or removed.\n\n### Updated Strategy:\nSince many of the historically co-changed files have either been removed or show no current coupling, I will now:\n1. Examine the **current source code** of `DisplayManager.java` to understand its structure and potential relationships.\n2. Investigate whether any other co-changed files (with moderate support) still exist and exhibit coupling.\n\nLet me begin by retrieving the source code for `DisplayManager.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_98772150d3bd4ab6a196fc",
                        "function": {
                            "arguments": "{\"entity\": \"DisplayManager.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m16": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package org.gjt.sp.jedit.textarea;\\nimport java.awt.Toolkit;\\nimport java.util.*;\\nimport org.gjt.sp.jedit.buffer.*;\\nimport org.gjt.sp.jedit.*;\\nimport org.gjt.sp.util.Log;\\npublic class DisplayManager\\n{\\n\\tpublic static long scanCount, scannedLines;\\n\\t\\tstatic DisplayManager getDisplayManager(Buffer buffer,\\n\\t\\tJEditTextArea textArea)\\n\\t{\\n\\t\\tList l = (List)bufferMap.get(buffer);\\n\\t\\tDisplayManager dmgr;\\n\\t\\tif(l == null)\\n\\t\\t{\\n\\t\\t\\tl = new LinkedList();\\n\\t\\t\\tbufferMap.put(buffer,l);\\n\\t\\t}\\n\\t\\tIterator liter = l.iterator();\\n\\t\\twhile(liter.hasNext())\\n\\t\\t{\\n\\t\\t\\tdmgr = (DisplayManager)liter.next();\\n\\t\\t\\tif(!dmgr.inUse && dmgr.textArea == textArea)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdmgr.inUse = true;\\n\\t\\t\\t\\treturn dmgr;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tdmgr = new DisplayManager(buffer,textArea);\\n\\t\\tdmgr.inUse = true;\\n\\t\\tl.add(dmgr);\\n\\t\\treturn dmgr;\\n\\t} \\n\\t\\tstatic void releaseDisplayManager(DisplayManager dmgr)\\n\\t{\\n\\t\\tdmgr.inUse = false;\\n\\t} \\n\\t\\tpublic static void bufferClosed(Buffer buffer)\\n\\t{\\n\\t\\tbufferMap.remove(buffer);\\n\\t} \\n\\t\\tstatic void textAreaDisposed(JEditTextArea textArea)\\n\\t{\\n\\t\\tIterator biter = bufferMap.values().iterator();\\n\\t\\twhile(biter.hasNext())\\n\\t\\t{\\n\\t\\t\\tList l = (List)biter.next();\\n\\t\\t\\tIterator liter = l.iterator();\\n\\t\\t\\twhile(liter.hasNext())\\n\\t\\t\\t{\\n\\t\\t\\t\\tDisplayManager dmgr = (DisplayManager)\\n\\t\\t\\t\\t\\tliter.next();\\n\\t\\t\\t\\tif(dmgr.textArea == textArea)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdmgr.dispose();\\n\\t\\t\\t\\t\\tliter.remove();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tprivate static Map bufferMap = new HashMap();\\n\\tpublic final boolean isLineVisible(int line)\\n\\t{\\n\\t\\treturn fvmget(line) % 2 == 0;\\n\\t} \\n\\tpublic int getFirstVisibleLine()\\n\\t{\\n\\t\\treturn fvm[0];\\n\\t} \\n\\tpublic int getLastVisibleLine()\\n\\t{\\n\\t\\treturn fvm[fvmcount - 1] - 1;\\n\\t} \\n\\tpublic int getNextVisibleLine(int line)\\n\\t{\\n\\t\\tint index = fvmget(line);\\n\\t\\tif(index % 2 != 0)\\n\\t\\t{\\n\\t\\t\\tif(fvmcount == index + 1)\\n\\t\\t\\t\\treturn - 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn fvm[index + 1];\\n\\t\\t}\\n\\t\\telse if(line == fvm[index + 1] - 1)\\n\\t\\t{\\n\\t\\t\\tif(fvmcount == index + 2)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn fvm[index + 2];\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn line + 1;\\n\\t} \\n\\tpublic int getPrevVisibleLine(int line)\\n\\t{\\n\\t\\tint index = fvmget(line);\\n\\t\\tif(index == -1)\\n\\t\\t\\treturn -1;\\n\\t\\telse if(index % 2 == 1)\\n\\t\\t{\\n\\t\\t\\treturn fvm[index] - 1;\\n\\t\\t}\\n\\t\\telse if(line == fvm[index])\\n\\t\\t{\\n\\t\\t\\tif(index == 0)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn fvm[index - 1] - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn line - 1;\\n\\t} \\n\\t\\tpublic final int getScreenLineCount(int line)\\n\\t{\\n\\t\\tif(lineMgr.isScreenLineCountValid(line))\\n\\t\\t\\treturn lineMgr.getScreenLineCount(line);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint newCount = textArea.chunkCache\\n\\t\\t\\t\\t.getLineSubregionCount(line);\\n\\t\\t\\tsetScreenLineCount(line,newCount);\\n\\t\\t\\treturn newCount;\\n\\t\\t}\\n\\t} \\n\\t\\tpublic final int getScrollLineCount()\\n\\t{\\n\\t\\treturn scrollLineCount.scrollLine;\\n\\t} \\n\\tpublic void collapseFold(int line)\\n\\t{\\n\\t\\tint lineCount = buffer.getLineCount();\\n\\t\\tint start = 0;\\n\\t\\tint end = lineCount - 1;\\n\\t\\t\\t\\t\\t\\tif(line != 0\\n\\t\\t\\t&& line != buffer.getLineCount() - 1\\n\\t\\t\\t&& buffer.isFoldStart(line)\\n\\t\\t\\t&& !isLineVisible(line + 1))\\n\\t\\t{\\n\\t\\t\\tline--;\\n\\t\\t}\\n\\t\\tint initialFoldLevel = buffer.getFoldLevel(line);\\n\\t\\t\\t\\tif(line != lineCount - 1\\n\\t\\t\\t&& buffer.getFoldLevel(line + 1) > initialFoldLevel)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tstart = line + 1;\\n\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.getFoldLevel(i) <= initialFoldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tboolean ok = false;\\n\\t\\t\\t\\t\\t\\tfor(int i = line - 1; i >= 0; i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstart = i + 1;\\n\\t\\t\\t\\t\\tok = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(!ok)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\thideLineRange(start,end);\\n\\t\\t_notifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic int expandFold(int line, boolean fully)\\n\\t{\\n\\t\\t\\t\\tint returnValue = -1;\\n\\t\\tint lineCount = buffer.getLineCount();\\n\\t\\tint start = 0;\\n\\t\\tint end = lineCount - 1;\\n\\t\\tint initialFoldLevel = buffer.getFoldLevel(line);\\n\\t\\t\\t\\tif(line != lineCount - 1\\n\\t\\t\\t&& isLineVisible(line)\\n\\t\\t\\t&& !isLineVisible(line + 1)\\n\\t\\t\\t&& buffer.getFoldLevel(line + 1) > initialFoldLevel)\\n\\t\\t{\\n\\t\\t\\tint index = fvmget(line + 1);\\n\\t\\t\\tstart = fvm[index];\\n\\t\\t\\tif(index != fvmcount - 1)\\n\\t\\t\\t\\tend = fvm[index + 1] - 1;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart = line + 1;\\n\\t\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(\\n\\t\\t\\t\\t\\t\\tbuffer.getFoldLevel(i) <= initialFoldLevel)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint index = fvmget(line);\\n\\t\\t\\tstart = fvm[index];\\n\\t\\t\\tif(index != fvmcount - 1)\\n\\t\\t\\t\\tend = fvm[index + 1] - 1;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif((isLineVisible(i) &&\\n\\t\\t\\t\\t\\t\\tbuffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t\\t\\t|| i == getLastVisibleLine())\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tif(fully)\\n\\t\\t{\\n\\t\\t\\tshowLineRange(start,end);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tinitialFoldLevel = buffer.getFoldLevel(start);\\n\\t\\t\\tint firstVisible = start;\\n\\t\\t\\tfor(int i = start; i <= end; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.getFoldLevel(i) > initialFoldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(returnValue == -1\\n\\t\\t\\t\\t\\t\\t&& i != 0\\n\\t\\t\\t\\t\\t\\t&& buffer.isFoldStart(i - 1))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturnValue = i - 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(firstVisible != i)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tshowLineRange(firstVisible,i - 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfirstVisible = i + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(firstVisible != end + 1)\\n\\t\\t\\t\\tshowLineRange(firstVisible,end);\\n\\t\\t\\tif(!isLineVisible(line))\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\texpandFold(line,false);\\n\\t\\t\\t\\treturn returnValue;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t_notifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t\\treturn returnValue;\\n\\t} \\n\\tpublic void expandAllFolds()\\n\\t{\\n\\t\\tshowLineRange(0,buffer.getLineCount() - 1);\\n\\t\\t_notifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic void expandFolds(char digit)\\n\\t{\\n\\t\\tif(digit < '1' || digit > '9')\\n\\t\\t{\\n\\t\\t\\tToolkit.getDefaultToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\texpandFolds((int)(digit - '1') + 1);\\n\\t} \\n\\tpublic void expandFolds(int foldLevel)\\n\\t{\\n\\t\\tif(buffer.getFoldHandler() instanceof IndentFoldHandler)\\n\\t\\t\\tfoldLevel = (foldLevel - 1) * buffer.getIndentSize() + 1;\\n\\t\\tshowLineRange(0,buffer.getLineCount() - 1);\\n\\t\\tboolean seenVisibleLine = false;\\n\\t\\tint firstInvisible = 0;\\n\\t\\tfor(int i = 0; i < buffer.getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tif(!seenVisibleLine || buffer.getFoldLevel(i) < foldLevel)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(firstInvisible != i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\thideLineRange(firstInvisible,\\n\\t\\t\\t\\t\\t\\ti - 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfirstInvisible = i + 1;\\n\\t\\t\\t\\tseenVisibleLine = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(firstInvisible != buffer.getLineCount())\\n\\t\\t\\thideLineRange(firstInvisible,buffer.getLineCount() - 1);\\n\\t\\t_notifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic void narrow(int start, int end)\\n\\t{\\n\\t\\tif(start > end || start < 0 || end >= buffer.getLineCount())\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(start + \\\", \\\" + end);\\n\\t\\tif(start < getFirstVisibleLine() || end > getLastVisibleLine())\\n\\t\\t\\texpandAllFolds();\\n\\t\\tif(start != 0)\\n\\t\\t\\thideLineRange(0,start - 1);\\n\\t\\tif(end != buffer.getLineCount() - 1)\\n\\t\\t\\thideLineRange(end + 1,buffer.getLineCount() - 1);\\n\\t\\t\\t\\tif(start != buffer.getLineCount() - 1\\n\\t\\t\\t&& !isLineVisible(start + 1))\\n\\t\\t\\texpandFold(start,false);\\n\\t\\t\\t\\t\\t\\tGUIUtilities.getView(textArea).getStatus().setMessageAndClear(\\n\\t\\t\\tjEdit.getProperty(\\\"view.status.narrow\\\"));\\n\\t\\t_notifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\t\\tboolean softWrap;\\n\\tint wrapMargin;\\n\\tFirstLine firstLine;\\n\\tScrollLineCount scrollLineCount;\\n\\t\\tvoid init()\\n\\t{\\n\\t\\tif(!initialized)\\n\\t\\t{\\n\\t\\t\\tinitialized = true;\\n\\t\\t\\tfvm = new int[2];\\n\\t\\t\\tif(buffer.isLoaded())\\n\\t\\t\\t\\tbufferChangeHandler.foldHandlerChanged(buffer);\\n\\t\\t\\telse\\n\\t\\t\\t\\tfvmreset();\\n\\t\\t\\t_notifyScreenLineChanges();\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tupdateWrapSettings();\\n\\t\\t\\t_notifyScreenLineChanges();\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t}\\n\\t} \\n\\tvoid setScreenLineCount(int line, int count)\\n\\t{\\n\\t\\tint oldCount = lineMgr.getScreenLineCount(line);\\n\\t\\t\\t\\t\\t\\t\\t\\tlineMgr.setScreenLineCount(line,count);\\n\\t\\t\\t\\t\\t\\tif(count != oldCount)\\n\\t\\t{\\n\\t\\t\\tIterator iter = ((List)bufferMap.get(buffer))\\n\\t\\t\\t\\t.iterator();\\n\\t\\t\\twhile(iter.hasNext())\\n\\t\\t\\t{\\n\\t\\t\\t\\t((DisplayManager)iter.next())._setScreenLineCount(\\n\\t\\t\\t\\t\\tline,oldCount,count);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tvoid updateWrapSettings()\\n\\t{\\n\\t\\tString wrap = buffer.getStringProperty(\\\"wrap\\\");\\n\\t\\tsoftWrap = wrap.equals(\\\"soft\\\");\\n\\t\\tif(textArea.maxLineLen <= 0)\\n\\t\\t{\\n\\t\\t\\tsoftWrap = false;\\n\\t\\t\\twrapMargin = 0;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tchar[] foo = new char[textArea.maxLineLen];\\n\\t\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfoo[i] = ' ';\\n\\t\\t\\t}\\n\\t\\t\\tTextAreaPainter painter = textArea.getPainter();\\n\\t\\t\\twrapMargin = (int)painter.getFont().getStringBounds(\\n\\t\\t\\t\\tfoo,0,foo.length,\\n\\t\\t\\t\\tpainter.getFontRenderContext())\\n\\t\\t\\t\\t.getWidth();\\n\\t\\t}\\n\\t} \\n\\t\\tvoid _notifyScreenLineChanges()\\n\\t{\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"_notifyScreenLineChanges()\\\");\\n\\t\\t\\t\\t\\t\\tif(textArea.getDisplayManager() == this)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(firstLine.callReset)\\n\\t\\t\\t\\t\\tfirstLine.reset();\\n\\t\\t\\t\\telse if(firstLine.callChanged)\\n\\t\\t\\t\\t\\tfirstLine.changed();\\n\\t\\t\\t\\tif(scrollLineCount.callReset)\\n\\t\\t\\t\\t\\tscrollLineCount.reset();\\n\\t\\t\\t\\telse if(scrollLineCount.callChanged)\\n\\t\\t\\t\\t\\tscrollLineCount.changed();\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.callReset = firstLine.callChanged = false;\\n\\t\\t\\t\\tscrollLineCount.callReset = scrollLineCount.callChanged = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate boolean initialized;\\n\\tprivate boolean inUse;\\n\\tprivate Buffer buffer;\\n\\tprivate LineManager lineMgr;\\n\\tprivate JEditTextArea textArea;\\n\\tprivate BufferChangeHandler bufferChangeHandler;\\n\\tprivate int[] fvm;\\n\\tprivate int fvmcount;\\n\\tprivate int lastfvmget = -1;\\n\\t\\tprivate DisplayManager(Buffer buffer, JEditTextArea textArea)\\n\\t{\\n\\t\\tthis.buffer = buffer;\\n\\t\\tthis.lineMgr = buffer._getLineManager();\\n\\t\\tthis.textArea = textArea;\\n\\t\\tscrollLineCount = new ScrollLineCount();\\n\\t\\tfirstLine = new FirstLine();\\n\\t\\tbufferChangeHandler = new BufferChangeHandler();\\n\\t\\t\\t\\tbuffer.addBufferChangeListener(bufferChangeHandler,\\n\\t\\t\\tBuffer.HIGH_PRIORITY);\\n\\t} \\n\\t\\tprivate void dispose()\\n\\t{\\n\\t\\tbuffer.removeBufferChangeListener(bufferChangeHandler);\\n\\t} \\n\\t\\tprivate void fvmreset()\\n\\t{\\n\\t\\tlastfvmget = -1;\\n\\t\\tfvmcount = 2;\\n\\t\\tfvm[0] = 0;\\n\\t\\tfvm[1] = buffer.getLineCount();\\n\\t} \\n\\tprivate int fvmget(int line)\\n\\t{\\n\\t\\tscanCount++;\\n\\t\\tif(line < fvm[0])\\n\\t\\t\\treturn -1;\\n\\t\\tif(line >= fvm[fvmcount - 1])\\n\\t\\t\\treturn fvmcount - 1;\\n\\t\\tif(lastfvmget != -1)\\n\\t\\t{\\n\\t\\t\\tif(line >= fvm[lastfvmget])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(lastfvmget == fvmcount - 1\\n\\t\\t\\t\\t\\t|| line < fvm[lastfvmget + 1])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn lastfvmget;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint start = 0;\\n\\t\\tint end = fvmcount - 1;\\nloop:\\t\\tfor(;;)\\n\\t\\t{\\n\\t\\t\\tscannedLines++;\\n\\t\\t\\tswitch(end - start)\\n\\t\\t\\t{\\n\\t\\t\\tcase 0:\\n\\t\\t\\t\\tlastfvmget = start;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\tint value = fvm[end];\\n\\t\\t\\t\\tif(value <= line)\\n\\t\\t\\t\\t\\tlastfvmget = end;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tlastfvmget = start;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tint pivot = (end + start) / 2;\\n\\t\\t\\t\\tvalue = fvm[pivot];\\n\\t\\t\\t\\tif(value == line)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastfvmget = pivot;\\n\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(value < line)\\n\\t\\t\\t\\t\\tstart = pivot;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tend = pivot - 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn lastfvmget;\\n\\t} \\n\\tprivate void fvmput(int start, int end, int[] put)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tStringBuffer buf = new StringBuffer(\\\"{\\\");\\n\\t\\t\\tif(put != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i = 0; i < put.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(i != 0)\\n\\t\\t\\t\\t\\t\\tbuf.append(',');\\n\\t\\t\\t\\t\\tbuf.append(put[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tbuf.append(\\\"}\\\");\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"fvmput(\\\" + start + \\\",\\\"\\n\\t\\t\\t\\t+ end + \\\",\\\" + buf + \\\")\\\");\\n\\t\\t}\\n\\t\\tint putl = (put == null ? 0 : put.length);\\n\\t\\tint delta = putl - (end - start);\\n\\t\\tif(fvmcount + delta > fvm.length)\\n\\t\\t{\\n\\t\\t\\tint[] newfvm = new int[fvm.length * 2 + 1];\\n\\t\\t\\tSystem.arraycopy(fvm,0,newfvm,0,fvmcount);\\n\\t\\t\\tfvm = newfvm;\\n\\t\\t}\\n\\t\\tif(delta != 0)\\n\\t\\t{\\n\\t\\t\\tSystem.arraycopy(fvm,end,fvm,start + putl,\\n\\t\\t\\t\\tfvmcount - end);\\n\\t\\t}\\n\\t\\tif(putl != 0)\\n\\t\\t{\\n\\t\\t\\tSystem.arraycopy(put,0,fvm,start,put.length);\\n\\t\\t}\\n\\t\\tfvmcount += delta;\\n\\t\\tfvmdump();\\n\\t\\tif(fvmcount == 0)\\n\\t\\t\\tthrow new InternalError();\\n\\t} \\n\\tprivate void fvmput2(int starti, int endi, int start, int end)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"*fvmput2(\\\" + starti + \\\",\\\"\\n\\t\\t\\t\\t+ endi + \\\",\\\" + start + \\\",\\\" + end + \\\")\\\");\\n\\t\\t}\\n\\t\\tif(starti != -1 && fvm[starti] == start)\\n\\t\\t{\\n\\t\\t\\tif(endi <= fvmcount - 2 && fvm[endi + 1]\\n\\t\\t\\t\\t== end + 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti,endi + 2,null);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti,endi + 1,\\n\\t\\t\\t\\t\\tnew int[] { end + 1 });\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(endi != fvmcount - 1 && fvm[endi + 1]\\n\\t\\t\\t\\t== end + 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 2,\\n\\t\\t\\t\\t\\tnew int[] { start });\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 1,\\n\\t\\t\\t\\t\\tnew int[] { start,\\n\\t\\t\\t\\t\\tend + 1 });\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fvmdump()\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tStringBuffer buf = new StringBuffer(\\\"{\\\");\\n\\t\\t\\tfor(int i = 0; i < fvmcount; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i != 0)\\n\\t\\t\\t\\t\\tbuf.append(',');\\n\\t\\t\\t\\tbuf.append(fvm[i]);\\n\\t\\t\\t}\\n\\t\\t\\tbuf.append(\\\"}\\\");\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"fvm = \\\" + buf);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void showLineRange(int start, int end)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"showLineRange(\\\" + start\\n\\t\\t\\t\\t+ \\\",\\\" + end + \\\")\\\");\\n\\t\\t}\\n\\t\\tfor(int i = start; i <= end; i++)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(!isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tint screenLines = getScreenLineCount(i);\\n\\t\\t\\t\\tif(firstLine.physicalLine >= i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfirstLine.scrollLine += screenLines;\\n\\t\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tscrollLineCount.scrollLine += screenLines;\\n\\t\\t\\t\\tscrollLineCount.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint starti = fvmget(start);\\n\\t\\tint endi = fvmget(end);\\n\\t\\tif(starti % 2 == 0)\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 1,null);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(endi != fvmcount - 1\\n\\t\\t\\t\\t\\t&& fvm[endi + 1] == end + 1)\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi + 2,null);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\t\\tfvm[starti + 1] = end + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(starti != -1 && fvm[starti] == start)\\n\\t\\t\\t\\t\\tfvmput(starti,endi + 1,null);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\t\\tfvm[starti + 1] = start;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tfvmput2(starti,endi,start,end);\\n\\t\\t}\\n\\t\\tlastfvmget = -1;\\n\\t} \\n\\t\\tprivate void hideLineRange(int start, int end)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"hideLineRange(\\\" + start\\n\\t\\t\\t\\t+ \\\",\\\" + end + \\\")\\\");\\n\\t\\t}\\n\\t\\tfor(int i = start; i <= end; i++)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint screenLines = lineMgr\\n\\t\\t\\t\\t\\t.getScreenLineCount(i);\\n\\t\\t\\t\\tif(firstLine.physicalLine >= i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfirstLine.scrollLine -= screenLines;\\n\\t\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tscrollLineCount.scrollLine -= screenLines;\\n\\t\\t\\t\\tscrollLineCount.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint starti = fvmget(start);\\n\\t\\tint endi = fvmget(end);\\n\\t\\tif(starti % 2 == 0)\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t\\tfvmput2(starti,endi,start,end);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\tfvm[starti + 1] = start;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\tfvm[starti + 1] = end + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 1,null);\\n\\t\\t}\\n\\t\\tlastfvmget = -1;\\n\\t} \\n\\t\\tprivate void _setScreenLineCount(int line, int oldCount, int count)\\n\\t{\\n\\t\\tif(!isLineVisible(line))\\n\\t\\t\\treturn;\\n\\t\\tif(firstLine.physicalLine >= line)\\n\\t\\t{\\n\\t\\t\\tif(firstLine.physicalLine == line)\\n\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.scrollLine += (count - oldCount);\\n\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tscrollLineCount.scrollLine += (count - oldCount);\\n\\t\\tscrollLineCount.callChanged = true;\\n\\t} \\n\\t\\tstatic abstract class Anchor\\n\\t{\\n\\t\\tint physicalLine;\\n\\t\\tint scrollLine;\\n\\t\\tboolean callChanged;\\n\\t\\tboolean callReset;\\n\\t\\tabstract void reset();\\n\\t\\tabstract void changed();\\n\\t} \\n\\t\\tclass ScrollLineCount extends Anchor\\n\\t{\\n\\t\\t\\t\\tpublic void changed()\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"changed()\\\");\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t} \\n\\t\\t\\t\\tpublic void reset()\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"reset()\\\");\\n\\t\\t\\tphysicalLine = getFirstVisibleLine();\\n\\t\\t\\tscrollLine = 0;\\n\\t\\t\\twhile(physicalLine != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\tphysicalLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t}\\n\\t\\t\\tphysicalLine = buffer.getLineCount();\\n\\t\\t\\tfirstLine.ensurePhysicalLineIsVisible();\\n\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t} \\t} \\n\\t\\tclass FirstLine extends Anchor\\n\\t{\\n\\t\\tint skew;\\n\\t\\t\\t\\tpublic void changed()\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"changed() before: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t} \\n\\t\\t\\tensurePhysicalLineIsVisible();\\n\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\tif(skew >= screenLines)\\n\\t\\t\\t\\tskew = screenLines - 1;\\n\\t\\t\\t\\t\\t\\tif(Debug.SCROLL_VERIFY)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint verifyScrollLine = 0;\\n\\t\\t\\t\\tfor(int i = 0; i < buffer.getLineCount(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!isLineVisible(i))\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\tif(i >= physicalLine)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tverifyScrollLine += getScreenLineCount(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(verifyScrollLine != scrollLine)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tException ex = new Exception(scrollLine + \\\":\\\" + verifyScrollLine);\\n\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,ex);\\n\\t\\t\\t\\t\\tnew org.gjt.sp.jedit.gui.BeanShellErrorDialog(null,ex);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"changed() after: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t} \\n\\t\\t\\tif(!scrollLineCount.callChanged\\n\\t\\t\\t\\t&& !scrollLineCount.callReset)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void reset()\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"reset()\\\");\\n\\t\\t\\tString wrap = buffer.getStringProperty(\\\"wrap\\\");\\n\\t\\t\\tsoftWrap = wrap.equals(\\\"soft\\\");\\n\\t\\t\\tif(textArea.maxLineLen <= 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsoftWrap = false;\\n\\t\\t\\t\\twrapMargin = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tchar[] foo = new char[textArea.maxLineLen];\\n\\t\\t\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfoo[i] = ' ';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tTextAreaPainter painter = textArea.getPainter();\\n\\t\\t\\t\\twrapMargin = (int)painter.getFont().getStringBounds(\\n\\t\\t\\t\\t\\tfoo,0,foo.length,\\n\\t\\t\\t\\t\\tpainter.getFontRenderContext())\\n\\t\\t\\t\\t\\t.getWidth();\\n\\t\\t\\t}\\n\\t\\t\\tscrollLine = 0;\\n\\t\\t\\tint i = getFirstVisibleLine();\\n\\t\\t\\tfor(;;)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i >= physicalLine)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tscrollLine += getScreenLineCount(i);\\n\\t\\t\\t\\tint nextLine = getNextVisibleLine(i);\\n\\t\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\ti = nextLine;\\n\\t\\t\\t}\\n\\t\\t\\tphysicalLine = i;\\n\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\tif(skew >= screenLines)\\n\\t\\t\\t\\tskew = screenLines - 1;\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid physDown(int amount, int screenAmount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physDown() start: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tskew = 0;\\n\\t\\t\\tif(!isLineVisible(physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint lastVisibleLine = getLastVisibleLine();\\n\\t\\t\\t\\tif(physicalLine > lastVisibleLine)\\n\\t\\t\\t\\t\\tphysicalLine = lastVisibleLine;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint nextPhysicalLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tamount -= (nextPhysicalLine - physicalLine);\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = nextPhysicalLine;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(;;)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint nextPhysicalLine = getNextVisibleLine(\\n\\t\\t\\t\\t\\tphysicalLine);\\n\\t\\t\\t\\tif(nextPhysicalLine == -1)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse if(nextPhysicalLine > physicalLine + amount)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t\\tamount -= (nextPhysicalLine - physicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = nextPhysicalLine;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physDown() end: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tcallChanged = true;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(screenAmount < 0)\\n\\t\\t\\t\\tscrollUp(-screenAmount);\\n\\t\\t\\telse if(screenAmount > 0)\\n\\t\\t\\t\\tscrollDown(screenAmount);\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid physUp(int amount, int screenAmount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physUp() start: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tskew = 0;\\n\\t\\t\\tif(!isLineVisible(physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint firstVisibleLine = getFirstVisibleLine();\\n\\t\\t\\t\\tif(physicalLine < firstVisibleLine)\\n\\t\\t\\t\\t\\tphysicalLine = firstVisibleLine;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint prevPhysicalLine = getPrevVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tamount -= (physicalLine - prevPhysicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(;;)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint prevPhysicalLine = getPrevVisibleLine(\\n\\t\\t\\t\\t\\tphysicalLine);\\n\\t\\t\\t\\tif(prevPhysicalLine == -1)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse if(prevPhysicalLine < physicalLine - amount)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tamount -= (physicalLine - prevPhysicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = prevPhysicalLine;\\n\\t\\t\\t\\t\\tscrollLine -= getScreenLineCount(\\n\\t\\t\\t\\t\\t\\tprevPhysicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physUp() end: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tcallChanged = true;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(screenAmount < 0)\\n\\t\\t\\t\\tscrollUp(-screenAmount);\\n\\t\\t\\telse if(screenAmount > 0)\\n\\t\\t\\t\\tscrollDown(screenAmount);\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid scrollDown(int amount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"scrollDown()\\\");\\n\\t\\t\\tensurePhysicalLineIsVisible();\\n\\t\\t\\tamount += skew;\\n\\t\\t\\tskew = 0;\\n\\t\\t\\twhile(amount > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\t\\tif(amount < screenLines)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tskew = amount;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint nextLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tboolean visible = isLineVisible(physicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = nextLine;\\n\\t\\t\\t\\t\\tif(visible)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tamount -= screenLines;\\n\\t\\t\\t\\t\\t\\tscrollLine += screenLines;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcallChanged = true;\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid scrollUp(int amount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"scrollUp()\\\");\\n\\t\\t\\tensurePhysicalLineIsVisible();\\n\\t\\t\\tif(amount <= skew)\\n\\t\\t\\t{\\n\\t\\t\\t\\tskew -= amount;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tamount -= skew;\\n\\t\\t\\t\\tskew = 0;\\n\\t\\t\\t\\twhile(amount > 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint prevLine = getPrevVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tif(prevLine == -1)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tphysicalLine = prevLine;\\n\\t\\t\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t\\tscrollLine -= screenLines;\\n\\t\\t\\t\\t\\tif(amount < screenLines)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tskew = screenLines - amount;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tamount -= screenLines;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcallChanged = true;\\n\\t\\t} \\n\\t\\t\\t\\tprivate void ensurePhysicalLineIsVisible()\\n\\t\\t{\\n\\t\\t\\tif(!isLineVisible(physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(physicalLine > getLastVisibleLine())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysicalLine = getLastVisibleLine();\\n\\t\\t\\t\\t\\tscrollLine = getScrollLineCount() - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(physicalLine < getFirstVisibleLine())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysicalLine = getFirstVisibleLine();\\n\\t\\t\\t\\t\\tscrollLine = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysicalLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\t} \\n\\tclass BufferChangeHandler extends BufferChangeAdapter\\n\\t{\\n\\t\\tboolean delayedUpdate;\\n\\t\\tboolean delayedMultilineUpdate;\\n\\t\\tint delayedUpdateStart;\\n\\t\\tint delayedUpdateEnd;\\n\\t\\t\\t\\tpublic void foldHandlerChanged(Buffer buffer)\\n\\t\\t{\\n\\t\\t\\tfvmreset();\\n\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\tint collapseFolds = buffer.getIntegerProperty(\\n\\t\\t\\t\\t\\\"collapseFolds\\\",0);\\n\\t\\t\\tif(collapseFolds != 0)\\n\\t\\t\\t\\texpandFolds(collapseFolds);\\n\\t\\t\\t_notifyScreenLineChanges();\\n\\t\\t} \\n\\t\\t\\t\\tpublic void foldLevelChanged(Buffer buffer, int start, int end)\\n\\t\\t{\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this\\n\\t\\t\\t\\t&& end != 0 && buffer.isLoaded())\\n\\t\\t\\t{\\n\\t\\t\\t\\ttextArea.invalidateLineRange(start - 1,\\n\\t\\t\\t\\t\\ttextArea.getLastPhysicalLine());\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void contentInserted(Buffer buffer, int startLine,\\n\\t\\t\\tint offset, int numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tint endLine = startLine + numLines;\\n\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedMultilineUpdate = true;\\n\\t\\t\\t\\tint index = fvmget(startLine);\\n\\t\\t\\t\\tint start = index + 1;\\n\\t\\t\\t\\tfor(int i = start; i < fvmcount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvm[i] += numLines;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlastfvmget = -1;\\n\\t\\t\\t\\tfvmdump();\\n\\t\\t\\t}\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontentInserted(firstLine,startLine,numLines);\\n\\t\\t\\t\\tcontentInserted(scrollLineCount,startLine,numLines);\\n\\t\\t\\t\\tif(delayedUpdateEnd >= startLine)\\n\\t\\t\\t\\t\\tdelayedUpdateEnd += numLines;\\n\\t\\t\\t\\tdelayedUpdate(startLine,endLine);\\n\\t\\t\\t\\t\\t\\t\\t\\tfor(int i = 0; i < textArea.selection.size(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection s = (Selection)textArea\\n\\t\\t\\t\\t\\t\\t.selection.elementAt(i);\\n\\t\\t\\t\\t\\tif(s.contentInserted(buffer,startLine,offset,\\n\\t\\t\\t\\t\\t\\tnumLines,length))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdelayedUpdate(s.startLine,s.endLine);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tint caret = textArea.getCaretPosition();\\n\\t\\t\\t\\tif(caret >= offset)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.ELECTRIC_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(\\n\\t\\t\\t\\t\\t\\tcaret + length,scrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.NORMAL_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(\\n\\t\\t\\t\\t\\t\\tcaret,scrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void preContentRemoved(Buffer buffer, int startLine,\\n\\t\\t\\tint offset, int numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this)\\n\\t\\t\\t{\\n\\t\\t\\t\\tpreContentRemoved(firstLine,startLine,numLines);\\n\\t\\t\\t\\tpreContentRemoved(scrollLineCount,startLine,numLines);\\n\\t\\t\\t\\tif(delayedUpdateEnd >= startLine)\\n\\t\\t\\t\\t\\tdelayedUpdateEnd -= numLines;\\n\\t\\t\\t\\tdelayedUpdate(startLine,startLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\t}\\n\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedMultilineUpdate = true;\\n\\t\\t\\t\\tint endLine = startLine + numLines;\\n\\t\\t\\t\\tint starti = fvmget(startLine);\\n\\t\\t\\t\\tint endi = fvmget(endLine);\\n\\t\\t\\t\\tif(Math.abs(starti % 2) == Math.abs(endi % 2))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(endi - starti == fvmcount)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfvmreset();\\n\\t\\t\\t\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\t\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tfvmput(starti + 1,endi + 1,null);\\n\\t\\t\\t\\t\\t\\tstarti++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(starti != -1 && fvm[starti] == startLine)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfvmput(starti,endi + 1,null);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\t\\tfvm[starti + 1] = startLine;\\n\\t\\t\\t\\t\\tstarti += 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int i = starti; i < fvmcount; i++)\\n\\t\\t\\t\\t\\tfvm[i] -= numLines;\\n\\t\\t\\t\\tif(firstLine.physicalLine\\n\\t\\t\\t\\t\\t> getLastVisibleLine()\\n\\t\\t\\t\\t\\t|| firstLine.physicalLine\\n\\t\\t\\t\\t\\t< getFirstVisibleLine())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\telse if(!isLineVisible(\\n\\t\\t\\t\\t\\tfirstLine.physicalLine))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfirstLine.physicalLine =\\n\\t\\t\\t\\t\\t\\tgetNextVisibleLine(\\n\\t\\t\\t\\t\\t\\tfirstLine.physicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlastfvmget = -1;\\n\\t\\t\\t\\tfvmdump();\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void contentRemoved(Buffer buffer, int startLine,\\n\\t\\t\\tint start, int numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint endLine = startLine + numLines;\\n\\t\\t\\t\\t\\t\\t\\t\\tfor(int i = 0; i < textArea.selection.size(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection s = (Selection)textArea\\n\\t\\t\\t\\t\\t\\t.selection.elementAt(i);\\n\\t\\t\\t\\t\\tif(s.contentRemoved(buffer,startLine,\\n\\t\\t\\t\\t\\t\\tstart,numLines,length))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdelayedUpdate(s.startLine,s.endLine);\\n\\t\\t\\t\\t\\t\\tif(s.start == s.end)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\ttextArea.selection.removeElementAt(i);\\n\\t\\t\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tint caret = textArea.getCaretPosition();\\n\\t\\t\\t\\tif(caret >= start + length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.ELECTRIC_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(\\n\\t\\t\\t\\t\\t\\tcaret - length,\\n\\t\\t\\t\\t\\t\\tscrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(caret >= start)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.ELECTRIC_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(\\n\\t\\t\\t\\t\\t\\tstart,scrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.NORMAL_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(caret,scrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tpublic void transactionComplete(Buffer buffer)\\n\\t\\t{\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(delayedUpdate)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t_notifyScreenLineChanges();\\n\\t\\t\\t\\t\\tif(delayedMultilineUpdate)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ttextArea.invalidateScreenLineRange(\\n\\t\\t\\t\\t\\t\\t\\ttextArea.chunkCache\\n\\t\\t\\t\\t\\t\\t\\t.getScreenLineOfOffset(\\n\\t\\t\\t\\t\\t\\t\\tdelayedUpdateStart,0),\\n\\t\\t\\t\\t\\t\\t\\ttextArea.getVisibleLines());\\n\\t\\t\\t\\t\\t\\tdelayedMultilineUpdate = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ttextArea.invalidateLineRange(\\n\\t\\t\\t\\t\\t\\t\\tdelayedUpdateStart,\\n\\t\\t\\t\\t\\t\\t\\tdelayedUpdateEnd);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tint _firstLine = textArea.getFirstPhysicalLine();\\n\\t\\t\\t\\t\\tint _lastLine = textArea.getLastPhysicalLine();\\n\\t\\t\\t\\t\\tint line = delayedUpdateStart;\\n\\t\\t\\t\\t\\tif(!isLineVisible(line))\\n\\t\\t\\t\\t\\t\\tline = getNextVisibleLine(line);\\n\\t\\t\\t\\t\\twhile(line != -1 && line <= delayedUpdateEnd)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(line < _firstLine\\n\\t\\t\\t\\t\\t\\t\\t|| line > _lastLine)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tgetScreenLineCount(line);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tline = getNextVisibleLine(line);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tint visibleLines = textArea\\n\\t\\t\\t\\t\\t\\t.getVisibleLines();\\n\\t\\t\\t\\t\\tif(visibleLines != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ttextArea.chunkCache.getLineInfo(\\n\\t\\t\\t\\t\\t\\t\\tvisibleLines - 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttextArea._finishCaretUpdate();\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(Debug.SCROLL_VERIFY)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint scrollLineCount = 0;\\n\\t\\t\\t\\tfor(int i = 0; i < textArea.getLineCount(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(isLineVisible(i))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tscrollLineCount +=\\n\\t\\t\\t\\t\\t\\t\\tgetScreenLineCount(i);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(scrollLineCount != getScrollLineCount())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tthrow new InternalError(scrollLineCount\\n\\t\\t\\t\\t\\t\\t+ \\\" != \\\"\\n\\t\\t\\t\\t\\t\\t+ getScrollLineCount());\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\tdelayedUpdate = false;\\n\\t\\t} \\n\\t\\t\\t\\tprivate void contentInserted(Anchor anchor, int startLine,\\n\\t\\t\\tint numLines)\\n\\t\\t{\\n\\t\\t\\tif(anchor.physicalLine >= startLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(anchor.physicalLine != startLine)\\n\\t\\t\\t\\t\\tanchor.physicalLine += numLines;\\n\\t\\t\\t\\tanchor.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void preContentRemoved(Anchor anchor, int startLine,\\n\\t\\t\\tint numLines)\\n\\t\\t{\\n\\t\\t\\tif(anchor.physicalLine >= startLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(anchor.physicalLine == startLine)\\n\\t\\t\\t\\t\\tanchor.callChanged = true;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint end = Math.min(startLine + numLines,\\n\\t\\t\\t\\t\\t\\tanchor.physicalLine);\\n\\t\\t\\t\\t\\tfor(int i = startLine; i < end; i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(isLineVisible(i))\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tanchor.scrollLine -=\\n\\t\\t\\t\\t\\t\\t\\t\\tlineMgr\\n\\t\\t\\t\\t\\t\\t\\t\\t.getScreenLineCount(i);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tanchor.physicalLine -= (end - startLine);\\n\\t\\t\\t\\t\\tanchor.callChanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void delayedUpdate(int startLine, int endLine)\\n\\t\\t{\\n\\t\\t\\ttextArea.chunkCache.invalidateChunksFromPhys(startLine);\\n\\t\\t\\tif(!delayedUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedUpdateStart = startLine;\\n\\t\\t\\t\\tdelayedUpdateEnd = endLine;\\n\\t\\t\\t\\tdelayedUpdate = true;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedUpdateStart = Math.min(\\n\\t\\t\\t\\t\\tdelayedUpdateStart,\\n\\t\\t\\t\\t\\tstartLine);\\n\\t\\t\\t\\tdelayedUpdateEnd = Math.max(\\n\\t\\t\\t\\t\\tdelayedUpdateEnd,\\n\\t\\t\\t\\t\\tendLine);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tprivate boolean caretAutoScroll()\\n\\t\\t{\\n\\t\\t\\tView view = textArea.getView();\\n\\t\\t\\treturn view == jEdit.getActiveView()\\n\\t\\t\\t\\t&& view.getTextArea() == textArea;\\n\\t\\t} \\t} }\""
            },
            "m17": {
                "role": "user",
                "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
            },
            "m18": {
                "content": "Title: Diagnosis of starting entity `DisplayManager`\n\nChange set: [Log, ChunkCache, JEditTextArea, TextAreaPainter, BufferChangeHandler, FirstLine, ScrollLineCount, HelpIndex, HelpTOCPanel, View, RingListModel, OffsetManager, PosBottomHalf, PositionManager, PasteFromListDialog, ListHandler, KeyHandler, FontSelector, FontSelectorDialog, TextAreaOptionPane, ActionHandler, BeanShell, MouseHandler, Anchor, RangeMap]\n\nDetails:\n- **Log**: Directly referenced in the call graph of `DisplayManager.java`, indicating logging functionality is used.\n- **ChunkCache**: Historically co-changed with high support and although no coupling found, it may still be logically related to rendering or layout management.\n- **JEditTextArea**: A core component used by `DisplayManager` for text display and interaction, likely tightly integrated.\n- **TextAreaPainter**: Related to rendering visible lines, possibly called from DisplayManager during painting operations.\n- **BufferChangeHandler**: Instantiated and used directly by `DisplayManager`, making it integral to buffer change handling.\n- **FirstLine**/**ScrollLineCount**: Though removed in current versions, they were frequently co-changed with DisplayManager historically and used internally for scroll and line tracking.\n- **HelpIndex**/**HelpTOCPanel**: Part of UI components that might interact with DisplayManager for help-related views.\n- **View**: Central UI class in jEdit; likely used by DisplayManager for view updates or synchronization.\n- **RingListModel**/**OffsetManager**/**PosBottomHalf**/**PositionManager**: Possibly involved in managing visible content positions or scrolling states.\n- **PasteFromListDialog**/**ListHandler**/**KeyHandler**: UI or event handlers that may synchronize visual changes with DisplayManager.\n- **FontSelector**/**FontSelectorDialog**: May affect display rendering and thus could require synchronization.\n- **TextAreaOptionPane**/**ActionHandler**: Configuration/UI components potentially linked to display behavior.\n- **BeanShell**/**MouseHandler**/**Anchor**/**RangeMap**: Ancillary classes that might influence or react to display state changes.\n\nEven though some files like `FirstLine` and `ScrollLineCount` are now removed, their historical co-change relationship suggests past relevance. Based on CIA principles, we include entities with notable historical correlation, conceptual or indirect usage, or direct coupling.",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            }
        }
    }
}