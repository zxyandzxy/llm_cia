{
    "time": 1749540488.369073,
    "messages": [
        {
            "role": "system",
            "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
        },
        {
            "role": "user",
            "content": "The project you need to analyze is `jEdit`, a well-known Java open source project. The starting entity you need to deal with is JEditTextArea.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
        },
        {
            "content": "",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_9f2a7399492247eda5af20",
                    "function": {
                        "arguments": "{\"entity\": \"JEditTextArea.java\"}",
                        "name": "get_co_change_relationship"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "name": "get_co_change_relationship",
            "role": "tool",
            "content": "[[\"MouseHandler\", \"47\", \"0.26704545454545453\"], [\"Buffer\", \"19\", \"0.10795454545454546\"], [\"FoldVisibilityManager\", \"9\", \"0.05113636363636364\"], [\"DefaultInputHandler\", \"8\", \"0.045454545454545456\"], [\"SearchAndReplace\", \"17\", \"0.09659090909090909\"], [\"View\", \"21\", \"0.11931818181818182\"], [\"CharIndexedSegment\", \"2\", \"0.011363636363636364\"], [\"SearchMatcher\", \"4\", \"0.022727272727272728\"], [\"BrowserJTree\", \"4\", \"0.022727272727272728\"], [\"BoyerMooreSearchMatcher\", \"6\", \"0.03409090909090909\"], [\"HyperSearchRequest\", \"4\", \"0.022727272727272728\"], [\"RESearchMatcher\", \"6\", \"0.03409090909090909\"], [\"TextRenderer\", \"2\", \"0.011363636363636364\"], [\"RotatedTextIcon\", \"2\", \"0.011363636363636364\"], [\"FileVFS\", \"7\", \"0.03977272727272727\"], [\"FontSelectorDialog\", \"2\", \"0.011363636363636364\"], [\"FileRootsVFS\", \"4\", \"0.022727272727272728\"], [\"PanelWindowContainer\", \"8\", \"0.045454545454545456\"], [\"FontSelector\", \"2\", \"0.011363636363636364\"], [\"TextAreaPainter\", \"40\", \"0.22727272727272727\"], [\"Chunk\", \"4\", \"0.022727272727272728\"], [\"AboutPanel\", \"2\", \"0.011363636363636364\"], [\"TextUtilities\", \"11\", \"0.0625\"], [\"OffsetManager\", \"24\", \"0.13636363636363635\"], [\"BufferPrintable\", \"10\", \"0.056818181818181816\"], [\"MyFocusManager\", \"2\", \"0.011363636363636364\"], [\"BrowserView\", \"6\", \"0.03409090909090909\"], [\"BrowserIORequest\", \"4\", \"0.022727272727272728\"], [\"VFSBrowser\", \"12\", \"0.06818181818181818\"], [\"ChunkCache\", \"51\", \"0.2897727272727273\"], [\"LineInfo\", \"6\", \"0.03409090909090909\"], [\"BufferChangeHandler\", \"50\", \"0.2840909090909091\"], [\"Gutter\", \"25\", \"0.14204545454545456\"], [\"EditPane\", \"13\", \"0.07386363636363637\"], [\"FocusHandler\", \"5\", \"0.028409090909090908\"], [\"TOCTree\", \"2\", \"0.011363636363636364\"], [\"HelpViewer\", \"6\", \"0.03409090909090909\"], [\"HyperSearchResults\", \"5\", \"0.028409090909090908\"], [\"BufferPrinter\", \"2\", \"0.011363636363636364\"], [\"SearchDialog\", \"6\", \"0.03409090909090909\"], [\"EditAction\", \"4\", \"0.022727272727272728\"], [\"Macro\", \"2\", \"0.011363636363636364\"], [\"EnhancedButton\", \"2\", \"0.011363636363636364\"], [\"EnhancedMenuItem\", \"2\", \"0.011363636363636364\"], [\"ActionListHandler\", \"2\", \"0.011363636363636364\"], [\"InputHandler\", \"5\", \"0.028409090909090908\"], [\"DockingOptionPane\", \"2\", \"0.011363636363636364\"], [\"PaintSelection\", \"8\", \"0.045454545454545456\"], [\"ActionHandler\", \"17\", \"0.09659090909090909\"], [\"CompoundEdit\", \"2\", \"0.011363636363636364\"], [\"UndoManager\", \"4\", \"0.022727272727272728\"], [\"MemoryStatus\", \"2\", \"0.011363636363636364\"], [\"KeyEventWorkaround\", \"8\", \"0.045454545454545456\"], [\"HistoryModel\", \"2\", \"0.011363636363636364\"], [\"MultiSelectStatusChanged\", \"2\", \"0.011363636363636364\"], [\"GutterOptionPane\", \"2\", \"0.011363636363636364\"], [\"AbstractOptionPane\", \"2\", \"0.011363636363636364\"], [\"OptionsDialog\", \"2\", \"0.011363636363636364\"], [\"TextAreaOptionPane\", \"2\", \"0.011363636363636364\"], [\"Renderer\", \"2\", \"0.011363636363636364\"], [\"AbbrevsOptionPane\", \"2\", \"0.011363636363636364\"], [\"ExtensionManager\", \"2\", \"0.011363636363636364\"], [\"BrowserHandler\", \"2\", \"0.011363636363636364\"], [\"VFSFileChooserDialog\", \"4\", \"0.022727272727272728\"], [\"Word\", \"2\", \"0.011363636363636364\"], [\"Result\", \"2\", \"0.011363636363636364\"], [\"ModeOptionPane\", \"4\", \"0.022727272727272728\"], [\"HelpIndex\", \"3\", \"0.017045454545454544\"], [\"ModeProperties\", \"4\", \"0.022727272727272728\"], [\"HelpSearchPanel\", \"2\", \"0.011363636363636364\"], [\"ResultRenderer\", \"2\", \"0.011363636363636364\"], [\"BufferOptions\", \"4\", \"0.022727272727272728\"], [\"EditingOptionPane\", \"4\", \"0.022727272727272728\"], [\"KeyHandler\", \"3\", \"0.017045454545454544\"], [\"CompleteWord\", \"3\", \"0.017045454545454544\"], [\"CaretHandler\", \"1\", \"0.005681818181818182\"], [\"ResultVisitor\", \"1\", \"0.005681818181818182\"], [\"MouseWheelHandler\", \"6\", \"0.03409090909090909\"], [\"BufferLoadedVisitor\", \"1\", \"0.005681818181818182\"], [\"BufferClosedVisitor\", \"1\", \"0.005681818181818182\"], [\"Operation\", \"2\", \"0.011363636363636364\"], [\"Install\", \"4\", \"0.022727272727272728\"], [\"Plugin\", \"2\", \"0.011363636363636364\"], [\"PluginManagerProgress\", \"2\", \"0.011363636363636364\"], [\"Remove\", \"2\", \"0.011363636363636364\"], [\"Roster\", \"4\", \"0.022727272727272728\"], [\"SoftWrapTokenHandler\", \"2\", \"0.011363636363636364\"], [\"PluginResURLConnection\", \"2\", \"0.011363636363636364\"], [\"SettingsReloader\", \"2\", \"0.011363636363636364\"], [\"Autosave\", \"4\", \"0.022727272727272728\"], [\"BufferIORequest\", \"8\", \"0.045454545454545456\"], [\"BeanShell\", \"4\", \"0.022727272727272728\"], [\"DisplayTokenHandler\", \"6\", \"0.03409090909090909\"], [\"Log\", \"2\", \"0.011363636363636364\"], [\"GUIUtilities\", \"7\", \"0.03977272727272727\"], [\"LogViewer\", \"6\", \"0.03409090909090909\"], [\"ListHandler\", \"2\", \"0.011363636363636364\"], [\"LogListModel\", \"2\", \"0.011363636363636364\"], [\"Anchor\", \"4\", \"0.022727272727272728\"], [\"DisplayManager\", \"24\", \"0.13636363636363635\"], [\"ScrollLineCount\", \"8\", \"0.045454545454545456\"], [\"FirstLine\", \"20\", \"0.11363636363636363\"], [\"WrapGuide\", \"4\", \"0.022727272727272728\"], [\"DockableWindowManager\", \"9\", \"0.05113636363636364\"], [\"Entry\", \"6\", \"0.03409090909090909\"], [\"EnhancedCheckBoxMenuItem\", \"2\", \"0.011363636363636364\"], [\"FileCellRenderer\", \"2\", \"0.011363636363636364\"], [\"PaneNameRenderer\", \"2\", \"0.011363636363636364\"], [\"StatusBar\", \"5\", \"0.028409090909090908\"], [\"ParentDirectoryRenderer\", \"2\", \"0.011363636363636364\"], [\"RolloverButton\", \"4\", \"0.022727272727272728\"], [\"EditPlugin\", \"2\", \"0.011363636363636364\"], [\"EnhancedMenu\", \"2\", \"0.011363636363636364\"], [\"Debug\", \"6\", \"0.03409090909090909\"], [\"PaintLineBackground\", \"4\", \"0.022727272727272728\"], [\"ButtonLayout\", \"4\", \"0.022727272727272728\"], [\"VFSDirectoryEntryTable\", \"2\", \"0.011363636363636364\"], [\"VFSFileNameField\", \"4\", \"0.022727272727272728\"], [\"DockablePanel\", \"2\", \"0.011363636363636364\"], [\"DockableWindowCompare\", \"2\", \"0.011363636363636364\"], [\"RectParams\", \"2\", \"0.011363636363636364\"], [\"VMS\", \"2\", \"0.011363636363636364\"], [\"RingListModel\", \"2\", \"0.011363636363636364\"], [\"ActionTextField\", \"2\", \"0.011363636363636364\"], [\"ActionBar\", \"2\", \"0.011363636363636364\"], [\"PluginTableModel\", \"5\", \"0.028409090909090908\"], [\"InputPane\", \"3\", \"0.017045454545454544\"], [\"GrabKeyDialog\", \"2\", \"0.011363636363636364\"], [\"ButtonActionHandler\", \"2\", \"0.011363636363636364\"], [\"TextAreaTransferHandler\", \"8\", \"0.045454545454545456\"], [\"PosBottomHalf\", \"4\", \"0.022727272727272728\"], [\"PositionManager\", \"4\", \"0.022727272727272728\"], [\"PosTopHalf\", \"2\", \"0.011363636363636364\"], [\"RootsEntry\", \"2\", \"0.011363636363636364\"], [\"ActionSet\", \"2\", \"0.011363636363636364\"], [\"PluginJAR\", \"3\", \"0.017045454545454544\"], [\"DropHandler\", \"2\", \"0.011363636363636364\"], [\"SplashScreen\", \"2\", \"0.011363636363636364\"], [\"MiscUtilities\", \"5\", \"0.028409090909090908\"], [\"PerspectiveManager\", \"2\", \"0.011363636363636364\"], [\"DockableLayout\", \"2\", \"0.011363636363636364\"], [\"InstallPanel\", \"3\", \"0.017045454545454544\"], [\"LogList\", \"2\", \"0.011363636363636364\"], [\"MarkerHighlight\", \"2\", \"0.011363636363636364\"], [\"DockableListHandler\", \"2\", \"0.011363636363636364\"], [\"CheckBoxListModel\", \"2\", \"0.011363636363636364\"], [\"jEdit\", \"2\", \"0.011363636363636364\"], [\"ScrollLayout\", \"2\", \"0.011363636363636364\"], [\"TextAreaBorder\", \"2\", \"0.011363636363636364\"], [\"PaintWrapGuide\", \"4\", \"0.022727272727272728\"], [\"SelectionManager\", \"3\", \"0.017045454545454544\"], [\"Reset\", \"2\", \"0.011363636363636364\"], [\"RegexpIndentRule\", \"4\", \"0.022727272727272728\"], [\"OpenBracketIndentRule\", \"2\", \"0.011363636363636364\"], [\"IndentRuleFactory\", \"2\", \"0.011363636363636364\"], [\"Registers\", \"2\", \"0.011363636363636364\"], [\"RegisterViewer\", \"2\", \"0.011363636363636364\"], [\"Rect\", \"2\", \"0.011363636363636364\"], [\"JEditBuffer\", \"2\", \"0.011363636363636364\"], [\"AlignBracket\", \"2\", \"0.011363636363636364\"], [\"VFS\", \"2\", \"0.011363636363636364\"], [\"MacOSPlugin\", \"1\", \"0.005681818181818182\"], [\"Macros\", \"1\", \"0.005681818181818182\"], [\"BrowserColorsModel\", \"1\", \"0.005681818181818182\"]]"
        },
        {
            "content": "The co-change relationships for the entity `JEditTextArea.java` have been retrieved. The results indicate several files that are frequently modified together with `JEditTextArea.java`. Here's how we can interpret some of the top results:\n\n1. **MouseHandler (support: 47, confidence: ~0.267)**:\n   - Frequently changed alongside mouse-related functionality in `JEditTextArea`.\n\n2. **Buffer (support: 19, confidence: ~0.108)**:\n   - Related to buffer management within the text area.\n\n3. **TextAreaPainter (support: 40, confidence: ~0.227)**:\n   - A significant relationship suggesting frequent changes related to painting or rendering of the text area.\n\n4. **ChunkCache (support: 51, confidence: ~0.290)**:\n   - High support indicates it is often involved in changes with `JEditTextArea`, possibly related to caching chunks of text data.\n\n5. **BufferChangeHandler (support: 50, confidence: ~0.284)**:\n   - Strong indication of close coupling regarding buffer change events.\n\n6. **Gutter (support: 25, confidence: ~0.142)**:\n   - Often modified together with JEditTextArea, potentially involving line number or gutter-related visual elements.\n\n7. **DisplayManager (support: 24, confidence: ~0.136)**:\n   - Another key component likely involved in rendering and display logic tied to the text area.\n\n8. **OffsetManager (support: 24, confidence: ~0.136)**:\n   - Manages offsets in the text area, indicating a strong functional dependency.\n\nThese entities should be carefully reviewed for potential synchronization needs when changes are made to `JEditTextArea.java`.\n\nNext, to better understand the structural dependencies, I will use the `get_call_graph` function on `JEditTextArea.java` to see which entities are directly called or referenced by this class. \n\nLet me proceed with that.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_ad393200fd1f440a916190",
                    "function": {
                        "arguments": "{\"entity\": \"JEditTextArea.java\"}",
                        "name": "get_call_graph"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_call_graph",
            "content": "[\"Log\", \"\", \"\", \"\", \"\"]"
        },
        {
            "content": "The call graph analysis for `JEditTextArea.java` returned minimal useful information, showing only a reference to `Log`, which likely relates to logging functionality. Unfortunately, the majority of the output appears to be empty or incomplete, which doesn't help in identifying direct structural dependencies.\n\nGiven this limitation, we can instead examine the source code of `JEditTextArea.java` directly to identify important structural relationships and dependencies. By analyzing its method calls, variable usages, and other interactions with other classes, we can uncover entities that are tightly coupled with it.\n\nLet me retrieve the source code of `JEditTextArea.java` for further analysis.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_78ce53788bee41b8bc8a45",
                    "function": {
                        "arguments": "{\"entity\": \"JEditTextArea.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package org.gjt.sp.jedit.textarea;\\nimport java.awt.*;\\nimport java.awt.event.*;\\nimport java.lang.reflect.Method;\\nimport java.util.Enumeration;\\nimport java.util.Iterator;\\nimport java.util.LinkedList;\\nimport java.util.List;\\nimport java.util.Set;\\nimport java.util.TreeSet;\\nimport java.util.Vector;\\nimport javax.swing.*;\\nimport javax.swing.border.*;\\nimport javax.swing.event.*;\\nimport javax.swing.plaf.metal.MetalLookAndFeel;\\nimport javax.swing.text.Position;\\nimport javax.swing.text.Segment;\\nimport org.gjt.sp.jedit.*;\\nimport org.gjt.sp.jedit.buffer.*;\\nimport org.gjt.sp.jedit.gui.*;\\nimport org.gjt.sp.jedit.syntax.*;\\nimport org.gjt.sp.util.Log;\\npublic class JEditTextArea extends JComponent\\n{\\n\\tpublic JEditTextArea(View view)\\n\\t{\\n\\t\\tenableEvents(AWTEvent.FOCUS_EVENT_MASK | AWTEvent.KEY_EVENT_MASK);\\n\\t\\tthis.view = view;\\n\\t\\t\\t\\tselection = new Vector();\\n\\t\\tchunkCache = new ChunkCache(this);\\n\\t\\tpainter = new TextAreaPainter(this);\\n\\t\\tgutter = new Gutter(view,this);\\n\\t\\tbufferHandler = new BufferChangeHandler();\\n\\t\\tlistenerList = new EventListenerList();\\n\\t\\tcaretEvent = new MutableCaretEvent();\\n\\t\\tblink = true;\\n\\t\\tlineSegment = new Segment();\\n\\t\\treturnValue = new Point();\\n\\t\\trunnables = new LinkedList();\\n\\t\\tstructureMatchers = new LinkedList();\\n\\t\\tstructureMatchers.add(new StructureMatcher.BracketMatcher());\\n\\t\\t\\t\\tsetLayout(new ScrollLayout());\\n\\t\\tadd(CENTER,painter);\\n\\t\\tadd(LEFT,gutter);\\n\\t\\t\\t\\tverticalBox = new Box(BoxLayout.X_AXIS);\\n\\t\\tverticalBox.add(vertical = new JScrollBar(JScrollBar.VERTICAL));\\n\\t\\tvertical.setRequestFocusEnabled(false);\\n\\t\\tadd(RIGHT,verticalBox);\\n\\t\\tadd(BOTTOM,horizontal = new JScrollBar(JScrollBar.HORIZONTAL));\\n\\t\\thorizontal.setRequestFocusEnabled(false);\\n\\t\\thorizontal.setValues(0,0,0,0);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(UIManager.getLookAndFeel() instanceof MetalLookAndFeel)\\n\\t\\t{\\n\\t\\t\\tsetBorder(new TextAreaBorder());\\n\\t\\t\\tvertical.putClientProperty(\\\"JScrollBar.isFreeStanding\\\",\\n\\t\\t\\t\\tBoolean.FALSE);\\n\\t\\t\\thorizontal.putClientProperty(\\\"JScrollBar.isFreeStanding\\\",\\n\\t\\t\\t\\tBoolean.FALSE);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\tvertical.addAdjustmentListener(new AdjustHandler());\\n\\t\\thorizontal.addAdjustmentListener(new AdjustHandler());\\n\\t\\tmouseHandler = new MouseHandler();\\n\\t\\tpainter.addMouseListener(mouseHandler);\\n\\t\\tpainter.addMouseMotionListener(mouseHandler);\\n\\t\\taddFocusListener(new FocusHandler());\\n\\t\\t\\t\\t\\t\\t\\t\\tfocusedComponent = this;\\n\\t} \\n\\tpublic void dispose()\\n\\t{\\n\\t\\tDisplayManager.textAreaDisposed(this);\\n\\t} \\n\\tpublic final TextAreaPainter getPainter()\\n\\t{\\n\\t\\treturn painter;\\n\\t} \\n\\tpublic final Gutter getGutter()\\n\\t{\\n\\t\\treturn gutter;\\n\\t} \\n\\tpublic DisplayManager getDisplayManager()\\n\\t{\\n\\t\\treturn displayManager;\\n\\t} \\n\\tpublic final boolean isCaretBlinkEnabled()\\n\\t{\\n\\t\\treturn caretBlinks;\\n\\t} \\n\\tpublic void setCaretBlinkEnabled(boolean caretBlinks)\\n\\t{\\n\\t\\tthis.caretBlinks = caretBlinks;\\n\\t\\tif(!caretBlinks)\\n\\t\\t\\tblink = false;\\n\\t\\tif(buffer != null)\\n\\t\\t\\tinvalidateLine(caretLine);\\n\\t} \\n\\tpublic final int getElectricScroll()\\n\\t{\\n\\t\\treturn electricScroll;\\n\\t} \\n\\tpublic final void setElectricScroll(int electricScroll)\\n\\t{\\n\\t\\tthis.electricScroll = electricScroll;\\n\\t} \\n\\tpublic final boolean isQuickCopyEnabled()\\n\\t{\\n\\t\\treturn quickCopy;\\n\\t} \\n\\tpublic final void setQuickCopyEnabled(boolean quickCopy)\\n\\t{\\n\\t\\tthis.quickCopy = quickCopy;\\n\\t} \\n\\tpublic final Buffer getBuffer()\\n\\t{\\n\\t\\treturn buffer;\\n\\t} \\n\\tpublic void setBuffer(Buffer buffer)\\n\\t{\\n\\t\\tif(this.buffer == buffer)\\n\\t\\t\\treturn;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbufferChanging = true;\\n\\t\\t\\tif(this.buffer != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\t\\tcaretLine = caret = caretScreenLine = 0;\\n\\t\\t\\t\\tmatch = null;\\n\\t\\t\\t\\tthis.buffer.removeBufferChangeListener(bufferHandler);\\n\\t\\t\\t}\\n\\t\\t\\tthis.buffer = buffer;\\n\\t\\t\\tbuffer.addBufferChangeListener(bufferHandler);\\n\\t\\t\\tbufferHandlerInstalled = true;\\n\\t\\t\\tchunkCache.setBuffer(buffer);\\n\\t\\t\\tpropertiesChanged();\\n\\t\\t\\tif(displayManager != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tDisplayManager.releaseDisplayManager(\\n\\t\\t\\t\\t\\tdisplayManager);\\n\\t\\t\\t}\\n\\t\\t\\tdisplayManager = DisplayManager.getDisplayManager(\\n\\t\\t\\t\\tbuffer,this);\\n\\t\\t\\tdisplayManager.init();\\n\\t\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\t\\trepaint();\\n\\t\\t\\tfireScrollEvent(true);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbufferChanging = false;\\n\\t\\t}\\n\\t} \\n\\tpublic final boolean isEditable()\\n\\t{\\n\\t\\treturn buffer.isEditable();\\n\\t} \\n\\tpublic final JPopupMenu getRightClickPopup()\\n\\t{\\n\\t\\treturn popup;\\n\\t} \\n\\tpublic final void setRightClickPopup(JPopupMenu popup)\\n\\t{\\n\\t\\tthis.popup = popup;\\n\\t} \\n\\tpublic Method getDragAndDropCallback()\\n\\t{\\n\\t\\treturn dndCallback;\\n\\t} \\n\\tpublic void setDragAndDropCallback(Method meth)\\n\\t{\\n\\t\\tdndCallback = meth;\\n\\t} \\n\\tpublic boolean isDragInProgress()\\n\\t{\\n\\t\\treturn dndInProgress;\\n\\t} \\n\\tpublic void setDragInProgress(boolean dndInProgress)\\n\\t{\\n\\t\\tthis.dndInProgress = dndInProgress;\\n\\t} \\n\\tpublic boolean isDragEnabled()\\n\\t{\\n\\t\\treturn dndEnabled;\\n\\t} \\n\\tpublic void setDragEnabled(boolean dndEnabled)\\n\\t{\\n\\t\\tthis.dndEnabled = dndEnabled;\\n\\t} \\n\\tpublic final int getFirstLine()\\n\\t{\\n\\t\\treturn displayManager.firstLine.scrollLine\\n\\t\\t\\t+ displayManager.firstLine.skew;\\n\\t} \\n\\t\\tpublic Exception trace;\\n\\tpublic void setFirstLine(int firstLine)\\n\\t{\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"setFirstLine() from \\\"\\n\\t\\t\\t\\t+ getFirstLine() + \\\" to \\\" + firstLine);\\n\\t\\t}\\n\\t\\t\\t\\tint max = displayManager.getScrollLineCount() - visibleLines\\n\\t\\t\\t+ (lastLinePartial ? 1 : 0);\\n\\t\\tif(firstLine > max)\\n\\t\\t\\tfirstLine = max;\\n\\t\\tif(firstLine < 0)\\n\\t\\t\\tfirstLine = 0;\\n\\t\\tint oldFirstLine = getFirstLine();\\n\\t\\tif(firstLine == oldFirstLine)\\n\\t\\t\\treturn;\\n\\t\\ttrace = new Exception();\\n\\t\\tif(firstLine >= oldFirstLine + visibleLines)\\n\\t\\t{\\n\\t\\t\\tdisplayManager.firstLine.scrollDown(firstLine - oldFirstLine);\\n\\t\\t\\tchunkCache.invalidateAll();\\n\\t\\t}\\n\\t\\telse if(firstLine <= oldFirstLine - visibleLines)\\n\\t\\t{\\n\\t\\t\\tdisplayManager.firstLine.scrollUp(oldFirstLine - firstLine);\\n\\t\\t\\tchunkCache.invalidateAll();\\n\\t\\t}\\n\\t\\telse if(firstLine > oldFirstLine)\\n\\t\\t{\\n\\t\\t\\tdisplayManager.firstLine.scrollDown(firstLine - oldFirstLine);\\n\\t\\t\\tchunkCache.scrollDown(firstLine - oldFirstLine);\\n\\t\\t}\\n\\t\\telse if(firstLine < oldFirstLine)\\n\\t\\t{\\n\\t\\t\\tdisplayManager.firstLine.scrollUp(oldFirstLine - firstLine);\\n\\t\\t\\tchunkCache.scrollUp(oldFirstLine - firstLine);\\n\\t\\t}\\n\\t\\tdisplayManager.firstLine.changed();\\n\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\trepaint();\\n\\t\\tfireScrollEvent(true);\\n\\t} \\n\\tpublic final int getFirstPhysicalLine()\\n\\t{\\n\\t\\treturn displayManager.firstLine.physicalLine;\\n\\t} \\n\\tpublic void setFirstPhysicalLine(int physFirstLine)\\n\\t{\\n\\t\\tsetFirstPhysicalLine(physFirstLine,0);\\n\\t} \\n\\tpublic void setFirstPhysicalLine(int physFirstLine, int skew)\\n\\t{\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"setFirstPhysicalLine(\\\"\\n\\t\\t\\t\\t+ physFirstLine + \\\",\\\" + skew + \\\")\\\");\\n\\t\\t}\\n\\t\\tint amount = (physFirstLine - displayManager.firstLine.physicalLine);\\n\\t\\tint oldFirstLine = getFirstLine();\\n\\t\\tif(amount == 0)\\n\\t\\t{\\n\\t\\t\\tskew -= displayManager.firstLine.skew;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(skew < 0)\\n\\t\\t\\t\\tdisplayManager.firstLine.scrollUp(-skew);\\n\\t\\t\\telse if(skew > 0)\\n\\t\\t\\t\\tdisplayManager.firstLine.scrollDown(skew);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(amount > 0)\\n\\t\\t\\tdisplayManager.firstLine.physDown(amount,skew);\\n\\t\\telse if(amount < 0)\\n\\t\\t\\tdisplayManager.firstLine.physUp(-amount,skew);\\n\\t\\tint firstLine = getFirstLine();\\n\\t\\tif(firstLine == oldFirstLine)\\n\\t\\t\\t;\\n\\t\\telse if(firstLine >= oldFirstLine + visibleLines\\n\\t\\t\\t|| firstLine <= oldFirstLine - visibleLines)\\n\\t\\t{\\n\\t\\t\\tchunkCache.invalidateAll();\\n\\t\\t}\\n\\t\\telse if(firstLine > oldFirstLine)\\n\\t\\t{\\n\\t\\t\\tchunkCache.scrollDown(firstLine - oldFirstLine);\\n\\t\\t}\\n\\t\\telse if(firstLine < oldFirstLine)\\n\\t\\t{\\n\\t\\t\\tchunkCache.scrollUp(oldFirstLine - firstLine);\\n\\t\\t}\\n\\t\\tdisplayManager.firstLine.changed();\\n\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\trepaint();\\n\\t\\tfireScrollEvent(true);\\n\\t} \\n\\tpublic final int getLastPhysicalLine()\\n\\t{\\n\\t\\treturn physLastLine;\\n\\t} \\n\\tpublic final int getVisibleLines()\\n\\t{\\n\\t\\treturn visibleLines;\\n\\t} \\n\\tpublic final int getHorizontalOffset()\\n\\t{\\n\\t\\treturn horizontalOffset;\\n\\t} \\n\\tpublic void setHorizontalOffset(int horizontalOffset)\\n\\t{\\n\\t\\tif(horizontalOffset > 0)\\n\\t\\t\\thorizontalOffset = 0;\\n\\t\\tif(horizontalOffset == this.horizontalOffset)\\n\\t\\t\\treturn;\\n\\t\\tthis.horizontalOffset = horizontalOffset;\\n\\t\\tif(horizontalOffset != horizontal.getValue())\\n\\t\\t\\tupdateScrollBars();\\n\\t\\tpainter.repaint();\\n\\t\\tfireScrollEvent(false);\\n\\t} \\n\\tpublic void scrollUpLine()\\n\\t{\\n\\t\\tsetFirstLine(getFirstLine() - 1);\\n\\t} \\n\\tpublic void scrollUpPage()\\n\\t{\\n\\t\\tsetFirstLine(getFirstLine() - getVisibleLines()\\n\\t\\t\\t+ (lastLinePartial ? 1 : 0));\\n\\t} \\n\\tpublic void scrollDownLine()\\n\\t{\\n\\t\\tsetFirstLine(getFirstLine() + 1);\\n\\t} \\n\\tpublic void scrollDownPage()\\n\\t{\\n\\t\\tsetFirstLine(getFirstLine() + getVisibleLines()\\n\\t\\t\\t- (lastLinePartial ? 1 : 0));\\n\\t} \\n\\tpublic void scrollToCaret(boolean doElectricScroll)\\n\\t{\\n\\t\\tscrollTo(caretLine,caret - buffer.getLineStartOffset(caretLine),\\n\\t\\t\\tdoElectricScroll);\\n\\t} \\n\\tpublic void scrollTo(int offset, boolean doElectricScroll)\\n\\t{\\n\\t\\tint line = buffer.getLineOfOffset(offset);\\n\\t\\tscrollTo(line,offset - buffer.getLineStartOffset(line),\\n\\t\\t\\tdoElectricScroll);\\n\\t} \\n\\tpublic void scrollTo(int line, int offset, boolean doElectricScroll)\\n\\t{\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"scrollTo(), lineCount=\\\"\\n\\t\\t\\t\\t+ getLineCount());\\n\\t\\t\\t\\tint extraEndVirt;\\n\\t\\tint lineLength = buffer.getLineLength(line);\\n\\t\\tif(offset > lineLength)\\n\\t\\t{\\n\\t\\t\\textraEndVirt = charWidth * (offset - lineLength);\\n\\t\\t\\toffset = lineLength;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\textraEndVirt = 0;\\n\\t\\tint _electricScroll = (doElectricScroll\\n\\t\\t\\t&& visibleLines - 1 > electricScroll * 2\\n\\t\\t\\t? electricScroll : 0); \\n\\t\\tif(visibleLines == 0)\\n\\t\\t{\\n\\t\\t\\tsetFirstPhysicalLine(line,_electricScroll);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\t\\tint firstLine = getFirstLine();\\n\\t\\tint screenLine = chunkCache.getScreenLineOfOffset(line,offset);\\n\\t\\tint visibleLines = getVisibleLines();\\n\\t\\tif(screenLine == -1)\\n\\t\\t{\\n\\t\\t\\tChunkCache.LineInfo[] infos = chunkCache\\n\\t\\t\\t\\t.getLineInfosForPhysicalLine(line);\\n\\t\\t\\tint subregion = chunkCache.getSubregionOfOffset(\\n\\t\\t\\t\\toffset,infos);\\n\\t\\t\\tint prevLine = displayManager.getPrevVisibleLine(getFirstPhysicalLine());\\n\\t\\t\\tint nextLine = displayManager.getNextVisibleLine(getLastPhysicalLine());\\n\\t\\t\\tif(line == prevLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFirstPhysicalLine(prevLine,subregion\\n\\t\\t\\t\\t\\t- _electricScroll);\\n\\t\\t\\t}\\n\\t\\t\\telse if(line == nextLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFirstPhysicalLine(nextLine,\\n\\t\\t\\t\\t\\tsubregion + electricScroll\\n\\t\\t\\t\\t\\t- visibleLines\\n\\t\\t\\t\\t\\t+ (lastLinePartial ? 2 : 1));\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFirstPhysicalLine(line,subregion\\n\\t\\t\\t\\t\\t- visibleLines / 2);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(screenLine < _electricScroll)\\n\\t\\t{\\n\\t\\t\\tsetFirstLine(getFirstLine() - _electricScroll + screenLine);\\n\\t\\t}\\n\\t\\telse if(screenLine > visibleLines - _electricScroll\\n\\t\\t\\t- (lastLinePartial ? 2 : 1))\\n\\t\\t{\\n\\t\\t\\tsetFirstLine(getFirstLine() + _electricScroll - visibleLines + screenLine + (lastLinePartial ? 2 : 1));\\n\\t\\t} \\n\\t\\t\\t\\tif(!displayManager.isLineVisible(line))\\n\\t\\t\\treturn;\\n\\t\\tPoint point = offsetToXY(line,offset,returnValue);\\n\\t\\tif(point == null)\\n\\t\\t\\tLog.log(Log.ERROR,this,\\\"BUG: screenLine=\\\" + screenLine\\n\\t\\t\\t\\t+ \\\",visibleLines=\\\" + visibleLines\\n\\t\\t\\t\\t+ \\\",physicalLine=\\\" + line\\n\\t\\t\\t\\t+ \\\",firstPhysicalLine=\\\" + getFirstPhysicalLine()\\n\\t\\t\\t\\t+ \\\",lastPhysicalLine=\\\" + getLastPhysicalLine());\\n\\t\\tpoint.x += extraEndVirt;\\n\\t\\tif(point.x < 0)\\n\\t\\t{\\n\\t\\t\\tsetHorizontalOffset(horizontalOffset\\n\\t\\t\\t\\t- point.x + charWidth + 5);\\n\\t\\t}\\n\\t\\telse if(point.x >= painter.getWidth() - charWidth - 5)\\n\\t\\t{\\n\\t\\t\\tsetHorizontalOffset(horizontalOffset +\\n\\t\\t\\t\\t(painter.getWidth() - point.x)\\n\\t\\t\\t\\t- charWidth - 5);\\n\\t\\t} \\t} \\n\\tpublic final void addScrollListener(ScrollListener listener)\\n\\t{\\n\\t\\tlistenerList.add(ScrollListener.class,listener);\\n\\t} \\n\\tpublic final void removeScrollListener(ScrollListener listener)\\n\\t{\\n\\t\\tlistenerList.remove(ScrollListener.class,listener);\\n\\t} \\n\\tpublic int getPhysicalLineOfScreenLine(int screenLine)\\n\\t{\\n\\t\\treturn chunkCache.getLineInfo(screenLine).physicalLine;\\n\\t} \\n\\tpublic int getScreenLineOfOffset(int offset)\\n\\t{\\n\\t\\tint line = buffer.getLineOfOffset(offset);\\n\\t\\toffset -= buffer.getLineStartOffset(line);\\n\\t\\treturn chunkCache.getScreenLineOfOffset(line,offset);\\n\\t} \\n\\tpublic int getScreenLineStartOffset(int line)\\n\\t{\\n\\t\\tChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);\\n\\t\\tif(lineInfo.physicalLine == -1)\\n\\t\\t\\treturn -1;\\n\\t\\treturn buffer.getLineStartOffset(lineInfo.physicalLine)\\n\\t\\t\\t+ lineInfo.offset;\\n\\t} \\n\\tpublic int getScreenLineEndOffset(int line)\\n\\t{\\n\\t\\tChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);\\n\\t\\tif(lineInfo.physicalLine == -1)\\n\\t\\t\\treturn -1;\\n\\t\\treturn buffer.getLineStartOffset(lineInfo.physicalLine)\\n\\t\\t\\t+ lineInfo.offset + lineInfo.length;\\n\\t} \\n\\tpublic int xyToOffset(int x, int y)\\n\\t{\\n\\t\\treturn xyToOffset(x,y,true);\\n\\t} \\n\\tpublic int xyToOffset(int x, int y, boolean round)\\n\\t{\\n\\t\\tFontMetrics fm = painter.getFontMetrics();\\n\\t\\tint height = fm.getHeight();\\n\\t\\tint line = y / height;\\n\\t\\tif(line < 0 || line >= visibleLines)\\n\\t\\t\\treturn -1;\\n\\t\\treturn xToScreenLineOffset(line,x,round);\\n\\t} \\n\\tpublic int xToScreenLineOffset(int screenLine, int x, boolean round)\\n\\t{\\n\\t\\tChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(screenLine);\\n\\t\\tif(lineInfo.physicalLine == -1)\\n\\t\\t{\\n\\t\\t\\treturn getLineEndOffset(displayManager\\n\\t\\t\\t\\t.getLastVisibleLine()) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint offset = Chunk.xToOffset(lineInfo.chunks,\\n\\t\\t\\t\\tx - horizontalOffset,round);\\n\\t\\t\\tif(offset == -1 || offset == lineInfo.offset + lineInfo.length)\\n\\t\\t\\t\\toffset = lineInfo.offset + lineInfo.length - 1;\\n\\t\\t\\treturn getLineStartOffset(lineInfo.physicalLine) + offset;\\n\\t\\t}\\n\\t} \\n\\tpublic Point offsetToXY(int offset)\\n\\t{\\n\\t\\tint line = buffer.getLineOfOffset(offset);\\n\\t\\toffset -= buffer.getLineStartOffset(line);\\n\\t\\tPoint retVal = new Point();\\n\\t\\treturn offsetToXY(line,offset,retVal);\\n\\t} \\n\\tpublic Point offsetToXY(int line, int offset, Point retVal)\\n\\t{\\n\\t\\tint screenLine = chunkCache.getScreenLineOfOffset(line,offset);\\n\\t\\tif(screenLine == -1)\\n\\t\\t\\treturn null;\\n\\t\\tFontMetrics fm = painter.getFontMetrics();\\n\\t\\tretVal.y = screenLine * fm.getHeight();\\n\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(screenLine);\\n\\t\\tretVal.x = (int)(horizontalOffset + Chunk.offsetToX(\\n\\t\\t\\tinfo.chunks,offset));\\n\\t\\treturn retVal;\\n\\t} \\n\\tpublic void invalidateScreenLineRange(int start, int end)\\n\\t{\\n\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\treturn;\\n\\t\\tif(start > end)\\n\\t\\t{\\n\\t\\t\\tint tmp = end;\\n\\t\\t\\tend = start;\\n\\t\\t\\tstart = tmp;\\n\\t\\t}\\n\\t\\tif(chunkCache.needFullRepaint())\\n\\t\\t\\tend = visibleLines;\\n\\t\\tFontMetrics fm = painter.getFontMetrics();\\n\\t\\tint y = start * fm.getHeight();\\n\\t\\tint height = (end - start + 1) * fm.getHeight();\\n\\t\\tpainter.repaint(0,y,painter.getWidth(),height);\\n\\t\\tgutter.repaint(0,y,gutter.getWidth(),height);\\n\\t} \\n\\tpublic void invalidateLine(int line)\\n\\t{\\n\\t\\tif(!isShowing()\\n\\t\\t\\t|| !buffer.isLoaded()\\n\\t\\t\\t|| line < getFirstPhysicalLine()\\n\\t\\t\\t|| line > physLastLine\\n\\t\\t\\t|| !displayManager.isLineVisible(line))\\n\\t\\t\\treturn;\\n\\t\\tint startLine = -1;\\n\\t\\tint endLine = -1;\\n\\t\\tfor(int i = 0; i < visibleLines; i++)\\n\\t\\t{\\n\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(i);\\n\\t\\t\\tif((info.physicalLine >= line || info.physicalLine == -1)\\n\\t\\t\\t\\t&& startLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstartLine = i;\\n\\t\\t\\t}\\n\\t\\t\\tif((info.physicalLine >= line && info.lastSubregion)\\n\\t\\t\\t\\t|| info.physicalLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tendLine = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(chunkCache.needFullRepaint() || endLine == -1)\\n\\t\\t\\tendLine = visibleLines;\\n\\t\\tinvalidateScreenLineRange(startLine,endLine);\\n\\t} \\n\\tpublic void invalidateLineRange(int start, int end)\\n\\t{\\n\\t\\tif(!isShowing() || !buffer.isLoaded())\\n\\t\\t\\treturn;\\n\\t\\tif(end < start)\\n\\t\\t{\\n\\t\\t\\tint tmp = end;\\n\\t\\t\\tend = start;\\n\\t\\t\\tstart = tmp;\\n\\t\\t}\\n\\t\\tif(end < getFirstPhysicalLine() || start > getLastPhysicalLine())\\n\\t\\t\\treturn;\\n\\t\\tint startScreenLine = -1;\\n\\t\\tint endScreenLine = -1;\\n\\t\\tfor(int i = 0; i < visibleLines; i++)\\n\\t\\t{\\n\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(i);\\n\\t\\t\\tif((info.physicalLine >= start || info.physicalLine == -1)\\n\\t\\t\\t\\t&& startScreenLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstartScreenLine = i;\\n\\t\\t\\t}\\n\\t\\t\\tif((info.physicalLine >= end && info.lastSubregion)\\n\\t\\t\\t\\t|| info.physicalLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tendScreenLine = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(startScreenLine == -1)\\n\\t\\t\\tstartScreenLine = 0;\\n\\t\\tif(chunkCache.needFullRepaint() || endScreenLine == -1)\\n\\t\\t\\tendScreenLine = visibleLines;\\n\\t\\tinvalidateScreenLineRange(startScreenLine,endScreenLine);\\n\\t} \\n\\tpublic void invalidateSelectedLines()\\n\\t{\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tinvalidateLineRange(s.startLine,s.endLine);\\n\\t\\t}\\n\\t} \\n\\tpublic final int getBufferLength()\\n\\t{\\n\\t\\treturn buffer.getLength();\\n\\t} \\n\\tpublic final int getLineCount()\\n\\t{\\n\\t\\treturn buffer.getLineCount();\\n\\t} \\n\\tpublic final int getLineOfOffset(int offset)\\n\\t{\\n\\t\\treturn buffer.getLineOfOffset(offset);\\n\\t} \\n\\tpublic int getLineStartOffset(int line)\\n\\t{\\n\\t\\treturn buffer.getLineStartOffset(line);\\n\\t} \\n\\tpublic int getLineEndOffset(int line)\\n\\t{\\n\\t\\treturn buffer.getLineEndOffset(line);\\n\\t} \\n\\tpublic int getLineLength(int line)\\n\\t{\\n\\t\\treturn buffer.getLineLength(line);\\n\\t} \\n\\tpublic final String getText(int start, int len)\\n\\t{\\n\\t\\treturn buffer.getText(start,len);\\n\\t} \\n\\tpublic final void getText(int start, int len, Segment segment)\\n\\t{\\n\\t\\tbuffer.getText(start,len,segment);\\n\\t} \\n\\tpublic final String getLineText(int lineIndex)\\n\\t{\\n\\t\\treturn buffer.getLineText(lineIndex);\\n\\t} \\n\\tpublic final void getLineText(int lineIndex, Segment segment)\\n\\t{\\n\\t\\tbuffer.getLineText(lineIndex,segment);\\n\\t} \\n\\tpublic String getText()\\n\\t{\\n\\t\\treturn buffer.getText(0,buffer.getLength());\\n\\t} \\n\\tpublic void setText(String text)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tbuffer.remove(0,buffer.getLength());\\n\\t\\t\\tbuffer.insert(0,text);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic final void selectAll()\\n\\t{\\n\\t\\tsetSelection(new Selection.Range(0,buffer.getLength()));\\n\\t\\tmoveCaretPosition(buffer.getLength(),true);\\n\\t} \\n\\tpublic void selectLine()\\n\\t{\\n\\t\\tint caretLine = getCaretLine();\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine) - 1;\\n\\t\\tSelection s = new Selection.Range(start,end);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(end);\\n\\t} \\n\\tpublic void selectParagraph()\\n\\t{\\n\\t\\tint caretLine = getCaretLine();\\n\\t\\tif(getLineLength(caretLine) == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint start = caretLine;\\n\\t\\tint end = caretLine;\\n\\t\\twhile(start >= 0)\\n\\t\\t{\\n\\t\\t\\tif(getLineLength(start) == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\telse\\n\\t\\t\\t\\tstart--;\\n\\t\\t}\\n\\t\\twhile(end < getLineCount())\\n\\t\\t{\\n\\t\\t\\tif(getLineLength(end) == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\telse\\n\\t\\t\\t\\tend++;\\n\\t\\t}\\n\\t\\tint selectionStart = getLineStartOffset(start + 1);\\n\\t\\tint selectionEnd = getLineEndOffset(end - 1) - 1;\\n\\t\\tSelection s = new Selection.Range(selectionStart,selectionEnd);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(selectionEnd);\\n\\t} \\n\\tpublic void selectWord()\\n\\t{\\n\\t\\tint line = getCaretLine();\\n\\t\\tint lineStart = getLineStartOffset(line);\\n\\t\\tint offset = getCaretPosition() - lineStart;\\n\\t\\tif(getLineLength(line) == 0)\\n\\t\\t\\treturn;\\n\\t\\tString lineText = getLineText(line);\\n\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\tif(offset == getLineLength(line))\\n\\t\\t\\toffset--;\\n\\t\\tint wordStart = TextUtilities.findWordStart(lineText,offset,noWordSep);\\n\\t\\tint wordEnd = TextUtilities.findWordEnd(lineText,offset+1,noWordSep);\\n\\t\\tSelection s = new Selection.Range(lineStart + wordStart,\\n\\t\\t\\tlineStart + wordEnd);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(lineStart + wordEnd);\\n\\t} \\n\\tpublic Selection selectToMatchingBracket(int position,\\n\\t\\tboolean quickCopy)\\n\\t{\\n\\t\\tint positionLine = buffer.getLineOfOffset(position);\\n\\t\\tint lineOffset = position - buffer.getLineStartOffset(positionLine);\\n\\t\\tif(getLineLength(positionLine) != 0)\\n\\t\\t{\\n\\t\\t\\tint bracket = TextUtilities.findMatchingBracket(buffer,\\n\\t\\t\\t\\tpositionLine,Math.max(0,lineOffset - 1));\\n\\t\\t\\tif(bracket != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s;\\n\\t\\t\\t\\tif(bracket < position)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!quickCopy)\\n\\t\\t\\t\\t\\t\\tmoveCaretPosition(position,false);\\n\\t\\t\\t\\t\\ts = new Selection.Range(bracket,position);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!quickCopy)\\n\\t\\t\\t\\t\\t\\tmoveCaretPosition(bracket + 1,false);\\n\\t\\t\\t\\t\\ts = new Selection.Range(position - 1,bracket + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!multi && !quickCopy)\\n\\t\\t\\t\\t\\tselectNone();\\n\\t\\t\\t\\taddToSelection(s);\\n\\t\\t\\t\\treturn s;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic void selectToMatchingBracket()\\n\\t{\\n\\t\\tselectToMatchingBracket(caret,false);\\n\\t} \\n\\tpublic void selectBlock()\\n\\t{\\n\\t\\tString openBrackets = \\\"([{\\\";\\n\\t\\tString closeBrackets = \\\")]}\\\";\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint start, end;\\n\\t\\tif(s == null)\\n\\t\\t\\tstart = end = caret;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstart = s.start;\\n\\t\\t\\tend = s.end;\\n\\t\\t}\\n\\t\\tString text = getText(0,buffer.getLength());\\n\\t\\t\\t\\tint count = 1;\\n\\t\\tchar openBracket = '\\\\0';\\n\\t\\tchar closeBracket = '\\\\0';\\n\\t\\t\\t\\tif(start == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\nbackward_scan:\\twhile(--start > 0)\\n\\t\\t{\\n\\t\\t\\tchar c = text.charAt(start);\\n\\t\\t\\tint index = openBrackets.indexOf(c);\\n\\t\\t\\tif(index != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(--count == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\topenBracket = c;\\n\\t\\t\\t\\t\\tcloseBracket = closeBrackets.charAt(index);\\n\\t\\t\\t\\t\\tbreak backward_scan;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(closeBrackets.indexOf(c) != -1)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\t\\t\\tcount = 1;\\n\\t\\t\\t\\tif(openBracket == '\\\\0')\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\nforward_scan:\\t\\tdo\\n\\t\\t\\t{\\n\\t\\t\\t\\tchar c = text.charAt(end);\\n\\t\\t\\t\\tif(c == closeBracket)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(--count == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend++;\\n\\t\\t\\t\\t\\t\\tbreak forward_scan;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(c == openBracket)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\twhile(++end < buffer.getLength());\\n\\t\\t}\\n\\t\\ts = new Selection.Range(start,end);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(end);\\n\\t} \\n\\tpublic boolean lineInStructureScope(int line)\\n\\t{\\n\\t\\tif(match == null)\\n\\t\\t\\treturn false;\\n\\t\\tif(match.startLine < caretLine)\\n\\t\\t\\treturn (line >= match.startLine && line <= caretLine);\\n\\t\\telse\\n\\t\\t\\treturn (line <= match.endLine && line >= caretLine);\\n\\t} \\n\\tpublic final void invertSelection()\\n\\t{\\n\\t\\tSelection[] newSelection = new Selection[selection.size() + 1];\\n\\t\\tint lastOffset = 0;\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tnewSelection[i] = new Selection.Range(lastOffset,\\n\\t\\t\\t\\ts.getStart());\\n\\t\\t\\tlastOffset = s.getEnd();\\n\\t\\t}\\n\\t\\tnewSelection[selection.size()] = new Selection.Range(\\n\\t\\t\\tlastOffset,buffer.getLength());\\n\\t\\tsetSelection(newSelection);\\n\\t} \\n\\tpublic int getSelectionCount()\\n\\t{\\n\\t\\treturn selection.size();\\n\\t} \\n\\tpublic Selection[] getSelection()\\n\\t{\\n\\t\\tSelection[] sel = new Selection[selection.size()];\\n\\t\\tselection.copyInto(sel);\\n\\t\\treturn sel;\\n\\t} \\n\\tpublic void selectNone()\\n\\t{\\n\\t\\tsetSelection((Selection)null);\\n\\t} \\n\\tpublic void setSelection(Selection[] selection)\\n\\t{\\n\\t\\t\\t\\tinvalidateSelectedLines();\\n\\t\\tthis.selection.removeAllElements();\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t\\t_addToSelection(selection[i]);\\n\\t\\t}\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void setSelection(Selection selection)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tthis.selection.removeAllElements();\\n\\t\\tif(selection != null)\\n\\t\\t\\t_addToSelection(selection);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void addToSelection(Selection[] selection)\\n\\t{\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t\\t_addToSelection(selection[i]);\\n\\t\\t}\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void addToSelection(Selection selection)\\n\\t{\\n\\t\\t_addToSelection(selection);\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic Selection getSelectionAtOffset(int offset)\\n\\t{\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\t\\tif(offset >= s.start && offset <= s.end)\\n\\t\\t\\t\\t\\treturn s;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic void removeFromSelection(Selection sel)\\n\\t{\\n\\t\\tselection.removeElement(sel);\\n\\t\\tinvalidateLineRange(sel.startLine,sel.endLine);\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void removeFromSelection(int offset)\\n\\t{\\n\\t\\tSelection sel = getSelectionAtOffset(offset);\\n\\t\\tif(sel == null)\\n\\t\\t\\treturn;\\n\\t\\tselection.removeElement(sel);\\n\\t\\tinvalidateLineRange(sel.startLine,sel.endLine);\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void resizeSelection(int offset, int end, int extraEndVirt,\\n\\t\\tboolean rect)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(offset);\\n\\t\\tif(s != null)\\n\\t\\t{\\n\\t\\t\\tinvalidateLineRange(s.startLine,s.endLine);\\n\\t\\t\\tselection.removeElement(s);\\n\\t\\t}\\n\\t\\tboolean reversed = false;\\n\\t\\tif(end < offset)\\n\\t\\t{\\n\\t\\t\\tint tmp = offset;\\n\\t\\t\\toffset = end;\\n\\t\\t\\tend = tmp;\\n\\t\\t\\treversed = true;\\n\\t\\t}\\n\\t\\tSelection newSel;\\n\\t\\tif(rect)\\n\\t\\t{\\n\\t\\t\\tSelection.Rect rectSel = new Selection.Rect(offset,end);\\n\\t\\t\\tif(reversed)\\n\\t\\t\\t\\trectSel.extraStartVirt = extraEndVirt;\\n\\t\\t\\telse\\n\\t\\t\\t\\trectSel.extraEndVirt = extraEndVirt;\\n\\t\\t\\tnewSel = rectSel;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tnewSel = new Selection.Range(offset,end);\\n\\t\\t_addToSelection(newSel);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void extendSelection(int offset, int end)\\n\\t{\\n\\t\\textendSelection(offset,end,0,0);\\n\\t} \\n\\tpublic void extendSelection(int offset, int end,\\n\\t\\tint extraStartVirt, int extraEndVirt)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(offset);\\n\\t\\tif(s != null)\\n\\t\\t{\\n\\t\\t\\tinvalidateLineRange(s.startLine,s.endLine);\\n\\t\\t\\tselection.removeElement(s);\\n\\t\\t\\tif(offset == s.start)\\n\\t\\t\\t{\\n\\t\\t\\t\\toffset = end;\\n\\t\\t\\t\\tend = s.end;\\n\\t\\t\\t}\\n\\t\\t\\telse if(offset == s.end)\\n\\t\\t\\t{\\n\\t\\t\\t\\toffset = s.start;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(end < offset)\\n\\t\\t{\\n\\t\\t\\tint tmp = end;\\n\\t\\t\\tend = offset;\\n\\t\\t\\toffset = tmp;\\n\\t\\t}\\n\\t\\tif(rectangularSelectionMode)\\n\\t\\t{\\n\\t\\t\\ts = new Selection.Rect(offset,end);\\n\\t\\t\\t((Selection.Rect)s).extraStartVirt = extraStartVirt;\\n\\t\\t\\t((Selection.Rect)s).extraEndVirt = extraEndVirt;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\ts = new Selection.Range(offset,end);\\n\\t\\t_addToSelection(s);\\n\\t\\tfireCaretEvent();\\n\\t\\tif(rectangularSelectionMode && extraEndVirt != 0)\\n\\t\\t{\\n\\t\\t\\tint line = getLineOfOffset(end);\\n\\t\\t\\tscrollTo(line,getLineLength(line) + extraEndVirt,false);\\n\\t\\t}\\n\\t} \\n\\tpublic String getSelectedText(Selection s)\\n\\t{\\n\\t\\tStringBuffer buf = new StringBuffer();\\n\\t\\ts.getText(buffer,buf);\\n\\t\\treturn buf.toString();\\n\\t} \\n\\tpublic String getSelectedText(String separator)\\n\\t{\\n\\t\\tif(selection.size() == 0)\\n\\t\\t\\treturn null;\\n\\t\\tStringBuffer buf = new StringBuffer();\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tif(i != 0)\\n\\t\\t\\t\\tbuf.append(separator);\\n\\t\\t\\t((Selection)selection.elementAt(i)).getText(buffer,buf);\\n\\t\\t}\\n\\t\\treturn buf.toString();\\n\\t} \\n\\tpublic String getSelectedText()\\n\\t{\\n\\t\\treturn getSelectedText(\\\"\\\\n\\\");\\n\\t} \\n\\tpublic void setSelectedText(Selection s, String selectedText)\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tthrow new InternalError(\\\"Text component\\\"\\n\\t\\t\\t\\t+ \\\" read only\\\");\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tmoveCaretPosition(s.setText(buffer,selectedText));\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\t\\t\\t\\t} \\n\\tpublic void setSelectedText(String selectedText)\\n\\t{\\n\\t\\tsetSelectedText(selectedText,true);\\n\\t} \\n\\tpublic void setSelectedText(String selectedText, boolean moveCaret)\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tthrow new InternalError(\\\"Text component\\\"\\n\\t\\t\\t\\t+ \\\" read only\\\");\\n\\t\\t}\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(selection.length == 0)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.insert(caret,selectedText);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tint newCaret = -1;\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnewCaret = selection[i].setText(buffer,selectedText);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(moveCaret)\\n\\t\\t\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic int[] getSelectedLines()\\n\\t{\\n\\t\\tif(selection.size() == 0)\\n\\t\\t\\treturn new int[] { caretLine };\\n\\t\\tInteger line;\\n\\t\\tSet set = new TreeSet();\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tint endLine = (s.end == getLineStartOffset(s.endLine)\\n\\t\\t\\t\\t? s.endLine - 1\\n\\t\\t\\t\\t: s.endLine);\\n\\t\\t\\tfor(int j = s.startLine; j <= endLine; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tline = new Integer(j);\\n\\t\\t\\t\\tset.add(line);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint[] returnValue = new int[set.size()];\\n\\t\\tint i = 0;\\n\\t\\tIterator iter = set.iterator();\\n\\t\\twhile(iter.hasNext())\\n\\t\\t{\\n\\t\\t\\tline = (Integer)iter.next();\\n\\t\\t\\treturnValue[i++] = line.intValue();\\n\\t\\t}\\n\\t\\treturn returnValue;\\n\\t} \\n\\tpublic void showSelectLineRangeDialog()\\n\\t{\\n\\t\\tnew SelectLineRange(view);\\n\\t} \\n\\tpublic void addStructureMatcher(StructureMatcher matcher)\\n\\t{\\n\\t\\tstructureMatchers.add(matcher);\\n\\t} \\n\\tpublic void removeStructureMatcher(StructureMatcher matcher)\\n\\t{\\n\\t\\tstructureMatchers.remove(matcher);\\n\\t} \\n\\tpublic StructureMatcher.Match getStructureMatch()\\n\\t{\\n\\t\\treturn match;\\n\\t} \\n\\tpublic final void blinkCaret()\\n\\t{\\n\\t\\tif(caretBlinks)\\n\\t\\t{\\n\\t\\t\\tblink = !blink;\\n\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tblink = true;\\n\\t} \\n\\tpublic void centerCaret()\\n\\t{\\n\\t\\tint offset = getScreenLineStartOffset(visibleLines / 2);\\n\\t\\tif(offset == -1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t\\tsetCaretPosition(offset);\\n\\t} \\n\\tpublic void setCaretPosition(int newCaret)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tselection.removeAllElements();\\n\\t\\tmoveCaretPosition(newCaret,true);\\n\\t} \\n\\tpublic void setCaretPosition(int newCaret, boolean doElectricScroll)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tselection.removeAllElements();\\n\\t\\tmoveCaretPosition(newCaret,doElectricScroll);\\n\\t} \\n\\tpublic void moveCaretPosition(int newCaret)\\n\\t{\\n\\t\\tmoveCaretPosition(newCaret,true);\\n\\t} \\n\\tpublic void moveCaretPosition(int newCaret, boolean doElectricScroll)\\n\\t{\\n\\t\\tmoveCaretPosition(newCaret,doElectricScroll ? ELECTRIC_SCROLL\\n\\t\\t\\t: NORMAL_SCROLL);\\n\\t} \\n\\t\\tpublic static int NO_SCROLL = 0;\\n\\tpublic static int NORMAL_SCROLL = 1;\\n\\tpublic static int ELECTRIC_SCROLL = 2;\\n\\tpublic void moveCaretPosition(int newCaret, int scrollMode)\\n\\t{\\n\\t\\tif(newCaret < 0 || newCaret > buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tthrow new IllegalArgumentException(\\\"caret out of bounds: \\\"\\n\\t\\t\\t\\t+ newCaret);\\n\\t\\t}\\n\\t\\tif(match != null)\\n\\t\\t{\\n\\t\\t\\tif(caretLine < match.startLine)\\n\\t\\t\\t\\tinvalidateLineRange(caretLine,match.endLine);\\n\\t\\t\\telse\\n\\t\\t\\t\\tinvalidateLineRange(match.startLine,caretLine);\\n\\t\\t\\tmatch = null;\\n\\t\\t}\\n\\t\\tif(caret == newCaret)\\n\\t\\t{\\n\\t\\t\\tif(scrollMode == NORMAL_SCROLL)\\n\\t\\t\\t\\tfinishCaretUpdate(false,false);\\n\\t\\t\\telse if(scrollMode == ELECTRIC_SCROLL)\\n\\t\\t\\t\\tfinishCaretUpdate(true,false);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint newCaretLine = getLineOfOffset(newCaret);\\n\\t\\t\\tmagicCaret = -1;\\n\\t\\t\\tif(!displayManager.isLineVisible(newCaretLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(newCaretLine < displayManager.getFirstVisibleLine()\\n\\t\\t\\t\\t\\t|| newCaretLine > displayManager.getLastVisibleLine())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint collapseFolds = buffer.getIntegerProperty(\\n\\t\\t\\t\\t\\t\\t\\\"collapseFolds\\\",0);\\n\\t\\t\\t\\t\\tif(collapseFolds != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdisplayManager.expandFolds(collapseFolds);\\n\\t\\t\\t\\t\\t\\tdisplayManager.expandFold(newCaretLine,false);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tdisplayManager.expandAllFolds();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tdisplayManager.expandFold(newCaretLine,false);\\n\\t\\t\\t}\\n\\t\\t\\tif(caretLine == newCaretLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caretScreenLine != -1)\\n\\t\\t\\t\\t\\tinvalidateScreenLineRange(caretScreenLine,caretScreenLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint newCaretScreenLine = chunkCache.getScreenLineOfOffset(newCaretLine,\\n\\t\\t\\t\\t\\tnewCaret - buffer.getLineStartOffset(newCaretLine));\\n\\t\\t\\t\\tif(caretScreenLine == -1)\\n\\t\\t\\t\\t\\tinvalidateScreenLineRange(newCaretScreenLine,newCaretScreenLine);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tinvalidateScreenLineRange(caretScreenLine,newCaretScreenLine);\\n\\t\\t\\t\\tcaretScreenLine = newCaretScreenLine;\\n\\t\\t\\t}\\n\\t\\t\\tcaret = newCaret;\\n\\t\\t\\tcaretLine = newCaretLine;\\n\\t\\t\\tif(scrollMode == NORMAL_SCROLL)\\n\\t\\t\\t\\tfinishCaretUpdate(false,true);\\n\\t\\t\\telse if(scrollMode == ELECTRIC_SCROLL)\\n\\t\\t\\t\\tfinishCaretUpdate(true,true);\\n\\t\\t}\\n\\t} \\n\\tpublic int getCaretPosition()\\n\\t{\\n\\t\\treturn caret;\\n\\t} \\n\\tpublic int getCaretLine()\\n\\t{\\n\\t\\treturn caretLine;\\n\\t} \\n\\tpublic int getMagicCaretPosition()\\n\\t{\\n\\t\\tif(magicCaret == -1)\\n\\t\\t{\\n\\t\\t\\tmagicCaret = chunkCache.subregionOffsetToX(\\n\\t\\t\\t\\tcaretLine,caret - getLineStartOffset(caretLine));\\n\\t\\t}\\n\\t\\treturn magicCaret;\\n\\t} \\n\\tpublic void setMagicCaretPosition(int magicCaret)\\n\\t{\\n\\t\\tthis.magicCaret = magicCaret;\\n\\t} \\n\\tpublic final void addCaretListener(CaretListener listener)\\n\\t{\\n\\t\\tlistenerList.add(CaretListener.class,listener);\\n\\t} \\n\\tpublic final void removeCaretListener(CaretListener listener)\\n\\t{\\n\\t\\tlistenerList.remove(CaretListener.class,listener);\\n\\t} \\n\\tpublic void goToNextBracket(boolean select)\\n\\t{\\n\\t\\tString text = getText(caret,buffer.getLength() - caret - 1);\\n\\t\\tint newCaret = -1;\\nloop:\\t\\tfor(int i = 0; i < text.length(); i++)\\n\\t\\t{\\n\\t\\t\\tswitch(text.charAt(i))\\n\\t\\t\\t{\\n\\t\\t\\tcase ')': case ']': case '}':\\n\\t\\t\\t\\tnewCaret = caret + i + 1;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(newCaret == -1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(select)\\n\\t\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\t\\telse if(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t}\\n\\t} \\n\\tpublic void goToNextCharacter(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(!select && s instanceof Selection.Range)\\n\\t\\t{\\n\\t\\t\\tif(multi)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caret != s.end)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmoveCaretPosition(s.end);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetCaretPosition(s.end);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint extraStartVirt, extraEndVirt;\\n\\t\\tif(s instanceof Selection.Rect)\\n\\t\\t{\\n\\t\\t\\textraStartVirt = ((Selection.Rect)s).extraStartVirt;\\n\\t\\t\\textraEndVirt = ((Selection.Rect)s).extraEndVirt;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\textraStartVirt = 0;\\n\\t\\t\\textraEndVirt = 0;\\n\\t\\t}\\n\\t\\tint newCaret = caret;\\n\\t\\tif(select && caret == buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tif(rectangularSelectionMode || s instanceof Selection.Rect)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caret == s.start)\\n\\t\\t\\t\\t\\textraStartVirt++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\textraEndVirt++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(caret == getLineEndOffset(caretLine) - 1)\\n\\t\\t{\\n\\t\\t\\tif(rectangularSelectionMode || s instanceof Selection.Rect)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caret == s.start)\\n\\t\\t\\t\\t\\textraStartVirt++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\textraEndVirt++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint line = displayManager.getNextVisibleLine(caretLine);\\n\\t\\t\\t\\tif(line == -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tnewCaret = getLineStartOffset(line);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tnewCaret = caret + 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret,extraStartVirt,extraEndVirt);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToNextLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tboolean rectSelect = (s == null ? rectangularSelectionMode\\n\\t\\t\\t: s instanceof Selection.Rect);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = chunkCache.getBelowPosition(caretLine,\\n\\t\\t\\tcaret - buffer.getLineStartOffset(caretLine),magic + 1,\\n\\t\\t\\trectSelect && select);\\n\\t\\tif(newCaret == -1)\\n\\t\\t{\\n\\t\\t\\tint end = getLineEndOffset(caretLine) - 1;\\n\\t\\t\\tif(caret == end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tnewCaret = end;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t{\\n\\t\\t\\tRectParams params = getRectParams(caret,newCaret);\\n\\t\\t\\tint extraStartVirt;\\n\\t\\t\\tint extraEndVirt;\\n\\t\\t\\tif(params == null)\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = 0;\\n\\t\\t\\t\\textraEndVirt = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = params.extraStartVirt;\\n\\t\\t\\t\\textraEndVirt = params.extraEndVirt;\\n\\t\\t\\t\\tnewCaret = params.newCaret;\\n\\t\\t\\t}\\n\\t\\t\\textendSelection(caret,newCaret,extraStartVirt,extraEndVirt);\\n\\t\\t}\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToNextMarker(boolean select)\\n\\t{\\n\\t\\tVector markers = buffer.getMarkers();\\n\\t\\tif(markers.size() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tMarker marker = null;\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker _marker = (Marker)markers.get(i);\\n\\t\\t\\tif(_marker.getPosition() > caret)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmarker = _marker;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(marker == null)\\n\\t\\t\\tmarker = (Marker)markers.get(0);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,marker.getPosition());\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(marker.getPosition());\\n\\t} \\n\\tpublic void goToNextPage(boolean select)\\n\\t{\\n\\t\\tscrollToCaret(false);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint caretScreenLine = getScreenLineOfOffset(caret);\\n\\t\\tscrollDownPage();\\n\\t\\tint newCaret = xToScreenLineOffset(caretScreenLine,magic,true);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret,false);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToNextParagraph(boolean select)\\n\\t{\\n\\t\\tint lineNo = getCaretLine();\\n\\t\\tint newCaret = getBufferLength();\\n\\t\\tboolean foundBlank = false;\\nloop:\\t\\tfor(int i = lineNo + 1; i < getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tif(!displayManager.isLineVisible(i))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif(foundBlank)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnewCaret = getLineStartOffset(i);\\n\\t\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfoundBlank = true;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToNextWord(boolean select)\\n\\t{\\n\\t\\tgoToNextWord(select,false);\\n\\t} \\n\\tpublic void goToNextWord(boolean select, boolean stdNextPrevWord)\\n\\t{\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint newCaret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(newCaret == lineText.length())\\n\\t\\t{\\n\\t\\t\\tint nextLine = displayManager.getNextVisibleLine(caretLine);\\n\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret = getLineStartOffset(nextLine);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tnewCaret = TextUtilities.findWordEnd(lineText,newCaret + 1,\\n\\t\\t\\t\\tnoWordSep);\\n\\t\\t\\tif(stdNextPrevWord)\\n\\t\\t\\t{\\n\\t\\t\\t\\twhile((newCaret < lineText.length()) && Character.isWhitespace(lineText.charAt(newCaret)))\\n\\t\\t\\t\\t\\tnewCaret = TextUtilities.findWordEnd(lineText,newCaret + 1,\\n\\t\\t\\t\\t\\t\\tnoWordSep);\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret += lineStart;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToPrevBracket(boolean select)\\n\\t{\\n\\t\\tString text = getText(0,caret);\\n\\t\\tint newCaret = -1;\\nloop:\\t\\tfor(int i = getCaretPosition() - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tswitch(text.charAt(i))\\n\\t\\t\\t{\\n\\t\\t\\tcase '(': case '[': case '{':\\n\\t\\t\\t\\tnewCaret = i;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(newCaret == -1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(select)\\n\\t\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\t\\telse if(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t}\\n\\t} \\n\\tpublic void goToPrevCharacter(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(!select && s instanceof Selection.Range)\\n\\t\\t{\\n\\t\\t\\tif(multi)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caret != s.start)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmoveCaretPosition(s.start);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetCaretPosition(s.start);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint extraStartVirt = 0;\\n\\t\\tint extraEndVirt = 0;\\n\\t\\tint newCaret = caret;\\n\\t\\tif(select && caret == getLineEndOffset(caretLine) - 1)\\n\\t\\t{\\n\\t\\t\\tif(s instanceof Selection.Rect)\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = ((Selection.Rect)s).extraStartVirt;\\n\\t\\t\\t\\textraEndVirt = ((Selection.Rect)s).extraEndVirt;\\n\\t\\t\\t\\tif(caret == s.start)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(extraStartVirt == 0)\\n\\t\\t\\t\\t\\t\\tnewCaret = caret - 1;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\textraStartVirt--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(extraEndVirt == 0)\\n\\t\\t\\t\\t\\t\\tnewCaret = caret - 1;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\textraEndVirt--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tnewCaret = caret - 1;\\n\\t\\t}\\n\\t\\telse if(caret == getLineStartOffset(caretLine))\\n\\t\\t{\\n\\t\\t\\tint line = displayManager.getPrevVisibleLine(caretLine);\\n\\t\\t\\tif(line == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret = getLineEndOffset(line) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tnewCaret = caret - 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret,extraStartVirt,extraEndVirt);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToPrevLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tboolean rectSelect = (s == null ? rectangularSelectionMode\\n\\t\\t\\t: s instanceof Selection.Rect);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = chunkCache.getAbovePosition(caretLine,\\n\\t\\t\\tcaret - buffer.getLineStartOffset(caretLine),magic + 1,\\n\\t\\t\\trectSelect && select);\\n\\t\\tif(newCaret == -1)\\n\\t\\t{\\n\\t\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\t\\tif(caret == start)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tnewCaret = start;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t{\\n\\t\\t\\tRectParams params = getRectParams(caret,newCaret);\\n\\t\\t\\tint extraStartVirt;\\n\\t\\t\\tint extraEndVirt;\\n\\t\\t\\tif(params == null)\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = 0;\\n\\t\\t\\t\\textraEndVirt = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = params.extraStartVirt;\\n\\t\\t\\t\\textraEndVirt = params.extraEndVirt;\\n\\t\\t\\t\\tnewCaret = params.newCaret;\\n\\t\\t\\t}\\n\\t\\t\\textendSelection(caret,newCaret,extraStartVirt,extraEndVirt);\\n\\t\\t}\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToPrevMarker(boolean select)\\n\\t{\\n\\t\\tVector markers = buffer.getMarkers();\\n\\t\\tif(markers.size() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tMarker marker = null;\\n\\t\\tfor(int i = markers.size() - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tMarker _marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tif(_marker.getPosition() < caret)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmarker = _marker;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(marker == null)\\n\\t\\t\\tmarker = (Marker)markers.get(markers.size() - 1);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,marker.getPosition());\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(marker.getPosition());\\n\\t} \\n\\tpublic void goToPrevPage(boolean select)\\n\\t{\\n\\t\\tscrollToCaret(false);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint caretScreenLine = getScreenLineOfOffset(caret);\\n\\t\\tscrollUpPage();\\n\\t\\tint newCaret = xToScreenLineOffset(caretScreenLine,magic,true);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret,false);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToPrevParagraph(boolean select)\\n\\t{\\n\\t\\tint lineNo = caretLine;\\n\\t\\tint newCaret = 0;\\n\\t\\tboolean foundBlank = false;\\nloop:\\t\\tfor(int i = lineNo - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(!displayManager.isLineVisible(i))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif(foundBlank)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnewCaret = getLineEndOffset(i) - 1;\\n\\t\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfoundBlank = true;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToPrevWord(boolean select)\\n\\t{\\n\\t\\tgoToPrevWord(select,false);\\n\\t} \\n\\tpublic void goToPrevWord(boolean select, boolean stdNextPrevWord)\\n\\t{\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint newCaret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(newCaret == 0)\\n\\t\\t{\\n\\t\\t\\tif(lineStart == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint prevLine = displayManager.getPrevVisibleLine(caretLine);\\n\\t\\t\\t\\tif(prevLine == -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnewCaret = getLineEndOffset(prevLine) - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tnewCaret = TextUtilities.findWordStart(lineText,newCaret - 1,\\n\\t\\t\\t\\tnoWordSep);\\n\\t\\t\\tif(stdNextPrevWord)\\n\\t\\t\\t{\\n\\t\\t\\t\\twhile((newCaret > 0) && Character.isWhitespace(lineText.charAt(newCaret)))\\n\\t\\t\\t\\t\\tnewCaret = TextUtilities.findWordStart(lineText,newCaret - 1,\\n\\t\\t\\t\\t\\t\\tnoWordSep);\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret += lineStart;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void smartHome(boolean select)\\n\\t{\\n\\t\\tMacros.Recorder recorder = view.getMacroRecorder();\\n\\t\\tswitch(view.getInputHandler().getLastActionCount())\\n\\t\\t{\\n\\t\\tcase 1:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToStartOfWhiteSpace(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToStartOfWhiteSpace(select);\\n\\t\\t\\tbreak;\\n\\t\\tcase 2:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToStartOfLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToStartOfLine(select);\\n\\t\\t\\tbreak;\\n\\t\\tdefault: \\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToFirstVisibleLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToFirstVisibleLine(select);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t} \\n\\tpublic void smartEnd(boolean select)\\n\\t{\\n\\t\\tMacros.Recorder recorder = view.getMacroRecorder();\\n\\t\\tswitch(view.getInputHandler().getLastActionCount())\\n\\t\\t{\\n\\t\\tcase 1:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToEndOfWhiteSpace(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToEndOfWhiteSpace(select);\\n\\t\\t\\tbreak;\\n\\t\\tcase 2:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToEndOfLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToEndOfLine(select);\\n\\t\\t\\tbreak;\\n\\t\\tdefault: \\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToLastVisibleLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToLastVisibleLine(select);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t} \\n\\tpublic void goToStartOfLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line = (select || s == null\\n\\t\\t\\t? caretLine : s.startLine);\\n\\t\\tint newCaret = getLineStartOffset(line);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToEndOfLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line = (select || s == null\\n\\t\\t\\t? caretLine : s.endLine);\\n\\t\\tint newCaret = getLineEndOffset(line) - 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t\\t\\t\\t\\t\\t} \\n\\tpublic void goToStartOfWhiteSpace(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line, offset;\\n\\t\\tif(select || s == null)\\n\\t\\t{\\n\\t\\t\\tline = caretLine;\\n\\t\\t\\toffset = caret - buffer.getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tline = s.startLine;\\n\\t\\t\\toffset = s.start - buffer.getLineStartOffset(line);\\n\\t\\t}\\n\\t\\tint firstIndent = chunkCache.getSubregionStartOffset(line,offset);\\n\\t\\tif(firstIndent == getLineStartOffset(line))\\n\\t\\t{\\n\\t\\t\\tfirstIndent = MiscUtilities.getLeadingWhiteSpace(getLineText(line));\\n\\t\\t\\tif(firstIndent == getLineLength(line))\\n\\t\\t\\t\\tfirstIndent = 0;\\n\\t\\t\\tfirstIndent += getLineStartOffset(line);\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,firstIndent);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(firstIndent);\\n\\t} \\n\\tpublic void goToEndOfWhiteSpace(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line, offset;\\n\\t\\tif(select || s == null)\\n\\t\\t{\\n\\t\\t\\tline = caretLine;\\n\\t\\t\\toffset = caret - getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tline = s.endLine;\\n\\t\\t\\toffset = s.end - getLineStartOffset(line);\\n\\t\\t}\\n\\t\\tint lastIndent = chunkCache.getSubregionEndOffset(line,offset);\\n\\t\\tif(lastIndent == getLineEndOffset(line))\\n\\t\\t{\\n\\t\\t\\tlastIndent = getLineLength(line) - MiscUtilities.getTrailingWhiteSpace(getLineText(line));\\n\\t\\t\\tif(lastIndent == 0)\\n\\t\\t\\t\\tlastIndent = getLineLength(line);\\n\\t\\t\\tlastIndent += getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlastIndent--;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,lastIndent);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(lastIndent);\\n\\t} \\n\\tpublic void goToFirstVisibleLine(boolean select)\\n\\t{\\n\\t\\tint firstVisibleLine = getFirstLine() == 0 ? 0 : electricScroll;\\n\\t\\tint firstVisible = getScreenLineStartOffset(firstVisibleLine);\\n\\t\\tif(firstVisible == -1)\\n\\t\\t{\\n\\t\\t\\tfirstVisible = getLineStartOffset(displayManager\\n\\t\\t\\t\\t.getFirstVisibleLine());\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,firstVisible);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(firstVisible);\\n\\t} \\n\\tpublic void goToLastVisibleLine(boolean select)\\n\\t{\\n\\t\\tint lastVisible;\\n\\t\\tif(getFirstLine() + visibleLines >=\\n\\t\\t\\tdisplayManager.getScrollLineCount())\\n\\t\\t{\\n\\t\\t\\tlastVisible = getLineEndOffset(displayManager\\n\\t\\t\\t\\t.getLastVisibleLine()) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlastVisible = getScreenLineEndOffset(visibleLines\\n\\t\\t\\t\\t- electricScroll - 1) - 1;\\n\\t\\t\\tif(lastVisible == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlastVisible = getLineEndOffset(displayManager\\n\\t\\t\\t\\t\\t.getLastVisibleLine()) - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,lastVisible);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(lastVisible);\\n\\t} \\n\\tpublic void goToBufferStart(boolean select)\\n\\t{\\n\\t\\tint start = buffer.getLineStartOffset(\\n\\t\\t\\tdisplayManager.getFirstVisibleLine());\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,start);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(start);\\n\\t} \\n\\tpublic void goToBufferEnd(boolean select)\\n\\t{\\n\\t\\tint end = buffer.getLineEndOffset(\\n\\t\\t\\tdisplayManager.getLastVisibleLine()) - 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,end);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(end);\\n\\t} \\n\\tpublic void goToMatchingBracket()\\n\\t{\\n\\t\\tif(getLineLength(caretLine) != 0)\\n\\t\\t{\\n\\t\\t\\tint dot = caret - getLineStartOffset(caretLine);\\n\\t\\t\\tint bracket = TextUtilities.findMatchingBracket(\\n\\t\\t\\t\\tbuffer,caretLine,Math.max(0,dot - 1));\\n\\t\\t\\tif(bracket != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\t\\tmoveCaretPosition(bracket + 1,false);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tgetToolkit().beep();\\n\\t} \\n\\tpublic void showGoToLineDialog()\\n\\t{\\n\\t\\tString line = GUIUtilities.input(view,\\\"goto-line\\\",null);\\n\\t\\tif(line == null)\\n\\t\\t\\treturn;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tint lineNumber = Integer.parseInt(line) - 1;\\n\\t\\t\\tsetCaretPosition(getLineStartOffset(lineNumber));\\n\\t\\t}\\n\\t\\tcatch(Exception e)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t}\\n\\t} \\n\\tpublic void userInput(char ch)\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(ch == ' ' && Abbrevs.getExpandOnInput()\\n\\t\\t\\t&& Abbrevs.expandAbbrev(view,false))\\n\\t\\t\\treturn;\\n\\t\\telse if(ch == '\\\\t')\\n\\t\\t{\\n\\t\\t\\tif(selection.size() == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection sel = (Selection)selection.elementAt(0);\\n\\t\\t\\t\\tif(sel.startLine == sel.endLine\\n\\t\\t\\t\\t\\t&& (sel.start != buffer.getLineStartOffset(sel.startLine)\\n\\t\\t\\t\\t\\t|| sel.end != buffer.getLineEndOffset(sel.startLine) - 1))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tinsertTab();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tshiftIndentRight();\\n\\t\\t\\t}\\n\\t\\t\\telse if(selection.size() != 0)\\n\\t\\t\\t\\tshiftIndentRight();\\n\\t\\t\\telse\\n\\t\\t\\t\\tinsertTab();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tboolean indent;\\n\\t\\t\\t\\t\\t\\tString indentOpenBrackets = (String)buffer\\n\\t\\t\\t\\t.getProperty(\\\"indentOpenBrackets\\\");\\n\\t\\t\\tString indentCloseBrackets = (String)buffer\\n\\t\\t\\t\\t.getProperty(\\\"indentCloseBrackets\\\");\\n\\t\\t\\tif((indentCloseBrackets != null\\n\\t\\t\\t\\t&& indentCloseBrackets.indexOf(ch) != -1)\\n\\t\\t\\t\\t|| (indentOpenBrackets != null\\n\\t\\t\\t\\t&& indentOpenBrackets.indexOf(ch) != -1))\\n\\t\\t\\t{\\n\\t\\t\\t\\tindent = true;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tindent = false;\\n\\t\\t\\t}\\n\\t\\t\\tString str = String.valueOf(ch);\\n\\t\\t\\tSelection[] selection = getSelection();\\n\\t\\t\\tif(selection.length != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\t\\tsetSelectedText(s,str);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(ch == ' ')\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(doWordWrap(true))\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tdoWordWrap(false);\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(overwrite || indent)\\n\\t\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tif(overwrite)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint caretLineEnd = getLineEndOffset(caretLine);\\n\\t\\t\\t\\t\\tif(caretLineEnd - caret > 1)\\n\\t\\t\\t\\t\\t\\tbuffer.remove(caret,1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbuffer.insert(caret,str);\\n\\t\\t\\t\\tif(indent)\\n\\t\\t\\t\\t\\tbuffer.indentLine(caretLine,true);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(overwrite || indent)\\n\\t\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic final boolean isOverwriteEnabled()\\n\\t{\\n\\t\\treturn overwrite;\\n\\t} \\n\\tpublic final void setOverwriteEnabled(boolean overwrite)\\n\\t{\\n\\t\\tblink = true;\\n\\t\\tcaretTimer.restart();\\n\\t\\tthis.overwrite = overwrite;\\n\\t\\tinvalidateLine(caretLine);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t\\tview.getStatus().updateMiscStatus();\\n\\t} \\n\\tpublic final void toggleOverwriteEnabled()\\n\\t{\\n\\t\\tsetOverwriteEnabled(!overwrite);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t{\\n\\t\\t\\tview.getStatus().setMessageAndClear(\\n\\t\\t\\t\\tjEdit.getProperty(\\\"view.status.overwrite-changed\\\",\\n\\t\\t\\t\\tnew Integer[] { new Integer(overwrite ? 1 : 0) }));\\n\\t\\t}\\n\\t} \\n\\tpublic void backspace()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() != 0)\\n\\t\\t\\tsetSelectedText(null);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(caret == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.remove(caret - 1,1);\\n\\t\\t}\\n\\t} \\n\\tpublic void backspaceWord()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() != 0)\\n\\t\\t{\\n\\t\\t\\tsetSelectedText(\\\"\\\");\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint _caret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(_caret == 0)\\n\\t\\t{\\n\\t\\t\\tif(lineStart == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t_caret--;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\t_caret = TextUtilities.findWordStart(lineText,_caret-1,noWordSep);\\n\\t\\t}\\n\\t\\tbuffer.remove(_caret + lineStart,\\n\\t\\t\\tcaret - (_caret + lineStart));\\n\\t} \\n\\tpublic void delete()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() != 0)\\n\\t\\t\\tsetSelectedText(null);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(caret == buffer.getLength())\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.remove(caret,1);\\n\\t\\t}\\n\\t} \\n\\tpublic void deleteToEndOfLine()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.remove(caret,getLineEndOffset(caretLine)\\n\\t\\t\\t- caret - 1);\\n\\t} \\n\\tpublic void deleteLine()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine);\\n\\t\\tint x = chunkCache.subregionOffsetToX(caretLine,caret - start);\\n\\t\\t\\t\\t\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tif(end > buffer.getLength())\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(start != 0)\\n\\t\\t\\t\\t\\tstart--;\\n\\t\\t\\t\\tend--;\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tbuffer.remove(start,end - start);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\tint lastLine = displayManager.getLastVisibleLine();\\n\\t\\tif(caretLine == lastLine)\\n\\t\\t{\\n\\t\\t\\tint offset = chunkCache.xToSubregionOffset(lastLine,0,x,true);\\n\\t\\t\\tsetCaretPosition(buffer.getLineStartOffset(lastLine)\\n\\t\\t\\t\\t+ offset);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint offset = chunkCache.xToSubregionOffset(caretLine,0,x,true);\\n\\t\\t\\tsetCaretPosition(start + offset);\\n\\t\\t}\\n\\t} \\n\\tpublic void deleteParagraph()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint start = 0, end = buffer.getLength();\\nloop:\\t\\tfor(int i = caretLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tstart = getLineStartOffset(i);\\n\\t\\t\\tbreak loop;\\n\\t\\t}\\nloop:\\t\\tfor(int i = caretLine + 1; i < getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tend = getLineEndOffset(i) - 1;\\n\\t\\t\\tbreak loop;\\n\\t\\t}\\n\\t\\tbuffer.remove(start,end - start);\\n\\t} \\n\\tpublic void deleteToStartOfLine()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.remove(getLineStartOffset(caretLine),\\n\\t\\t\\tcaret - getLineStartOffset(caretLine));\\n\\t} \\n\\tpublic void deleteWord()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() != 0)\\n\\t\\t{\\n\\t\\t\\tsetSelectedText(\\\"\\\");\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint _caret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(_caret == lineText.length())\\n\\t\\t{\\n\\t\\t\\tif(lineStart + _caret == buffer.getLength())\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t_caret++;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\t_caret = TextUtilities.findWordEnd(lineText,\\n\\t\\t\\t\\t_caret+1,noWordSep);\\n\\t\\t}\\n\\t\\tbuffer.remove(caret,(_caret + lineStart) - caret);\\n\\t} \\n\\tpublic final boolean isMultipleSelectionEnabled()\\n\\t{\\n\\t\\treturn multi;\\n\\t} \\n\\tpublic final void toggleMultipleSelectionEnabled()\\n\\t{\\n\\t\\tsetMultipleSelectionEnabled(!multi);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t{\\n\\t\\t\\tview.getStatus().setMessageAndClear(\\n\\t\\t\\t\\tjEdit.getProperty(\\\"view.status.multi-changed\\\",\\n\\t\\t\\t\\tnew Integer[] { new Integer(multi ? 1 : 0) }));\\n\\t\\t}\\n\\t} \\n\\tpublic final void setMultipleSelectionEnabled(boolean multi)\\n\\t{\\n\\t\\tthis.multi = multi;\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t\\tview.getStatus().updateMiscStatus();\\n\\t\\tpainter.repaint();\\n\\t} \\n\\tpublic final boolean isRectangularSelectionEnabled()\\n\\t{\\n\\t\\treturn rectangularSelectionMode;\\n\\t} \\n\\tpublic final void toggleRectangularSelectionEnabled()\\n\\t{\\n\\t\\tsetRectangularSelectionEnabled(!rectangularSelectionMode);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t{\\n\\t\\t\\tview.getStatus().setMessageAndClear(\\n\\t\\t\\t\\tjEdit.getProperty(\\\"view.status.rect-select-changed\\\",\\n\\t\\t\\t\\tnew Integer[] { new Integer(rectangularSelectionMode ? 1 : 0) }));\\n\\t\\t}\\n\\t} \\n\\tpublic final void setRectangularSelectionEnabled(boolean rectangularSelectionMode)\\n\\t{\\n\\t\\tthis.rectangularSelectionMode = rectangularSelectionMode;\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t\\tview.getStatus().updateMiscStatus();\\n\\t\\tpainter.repaint();\\n\\t} \\n\\tpublic void goToMarker(char shortcut, boolean select)\\n\\t{\\n\\t\\tMarker marker = buffer.getMarker(shortcut);\\n\\t\\tif(marker == null)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint pos = marker.getPosition();\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,pos);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(pos);\\n\\t} \\n\\tpublic void addMarker()\\n\\t{\\n\\t\\t\\t\\tSelection[] selection = getSelection();\\n\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\tif(s.startLine != s.endLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s.startLine != caretLine)\\n\\t\\t\\t\\t\\tbuffer.addMarker('\\\\0',s.start);\\n\\t\\t\\t}\\n\\t\\t\\tif(s.endLine != caretLine)\\n\\t\\t\\t\\tbuffer.addMarker('\\\\0',s.end);\\n\\t\\t}\\n\\t\\t\\t\\tbuffer.addOrRemoveMarker('\\\\0',caret);\\n\\t} \\n\\tpublic void swapMarkerAndCaret(char shortcut)\\n\\t{\\n\\t\\tMarker marker = buffer.getMarker(shortcut);\\n\\t\\tif(marker == null)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint caret = getCaretPosition();\\n\\t\\tsetCaretPosition(marker.getPosition());\\n\\t\\tbuffer.addMarker(shortcut,caret);\\n\\t} \\n\\tpublic void goToParentFold()\\n\\t{\\n\\t\\tint line = -1;\\n\\t\\tint level = buffer.getFoldLevel(caretLine);\\n\\t\\tfor(int i = caretLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(buffer.getFoldLevel(i) < level)\\n\\t\\t\\t{\\n\\t\\t\\t\\tline = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(line == -1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = buffer.getLineStartOffset(line)\\n\\t\\t\\t+ chunkCache.xToSubregionOffset(line,0,magic + 1,true);\\n\\t\\tif(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToNextFold(boolean select)\\n\\t{\\n\\t\\tint nextFold = -1;\\n\\t\\tfor(int i = caretLine + 1; i < buffer.getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tif(buffer.isFoldStart(i)\\n\\t\\t\\t\\t&& displayManager.isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\tnextFold = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(nextFold == -1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = buffer.getLineStartOffset(nextFold)\\n\\t\\t\\t+ chunkCache.xToSubregionOffset(nextFold,0,magic + 1,true);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToPrevFold(boolean select)\\n\\t{\\n\\t\\tint prevFold = -1;\\n\\t\\tfor(int i = caretLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(buffer.isFoldStart(i)\\n\\t\\t\\t\\t&& displayManager.isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\tprevFold = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(prevFold == -1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = buffer.getLineStartOffset(prevFold)\\n\\t\\t\\t+ chunkCache.xToSubregionOffset(prevFold,0,magic + 1,true);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void collapseFold()\\n\\t{\\n\\t\\tint x = chunkCache.subregionOffsetToX(caretLine,\\n\\t\\t\\tcaret - getLineStartOffset(caretLine));\\n\\t\\tdisplayManager.collapseFold(caretLine);\\n\\t\\tif(displayManager.isLineVisible(caretLine))\\n\\t\\t\\treturn;\\n\\t\\tint line = displayManager.getPrevVisibleLine(caretLine);\\n\\t\\tif(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(buffer.getLineStartOffset(line)\\n\\t\\t\\t+ chunkCache.xToSubregionOffset(line,0,x,true));\\n\\t} \\n\\tpublic void expandFold(boolean fully)\\n\\t{\\n\\t\\tint x = chunkCache.subregionOffsetToX(caretLine,\\n\\t\\t\\tcaret - getLineStartOffset(caretLine));\\n\\t\\tint line = displayManager.expandFold(caretLine,fully);\\n\\t\\tif(!fully && line != -1)\\n\\t\\t{\\n\\t\\t\\tif(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\tmoveCaretPosition(getLineStartOffset(line)\\n\\t\\t\\t\\t+ chunkCache.xToSubregionOffset(line,0,x,true));\\n\\t\\t}\\n\\t} \\n\\tpublic void selectFold()\\n\\t{\\n\\t\\tselectFold(caretLine);\\n\\t} \\n\\tpublic void selectFold(int line)\\n\\t{\\n\\t\\tint[] lines = buffer.getFoldAtLine(line);\\n\\t\\tint newCaret = getLineEndOffset(lines[1]) - 1;\\n\\t\\tSelection s = new Selection.Range(getLineStartOffset(lines[0]),newCaret);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void narrowToFold()\\n\\t{\\n\\t\\tint[] lines = buffer.getFoldAtLine(caretLine);\\n\\t\\tif(lines[0] == 0 && lines[1] == buffer.getLineCount() - 1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t\\tdisplayManager.narrow(lines[0],lines[1]);\\n\\t} \\n\\tpublic void narrowToSelection()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tSelection sel = (Selection)selection.elementAt(0);\\n\\t\\tdisplayManager.narrow(sel.getStartLine(),sel.getEndLine());\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic void addExplicitFold()\\n\\t{\\n\\t\\tif(!buffer.getStringProperty(\\\"folding\\\").equals(\\\"explicit\\\"))\\n\\t\\t{\\n\\t\\t\\tGUIUtilities.error(view,\\\"folding-not-explicit\\\",null);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tString lineComment = buffer.getContextSensitiveProperty(caret,\\\"lineComment\\\");\\n\\t\\tString commentStart = buffer.getContextSensitiveProperty(caret,\\\"commentStart\\\");\\n\\t\\tString commentEnd = buffer.getContextSensitiveProperty(caret,\\\"commentEnd\\\");\\n\\t\\tString start, end;\\n\\t\\tif(lineComment != null)\\n\\t\\t{\\n\\t\\t\\tstart = lineComment + \\\"{{{ \\\\n\\\";\\n\\t\\t\\tend = lineComment + \\\"}}}\\\";\\n\\t\\t}\\n\\t\\telse if(commentStart != null && commentEnd != null)\\n\\t\\t{\\n\\t\\t\\tstart = commentStart + \\\"{{{  \\\" + commentEnd + \\\"\\\\n\\\";\\n\\t\\t\\tend = commentStart + \\\"}}}\\\" + commentEnd;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstart = \\\"{{{ \\\\n\\\";\\n\\t\\t\\tend = \\\"}}}\\\";\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tif(selection.size() == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tString line = buffer.getLineText(caretLine);\\n\\t\\t\\t\\tString whitespace = line.substring(0,\\n\\t\\t\\t\\t\\tMiscUtilities.getLeadingWhiteSpace(line));\\n\\t\\t\\t\\tint loc = caret + start.length() - 1;\\n\\t\\t\\t\\tstart = start + whitespace;\\n\\t\\t\\t\\tbuffer.insert(caret,start);\\n\\t\\t\\t\\t\\t\\t\\t\\tbuffer.insert(caret,end);\\n\\t\\t\\t\\tmoveCaretPosition(loc,false);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint loc = -1;\\n\\t\\t\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\t\\t\\tString line = buffer.getLineText(s.startLine);\\n\\t\\t\\t\\t\\tString whitespace = line.substring(0,\\n\\t\\t\\t\\t\\t\\tMiscUtilities.getLeadingWhiteSpace(line));\\n\\t\\t\\t\\t\\tloc = s.start + start.length() - 1;\\n\\t\\t\\t\\t\\tbuffer.insert(s.start,start + whitespace);\\n\\t\\t\\t\\t\\tbuffer.insert(s.end,\\\" \\\" + end);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsetCaretPosition(loc,false);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void lineComment()\\n\\t{\\n\\t\\tString comment = buffer.getContextSensitiveProperty(caret,\\\"lineComment\\\");\\n\\t\\tif(!buffer.isEditable() || comment == null || comment.length() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tcomment = comment + ' ';\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tint[] lines = getSelectedLines();\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < lines.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tString text = getLineText(lines[i]);\\n\\t\\t\\t\\tbuffer.insert(getLineStartOffset(lines[i])\\n\\t\\t\\t\\t\\t+ MiscUtilities.getLeadingWhiteSpace(text),\\n\\t\\t\\t\\t\\tcomment);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic void rangeComment()\\n\\t{\\n\\t\\tString commentStart = buffer.getContextSensitiveProperty(caret,\\\"commentStart\\\");\\n\\t\\tString commentEnd = buffer.getContextSensitiveProperty(caret,\\\"commentEnd\\\");\\n\\t\\tif(!buffer.isEditable() || commentStart == null || commentEnd == null\\n\\t\\t\\t|| commentStart.length() == 0 || commentEnd.length() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tcommentStart = commentStart + ' ';\\n\\t\\tcommentEnd = ' ' + commentEnd;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tSelection[] selection = getSelection();\\n\\t\\t\\tif(selection.length == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint oldCaret = caret;\\n\\t\\t\\t\\tbuffer.insert(caret,commentStart);\\n\\t\\t\\t\\tbuffer.insert(caret,commentEnd);\\n\\t\\t\\t\\tsetCaretPosition(oldCaret + commentStart.length());\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tif(s instanceof Selection.Range)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbuffer.insert(s.start,commentStart);\\n\\t\\t\\t\\t\\tbuffer.insert(s.end,commentEnd);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(s instanceof Selection.Rect)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection.Rect rect = (Selection.Rect)s;\\n\\t\\t\\t\\t\\tint start = rect.getStartColumn(buffer);\\n\\t\\t\\t\\t\\tint end = rect.getEndColumn(buffer);\\n\\t\\t\\t\\t\\tfor(int j = s.startLine; j <= s.endLine; j++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.insertAtColumn(j,end,\\n\\t\\t\\t\\t\\t\\t\\tcommentEnd);\\n\\t\\t\\t\\t\\t\\tbuffer.insertAtColumn(j,start,\\n\\t\\t\\t\\t\\t\\t\\tcommentStart);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tselectNone();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void formatParagraph()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(maxLineLen <= 0)\\n\\t\\t{\\n\\t\\t\\tGUIUtilities.error(view,\\\"format-maxlinelen\\\",null);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(selection.length != 0)\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tsetSelectedText(s,TextUtilities.format(\\n\\t\\t\\t\\t\\tgetSelectedText(s),maxLineLen,\\n\\t\\t\\t\\t\\tbuffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint lineNo = getCaretLine();\\n\\t\\t\\tint start = 0, end = buffer.getLength();\\nloop:\\t\\t\\tfor(int i = lineNo - 1; i >= 0; i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstart = getLineEndOffset(i);\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\nloop:\\t\\t\\tfor(int i = lineNo + 1; i < getLineCount(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tend = getLineStartOffset(i) - 1;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tString text = buffer.getText(start,end - start);\\n\\t\\t\\t\\tbuffer.remove(start,end - start);\\n\\t\\t\\t\\tbuffer.insert(start,TextUtilities.format(\\n\\t\\t\\t\\t\\ttext,maxLineLen,buffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic void spacesToTabs()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tif(selection.length == 0)\\n\\t\\t{\\n\\t\\t\\tsetText(TextUtilities.spacesToTabs(\\n\\t\\t\\t\\tgetText(), buffer.getTabSize()));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tsetSelectedText(s,TextUtilities.spacesToTabs(\\n\\t\\t\\t\\t\\tgetSelectedText(s),buffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void tabsToSpaces()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tif(selection.length == 0)\\n\\t\\t{\\n\\t\\t\\tsetText(TextUtilities.tabsToSpaces(\\n\\t\\t\\t\\tgetText(), buffer.getTabSize()));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tsetSelectedText(s,TextUtilities.tabsToSpaces(\\n\\t\\t\\t\\t\\tgetSelectedText(s),buffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void toUpperCase()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable() || selection.length == 0)\\n                {\\n                \\tgetToolkit().beep();\\n                \\treturn;\\n                }\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\tsetSelectedText(s,getSelectedText(s).toUpperCase());\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void toLowerCase()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable() || selection.length == 0)\\n                {\\n                \\tgetToolkit().beep();\\n                \\treturn;\\n                }\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\tsetSelectedText(s,getSelectedText(s).toLowerCase());\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void removeTrailingWhiteSpace()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbuffer.removeTrailingWhiteSpace(getSelectedLines());\\n\\t\\t}\\n\\t} \\n\\t\\tpublic void insertEnterAndIndent()\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tsetSelectedText(\\\"\\\\n\\\");\\n\\t\\t\\t\\tbuffer.indentLine(caretLine,true);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tpublic void insertTabAndIndent()\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() == 0)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tString text = buffer.getLineText(caretLine);\\n\\t\\t\\tint start = buffer.getLineStartOffset(caretLine);\\n\\t\\t\\tint whiteSpace = MiscUtilities.getLeadingWhiteSpace(text);\\n\\t\\t\\tif(caret - start <= whiteSpace\\n\\t\\t\\t\\t&& buffer.indentLine(caretLine,false))\\n\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tuserInput('\\\\t');\\n\\t} \\n\\tpublic void indentSelectedLines()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbuffer.indentLines(getSelectedLines());\\n\\t\\t\\tselectNone();\\n\\t\\t}\\n\\t} \\n\\tpublic void shiftIndentLeft()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbuffer.shiftIndentLeft(getSelectedLines());\\n\\t\\t}\\n\\t} \\n\\tpublic void shiftIndentRight()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t\\tbuffer.shiftIndentRight(getSelectedLines());\\n\\t} \\n\\tpublic void joinLines()\\n\\t{\\n\\t\\tint end = getLineEndOffset(caretLine);\\n\\t\\tif(end > buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.remove(end - 1,MiscUtilities.getLeadingWhiteSpace(\\n\\t\\t\\tbuffer.getLineText(caretLine + 1)) + 1);\\n\\t\\tsetCaretPosition(end - 1);\\n\\t} \\n\\tpublic void showWordCountDialog()\\n\\t{\\n\\t\\tString selection = getSelectedText();\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tdoWordCount(view,selection);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tdoWordCount(view,buffer.getText(0,buffer.getLength()));\\n\\t} \\n\\tpublic void addLeftOfScrollBar(Component comp)\\n\\t{\\n\\t\\tverticalBox.add(comp,verticalBox.getComponentCount() - 1);\\n\\t} \\n\\tpublic void removeLeftOfScrollBar(Component comp)\\n\\t{\\n\\t\\tverticalBox.remove(comp);\\n\\t} \\n\\tpublic void addNotify()\\n\\t{\\n\\t\\tsuper.addNotify();\\n\\t\\tToolTipManager.sharedInstance().registerComponent(painter);\\n\\t\\tToolTipManager.sharedInstance().registerComponent(gutter);\\n\\t\\tif(!bufferHandlerInstalled)\\n\\t\\t{\\n\\t\\t\\tbufferHandlerInstalled = true;\\n\\t\\t\\tbuffer.addBufferChangeListener(bufferHandler);\\n\\t\\t}\\n\\t\\trecalculateVisibleLines();\\n\\t\\tif(buffer.isLoaded())\\n\\t\\t\\trecalculateLastPhysicalLine();\\n\\t\\tpropertiesChanged();\\n\\t} \\n\\tpublic void removeNotify()\\n\\t{\\n\\t\\tsuper.removeNotify();\\n\\t\\tToolTipManager.sharedInstance().unregisterComponent(painter);\\n\\t\\tToolTipManager.sharedInstance().unregisterComponent(gutter);\\n\\t\\tif(focusedComponent == this)\\n\\t\\t\\tfocusedComponent = null;\\n\\t\\tif(bufferHandlerInstalled)\\n\\t\\t{\\n\\t\\t\\tbuffer.removeBufferChangeListener(bufferHandler);\\n\\t\\t\\tbufferHandlerInstalled = false;\\n\\t\\t}\\n\\t} \\n\\tpublic boolean getFocusTraversalKeysEnabled()\\n\\t{\\n\\t\\treturn false;\\n\\t} \\n\\tpublic boolean getFocusCycleRoot()\\n\\t{\\n\\t\\treturn true;\\n\\t} \\n\\t\\tpublic void processKeyEvent(KeyEvent evt)\\n\\t{\\n\\t\\tview.processKeyEvent(evt,true);\\n\\t\\tif(!evt.isConsumed())\\n\\t\\t\\tsuper.processKeyEvent(evt);\\n\\t} \\n\\tpublic void addTopComponent(Component comp)\\n\\t{\\n\\t\\tadd(TOP,comp);\\n\\t} \\n\\tpublic void removeTopComponent(Component comp)\\n\\t{\\n\\t\\tremove(comp);\\n\\t} \\n\\tpublic void propertiesChanged()\\n\\t{\\n\\t\\tif(buffer == null)\\n\\t\\t\\treturn;\\n\\t\\tint _tabSize = buffer.getTabSize();\\n\\t\\tchar[] foo = new char[_tabSize];\\n\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t{\\n\\t\\t\\tfoo[i] = ' ';\\n\\t\\t}\\n\\t\\ttabSize = (float)painter.getFont().getStringBounds(foo,0,_tabSize,\\n\\t\\t\\tpainter.getFontRenderContext()).getWidth();\\n\\t\\tcharWidth = (int)Math.round(painter.getFont().getStringBounds(foo,0,1,\\n\\t\\t\\tpainter.getFontRenderContext()).getWidth());\\n\\t\\tString wrap = buffer.getStringProperty(\\\"wrap\\\");\\n\\t\\thardWrap = wrap.equals(\\\"hard\\\");\\n\\t\\tmaxLineLen = buffer.getIntegerProperty(\\\"maxLineLen\\\",0);\\n\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\tif(displayManager != null && !bufferChanging)\\n\\t\\t\\tdisplayManager.updateWrapSettings();\\n\\t\\tchunkCache.invalidateAll();\\n\\t\\tgutter.repaint();\\n\\t\\tpainter.repaint();\\n\\t} \\n\\tpublic final int getSelectionStart()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getStart();\\n\\t} \\n\\tpublic int getSelectionStart(int line)\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getStart(\\n\\t\\t\\tbuffer,line);\\n\\t} \\n\\tpublic final int getSelectionStartLine()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getStartLine();\\n\\t} \\n\\tpublic final void setSelectionStart(int selectionStart)\\n\\t{\\n\\t\\tselect(selectionStart,getSelectionEnd(),true);\\n\\t} \\n\\tpublic final int getSelectionEnd()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getEnd();\\n\\t} \\n\\tpublic int getSelectionEnd(int line)\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getEnd(\\n\\t\\t\\tbuffer,line);\\n\\t} \\n\\tpublic final int getSelectionEndLine()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getEndLine();\\n\\t} \\n\\tpublic final void setSelectionEnd(int selectionEnd)\\n\\t{\\n\\t\\tselect(getSelectionStart(),selectionEnd,true);\\n\\t} \\n\\tpublic final int getMarkPosition()\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(s == null)\\n\\t\\t\\treturn caret;\\n\\t\\tif(s.start == caret)\\n\\t\\t\\treturn s.end;\\n\\t\\telse if(s.end == caret)\\n\\t\\t\\treturn s.start;\\n\\t\\telse\\n\\t\\t\\treturn caret;\\n\\t} \\n\\tpublic final int getMarkLine()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caretLine;\\n\\t\\tSelection s = (Selection)selection.elementAt(0);\\n\\t\\tif(s.start == caret)\\n\\t\\t\\treturn s.endLine;\\n\\t\\telse if(s.end == caret)\\n\\t\\t\\treturn s.startLine;\\n\\t\\telse\\n\\t\\t\\treturn caretLine;\\n\\t} \\n\\tpublic void select(int start, int end)\\n\\t{\\n\\t\\tselect(start,end,true);\\n\\t} \\n\\tpublic void select(int start, int end, boolean doElectricScroll)\\n\\t{\\n\\t\\tselectNone();\\n\\t\\tint newStart, newEnd;\\n\\t\\tif(start < end)\\n\\t\\t{\\n\\t\\t\\tnewStart = start;\\n\\t\\t\\tnewEnd = end;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tnewStart = end;\\n\\t\\t\\tnewEnd = start;\\n\\t\\t}\\n\\t\\tsetSelection(new Selection.Range(newStart,newEnd));\\n\\t\\tmoveCaretPosition(end,doElectricScroll);\\n\\t} \\n\\tpublic boolean isSelectionRectangular()\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(s == null)\\n\\t\\t\\treturn false;\\n\\t\\telse\\n\\t\\t\\treturn (s instanceof Selection.Rect);\\n\\t} \\n\\t\\tSegment lineSegment;\\n\\tMouseHandler mouseHandler;\\n\\tChunkCache chunkCache;\\n\\tDisplayManager displayManager;\\n\\tboolean bufferChanging;\\n\\tint maxHorizontalScrollWidth;\\n\\tboolean updateMaxHorizontalScrollWidth;\\n\\tboolean hardWrap;\\n\\tfloat tabSize;\\n\\tint charWidth;\\n\\tint maxLineLen;\\n\\tboolean scrollBarsInitialized;\\n\\t\\t\\t\\t\\t\\t\\tboolean queuedScrollTo;\\n\\tboolean queuedScrollToElectric;\\n\\tboolean queuedFireCaretEvent;\\n\\tList runnables;\\n\\t\\t\\tVector selection;\\n\\t\\tPoint returnValue;\\n\\tboolean lastLinePartial;\\n\\tfinal boolean isCaretVisible()\\n\\t{\\n\\t\\treturn blink && hasFocus();\\n\\t} \\n\\tfinal boolean isStructureHighlightVisible()\\n\\t{\\n\\t\\treturn match != null\\n\\t\\t\\t&& hasFocus()\\n\\t\\t\\t&& displayManager.isLineVisible(match.startLine)\\n\\t\\t\\t&& displayManager.isLineVisible(match.endLine);\\n\\t} \\n\\t\\tvoid updateMaxHorizontalScrollWidth()\\n\\t{\\n\\t\\tint max = chunkCache.getMaxHorizontalScrollWidth();\\n\\t\\tif(max != maxHorizontalScrollWidth)\\n\\t\\t{\\n\\t\\t\\tmaxHorizontalScrollWidth = max;\\n\\t\\t\\thorizontal.setValues(Math.max(0,\\n\\t\\t\\t\\tMath.min(maxHorizontalScrollWidth + charWidth\\n\\t\\t\\t\\t- painter.getWidth(),\\n\\t\\t\\t\\t-horizontalOffset)),\\n\\t\\t\\t\\tpainter.getWidth(),\\n\\t\\t\\t\\t0,maxHorizontalScrollWidth\\n\\t\\t\\t\\t+ charWidth);\\n\\t\\t}\\n\\t} \\n\\t\\tvoid recalculateVisibleLines()\\n\\t{\\n\\t\\tif(painter == null)\\n\\t\\t\\treturn;\\n\\t\\tint height = painter.getHeight();\\n\\t\\tint lineHeight = painter.getFontMetrics().getHeight();\\n\\t\\tvisibleLines = height / lineHeight;\\n\\t\\tlastLinePartial = (height % lineHeight != 0);\\n\\t\\tif(lastLinePartial)\\n\\t\\t\\tvisibleLines++;\\n\\t\\tchunkCache.recalculateVisibleLines();\\n\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\t\\t\\tif(displayManager != null && buffer != null && buffer.isLoaded())\\n\\t\\t\\tsetFirstLine(getFirstLine());\\n\\t\\tupdateScrollBars();\\n\\t} \\n\\t\\tvoid foldStructureChanged()\\n\\t{\\n\\t\\tchunkCache.invalidateAll();\\n\\t\\trecalculateLastPhysicalLine();\\n\\t\\trepaint();\\n\\t} \\n\\tvoid updateScrollBars()\\n\\t{\\n\\t\\tif(buffer == null)\\n\\t\\t\\treturn;\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"updateScrollBars(), slc=\\\"\\n\\t\\t\\t\\t+ displayManager.getScrollLineCount());\\n\\t\\tif(vertical != null && visibleLines != 0)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"Vertical ok\\\");\\n\\t\\t\\tint lineCount = displayManager.getScrollLineCount();\\n\\t\\t\\tint firstLine = getFirstLine();\\n\\t\\t\\tint visible = visibleLines - (lastLinePartial ? 1 : 0);\\n\\t\\t\\tvertical.setValues(firstLine,visible,0,lineCount);\\n\\t\\t\\tvertical.setUnitIncrement(2);\\n\\t\\t\\tvertical.setBlockIncrement(visible);\\n\\t\\t}\\n\\t\\tint width = painter.getWidth();\\n\\t\\tif(horizontal != null && width != 0)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"Horizontal ok\\\");\\n\\t\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\t\\tpainter.repaint();\\n\\t\\t\\thorizontal.setUnitIncrement(painter.getFontMetrics()\\n\\t\\t\\t\\t.charWidth('w'));\\n\\t\\t\\thorizontal.setBlockIncrement(width / 2);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate static String CENTER = \\\"center\\\";\\n\\tprivate static String RIGHT = \\\"right\\\";\\n\\tprivate static String LEFT = \\\"left\\\";\\n\\tprivate static String BOTTOM = \\\"bottom\\\";\\n\\tprivate static String TOP = \\\"top\\\";\\n\\tprivate static Timer caretTimer;\\n\\tprivate static Timer structureTimer;\\n\\tprivate static JEditTextArea focusedComponent;\\n\\t\\tprivate View view;\\n\\tprivate Gutter gutter;\\n\\tprivate TextAreaPainter painter;\\n\\tprivate JPopupMenu popup;\\n\\tprivate EventListenerList listenerList;\\n\\tprivate MutableCaretEvent caretEvent;\\n\\tprivate boolean caretBlinks;\\n\\tprivate boolean blink;\\n\\tprivate int physLastLine;\\n\\tprivate int screenLastLine;\\n\\tprivate int visibleLines;\\n\\tprivate int electricScroll;\\n\\tprivate int horizontalOffset;\\n\\tprivate boolean quickCopy;\\n\\t\\tprivate Box verticalBox;\\n\\tprivate JScrollBar vertical;\\n\\tprivate JScrollBar horizontal;\\n\\tprivate Buffer buffer;\\n\\tprivate BufferChangeHandler bufferHandler;\\n\\tprivate boolean bufferHandlerInstalled;\\n\\tprivate int caret;\\n\\tprivate int caretLine;\\n\\tprivate int caretScreenLine;\\n\\tprivate List structureMatchers;\\n\\tprivate StructureMatcher.Match match;\\n\\tprivate int magicCaret;\\n\\tprivate boolean multi;\\n\\tprivate boolean overwrite;\\n\\tprivate boolean rectangularSelectionMode;\\n\\tprivate boolean delayedScrollTo;\\n\\tprivate boolean dndEnabled;\\n\\tprivate Method dndCallback;\\n\\tprivate boolean dndInProgress;\\n\\t\\t\\tprivate void startDragAndDrop(InputEvent evt, boolean copy)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tdndCallback.invoke(null,new Object[] { this, evt,\\n\\t\\t\\t\\tnew Boolean(copy) });\\n\\t\\t}\\n\\t\\tcatch(Exception e)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.ERROR,this,e);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void _addToSelection(Selection addMe)\\n\\t{\\n\\t\\tif(addMe.start > addMe.end)\\n\\t\\t{\\n\\t\\t\\tthrow new IllegalArgumentException(addMe.start\\n\\t\\t\\t\\t+ \\\" > \\\" + addMe.end);\\n\\t\\t}\\n\\t\\telse if(addMe.start == addMe.end)\\n\\t\\t{\\n\\t\\t\\tif(addMe instanceof Selection.Range)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\telse if(addMe instanceof Selection.Rect)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(((Selection.Rect)addMe).extraEndVirt == 0)\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tif(s.overlaps(addMe))\\n\\t\\t\\t{\\n\\t\\t\\t\\taddMe.start = Math.min(s.start,addMe.start);\\n\\t\\t\\t\\taddMe.end = Math.max(s.end,addMe.end);\\n\\t\\t\\t\\tselection.removeElement(s);\\n\\t\\t\\t\\ti--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\taddMe.startLine = getLineOfOffset(addMe.start);\\n\\t\\taddMe.endLine = getLineOfOffset(addMe.end);\\n\\t\\tboolean added = false;\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tif(addMe.start < s.start)\\n\\t\\t\\t{\\n\\t\\t\\t\\tselection.insertElementAt(addMe,i);\\n\\t\\t\\t\\tadded = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(!added)\\n\\t\\t\\tselection.addElement(addMe);\\n\\t\\tinvalidateLineRange(addMe.startLine,addMe.endLine);\\n\\t} \\n\\tprivate void finishCaretUpdate(boolean doElectricScroll,\\n\\t\\tboolean fireCaretEvent)\\n\\t{\\n\\t\\tthis.queuedScrollToElectric |= doElectricScroll;\\n\\t\\tthis.queuedFireCaretEvent |= fireCaretEvent;\\n\\t\\tif(queuedScrollTo)\\n\\t\\t\\treturn;\\n\\t\\tRunnable r = new Runnable()\\n\\t\\t{\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tblink = true;\\n\\t\\t\\t\\tcaretTimer.restart();\\n\\t\\t\\t\\tscrollToCaret(queuedScrollToElectric);\\n\\t\\t\\t\\tupdateBracketHighlightWithDelay();\\n\\t\\t\\t\\tif(queuedFireCaretEvent)\\n\\t\\t\\t\\t\\tfireCaretEvent();\\n\\t\\t\\t\\tqueuedScrollTo = queuedScrollToElectric\\n\\t\\t\\t\\t\\t= queuedFireCaretEvent = false;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tif(buffer.isTransactionInProgress())\\n\\t\\t{\\n\\t\\t\\tqueuedScrollTo = true;\\n\\t\\t\\trunnables.add(r);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tr.run();\\n\\t} \\n\\t\\tprivate void fireCaretEvent()\\n\\t{\\n\\t\\tObject[] listeners = listenerList.getListenerList();\\n\\t\\tfor(int i = listeners.length - 2; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(listeners[i] == CaretListener.class)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t((CaretListener)listeners[i+1]).caretUpdate(caretEvent);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireScrollEvent(boolean vertical)\\n\\t{\\n\\t\\tObject[] listeners = listenerList.getListenerList();\\n\\t\\tfor(int i = listeners.length - 2; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(listeners[i] == ScrollListener.class)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(vertical)\\n\\t\\t\\t\\t\\t\\t((ScrollListener)listeners[i+1]).scrolledVertically(this);\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t((ScrollListener)listeners[i+1]).scrolledHorizontally(this);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void insertTab()\\n\\t{\\n\\t\\tint tabSize = buffer.getTabSize();\\n\\t\\tif(buffer.getBooleanProperty(\\\"noTabs\\\"))\\n\\t\\t{\\n\\t\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\t\\tString line = getText(lineStart,caret - lineStart);\\n\\t\\t\\tint pos = 0;\\n\\t\\t\\tfor(int i = 0; i < line.length(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(line.charAt(pos))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tpos = 0;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif(++pos >= tabSize)\\n\\t\\t\\t\\t\\t\\tpos = 0;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tsetSelectedText(MiscUtilities.createWhiteSpace(\\n\\t\\t\\t\\ttabSize - pos,0));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tsetSelectedText(\\\"\\\\t\\\");\\n\\t} \\n\\t\\tprivate boolean doWordWrap(boolean spaceInserted)\\n\\t{\\n\\t\\tif(!hardWrap || maxLineLen <= 0)\\n\\t\\t\\treturn false;\\n\\t\\tbuffer.getLineText(caretLine,lineSegment);\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine);\\n\\t\\tint len = end - start - 1;\\n\\t\\tint caretPos = caret - start;\\n\\t\\t\\t\\t\\t\\tfor(int i = caretPos; i < len; i++)\\n\\t\\t{\\n\\t\\t\\tchar ch = lineSegment.array[lineSegment.offset + i];\\n\\t\\t\\tif(ch != ' ' && ch != '\\\\t')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tboolean returnValue = false;\\n\\t\\tint tabSize = buffer.getTabSize();\\n\\t\\tString wordBreakChars = buffer.getStringProperty(\\\"wordBreakChars\\\");\\n\\t\\tint logicalLength = 0; \\t\\tint lastWordOffset = -1;\\n\\t\\tboolean lastWasSpace = true;\\n\\t\\tfor(int i = 0; i < caretPos; i++)\\n\\t\\t{\\n\\t\\t\\tchar ch = lineSegment.array[lineSegment.offset + i];\\n\\t\\t\\tif(ch == '\\\\t')\\n\\t\\t\\t{\\n\\t\\t\\t\\tlogicalLength += tabSize - (logicalLength % tabSize);\\n\\t\\t\\t\\tif(!lastWasSpace && logicalLength <= maxLineLen)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastWordOffset = i;\\n\\t\\t\\t\\t\\tlastWasSpace = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(ch == ' ')\\n\\t\\t\\t{\\n\\t\\t\\t\\tlogicalLength++;\\n\\t\\t\\t\\tif(!lastWasSpace && logicalLength <= maxLineLen)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastWordOffset = i;\\n\\t\\t\\t\\t\\tlastWasSpace = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(wordBreakChars != null && wordBreakChars.indexOf(ch) != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlogicalLength++;\\n\\t\\t\\t\\tif(!lastWasSpace && logicalLength <= maxLineLen)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastWordOffset = i;\\n\\t\\t\\t\\t\\tlastWasSpace = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tlogicalLength++;\\n\\t\\t\\t\\tlastWasSpace = false;\\n\\t\\t\\t}\\n\\t\\t\\tint insertNewLineAt;\\n\\t\\t\\tif(spaceInserted && logicalLength == maxLineLen\\n\\t\\t\\t\\t&& i == caretPos - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsertNewLineAt = caretPos;\\n\\t\\t\\t\\treturnValue = true;\\n\\t\\t\\t}\\n\\t\\t\\telse if(logicalLength >= maxLineLen && lastWordOffset != -1)\\n\\t\\t\\t\\tinsertNewLineAt = lastWordOffset;\\n\\t\\t\\telse\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tbuffer.insert(start + insertNewLineAt,\\\"\\\\n\\\");\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbuffer.indentLine(caretLine,true);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t\\treturn returnValue;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t} \\n\\t\\tprivate void doWordCount(View view, String text)\\n\\t{\\n\\t\\tchar[] chars = text.toCharArray();\\n\\t\\tint characters = chars.length;\\n\\t\\tint words;\\n\\t\\tif(characters == 0)\\n\\t\\t\\twords = 0;\\n\\t\\telse\\n\\t\\t\\twords = 1;\\n\\t\\tint lines = 1;\\n\\t\\tboolean word = false;\\n\\t\\tfor(int i = 0; i < chars.length; i++)\\n\\t\\t{\\n\\t\\t\\tswitch(chars[i])\\n\\t\\t\\t{\\n\\t\\t\\tcase '\\\\r': case '\\\\n':\\n\\t\\t\\t\\tlines++;\\n\\t\\t\\tcase ' ': case '\\\\t':\\n\\t\\t\\t\\tif(word)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twords++;\\n\\t\\t\\t\\t\\tword = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tword = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tObject[] args = { new Integer(characters), new Integer(words),\\n\\t\\t\\tnew Integer(lines) };\\n\\t\\tGUIUtilities.message(view,\\\"wordcount\\\",args);\\n\\t} \\n\\t\\tprivate void updateBracketHighlightWithDelay()\\n\\t{\\n\\t\\tstructureTimer.stop();\\n\\t\\tstructureTimer.start();\\n\\t} \\n\\t\\tprivate void updateStructureHighlight()\\n\\t{\\n\\t\\tif(!painter.isStructureHighlightEnabled()\\n\\t\\t\\t&& !gutter.isStructureHighlightEnabled())\\n\\t\\t\\treturn;\\n\\t\\tIterator iter = structureMatchers.iterator();\\n\\t\\twhile(iter.hasNext())\\n\\t\\t{\\n\\t\\t\\tStructureMatcher matcher = (StructureMatcher)\\n\\t\\t\\t\\titer.next();\\n\\t\\t\\tmatch = matcher.getMatch(this);\\n\\t\\t\\tif(match != null)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tif(match != null)\\n\\t\\t{\\n\\t\\t\\tif(caretLine < match.startLine)\\n\\t\\t\\t\\tinvalidateLineRange(caretLine,match.endLine);\\n\\t\\t\\telse\\n\\t\\t\\t\\tinvalidateLineRange(match.startLine,caretLine);\\n\\t\\t\\tif(chunkCache.getScreenLineOfOffset(match.startLine,\\n\\t\\t\\t\\tmatch.start - getLineStartOffset(match.startLine))\\n\\t\\t\\t\\t== -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tshowStructureStatusMessage(match.startLine < caretLine);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void showStructureStatusMessage(boolean backward)\\n\\t{\\n\\t\\tString text = buffer.getLineText(match.startLine).trim();\\n\\t\\tif(backward && match.startLine != 0 && text.length() == 1)\\n\\t\\t{\\n\\t\\t\\tswitch(text.charAt(0))\\n\\t\\t\\t{\\n\\t\\t\\tcase '{': case '}':\\n\\t\\t\\tcase '[': case ']':\\n\\t\\t\\tcase '(': case ')':\\n\\t\\t\\t\\ttext = buffer.getLineText(match.startLine - 1)\\n\\t\\t\\t\\t\\t.trim() + \\\" \\\" + text;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\ttext = text.replace('\\\\t',' ');\\n\\t\\tview.getStatus().setMessageAndClear(jEdit.getProperty(\\n\\t\\t\\t\\\"view.status.bracket\\\",new Object[] { \\n\\t\\t\\tnew Integer(match.startLine + 1), text }));\\n\\t} \\n\\t\\tvoid recalculateLastPhysicalLine()\\n\\t{\\n\\t\\tint oldScreenLastLine = screenLastLine;\\n\\t\\tfor(int i = visibleLines - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(i);\\n\\t\\t\\tif(info.physicalLine != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tphysLastLine = info.physicalLine;\\n\\t\\t\\t\\tscreenLastLine = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tinvalidateScreenLineRange(oldScreenLastLine,screenLastLine);\\n\\t} \\n\\t\\tstatic class RectParams\\n\\t{\\n\\t\\tint extraStartVirt;\\n\\t\\tint extraEndVirt;\\n\\t\\tint newCaret;\\n\\t\\tRectParams(int extraStartVirt, int extraEndVirt, int newCaret)\\n\\t\\t{\\n\\t\\t\\tthis.extraStartVirt = extraStartVirt;\\n\\t\\t\\tthis.extraEndVirt = extraEndVirt;\\n\\t\\t\\tthis.newCaret = newCaret;\\n\\t\\t}\\n\\t}\\n\\tprivate RectParams getRectParams(int caret, int newCaret)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint virtualWidth;\\n\\t\\tif(s instanceof Selection.Rect)\\n\\t\\t{\\n\\t\\t\\tif(caret == s.end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvirtualWidth = buffer.getVirtualWidth(\\n\\t\\t\\t\\t\\ts.endLine,s.end - getLineStartOffset(\\n\\t\\t\\t\\t\\ts.endLine)) + ((Selection.Rect)s).extraEndVirt;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tvirtualWidth = buffer.getVirtualWidth(\\n\\t\\t\\t\\t\\ts.startLine,s.start - getLineStartOffset(\\n\\t\\t\\t\\t\\ts.startLine)) + ((Selection.Rect)s).extraStartVirt;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(rectangularSelectionMode)\\n\\t\\t{\\n\\t\\t\\tvirtualWidth = buffer.getVirtualWidth(\\n\\t\\t\\t\\tcaretLine,caret - buffer.getLineStartOffset(caretLine));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn null;\\n\\t\\tint newLine = getLineOfOffset(newCaret);\\n\\t\\tint[] totalVirtualWidth = new int[1];\\n\\t\\tint newOffset = buffer.getOffsetOfVirtualColumn(newLine,\\n\\t\\t\\tvirtualWidth,totalVirtualWidth);\\n\\t\\tif(newOffset == -1)\\n\\t\\t{\\n\\t\\t\\tint extraVirt = virtualWidth - totalVirtualWidth[0];\\n\\t\\t\\tnewCaret = getLineEndOffset(newLine) - 1;\\n\\t\\t\\tRectParams returnValue;\\n\\t\\t\\tboolean bias;\\n\\t\\t\\tif(s == null)\\n\\t\\t\\t\\tbias = (newCaret < caret);\\n\\t\\t\\telse if(s.start == caret)\\n\\t\\t\\t\\tbias = (newCaret <= s.end);\\n\\t\\t\\telse if(s.end == caret)\\n\\t\\t\\t\\tbias = (newCaret <= s.start);\\n\\t\\t\\telse\\n\\t\\t\\t\\tbias = false;\\n\\t\\t\\tif(bias)\\n\\t\\t\\t\\treturnValue = new RectParams(extraVirt,0,newCaret);\\n\\t\\t\\telse\\n\\t\\t\\t\\treturnValue = new RectParams(0,extraVirt,newCaret);\\n\\t\\t\\treturn returnValue;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\treturn new RectParams(0,0,getLineStartOffset(newLine)\\n\\t\\t\\t\\t+ newOffset);\\n\\t\\t}\\n\\t} \\n\\t\\tstatic class TextAreaBorder extends AbstractBorder\\n\\t{\\n\\t\\tprivate static final Insets insets = new Insets(1, 1, 2, 2);\\n\\t\\t\\t\\tpublic void paintBorder(Component c, Graphics g, int x, int y,\\n\\t\\t\\tint width, int height)\\n\\t\\t{\\n\\t\\t\\tg.translate(x,y);\\n\\t\\t\\tg.setColor(MetalLookAndFeel.getControlDarkShadow());\\n\\t\\t\\tg.drawRect(0,0,width-2,height-2);\\n\\t\\t\\tg.setColor(MetalLookAndFeel.getControlHighlight());\\n\\t\\t\\tg.drawLine(width-1,1,width-1,height-1);\\n\\t\\t\\tg.drawLine(1,height-1,width-1,height-1);\\n\\t\\t\\tg.setColor(MetalLookAndFeel.getControl());\\n\\t\\t\\tg.drawLine(width-2,2,width-2,2);\\n\\t\\t\\tg.drawLine(1,height-2,1,height-2);\\n\\t\\t\\tg.translate(-x,-y);\\n\\t\\t} \\n\\t\\t\\t\\tpublic Insets getBorderInsets(Component c)\\n\\t\\t{\\n\\t\\t\\treturn new Insets(1,1,2,2);\\n\\t\\t} \\t} \\n\\t\\tclass ScrollLayout implements LayoutManager\\n\\t{\\n\\t\\t\\t\\tpublic void addLayoutComponent(String name, Component comp)\\n\\t\\t{\\n\\t\\t\\tif(name.equals(CENTER))\\n\\t\\t\\t\\tcenter = comp;\\n\\t\\t\\telse if(name.equals(RIGHT))\\n\\t\\t\\t\\tright = comp;\\n\\t\\t\\telse if(name.equals(LEFT))\\n\\t\\t\\t\\tleft = comp;\\n\\t\\t\\telse if(name.equals(BOTTOM))\\n\\t\\t\\t\\tbottom = comp;\\n\\t\\t\\telse if(name.equals(TOP))\\n\\t\\t\\t\\ttop = comp;\\n\\t\\t} \\n\\t\\t\\t\\tpublic void removeLayoutComponent(Component comp)\\n\\t\\t{\\n\\t\\t\\tif(center == comp)\\n\\t\\t\\t\\tcenter = null;\\n\\t\\t\\telse if(right == comp)\\n\\t\\t\\t\\tright = null;\\n\\t\\t\\telse if(left == comp)\\n\\t\\t\\t\\tleft = null;\\n\\t\\t\\telse if(bottom == comp)\\n\\t\\t\\t\\tbottom = null;\\n\\t\\t\\telse if(top == comp)\\n\\t\\t\\t\\ttop = null;\\n\\t\\t} \\n\\t\\t\\t\\tpublic Dimension preferredLayoutSize(Container parent)\\n\\t\\t{\\n\\t\\t\\tDimension dim = new Dimension();\\n\\t\\t\\tBorder border = getBorder();\\n\\t\\t\\tInsets insets;\\n\\t\\t\\tif(border == null)\\n\\t\\t\\t\\tinsets = new Insets(0,0,0,0);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsets = getBorder().getBorderInsets(\\n\\t\\t\\t\\t\\tJEditTextArea.this);\\n\\t\\t\\t}\\n\\t\\t\\tdim.width = insets.left + insets.right;\\n\\t\\t\\tdim.height = insets.top + insets.bottom;\\n\\t\\t\\tDimension leftPref = left.getPreferredSize();\\n\\t\\t\\tdim.width += leftPref.width;\\n\\t\\t\\tDimension centerPref = center.getPreferredSize();\\n\\t\\t\\tdim.width += centerPref.width;\\n\\t\\t\\tdim.height += centerPref.height;\\n\\t\\t\\tDimension rightPref = right.getPreferredSize();\\n\\t\\t\\tdim.width += rightPref.width;\\n\\t\\t\\tDimension bottomPref = bottom.getPreferredSize();\\n\\t\\t\\tdim.height += bottomPref.height;\\n\\t\\t\\tif(top != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tDimension topPref = top.getPreferredSize();\\n\\t\\t\\t\\tdim.height += topPref.height;\\n\\t\\t\\t}\\n\\t\\t\\treturn dim;\\n\\t\\t} \\n\\t\\t\\t\\tpublic Dimension minimumLayoutSize(Container parent)\\n\\t\\t{\\n\\t\\t\\tDimension dim = new Dimension();\\n\\t\\t\\tBorder border = getBorder();\\n\\t\\t\\tInsets insets;\\n\\t\\t\\tif(border == null)\\n\\t\\t\\t\\tinsets = new Insets(0,0,0,0);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsets = getBorder().getBorderInsets(\\n\\t\\t\\t\\t\\tJEditTextArea.this);\\n\\t\\t\\t}\\n\\t\\t\\tdim.width = insets.left + insets.right;\\n\\t\\t\\tdim.height = insets.top + insets.bottom;\\n\\t\\t\\tDimension leftPref = left.getMinimumSize();\\n\\t\\t\\tdim.width += leftPref.width;\\n\\t\\t\\tDimension centerPref = center.getMinimumSize();\\n\\t\\t\\tdim.width += centerPref.width; \\n\\t\\t\\tdim.height += centerPref.height;\\n\\t\\t\\tDimension rightPref = right.getMinimumSize();\\n\\t\\t\\tdim.width += rightPref.width;\\n\\t\\t\\tDimension bottomPref = bottom.getMinimumSize();\\n\\t\\t\\tdim.height += bottomPref.height;\\n\\t\\t\\tif(top != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tDimension topPref = top.getMinimumSize();\\n\\t\\t\\t\\tdim.height += topPref.height;\\n\\t\\t\\t}\\n\\t\\t\\treturn dim;\\n\\t\\t} \\n\\t\\t\\t\\tpublic void layoutContainer(Container parent)\\n\\t\\t{\\n\\t\\t\\tDimension size = parent.getSize();\\n\\t\\t\\tBorder border = getBorder();\\n\\t\\t\\tInsets insets;\\n\\t\\t\\tif(border == null)\\n\\t\\t\\t\\tinsets = new Insets(0,0,0,0);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsets = getBorder().getBorderInsets(\\n\\t\\t\\t\\t\\tJEditTextArea.this);\\n\\t\\t\\t}\\n\\t\\t\\tint itop = insets.top;\\n\\t\\t\\tint ileft = insets.left;\\n\\t\\t\\tint ibottom = insets.bottom;\\n\\t\\t\\tint iright = insets.right;\\n\\t\\t\\tint rightWidth = right.getPreferredSize().width;\\n\\t\\t\\tint leftWidth = left.getPreferredSize().width;\\n\\t\\t\\tint topHeight;\\n\\t\\t\\tif(top != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttopHeight = top.getPreferredSize().height;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\ttopHeight = 0;\\n\\t\\t\\t}\\n\\t\\t\\tint bottomHeight = bottom.getPreferredSize().height;\\n\\t\\t\\tint centerWidth = Math.max(0,size.width - leftWidth\\n\\t\\t\\t\\t- rightWidth - ileft - iright);\\n\\t\\t\\tint centerHeight = Math.max(0,size.height - topHeight\\n\\t\\t\\t\\t- bottomHeight - itop - ibottom);\\n\\t\\t\\tleft.setBounds(\\n\\t\\t\\t\\tileft,\\n\\t\\t\\t\\titop+topHeight,\\n\\t\\t\\t\\tleftWidth,\\n\\t\\t\\t\\tcenterHeight);\\n\\t\\t\\tcenter.setBounds(\\n\\t\\t\\t\\tileft + leftWidth,\\n\\t\\t\\t\\titop+topHeight,\\n\\t\\t\\t\\tcenterWidth,\\n\\t\\t\\t\\tcenterHeight);\\n\\t\\t\\tright.setBounds(\\n\\t\\t\\t\\tileft + leftWidth + centerWidth,\\n\\t\\t\\t\\titop+topHeight,\\n\\t\\t\\t\\trightWidth,\\n\\t\\t\\t\\tcenterHeight);\\n\\t\\t\\tbottom.setBounds(\\n\\t\\t\\t\\tileft,\\n\\t\\t\\t\\titop + topHeight + centerHeight,\\n\\t\\t\\t\\tMath.max(0,size.width - vertical.getWidth()\\n\\t\\t\\t\\t\\t- ileft - iright),\\n\\t\\t\\t\\tbottomHeight);\\n\\t\\t\\tif(top != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttop.setBounds(\\n\\t\\t\\t\\t\\tileft,\\n\\t\\t\\t\\t\\titop,\\n\\t\\t\\t\\t\\tleftWidth+centerWidth+rightWidth,\\n\\t\\t\\t\\t\\ttopHeight);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tComponent center;\\n\\t\\tComponent left;\\n\\t\\tComponent right;\\n\\t\\tComponent bottom;\\n\\t\\tComponent top;\\n\\t} \\n\\t\\tstatic class CaretBlinker implements ActionListener\\n\\t{\\n\\t\\t\\t\\tpublic void actionPerformed(ActionEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(focusedComponent != null && focusedComponent.hasFocus())\\n\\t\\t\\t\\tfocusedComponent.blinkCaret();\\n\\t\\t} \\t} \\n\\t\\tclass MutableCaretEvent extends CaretEvent\\n\\t{\\n\\t\\t\\t\\tMutableCaretEvent()\\n\\t\\t{\\n\\t\\t\\tsuper(JEditTextArea.this);\\n\\t\\t} \\n\\t\\t\\t\\tpublic int getDot()\\n\\t\\t{\\n\\t\\t\\treturn getCaretPosition();\\n\\t\\t} \\n\\t\\t\\t\\tpublic int getMark()\\n\\t\\t{\\n\\t\\t\\treturn getMarkPosition();\\n\\t\\t} \\t} \\n\\t\\tclass AdjustHandler implements AdjustmentListener\\n\\t{\\n\\t\\t\\t\\tpublic void adjustmentValueChanged(final AdjustmentEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(!scrollBarsInitialized)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(evt.getAdjustable() == vertical)\\n\\t\\t\\t\\tsetFirstLine(vertical.getValue());\\n\\t\\t\\telse\\n\\t\\t\\t\\tsetHorizontalOffset(-horizontal.getValue());\\n\\t\\t} \\t} \\n\\tclass BufferChangeHandler extends BufferChangeAdapter\\n\\t{\\n\\t\\tboolean delayedUpdate;\\n\\t\\tboolean delayedMultilineUpdate;\\n\\t\\tint delayedRepaintStart;\\n\\t\\tint delayedRepaintEnd;\\n\\t\\t\\t\\tpublic void foldLevelChanged(Buffer buffer, int start, int end)\\n\\t\\t{\\n\\t\\t\\tif(!bufferChanging && end != 0\\n\\t\\t\\t\\t&& buffer.isLoaded())\\n\\t\\t\\t{\\n\\t\\t\\t\\tinvalidateLineRange(start - 1,\\n\\t\\t\\t\\t\\tgetLastPhysicalLine());\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void contentInserted(Buffer buffer, int startLine, int start,\\n\\t\\t\\tint numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t\\tdelayedMultilineUpdate = true;\\n\\t\\t\\tint endLine = startLine + numLines;\\n\\t\\t\\tdelayedRepaint(startLine,endLine);\\n\\t\\t\\t\\t\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\t\\tif(s.contentInserted(buffer,startLine,start,\\n\\t\\t\\t\\t\\tnumLines,length))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdelayedRepaint(s.startLine,s.endLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(!buffer.isTransactionInProgress())\\n\\t\\t\\t\\ttransactionComplete(buffer);\\n\\t\\t\\tif(caret >= start)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t? ELECTRIC_SCROLL : NO_SCROLL);\\n\\t\\t\\t\\tmoveCaretPosition(caret + length,scrollMode);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t? NORMAL_SCROLL : NO_SCROLL);\\n\\t\\t\\t\\tmoveCaretPosition(caret,scrollMode);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tpublic void contentRemoved(Buffer buffer, int startLine, int start,\\n\\t\\t\\tint numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t\\tdelayedMultilineUpdate = true;\\n\\t\\t\\tdelayedRepaint(startLine,startLine);\\n\\t\\t\\t\\t\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\t\\tint oldStartLine = s.startLine;\\n\\t\\t\\t\\tint oldEndLine = s.endLine;\\n\\t\\t\\t\\tboolean changed = s.contentRemoved(buffer,\\n\\t\\t\\t\\t\\tstartLine,start,numLines,length);\\n\\t\\t\\t\\tif(s.start == s.end)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tselection.removeElement(s);\\n\\t\\t\\t\\t\\tdelayedRepaint(oldStartLine,oldEndLine);\\n\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(changed)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdelayedRepaint(s.startLine,s.endLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t? NORMAL_SCROLL : NO_SCROLL);\\n\\t\\t\\tif(caret > start)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caret <= start + length)\\n\\t\\t\\t\\t\\tmoveCaretPosition(start,scrollMode);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmoveCaretPosition(caret - length,scrollMode);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tmoveCaretPosition(caret,scrollMode);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(!buffer.isTransactionInProgress())\\n\\t\\t\\t\\ttransactionComplete(buffer);\\n\\t\\t}\\n\\t\\t\\t\\tpublic void transactionComplete(Buffer buffer)\\n\\t\\t{\\n\\t\\t\\tif(delayedUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(delayedMultilineUpdate)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tinvalidateScreenLineRange(chunkCache\\n\\t\\t\\t\\t\\t\\t.getScreenLineOfOffset(\\n\\t\\t\\t\\t\\t\\tdelayedRepaintStart,0),\\n\\t\\t\\t\\t\\t\\tvisibleLines);\\n\\t\\t\\t\\t\\tdelayedMultilineUpdate = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tinvalidateLineRange(delayedRepaintStart,\\n\\t\\t\\t\\t\\t\\tdelayedRepaintEnd);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdelayedUpdate = false;\\n\\t\\t\\t}\\n\\t\\t\\tIterator iter = runnables.iterator();\\n\\t\\t\\twhile(iter.hasNext())\\n\\t\\t\\t\\t((Runnable)iter.next()).run();\\n\\t\\t\\trunnables.clear();\\n\\t\\t} \\n\\t\\tprivate boolean caretAutoScroll()\\n\\t\\t{\\n\\t\\t\\treturn view == jEdit.getActiveView()\\n\\t\\t\\t\\t&& view.getTextArea() == JEditTextArea.this;\\n\\t\\t} \\n\\t\\t\\t\\tprivate void delayedRepaint(int startLine, int endLine)\\n\\t\\t{\\n\\t\\t\\tchunkCache.invalidateChunksFromPhys(startLine);\\n\\t\\t\\tif(!delayedUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedRepaintStart = startLine;\\n\\t\\t\\t\\tdelayedRepaintEnd = endLine;\\n\\t\\t\\t\\tdelayedUpdate = true;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedRepaintStart = Math.min(\\n\\t\\t\\t\\t\\tdelayedRepaintStart,\\n\\t\\t\\t\\t\\tstartLine);\\n\\t\\t\\t\\tdelayedRepaintEnd = Math.max(\\n\\t\\t\\t\\t\\tdelayedRepaintEnd,\\n\\t\\t\\t\\t\\tendLine);\\n\\t\\t\\t}\\n\\t\\t} \\t} \\n\\t\\tclass FocusHandler implements FocusListener\\n\\t{\\n\\t\\t\\t\\tpublic void focusGained(FocusEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(bufferChanging)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(match != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caretLine < match.startLine)\\n\\t\\t\\t\\t\\tinvalidateLineRange(caretLine,match.endLine);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tinvalidateLineRange(match.startLine,caretLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t\\tfocusedComponent = JEditTextArea.this;\\n\\t\\t} \\n\\t\\t\\t\\tpublic void focusLost(FocusEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(!isShowing())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(match != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caretLine < match.startLine)\\n\\t\\t\\t\\t\\tinvalidateLineRange(caretLine,match.endLine);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tinvalidateLineRange(match.startLine,caretLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t} \\t} \\n\\t\\tclass MouseHandler extends MouseInputAdapter\\n\\t{\\n\\t\\tprivate int dragStartLine;\\n\\t\\tprivate int dragStartOffset;\\n\\t\\tprivate int dragStart;\\n\\t\\tprivate int clickCount;\\n\\t\\tprivate boolean dragged;\\n\\t\\tprivate boolean quickCopyDrag;\\n\\t\\tprivate boolean clearStatus;\\n\\t\\tprivate boolean control;\\n\\t\\tprivate boolean maybeDragAndDrop;\\n\\t\\t\\t\\tpublic void mousePressed(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tcontrol = (OperatingSystem.isMacOS() && evt.isMetaDown())\\n\\t\\t\\t\\t|| (!OperatingSystem.isMacOS() && evt.isControlDown());\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tview.getInputHandler().resetLastActionCount();\\n\\t\\t\\tquickCopyDrag = (isQuickCopyEnabled() &&\\n\\t\\t\\t\\tGUIUtilities.isMiddleButton(evt.getModifiers()));\\n\\t\\t\\tif(!quickCopyDrag)\\n\\t\\t\\t{\\n\\t\\t\\t\\trequestFocus();\\n\\t\\t\\t\\tfocusedComponent = JEditTextArea.this;\\n\\t\\t\\t}\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tint x = evt.getX();\\n\\t\\t\\tint y = evt.getY();\\n\\t\\t\\tdragStart = xyToOffset(x,y,!(painter.isBlockCaretEnabled()\\n\\t\\t\\t\\t|| isOverwriteEnabled()));\\n\\t\\t\\tdragStartLine = getLineOfOffset(dragStart);\\n\\t\\t\\tdragStartOffset = dragStart - getLineStartOffset(dragStartLine);\\n\\t\\t\\tif(GUIUtilities.isPopupTrigger(evt) && popup != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(popup.isVisible())\\n\\t\\t\\t\\t\\tpopup.setVisible(false);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(getSelectionCount() == 0 || multi)\\n\\t\\t\\t\\t\\t\\tmoveCaretPosition(dragStart,false);\\n\\t\\t\\t\\t\\tGUIUtilities.showPopupMenu(popup,painter,\\n\\t\\t\\t\\t\\t\\tevt.getX(),evt.getY());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tdragged = false;\\n\\t\\t\\tblink = true;\\n\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t\\tclickCount = evt.getClickCount();\\n\\t\\t\\tif(isDragEnabled() && getDragAndDropCallback() != null\\n\\t\\t\\t\\t&& getSelectionAtOffset(dragStart) != null\\n\\t\\t\\t\\t&& clickCount == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmaybeDragAndDrop = true;\\n\\t\\t\\t\\tmoveCaretPosition(dragStart,false);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tmaybeDragAndDrop = false;\\n\\t\\t\\tswitch(clickCount)\\n\\t\\t\\t{\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\tdoSingleClick(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\tdoDoubleClick(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault: \\t\\t\\t\\tdoTripleClick(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doSingleClick(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tint x = evt.getX();\\n\\t\\t\\tint extraEndVirt = 0;\\n\\t\\t\\tif(chunkCache.getLineInfo(screenLastLine).lastSubregion)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfloat dragStartLineWidth = offsetToXY(\\n\\t\\t\\t\\t\\tdragStartLine,getLineLength(dragStartLine),\\n\\t\\t\\t\\t\\treturnValue).x;\\n\\t\\t\\t\\tif(x > dragStartLineWidth)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\textraEndVirt = (int)(\\n\\t\\t\\t\\t\\t\\t(x - dragStartLineWidth)\\n\\t\\t\\t\\t\\t\\t/ charWidth);\\n\\t\\t\\t\\t\\tif(!getPainter().isBlockCaretEnabled()\\n\\t\\t\\t\\t\\t\\t&& !isOverwriteEnabled()\\n\\t\\t\\t\\t\\t\\t&& (x - getHorizontalOffset()) % charWidth > charWidth / 2)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\textraEndVirt++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(control || isRectangularSelectionEnabled())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint screenLine = (evt.getY() / getPainter()\\n\\t\\t\\t\\t\\t.getFontMetrics().getHeight());\\n\\t\\t\\t\\tif(screenLine > screenLastLine)\\n\\t\\t\\t\\t\\tscreenLine = screenLastLine;\\n\\t\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(screenLine);\\n\\t\\t\\t\\tif(info.lastSubregion)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tString whitespace = MiscUtilities\\n\\t\\t\\t\\t\\t\\t.createWhiteSpace(extraEndVirt,0);\\n\\t\\t\\t\\t\\tbuffer.insert(dragStart,whitespace);\\n\\t\\t\\t\\t\\tdragStart += whitespace.length();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(evt.isShiftDown())\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tresizeSelection(getMarkPosition(),dragStart,extraEndVirt,\\n\\t\\t\\t\\t\\tisRectangularSelectionEnabled()\\n\\t\\t\\t\\t\\t|| control);\\n\\t\\t\\t\\tif(!quickCopyDrag)\\n\\t\\t\\t\\t\\tmoveCaretPosition(dragStart,false);\\n\\t\\t\\t\\t\\t\\t\\t\\tdragStartLine = getMarkLine();\\n\\t\\t\\t\\tdragStart = getMarkPosition();\\n\\t\\t\\t\\tdragStartOffset = dragStart\\n\\t\\t\\t\\t\\t- getLineStartOffset(dragStartLine);\\n\\t\\t\\t\\t\\t\\t\\t\\tdragged = true;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(!quickCopyDrag)\\n\\t\\t\\t\\tmoveCaretPosition(dragStart,false);\\n\\t\\t\\tif(!(multi || quickCopyDrag))\\n\\t\\t\\t\\tselectNone();\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doDoubleClick(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(getLineLength(dragStartLine) == 0)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tString lineText = getLineText(dragStartLine);\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tif(dragStartOffset == getLineLength(dragStartLine))\\n\\t\\t\\t\\tdragStartOffset--;\\n\\t\\t\\tboolean joinNonWordChars =\\n\\t\\t\\t\\tjEdit.getBooleanProperty(\\\"view.joinNonWordChars\\\");\\n\\t\\t\\tint wordStart = TextUtilities.findWordStart(lineText,\\n\\t\\t\\t\\tdragStartOffset,noWordSep,joinNonWordChars);\\n\\t\\t\\tint wordEnd = TextUtilities.findWordEnd(lineText,\\n\\t\\t\\t\\tdragStartOffset+1,noWordSep,joinNonWordChars);\\n\\t\\t\\tint lineStart = getLineStartOffset(dragStartLine);\\n\\t\\t\\tSelection sel = new Selection.Range(\\n\\t\\t\\t\\tlineStart + wordStart,\\n\\t\\t\\t\\tlineStart + wordEnd);\\n\\t\\t\\tif(isMultipleSelectionEnabled())\\n\\t\\t\\t\\taddToSelection(sel);\\n\\t\\t\\telse\\n\\t\\t\\t\\tsetSelection(sel);\\n\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t\\tquickCopyDrag = false;\\n\\t\\t\\tmoveCaretPosition(lineStart + wordEnd,false);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdragged = true;\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doTripleClick(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tint newCaret = getLineEndOffset(dragStartLine);\\n\\t\\t\\tif(dragStartLine == buffer.getLineCount() - 1)\\n\\t\\t\\t\\tnewCaret--;\\n\\t\\t\\tSelection sel = new Selection.Range(\\n\\t\\t\\t\\tgetLineStartOffset(dragStartLine),\\n\\t\\t\\t\\tnewCaret);\\n\\t\\t\\tif(isMultipleSelectionEnabled())\\n\\t\\t\\t\\taddToSelection(sel);\\n\\t\\t\\telse\\n\\t\\t\\t\\tsetSelection(sel);\\n\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t\\tquickCopyDrag = false;\\n\\t\\t\\tmoveCaretPosition(newCaret,false);\\n\\t\\t} \\n\\t\\t\\t\\tpublic void mouseDragged(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(maybeDragAndDrop)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstartDragAndDrop(evt,control);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(dndInProgress)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(GUIUtilities.isPopupTrigger(evt)\\n\\t\\t\\t\\t|| (popup != null && popup.isVisible()))\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(evt.getY() < 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint delta = Math.min(-1,evt.getY()\\n\\t\\t\\t\\t\\t/ painter.getFontMetrics()\\n\\t\\t\\t\\t\\t.getHeight());\\n\\t\\t\\t\\tsetFirstLine(getFirstLine() + delta);\\n\\t\\t\\t}\\n\\t\\t\\telse if(evt.getY() >= painter.getHeight())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint delta = Math.max(1,(evt.getY()\\n\\t\\t\\t\\t\\t- painter.getHeight()) /\\n\\t\\t\\t\\t\\tpainter.getFontMetrics()\\n\\t\\t\\t\\t\\t.getHeight());\\n\\t\\t\\t\\tif(lastLinePartial)\\n\\t\\t\\t\\t\\tdelta--;\\n\\t\\t\\t\\tsetFirstLine(getFirstLine() + delta);\\n\\t\\t\\t}\\n\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t{\\n\\t\\t\\t\\tview.getStatus().setMessage(jEdit.getProperty(\\n\\t\\t\\t\\t\\t\\\"view.status.rect-quick-copy\\\"));\\n\\t\\t\\t\\tclearStatus = true;\\n\\t\\t\\t}\\n\\t\\t\\tswitch(clickCount)\\n\\t\\t\\t{\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\tdoSingleDrag(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\tdoDoubleDrag(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault: \\t\\t\\t\\tdoTripleDrag(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doSingleDrag(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tdragged = true;\\n\\t\\t\\tint x = evt.getX();\\n\\t\\t\\tint y = evt.getY();\\n\\t\\t\\tif(y < 0)\\n\\t\\t\\t\\ty = 0;\\n\\t\\t\\telse if(y >= painter.getHeight())\\n\\t\\t\\t\\ty = painter.getHeight() - 1;\\n\\t\\t\\tint dot = xyToOffset(x,y,\\n\\t\\t\\t\\t(!painter.isBlockCaretEnabled()\\n\\t\\t\\t\\t&& !isOverwriteEnabled())\\n\\t\\t\\t\\t|| quickCopyDrag);\\n\\t\\t\\tint dotLine = buffer.getLineOfOffset(dot);\\n\\t\\t\\tint extraEndVirt = 0;\\n\\t\\t\\tif(chunkCache.getLineInfo(screenLastLine).lastSubregion)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfloat dotLineWidth = offsetToXY(dotLine,getLineLength(dotLine),\\n\\t\\t\\t\\t\\treturnValue).x;\\n\\t\\t\\t\\tif(x > dotLineWidth)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\textraEndVirt = (int)((x - dotLineWidth) / charWidth);\\n\\t\\t\\t\\t\\tif(!getPainter().isBlockCaretEnabled()\\n\\t\\t\\t\\t\\t\\t&& !isOverwriteEnabled()\\n\\t\\t\\t\\t\\t\\t&& (x - getHorizontalOffset()) % charWidth > charWidth / 2)\\n\\t\\t\\t\\t\\t\\textraEndVirt++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tresizeSelection(dragStart,dot,extraEndVirt,\\n\\t\\t\\t\\tisRectangularSelectionEnabled()\\n\\t\\t\\t\\t|| control);\\n\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tscrollTo(dotLine,dot - buffer.getLineStartOffset(dotLine),false);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(dot != caret)\\n\\t\\t\\t\\t\\tmoveCaretPosition(dot,false);\\n\\t\\t\\t\\tif(isRectangularSelectionEnabled()\\n\\t\\t\\t\\t\\t&& extraEndVirt != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscrollTo(dotLine,dot - buffer.getLineStartOffset(dotLine)\\n\\t\\t\\t\\t\\t\\t+ extraEndVirt,false);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doDoubleDrag(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tint markLineStart = getLineStartOffset(dragStartLine);\\n\\t\\t\\tint markLineLength = getLineLength(dragStartLine);\\n\\t\\t\\tint mark = dragStartOffset;\\n\\t\\t\\tint pos = xyToOffset(evt.getX(),\\n\\t\\t\\t\\tMath.max(0,Math.min(painter.getHeight(),evt.getY())),\\n\\t\\t\\t\\t!(painter.isBlockCaretEnabled() || isOverwriteEnabled()));\\n\\t\\t\\tint line = getLineOfOffset(pos);\\n\\t\\t\\tint lineStart = getLineStartOffset(line);\\n\\t\\t\\tint lineLength = getLineLength(line);\\n\\t\\t\\tint offset = pos - lineStart;\\n\\t\\t\\tString lineText = getLineText(line);\\n\\t\\t\\tString markLineText = getLineText(dragStartLine);\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tboolean joinNonWordChars =\\n\\t\\t\\t\\tjEdit.getBooleanProperty(\\\"view.joinNonWordChars\\\");\\n\\t\\t\\tif(markLineStart + dragStartOffset > lineStart + offset)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(offset != 0 && offset != lineLength)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\toffset = TextUtilities.findWordStart(\\n\\t\\t\\t\\t\\t\\tlineText,offset,noWordSep,\\n\\t\\t\\t\\t\\t\\tjoinNonWordChars);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(markLineLength != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmark = TextUtilities.findWordEnd(\\n\\t\\t\\t\\t\\t\\tmarkLineText,mark,noWordSep,\\n\\t\\t\\t\\t\\t\\tjoinNonWordChars);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(offset != 0 && lineLength != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\toffset = TextUtilities.findWordEnd(\\n\\t\\t\\t\\t\\t\\tlineText,offset,noWordSep,\\n\\t\\t\\t\\t\\t\\tjoinNonWordChars);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(mark != 0 && mark != markLineLength)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmark = TextUtilities.findWordStart(\\n\\t\\t\\t\\t\\t\\tmarkLineText,mark,noWordSep,\\n\\t\\t\\t\\t\\t\\tjoinNonWordChars);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(lineStart + offset == caret)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tresizeSelection(markLineStart + mark,lineStart + offset,\\n\\t\\t\\t\\t0,false);\\n\\t\\t\\tif(!quickCopyDrag)\\n\\t\\t\\t\\tmoveCaretPosition(lineStart + offset,false);\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doTripleDrag(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tint offset = xyToOffset(evt.getX(),\\n\\t\\t\\t\\tMath.max(0,Math.min(painter.getHeight(),evt.getY())),\\n\\t\\t\\t\\tfalse);\\n\\t\\t\\tint mouseLine = getLineOfOffset(offset);\\n\\t\\t\\tint mark;\\n\\t\\t\\tint mouse;\\n\\t\\t\\tif(dragStartLine > mouseLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmark = getLineEndOffset(dragStartLine) - 1;\\n\\t\\t\\t\\tif(offset == getLineEndOffset(mouseLine) - 1)\\n\\t\\t\\t\\t\\tmouse = offset;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmouse = getLineStartOffset(mouseLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tmark = getLineStartOffset(dragStartLine);\\n\\t\\t\\t\\tif(offset == getLineStartOffset(mouseLine))\\n\\t\\t\\t\\t\\tmouse = offset;\\n\\t\\t\\t\\telse if(offset == getLineEndOffset(mouseLine) - 1\\n\\t\\t\\t\\t\\t&& mouseLine != getBuffer().getLineCount() - 1)\\n\\t\\t\\t\\t\\tmouse = getLineEndOffset(mouseLine);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmouse = getLineEndOffset(mouseLine) - 1;\\n\\t\\t\\t}\\n\\t\\t\\tmouse = Math.min(getBuffer().getLength(),mouse);\\n\\t\\t\\tif(mouse == caret)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tdragged = true;\\n\\t\\t\\tresizeSelection(mark,mouse,0,false);\\n\\t\\t\\tmoveCaretPosition(mouse,false);\\n\\t\\t} \\n\\t\\t\\t\\tpublic void mouseReleased(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tSelection sel = getSelectionAtOffset(dragStart);\\n\\t\\t\\tif(dragged && sel != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tRegisters.setRegister('%',getSelectedText(sel));\\n\\t\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tremoveFromSelection(sel);\\n\\t\\t\\t\\t\\tRegisters.paste(focusedComponent,\\n\\t\\t\\t\\t\\t\\t'%',sel instanceof Selection.Rect);\\n\\t\\t\\t\\t\\tfocusedComponent.requestFocus();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(isQuickCopyEnabled()\\n\\t\\t\\t\\t&& GUIUtilities.isMiddleButton(evt.getModifiers()))\\n\\t\\t\\t{\\n\\t\\t\\t\\tJEditTextArea.this.requestFocus();\\n\\t\\t\\t\\tfocusedComponent = JEditTextArea.this;\\n\\t\\t\\t\\tsetCaretPosition(dragStart,false);\\n\\t\\t\\t\\tif(!isEditable())\\n\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tRegisters.paste(JEditTextArea.this,'%',control);\\n\\t\\t\\t}\\n\\t\\t\\telse if(maybeDragAndDrop && !isMultipleSelectionEnabled())\\n\\t\\t\\t{\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\t}\\n\\t\\t\\tdragged = false;\\n\\t\\t\\tif(clearStatus)\\n\\t\\t\\t{\\n\\t\\t\\t\\tclearStatus = false;\\n\\t\\t\\t\\tview.getStatus().setMessage(null);\\n\\t\\t\\t}\\n\\t\\t} \\t} \\n\\t\\tstatic\\n\\t{\\n\\t\\tcaretTimer = new Timer(500,new CaretBlinker());\\n\\t\\tcaretTimer.setInitialDelay(500);\\n\\t\\tcaretTimer.start();\\n\\t\\tstructureTimer = new Timer(100,new ActionListener()\\n\\t\\t{\\n\\t\\t\\tpublic void actionPerformed(ActionEvent evt)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(focusedComponent != null)\\n\\t\\t\\t\\t\\tfocusedComponent.updateStructureHighlight();\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tstructureTimer.setInitialDelay(100);\\n\\t\\tstructureTimer.setRepeats(false);\\n\\t} }\""
        },
        {
            "content": "The source code for `JEditTextArea.java` reveals several key structural and functional dependencies. This class is central to the text editing functionality in jEdit, and it interacts with a number of other classes for rendering, buffer management, input handling, and user interface components.\n\n### Key Dependencies Identified from the Code:\n\n1. **Buffer (`org.gjt.sp.jedit.buffer.Buffer`)**:\n   - The `JEditTextArea` maintains a reference to a `Buffer` object which holds the actual text content.\n   - Operations like `getText()`, `setText()`, `getLineText()`, and `insert()` are delegated to the buffer.\n   - Changes to this class will likely impact any code interacting with the buffer or its contents.\n\n2. **TextAreaPainter (`org.gjt.sp.jedit.textarea.TextAreaPainter`)**:\n   - Responsible for rendering the text area.\n   - Directly used for painting, caret rendering, and screen updates.\n\n3. **Gutter (`org.gjt.sp.jedit.textarea.Gutter`)**:\n   - Manages the gutter (line numbers, icons, etc.) associated with the text area.\n   - Instantiated and managed by `JEditTextArea`.\n\n4. **MouseHandler (`JEditTextArea.MouseHandler`)**:\n   - Inner class that handles mouse events and selections.\n   - Extensive interaction with selection logic and caret positioning.\n\n5. **ChunkCache (`org.gjt.sp.jedit.textarea.ChunkCache`)**:\n   - Used to manage how lines are displayed, especially for wrapped or folded lines.\n   - Critical for performance and display correctness.\n\n6. **DisplayManager (`org.gjt.sp.jedit.textarea.DisplayManager`)**:\n   - Manages visible lines, folding, and scrolling behavior.\n   - Tightly integrated with how the text area renders content.\n\n7. **Selection Classes (`org.gjt.sp.jedit.textarea.Selection.*`)**:\n   - Used to manage various types of selections (range, rectangular).\n   - Core to text manipulation and UI interactions.\n\n8. **Input/Event Handling**:\n   - Interfaces with `InputHandler`, `KeyHandler`, and `FocusHandler`.\n   - These influence keyboard shortcuts, focus behavior, and event propagation.\n\n9. **Utilities (`org.gjt.sp.util.Log`, `org.gjt.sp.jedit.MiscUtilities`, `org.gjt.sp.jedit.TextUtilities`)**:\n   - Logging, utility functions for string manipulation, whitespace handling, etc., are used throughout the code.\n\n10. **GUI Components (`javax.swing.*`, `java.awt.*`)**:\n    - Heavy reliance on Swing components for layout, painting, and event handling.\n\n---\n\n### Entities That Need Synchronization Based on Co-Change and Structural Analysis\n\nFrom the co-change data and structural analysis, the following entities should be closely examined for synchronization when changes occur in `JEditTextArea.java`:\n\n| Entity | Reason |\n|--------|--------|\n| **Buffer.java** | Core data structure; frequent modifications and high confidence in co-change relationships. |\n| **TextAreaPainter.java** | Rendering component; frequently co-changed and tightly coupled structurally. |\n| **Gutter.java** | Visual component tied directly to line information; often modified together. |\n| **ChunkCache.java** | Influences how lines are rendered and cached; high co-change support. |\n| **DisplayManager.java** | Controls visibility, folding, and scrolling; significant coupling. |\n| **Selection.java** and related inner classes | Central to selection logic; modified alongside JEditTextArea. |\n| **MouseHandler.java** | Handles mouse-based interactions; tightly integrated with selection and caret movement. |\n| **BufferChangeHandler.java** | Listens to buffer changes and triggers repaints/updates. |\n| **Log.java** | Logging mechanism used within JEditTextArea. |\n| **View.java** | Top-level container passed through constructors and used for event handling. |\n\n### Next Steps\nTo further validate these findings and uncover deeper interdependencies, I can:\n1. Use `get_coupling_dependencies` between `JEditTextArea.java` and each of the above files to confirm structural dependencies.\n2. Use `get_conceptual_coupling` to check semantic similarity if needed.\n\nWould you like me to proceed with checking coupling dependencies for one or more of these files?\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_7594cddae05c49be87d99a",
                    "function": {
                        "arguments": "{\"entity1\": \"JEditTextArea.java\", \"entity2\": \"Buffer.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"There are no coupling dependencies between these two entities\"]"
        },
        {
            "content": "There are no direct coupling dependencies between `JEditTextArea.java` and `Buffer.java`, despite their strong functional relationship. This suggests that the interaction might be primarily through method calls or usage rather than structural dependencies like inheritance, interfaces, or field declarations.\n\nLet\u2019s continue by checking coupling dependencies with other key entities identified from co-change and source code analysis:\n\n1. **TextAreaPainter.java** \u2013 Responsible for rendering.\n2. **Gutter.java** \u2013 Directly used in layout and display.\n3. **ChunkCache.java** \u2013 Critical for line management and display logic.\n\nI'll check coupling dependencies with these next.\n\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_8d89fc1b96544e6c8f0120",
                    "function": {
                        "arguments": "{\"entity1\": \"JEditTextArea.java\", \"entity2\": \"TextAreaPainter.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"ReturnType(RT): Return Type found: getPainter returns TextAreaPainter,  \", \"Class Member Variable Usage Variable (CMAUA): Coupling found in method getPainter, at line: 157. Instance of TextAreaPainter member variable painter is used directly.  Coupling found in method recalculateVisibleLines, at line: 5177. Instance of TextAreaPainter member variable painter is used directly.  \", \"ConstructorInvoking(CMI): Construction Method Invoking found: new TextAreaPainter(this),  \", \"ConstructorInvoking(CMAIM): Coupling found in method setHorizontalOffset, at line: 673. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method repaint.  Coupling found in method scrollTo, at line: 840. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getWidth.  Coupling found in method scrollTo, at line: 843. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getWidth.  Coupling found in method xyToOffset, at line: 962. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getFontMetrics.  Coupling found in method offsetToXY, at line: 1035. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getFontMetrics.  Coupling found in method invalidateScreenLineRange, at line: 1076. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getFontMetrics.  Coupling found in method invalidateScreenLineRange, at line: 1079. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method repaint.  Coupling found in method invalidateScreenLineRange, at line: 1079. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getWidth.  Coupling found in method setMultipleSelectionEnabled, at line: 3850. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method repaint.  Coupling found in method setRectangularSelectionEnabled, at line: 3895. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method repaint.  Coupling found in method propertiesChanged, at line: 4886. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getFont.  Coupling found in method propertiesChanged, at line: 4887. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getFontRenderContext.  Coupling found in method propertiesChanged, at line: 4889. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getFont.  Coupling found in method propertiesChanged, at line: 4890. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getFontRenderContext.  Coupling found in method propertiesChanged, at line: 4904. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method repaint.  Coupling found in method updateMaxHorizontalScrollWidth, at line: 5166. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getWidth.  Coupling found in method updateMaxHorizontalScrollWidth, at line: 5168. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getWidth.  Coupling found in method recalculateVisibleLines, at line: 5179. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getHeight.  Coupling found in method recalculateVisibleLines, at line: 5180. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getFontMetrics.  Coupling found in method updateScrollBars, at line: 5232. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getWidth.  Coupling found in method updateScrollBars, at line: 5238. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method repaint.  Coupling found in method updateScrollBars, at line: 5240. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getFontMetrics.  Coupling found in method updateStructureHighlight, at line: 5654. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method isStructureHighlightEnabled.  Coupling found in method mousePressed, at line: 6350. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method isBlockCaretEnabled.  Coupling found in method mouseDragged, at line: 6557. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getFontMetrics.  Coupling found in method mouseDragged, at line: 6561. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getHeight.  Coupling found in method mouseDragged, at line: 6564. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getHeight.  Coupling found in method mouseDragged, at line: 6565. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getFontMetrics.  Coupling found in method doSingleDrag, at line: 6602. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getHeight.  Coupling found in method doSingleDrag, at line: 6603. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getHeight.  Coupling found in method doSingleDrag, at line: 6606. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method isBlockCaretEnabled.  Coupling found in method doDoubleDrag, at line: 6656. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getHeight.  Coupling found in method doDoubleDrag, at line: 6657. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method isBlockCaretEnabled.  Coupling found in method doTripleDrag, at line: 6715. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getHeight.\"]"
        },
        {
            "content": "There are **strong coupling dependencies** between `JEditTextArea.java` and `TextAreaPainter.java`. These dependencies indicate that `JEditTextArea` heavily relies on `TextAreaPainter` for rendering, layout calculations, and user interaction handling. Below is a breakdown of the key coupling types:\n\n---\n\n### \ud83d\udccc Coupling Dependency Types Identified\n\n1. **Return Type (RT)**:\n   - `getPainter()` returns an instance of `TextAreaPainter`, indicating a direct structural dependency.\n\n2. **Class Member Variable Usage (CMAUA, CMAIM)**:\n   - The `painter` member variable is used throughout `JEditTextArea` to:\n     - Access UI-related properties (e.g., `getWidth()`, `getHeight()`, `getFontMetrics()`)\n     - Trigger repaints (`repaint()`)\n     - Check painter state (`isBlockCaretEnabled()`, `isStructureHighlightEnabled()`)\n\n3. **Constructor Invoking (CMI)**:\n   - A new `TextAreaPainter` is constructed with `new TextAreaPainter(this)`, showing tight integration.\n\n4. **Method Calls**:\n   - Multiple methods in `JEditTextArea` invoke operations on the `TextAreaPainter` object, such as:\n     - `repaint()`\n     - `getFontMetrics()`\n     - `getWidth()`\n     - `getHeight()`\n\n---\n\n### \ud83d\udd0d Implications for Change Impact Analysis\n\nDue to these dependencies, changes in either class can significantly impact the other:\n\n- **Changes in `TextAreaPainter` API or behavior** (e.g., method renaming, return type modification, visual logic updates) will likely require corresponding updates in `JEditTextArea`.\n- **Changes in `JEditTextArea`** related to rendering, scrolling, or caret movement may necessitate adjustments in `TextAreaPainter`.\n\nThis confirms that `TextAreaPainter.java` must be **synchronized** alongside `JEditTextArea.java` during any change.\n\n---\n\n### Next Steps\n\nLet\u2019s continue checking coupling for the remaining high-priority files identified earlier:\n\n1. **Gutter.java**\n2. **ChunkCache.java**\n\nWould you like me to check coupling for one of these next?\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_88d63490e21d4e9ab7d4eb",
                    "function": {
                        "arguments": "{\"entity1\": \"JEditTextArea.java\", \"entity2\": \"Gutter.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"ReturnType(RT): Return Type found: getGutter returns Gutter,  \", \"Class Member Variable Usage Variable (CMAUA): Coupling found in method getGutter, at line: 167. Instance of Gutter member variable gutter is used directly.  \", \"ConstructorInvoking(CMI): Construction Method Invoking found: new Gutter(view, this),  \", \"ConstructorInvoking(CMAIM): Coupling found in method invalidateScreenLineRange, at line: 1080. Instance of Gutter member variable gutter is used to call Gutter's method repaint.  Coupling found in method invalidateScreenLineRange, at line: 1080. Instance of Gutter member variable gutter is used to call Gutter's method getWidth.  Coupling found in method propertiesChanged, at line: 4903. Instance of Gutter member variable gutter is used to call Gutter's method repaint.  Coupling found in method updateStructureHighlight, at line: 5655. Instance of Gutter member variable gutter is used to call Gutter's method isStructureHighlightEnabled.\"]"
        },
        {
            "content": "There are **clear and significant coupling dependencies** between `JEditTextArea.java` and `Gutter.java`. Below is a summary of the dependency types and their implications:\n\n---\n\n### \ud83d\udccc Coupling Dependency Types Identified\n\n1. **Return Type (RT)**:\n   - `getGutter()` returns an instance of `Gutter`, indicating that `JEditTextArea` provides access to its internal gutter component.\n\n2. **Class Member Variable Usage (CMAUA, CMAIM)**:\n   - The `gutter` member variable is used directly in several methods for:\n     - Repainting (`repaint()`)\n     - Width calculation (`getWidth()`)\n     - Checking visual state (`isStructureHighlightEnabled()`)\n\n3. **Constructor Invoking (CMI)**:\n   - A new `Gutter` is instantiated with `new Gutter(view, this)`, showing tight integration between these classes.\n\n4. **Method Calls**:\n   - `JEditTextArea` calls methods on the `Gutter` object such as `repaint()` and checks UI-related properties like structure highlighting.\n\n---\n\n### \ud83d\udd0d Implications for Change Impact Analysis\n\n- Since `JEditTextArea` creates and manages a `Gutter` instance directly, any change in the `Gutter`'s constructor or method signatures will impact `JEditTextArea`.\n- UI-related changes in how the gutter behaves or renders (e.g., repaint logic, width calculations, structure highlighting) may require corresponding updates in `JEditTextArea`.\n\nThis confirms that `Gutter.java` must be **synchronized** alongside `JEditTextArea.java` when making changes.\n\n---\n\n### \u2705 Entities That Must Be Synchronized So Far\n\n| Entity | Reason |\n|--------|--------|\n| `TextAreaPainter.java` | Heavy rendering interaction; many method calls and structural dependencies |\n| `Gutter.java` | Direct instantiation and usage; UI synchronization needed |\n\n---\n\n### Next Step\n\nWe should continue validating coupling with other co-changed and structurally dependent entities. The next logical candidate is **`ChunkCache.java`**, which plays a central role in line rendering and display logic.\n\nWould you like me to proceed with checking coupling dependencies for `ChunkCache.java`?\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_a1cfc3d41ba84a9a858685",
                    "function": {
                        "arguments": "{\"entity1\": \"JEditTextArea.java\", \"entity2\": \"ChunkCache.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"ConstructorInvoking(CMI): Construction Method Invoking found: new ChunkCache(this),  \", \"ConstructorInvoking(CMAIM): Coupling found in method setBuffer, at line: 289. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method setBuffer.  Coupling found in method setFirstLine, at line: 487. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method invalidateAll.  Coupling found in method setFirstLine, at line: 492. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method invalidateAll.  Coupling found in method setFirstLine, at line: 497. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method scrollDown.  Coupling found in method setFirstLine, at line: 502. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method scrollUp.  Coupling found in method setFirstPhysicalLine, at line: 605. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method invalidateAll.  Coupling found in method setFirstPhysicalLine, at line: 609. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method scrollDown.  Coupling found in method setFirstPhysicalLine, at line: 613. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method scrollUp.  Coupling found in method scrollTo, at line: 784. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getScreenLineOfOffset.  Coupling found in method scrollTo, at line: 788. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method scrollTo, at line: 790. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getSubregionOfOffset.  Coupling found in method getPhysicalLineOfScreenLine, at line: 883. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method getScreenLineOfOffset, at line: 896. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getScreenLineOfOffset.  Coupling found in method getScreenLineStartOffset, at line: 907. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method getScreenLineEndOffset, at line: 923. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method xToScreenLineOffset, at line: 985. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method offsetToXY, at line: 1031. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getScreenLineOfOffset.  Coupling found in method offsetToXY, at line: 1039. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method invalidateScreenLineRange, at line: 1073. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method needFullRepaint.  Coupling found in method invalidateLine, at line: 1102. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method invalidateLine, at line: 1118. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method needFullRepaint.  Coupling found in method invalidateLineRange, at line: 1153. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method invalidateLineRange, at line: 1172. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method needFullRepaint.  Coupling found in method moveCaretPosition, at line: 2292. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getScreenLineOfOffset.  Coupling found in method getMagicCaretPosition, at line: 2339. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method subregionOffsetToX.  Coupling found in method goToNextLine, at line: 2509. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getBelowPosition.  Coupling found in method goToPrevLine, at line: 2833. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getAbovePosition.  Coupling found in method goToStartOfWhiteSpace, at line: 3170. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getSubregionStartOffset.  Coupling found in method goToEndOfWhiteSpace, at line: 3207. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getSubregionEndOffset.  Coupling found in method deleteLine, at line: 3650. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method subregionOffsetToX.  Coupling found in method deleteLine, at line: 3673. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method xToSubregionOffset.  Coupling found in method deleteLine, at line: 3679. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method xToSubregionOffset.  Coupling found in method goToParentFold, at line: 4008. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method xToSubregionOffset.  Coupling found in method goToNextFold, at line: 4043. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method xToSubregionOffset.  Coupling found in method goToPrevFold, at line: 4080. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method xToSubregionOffset.  Coupling found in method collapseFold, at line: 4098. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method subregionOffsetToX.  Coupling found in method collapseFold, at line: 4111. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method xToSubregionOffset.  Coupling found in method expandFold, at line: 4122. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method subregionOffsetToX.  Coupling found in method expandFold, at line: 4132. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method xToSubregionOffset.  Coupling found in method propertiesChanged, at line: 4902. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method invalidateAll.  Coupling found in method updateMaxHorizontalScrollWidth, at line: 5159. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getMaxHorizontalScrollWidth.  Coupling found in method recalculateVisibleLines, at line: 5186. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method recalculateVisibleLines.  Coupling found in method foldStructureChanged, at line: 5199. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method invalidateAll.  Coupling found in method updateStructureHighlight, at line: 5675. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getScreenLineOfOffset.  Coupling found in method recalculateLastPhysicalLine, at line: 5715. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method transactionComplete, at line: 6216. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getScreenLineOfOffset.  Coupling found in method delayedRepaint, at line: 6250. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method invalidateChunksFromPhys.  Coupling found in method doSingleClick, at line: 6409. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method doSingleClick, at line: 6434. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method doSingleDrag, at line: 6612. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.\"]"
        },
        {
            "role": "user",
            "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
        },
        {
            "content": "Title: Diagnosis of starting entity `JEditTextArea.java`  \nChange set: [TextAreaPainter.java, Gutter.java, ChunkCache.java, BufferChangeHandler.java, DisplayManager.java, MouseHandler.java, View.java, Buffer.java, Selection.java, Log.java, TextAreaBorder.java, ScrollLayout.java, AbstractOptionPane.java, EditAction.java, InputHandler.java, FocusHandler.java, AboutPanel.java, EnhancedMenu.java, EnhancedMenuItem.java, EnhancedCheckBoxMenuItem.java, EnhancedButton.java, DockingOptionPane.java, TextAreaOptionPane.java, AbbrevsOptionPane.java, ModeOptionPane.java, OptionsDialog.java, HistoryModel.java, Abbrevs.java, Registers.java, GUIUtilities.java, Macros.java, Plugin.java, DockableWindowManager.java, Status.java, ToolTipManager.java, FoldVisibilityManager.java, DefaultInputHandler.java, SearchAndReplace.java, VFSBrowser.java, FileVFS.java, MiscUtilities.java, TextUtilities.java]  \n\nDetails:  \n- **TextAreaPainter.java**: Directly used for rendering and screen updates; heavy method calls and construction.  \n- **Gutter.java**: Created and managed directly by JEditTextArea; used for line number and gutter rendering.  \n- **ChunkCache.java**: Central to managing how lines are displayed and cached; used throughout the text area logic.  \n- **BufferChangeHandler.java**: Listens to buffer changes and triggers repaints or updates.  \n- **DisplayManager.java**: Controls visibility, folding, and scrolling behavior; tightly integrated with display logic.  \n- **MouseHandler.java**: Inner class handling mouse events and selection; deeply embedded in user interaction.  \n- **View.java**: Passed through constructor; used for input handling, status updates, and UI coordination.  \n- **Buffer.java**: Core data structure holding the text content; many methods delegate to it.  \n- **Selection.java**: Used extensively for managing selections (range, rectangular).  \n- **Log.java**: Logging mechanism used throughout the code for debug and error output.  \n- **TextAreaBorder.java**: Custom border used in layout and painting.  \n- **ScrollLayout.java**: Layout manager responsible for scrollable area arrangement.  \n- **AbstractOptionPane.java**: Base class for options panels that may interact with text editing settings.  \n- **EditAction.java**: Actions tied to editor commands executed from this component.  \n- **InputHandler.java**: Manages keyboard input and action dispatching.  \n- **FocusHandler.java**: Handles focus gained/lost events affecting caret and highlight behavior.  \n- **AboutPanel.java**: May be invoked via menu actions linked to the text area.  \n- **EnhancedMenu.java, EnhancedMenuItem.java, EnhancedCheckBoxMenuItem.java, EnhancedButton.java**: UI components potentially used in context menus or toolbars.  \n- **DockingOptionPane.java, TextAreaOptionPane.java, AbbrevsOptionPane.java, ModeOptionPane.java, OptionsDialog.java**: Option panes/settings dialogs related to text area configuration.  \n- **HistoryModel.java**: Could be involved in caret or edit history tracking.  \n- **Abbrevs.java**: Auto-expansion abbreviations tied to typing behavior.  \n- **Registers.java**: Clipboard/register operations linked to selection and paste logic.  \n- **GUIUtilities.java**: Used for dialog display, popup triggering, and general UI utility.  \n- **Macros.java**: Macro recording and execution can be triggered from the text area.  \n- **Plugin.java**: Plugins may hook into editing functionality or UI elements.  \n- **DockableWindowManager.java**: Manages dockable windows associated with the view.  \n- **Status.java**: StatusBar updates linked to caret position, selection, etc.  \n- **ToolTipManager.java**: Tooltip management for painter and gutter.  \n- **FoldVisibilityManager.java**: Controls fold expansion/collapse; interacts with display manager.  \n- **DefaultInputHandler.java**: Default implementation of input handler used by the text area.  \n- **SearchAndReplace.java**: Search-related actions often initiated from the text area.  \n- **VFSBrowser.java**: Invoked for file operations possibly triggered from macros or plugins.  \n- **FileVFS.java**: File access abstraction used during editing or search operations.  \n- **MiscUtilities.java**: General-purpose utilities used in indentation, spacing, etc.  \n- **TextUtilities.java**: Core text manipulation routines used in selection and word operations.",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        }
    ],
    "interaction_records": {
        "step_histories": [
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4"
                ],
                "response_message": "m5"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6"
                ],
                "response_message": "m7"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8"
                ],
                "response_message": "m9"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10"
                ],
                "response_message": "m11"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12"
                ],
                "response_message": "m13"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14"
                ],
                "response_message": "m15"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14",
                    "m15",
                    "m16",
                    "m17"
                ],
                "response_message": "m18"
            }
        ],
        "mid_to_message": {
            "m1": {
                "role": "system",
                "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
            },
            "m2": {
                "role": "user",
                "content": "The project you need to analyze is `jEdit`, a well-known Java open source project. The starting entity you need to deal with is JEditTextArea.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
            },
            "m3": {
                "content": "",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_9f2a7399492247eda5af20",
                        "function": {
                            "arguments": "{\"entity\": \"JEditTextArea.java\"}",
                            "name": "get_co_change_relationship"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m4": {
                "name": "get_co_change_relationship",
                "role": "tool",
                "content": "[[\"MouseHandler\", \"47\", \"0.26704545454545453\"], [\"Buffer\", \"19\", \"0.10795454545454546\"], [\"FoldVisibilityManager\", \"9\", \"0.05113636363636364\"], [\"DefaultInputHandler\", \"8\", \"0.045454545454545456\"], [\"SearchAndReplace\", \"17\", \"0.09659090909090909\"], [\"View\", \"21\", \"0.11931818181818182\"], [\"CharIndexedSegment\", \"2\", \"0.011363636363636364\"], [\"SearchMatcher\", \"4\", \"0.022727272727272728\"], [\"BrowserJTree\", \"4\", \"0.022727272727272728\"], [\"BoyerMooreSearchMatcher\", \"6\", \"0.03409090909090909\"], [\"HyperSearchRequest\", \"4\", \"0.022727272727272728\"], [\"RESearchMatcher\", \"6\", \"0.03409090909090909\"], [\"TextRenderer\", \"2\", \"0.011363636363636364\"], [\"RotatedTextIcon\", \"2\", \"0.011363636363636364\"], [\"FileVFS\", \"7\", \"0.03977272727272727\"], [\"FontSelectorDialog\", \"2\", \"0.011363636363636364\"], [\"FileRootsVFS\", \"4\", \"0.022727272727272728\"], [\"PanelWindowContainer\", \"8\", \"0.045454545454545456\"], [\"FontSelector\", \"2\", \"0.011363636363636364\"], [\"TextAreaPainter\", \"40\", \"0.22727272727272727\"], [\"Chunk\", \"4\", \"0.022727272727272728\"], [\"AboutPanel\", \"2\", \"0.011363636363636364\"], [\"TextUtilities\", \"11\", \"0.0625\"], [\"OffsetManager\", \"24\", \"0.13636363636363635\"], [\"BufferPrintable\", \"10\", \"0.056818181818181816\"], [\"MyFocusManager\", \"2\", \"0.011363636363636364\"], [\"BrowserView\", \"6\", \"0.03409090909090909\"], [\"BrowserIORequest\", \"4\", \"0.022727272727272728\"], [\"VFSBrowser\", \"12\", \"0.06818181818181818\"], [\"ChunkCache\", \"51\", \"0.2897727272727273\"], [\"LineInfo\", \"6\", \"0.03409090909090909\"], [\"BufferChangeHandler\", \"50\", \"0.2840909090909091\"], [\"Gutter\", \"25\", \"0.14204545454545456\"], [\"EditPane\", \"13\", \"0.07386363636363637\"], [\"FocusHandler\", \"5\", \"0.028409090909090908\"], [\"TOCTree\", \"2\", \"0.011363636363636364\"], [\"HelpViewer\", \"6\", \"0.03409090909090909\"], [\"HyperSearchResults\", \"5\", \"0.028409090909090908\"], [\"BufferPrinter\", \"2\", \"0.011363636363636364\"], [\"SearchDialog\", \"6\", \"0.03409090909090909\"], [\"EditAction\", \"4\", \"0.022727272727272728\"], [\"Macro\", \"2\", \"0.011363636363636364\"], [\"EnhancedButton\", \"2\", \"0.011363636363636364\"], [\"EnhancedMenuItem\", \"2\", \"0.011363636363636364\"], [\"ActionListHandler\", \"2\", \"0.011363636363636364\"], [\"InputHandler\", \"5\", \"0.028409090909090908\"], [\"DockingOptionPane\", \"2\", \"0.011363636363636364\"], [\"PaintSelection\", \"8\", \"0.045454545454545456\"], [\"ActionHandler\", \"17\", \"0.09659090909090909\"], [\"CompoundEdit\", \"2\", \"0.011363636363636364\"], [\"UndoManager\", \"4\", \"0.022727272727272728\"], [\"MemoryStatus\", \"2\", \"0.011363636363636364\"], [\"KeyEventWorkaround\", \"8\", \"0.045454545454545456\"], [\"HistoryModel\", \"2\", \"0.011363636363636364\"], [\"MultiSelectStatusChanged\", \"2\", \"0.011363636363636364\"], [\"GutterOptionPane\", \"2\", \"0.011363636363636364\"], [\"AbstractOptionPane\", \"2\", \"0.011363636363636364\"], [\"OptionsDialog\", \"2\", \"0.011363636363636364\"], [\"TextAreaOptionPane\", \"2\", \"0.011363636363636364\"], [\"Renderer\", \"2\", \"0.011363636363636364\"], [\"AbbrevsOptionPane\", \"2\", \"0.011363636363636364\"], [\"ExtensionManager\", \"2\", \"0.011363636363636364\"], [\"BrowserHandler\", \"2\", \"0.011363636363636364\"], [\"VFSFileChooserDialog\", \"4\", \"0.022727272727272728\"], [\"Word\", \"2\", \"0.011363636363636364\"], [\"Result\", \"2\", \"0.011363636363636364\"], [\"ModeOptionPane\", \"4\", \"0.022727272727272728\"], [\"HelpIndex\", \"3\", \"0.017045454545454544\"], [\"ModeProperties\", \"4\", \"0.022727272727272728\"], [\"HelpSearchPanel\", \"2\", \"0.011363636363636364\"], [\"ResultRenderer\", \"2\", \"0.011363636363636364\"], [\"BufferOptions\", \"4\", \"0.022727272727272728\"], [\"EditingOptionPane\", \"4\", \"0.022727272727272728\"], [\"KeyHandler\", \"3\", \"0.017045454545454544\"], [\"CompleteWord\", \"3\", \"0.017045454545454544\"], [\"CaretHandler\", \"1\", \"0.005681818181818182\"], [\"ResultVisitor\", \"1\", \"0.005681818181818182\"], [\"MouseWheelHandler\", \"6\", \"0.03409090909090909\"], [\"BufferLoadedVisitor\", \"1\", \"0.005681818181818182\"], [\"BufferClosedVisitor\", \"1\", \"0.005681818181818182\"], [\"Operation\", \"2\", \"0.011363636363636364\"], [\"Install\", \"4\", \"0.022727272727272728\"], [\"Plugin\", \"2\", \"0.011363636363636364\"], [\"PluginManagerProgress\", \"2\", \"0.011363636363636364\"], [\"Remove\", \"2\", \"0.011363636363636364\"], [\"Roster\", \"4\", \"0.022727272727272728\"], [\"SoftWrapTokenHandler\", \"2\", \"0.011363636363636364\"], [\"PluginResURLConnection\", \"2\", \"0.011363636363636364\"], [\"SettingsReloader\", \"2\", \"0.011363636363636364\"], [\"Autosave\", \"4\", \"0.022727272727272728\"], [\"BufferIORequest\", \"8\", \"0.045454545454545456\"], [\"BeanShell\", \"4\", \"0.022727272727272728\"], [\"DisplayTokenHandler\", \"6\", \"0.03409090909090909\"], [\"Log\", \"2\", \"0.011363636363636364\"], [\"GUIUtilities\", \"7\", \"0.03977272727272727\"], [\"LogViewer\", \"6\", \"0.03409090909090909\"], [\"ListHandler\", \"2\", \"0.011363636363636364\"], [\"LogListModel\", \"2\", \"0.011363636363636364\"], [\"Anchor\", \"4\", \"0.022727272727272728\"], [\"DisplayManager\", \"24\", \"0.13636363636363635\"], [\"ScrollLineCount\", \"8\", \"0.045454545454545456\"], [\"FirstLine\", \"20\", \"0.11363636363636363\"], [\"WrapGuide\", \"4\", \"0.022727272727272728\"], [\"DockableWindowManager\", \"9\", \"0.05113636363636364\"], [\"Entry\", \"6\", \"0.03409090909090909\"], [\"EnhancedCheckBoxMenuItem\", \"2\", \"0.011363636363636364\"], [\"FileCellRenderer\", \"2\", \"0.011363636363636364\"], [\"PaneNameRenderer\", \"2\", \"0.011363636363636364\"], [\"StatusBar\", \"5\", \"0.028409090909090908\"], [\"ParentDirectoryRenderer\", \"2\", \"0.011363636363636364\"], [\"RolloverButton\", \"4\", \"0.022727272727272728\"], [\"EditPlugin\", \"2\", \"0.011363636363636364\"], [\"EnhancedMenu\", \"2\", \"0.011363636363636364\"], [\"Debug\", \"6\", \"0.03409090909090909\"], [\"PaintLineBackground\", \"4\", \"0.022727272727272728\"], [\"ButtonLayout\", \"4\", \"0.022727272727272728\"], [\"VFSDirectoryEntryTable\", \"2\", \"0.011363636363636364\"], [\"VFSFileNameField\", \"4\", \"0.022727272727272728\"], [\"DockablePanel\", \"2\", \"0.011363636363636364\"], [\"DockableWindowCompare\", \"2\", \"0.011363636363636364\"], [\"RectParams\", \"2\", \"0.011363636363636364\"], [\"VMS\", \"2\", \"0.011363636363636364\"], [\"RingListModel\", \"2\", \"0.011363636363636364\"], [\"ActionTextField\", \"2\", \"0.011363636363636364\"], [\"ActionBar\", \"2\", \"0.011363636363636364\"], [\"PluginTableModel\", \"5\", \"0.028409090909090908\"], [\"InputPane\", \"3\", \"0.017045454545454544\"], [\"GrabKeyDialog\", \"2\", \"0.011363636363636364\"], [\"ButtonActionHandler\", \"2\", \"0.011363636363636364\"], [\"TextAreaTransferHandler\", \"8\", \"0.045454545454545456\"], [\"PosBottomHalf\", \"4\", \"0.022727272727272728\"], [\"PositionManager\", \"4\", \"0.022727272727272728\"], [\"PosTopHalf\", \"2\", \"0.011363636363636364\"], [\"RootsEntry\", \"2\", \"0.011363636363636364\"], [\"ActionSet\", \"2\", \"0.011363636363636364\"], [\"PluginJAR\", \"3\", \"0.017045454545454544\"], [\"DropHandler\", \"2\", \"0.011363636363636364\"], [\"SplashScreen\", \"2\", \"0.011363636363636364\"], [\"MiscUtilities\", \"5\", \"0.028409090909090908\"], [\"PerspectiveManager\", \"2\", \"0.011363636363636364\"], [\"DockableLayout\", \"2\", \"0.011363636363636364\"], [\"InstallPanel\", \"3\", \"0.017045454545454544\"], [\"LogList\", \"2\", \"0.011363636363636364\"], [\"MarkerHighlight\", \"2\", \"0.011363636363636364\"], [\"DockableListHandler\", \"2\", \"0.011363636363636364\"], [\"CheckBoxListModel\", \"2\", \"0.011363636363636364\"], [\"jEdit\", \"2\", \"0.011363636363636364\"], [\"ScrollLayout\", \"2\", \"0.011363636363636364\"], [\"TextAreaBorder\", \"2\", \"0.011363636363636364\"], [\"PaintWrapGuide\", \"4\", \"0.022727272727272728\"], [\"SelectionManager\", \"3\", \"0.017045454545454544\"], [\"Reset\", \"2\", \"0.011363636363636364\"], [\"RegexpIndentRule\", \"4\", \"0.022727272727272728\"], [\"OpenBracketIndentRule\", \"2\", \"0.011363636363636364\"], [\"IndentRuleFactory\", \"2\", \"0.011363636363636364\"], [\"Registers\", \"2\", \"0.011363636363636364\"], [\"RegisterViewer\", \"2\", \"0.011363636363636364\"], [\"Rect\", \"2\", \"0.011363636363636364\"], [\"JEditBuffer\", \"2\", \"0.011363636363636364\"], [\"AlignBracket\", \"2\", \"0.011363636363636364\"], [\"VFS\", \"2\", \"0.011363636363636364\"], [\"MacOSPlugin\", \"1\", \"0.005681818181818182\"], [\"Macros\", \"1\", \"0.005681818181818182\"], [\"BrowserColorsModel\", \"1\", \"0.005681818181818182\"]]"
            },
            "m5": {
                "content": "The co-change relationships for the entity `JEditTextArea.java` have been retrieved. The results indicate several files that are frequently modified together with `JEditTextArea.java`. Here's how we can interpret some of the top results:\n\n1. **MouseHandler (support: 47, confidence: ~0.267)**:\n   - Frequently changed alongside mouse-related functionality in `JEditTextArea`.\n\n2. **Buffer (support: 19, confidence: ~0.108)**:\n   - Related to buffer management within the text area.\n\n3. **TextAreaPainter (support: 40, confidence: ~0.227)**:\n   - A significant relationship suggesting frequent changes related to painting or rendering of the text area.\n\n4. **ChunkCache (support: 51, confidence: ~0.290)**:\n   - High support indicates it is often involved in changes with `JEditTextArea`, possibly related to caching chunks of text data.\n\n5. **BufferChangeHandler (support: 50, confidence: ~0.284)**:\n   - Strong indication of close coupling regarding buffer change events.\n\n6. **Gutter (support: 25, confidence: ~0.142)**:\n   - Often modified together with JEditTextArea, potentially involving line number or gutter-related visual elements.\n\n7. **DisplayManager (support: 24, confidence: ~0.136)**:\n   - Another key component likely involved in rendering and display logic tied to the text area.\n\n8. **OffsetManager (support: 24, confidence: ~0.136)**:\n   - Manages offsets in the text area, indicating a strong functional dependency.\n\nThese entities should be carefully reviewed for potential synchronization needs when changes are made to `JEditTextArea.java`.\n\nNext, to better understand the structural dependencies, I will use the `get_call_graph` function on `JEditTextArea.java` to see which entities are directly called or referenced by this class. \n\nLet me proceed with that.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_ad393200fd1f440a916190",
                        "function": {
                            "arguments": "{\"entity\": \"JEditTextArea.java\"}",
                            "name": "get_call_graph"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m6": {
                "role": "tool",
                "name": "get_call_graph",
                "content": "[\"Log\", \"\", \"\", \"\", \"\"]"
            },
            "m7": {
                "content": "The call graph analysis for `JEditTextArea.java` returned minimal useful information, showing only a reference to `Log`, which likely relates to logging functionality. Unfortunately, the majority of the output appears to be empty or incomplete, which doesn't help in identifying direct structural dependencies.\n\nGiven this limitation, we can instead examine the source code of `JEditTextArea.java` directly to identify important structural relationships and dependencies. By analyzing its method calls, variable usages, and other interactions with other classes, we can uncover entities that are tightly coupled with it.\n\nLet me retrieve the source code of `JEditTextArea.java` for further analysis.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_78ce53788bee41b8bc8a45",
                        "function": {
                            "arguments": "{\"entity\": \"JEditTextArea.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m8": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package org.gjt.sp.jedit.textarea;\\nimport java.awt.*;\\nimport java.awt.event.*;\\nimport java.lang.reflect.Method;\\nimport java.util.Enumeration;\\nimport java.util.Iterator;\\nimport java.util.LinkedList;\\nimport java.util.List;\\nimport java.util.Set;\\nimport java.util.TreeSet;\\nimport java.util.Vector;\\nimport javax.swing.*;\\nimport javax.swing.border.*;\\nimport javax.swing.event.*;\\nimport javax.swing.plaf.metal.MetalLookAndFeel;\\nimport javax.swing.text.Position;\\nimport javax.swing.text.Segment;\\nimport org.gjt.sp.jedit.*;\\nimport org.gjt.sp.jedit.buffer.*;\\nimport org.gjt.sp.jedit.gui.*;\\nimport org.gjt.sp.jedit.syntax.*;\\nimport org.gjt.sp.util.Log;\\npublic class JEditTextArea extends JComponent\\n{\\n\\tpublic JEditTextArea(View view)\\n\\t{\\n\\t\\tenableEvents(AWTEvent.FOCUS_EVENT_MASK | AWTEvent.KEY_EVENT_MASK);\\n\\t\\tthis.view = view;\\n\\t\\t\\t\\tselection = new Vector();\\n\\t\\tchunkCache = new ChunkCache(this);\\n\\t\\tpainter = new TextAreaPainter(this);\\n\\t\\tgutter = new Gutter(view,this);\\n\\t\\tbufferHandler = new BufferChangeHandler();\\n\\t\\tlistenerList = new EventListenerList();\\n\\t\\tcaretEvent = new MutableCaretEvent();\\n\\t\\tblink = true;\\n\\t\\tlineSegment = new Segment();\\n\\t\\treturnValue = new Point();\\n\\t\\trunnables = new LinkedList();\\n\\t\\tstructureMatchers = new LinkedList();\\n\\t\\tstructureMatchers.add(new StructureMatcher.BracketMatcher());\\n\\t\\t\\t\\tsetLayout(new ScrollLayout());\\n\\t\\tadd(CENTER,painter);\\n\\t\\tadd(LEFT,gutter);\\n\\t\\t\\t\\tverticalBox = new Box(BoxLayout.X_AXIS);\\n\\t\\tverticalBox.add(vertical = new JScrollBar(JScrollBar.VERTICAL));\\n\\t\\tvertical.setRequestFocusEnabled(false);\\n\\t\\tadd(RIGHT,verticalBox);\\n\\t\\tadd(BOTTOM,horizontal = new JScrollBar(JScrollBar.HORIZONTAL));\\n\\t\\thorizontal.setRequestFocusEnabled(false);\\n\\t\\thorizontal.setValues(0,0,0,0);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(UIManager.getLookAndFeel() instanceof MetalLookAndFeel)\\n\\t\\t{\\n\\t\\t\\tsetBorder(new TextAreaBorder());\\n\\t\\t\\tvertical.putClientProperty(\\\"JScrollBar.isFreeStanding\\\",\\n\\t\\t\\t\\tBoolean.FALSE);\\n\\t\\t\\thorizontal.putClientProperty(\\\"JScrollBar.isFreeStanding\\\",\\n\\t\\t\\t\\tBoolean.FALSE);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\tvertical.addAdjustmentListener(new AdjustHandler());\\n\\t\\thorizontal.addAdjustmentListener(new AdjustHandler());\\n\\t\\tmouseHandler = new MouseHandler();\\n\\t\\tpainter.addMouseListener(mouseHandler);\\n\\t\\tpainter.addMouseMotionListener(mouseHandler);\\n\\t\\taddFocusListener(new FocusHandler());\\n\\t\\t\\t\\t\\t\\t\\t\\tfocusedComponent = this;\\n\\t} \\n\\tpublic void dispose()\\n\\t{\\n\\t\\tDisplayManager.textAreaDisposed(this);\\n\\t} \\n\\tpublic final TextAreaPainter getPainter()\\n\\t{\\n\\t\\treturn painter;\\n\\t} \\n\\tpublic final Gutter getGutter()\\n\\t{\\n\\t\\treturn gutter;\\n\\t} \\n\\tpublic DisplayManager getDisplayManager()\\n\\t{\\n\\t\\treturn displayManager;\\n\\t} \\n\\tpublic final boolean isCaretBlinkEnabled()\\n\\t{\\n\\t\\treturn caretBlinks;\\n\\t} \\n\\tpublic void setCaretBlinkEnabled(boolean caretBlinks)\\n\\t{\\n\\t\\tthis.caretBlinks = caretBlinks;\\n\\t\\tif(!caretBlinks)\\n\\t\\t\\tblink = false;\\n\\t\\tif(buffer != null)\\n\\t\\t\\tinvalidateLine(caretLine);\\n\\t} \\n\\tpublic final int getElectricScroll()\\n\\t{\\n\\t\\treturn electricScroll;\\n\\t} \\n\\tpublic final void setElectricScroll(int electricScroll)\\n\\t{\\n\\t\\tthis.electricScroll = electricScroll;\\n\\t} \\n\\tpublic final boolean isQuickCopyEnabled()\\n\\t{\\n\\t\\treturn quickCopy;\\n\\t} \\n\\tpublic final void setQuickCopyEnabled(boolean quickCopy)\\n\\t{\\n\\t\\tthis.quickCopy = quickCopy;\\n\\t} \\n\\tpublic final Buffer getBuffer()\\n\\t{\\n\\t\\treturn buffer;\\n\\t} \\n\\tpublic void setBuffer(Buffer buffer)\\n\\t{\\n\\t\\tif(this.buffer == buffer)\\n\\t\\t\\treturn;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbufferChanging = true;\\n\\t\\t\\tif(this.buffer != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\t\\tcaretLine = caret = caretScreenLine = 0;\\n\\t\\t\\t\\tmatch = null;\\n\\t\\t\\t\\tthis.buffer.removeBufferChangeListener(bufferHandler);\\n\\t\\t\\t}\\n\\t\\t\\tthis.buffer = buffer;\\n\\t\\t\\tbuffer.addBufferChangeListener(bufferHandler);\\n\\t\\t\\tbufferHandlerInstalled = true;\\n\\t\\t\\tchunkCache.setBuffer(buffer);\\n\\t\\t\\tpropertiesChanged();\\n\\t\\t\\tif(displayManager != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tDisplayManager.releaseDisplayManager(\\n\\t\\t\\t\\t\\tdisplayManager);\\n\\t\\t\\t}\\n\\t\\t\\tdisplayManager = DisplayManager.getDisplayManager(\\n\\t\\t\\t\\tbuffer,this);\\n\\t\\t\\tdisplayManager.init();\\n\\t\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\t\\trepaint();\\n\\t\\t\\tfireScrollEvent(true);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbufferChanging = false;\\n\\t\\t}\\n\\t} \\n\\tpublic final boolean isEditable()\\n\\t{\\n\\t\\treturn buffer.isEditable();\\n\\t} \\n\\tpublic final JPopupMenu getRightClickPopup()\\n\\t{\\n\\t\\treturn popup;\\n\\t} \\n\\tpublic final void setRightClickPopup(JPopupMenu popup)\\n\\t{\\n\\t\\tthis.popup = popup;\\n\\t} \\n\\tpublic Method getDragAndDropCallback()\\n\\t{\\n\\t\\treturn dndCallback;\\n\\t} \\n\\tpublic void setDragAndDropCallback(Method meth)\\n\\t{\\n\\t\\tdndCallback = meth;\\n\\t} \\n\\tpublic boolean isDragInProgress()\\n\\t{\\n\\t\\treturn dndInProgress;\\n\\t} \\n\\tpublic void setDragInProgress(boolean dndInProgress)\\n\\t{\\n\\t\\tthis.dndInProgress = dndInProgress;\\n\\t} \\n\\tpublic boolean isDragEnabled()\\n\\t{\\n\\t\\treturn dndEnabled;\\n\\t} \\n\\tpublic void setDragEnabled(boolean dndEnabled)\\n\\t{\\n\\t\\tthis.dndEnabled = dndEnabled;\\n\\t} \\n\\tpublic final int getFirstLine()\\n\\t{\\n\\t\\treturn displayManager.firstLine.scrollLine\\n\\t\\t\\t+ displayManager.firstLine.skew;\\n\\t} \\n\\t\\tpublic Exception trace;\\n\\tpublic void setFirstLine(int firstLine)\\n\\t{\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"setFirstLine() from \\\"\\n\\t\\t\\t\\t+ getFirstLine() + \\\" to \\\" + firstLine);\\n\\t\\t}\\n\\t\\t\\t\\tint max = displayManager.getScrollLineCount() - visibleLines\\n\\t\\t\\t+ (lastLinePartial ? 1 : 0);\\n\\t\\tif(firstLine > max)\\n\\t\\t\\tfirstLine = max;\\n\\t\\tif(firstLine < 0)\\n\\t\\t\\tfirstLine = 0;\\n\\t\\tint oldFirstLine = getFirstLine();\\n\\t\\tif(firstLine == oldFirstLine)\\n\\t\\t\\treturn;\\n\\t\\ttrace = new Exception();\\n\\t\\tif(firstLine >= oldFirstLine + visibleLines)\\n\\t\\t{\\n\\t\\t\\tdisplayManager.firstLine.scrollDown(firstLine - oldFirstLine);\\n\\t\\t\\tchunkCache.invalidateAll();\\n\\t\\t}\\n\\t\\telse if(firstLine <= oldFirstLine - visibleLines)\\n\\t\\t{\\n\\t\\t\\tdisplayManager.firstLine.scrollUp(oldFirstLine - firstLine);\\n\\t\\t\\tchunkCache.invalidateAll();\\n\\t\\t}\\n\\t\\telse if(firstLine > oldFirstLine)\\n\\t\\t{\\n\\t\\t\\tdisplayManager.firstLine.scrollDown(firstLine - oldFirstLine);\\n\\t\\t\\tchunkCache.scrollDown(firstLine - oldFirstLine);\\n\\t\\t}\\n\\t\\telse if(firstLine < oldFirstLine)\\n\\t\\t{\\n\\t\\t\\tdisplayManager.firstLine.scrollUp(oldFirstLine - firstLine);\\n\\t\\t\\tchunkCache.scrollUp(oldFirstLine - firstLine);\\n\\t\\t}\\n\\t\\tdisplayManager.firstLine.changed();\\n\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\trepaint();\\n\\t\\tfireScrollEvent(true);\\n\\t} \\n\\tpublic final int getFirstPhysicalLine()\\n\\t{\\n\\t\\treturn displayManager.firstLine.physicalLine;\\n\\t} \\n\\tpublic void setFirstPhysicalLine(int physFirstLine)\\n\\t{\\n\\t\\tsetFirstPhysicalLine(physFirstLine,0);\\n\\t} \\n\\tpublic void setFirstPhysicalLine(int physFirstLine, int skew)\\n\\t{\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"setFirstPhysicalLine(\\\"\\n\\t\\t\\t\\t+ physFirstLine + \\\",\\\" + skew + \\\")\\\");\\n\\t\\t}\\n\\t\\tint amount = (physFirstLine - displayManager.firstLine.physicalLine);\\n\\t\\tint oldFirstLine = getFirstLine();\\n\\t\\tif(amount == 0)\\n\\t\\t{\\n\\t\\t\\tskew -= displayManager.firstLine.skew;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(skew < 0)\\n\\t\\t\\t\\tdisplayManager.firstLine.scrollUp(-skew);\\n\\t\\t\\telse if(skew > 0)\\n\\t\\t\\t\\tdisplayManager.firstLine.scrollDown(skew);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(amount > 0)\\n\\t\\t\\tdisplayManager.firstLine.physDown(amount,skew);\\n\\t\\telse if(amount < 0)\\n\\t\\t\\tdisplayManager.firstLine.physUp(-amount,skew);\\n\\t\\tint firstLine = getFirstLine();\\n\\t\\tif(firstLine == oldFirstLine)\\n\\t\\t\\t;\\n\\t\\telse if(firstLine >= oldFirstLine + visibleLines\\n\\t\\t\\t|| firstLine <= oldFirstLine - visibleLines)\\n\\t\\t{\\n\\t\\t\\tchunkCache.invalidateAll();\\n\\t\\t}\\n\\t\\telse if(firstLine > oldFirstLine)\\n\\t\\t{\\n\\t\\t\\tchunkCache.scrollDown(firstLine - oldFirstLine);\\n\\t\\t}\\n\\t\\telse if(firstLine < oldFirstLine)\\n\\t\\t{\\n\\t\\t\\tchunkCache.scrollUp(oldFirstLine - firstLine);\\n\\t\\t}\\n\\t\\tdisplayManager.firstLine.changed();\\n\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\trepaint();\\n\\t\\tfireScrollEvent(true);\\n\\t} \\n\\tpublic final int getLastPhysicalLine()\\n\\t{\\n\\t\\treturn physLastLine;\\n\\t} \\n\\tpublic final int getVisibleLines()\\n\\t{\\n\\t\\treturn visibleLines;\\n\\t} \\n\\tpublic final int getHorizontalOffset()\\n\\t{\\n\\t\\treturn horizontalOffset;\\n\\t} \\n\\tpublic void setHorizontalOffset(int horizontalOffset)\\n\\t{\\n\\t\\tif(horizontalOffset > 0)\\n\\t\\t\\thorizontalOffset = 0;\\n\\t\\tif(horizontalOffset == this.horizontalOffset)\\n\\t\\t\\treturn;\\n\\t\\tthis.horizontalOffset = horizontalOffset;\\n\\t\\tif(horizontalOffset != horizontal.getValue())\\n\\t\\t\\tupdateScrollBars();\\n\\t\\tpainter.repaint();\\n\\t\\tfireScrollEvent(false);\\n\\t} \\n\\tpublic void scrollUpLine()\\n\\t{\\n\\t\\tsetFirstLine(getFirstLine() - 1);\\n\\t} \\n\\tpublic void scrollUpPage()\\n\\t{\\n\\t\\tsetFirstLine(getFirstLine() - getVisibleLines()\\n\\t\\t\\t+ (lastLinePartial ? 1 : 0));\\n\\t} \\n\\tpublic void scrollDownLine()\\n\\t{\\n\\t\\tsetFirstLine(getFirstLine() + 1);\\n\\t} \\n\\tpublic void scrollDownPage()\\n\\t{\\n\\t\\tsetFirstLine(getFirstLine() + getVisibleLines()\\n\\t\\t\\t- (lastLinePartial ? 1 : 0));\\n\\t} \\n\\tpublic void scrollToCaret(boolean doElectricScroll)\\n\\t{\\n\\t\\tscrollTo(caretLine,caret - buffer.getLineStartOffset(caretLine),\\n\\t\\t\\tdoElectricScroll);\\n\\t} \\n\\tpublic void scrollTo(int offset, boolean doElectricScroll)\\n\\t{\\n\\t\\tint line = buffer.getLineOfOffset(offset);\\n\\t\\tscrollTo(line,offset - buffer.getLineStartOffset(line),\\n\\t\\t\\tdoElectricScroll);\\n\\t} \\n\\tpublic void scrollTo(int line, int offset, boolean doElectricScroll)\\n\\t{\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"scrollTo(), lineCount=\\\"\\n\\t\\t\\t\\t+ getLineCount());\\n\\t\\t\\t\\tint extraEndVirt;\\n\\t\\tint lineLength = buffer.getLineLength(line);\\n\\t\\tif(offset > lineLength)\\n\\t\\t{\\n\\t\\t\\textraEndVirt = charWidth * (offset - lineLength);\\n\\t\\t\\toffset = lineLength;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\textraEndVirt = 0;\\n\\t\\tint _electricScroll = (doElectricScroll\\n\\t\\t\\t&& visibleLines - 1 > electricScroll * 2\\n\\t\\t\\t? electricScroll : 0); \\n\\t\\tif(visibleLines == 0)\\n\\t\\t{\\n\\t\\t\\tsetFirstPhysicalLine(line,_electricScroll);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\t\\tint firstLine = getFirstLine();\\n\\t\\tint screenLine = chunkCache.getScreenLineOfOffset(line,offset);\\n\\t\\tint visibleLines = getVisibleLines();\\n\\t\\tif(screenLine == -1)\\n\\t\\t{\\n\\t\\t\\tChunkCache.LineInfo[] infos = chunkCache\\n\\t\\t\\t\\t.getLineInfosForPhysicalLine(line);\\n\\t\\t\\tint subregion = chunkCache.getSubregionOfOffset(\\n\\t\\t\\t\\toffset,infos);\\n\\t\\t\\tint prevLine = displayManager.getPrevVisibleLine(getFirstPhysicalLine());\\n\\t\\t\\tint nextLine = displayManager.getNextVisibleLine(getLastPhysicalLine());\\n\\t\\t\\tif(line == prevLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFirstPhysicalLine(prevLine,subregion\\n\\t\\t\\t\\t\\t- _electricScroll);\\n\\t\\t\\t}\\n\\t\\t\\telse if(line == nextLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFirstPhysicalLine(nextLine,\\n\\t\\t\\t\\t\\tsubregion + electricScroll\\n\\t\\t\\t\\t\\t- visibleLines\\n\\t\\t\\t\\t\\t+ (lastLinePartial ? 2 : 1));\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFirstPhysicalLine(line,subregion\\n\\t\\t\\t\\t\\t- visibleLines / 2);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(screenLine < _electricScroll)\\n\\t\\t{\\n\\t\\t\\tsetFirstLine(getFirstLine() - _electricScroll + screenLine);\\n\\t\\t}\\n\\t\\telse if(screenLine > visibleLines - _electricScroll\\n\\t\\t\\t- (lastLinePartial ? 2 : 1))\\n\\t\\t{\\n\\t\\t\\tsetFirstLine(getFirstLine() + _electricScroll - visibleLines + screenLine + (lastLinePartial ? 2 : 1));\\n\\t\\t} \\n\\t\\t\\t\\tif(!displayManager.isLineVisible(line))\\n\\t\\t\\treturn;\\n\\t\\tPoint point = offsetToXY(line,offset,returnValue);\\n\\t\\tif(point == null)\\n\\t\\t\\tLog.log(Log.ERROR,this,\\\"BUG: screenLine=\\\" + screenLine\\n\\t\\t\\t\\t+ \\\",visibleLines=\\\" + visibleLines\\n\\t\\t\\t\\t+ \\\",physicalLine=\\\" + line\\n\\t\\t\\t\\t+ \\\",firstPhysicalLine=\\\" + getFirstPhysicalLine()\\n\\t\\t\\t\\t+ \\\",lastPhysicalLine=\\\" + getLastPhysicalLine());\\n\\t\\tpoint.x += extraEndVirt;\\n\\t\\tif(point.x < 0)\\n\\t\\t{\\n\\t\\t\\tsetHorizontalOffset(horizontalOffset\\n\\t\\t\\t\\t- point.x + charWidth + 5);\\n\\t\\t}\\n\\t\\telse if(point.x >= painter.getWidth() - charWidth - 5)\\n\\t\\t{\\n\\t\\t\\tsetHorizontalOffset(horizontalOffset +\\n\\t\\t\\t\\t(painter.getWidth() - point.x)\\n\\t\\t\\t\\t- charWidth - 5);\\n\\t\\t} \\t} \\n\\tpublic final void addScrollListener(ScrollListener listener)\\n\\t{\\n\\t\\tlistenerList.add(ScrollListener.class,listener);\\n\\t} \\n\\tpublic final void removeScrollListener(ScrollListener listener)\\n\\t{\\n\\t\\tlistenerList.remove(ScrollListener.class,listener);\\n\\t} \\n\\tpublic int getPhysicalLineOfScreenLine(int screenLine)\\n\\t{\\n\\t\\treturn chunkCache.getLineInfo(screenLine).physicalLine;\\n\\t} \\n\\tpublic int getScreenLineOfOffset(int offset)\\n\\t{\\n\\t\\tint line = buffer.getLineOfOffset(offset);\\n\\t\\toffset -= buffer.getLineStartOffset(line);\\n\\t\\treturn chunkCache.getScreenLineOfOffset(line,offset);\\n\\t} \\n\\tpublic int getScreenLineStartOffset(int line)\\n\\t{\\n\\t\\tChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);\\n\\t\\tif(lineInfo.physicalLine == -1)\\n\\t\\t\\treturn -1;\\n\\t\\treturn buffer.getLineStartOffset(lineInfo.physicalLine)\\n\\t\\t\\t+ lineInfo.offset;\\n\\t} \\n\\tpublic int getScreenLineEndOffset(int line)\\n\\t{\\n\\t\\tChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);\\n\\t\\tif(lineInfo.physicalLine == -1)\\n\\t\\t\\treturn -1;\\n\\t\\treturn buffer.getLineStartOffset(lineInfo.physicalLine)\\n\\t\\t\\t+ lineInfo.offset + lineInfo.length;\\n\\t} \\n\\tpublic int xyToOffset(int x, int y)\\n\\t{\\n\\t\\treturn xyToOffset(x,y,true);\\n\\t} \\n\\tpublic int xyToOffset(int x, int y, boolean round)\\n\\t{\\n\\t\\tFontMetrics fm = painter.getFontMetrics();\\n\\t\\tint height = fm.getHeight();\\n\\t\\tint line = y / height;\\n\\t\\tif(line < 0 || line >= visibleLines)\\n\\t\\t\\treturn -1;\\n\\t\\treturn xToScreenLineOffset(line,x,round);\\n\\t} \\n\\tpublic int xToScreenLineOffset(int screenLine, int x, boolean round)\\n\\t{\\n\\t\\tChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(screenLine);\\n\\t\\tif(lineInfo.physicalLine == -1)\\n\\t\\t{\\n\\t\\t\\treturn getLineEndOffset(displayManager\\n\\t\\t\\t\\t.getLastVisibleLine()) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint offset = Chunk.xToOffset(lineInfo.chunks,\\n\\t\\t\\t\\tx - horizontalOffset,round);\\n\\t\\t\\tif(offset == -1 || offset == lineInfo.offset + lineInfo.length)\\n\\t\\t\\t\\toffset = lineInfo.offset + lineInfo.length - 1;\\n\\t\\t\\treturn getLineStartOffset(lineInfo.physicalLine) + offset;\\n\\t\\t}\\n\\t} \\n\\tpublic Point offsetToXY(int offset)\\n\\t{\\n\\t\\tint line = buffer.getLineOfOffset(offset);\\n\\t\\toffset -= buffer.getLineStartOffset(line);\\n\\t\\tPoint retVal = new Point();\\n\\t\\treturn offsetToXY(line,offset,retVal);\\n\\t} \\n\\tpublic Point offsetToXY(int line, int offset, Point retVal)\\n\\t{\\n\\t\\tint screenLine = chunkCache.getScreenLineOfOffset(line,offset);\\n\\t\\tif(screenLine == -1)\\n\\t\\t\\treturn null;\\n\\t\\tFontMetrics fm = painter.getFontMetrics();\\n\\t\\tretVal.y = screenLine * fm.getHeight();\\n\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(screenLine);\\n\\t\\tretVal.x = (int)(horizontalOffset + Chunk.offsetToX(\\n\\t\\t\\tinfo.chunks,offset));\\n\\t\\treturn retVal;\\n\\t} \\n\\tpublic void invalidateScreenLineRange(int start, int end)\\n\\t{\\n\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\treturn;\\n\\t\\tif(start > end)\\n\\t\\t{\\n\\t\\t\\tint tmp = end;\\n\\t\\t\\tend = start;\\n\\t\\t\\tstart = tmp;\\n\\t\\t}\\n\\t\\tif(chunkCache.needFullRepaint())\\n\\t\\t\\tend = visibleLines;\\n\\t\\tFontMetrics fm = painter.getFontMetrics();\\n\\t\\tint y = start * fm.getHeight();\\n\\t\\tint height = (end - start + 1) * fm.getHeight();\\n\\t\\tpainter.repaint(0,y,painter.getWidth(),height);\\n\\t\\tgutter.repaint(0,y,gutter.getWidth(),height);\\n\\t} \\n\\tpublic void invalidateLine(int line)\\n\\t{\\n\\t\\tif(!isShowing()\\n\\t\\t\\t|| !buffer.isLoaded()\\n\\t\\t\\t|| line < getFirstPhysicalLine()\\n\\t\\t\\t|| line > physLastLine\\n\\t\\t\\t|| !displayManager.isLineVisible(line))\\n\\t\\t\\treturn;\\n\\t\\tint startLine = -1;\\n\\t\\tint endLine = -1;\\n\\t\\tfor(int i = 0; i < visibleLines; i++)\\n\\t\\t{\\n\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(i);\\n\\t\\t\\tif((info.physicalLine >= line || info.physicalLine == -1)\\n\\t\\t\\t\\t&& startLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstartLine = i;\\n\\t\\t\\t}\\n\\t\\t\\tif((info.physicalLine >= line && info.lastSubregion)\\n\\t\\t\\t\\t|| info.physicalLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tendLine = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(chunkCache.needFullRepaint() || endLine == -1)\\n\\t\\t\\tendLine = visibleLines;\\n\\t\\tinvalidateScreenLineRange(startLine,endLine);\\n\\t} \\n\\tpublic void invalidateLineRange(int start, int end)\\n\\t{\\n\\t\\tif(!isShowing() || !buffer.isLoaded())\\n\\t\\t\\treturn;\\n\\t\\tif(end < start)\\n\\t\\t{\\n\\t\\t\\tint tmp = end;\\n\\t\\t\\tend = start;\\n\\t\\t\\tstart = tmp;\\n\\t\\t}\\n\\t\\tif(end < getFirstPhysicalLine() || start > getLastPhysicalLine())\\n\\t\\t\\treturn;\\n\\t\\tint startScreenLine = -1;\\n\\t\\tint endScreenLine = -1;\\n\\t\\tfor(int i = 0; i < visibleLines; i++)\\n\\t\\t{\\n\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(i);\\n\\t\\t\\tif((info.physicalLine >= start || info.physicalLine == -1)\\n\\t\\t\\t\\t&& startScreenLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstartScreenLine = i;\\n\\t\\t\\t}\\n\\t\\t\\tif((info.physicalLine >= end && info.lastSubregion)\\n\\t\\t\\t\\t|| info.physicalLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tendScreenLine = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(startScreenLine == -1)\\n\\t\\t\\tstartScreenLine = 0;\\n\\t\\tif(chunkCache.needFullRepaint() || endScreenLine == -1)\\n\\t\\t\\tendScreenLine = visibleLines;\\n\\t\\tinvalidateScreenLineRange(startScreenLine,endScreenLine);\\n\\t} \\n\\tpublic void invalidateSelectedLines()\\n\\t{\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tinvalidateLineRange(s.startLine,s.endLine);\\n\\t\\t}\\n\\t} \\n\\tpublic final int getBufferLength()\\n\\t{\\n\\t\\treturn buffer.getLength();\\n\\t} \\n\\tpublic final int getLineCount()\\n\\t{\\n\\t\\treturn buffer.getLineCount();\\n\\t} \\n\\tpublic final int getLineOfOffset(int offset)\\n\\t{\\n\\t\\treturn buffer.getLineOfOffset(offset);\\n\\t} \\n\\tpublic int getLineStartOffset(int line)\\n\\t{\\n\\t\\treturn buffer.getLineStartOffset(line);\\n\\t} \\n\\tpublic int getLineEndOffset(int line)\\n\\t{\\n\\t\\treturn buffer.getLineEndOffset(line);\\n\\t} \\n\\tpublic int getLineLength(int line)\\n\\t{\\n\\t\\treturn buffer.getLineLength(line);\\n\\t} \\n\\tpublic final String getText(int start, int len)\\n\\t{\\n\\t\\treturn buffer.getText(start,len);\\n\\t} \\n\\tpublic final void getText(int start, int len, Segment segment)\\n\\t{\\n\\t\\tbuffer.getText(start,len,segment);\\n\\t} \\n\\tpublic final String getLineText(int lineIndex)\\n\\t{\\n\\t\\treturn buffer.getLineText(lineIndex);\\n\\t} \\n\\tpublic final void getLineText(int lineIndex, Segment segment)\\n\\t{\\n\\t\\tbuffer.getLineText(lineIndex,segment);\\n\\t} \\n\\tpublic String getText()\\n\\t{\\n\\t\\treturn buffer.getText(0,buffer.getLength());\\n\\t} \\n\\tpublic void setText(String text)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tbuffer.remove(0,buffer.getLength());\\n\\t\\t\\tbuffer.insert(0,text);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic final void selectAll()\\n\\t{\\n\\t\\tsetSelection(new Selection.Range(0,buffer.getLength()));\\n\\t\\tmoveCaretPosition(buffer.getLength(),true);\\n\\t} \\n\\tpublic void selectLine()\\n\\t{\\n\\t\\tint caretLine = getCaretLine();\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine) - 1;\\n\\t\\tSelection s = new Selection.Range(start,end);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(end);\\n\\t} \\n\\tpublic void selectParagraph()\\n\\t{\\n\\t\\tint caretLine = getCaretLine();\\n\\t\\tif(getLineLength(caretLine) == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint start = caretLine;\\n\\t\\tint end = caretLine;\\n\\t\\twhile(start >= 0)\\n\\t\\t{\\n\\t\\t\\tif(getLineLength(start) == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\telse\\n\\t\\t\\t\\tstart--;\\n\\t\\t}\\n\\t\\twhile(end < getLineCount())\\n\\t\\t{\\n\\t\\t\\tif(getLineLength(end) == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\telse\\n\\t\\t\\t\\tend++;\\n\\t\\t}\\n\\t\\tint selectionStart = getLineStartOffset(start + 1);\\n\\t\\tint selectionEnd = getLineEndOffset(end - 1) - 1;\\n\\t\\tSelection s = new Selection.Range(selectionStart,selectionEnd);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(selectionEnd);\\n\\t} \\n\\tpublic void selectWord()\\n\\t{\\n\\t\\tint line = getCaretLine();\\n\\t\\tint lineStart = getLineStartOffset(line);\\n\\t\\tint offset = getCaretPosition() - lineStart;\\n\\t\\tif(getLineLength(line) == 0)\\n\\t\\t\\treturn;\\n\\t\\tString lineText = getLineText(line);\\n\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\tif(offset == getLineLength(line))\\n\\t\\t\\toffset--;\\n\\t\\tint wordStart = TextUtilities.findWordStart(lineText,offset,noWordSep);\\n\\t\\tint wordEnd = TextUtilities.findWordEnd(lineText,offset+1,noWordSep);\\n\\t\\tSelection s = new Selection.Range(lineStart + wordStart,\\n\\t\\t\\tlineStart + wordEnd);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(lineStart + wordEnd);\\n\\t} \\n\\tpublic Selection selectToMatchingBracket(int position,\\n\\t\\tboolean quickCopy)\\n\\t{\\n\\t\\tint positionLine = buffer.getLineOfOffset(position);\\n\\t\\tint lineOffset = position - buffer.getLineStartOffset(positionLine);\\n\\t\\tif(getLineLength(positionLine) != 0)\\n\\t\\t{\\n\\t\\t\\tint bracket = TextUtilities.findMatchingBracket(buffer,\\n\\t\\t\\t\\tpositionLine,Math.max(0,lineOffset - 1));\\n\\t\\t\\tif(bracket != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s;\\n\\t\\t\\t\\tif(bracket < position)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!quickCopy)\\n\\t\\t\\t\\t\\t\\tmoveCaretPosition(position,false);\\n\\t\\t\\t\\t\\ts = new Selection.Range(bracket,position);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!quickCopy)\\n\\t\\t\\t\\t\\t\\tmoveCaretPosition(bracket + 1,false);\\n\\t\\t\\t\\t\\ts = new Selection.Range(position - 1,bracket + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!multi && !quickCopy)\\n\\t\\t\\t\\t\\tselectNone();\\n\\t\\t\\t\\taddToSelection(s);\\n\\t\\t\\t\\treturn s;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic void selectToMatchingBracket()\\n\\t{\\n\\t\\tselectToMatchingBracket(caret,false);\\n\\t} \\n\\tpublic void selectBlock()\\n\\t{\\n\\t\\tString openBrackets = \\\"([{\\\";\\n\\t\\tString closeBrackets = \\\")]}\\\";\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint start, end;\\n\\t\\tif(s == null)\\n\\t\\t\\tstart = end = caret;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstart = s.start;\\n\\t\\t\\tend = s.end;\\n\\t\\t}\\n\\t\\tString text = getText(0,buffer.getLength());\\n\\t\\t\\t\\tint count = 1;\\n\\t\\tchar openBracket = '\\\\0';\\n\\t\\tchar closeBracket = '\\\\0';\\n\\t\\t\\t\\tif(start == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\nbackward_scan:\\twhile(--start > 0)\\n\\t\\t{\\n\\t\\t\\tchar c = text.charAt(start);\\n\\t\\t\\tint index = openBrackets.indexOf(c);\\n\\t\\t\\tif(index != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(--count == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\topenBracket = c;\\n\\t\\t\\t\\t\\tcloseBracket = closeBrackets.charAt(index);\\n\\t\\t\\t\\t\\tbreak backward_scan;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(closeBrackets.indexOf(c) != -1)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\t\\t\\tcount = 1;\\n\\t\\t\\t\\tif(openBracket == '\\\\0')\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\nforward_scan:\\t\\tdo\\n\\t\\t\\t{\\n\\t\\t\\t\\tchar c = text.charAt(end);\\n\\t\\t\\t\\tif(c == closeBracket)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(--count == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend++;\\n\\t\\t\\t\\t\\t\\tbreak forward_scan;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(c == openBracket)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\twhile(++end < buffer.getLength());\\n\\t\\t}\\n\\t\\ts = new Selection.Range(start,end);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(end);\\n\\t} \\n\\tpublic boolean lineInStructureScope(int line)\\n\\t{\\n\\t\\tif(match == null)\\n\\t\\t\\treturn false;\\n\\t\\tif(match.startLine < caretLine)\\n\\t\\t\\treturn (line >= match.startLine && line <= caretLine);\\n\\t\\telse\\n\\t\\t\\treturn (line <= match.endLine && line >= caretLine);\\n\\t} \\n\\tpublic final void invertSelection()\\n\\t{\\n\\t\\tSelection[] newSelection = new Selection[selection.size() + 1];\\n\\t\\tint lastOffset = 0;\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tnewSelection[i] = new Selection.Range(lastOffset,\\n\\t\\t\\t\\ts.getStart());\\n\\t\\t\\tlastOffset = s.getEnd();\\n\\t\\t}\\n\\t\\tnewSelection[selection.size()] = new Selection.Range(\\n\\t\\t\\tlastOffset,buffer.getLength());\\n\\t\\tsetSelection(newSelection);\\n\\t} \\n\\tpublic int getSelectionCount()\\n\\t{\\n\\t\\treturn selection.size();\\n\\t} \\n\\tpublic Selection[] getSelection()\\n\\t{\\n\\t\\tSelection[] sel = new Selection[selection.size()];\\n\\t\\tselection.copyInto(sel);\\n\\t\\treturn sel;\\n\\t} \\n\\tpublic void selectNone()\\n\\t{\\n\\t\\tsetSelection((Selection)null);\\n\\t} \\n\\tpublic void setSelection(Selection[] selection)\\n\\t{\\n\\t\\t\\t\\tinvalidateSelectedLines();\\n\\t\\tthis.selection.removeAllElements();\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t\\t_addToSelection(selection[i]);\\n\\t\\t}\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void setSelection(Selection selection)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tthis.selection.removeAllElements();\\n\\t\\tif(selection != null)\\n\\t\\t\\t_addToSelection(selection);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void addToSelection(Selection[] selection)\\n\\t{\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t\\t_addToSelection(selection[i]);\\n\\t\\t}\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void addToSelection(Selection selection)\\n\\t{\\n\\t\\t_addToSelection(selection);\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic Selection getSelectionAtOffset(int offset)\\n\\t{\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\t\\tif(offset >= s.start && offset <= s.end)\\n\\t\\t\\t\\t\\treturn s;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic void removeFromSelection(Selection sel)\\n\\t{\\n\\t\\tselection.removeElement(sel);\\n\\t\\tinvalidateLineRange(sel.startLine,sel.endLine);\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void removeFromSelection(int offset)\\n\\t{\\n\\t\\tSelection sel = getSelectionAtOffset(offset);\\n\\t\\tif(sel == null)\\n\\t\\t\\treturn;\\n\\t\\tselection.removeElement(sel);\\n\\t\\tinvalidateLineRange(sel.startLine,sel.endLine);\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void resizeSelection(int offset, int end, int extraEndVirt,\\n\\t\\tboolean rect)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(offset);\\n\\t\\tif(s != null)\\n\\t\\t{\\n\\t\\t\\tinvalidateLineRange(s.startLine,s.endLine);\\n\\t\\t\\tselection.removeElement(s);\\n\\t\\t}\\n\\t\\tboolean reversed = false;\\n\\t\\tif(end < offset)\\n\\t\\t{\\n\\t\\t\\tint tmp = offset;\\n\\t\\t\\toffset = end;\\n\\t\\t\\tend = tmp;\\n\\t\\t\\treversed = true;\\n\\t\\t}\\n\\t\\tSelection newSel;\\n\\t\\tif(rect)\\n\\t\\t{\\n\\t\\t\\tSelection.Rect rectSel = new Selection.Rect(offset,end);\\n\\t\\t\\tif(reversed)\\n\\t\\t\\t\\trectSel.extraStartVirt = extraEndVirt;\\n\\t\\t\\telse\\n\\t\\t\\t\\trectSel.extraEndVirt = extraEndVirt;\\n\\t\\t\\tnewSel = rectSel;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tnewSel = new Selection.Range(offset,end);\\n\\t\\t_addToSelection(newSel);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void extendSelection(int offset, int end)\\n\\t{\\n\\t\\textendSelection(offset,end,0,0);\\n\\t} \\n\\tpublic void extendSelection(int offset, int end,\\n\\t\\tint extraStartVirt, int extraEndVirt)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(offset);\\n\\t\\tif(s != null)\\n\\t\\t{\\n\\t\\t\\tinvalidateLineRange(s.startLine,s.endLine);\\n\\t\\t\\tselection.removeElement(s);\\n\\t\\t\\tif(offset == s.start)\\n\\t\\t\\t{\\n\\t\\t\\t\\toffset = end;\\n\\t\\t\\t\\tend = s.end;\\n\\t\\t\\t}\\n\\t\\t\\telse if(offset == s.end)\\n\\t\\t\\t{\\n\\t\\t\\t\\toffset = s.start;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(end < offset)\\n\\t\\t{\\n\\t\\t\\tint tmp = end;\\n\\t\\t\\tend = offset;\\n\\t\\t\\toffset = tmp;\\n\\t\\t}\\n\\t\\tif(rectangularSelectionMode)\\n\\t\\t{\\n\\t\\t\\ts = new Selection.Rect(offset,end);\\n\\t\\t\\t((Selection.Rect)s).extraStartVirt = extraStartVirt;\\n\\t\\t\\t((Selection.Rect)s).extraEndVirt = extraEndVirt;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\ts = new Selection.Range(offset,end);\\n\\t\\t_addToSelection(s);\\n\\t\\tfireCaretEvent();\\n\\t\\tif(rectangularSelectionMode && extraEndVirt != 0)\\n\\t\\t{\\n\\t\\t\\tint line = getLineOfOffset(end);\\n\\t\\t\\tscrollTo(line,getLineLength(line) + extraEndVirt,false);\\n\\t\\t}\\n\\t} \\n\\tpublic String getSelectedText(Selection s)\\n\\t{\\n\\t\\tStringBuffer buf = new StringBuffer();\\n\\t\\ts.getText(buffer,buf);\\n\\t\\treturn buf.toString();\\n\\t} \\n\\tpublic String getSelectedText(String separator)\\n\\t{\\n\\t\\tif(selection.size() == 0)\\n\\t\\t\\treturn null;\\n\\t\\tStringBuffer buf = new StringBuffer();\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tif(i != 0)\\n\\t\\t\\t\\tbuf.append(separator);\\n\\t\\t\\t((Selection)selection.elementAt(i)).getText(buffer,buf);\\n\\t\\t}\\n\\t\\treturn buf.toString();\\n\\t} \\n\\tpublic String getSelectedText()\\n\\t{\\n\\t\\treturn getSelectedText(\\\"\\\\n\\\");\\n\\t} \\n\\tpublic void setSelectedText(Selection s, String selectedText)\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tthrow new InternalError(\\\"Text component\\\"\\n\\t\\t\\t\\t+ \\\" read only\\\");\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tmoveCaretPosition(s.setText(buffer,selectedText));\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\t\\t\\t\\t} \\n\\tpublic void setSelectedText(String selectedText)\\n\\t{\\n\\t\\tsetSelectedText(selectedText,true);\\n\\t} \\n\\tpublic void setSelectedText(String selectedText, boolean moveCaret)\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tthrow new InternalError(\\\"Text component\\\"\\n\\t\\t\\t\\t+ \\\" read only\\\");\\n\\t\\t}\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(selection.length == 0)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.insert(caret,selectedText);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tint newCaret = -1;\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnewCaret = selection[i].setText(buffer,selectedText);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(moveCaret)\\n\\t\\t\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic int[] getSelectedLines()\\n\\t{\\n\\t\\tif(selection.size() == 0)\\n\\t\\t\\treturn new int[] { caretLine };\\n\\t\\tInteger line;\\n\\t\\tSet set = new TreeSet();\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tint endLine = (s.end == getLineStartOffset(s.endLine)\\n\\t\\t\\t\\t? s.endLine - 1\\n\\t\\t\\t\\t: s.endLine);\\n\\t\\t\\tfor(int j = s.startLine; j <= endLine; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tline = new Integer(j);\\n\\t\\t\\t\\tset.add(line);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint[] returnValue = new int[set.size()];\\n\\t\\tint i = 0;\\n\\t\\tIterator iter = set.iterator();\\n\\t\\twhile(iter.hasNext())\\n\\t\\t{\\n\\t\\t\\tline = (Integer)iter.next();\\n\\t\\t\\treturnValue[i++] = line.intValue();\\n\\t\\t}\\n\\t\\treturn returnValue;\\n\\t} \\n\\tpublic void showSelectLineRangeDialog()\\n\\t{\\n\\t\\tnew SelectLineRange(view);\\n\\t} \\n\\tpublic void addStructureMatcher(StructureMatcher matcher)\\n\\t{\\n\\t\\tstructureMatchers.add(matcher);\\n\\t} \\n\\tpublic void removeStructureMatcher(StructureMatcher matcher)\\n\\t{\\n\\t\\tstructureMatchers.remove(matcher);\\n\\t} \\n\\tpublic StructureMatcher.Match getStructureMatch()\\n\\t{\\n\\t\\treturn match;\\n\\t} \\n\\tpublic final void blinkCaret()\\n\\t{\\n\\t\\tif(caretBlinks)\\n\\t\\t{\\n\\t\\t\\tblink = !blink;\\n\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tblink = true;\\n\\t} \\n\\tpublic void centerCaret()\\n\\t{\\n\\t\\tint offset = getScreenLineStartOffset(visibleLines / 2);\\n\\t\\tif(offset == -1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t\\tsetCaretPosition(offset);\\n\\t} \\n\\tpublic void setCaretPosition(int newCaret)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tselection.removeAllElements();\\n\\t\\tmoveCaretPosition(newCaret,true);\\n\\t} \\n\\tpublic void setCaretPosition(int newCaret, boolean doElectricScroll)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tselection.removeAllElements();\\n\\t\\tmoveCaretPosition(newCaret,doElectricScroll);\\n\\t} \\n\\tpublic void moveCaretPosition(int newCaret)\\n\\t{\\n\\t\\tmoveCaretPosition(newCaret,true);\\n\\t} \\n\\tpublic void moveCaretPosition(int newCaret, boolean doElectricScroll)\\n\\t{\\n\\t\\tmoveCaretPosition(newCaret,doElectricScroll ? ELECTRIC_SCROLL\\n\\t\\t\\t: NORMAL_SCROLL);\\n\\t} \\n\\t\\tpublic static int NO_SCROLL = 0;\\n\\tpublic static int NORMAL_SCROLL = 1;\\n\\tpublic static int ELECTRIC_SCROLL = 2;\\n\\tpublic void moveCaretPosition(int newCaret, int scrollMode)\\n\\t{\\n\\t\\tif(newCaret < 0 || newCaret > buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tthrow new IllegalArgumentException(\\\"caret out of bounds: \\\"\\n\\t\\t\\t\\t+ newCaret);\\n\\t\\t}\\n\\t\\tif(match != null)\\n\\t\\t{\\n\\t\\t\\tif(caretLine < match.startLine)\\n\\t\\t\\t\\tinvalidateLineRange(caretLine,match.endLine);\\n\\t\\t\\telse\\n\\t\\t\\t\\tinvalidateLineRange(match.startLine,caretLine);\\n\\t\\t\\tmatch = null;\\n\\t\\t}\\n\\t\\tif(caret == newCaret)\\n\\t\\t{\\n\\t\\t\\tif(scrollMode == NORMAL_SCROLL)\\n\\t\\t\\t\\tfinishCaretUpdate(false,false);\\n\\t\\t\\telse if(scrollMode == ELECTRIC_SCROLL)\\n\\t\\t\\t\\tfinishCaretUpdate(true,false);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint newCaretLine = getLineOfOffset(newCaret);\\n\\t\\t\\tmagicCaret = -1;\\n\\t\\t\\tif(!displayManager.isLineVisible(newCaretLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(newCaretLine < displayManager.getFirstVisibleLine()\\n\\t\\t\\t\\t\\t|| newCaretLine > displayManager.getLastVisibleLine())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint collapseFolds = buffer.getIntegerProperty(\\n\\t\\t\\t\\t\\t\\t\\\"collapseFolds\\\",0);\\n\\t\\t\\t\\t\\tif(collapseFolds != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdisplayManager.expandFolds(collapseFolds);\\n\\t\\t\\t\\t\\t\\tdisplayManager.expandFold(newCaretLine,false);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tdisplayManager.expandAllFolds();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tdisplayManager.expandFold(newCaretLine,false);\\n\\t\\t\\t}\\n\\t\\t\\tif(caretLine == newCaretLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caretScreenLine != -1)\\n\\t\\t\\t\\t\\tinvalidateScreenLineRange(caretScreenLine,caretScreenLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint newCaretScreenLine = chunkCache.getScreenLineOfOffset(newCaretLine,\\n\\t\\t\\t\\t\\tnewCaret - buffer.getLineStartOffset(newCaretLine));\\n\\t\\t\\t\\tif(caretScreenLine == -1)\\n\\t\\t\\t\\t\\tinvalidateScreenLineRange(newCaretScreenLine,newCaretScreenLine);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tinvalidateScreenLineRange(caretScreenLine,newCaretScreenLine);\\n\\t\\t\\t\\tcaretScreenLine = newCaretScreenLine;\\n\\t\\t\\t}\\n\\t\\t\\tcaret = newCaret;\\n\\t\\t\\tcaretLine = newCaretLine;\\n\\t\\t\\tif(scrollMode == NORMAL_SCROLL)\\n\\t\\t\\t\\tfinishCaretUpdate(false,true);\\n\\t\\t\\telse if(scrollMode == ELECTRIC_SCROLL)\\n\\t\\t\\t\\tfinishCaretUpdate(true,true);\\n\\t\\t}\\n\\t} \\n\\tpublic int getCaretPosition()\\n\\t{\\n\\t\\treturn caret;\\n\\t} \\n\\tpublic int getCaretLine()\\n\\t{\\n\\t\\treturn caretLine;\\n\\t} \\n\\tpublic int getMagicCaretPosition()\\n\\t{\\n\\t\\tif(magicCaret == -1)\\n\\t\\t{\\n\\t\\t\\tmagicCaret = chunkCache.subregionOffsetToX(\\n\\t\\t\\t\\tcaretLine,caret - getLineStartOffset(caretLine));\\n\\t\\t}\\n\\t\\treturn magicCaret;\\n\\t} \\n\\tpublic void setMagicCaretPosition(int magicCaret)\\n\\t{\\n\\t\\tthis.magicCaret = magicCaret;\\n\\t} \\n\\tpublic final void addCaretListener(CaretListener listener)\\n\\t{\\n\\t\\tlistenerList.add(CaretListener.class,listener);\\n\\t} \\n\\tpublic final void removeCaretListener(CaretListener listener)\\n\\t{\\n\\t\\tlistenerList.remove(CaretListener.class,listener);\\n\\t} \\n\\tpublic void goToNextBracket(boolean select)\\n\\t{\\n\\t\\tString text = getText(caret,buffer.getLength() - caret - 1);\\n\\t\\tint newCaret = -1;\\nloop:\\t\\tfor(int i = 0; i < text.length(); i++)\\n\\t\\t{\\n\\t\\t\\tswitch(text.charAt(i))\\n\\t\\t\\t{\\n\\t\\t\\tcase ')': case ']': case '}':\\n\\t\\t\\t\\tnewCaret = caret + i + 1;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(newCaret == -1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(select)\\n\\t\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\t\\telse if(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t}\\n\\t} \\n\\tpublic void goToNextCharacter(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(!select && s instanceof Selection.Range)\\n\\t\\t{\\n\\t\\t\\tif(multi)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caret != s.end)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmoveCaretPosition(s.end);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetCaretPosition(s.end);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint extraStartVirt, extraEndVirt;\\n\\t\\tif(s instanceof Selection.Rect)\\n\\t\\t{\\n\\t\\t\\textraStartVirt = ((Selection.Rect)s).extraStartVirt;\\n\\t\\t\\textraEndVirt = ((Selection.Rect)s).extraEndVirt;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\textraStartVirt = 0;\\n\\t\\t\\textraEndVirt = 0;\\n\\t\\t}\\n\\t\\tint newCaret = caret;\\n\\t\\tif(select && caret == buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tif(rectangularSelectionMode || s instanceof Selection.Rect)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caret == s.start)\\n\\t\\t\\t\\t\\textraStartVirt++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\textraEndVirt++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(caret == getLineEndOffset(caretLine) - 1)\\n\\t\\t{\\n\\t\\t\\tif(rectangularSelectionMode || s instanceof Selection.Rect)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caret == s.start)\\n\\t\\t\\t\\t\\textraStartVirt++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\textraEndVirt++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint line = displayManager.getNextVisibleLine(caretLine);\\n\\t\\t\\t\\tif(line == -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tnewCaret = getLineStartOffset(line);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tnewCaret = caret + 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret,extraStartVirt,extraEndVirt);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToNextLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tboolean rectSelect = (s == null ? rectangularSelectionMode\\n\\t\\t\\t: s instanceof Selection.Rect);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = chunkCache.getBelowPosition(caretLine,\\n\\t\\t\\tcaret - buffer.getLineStartOffset(caretLine),magic + 1,\\n\\t\\t\\trectSelect && select);\\n\\t\\tif(newCaret == -1)\\n\\t\\t{\\n\\t\\t\\tint end = getLineEndOffset(caretLine) - 1;\\n\\t\\t\\tif(caret == end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tnewCaret = end;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t{\\n\\t\\t\\tRectParams params = getRectParams(caret,newCaret);\\n\\t\\t\\tint extraStartVirt;\\n\\t\\t\\tint extraEndVirt;\\n\\t\\t\\tif(params == null)\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = 0;\\n\\t\\t\\t\\textraEndVirt = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = params.extraStartVirt;\\n\\t\\t\\t\\textraEndVirt = params.extraEndVirt;\\n\\t\\t\\t\\tnewCaret = params.newCaret;\\n\\t\\t\\t}\\n\\t\\t\\textendSelection(caret,newCaret,extraStartVirt,extraEndVirt);\\n\\t\\t}\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToNextMarker(boolean select)\\n\\t{\\n\\t\\tVector markers = buffer.getMarkers();\\n\\t\\tif(markers.size() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tMarker marker = null;\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker _marker = (Marker)markers.get(i);\\n\\t\\t\\tif(_marker.getPosition() > caret)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmarker = _marker;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(marker == null)\\n\\t\\t\\tmarker = (Marker)markers.get(0);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,marker.getPosition());\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(marker.getPosition());\\n\\t} \\n\\tpublic void goToNextPage(boolean select)\\n\\t{\\n\\t\\tscrollToCaret(false);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint caretScreenLine = getScreenLineOfOffset(caret);\\n\\t\\tscrollDownPage();\\n\\t\\tint newCaret = xToScreenLineOffset(caretScreenLine,magic,true);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret,false);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToNextParagraph(boolean select)\\n\\t{\\n\\t\\tint lineNo = getCaretLine();\\n\\t\\tint newCaret = getBufferLength();\\n\\t\\tboolean foundBlank = false;\\nloop:\\t\\tfor(int i = lineNo + 1; i < getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tif(!displayManager.isLineVisible(i))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif(foundBlank)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnewCaret = getLineStartOffset(i);\\n\\t\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfoundBlank = true;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToNextWord(boolean select)\\n\\t{\\n\\t\\tgoToNextWord(select,false);\\n\\t} \\n\\tpublic void goToNextWord(boolean select, boolean stdNextPrevWord)\\n\\t{\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint newCaret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(newCaret == lineText.length())\\n\\t\\t{\\n\\t\\t\\tint nextLine = displayManager.getNextVisibleLine(caretLine);\\n\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret = getLineStartOffset(nextLine);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tnewCaret = TextUtilities.findWordEnd(lineText,newCaret + 1,\\n\\t\\t\\t\\tnoWordSep);\\n\\t\\t\\tif(stdNextPrevWord)\\n\\t\\t\\t{\\n\\t\\t\\t\\twhile((newCaret < lineText.length()) && Character.isWhitespace(lineText.charAt(newCaret)))\\n\\t\\t\\t\\t\\tnewCaret = TextUtilities.findWordEnd(lineText,newCaret + 1,\\n\\t\\t\\t\\t\\t\\tnoWordSep);\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret += lineStart;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToPrevBracket(boolean select)\\n\\t{\\n\\t\\tString text = getText(0,caret);\\n\\t\\tint newCaret = -1;\\nloop:\\t\\tfor(int i = getCaretPosition() - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tswitch(text.charAt(i))\\n\\t\\t\\t{\\n\\t\\t\\tcase '(': case '[': case '{':\\n\\t\\t\\t\\tnewCaret = i;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(newCaret == -1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(select)\\n\\t\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\t\\telse if(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t}\\n\\t} \\n\\tpublic void goToPrevCharacter(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(!select && s instanceof Selection.Range)\\n\\t\\t{\\n\\t\\t\\tif(multi)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caret != s.start)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmoveCaretPosition(s.start);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetCaretPosition(s.start);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint extraStartVirt = 0;\\n\\t\\tint extraEndVirt = 0;\\n\\t\\tint newCaret = caret;\\n\\t\\tif(select && caret == getLineEndOffset(caretLine) - 1)\\n\\t\\t{\\n\\t\\t\\tif(s instanceof Selection.Rect)\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = ((Selection.Rect)s).extraStartVirt;\\n\\t\\t\\t\\textraEndVirt = ((Selection.Rect)s).extraEndVirt;\\n\\t\\t\\t\\tif(caret == s.start)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(extraStartVirt == 0)\\n\\t\\t\\t\\t\\t\\tnewCaret = caret - 1;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\textraStartVirt--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(extraEndVirt == 0)\\n\\t\\t\\t\\t\\t\\tnewCaret = caret - 1;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\textraEndVirt--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tnewCaret = caret - 1;\\n\\t\\t}\\n\\t\\telse if(caret == getLineStartOffset(caretLine))\\n\\t\\t{\\n\\t\\t\\tint line = displayManager.getPrevVisibleLine(caretLine);\\n\\t\\t\\tif(line == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret = getLineEndOffset(line) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tnewCaret = caret - 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret,extraStartVirt,extraEndVirt);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToPrevLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tboolean rectSelect = (s == null ? rectangularSelectionMode\\n\\t\\t\\t: s instanceof Selection.Rect);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = chunkCache.getAbovePosition(caretLine,\\n\\t\\t\\tcaret - buffer.getLineStartOffset(caretLine),magic + 1,\\n\\t\\t\\trectSelect && select);\\n\\t\\tif(newCaret == -1)\\n\\t\\t{\\n\\t\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\t\\tif(caret == start)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tnewCaret = start;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t{\\n\\t\\t\\tRectParams params = getRectParams(caret,newCaret);\\n\\t\\t\\tint extraStartVirt;\\n\\t\\t\\tint extraEndVirt;\\n\\t\\t\\tif(params == null)\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = 0;\\n\\t\\t\\t\\textraEndVirt = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = params.extraStartVirt;\\n\\t\\t\\t\\textraEndVirt = params.extraEndVirt;\\n\\t\\t\\t\\tnewCaret = params.newCaret;\\n\\t\\t\\t}\\n\\t\\t\\textendSelection(caret,newCaret,extraStartVirt,extraEndVirt);\\n\\t\\t}\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToPrevMarker(boolean select)\\n\\t{\\n\\t\\tVector markers = buffer.getMarkers();\\n\\t\\tif(markers.size() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tMarker marker = null;\\n\\t\\tfor(int i = markers.size() - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tMarker _marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tif(_marker.getPosition() < caret)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmarker = _marker;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(marker == null)\\n\\t\\t\\tmarker = (Marker)markers.get(markers.size() - 1);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,marker.getPosition());\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(marker.getPosition());\\n\\t} \\n\\tpublic void goToPrevPage(boolean select)\\n\\t{\\n\\t\\tscrollToCaret(false);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint caretScreenLine = getScreenLineOfOffset(caret);\\n\\t\\tscrollUpPage();\\n\\t\\tint newCaret = xToScreenLineOffset(caretScreenLine,magic,true);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret,false);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToPrevParagraph(boolean select)\\n\\t{\\n\\t\\tint lineNo = caretLine;\\n\\t\\tint newCaret = 0;\\n\\t\\tboolean foundBlank = false;\\nloop:\\t\\tfor(int i = lineNo - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(!displayManager.isLineVisible(i))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif(foundBlank)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnewCaret = getLineEndOffset(i) - 1;\\n\\t\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfoundBlank = true;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToPrevWord(boolean select)\\n\\t{\\n\\t\\tgoToPrevWord(select,false);\\n\\t} \\n\\tpublic void goToPrevWord(boolean select, boolean stdNextPrevWord)\\n\\t{\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint newCaret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(newCaret == 0)\\n\\t\\t{\\n\\t\\t\\tif(lineStart == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint prevLine = displayManager.getPrevVisibleLine(caretLine);\\n\\t\\t\\t\\tif(prevLine == -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnewCaret = getLineEndOffset(prevLine) - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tnewCaret = TextUtilities.findWordStart(lineText,newCaret - 1,\\n\\t\\t\\t\\tnoWordSep);\\n\\t\\t\\tif(stdNextPrevWord)\\n\\t\\t\\t{\\n\\t\\t\\t\\twhile((newCaret > 0) && Character.isWhitespace(lineText.charAt(newCaret)))\\n\\t\\t\\t\\t\\tnewCaret = TextUtilities.findWordStart(lineText,newCaret - 1,\\n\\t\\t\\t\\t\\t\\tnoWordSep);\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret += lineStart;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void smartHome(boolean select)\\n\\t{\\n\\t\\tMacros.Recorder recorder = view.getMacroRecorder();\\n\\t\\tswitch(view.getInputHandler().getLastActionCount())\\n\\t\\t{\\n\\t\\tcase 1:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToStartOfWhiteSpace(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToStartOfWhiteSpace(select);\\n\\t\\t\\tbreak;\\n\\t\\tcase 2:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToStartOfLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToStartOfLine(select);\\n\\t\\t\\tbreak;\\n\\t\\tdefault: \\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToFirstVisibleLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToFirstVisibleLine(select);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t} \\n\\tpublic void smartEnd(boolean select)\\n\\t{\\n\\t\\tMacros.Recorder recorder = view.getMacroRecorder();\\n\\t\\tswitch(view.getInputHandler().getLastActionCount())\\n\\t\\t{\\n\\t\\tcase 1:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToEndOfWhiteSpace(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToEndOfWhiteSpace(select);\\n\\t\\t\\tbreak;\\n\\t\\tcase 2:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToEndOfLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToEndOfLine(select);\\n\\t\\t\\tbreak;\\n\\t\\tdefault: \\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToLastVisibleLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToLastVisibleLine(select);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t} \\n\\tpublic void goToStartOfLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line = (select || s == null\\n\\t\\t\\t? caretLine : s.startLine);\\n\\t\\tint newCaret = getLineStartOffset(line);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToEndOfLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line = (select || s == null\\n\\t\\t\\t? caretLine : s.endLine);\\n\\t\\tint newCaret = getLineEndOffset(line) - 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t\\t\\t\\t\\t\\t} \\n\\tpublic void goToStartOfWhiteSpace(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line, offset;\\n\\t\\tif(select || s == null)\\n\\t\\t{\\n\\t\\t\\tline = caretLine;\\n\\t\\t\\toffset = caret - buffer.getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tline = s.startLine;\\n\\t\\t\\toffset = s.start - buffer.getLineStartOffset(line);\\n\\t\\t}\\n\\t\\tint firstIndent = chunkCache.getSubregionStartOffset(line,offset);\\n\\t\\tif(firstIndent == getLineStartOffset(line))\\n\\t\\t{\\n\\t\\t\\tfirstIndent = MiscUtilities.getLeadingWhiteSpace(getLineText(line));\\n\\t\\t\\tif(firstIndent == getLineLength(line))\\n\\t\\t\\t\\tfirstIndent = 0;\\n\\t\\t\\tfirstIndent += getLineStartOffset(line);\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,firstIndent);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(firstIndent);\\n\\t} \\n\\tpublic void goToEndOfWhiteSpace(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line, offset;\\n\\t\\tif(select || s == null)\\n\\t\\t{\\n\\t\\t\\tline = caretLine;\\n\\t\\t\\toffset = caret - getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tline = s.endLine;\\n\\t\\t\\toffset = s.end - getLineStartOffset(line);\\n\\t\\t}\\n\\t\\tint lastIndent = chunkCache.getSubregionEndOffset(line,offset);\\n\\t\\tif(lastIndent == getLineEndOffset(line))\\n\\t\\t{\\n\\t\\t\\tlastIndent = getLineLength(line) - MiscUtilities.getTrailingWhiteSpace(getLineText(line));\\n\\t\\t\\tif(lastIndent == 0)\\n\\t\\t\\t\\tlastIndent = getLineLength(line);\\n\\t\\t\\tlastIndent += getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlastIndent--;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,lastIndent);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(lastIndent);\\n\\t} \\n\\tpublic void goToFirstVisibleLine(boolean select)\\n\\t{\\n\\t\\tint firstVisibleLine = getFirstLine() == 0 ? 0 : electricScroll;\\n\\t\\tint firstVisible = getScreenLineStartOffset(firstVisibleLine);\\n\\t\\tif(firstVisible == -1)\\n\\t\\t{\\n\\t\\t\\tfirstVisible = getLineStartOffset(displayManager\\n\\t\\t\\t\\t.getFirstVisibleLine());\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,firstVisible);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(firstVisible);\\n\\t} \\n\\tpublic void goToLastVisibleLine(boolean select)\\n\\t{\\n\\t\\tint lastVisible;\\n\\t\\tif(getFirstLine() + visibleLines >=\\n\\t\\t\\tdisplayManager.getScrollLineCount())\\n\\t\\t{\\n\\t\\t\\tlastVisible = getLineEndOffset(displayManager\\n\\t\\t\\t\\t.getLastVisibleLine()) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlastVisible = getScreenLineEndOffset(visibleLines\\n\\t\\t\\t\\t- electricScroll - 1) - 1;\\n\\t\\t\\tif(lastVisible == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlastVisible = getLineEndOffset(displayManager\\n\\t\\t\\t\\t\\t.getLastVisibleLine()) - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,lastVisible);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(lastVisible);\\n\\t} \\n\\tpublic void goToBufferStart(boolean select)\\n\\t{\\n\\t\\tint start = buffer.getLineStartOffset(\\n\\t\\t\\tdisplayManager.getFirstVisibleLine());\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,start);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(start);\\n\\t} \\n\\tpublic void goToBufferEnd(boolean select)\\n\\t{\\n\\t\\tint end = buffer.getLineEndOffset(\\n\\t\\t\\tdisplayManager.getLastVisibleLine()) - 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,end);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(end);\\n\\t} \\n\\tpublic void goToMatchingBracket()\\n\\t{\\n\\t\\tif(getLineLength(caretLine) != 0)\\n\\t\\t{\\n\\t\\t\\tint dot = caret - getLineStartOffset(caretLine);\\n\\t\\t\\tint bracket = TextUtilities.findMatchingBracket(\\n\\t\\t\\t\\tbuffer,caretLine,Math.max(0,dot - 1));\\n\\t\\t\\tif(bracket != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\t\\tmoveCaretPosition(bracket + 1,false);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tgetToolkit().beep();\\n\\t} \\n\\tpublic void showGoToLineDialog()\\n\\t{\\n\\t\\tString line = GUIUtilities.input(view,\\\"goto-line\\\",null);\\n\\t\\tif(line == null)\\n\\t\\t\\treturn;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tint lineNumber = Integer.parseInt(line) - 1;\\n\\t\\t\\tsetCaretPosition(getLineStartOffset(lineNumber));\\n\\t\\t}\\n\\t\\tcatch(Exception e)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t}\\n\\t} \\n\\tpublic void userInput(char ch)\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(ch == ' ' && Abbrevs.getExpandOnInput()\\n\\t\\t\\t&& Abbrevs.expandAbbrev(view,false))\\n\\t\\t\\treturn;\\n\\t\\telse if(ch == '\\\\t')\\n\\t\\t{\\n\\t\\t\\tif(selection.size() == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection sel = (Selection)selection.elementAt(0);\\n\\t\\t\\t\\tif(sel.startLine == sel.endLine\\n\\t\\t\\t\\t\\t&& (sel.start != buffer.getLineStartOffset(sel.startLine)\\n\\t\\t\\t\\t\\t|| sel.end != buffer.getLineEndOffset(sel.startLine) - 1))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tinsertTab();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tshiftIndentRight();\\n\\t\\t\\t}\\n\\t\\t\\telse if(selection.size() != 0)\\n\\t\\t\\t\\tshiftIndentRight();\\n\\t\\t\\telse\\n\\t\\t\\t\\tinsertTab();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tboolean indent;\\n\\t\\t\\t\\t\\t\\tString indentOpenBrackets = (String)buffer\\n\\t\\t\\t\\t.getProperty(\\\"indentOpenBrackets\\\");\\n\\t\\t\\tString indentCloseBrackets = (String)buffer\\n\\t\\t\\t\\t.getProperty(\\\"indentCloseBrackets\\\");\\n\\t\\t\\tif((indentCloseBrackets != null\\n\\t\\t\\t\\t&& indentCloseBrackets.indexOf(ch) != -1)\\n\\t\\t\\t\\t|| (indentOpenBrackets != null\\n\\t\\t\\t\\t&& indentOpenBrackets.indexOf(ch) != -1))\\n\\t\\t\\t{\\n\\t\\t\\t\\tindent = true;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tindent = false;\\n\\t\\t\\t}\\n\\t\\t\\tString str = String.valueOf(ch);\\n\\t\\t\\tSelection[] selection = getSelection();\\n\\t\\t\\tif(selection.length != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\t\\tsetSelectedText(s,str);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(ch == ' ')\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(doWordWrap(true))\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tdoWordWrap(false);\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(overwrite || indent)\\n\\t\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tif(overwrite)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint caretLineEnd = getLineEndOffset(caretLine);\\n\\t\\t\\t\\t\\tif(caretLineEnd - caret > 1)\\n\\t\\t\\t\\t\\t\\tbuffer.remove(caret,1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbuffer.insert(caret,str);\\n\\t\\t\\t\\tif(indent)\\n\\t\\t\\t\\t\\tbuffer.indentLine(caretLine,true);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(overwrite || indent)\\n\\t\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic final boolean isOverwriteEnabled()\\n\\t{\\n\\t\\treturn overwrite;\\n\\t} \\n\\tpublic final void setOverwriteEnabled(boolean overwrite)\\n\\t{\\n\\t\\tblink = true;\\n\\t\\tcaretTimer.restart();\\n\\t\\tthis.overwrite = overwrite;\\n\\t\\tinvalidateLine(caretLine);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t\\tview.getStatus().updateMiscStatus();\\n\\t} \\n\\tpublic final void toggleOverwriteEnabled()\\n\\t{\\n\\t\\tsetOverwriteEnabled(!overwrite);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t{\\n\\t\\t\\tview.getStatus().setMessageAndClear(\\n\\t\\t\\t\\tjEdit.getProperty(\\\"view.status.overwrite-changed\\\",\\n\\t\\t\\t\\tnew Integer[] { new Integer(overwrite ? 1 : 0) }));\\n\\t\\t}\\n\\t} \\n\\tpublic void backspace()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() != 0)\\n\\t\\t\\tsetSelectedText(null);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(caret == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.remove(caret - 1,1);\\n\\t\\t}\\n\\t} \\n\\tpublic void backspaceWord()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() != 0)\\n\\t\\t{\\n\\t\\t\\tsetSelectedText(\\\"\\\");\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint _caret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(_caret == 0)\\n\\t\\t{\\n\\t\\t\\tif(lineStart == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t_caret--;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\t_caret = TextUtilities.findWordStart(lineText,_caret-1,noWordSep);\\n\\t\\t}\\n\\t\\tbuffer.remove(_caret + lineStart,\\n\\t\\t\\tcaret - (_caret + lineStart));\\n\\t} \\n\\tpublic void delete()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() != 0)\\n\\t\\t\\tsetSelectedText(null);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(caret == buffer.getLength())\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.remove(caret,1);\\n\\t\\t}\\n\\t} \\n\\tpublic void deleteToEndOfLine()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.remove(caret,getLineEndOffset(caretLine)\\n\\t\\t\\t- caret - 1);\\n\\t} \\n\\tpublic void deleteLine()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine);\\n\\t\\tint x = chunkCache.subregionOffsetToX(caretLine,caret - start);\\n\\t\\t\\t\\t\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tif(end > buffer.getLength())\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(start != 0)\\n\\t\\t\\t\\t\\tstart--;\\n\\t\\t\\t\\tend--;\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tbuffer.remove(start,end - start);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\tint lastLine = displayManager.getLastVisibleLine();\\n\\t\\tif(caretLine == lastLine)\\n\\t\\t{\\n\\t\\t\\tint offset = chunkCache.xToSubregionOffset(lastLine,0,x,true);\\n\\t\\t\\tsetCaretPosition(buffer.getLineStartOffset(lastLine)\\n\\t\\t\\t\\t+ offset);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint offset = chunkCache.xToSubregionOffset(caretLine,0,x,true);\\n\\t\\t\\tsetCaretPosition(start + offset);\\n\\t\\t}\\n\\t} \\n\\tpublic void deleteParagraph()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint start = 0, end = buffer.getLength();\\nloop:\\t\\tfor(int i = caretLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tstart = getLineStartOffset(i);\\n\\t\\t\\tbreak loop;\\n\\t\\t}\\nloop:\\t\\tfor(int i = caretLine + 1; i < getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tend = getLineEndOffset(i) - 1;\\n\\t\\t\\tbreak loop;\\n\\t\\t}\\n\\t\\tbuffer.remove(start,end - start);\\n\\t} \\n\\tpublic void deleteToStartOfLine()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.remove(getLineStartOffset(caretLine),\\n\\t\\t\\tcaret - getLineStartOffset(caretLine));\\n\\t} \\n\\tpublic void deleteWord()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() != 0)\\n\\t\\t{\\n\\t\\t\\tsetSelectedText(\\\"\\\");\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint _caret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(_caret == lineText.length())\\n\\t\\t{\\n\\t\\t\\tif(lineStart + _caret == buffer.getLength())\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t_caret++;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\t_caret = TextUtilities.findWordEnd(lineText,\\n\\t\\t\\t\\t_caret+1,noWordSep);\\n\\t\\t}\\n\\t\\tbuffer.remove(caret,(_caret + lineStart) - caret);\\n\\t} \\n\\tpublic final boolean isMultipleSelectionEnabled()\\n\\t{\\n\\t\\treturn multi;\\n\\t} \\n\\tpublic final void toggleMultipleSelectionEnabled()\\n\\t{\\n\\t\\tsetMultipleSelectionEnabled(!multi);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t{\\n\\t\\t\\tview.getStatus().setMessageAndClear(\\n\\t\\t\\t\\tjEdit.getProperty(\\\"view.status.multi-changed\\\",\\n\\t\\t\\t\\tnew Integer[] { new Integer(multi ? 1 : 0) }));\\n\\t\\t}\\n\\t} \\n\\tpublic final void setMultipleSelectionEnabled(boolean multi)\\n\\t{\\n\\t\\tthis.multi = multi;\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t\\tview.getStatus().updateMiscStatus();\\n\\t\\tpainter.repaint();\\n\\t} \\n\\tpublic final boolean isRectangularSelectionEnabled()\\n\\t{\\n\\t\\treturn rectangularSelectionMode;\\n\\t} \\n\\tpublic final void toggleRectangularSelectionEnabled()\\n\\t{\\n\\t\\tsetRectangularSelectionEnabled(!rectangularSelectionMode);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t{\\n\\t\\t\\tview.getStatus().setMessageAndClear(\\n\\t\\t\\t\\tjEdit.getProperty(\\\"view.status.rect-select-changed\\\",\\n\\t\\t\\t\\tnew Integer[] { new Integer(rectangularSelectionMode ? 1 : 0) }));\\n\\t\\t}\\n\\t} \\n\\tpublic final void setRectangularSelectionEnabled(boolean rectangularSelectionMode)\\n\\t{\\n\\t\\tthis.rectangularSelectionMode = rectangularSelectionMode;\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t\\tview.getStatus().updateMiscStatus();\\n\\t\\tpainter.repaint();\\n\\t} \\n\\tpublic void goToMarker(char shortcut, boolean select)\\n\\t{\\n\\t\\tMarker marker = buffer.getMarker(shortcut);\\n\\t\\tif(marker == null)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint pos = marker.getPosition();\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,pos);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(pos);\\n\\t} \\n\\tpublic void addMarker()\\n\\t{\\n\\t\\t\\t\\tSelection[] selection = getSelection();\\n\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\tif(s.startLine != s.endLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s.startLine != caretLine)\\n\\t\\t\\t\\t\\tbuffer.addMarker('\\\\0',s.start);\\n\\t\\t\\t}\\n\\t\\t\\tif(s.endLine != caretLine)\\n\\t\\t\\t\\tbuffer.addMarker('\\\\0',s.end);\\n\\t\\t}\\n\\t\\t\\t\\tbuffer.addOrRemoveMarker('\\\\0',caret);\\n\\t} \\n\\tpublic void swapMarkerAndCaret(char shortcut)\\n\\t{\\n\\t\\tMarker marker = buffer.getMarker(shortcut);\\n\\t\\tif(marker == null)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint caret = getCaretPosition();\\n\\t\\tsetCaretPosition(marker.getPosition());\\n\\t\\tbuffer.addMarker(shortcut,caret);\\n\\t} \\n\\tpublic void goToParentFold()\\n\\t{\\n\\t\\tint line = -1;\\n\\t\\tint level = buffer.getFoldLevel(caretLine);\\n\\t\\tfor(int i = caretLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(buffer.getFoldLevel(i) < level)\\n\\t\\t\\t{\\n\\t\\t\\t\\tline = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(line == -1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = buffer.getLineStartOffset(line)\\n\\t\\t\\t+ chunkCache.xToSubregionOffset(line,0,magic + 1,true);\\n\\t\\tif(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToNextFold(boolean select)\\n\\t{\\n\\t\\tint nextFold = -1;\\n\\t\\tfor(int i = caretLine + 1; i < buffer.getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tif(buffer.isFoldStart(i)\\n\\t\\t\\t\\t&& displayManager.isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\tnextFold = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(nextFold == -1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = buffer.getLineStartOffset(nextFold)\\n\\t\\t\\t+ chunkCache.xToSubregionOffset(nextFold,0,magic + 1,true);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToPrevFold(boolean select)\\n\\t{\\n\\t\\tint prevFold = -1;\\n\\t\\tfor(int i = caretLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(buffer.isFoldStart(i)\\n\\t\\t\\t\\t&& displayManager.isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\tprevFold = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(prevFold == -1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = buffer.getLineStartOffset(prevFold)\\n\\t\\t\\t+ chunkCache.xToSubregionOffset(prevFold,0,magic + 1,true);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void collapseFold()\\n\\t{\\n\\t\\tint x = chunkCache.subregionOffsetToX(caretLine,\\n\\t\\t\\tcaret - getLineStartOffset(caretLine));\\n\\t\\tdisplayManager.collapseFold(caretLine);\\n\\t\\tif(displayManager.isLineVisible(caretLine))\\n\\t\\t\\treturn;\\n\\t\\tint line = displayManager.getPrevVisibleLine(caretLine);\\n\\t\\tif(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(buffer.getLineStartOffset(line)\\n\\t\\t\\t+ chunkCache.xToSubregionOffset(line,0,x,true));\\n\\t} \\n\\tpublic void expandFold(boolean fully)\\n\\t{\\n\\t\\tint x = chunkCache.subregionOffsetToX(caretLine,\\n\\t\\t\\tcaret - getLineStartOffset(caretLine));\\n\\t\\tint line = displayManager.expandFold(caretLine,fully);\\n\\t\\tif(!fully && line != -1)\\n\\t\\t{\\n\\t\\t\\tif(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\tmoveCaretPosition(getLineStartOffset(line)\\n\\t\\t\\t\\t+ chunkCache.xToSubregionOffset(line,0,x,true));\\n\\t\\t}\\n\\t} \\n\\tpublic void selectFold()\\n\\t{\\n\\t\\tselectFold(caretLine);\\n\\t} \\n\\tpublic void selectFold(int line)\\n\\t{\\n\\t\\tint[] lines = buffer.getFoldAtLine(line);\\n\\t\\tint newCaret = getLineEndOffset(lines[1]) - 1;\\n\\t\\tSelection s = new Selection.Range(getLineStartOffset(lines[0]),newCaret);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void narrowToFold()\\n\\t{\\n\\t\\tint[] lines = buffer.getFoldAtLine(caretLine);\\n\\t\\tif(lines[0] == 0 && lines[1] == buffer.getLineCount() - 1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t\\tdisplayManager.narrow(lines[0],lines[1]);\\n\\t} \\n\\tpublic void narrowToSelection()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tSelection sel = (Selection)selection.elementAt(0);\\n\\t\\tdisplayManager.narrow(sel.getStartLine(),sel.getEndLine());\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic void addExplicitFold()\\n\\t{\\n\\t\\tif(!buffer.getStringProperty(\\\"folding\\\").equals(\\\"explicit\\\"))\\n\\t\\t{\\n\\t\\t\\tGUIUtilities.error(view,\\\"folding-not-explicit\\\",null);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tString lineComment = buffer.getContextSensitiveProperty(caret,\\\"lineComment\\\");\\n\\t\\tString commentStart = buffer.getContextSensitiveProperty(caret,\\\"commentStart\\\");\\n\\t\\tString commentEnd = buffer.getContextSensitiveProperty(caret,\\\"commentEnd\\\");\\n\\t\\tString start, end;\\n\\t\\tif(lineComment != null)\\n\\t\\t{\\n\\t\\t\\tstart = lineComment + \\\"{{{ \\\\n\\\";\\n\\t\\t\\tend = lineComment + \\\"}}}\\\";\\n\\t\\t}\\n\\t\\telse if(commentStart != null && commentEnd != null)\\n\\t\\t{\\n\\t\\t\\tstart = commentStart + \\\"{{{  \\\" + commentEnd + \\\"\\\\n\\\";\\n\\t\\t\\tend = commentStart + \\\"}}}\\\" + commentEnd;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstart = \\\"{{{ \\\\n\\\";\\n\\t\\t\\tend = \\\"}}}\\\";\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tif(selection.size() == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tString line = buffer.getLineText(caretLine);\\n\\t\\t\\t\\tString whitespace = line.substring(0,\\n\\t\\t\\t\\t\\tMiscUtilities.getLeadingWhiteSpace(line));\\n\\t\\t\\t\\tint loc = caret + start.length() - 1;\\n\\t\\t\\t\\tstart = start + whitespace;\\n\\t\\t\\t\\tbuffer.insert(caret,start);\\n\\t\\t\\t\\t\\t\\t\\t\\tbuffer.insert(caret,end);\\n\\t\\t\\t\\tmoveCaretPosition(loc,false);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint loc = -1;\\n\\t\\t\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\t\\t\\tString line = buffer.getLineText(s.startLine);\\n\\t\\t\\t\\t\\tString whitespace = line.substring(0,\\n\\t\\t\\t\\t\\t\\tMiscUtilities.getLeadingWhiteSpace(line));\\n\\t\\t\\t\\t\\tloc = s.start + start.length() - 1;\\n\\t\\t\\t\\t\\tbuffer.insert(s.start,start + whitespace);\\n\\t\\t\\t\\t\\tbuffer.insert(s.end,\\\" \\\" + end);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsetCaretPosition(loc,false);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void lineComment()\\n\\t{\\n\\t\\tString comment = buffer.getContextSensitiveProperty(caret,\\\"lineComment\\\");\\n\\t\\tif(!buffer.isEditable() || comment == null || comment.length() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tcomment = comment + ' ';\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tint[] lines = getSelectedLines();\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < lines.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tString text = getLineText(lines[i]);\\n\\t\\t\\t\\tbuffer.insert(getLineStartOffset(lines[i])\\n\\t\\t\\t\\t\\t+ MiscUtilities.getLeadingWhiteSpace(text),\\n\\t\\t\\t\\t\\tcomment);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic void rangeComment()\\n\\t{\\n\\t\\tString commentStart = buffer.getContextSensitiveProperty(caret,\\\"commentStart\\\");\\n\\t\\tString commentEnd = buffer.getContextSensitiveProperty(caret,\\\"commentEnd\\\");\\n\\t\\tif(!buffer.isEditable() || commentStart == null || commentEnd == null\\n\\t\\t\\t|| commentStart.length() == 0 || commentEnd.length() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tcommentStart = commentStart + ' ';\\n\\t\\tcommentEnd = ' ' + commentEnd;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tSelection[] selection = getSelection();\\n\\t\\t\\tif(selection.length == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint oldCaret = caret;\\n\\t\\t\\t\\tbuffer.insert(caret,commentStart);\\n\\t\\t\\t\\tbuffer.insert(caret,commentEnd);\\n\\t\\t\\t\\tsetCaretPosition(oldCaret + commentStart.length());\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tif(s instanceof Selection.Range)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbuffer.insert(s.start,commentStart);\\n\\t\\t\\t\\t\\tbuffer.insert(s.end,commentEnd);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(s instanceof Selection.Rect)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection.Rect rect = (Selection.Rect)s;\\n\\t\\t\\t\\t\\tint start = rect.getStartColumn(buffer);\\n\\t\\t\\t\\t\\tint end = rect.getEndColumn(buffer);\\n\\t\\t\\t\\t\\tfor(int j = s.startLine; j <= s.endLine; j++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.insertAtColumn(j,end,\\n\\t\\t\\t\\t\\t\\t\\tcommentEnd);\\n\\t\\t\\t\\t\\t\\tbuffer.insertAtColumn(j,start,\\n\\t\\t\\t\\t\\t\\t\\tcommentStart);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tselectNone();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void formatParagraph()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(maxLineLen <= 0)\\n\\t\\t{\\n\\t\\t\\tGUIUtilities.error(view,\\\"format-maxlinelen\\\",null);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(selection.length != 0)\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tsetSelectedText(s,TextUtilities.format(\\n\\t\\t\\t\\t\\tgetSelectedText(s),maxLineLen,\\n\\t\\t\\t\\t\\tbuffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint lineNo = getCaretLine();\\n\\t\\t\\tint start = 0, end = buffer.getLength();\\nloop:\\t\\t\\tfor(int i = lineNo - 1; i >= 0; i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstart = getLineEndOffset(i);\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\nloop:\\t\\t\\tfor(int i = lineNo + 1; i < getLineCount(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tend = getLineStartOffset(i) - 1;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tString text = buffer.getText(start,end - start);\\n\\t\\t\\t\\tbuffer.remove(start,end - start);\\n\\t\\t\\t\\tbuffer.insert(start,TextUtilities.format(\\n\\t\\t\\t\\t\\ttext,maxLineLen,buffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic void spacesToTabs()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tif(selection.length == 0)\\n\\t\\t{\\n\\t\\t\\tsetText(TextUtilities.spacesToTabs(\\n\\t\\t\\t\\tgetText(), buffer.getTabSize()));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tsetSelectedText(s,TextUtilities.spacesToTabs(\\n\\t\\t\\t\\t\\tgetSelectedText(s),buffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void tabsToSpaces()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tif(selection.length == 0)\\n\\t\\t{\\n\\t\\t\\tsetText(TextUtilities.tabsToSpaces(\\n\\t\\t\\t\\tgetText(), buffer.getTabSize()));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tsetSelectedText(s,TextUtilities.tabsToSpaces(\\n\\t\\t\\t\\t\\tgetSelectedText(s),buffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void toUpperCase()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable() || selection.length == 0)\\n                {\\n                \\tgetToolkit().beep();\\n                \\treturn;\\n                }\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\tsetSelectedText(s,getSelectedText(s).toUpperCase());\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void toLowerCase()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable() || selection.length == 0)\\n                {\\n                \\tgetToolkit().beep();\\n                \\treturn;\\n                }\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\tsetSelectedText(s,getSelectedText(s).toLowerCase());\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void removeTrailingWhiteSpace()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbuffer.removeTrailingWhiteSpace(getSelectedLines());\\n\\t\\t}\\n\\t} \\n\\t\\tpublic void insertEnterAndIndent()\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tsetSelectedText(\\\"\\\\n\\\");\\n\\t\\t\\t\\tbuffer.indentLine(caretLine,true);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tpublic void insertTabAndIndent()\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(selection.size() == 0)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tString text = buffer.getLineText(caretLine);\\n\\t\\t\\tint start = buffer.getLineStartOffset(caretLine);\\n\\t\\t\\tint whiteSpace = MiscUtilities.getLeadingWhiteSpace(text);\\n\\t\\t\\tif(caret - start <= whiteSpace\\n\\t\\t\\t\\t&& buffer.indentLine(caretLine,false))\\n\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tuserInput('\\\\t');\\n\\t} \\n\\tpublic void indentSelectedLines()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbuffer.indentLines(getSelectedLines());\\n\\t\\t\\tselectNone();\\n\\t\\t}\\n\\t} \\n\\tpublic void shiftIndentLeft()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbuffer.shiftIndentLeft(getSelectedLines());\\n\\t\\t}\\n\\t} \\n\\tpublic void shiftIndentRight()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t\\tbuffer.shiftIndentRight(getSelectedLines());\\n\\t} \\n\\tpublic void joinLines()\\n\\t{\\n\\t\\tint end = getLineEndOffset(caretLine);\\n\\t\\tif(end > buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.remove(end - 1,MiscUtilities.getLeadingWhiteSpace(\\n\\t\\t\\tbuffer.getLineText(caretLine + 1)) + 1);\\n\\t\\tsetCaretPosition(end - 1);\\n\\t} \\n\\tpublic void showWordCountDialog()\\n\\t{\\n\\t\\tString selection = getSelectedText();\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tdoWordCount(view,selection);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tdoWordCount(view,buffer.getText(0,buffer.getLength()));\\n\\t} \\n\\tpublic void addLeftOfScrollBar(Component comp)\\n\\t{\\n\\t\\tverticalBox.add(comp,verticalBox.getComponentCount() - 1);\\n\\t} \\n\\tpublic void removeLeftOfScrollBar(Component comp)\\n\\t{\\n\\t\\tverticalBox.remove(comp);\\n\\t} \\n\\tpublic void addNotify()\\n\\t{\\n\\t\\tsuper.addNotify();\\n\\t\\tToolTipManager.sharedInstance().registerComponent(painter);\\n\\t\\tToolTipManager.sharedInstance().registerComponent(gutter);\\n\\t\\tif(!bufferHandlerInstalled)\\n\\t\\t{\\n\\t\\t\\tbufferHandlerInstalled = true;\\n\\t\\t\\tbuffer.addBufferChangeListener(bufferHandler);\\n\\t\\t}\\n\\t\\trecalculateVisibleLines();\\n\\t\\tif(buffer.isLoaded())\\n\\t\\t\\trecalculateLastPhysicalLine();\\n\\t\\tpropertiesChanged();\\n\\t} \\n\\tpublic void removeNotify()\\n\\t{\\n\\t\\tsuper.removeNotify();\\n\\t\\tToolTipManager.sharedInstance().unregisterComponent(painter);\\n\\t\\tToolTipManager.sharedInstance().unregisterComponent(gutter);\\n\\t\\tif(focusedComponent == this)\\n\\t\\t\\tfocusedComponent = null;\\n\\t\\tif(bufferHandlerInstalled)\\n\\t\\t{\\n\\t\\t\\tbuffer.removeBufferChangeListener(bufferHandler);\\n\\t\\t\\tbufferHandlerInstalled = false;\\n\\t\\t}\\n\\t} \\n\\tpublic boolean getFocusTraversalKeysEnabled()\\n\\t{\\n\\t\\treturn false;\\n\\t} \\n\\tpublic boolean getFocusCycleRoot()\\n\\t{\\n\\t\\treturn true;\\n\\t} \\n\\t\\tpublic void processKeyEvent(KeyEvent evt)\\n\\t{\\n\\t\\tview.processKeyEvent(evt,true);\\n\\t\\tif(!evt.isConsumed())\\n\\t\\t\\tsuper.processKeyEvent(evt);\\n\\t} \\n\\tpublic void addTopComponent(Component comp)\\n\\t{\\n\\t\\tadd(TOP,comp);\\n\\t} \\n\\tpublic void removeTopComponent(Component comp)\\n\\t{\\n\\t\\tremove(comp);\\n\\t} \\n\\tpublic void propertiesChanged()\\n\\t{\\n\\t\\tif(buffer == null)\\n\\t\\t\\treturn;\\n\\t\\tint _tabSize = buffer.getTabSize();\\n\\t\\tchar[] foo = new char[_tabSize];\\n\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t{\\n\\t\\t\\tfoo[i] = ' ';\\n\\t\\t}\\n\\t\\ttabSize = (float)painter.getFont().getStringBounds(foo,0,_tabSize,\\n\\t\\t\\tpainter.getFontRenderContext()).getWidth();\\n\\t\\tcharWidth = (int)Math.round(painter.getFont().getStringBounds(foo,0,1,\\n\\t\\t\\tpainter.getFontRenderContext()).getWidth());\\n\\t\\tString wrap = buffer.getStringProperty(\\\"wrap\\\");\\n\\t\\thardWrap = wrap.equals(\\\"hard\\\");\\n\\t\\tmaxLineLen = buffer.getIntegerProperty(\\\"maxLineLen\\\",0);\\n\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\tif(displayManager != null && !bufferChanging)\\n\\t\\t\\tdisplayManager.updateWrapSettings();\\n\\t\\tchunkCache.invalidateAll();\\n\\t\\tgutter.repaint();\\n\\t\\tpainter.repaint();\\n\\t} \\n\\tpublic final int getSelectionStart()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getStart();\\n\\t} \\n\\tpublic int getSelectionStart(int line)\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getStart(\\n\\t\\t\\tbuffer,line);\\n\\t} \\n\\tpublic final int getSelectionStartLine()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getStartLine();\\n\\t} \\n\\tpublic final void setSelectionStart(int selectionStart)\\n\\t{\\n\\t\\tselect(selectionStart,getSelectionEnd(),true);\\n\\t} \\n\\tpublic final int getSelectionEnd()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getEnd();\\n\\t} \\n\\tpublic int getSelectionEnd(int line)\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getEnd(\\n\\t\\t\\tbuffer,line);\\n\\t} \\n\\tpublic final int getSelectionEndLine()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn ((Selection)selection.elementAt(0)).getEndLine();\\n\\t} \\n\\tpublic final void setSelectionEnd(int selectionEnd)\\n\\t{\\n\\t\\tselect(getSelectionStart(),selectionEnd,true);\\n\\t} \\n\\tpublic final int getMarkPosition()\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(s == null)\\n\\t\\t\\treturn caret;\\n\\t\\tif(s.start == caret)\\n\\t\\t\\treturn s.end;\\n\\t\\telse if(s.end == caret)\\n\\t\\t\\treturn s.start;\\n\\t\\telse\\n\\t\\t\\treturn caret;\\n\\t} \\n\\tpublic final int getMarkLine()\\n\\t{\\n\\t\\tif(selection.size() != 1)\\n\\t\\t\\treturn caretLine;\\n\\t\\tSelection s = (Selection)selection.elementAt(0);\\n\\t\\tif(s.start == caret)\\n\\t\\t\\treturn s.endLine;\\n\\t\\telse if(s.end == caret)\\n\\t\\t\\treturn s.startLine;\\n\\t\\telse\\n\\t\\t\\treturn caretLine;\\n\\t} \\n\\tpublic void select(int start, int end)\\n\\t{\\n\\t\\tselect(start,end,true);\\n\\t} \\n\\tpublic void select(int start, int end, boolean doElectricScroll)\\n\\t{\\n\\t\\tselectNone();\\n\\t\\tint newStart, newEnd;\\n\\t\\tif(start < end)\\n\\t\\t{\\n\\t\\t\\tnewStart = start;\\n\\t\\t\\tnewEnd = end;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tnewStart = end;\\n\\t\\t\\tnewEnd = start;\\n\\t\\t}\\n\\t\\tsetSelection(new Selection.Range(newStart,newEnd));\\n\\t\\tmoveCaretPosition(end,doElectricScroll);\\n\\t} \\n\\tpublic boolean isSelectionRectangular()\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(s == null)\\n\\t\\t\\treturn false;\\n\\t\\telse\\n\\t\\t\\treturn (s instanceof Selection.Rect);\\n\\t} \\n\\t\\tSegment lineSegment;\\n\\tMouseHandler mouseHandler;\\n\\tChunkCache chunkCache;\\n\\tDisplayManager displayManager;\\n\\tboolean bufferChanging;\\n\\tint maxHorizontalScrollWidth;\\n\\tboolean updateMaxHorizontalScrollWidth;\\n\\tboolean hardWrap;\\n\\tfloat tabSize;\\n\\tint charWidth;\\n\\tint maxLineLen;\\n\\tboolean scrollBarsInitialized;\\n\\t\\t\\t\\t\\t\\t\\tboolean queuedScrollTo;\\n\\tboolean queuedScrollToElectric;\\n\\tboolean queuedFireCaretEvent;\\n\\tList runnables;\\n\\t\\t\\tVector selection;\\n\\t\\tPoint returnValue;\\n\\tboolean lastLinePartial;\\n\\tfinal boolean isCaretVisible()\\n\\t{\\n\\t\\treturn blink && hasFocus();\\n\\t} \\n\\tfinal boolean isStructureHighlightVisible()\\n\\t{\\n\\t\\treturn match != null\\n\\t\\t\\t&& hasFocus()\\n\\t\\t\\t&& displayManager.isLineVisible(match.startLine)\\n\\t\\t\\t&& displayManager.isLineVisible(match.endLine);\\n\\t} \\n\\t\\tvoid updateMaxHorizontalScrollWidth()\\n\\t{\\n\\t\\tint max = chunkCache.getMaxHorizontalScrollWidth();\\n\\t\\tif(max != maxHorizontalScrollWidth)\\n\\t\\t{\\n\\t\\t\\tmaxHorizontalScrollWidth = max;\\n\\t\\t\\thorizontal.setValues(Math.max(0,\\n\\t\\t\\t\\tMath.min(maxHorizontalScrollWidth + charWidth\\n\\t\\t\\t\\t- painter.getWidth(),\\n\\t\\t\\t\\t-horizontalOffset)),\\n\\t\\t\\t\\tpainter.getWidth(),\\n\\t\\t\\t\\t0,maxHorizontalScrollWidth\\n\\t\\t\\t\\t+ charWidth);\\n\\t\\t}\\n\\t} \\n\\t\\tvoid recalculateVisibleLines()\\n\\t{\\n\\t\\tif(painter == null)\\n\\t\\t\\treturn;\\n\\t\\tint height = painter.getHeight();\\n\\t\\tint lineHeight = painter.getFontMetrics().getHeight();\\n\\t\\tvisibleLines = height / lineHeight;\\n\\t\\tlastLinePartial = (height % lineHeight != 0);\\n\\t\\tif(lastLinePartial)\\n\\t\\t\\tvisibleLines++;\\n\\t\\tchunkCache.recalculateVisibleLines();\\n\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\t\\t\\tif(displayManager != null && buffer != null && buffer.isLoaded())\\n\\t\\t\\tsetFirstLine(getFirstLine());\\n\\t\\tupdateScrollBars();\\n\\t} \\n\\t\\tvoid foldStructureChanged()\\n\\t{\\n\\t\\tchunkCache.invalidateAll();\\n\\t\\trecalculateLastPhysicalLine();\\n\\t\\trepaint();\\n\\t} \\n\\tvoid updateScrollBars()\\n\\t{\\n\\t\\tif(buffer == null)\\n\\t\\t\\treturn;\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"updateScrollBars(), slc=\\\"\\n\\t\\t\\t\\t+ displayManager.getScrollLineCount());\\n\\t\\tif(vertical != null && visibleLines != 0)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"Vertical ok\\\");\\n\\t\\t\\tint lineCount = displayManager.getScrollLineCount();\\n\\t\\t\\tint firstLine = getFirstLine();\\n\\t\\t\\tint visible = visibleLines - (lastLinePartial ? 1 : 0);\\n\\t\\t\\tvertical.setValues(firstLine,visible,0,lineCount);\\n\\t\\t\\tvertical.setUnitIncrement(2);\\n\\t\\t\\tvertical.setBlockIncrement(visible);\\n\\t\\t}\\n\\t\\tint width = painter.getWidth();\\n\\t\\tif(horizontal != null && width != 0)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"Horizontal ok\\\");\\n\\t\\t\\tmaxHorizontalScrollWidth = 0;\\n\\t\\t\\tpainter.repaint();\\n\\t\\t\\thorizontal.setUnitIncrement(painter.getFontMetrics()\\n\\t\\t\\t\\t.charWidth('w'));\\n\\t\\t\\thorizontal.setBlockIncrement(width / 2);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate static String CENTER = \\\"center\\\";\\n\\tprivate static String RIGHT = \\\"right\\\";\\n\\tprivate static String LEFT = \\\"left\\\";\\n\\tprivate static String BOTTOM = \\\"bottom\\\";\\n\\tprivate static String TOP = \\\"top\\\";\\n\\tprivate static Timer caretTimer;\\n\\tprivate static Timer structureTimer;\\n\\tprivate static JEditTextArea focusedComponent;\\n\\t\\tprivate View view;\\n\\tprivate Gutter gutter;\\n\\tprivate TextAreaPainter painter;\\n\\tprivate JPopupMenu popup;\\n\\tprivate EventListenerList listenerList;\\n\\tprivate MutableCaretEvent caretEvent;\\n\\tprivate boolean caretBlinks;\\n\\tprivate boolean blink;\\n\\tprivate int physLastLine;\\n\\tprivate int screenLastLine;\\n\\tprivate int visibleLines;\\n\\tprivate int electricScroll;\\n\\tprivate int horizontalOffset;\\n\\tprivate boolean quickCopy;\\n\\t\\tprivate Box verticalBox;\\n\\tprivate JScrollBar vertical;\\n\\tprivate JScrollBar horizontal;\\n\\tprivate Buffer buffer;\\n\\tprivate BufferChangeHandler bufferHandler;\\n\\tprivate boolean bufferHandlerInstalled;\\n\\tprivate int caret;\\n\\tprivate int caretLine;\\n\\tprivate int caretScreenLine;\\n\\tprivate List structureMatchers;\\n\\tprivate StructureMatcher.Match match;\\n\\tprivate int magicCaret;\\n\\tprivate boolean multi;\\n\\tprivate boolean overwrite;\\n\\tprivate boolean rectangularSelectionMode;\\n\\tprivate boolean delayedScrollTo;\\n\\tprivate boolean dndEnabled;\\n\\tprivate Method dndCallback;\\n\\tprivate boolean dndInProgress;\\n\\t\\t\\tprivate void startDragAndDrop(InputEvent evt, boolean copy)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tdndCallback.invoke(null,new Object[] { this, evt,\\n\\t\\t\\t\\tnew Boolean(copy) });\\n\\t\\t}\\n\\t\\tcatch(Exception e)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.ERROR,this,e);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void _addToSelection(Selection addMe)\\n\\t{\\n\\t\\tif(addMe.start > addMe.end)\\n\\t\\t{\\n\\t\\t\\tthrow new IllegalArgumentException(addMe.start\\n\\t\\t\\t\\t+ \\\" > \\\" + addMe.end);\\n\\t\\t}\\n\\t\\telse if(addMe.start == addMe.end)\\n\\t\\t{\\n\\t\\t\\tif(addMe instanceof Selection.Range)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\telse if(addMe instanceof Selection.Rect)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(((Selection.Rect)addMe).extraEndVirt == 0)\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tif(s.overlaps(addMe))\\n\\t\\t\\t{\\n\\t\\t\\t\\taddMe.start = Math.min(s.start,addMe.start);\\n\\t\\t\\t\\taddMe.end = Math.max(s.end,addMe.end);\\n\\t\\t\\t\\tselection.removeElement(s);\\n\\t\\t\\t\\ti--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\taddMe.startLine = getLineOfOffset(addMe.start);\\n\\t\\taddMe.endLine = getLineOfOffset(addMe.end);\\n\\t\\tboolean added = false;\\n\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\tif(addMe.start < s.start)\\n\\t\\t\\t{\\n\\t\\t\\t\\tselection.insertElementAt(addMe,i);\\n\\t\\t\\t\\tadded = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(!added)\\n\\t\\t\\tselection.addElement(addMe);\\n\\t\\tinvalidateLineRange(addMe.startLine,addMe.endLine);\\n\\t} \\n\\tprivate void finishCaretUpdate(boolean doElectricScroll,\\n\\t\\tboolean fireCaretEvent)\\n\\t{\\n\\t\\tthis.queuedScrollToElectric |= doElectricScroll;\\n\\t\\tthis.queuedFireCaretEvent |= fireCaretEvent;\\n\\t\\tif(queuedScrollTo)\\n\\t\\t\\treturn;\\n\\t\\tRunnable r = new Runnable()\\n\\t\\t{\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tblink = true;\\n\\t\\t\\t\\tcaretTimer.restart();\\n\\t\\t\\t\\tscrollToCaret(queuedScrollToElectric);\\n\\t\\t\\t\\tupdateBracketHighlightWithDelay();\\n\\t\\t\\t\\tif(queuedFireCaretEvent)\\n\\t\\t\\t\\t\\tfireCaretEvent();\\n\\t\\t\\t\\tqueuedScrollTo = queuedScrollToElectric\\n\\t\\t\\t\\t\\t= queuedFireCaretEvent = false;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tif(buffer.isTransactionInProgress())\\n\\t\\t{\\n\\t\\t\\tqueuedScrollTo = true;\\n\\t\\t\\trunnables.add(r);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tr.run();\\n\\t} \\n\\t\\tprivate void fireCaretEvent()\\n\\t{\\n\\t\\tObject[] listeners = listenerList.getListenerList();\\n\\t\\tfor(int i = listeners.length - 2; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(listeners[i] == CaretListener.class)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t((CaretListener)listeners[i+1]).caretUpdate(caretEvent);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireScrollEvent(boolean vertical)\\n\\t{\\n\\t\\tObject[] listeners = listenerList.getListenerList();\\n\\t\\tfor(int i = listeners.length - 2; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(listeners[i] == ScrollListener.class)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(vertical)\\n\\t\\t\\t\\t\\t\\t((ScrollListener)listeners[i+1]).scrolledVertically(this);\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t((ScrollListener)listeners[i+1]).scrolledHorizontally(this);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void insertTab()\\n\\t{\\n\\t\\tint tabSize = buffer.getTabSize();\\n\\t\\tif(buffer.getBooleanProperty(\\\"noTabs\\\"))\\n\\t\\t{\\n\\t\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\t\\tString line = getText(lineStart,caret - lineStart);\\n\\t\\t\\tint pos = 0;\\n\\t\\t\\tfor(int i = 0; i < line.length(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(line.charAt(pos))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tpos = 0;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif(++pos >= tabSize)\\n\\t\\t\\t\\t\\t\\tpos = 0;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tsetSelectedText(MiscUtilities.createWhiteSpace(\\n\\t\\t\\t\\ttabSize - pos,0));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tsetSelectedText(\\\"\\\\t\\\");\\n\\t} \\n\\t\\tprivate boolean doWordWrap(boolean spaceInserted)\\n\\t{\\n\\t\\tif(!hardWrap || maxLineLen <= 0)\\n\\t\\t\\treturn false;\\n\\t\\tbuffer.getLineText(caretLine,lineSegment);\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine);\\n\\t\\tint len = end - start - 1;\\n\\t\\tint caretPos = caret - start;\\n\\t\\t\\t\\t\\t\\tfor(int i = caretPos; i < len; i++)\\n\\t\\t{\\n\\t\\t\\tchar ch = lineSegment.array[lineSegment.offset + i];\\n\\t\\t\\tif(ch != ' ' && ch != '\\\\t')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tboolean returnValue = false;\\n\\t\\tint tabSize = buffer.getTabSize();\\n\\t\\tString wordBreakChars = buffer.getStringProperty(\\\"wordBreakChars\\\");\\n\\t\\tint logicalLength = 0; \\t\\tint lastWordOffset = -1;\\n\\t\\tboolean lastWasSpace = true;\\n\\t\\tfor(int i = 0; i < caretPos; i++)\\n\\t\\t{\\n\\t\\t\\tchar ch = lineSegment.array[lineSegment.offset + i];\\n\\t\\t\\tif(ch == '\\\\t')\\n\\t\\t\\t{\\n\\t\\t\\t\\tlogicalLength += tabSize - (logicalLength % tabSize);\\n\\t\\t\\t\\tif(!lastWasSpace && logicalLength <= maxLineLen)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastWordOffset = i;\\n\\t\\t\\t\\t\\tlastWasSpace = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(ch == ' ')\\n\\t\\t\\t{\\n\\t\\t\\t\\tlogicalLength++;\\n\\t\\t\\t\\tif(!lastWasSpace && logicalLength <= maxLineLen)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastWordOffset = i;\\n\\t\\t\\t\\t\\tlastWasSpace = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(wordBreakChars != null && wordBreakChars.indexOf(ch) != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlogicalLength++;\\n\\t\\t\\t\\tif(!lastWasSpace && logicalLength <= maxLineLen)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastWordOffset = i;\\n\\t\\t\\t\\t\\tlastWasSpace = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tlogicalLength++;\\n\\t\\t\\t\\tlastWasSpace = false;\\n\\t\\t\\t}\\n\\t\\t\\tint insertNewLineAt;\\n\\t\\t\\tif(spaceInserted && logicalLength == maxLineLen\\n\\t\\t\\t\\t&& i == caretPos - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsertNewLineAt = caretPos;\\n\\t\\t\\t\\treturnValue = true;\\n\\t\\t\\t}\\n\\t\\t\\telse if(logicalLength >= maxLineLen && lastWordOffset != -1)\\n\\t\\t\\t\\tinsertNewLineAt = lastWordOffset;\\n\\t\\t\\telse\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tbuffer.insert(start + insertNewLineAt,\\\"\\\\n\\\");\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbuffer.indentLine(caretLine,true);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t\\treturn returnValue;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t} \\n\\t\\tprivate void doWordCount(View view, String text)\\n\\t{\\n\\t\\tchar[] chars = text.toCharArray();\\n\\t\\tint characters = chars.length;\\n\\t\\tint words;\\n\\t\\tif(characters == 0)\\n\\t\\t\\twords = 0;\\n\\t\\telse\\n\\t\\t\\twords = 1;\\n\\t\\tint lines = 1;\\n\\t\\tboolean word = false;\\n\\t\\tfor(int i = 0; i < chars.length; i++)\\n\\t\\t{\\n\\t\\t\\tswitch(chars[i])\\n\\t\\t\\t{\\n\\t\\t\\tcase '\\\\r': case '\\\\n':\\n\\t\\t\\t\\tlines++;\\n\\t\\t\\tcase ' ': case '\\\\t':\\n\\t\\t\\t\\tif(word)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twords++;\\n\\t\\t\\t\\t\\tword = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tword = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tObject[] args = { new Integer(characters), new Integer(words),\\n\\t\\t\\tnew Integer(lines) };\\n\\t\\tGUIUtilities.message(view,\\\"wordcount\\\",args);\\n\\t} \\n\\t\\tprivate void updateBracketHighlightWithDelay()\\n\\t{\\n\\t\\tstructureTimer.stop();\\n\\t\\tstructureTimer.start();\\n\\t} \\n\\t\\tprivate void updateStructureHighlight()\\n\\t{\\n\\t\\tif(!painter.isStructureHighlightEnabled()\\n\\t\\t\\t&& !gutter.isStructureHighlightEnabled())\\n\\t\\t\\treturn;\\n\\t\\tIterator iter = structureMatchers.iterator();\\n\\t\\twhile(iter.hasNext())\\n\\t\\t{\\n\\t\\t\\tStructureMatcher matcher = (StructureMatcher)\\n\\t\\t\\t\\titer.next();\\n\\t\\t\\tmatch = matcher.getMatch(this);\\n\\t\\t\\tif(match != null)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tif(match != null)\\n\\t\\t{\\n\\t\\t\\tif(caretLine < match.startLine)\\n\\t\\t\\t\\tinvalidateLineRange(caretLine,match.endLine);\\n\\t\\t\\telse\\n\\t\\t\\t\\tinvalidateLineRange(match.startLine,caretLine);\\n\\t\\t\\tif(chunkCache.getScreenLineOfOffset(match.startLine,\\n\\t\\t\\t\\tmatch.start - getLineStartOffset(match.startLine))\\n\\t\\t\\t\\t== -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tshowStructureStatusMessage(match.startLine < caretLine);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void showStructureStatusMessage(boolean backward)\\n\\t{\\n\\t\\tString text = buffer.getLineText(match.startLine).trim();\\n\\t\\tif(backward && match.startLine != 0 && text.length() == 1)\\n\\t\\t{\\n\\t\\t\\tswitch(text.charAt(0))\\n\\t\\t\\t{\\n\\t\\t\\tcase '{': case '}':\\n\\t\\t\\tcase '[': case ']':\\n\\t\\t\\tcase '(': case ')':\\n\\t\\t\\t\\ttext = buffer.getLineText(match.startLine - 1)\\n\\t\\t\\t\\t\\t.trim() + \\\" \\\" + text;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\ttext = text.replace('\\\\t',' ');\\n\\t\\tview.getStatus().setMessageAndClear(jEdit.getProperty(\\n\\t\\t\\t\\\"view.status.bracket\\\",new Object[] { \\n\\t\\t\\tnew Integer(match.startLine + 1), text }));\\n\\t} \\n\\t\\tvoid recalculateLastPhysicalLine()\\n\\t{\\n\\t\\tint oldScreenLastLine = screenLastLine;\\n\\t\\tfor(int i = visibleLines - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(i);\\n\\t\\t\\tif(info.physicalLine != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tphysLastLine = info.physicalLine;\\n\\t\\t\\t\\tscreenLastLine = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tinvalidateScreenLineRange(oldScreenLastLine,screenLastLine);\\n\\t} \\n\\t\\tstatic class RectParams\\n\\t{\\n\\t\\tint extraStartVirt;\\n\\t\\tint extraEndVirt;\\n\\t\\tint newCaret;\\n\\t\\tRectParams(int extraStartVirt, int extraEndVirt, int newCaret)\\n\\t\\t{\\n\\t\\t\\tthis.extraStartVirt = extraStartVirt;\\n\\t\\t\\tthis.extraEndVirt = extraEndVirt;\\n\\t\\t\\tthis.newCaret = newCaret;\\n\\t\\t}\\n\\t}\\n\\tprivate RectParams getRectParams(int caret, int newCaret)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint virtualWidth;\\n\\t\\tif(s instanceof Selection.Rect)\\n\\t\\t{\\n\\t\\t\\tif(caret == s.end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvirtualWidth = buffer.getVirtualWidth(\\n\\t\\t\\t\\t\\ts.endLine,s.end - getLineStartOffset(\\n\\t\\t\\t\\t\\ts.endLine)) + ((Selection.Rect)s).extraEndVirt;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tvirtualWidth = buffer.getVirtualWidth(\\n\\t\\t\\t\\t\\ts.startLine,s.start - getLineStartOffset(\\n\\t\\t\\t\\t\\ts.startLine)) + ((Selection.Rect)s).extraStartVirt;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(rectangularSelectionMode)\\n\\t\\t{\\n\\t\\t\\tvirtualWidth = buffer.getVirtualWidth(\\n\\t\\t\\t\\tcaretLine,caret - buffer.getLineStartOffset(caretLine));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn null;\\n\\t\\tint newLine = getLineOfOffset(newCaret);\\n\\t\\tint[] totalVirtualWidth = new int[1];\\n\\t\\tint newOffset = buffer.getOffsetOfVirtualColumn(newLine,\\n\\t\\t\\tvirtualWidth,totalVirtualWidth);\\n\\t\\tif(newOffset == -1)\\n\\t\\t{\\n\\t\\t\\tint extraVirt = virtualWidth - totalVirtualWidth[0];\\n\\t\\t\\tnewCaret = getLineEndOffset(newLine) - 1;\\n\\t\\t\\tRectParams returnValue;\\n\\t\\t\\tboolean bias;\\n\\t\\t\\tif(s == null)\\n\\t\\t\\t\\tbias = (newCaret < caret);\\n\\t\\t\\telse if(s.start == caret)\\n\\t\\t\\t\\tbias = (newCaret <= s.end);\\n\\t\\t\\telse if(s.end == caret)\\n\\t\\t\\t\\tbias = (newCaret <= s.start);\\n\\t\\t\\telse\\n\\t\\t\\t\\tbias = false;\\n\\t\\t\\tif(bias)\\n\\t\\t\\t\\treturnValue = new RectParams(extraVirt,0,newCaret);\\n\\t\\t\\telse\\n\\t\\t\\t\\treturnValue = new RectParams(0,extraVirt,newCaret);\\n\\t\\t\\treturn returnValue;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\treturn new RectParams(0,0,getLineStartOffset(newLine)\\n\\t\\t\\t\\t+ newOffset);\\n\\t\\t}\\n\\t} \\n\\t\\tstatic class TextAreaBorder extends AbstractBorder\\n\\t{\\n\\t\\tprivate static final Insets insets = new Insets(1, 1, 2, 2);\\n\\t\\t\\t\\tpublic void paintBorder(Component c, Graphics g, int x, int y,\\n\\t\\t\\tint width, int height)\\n\\t\\t{\\n\\t\\t\\tg.translate(x,y);\\n\\t\\t\\tg.setColor(MetalLookAndFeel.getControlDarkShadow());\\n\\t\\t\\tg.drawRect(0,0,width-2,height-2);\\n\\t\\t\\tg.setColor(MetalLookAndFeel.getControlHighlight());\\n\\t\\t\\tg.drawLine(width-1,1,width-1,height-1);\\n\\t\\t\\tg.drawLine(1,height-1,width-1,height-1);\\n\\t\\t\\tg.setColor(MetalLookAndFeel.getControl());\\n\\t\\t\\tg.drawLine(width-2,2,width-2,2);\\n\\t\\t\\tg.drawLine(1,height-2,1,height-2);\\n\\t\\t\\tg.translate(-x,-y);\\n\\t\\t} \\n\\t\\t\\t\\tpublic Insets getBorderInsets(Component c)\\n\\t\\t{\\n\\t\\t\\treturn new Insets(1,1,2,2);\\n\\t\\t} \\t} \\n\\t\\tclass ScrollLayout implements LayoutManager\\n\\t{\\n\\t\\t\\t\\tpublic void addLayoutComponent(String name, Component comp)\\n\\t\\t{\\n\\t\\t\\tif(name.equals(CENTER))\\n\\t\\t\\t\\tcenter = comp;\\n\\t\\t\\telse if(name.equals(RIGHT))\\n\\t\\t\\t\\tright = comp;\\n\\t\\t\\telse if(name.equals(LEFT))\\n\\t\\t\\t\\tleft = comp;\\n\\t\\t\\telse if(name.equals(BOTTOM))\\n\\t\\t\\t\\tbottom = comp;\\n\\t\\t\\telse if(name.equals(TOP))\\n\\t\\t\\t\\ttop = comp;\\n\\t\\t} \\n\\t\\t\\t\\tpublic void removeLayoutComponent(Component comp)\\n\\t\\t{\\n\\t\\t\\tif(center == comp)\\n\\t\\t\\t\\tcenter = null;\\n\\t\\t\\telse if(right == comp)\\n\\t\\t\\t\\tright = null;\\n\\t\\t\\telse if(left == comp)\\n\\t\\t\\t\\tleft = null;\\n\\t\\t\\telse if(bottom == comp)\\n\\t\\t\\t\\tbottom = null;\\n\\t\\t\\telse if(top == comp)\\n\\t\\t\\t\\ttop = null;\\n\\t\\t} \\n\\t\\t\\t\\tpublic Dimension preferredLayoutSize(Container parent)\\n\\t\\t{\\n\\t\\t\\tDimension dim = new Dimension();\\n\\t\\t\\tBorder border = getBorder();\\n\\t\\t\\tInsets insets;\\n\\t\\t\\tif(border == null)\\n\\t\\t\\t\\tinsets = new Insets(0,0,0,0);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsets = getBorder().getBorderInsets(\\n\\t\\t\\t\\t\\tJEditTextArea.this);\\n\\t\\t\\t}\\n\\t\\t\\tdim.width = insets.left + insets.right;\\n\\t\\t\\tdim.height = insets.top + insets.bottom;\\n\\t\\t\\tDimension leftPref = left.getPreferredSize();\\n\\t\\t\\tdim.width += leftPref.width;\\n\\t\\t\\tDimension centerPref = center.getPreferredSize();\\n\\t\\t\\tdim.width += centerPref.width;\\n\\t\\t\\tdim.height += centerPref.height;\\n\\t\\t\\tDimension rightPref = right.getPreferredSize();\\n\\t\\t\\tdim.width += rightPref.width;\\n\\t\\t\\tDimension bottomPref = bottom.getPreferredSize();\\n\\t\\t\\tdim.height += bottomPref.height;\\n\\t\\t\\tif(top != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tDimension topPref = top.getPreferredSize();\\n\\t\\t\\t\\tdim.height += topPref.height;\\n\\t\\t\\t}\\n\\t\\t\\treturn dim;\\n\\t\\t} \\n\\t\\t\\t\\tpublic Dimension minimumLayoutSize(Container parent)\\n\\t\\t{\\n\\t\\t\\tDimension dim = new Dimension();\\n\\t\\t\\tBorder border = getBorder();\\n\\t\\t\\tInsets insets;\\n\\t\\t\\tif(border == null)\\n\\t\\t\\t\\tinsets = new Insets(0,0,0,0);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsets = getBorder().getBorderInsets(\\n\\t\\t\\t\\t\\tJEditTextArea.this);\\n\\t\\t\\t}\\n\\t\\t\\tdim.width = insets.left + insets.right;\\n\\t\\t\\tdim.height = insets.top + insets.bottom;\\n\\t\\t\\tDimension leftPref = left.getMinimumSize();\\n\\t\\t\\tdim.width += leftPref.width;\\n\\t\\t\\tDimension centerPref = center.getMinimumSize();\\n\\t\\t\\tdim.width += centerPref.width; \\n\\t\\t\\tdim.height += centerPref.height;\\n\\t\\t\\tDimension rightPref = right.getMinimumSize();\\n\\t\\t\\tdim.width += rightPref.width;\\n\\t\\t\\tDimension bottomPref = bottom.getMinimumSize();\\n\\t\\t\\tdim.height += bottomPref.height;\\n\\t\\t\\tif(top != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tDimension topPref = top.getMinimumSize();\\n\\t\\t\\t\\tdim.height += topPref.height;\\n\\t\\t\\t}\\n\\t\\t\\treturn dim;\\n\\t\\t} \\n\\t\\t\\t\\tpublic void layoutContainer(Container parent)\\n\\t\\t{\\n\\t\\t\\tDimension size = parent.getSize();\\n\\t\\t\\tBorder border = getBorder();\\n\\t\\t\\tInsets insets;\\n\\t\\t\\tif(border == null)\\n\\t\\t\\t\\tinsets = new Insets(0,0,0,0);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsets = getBorder().getBorderInsets(\\n\\t\\t\\t\\t\\tJEditTextArea.this);\\n\\t\\t\\t}\\n\\t\\t\\tint itop = insets.top;\\n\\t\\t\\tint ileft = insets.left;\\n\\t\\t\\tint ibottom = insets.bottom;\\n\\t\\t\\tint iright = insets.right;\\n\\t\\t\\tint rightWidth = right.getPreferredSize().width;\\n\\t\\t\\tint leftWidth = left.getPreferredSize().width;\\n\\t\\t\\tint topHeight;\\n\\t\\t\\tif(top != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttopHeight = top.getPreferredSize().height;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\ttopHeight = 0;\\n\\t\\t\\t}\\n\\t\\t\\tint bottomHeight = bottom.getPreferredSize().height;\\n\\t\\t\\tint centerWidth = Math.max(0,size.width - leftWidth\\n\\t\\t\\t\\t- rightWidth - ileft - iright);\\n\\t\\t\\tint centerHeight = Math.max(0,size.height - topHeight\\n\\t\\t\\t\\t- bottomHeight - itop - ibottom);\\n\\t\\t\\tleft.setBounds(\\n\\t\\t\\t\\tileft,\\n\\t\\t\\t\\titop+topHeight,\\n\\t\\t\\t\\tleftWidth,\\n\\t\\t\\t\\tcenterHeight);\\n\\t\\t\\tcenter.setBounds(\\n\\t\\t\\t\\tileft + leftWidth,\\n\\t\\t\\t\\titop+topHeight,\\n\\t\\t\\t\\tcenterWidth,\\n\\t\\t\\t\\tcenterHeight);\\n\\t\\t\\tright.setBounds(\\n\\t\\t\\t\\tileft + leftWidth + centerWidth,\\n\\t\\t\\t\\titop+topHeight,\\n\\t\\t\\t\\trightWidth,\\n\\t\\t\\t\\tcenterHeight);\\n\\t\\t\\tbottom.setBounds(\\n\\t\\t\\t\\tileft,\\n\\t\\t\\t\\titop + topHeight + centerHeight,\\n\\t\\t\\t\\tMath.max(0,size.width - vertical.getWidth()\\n\\t\\t\\t\\t\\t- ileft - iright),\\n\\t\\t\\t\\tbottomHeight);\\n\\t\\t\\tif(top != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttop.setBounds(\\n\\t\\t\\t\\t\\tileft,\\n\\t\\t\\t\\t\\titop,\\n\\t\\t\\t\\t\\tleftWidth+centerWidth+rightWidth,\\n\\t\\t\\t\\t\\ttopHeight);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tComponent center;\\n\\t\\tComponent left;\\n\\t\\tComponent right;\\n\\t\\tComponent bottom;\\n\\t\\tComponent top;\\n\\t} \\n\\t\\tstatic class CaretBlinker implements ActionListener\\n\\t{\\n\\t\\t\\t\\tpublic void actionPerformed(ActionEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(focusedComponent != null && focusedComponent.hasFocus())\\n\\t\\t\\t\\tfocusedComponent.blinkCaret();\\n\\t\\t} \\t} \\n\\t\\tclass MutableCaretEvent extends CaretEvent\\n\\t{\\n\\t\\t\\t\\tMutableCaretEvent()\\n\\t\\t{\\n\\t\\t\\tsuper(JEditTextArea.this);\\n\\t\\t} \\n\\t\\t\\t\\tpublic int getDot()\\n\\t\\t{\\n\\t\\t\\treturn getCaretPosition();\\n\\t\\t} \\n\\t\\t\\t\\tpublic int getMark()\\n\\t\\t{\\n\\t\\t\\treturn getMarkPosition();\\n\\t\\t} \\t} \\n\\t\\tclass AdjustHandler implements AdjustmentListener\\n\\t{\\n\\t\\t\\t\\tpublic void adjustmentValueChanged(final AdjustmentEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(!scrollBarsInitialized)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(evt.getAdjustable() == vertical)\\n\\t\\t\\t\\tsetFirstLine(vertical.getValue());\\n\\t\\t\\telse\\n\\t\\t\\t\\tsetHorizontalOffset(-horizontal.getValue());\\n\\t\\t} \\t} \\n\\tclass BufferChangeHandler extends BufferChangeAdapter\\n\\t{\\n\\t\\tboolean delayedUpdate;\\n\\t\\tboolean delayedMultilineUpdate;\\n\\t\\tint delayedRepaintStart;\\n\\t\\tint delayedRepaintEnd;\\n\\t\\t\\t\\tpublic void foldLevelChanged(Buffer buffer, int start, int end)\\n\\t\\t{\\n\\t\\t\\tif(!bufferChanging && end != 0\\n\\t\\t\\t\\t&& buffer.isLoaded())\\n\\t\\t\\t{\\n\\t\\t\\t\\tinvalidateLineRange(start - 1,\\n\\t\\t\\t\\t\\tgetLastPhysicalLine());\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void contentInserted(Buffer buffer, int startLine, int start,\\n\\t\\t\\tint numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t\\tdelayedMultilineUpdate = true;\\n\\t\\t\\tint endLine = startLine + numLines;\\n\\t\\t\\tdelayedRepaint(startLine,endLine);\\n\\t\\t\\t\\t\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\t\\tif(s.contentInserted(buffer,startLine,start,\\n\\t\\t\\t\\t\\tnumLines,length))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdelayedRepaint(s.startLine,s.endLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(!buffer.isTransactionInProgress())\\n\\t\\t\\t\\ttransactionComplete(buffer);\\n\\t\\t\\tif(caret >= start)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t? ELECTRIC_SCROLL : NO_SCROLL);\\n\\t\\t\\t\\tmoveCaretPosition(caret + length,scrollMode);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t? NORMAL_SCROLL : NO_SCROLL);\\n\\t\\t\\t\\tmoveCaretPosition(caret,scrollMode);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tpublic void contentRemoved(Buffer buffer, int startLine, int start,\\n\\t\\t\\tint numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t\\tdelayedMultilineUpdate = true;\\n\\t\\t\\tdelayedRepaint(startLine,startLine);\\n\\t\\t\\t\\t\\t\\tfor(int i = 0; i < selection.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = (Selection)selection.elementAt(i);\\n\\t\\t\\t\\tint oldStartLine = s.startLine;\\n\\t\\t\\t\\tint oldEndLine = s.endLine;\\n\\t\\t\\t\\tboolean changed = s.contentRemoved(buffer,\\n\\t\\t\\t\\t\\tstartLine,start,numLines,length);\\n\\t\\t\\t\\tif(s.start == s.end)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tselection.removeElement(s);\\n\\t\\t\\t\\t\\tdelayedRepaint(oldStartLine,oldEndLine);\\n\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(changed)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdelayedRepaint(s.startLine,s.endLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t? NORMAL_SCROLL : NO_SCROLL);\\n\\t\\t\\tif(caret > start)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caret <= start + length)\\n\\t\\t\\t\\t\\tmoveCaretPosition(start,scrollMode);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmoveCaretPosition(caret - length,scrollMode);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tmoveCaretPosition(caret,scrollMode);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(!buffer.isTransactionInProgress())\\n\\t\\t\\t\\ttransactionComplete(buffer);\\n\\t\\t}\\n\\t\\t\\t\\tpublic void transactionComplete(Buffer buffer)\\n\\t\\t{\\n\\t\\t\\tif(delayedUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(delayedMultilineUpdate)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tinvalidateScreenLineRange(chunkCache\\n\\t\\t\\t\\t\\t\\t.getScreenLineOfOffset(\\n\\t\\t\\t\\t\\t\\tdelayedRepaintStart,0),\\n\\t\\t\\t\\t\\t\\tvisibleLines);\\n\\t\\t\\t\\t\\tdelayedMultilineUpdate = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tinvalidateLineRange(delayedRepaintStart,\\n\\t\\t\\t\\t\\t\\tdelayedRepaintEnd);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdelayedUpdate = false;\\n\\t\\t\\t}\\n\\t\\t\\tIterator iter = runnables.iterator();\\n\\t\\t\\twhile(iter.hasNext())\\n\\t\\t\\t\\t((Runnable)iter.next()).run();\\n\\t\\t\\trunnables.clear();\\n\\t\\t} \\n\\t\\tprivate boolean caretAutoScroll()\\n\\t\\t{\\n\\t\\t\\treturn view == jEdit.getActiveView()\\n\\t\\t\\t\\t&& view.getTextArea() == JEditTextArea.this;\\n\\t\\t} \\n\\t\\t\\t\\tprivate void delayedRepaint(int startLine, int endLine)\\n\\t\\t{\\n\\t\\t\\tchunkCache.invalidateChunksFromPhys(startLine);\\n\\t\\t\\tif(!delayedUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedRepaintStart = startLine;\\n\\t\\t\\t\\tdelayedRepaintEnd = endLine;\\n\\t\\t\\t\\tdelayedUpdate = true;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedRepaintStart = Math.min(\\n\\t\\t\\t\\t\\tdelayedRepaintStart,\\n\\t\\t\\t\\t\\tstartLine);\\n\\t\\t\\t\\tdelayedRepaintEnd = Math.max(\\n\\t\\t\\t\\t\\tdelayedRepaintEnd,\\n\\t\\t\\t\\t\\tendLine);\\n\\t\\t\\t}\\n\\t\\t} \\t} \\n\\t\\tclass FocusHandler implements FocusListener\\n\\t{\\n\\t\\t\\t\\tpublic void focusGained(FocusEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(bufferChanging)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(match != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caretLine < match.startLine)\\n\\t\\t\\t\\t\\tinvalidateLineRange(caretLine,match.endLine);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tinvalidateLineRange(match.startLine,caretLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t\\tfocusedComponent = JEditTextArea.this;\\n\\t\\t} \\n\\t\\t\\t\\tpublic void focusLost(FocusEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(!isShowing())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(match != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caretLine < match.startLine)\\n\\t\\t\\t\\t\\tinvalidateLineRange(caretLine,match.endLine);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tinvalidateLineRange(match.startLine,caretLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t} \\t} \\n\\t\\tclass MouseHandler extends MouseInputAdapter\\n\\t{\\n\\t\\tprivate int dragStartLine;\\n\\t\\tprivate int dragStartOffset;\\n\\t\\tprivate int dragStart;\\n\\t\\tprivate int clickCount;\\n\\t\\tprivate boolean dragged;\\n\\t\\tprivate boolean quickCopyDrag;\\n\\t\\tprivate boolean clearStatus;\\n\\t\\tprivate boolean control;\\n\\t\\tprivate boolean maybeDragAndDrop;\\n\\t\\t\\t\\tpublic void mousePressed(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tcontrol = (OperatingSystem.isMacOS() && evt.isMetaDown())\\n\\t\\t\\t\\t|| (!OperatingSystem.isMacOS() && evt.isControlDown());\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tview.getInputHandler().resetLastActionCount();\\n\\t\\t\\tquickCopyDrag = (isQuickCopyEnabled() &&\\n\\t\\t\\t\\tGUIUtilities.isMiddleButton(evt.getModifiers()));\\n\\t\\t\\tif(!quickCopyDrag)\\n\\t\\t\\t{\\n\\t\\t\\t\\trequestFocus();\\n\\t\\t\\t\\tfocusedComponent = JEditTextArea.this;\\n\\t\\t\\t}\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tint x = evt.getX();\\n\\t\\t\\tint y = evt.getY();\\n\\t\\t\\tdragStart = xyToOffset(x,y,!(painter.isBlockCaretEnabled()\\n\\t\\t\\t\\t|| isOverwriteEnabled()));\\n\\t\\t\\tdragStartLine = getLineOfOffset(dragStart);\\n\\t\\t\\tdragStartOffset = dragStart - getLineStartOffset(dragStartLine);\\n\\t\\t\\tif(GUIUtilities.isPopupTrigger(evt) && popup != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(popup.isVisible())\\n\\t\\t\\t\\t\\tpopup.setVisible(false);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(getSelectionCount() == 0 || multi)\\n\\t\\t\\t\\t\\t\\tmoveCaretPosition(dragStart,false);\\n\\t\\t\\t\\t\\tGUIUtilities.showPopupMenu(popup,painter,\\n\\t\\t\\t\\t\\t\\tevt.getX(),evt.getY());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tdragged = false;\\n\\t\\t\\tblink = true;\\n\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t\\tclickCount = evt.getClickCount();\\n\\t\\t\\tif(isDragEnabled() && getDragAndDropCallback() != null\\n\\t\\t\\t\\t&& getSelectionAtOffset(dragStart) != null\\n\\t\\t\\t\\t&& clickCount == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmaybeDragAndDrop = true;\\n\\t\\t\\t\\tmoveCaretPosition(dragStart,false);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tmaybeDragAndDrop = false;\\n\\t\\t\\tswitch(clickCount)\\n\\t\\t\\t{\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\tdoSingleClick(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\tdoDoubleClick(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault: \\t\\t\\t\\tdoTripleClick(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doSingleClick(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tint x = evt.getX();\\n\\t\\t\\tint extraEndVirt = 0;\\n\\t\\t\\tif(chunkCache.getLineInfo(screenLastLine).lastSubregion)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfloat dragStartLineWidth = offsetToXY(\\n\\t\\t\\t\\t\\tdragStartLine,getLineLength(dragStartLine),\\n\\t\\t\\t\\t\\treturnValue).x;\\n\\t\\t\\t\\tif(x > dragStartLineWidth)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\textraEndVirt = (int)(\\n\\t\\t\\t\\t\\t\\t(x - dragStartLineWidth)\\n\\t\\t\\t\\t\\t\\t/ charWidth);\\n\\t\\t\\t\\t\\tif(!getPainter().isBlockCaretEnabled()\\n\\t\\t\\t\\t\\t\\t&& !isOverwriteEnabled()\\n\\t\\t\\t\\t\\t\\t&& (x - getHorizontalOffset()) % charWidth > charWidth / 2)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\textraEndVirt++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(control || isRectangularSelectionEnabled())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint screenLine = (evt.getY() / getPainter()\\n\\t\\t\\t\\t\\t.getFontMetrics().getHeight());\\n\\t\\t\\t\\tif(screenLine > screenLastLine)\\n\\t\\t\\t\\t\\tscreenLine = screenLastLine;\\n\\t\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(screenLine);\\n\\t\\t\\t\\tif(info.lastSubregion)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tString whitespace = MiscUtilities\\n\\t\\t\\t\\t\\t\\t.createWhiteSpace(extraEndVirt,0);\\n\\t\\t\\t\\t\\tbuffer.insert(dragStart,whitespace);\\n\\t\\t\\t\\t\\tdragStart += whitespace.length();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(evt.isShiftDown())\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tresizeSelection(getMarkPosition(),dragStart,extraEndVirt,\\n\\t\\t\\t\\t\\tisRectangularSelectionEnabled()\\n\\t\\t\\t\\t\\t|| control);\\n\\t\\t\\t\\tif(!quickCopyDrag)\\n\\t\\t\\t\\t\\tmoveCaretPosition(dragStart,false);\\n\\t\\t\\t\\t\\t\\t\\t\\tdragStartLine = getMarkLine();\\n\\t\\t\\t\\tdragStart = getMarkPosition();\\n\\t\\t\\t\\tdragStartOffset = dragStart\\n\\t\\t\\t\\t\\t- getLineStartOffset(dragStartLine);\\n\\t\\t\\t\\t\\t\\t\\t\\tdragged = true;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(!quickCopyDrag)\\n\\t\\t\\t\\tmoveCaretPosition(dragStart,false);\\n\\t\\t\\tif(!(multi || quickCopyDrag))\\n\\t\\t\\t\\tselectNone();\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doDoubleClick(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(getLineLength(dragStartLine) == 0)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tString lineText = getLineText(dragStartLine);\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tif(dragStartOffset == getLineLength(dragStartLine))\\n\\t\\t\\t\\tdragStartOffset--;\\n\\t\\t\\tboolean joinNonWordChars =\\n\\t\\t\\t\\tjEdit.getBooleanProperty(\\\"view.joinNonWordChars\\\");\\n\\t\\t\\tint wordStart = TextUtilities.findWordStart(lineText,\\n\\t\\t\\t\\tdragStartOffset,noWordSep,joinNonWordChars);\\n\\t\\t\\tint wordEnd = TextUtilities.findWordEnd(lineText,\\n\\t\\t\\t\\tdragStartOffset+1,noWordSep,joinNonWordChars);\\n\\t\\t\\tint lineStart = getLineStartOffset(dragStartLine);\\n\\t\\t\\tSelection sel = new Selection.Range(\\n\\t\\t\\t\\tlineStart + wordStart,\\n\\t\\t\\t\\tlineStart + wordEnd);\\n\\t\\t\\tif(isMultipleSelectionEnabled())\\n\\t\\t\\t\\taddToSelection(sel);\\n\\t\\t\\telse\\n\\t\\t\\t\\tsetSelection(sel);\\n\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t\\tquickCopyDrag = false;\\n\\t\\t\\tmoveCaretPosition(lineStart + wordEnd,false);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdragged = true;\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doTripleClick(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tint newCaret = getLineEndOffset(dragStartLine);\\n\\t\\t\\tif(dragStartLine == buffer.getLineCount() - 1)\\n\\t\\t\\t\\tnewCaret--;\\n\\t\\t\\tSelection sel = new Selection.Range(\\n\\t\\t\\t\\tgetLineStartOffset(dragStartLine),\\n\\t\\t\\t\\tnewCaret);\\n\\t\\t\\tif(isMultipleSelectionEnabled())\\n\\t\\t\\t\\taddToSelection(sel);\\n\\t\\t\\telse\\n\\t\\t\\t\\tsetSelection(sel);\\n\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t\\tquickCopyDrag = false;\\n\\t\\t\\tmoveCaretPosition(newCaret,false);\\n\\t\\t} \\n\\t\\t\\t\\tpublic void mouseDragged(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(maybeDragAndDrop)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstartDragAndDrop(evt,control);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(dndInProgress)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(GUIUtilities.isPopupTrigger(evt)\\n\\t\\t\\t\\t|| (popup != null && popup.isVisible()))\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(evt.getY() < 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint delta = Math.min(-1,evt.getY()\\n\\t\\t\\t\\t\\t/ painter.getFontMetrics()\\n\\t\\t\\t\\t\\t.getHeight());\\n\\t\\t\\t\\tsetFirstLine(getFirstLine() + delta);\\n\\t\\t\\t}\\n\\t\\t\\telse if(evt.getY() >= painter.getHeight())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint delta = Math.max(1,(evt.getY()\\n\\t\\t\\t\\t\\t- painter.getHeight()) /\\n\\t\\t\\t\\t\\tpainter.getFontMetrics()\\n\\t\\t\\t\\t\\t.getHeight());\\n\\t\\t\\t\\tif(lastLinePartial)\\n\\t\\t\\t\\t\\tdelta--;\\n\\t\\t\\t\\tsetFirstLine(getFirstLine() + delta);\\n\\t\\t\\t}\\n\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t{\\n\\t\\t\\t\\tview.getStatus().setMessage(jEdit.getProperty(\\n\\t\\t\\t\\t\\t\\\"view.status.rect-quick-copy\\\"));\\n\\t\\t\\t\\tclearStatus = true;\\n\\t\\t\\t}\\n\\t\\t\\tswitch(clickCount)\\n\\t\\t\\t{\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\tdoSingleDrag(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\tdoDoubleDrag(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault: \\t\\t\\t\\tdoTripleDrag(evt);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doSingleDrag(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tdragged = true;\\n\\t\\t\\tint x = evt.getX();\\n\\t\\t\\tint y = evt.getY();\\n\\t\\t\\tif(y < 0)\\n\\t\\t\\t\\ty = 0;\\n\\t\\t\\telse if(y >= painter.getHeight())\\n\\t\\t\\t\\ty = painter.getHeight() - 1;\\n\\t\\t\\tint dot = xyToOffset(x,y,\\n\\t\\t\\t\\t(!painter.isBlockCaretEnabled()\\n\\t\\t\\t\\t&& !isOverwriteEnabled())\\n\\t\\t\\t\\t|| quickCopyDrag);\\n\\t\\t\\tint dotLine = buffer.getLineOfOffset(dot);\\n\\t\\t\\tint extraEndVirt = 0;\\n\\t\\t\\tif(chunkCache.getLineInfo(screenLastLine).lastSubregion)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfloat dotLineWidth = offsetToXY(dotLine,getLineLength(dotLine),\\n\\t\\t\\t\\t\\treturnValue).x;\\n\\t\\t\\t\\tif(x > dotLineWidth)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\textraEndVirt = (int)((x - dotLineWidth) / charWidth);\\n\\t\\t\\t\\t\\tif(!getPainter().isBlockCaretEnabled()\\n\\t\\t\\t\\t\\t\\t&& !isOverwriteEnabled()\\n\\t\\t\\t\\t\\t\\t&& (x - getHorizontalOffset()) % charWidth > charWidth / 2)\\n\\t\\t\\t\\t\\t\\textraEndVirt++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tresizeSelection(dragStart,dot,extraEndVirt,\\n\\t\\t\\t\\tisRectangularSelectionEnabled()\\n\\t\\t\\t\\t|| control);\\n\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tscrollTo(dotLine,dot - buffer.getLineStartOffset(dotLine),false);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(dot != caret)\\n\\t\\t\\t\\t\\tmoveCaretPosition(dot,false);\\n\\t\\t\\t\\tif(isRectangularSelectionEnabled()\\n\\t\\t\\t\\t\\t&& extraEndVirt != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscrollTo(dotLine,dot - buffer.getLineStartOffset(dotLine)\\n\\t\\t\\t\\t\\t\\t+ extraEndVirt,false);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doDoubleDrag(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tint markLineStart = getLineStartOffset(dragStartLine);\\n\\t\\t\\tint markLineLength = getLineLength(dragStartLine);\\n\\t\\t\\tint mark = dragStartOffset;\\n\\t\\t\\tint pos = xyToOffset(evt.getX(),\\n\\t\\t\\t\\tMath.max(0,Math.min(painter.getHeight(),evt.getY())),\\n\\t\\t\\t\\t!(painter.isBlockCaretEnabled() || isOverwriteEnabled()));\\n\\t\\t\\tint line = getLineOfOffset(pos);\\n\\t\\t\\tint lineStart = getLineStartOffset(line);\\n\\t\\t\\tint lineLength = getLineLength(line);\\n\\t\\t\\tint offset = pos - lineStart;\\n\\t\\t\\tString lineText = getLineText(line);\\n\\t\\t\\tString markLineText = getLineText(dragStartLine);\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tboolean joinNonWordChars =\\n\\t\\t\\t\\tjEdit.getBooleanProperty(\\\"view.joinNonWordChars\\\");\\n\\t\\t\\tif(markLineStart + dragStartOffset > lineStart + offset)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(offset != 0 && offset != lineLength)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\toffset = TextUtilities.findWordStart(\\n\\t\\t\\t\\t\\t\\tlineText,offset,noWordSep,\\n\\t\\t\\t\\t\\t\\tjoinNonWordChars);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(markLineLength != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmark = TextUtilities.findWordEnd(\\n\\t\\t\\t\\t\\t\\tmarkLineText,mark,noWordSep,\\n\\t\\t\\t\\t\\t\\tjoinNonWordChars);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(offset != 0 && lineLength != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\toffset = TextUtilities.findWordEnd(\\n\\t\\t\\t\\t\\t\\tlineText,offset,noWordSep,\\n\\t\\t\\t\\t\\t\\tjoinNonWordChars);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(mark != 0 && mark != markLineLength)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmark = TextUtilities.findWordStart(\\n\\t\\t\\t\\t\\t\\tmarkLineText,mark,noWordSep,\\n\\t\\t\\t\\t\\t\\tjoinNonWordChars);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(lineStart + offset == caret)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tresizeSelection(markLineStart + mark,lineStart + offset,\\n\\t\\t\\t\\t0,false);\\n\\t\\t\\tif(!quickCopyDrag)\\n\\t\\t\\t\\tmoveCaretPosition(lineStart + offset,false);\\n\\t\\t} \\n\\t\\t\\t\\tprivate void doTripleDrag(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\tint offset = xyToOffset(evt.getX(),\\n\\t\\t\\t\\tMath.max(0,Math.min(painter.getHeight(),evt.getY())),\\n\\t\\t\\t\\tfalse);\\n\\t\\t\\tint mouseLine = getLineOfOffset(offset);\\n\\t\\t\\tint mark;\\n\\t\\t\\tint mouse;\\n\\t\\t\\tif(dragStartLine > mouseLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmark = getLineEndOffset(dragStartLine) - 1;\\n\\t\\t\\t\\tif(offset == getLineEndOffset(mouseLine) - 1)\\n\\t\\t\\t\\t\\tmouse = offset;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmouse = getLineStartOffset(mouseLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tmark = getLineStartOffset(dragStartLine);\\n\\t\\t\\t\\tif(offset == getLineStartOffset(mouseLine))\\n\\t\\t\\t\\t\\tmouse = offset;\\n\\t\\t\\t\\telse if(offset == getLineEndOffset(mouseLine) - 1\\n\\t\\t\\t\\t\\t&& mouseLine != getBuffer().getLineCount() - 1)\\n\\t\\t\\t\\t\\tmouse = getLineEndOffset(mouseLine);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmouse = getLineEndOffset(mouseLine) - 1;\\n\\t\\t\\t}\\n\\t\\t\\tmouse = Math.min(getBuffer().getLength(),mouse);\\n\\t\\t\\tif(mouse == caret)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tdragged = true;\\n\\t\\t\\tresizeSelection(mark,mouse,0,false);\\n\\t\\t\\tmoveCaretPosition(mouse,false);\\n\\t\\t} \\n\\t\\t\\t\\tpublic void mouseReleased(MouseEvent evt)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tSelection sel = getSelectionAtOffset(dragStart);\\n\\t\\t\\tif(dragged && sel != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tRegisters.setRegister('%',getSelectedText(sel));\\n\\t\\t\\t\\tif(quickCopyDrag)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tremoveFromSelection(sel);\\n\\t\\t\\t\\t\\tRegisters.paste(focusedComponent,\\n\\t\\t\\t\\t\\t\\t'%',sel instanceof Selection.Rect);\\n\\t\\t\\t\\t\\tfocusedComponent.requestFocus();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(isQuickCopyEnabled()\\n\\t\\t\\t\\t&& GUIUtilities.isMiddleButton(evt.getModifiers()))\\n\\t\\t\\t{\\n\\t\\t\\t\\tJEditTextArea.this.requestFocus();\\n\\t\\t\\t\\tfocusedComponent = JEditTextArea.this;\\n\\t\\t\\t\\tsetCaretPosition(dragStart,false);\\n\\t\\t\\t\\tif(!isEditable())\\n\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tRegisters.paste(JEditTextArea.this,'%',control);\\n\\t\\t\\t}\\n\\t\\t\\telse if(maybeDragAndDrop && !isMultipleSelectionEnabled())\\n\\t\\t\\t{\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\t}\\n\\t\\t\\tdragged = false;\\n\\t\\t\\tif(clearStatus)\\n\\t\\t\\t{\\n\\t\\t\\t\\tclearStatus = false;\\n\\t\\t\\t\\tview.getStatus().setMessage(null);\\n\\t\\t\\t}\\n\\t\\t} \\t} \\n\\t\\tstatic\\n\\t{\\n\\t\\tcaretTimer = new Timer(500,new CaretBlinker());\\n\\t\\tcaretTimer.setInitialDelay(500);\\n\\t\\tcaretTimer.start();\\n\\t\\tstructureTimer = new Timer(100,new ActionListener()\\n\\t\\t{\\n\\t\\t\\tpublic void actionPerformed(ActionEvent evt)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(focusedComponent != null)\\n\\t\\t\\t\\t\\tfocusedComponent.updateStructureHighlight();\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tstructureTimer.setInitialDelay(100);\\n\\t\\tstructureTimer.setRepeats(false);\\n\\t} }\""
            },
            "m9": {
                "content": "The source code for `JEditTextArea.java` reveals several key structural and functional dependencies. This class is central to the text editing functionality in jEdit, and it interacts with a number of other classes for rendering, buffer management, input handling, and user interface components.\n\n### Key Dependencies Identified from the Code:\n\n1. **Buffer (`org.gjt.sp.jedit.buffer.Buffer`)**:\n   - The `JEditTextArea` maintains a reference to a `Buffer` object which holds the actual text content.\n   - Operations like `getText()`, `setText()`, `getLineText()`, and `insert()` are delegated to the buffer.\n   - Changes to this class will likely impact any code interacting with the buffer or its contents.\n\n2. **TextAreaPainter (`org.gjt.sp.jedit.textarea.TextAreaPainter`)**:\n   - Responsible for rendering the text area.\n   - Directly used for painting, caret rendering, and screen updates.\n\n3. **Gutter (`org.gjt.sp.jedit.textarea.Gutter`)**:\n   - Manages the gutter (line numbers, icons, etc.) associated with the text area.\n   - Instantiated and managed by `JEditTextArea`.\n\n4. **MouseHandler (`JEditTextArea.MouseHandler`)**:\n   - Inner class that handles mouse events and selections.\n   - Extensive interaction with selection logic and caret positioning.\n\n5. **ChunkCache (`org.gjt.sp.jedit.textarea.ChunkCache`)**:\n   - Used to manage how lines are displayed, especially for wrapped or folded lines.\n   - Critical for performance and display correctness.\n\n6. **DisplayManager (`org.gjt.sp.jedit.textarea.DisplayManager`)**:\n   - Manages visible lines, folding, and scrolling behavior.\n   - Tightly integrated with how the text area renders content.\n\n7. **Selection Classes (`org.gjt.sp.jedit.textarea.Selection.*`)**:\n   - Used to manage various types of selections (range, rectangular).\n   - Core to text manipulation and UI interactions.\n\n8. **Input/Event Handling**:\n   - Interfaces with `InputHandler`, `KeyHandler`, and `FocusHandler`.\n   - These influence keyboard shortcuts, focus behavior, and event propagation.\n\n9. **Utilities (`org.gjt.sp.util.Log`, `org.gjt.sp.jedit.MiscUtilities`, `org.gjt.sp.jedit.TextUtilities`)**:\n   - Logging, utility functions for string manipulation, whitespace handling, etc., are used throughout the code.\n\n10. **GUI Components (`javax.swing.*`, `java.awt.*`)**:\n    - Heavy reliance on Swing components for layout, painting, and event handling.\n\n---\n\n### Entities That Need Synchronization Based on Co-Change and Structural Analysis\n\nFrom the co-change data and structural analysis, the following entities should be closely examined for synchronization when changes occur in `JEditTextArea.java`:\n\n| Entity | Reason |\n|--------|--------|\n| **Buffer.java** | Core data structure; frequent modifications and high confidence in co-change relationships. |\n| **TextAreaPainter.java** | Rendering component; frequently co-changed and tightly coupled structurally. |\n| **Gutter.java** | Visual component tied directly to line information; often modified together. |\n| **ChunkCache.java** | Influences how lines are rendered and cached; high co-change support. |\n| **DisplayManager.java** | Controls visibility, folding, and scrolling; significant coupling. |\n| **Selection.java** and related inner classes | Central to selection logic; modified alongside JEditTextArea. |\n| **MouseHandler.java** | Handles mouse-based interactions; tightly integrated with selection and caret movement. |\n| **BufferChangeHandler.java** | Listens to buffer changes and triggers repaints/updates. |\n| **Log.java** | Logging mechanism used within JEditTextArea. |\n| **View.java** | Top-level container passed through constructors and used for event handling. |\n\n### Next Steps\nTo further validate these findings and uncover deeper interdependencies, I can:\n1. Use `get_coupling_dependencies` between `JEditTextArea.java` and each of the above files to confirm structural dependencies.\n2. Use `get_conceptual_coupling` to check semantic similarity if needed.\n\nWould you like me to proceed with checking coupling dependencies for one or more of these files?\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_7594cddae05c49be87d99a",
                        "function": {
                            "arguments": "{\"entity1\": \"JEditTextArea.java\", \"entity2\": \"Buffer.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m10": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"There are no coupling dependencies between these two entities\"]"
            },
            "m11": {
                "content": "There are no direct coupling dependencies between `JEditTextArea.java` and `Buffer.java`, despite their strong functional relationship. This suggests that the interaction might be primarily through method calls or usage rather than structural dependencies like inheritance, interfaces, or field declarations.\n\nLet\u2019s continue by checking coupling dependencies with other key entities identified from co-change and source code analysis:\n\n1. **TextAreaPainter.java** \u2013 Responsible for rendering.\n2. **Gutter.java** \u2013 Directly used in layout and display.\n3. **ChunkCache.java** \u2013 Critical for line management and display logic.\n\nI'll check coupling dependencies with these next.\n\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_8d89fc1b96544e6c8f0120",
                        "function": {
                            "arguments": "{\"entity1\": \"JEditTextArea.java\", \"entity2\": \"TextAreaPainter.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m12": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"ReturnType(RT): Return Type found: getPainter returns TextAreaPainter,  \", \"Class Member Variable Usage Variable (CMAUA): Coupling found in method getPainter, at line: 157. Instance of TextAreaPainter member variable painter is used directly.  Coupling found in method recalculateVisibleLines, at line: 5177. Instance of TextAreaPainter member variable painter is used directly.  \", \"ConstructorInvoking(CMI): Construction Method Invoking found: new TextAreaPainter(this),  \", \"ConstructorInvoking(CMAIM): Coupling found in method setHorizontalOffset, at line: 673. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method repaint.  Coupling found in method scrollTo, at line: 840. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getWidth.  Coupling found in method scrollTo, at line: 843. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getWidth.  Coupling found in method xyToOffset, at line: 962. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getFontMetrics.  Coupling found in method offsetToXY, at line: 1035. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getFontMetrics.  Coupling found in method invalidateScreenLineRange, at line: 1076. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getFontMetrics.  Coupling found in method invalidateScreenLineRange, at line: 1079. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method repaint.  Coupling found in method invalidateScreenLineRange, at line: 1079. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getWidth.  Coupling found in method setMultipleSelectionEnabled, at line: 3850. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method repaint.  Coupling found in method setRectangularSelectionEnabled, at line: 3895. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method repaint.  Coupling found in method propertiesChanged, at line: 4886. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getFont.  Coupling found in method propertiesChanged, at line: 4887. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getFontRenderContext.  Coupling found in method propertiesChanged, at line: 4889. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getFont.  Coupling found in method propertiesChanged, at line: 4890. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getFontRenderContext.  Coupling found in method propertiesChanged, at line: 4904. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method repaint.  Coupling found in method updateMaxHorizontalScrollWidth, at line: 5166. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getWidth.  Coupling found in method updateMaxHorizontalScrollWidth, at line: 5168. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getWidth.  Coupling found in method recalculateVisibleLines, at line: 5179. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getHeight.  Coupling found in method recalculateVisibleLines, at line: 5180. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getFontMetrics.  Coupling found in method updateScrollBars, at line: 5232. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getWidth.  Coupling found in method updateScrollBars, at line: 5238. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method repaint.  Coupling found in method updateScrollBars, at line: 5240. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getFontMetrics.  Coupling found in method updateStructureHighlight, at line: 5654. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method isStructureHighlightEnabled.  Coupling found in method mousePressed, at line: 6350. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method isBlockCaretEnabled.  Coupling found in method mouseDragged, at line: 6557. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getFontMetrics.  Coupling found in method mouseDragged, at line: 6561. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getHeight.  Coupling found in method mouseDragged, at line: 6564. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getHeight.  Coupling found in method mouseDragged, at line: 6565. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getFontMetrics.  Coupling found in method doSingleDrag, at line: 6602. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getHeight.  Coupling found in method doSingleDrag, at line: 6603. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getHeight.  Coupling found in method doSingleDrag, at line: 6606. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method isBlockCaretEnabled.  Coupling found in method doDoubleDrag, at line: 6656. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getHeight.  Coupling found in method doDoubleDrag, at line: 6657. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method isBlockCaretEnabled.  Coupling found in method doTripleDrag, at line: 6715. Instance of TextAreaPainter member variable painter is used to call TextAreaPainter's method getHeight.\"]"
            },
            "m13": {
                "content": "There are **strong coupling dependencies** between `JEditTextArea.java` and `TextAreaPainter.java`. These dependencies indicate that `JEditTextArea` heavily relies on `TextAreaPainter` for rendering, layout calculations, and user interaction handling. Below is a breakdown of the key coupling types:\n\n---\n\n### \ud83d\udccc Coupling Dependency Types Identified\n\n1. **Return Type (RT)**:\n   - `getPainter()` returns an instance of `TextAreaPainter`, indicating a direct structural dependency.\n\n2. **Class Member Variable Usage (CMAUA, CMAIM)**:\n   - The `painter` member variable is used throughout `JEditTextArea` to:\n     - Access UI-related properties (e.g., `getWidth()`, `getHeight()`, `getFontMetrics()`)\n     - Trigger repaints (`repaint()`)\n     - Check painter state (`isBlockCaretEnabled()`, `isStructureHighlightEnabled()`)\n\n3. **Constructor Invoking (CMI)**:\n   - A new `TextAreaPainter` is constructed with `new TextAreaPainter(this)`, showing tight integration.\n\n4. **Method Calls**:\n   - Multiple methods in `JEditTextArea` invoke operations on the `TextAreaPainter` object, such as:\n     - `repaint()`\n     - `getFontMetrics()`\n     - `getWidth()`\n     - `getHeight()`\n\n---\n\n### \ud83d\udd0d Implications for Change Impact Analysis\n\nDue to these dependencies, changes in either class can significantly impact the other:\n\n- **Changes in `TextAreaPainter` API or behavior** (e.g., method renaming, return type modification, visual logic updates) will likely require corresponding updates in `JEditTextArea`.\n- **Changes in `JEditTextArea`** related to rendering, scrolling, or caret movement may necessitate adjustments in `TextAreaPainter`.\n\nThis confirms that `TextAreaPainter.java` must be **synchronized** alongside `JEditTextArea.java` during any change.\n\n---\n\n### Next Steps\n\nLet\u2019s continue checking coupling for the remaining high-priority files identified earlier:\n\n1. **Gutter.java**\n2. **ChunkCache.java**\n\nWould you like me to check coupling for one of these next?\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_88d63490e21d4e9ab7d4eb",
                        "function": {
                            "arguments": "{\"entity1\": \"JEditTextArea.java\", \"entity2\": \"Gutter.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m14": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"ReturnType(RT): Return Type found: getGutter returns Gutter,  \", \"Class Member Variable Usage Variable (CMAUA): Coupling found in method getGutter, at line: 167. Instance of Gutter member variable gutter is used directly.  \", \"ConstructorInvoking(CMI): Construction Method Invoking found: new Gutter(view, this),  \", \"ConstructorInvoking(CMAIM): Coupling found in method invalidateScreenLineRange, at line: 1080. Instance of Gutter member variable gutter is used to call Gutter's method repaint.  Coupling found in method invalidateScreenLineRange, at line: 1080. Instance of Gutter member variable gutter is used to call Gutter's method getWidth.  Coupling found in method propertiesChanged, at line: 4903. Instance of Gutter member variable gutter is used to call Gutter's method repaint.  Coupling found in method updateStructureHighlight, at line: 5655. Instance of Gutter member variable gutter is used to call Gutter's method isStructureHighlightEnabled.\"]"
            },
            "m15": {
                "content": "There are **clear and significant coupling dependencies** between `JEditTextArea.java` and `Gutter.java`. Below is a summary of the dependency types and their implications:\n\n---\n\n### \ud83d\udccc Coupling Dependency Types Identified\n\n1. **Return Type (RT)**:\n   - `getGutter()` returns an instance of `Gutter`, indicating that `JEditTextArea` provides access to its internal gutter component.\n\n2. **Class Member Variable Usage (CMAUA, CMAIM)**:\n   - The `gutter` member variable is used directly in several methods for:\n     - Repainting (`repaint()`)\n     - Width calculation (`getWidth()`)\n     - Checking visual state (`isStructureHighlightEnabled()`)\n\n3. **Constructor Invoking (CMI)**:\n   - A new `Gutter` is instantiated with `new Gutter(view, this)`, showing tight integration between these classes.\n\n4. **Method Calls**:\n   - `JEditTextArea` calls methods on the `Gutter` object such as `repaint()` and checks UI-related properties like structure highlighting.\n\n---\n\n### \ud83d\udd0d Implications for Change Impact Analysis\n\n- Since `JEditTextArea` creates and manages a `Gutter` instance directly, any change in the `Gutter`'s constructor or method signatures will impact `JEditTextArea`.\n- UI-related changes in how the gutter behaves or renders (e.g., repaint logic, width calculations, structure highlighting) may require corresponding updates in `JEditTextArea`.\n\nThis confirms that `Gutter.java` must be **synchronized** alongside `JEditTextArea.java` when making changes.\n\n---\n\n### \u2705 Entities That Must Be Synchronized So Far\n\n| Entity | Reason |\n|--------|--------|\n| `TextAreaPainter.java` | Heavy rendering interaction; many method calls and structural dependencies |\n| `Gutter.java` | Direct instantiation and usage; UI synchronization needed |\n\n---\n\n### Next Step\n\nWe should continue validating coupling with other co-changed and structurally dependent entities. The next logical candidate is **`ChunkCache.java`**, which plays a central role in line rendering and display logic.\n\nWould you like me to proceed with checking coupling dependencies for `ChunkCache.java`?\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_a1cfc3d41ba84a9a858685",
                        "function": {
                            "arguments": "{\"entity1\": \"JEditTextArea.java\", \"entity2\": \"ChunkCache.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m16": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"ConstructorInvoking(CMI): Construction Method Invoking found: new ChunkCache(this),  \", \"ConstructorInvoking(CMAIM): Coupling found in method setBuffer, at line: 289. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method setBuffer.  Coupling found in method setFirstLine, at line: 487. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method invalidateAll.  Coupling found in method setFirstLine, at line: 492. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method invalidateAll.  Coupling found in method setFirstLine, at line: 497. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method scrollDown.  Coupling found in method setFirstLine, at line: 502. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method scrollUp.  Coupling found in method setFirstPhysicalLine, at line: 605. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method invalidateAll.  Coupling found in method setFirstPhysicalLine, at line: 609. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method scrollDown.  Coupling found in method setFirstPhysicalLine, at line: 613. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method scrollUp.  Coupling found in method scrollTo, at line: 784. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getScreenLineOfOffset.  Coupling found in method scrollTo, at line: 788. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfosForPhysicalLine.  Coupling found in method scrollTo, at line: 790. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getSubregionOfOffset.  Coupling found in method getPhysicalLineOfScreenLine, at line: 883. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method getScreenLineOfOffset, at line: 896. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getScreenLineOfOffset.  Coupling found in method getScreenLineStartOffset, at line: 907. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method getScreenLineEndOffset, at line: 923. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method xToScreenLineOffset, at line: 985. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method offsetToXY, at line: 1031. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getScreenLineOfOffset.  Coupling found in method offsetToXY, at line: 1039. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method invalidateScreenLineRange, at line: 1073. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method needFullRepaint.  Coupling found in method invalidateLine, at line: 1102. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method invalidateLine, at line: 1118. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method needFullRepaint.  Coupling found in method invalidateLineRange, at line: 1153. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method invalidateLineRange, at line: 1172. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method needFullRepaint.  Coupling found in method moveCaretPosition, at line: 2292. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getScreenLineOfOffset.  Coupling found in method getMagicCaretPosition, at line: 2339. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method subregionOffsetToX.  Coupling found in method goToNextLine, at line: 2509. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getBelowPosition.  Coupling found in method goToPrevLine, at line: 2833. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getAbovePosition.  Coupling found in method goToStartOfWhiteSpace, at line: 3170. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getSubregionStartOffset.  Coupling found in method goToEndOfWhiteSpace, at line: 3207. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getSubregionEndOffset.  Coupling found in method deleteLine, at line: 3650. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method subregionOffsetToX.  Coupling found in method deleteLine, at line: 3673. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method xToSubregionOffset.  Coupling found in method deleteLine, at line: 3679. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method xToSubregionOffset.  Coupling found in method goToParentFold, at line: 4008. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method xToSubregionOffset.  Coupling found in method goToNextFold, at line: 4043. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method xToSubregionOffset.  Coupling found in method goToPrevFold, at line: 4080. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method xToSubregionOffset.  Coupling found in method collapseFold, at line: 4098. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method subregionOffsetToX.  Coupling found in method collapseFold, at line: 4111. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method xToSubregionOffset.  Coupling found in method expandFold, at line: 4122. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method subregionOffsetToX.  Coupling found in method expandFold, at line: 4132. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method xToSubregionOffset.  Coupling found in method propertiesChanged, at line: 4902. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method invalidateAll.  Coupling found in method updateMaxHorizontalScrollWidth, at line: 5159. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getMaxHorizontalScrollWidth.  Coupling found in method recalculateVisibleLines, at line: 5186. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method recalculateVisibleLines.  Coupling found in method foldStructureChanged, at line: 5199. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method invalidateAll.  Coupling found in method updateStructureHighlight, at line: 5675. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getScreenLineOfOffset.  Coupling found in method recalculateLastPhysicalLine, at line: 5715. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method transactionComplete, at line: 6216. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getScreenLineOfOffset.  Coupling found in method delayedRepaint, at line: 6250. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method invalidateChunksFromPhys.  Coupling found in method doSingleClick, at line: 6409. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method doSingleClick, at line: 6434. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.  Coupling found in method doSingleDrag, at line: 6612. Instance of ChunkCache member variable chunkCache is used to call ChunkCache's method getLineInfo.\"]"
            },
            "m17": {
                "role": "user",
                "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
            },
            "m18": {
                "content": "Title: Diagnosis of starting entity `JEditTextArea.java`  \nChange set: [TextAreaPainter.java, Gutter.java, ChunkCache.java, BufferChangeHandler.java, DisplayManager.java, MouseHandler.java, View.java, Buffer.java, Selection.java, Log.java, TextAreaBorder.java, ScrollLayout.java, AbstractOptionPane.java, EditAction.java, InputHandler.java, FocusHandler.java, AboutPanel.java, EnhancedMenu.java, EnhancedMenuItem.java, EnhancedCheckBoxMenuItem.java, EnhancedButton.java, DockingOptionPane.java, TextAreaOptionPane.java, AbbrevsOptionPane.java, ModeOptionPane.java, OptionsDialog.java, HistoryModel.java, Abbrevs.java, Registers.java, GUIUtilities.java, Macros.java, Plugin.java, DockableWindowManager.java, Status.java, ToolTipManager.java, FoldVisibilityManager.java, DefaultInputHandler.java, SearchAndReplace.java, VFSBrowser.java, FileVFS.java, MiscUtilities.java, TextUtilities.java]  \n\nDetails:  \n- **TextAreaPainter.java**: Directly used for rendering and screen updates; heavy method calls and construction.  \n- **Gutter.java**: Created and managed directly by JEditTextArea; used for line number and gutter rendering.  \n- **ChunkCache.java**: Central to managing how lines are displayed and cached; used throughout the text area logic.  \n- **BufferChangeHandler.java**: Listens to buffer changes and triggers repaints or updates.  \n- **DisplayManager.java**: Controls visibility, folding, and scrolling behavior; tightly integrated with display logic.  \n- **MouseHandler.java**: Inner class handling mouse events and selection; deeply embedded in user interaction.  \n- **View.java**: Passed through constructor; used for input handling, status updates, and UI coordination.  \n- **Buffer.java**: Core data structure holding the text content; many methods delegate to it.  \n- **Selection.java**: Used extensively for managing selections (range, rectangular).  \n- **Log.java**: Logging mechanism used throughout the code for debug and error output.  \n- **TextAreaBorder.java**: Custom border used in layout and painting.  \n- **ScrollLayout.java**: Layout manager responsible for scrollable area arrangement.  \n- **AbstractOptionPane.java**: Base class for options panels that may interact with text editing settings.  \n- **EditAction.java**: Actions tied to editor commands executed from this component.  \n- **InputHandler.java**: Manages keyboard input and action dispatching.  \n- **FocusHandler.java**: Handles focus gained/lost events affecting caret and highlight behavior.  \n- **AboutPanel.java**: May be invoked via menu actions linked to the text area.  \n- **EnhancedMenu.java, EnhancedMenuItem.java, EnhancedCheckBoxMenuItem.java, EnhancedButton.java**: UI components potentially used in context menus or toolbars.  \n- **DockingOptionPane.java, TextAreaOptionPane.java, AbbrevsOptionPane.java, ModeOptionPane.java, OptionsDialog.java**: Option panes/settings dialogs related to text area configuration.  \n- **HistoryModel.java**: Could be involved in caret or edit history tracking.  \n- **Abbrevs.java**: Auto-expansion abbreviations tied to typing behavior.  \n- **Registers.java**: Clipboard/register operations linked to selection and paste logic.  \n- **GUIUtilities.java**: Used for dialog display, popup triggering, and general UI utility.  \n- **Macros.java**: Macro recording and execution can be triggered from the text area.  \n- **Plugin.java**: Plugins may hook into editing functionality or UI elements.  \n- **DockableWindowManager.java**: Manages dockable windows associated with the view.  \n- **Status.java**: StatusBar updates linked to caret position, selection, etc.  \n- **ToolTipManager.java**: Tooltip management for painter and gutter.  \n- **FoldVisibilityManager.java**: Controls fold expansion/collapse; interacts with display manager.  \n- **DefaultInputHandler.java**: Default implementation of input handler used by the text area.  \n- **SearchAndReplace.java**: Search-related actions often initiated from the text area.  \n- **VFSBrowser.java**: Invoked for file operations possibly triggered from macros or plugins.  \n- **FileVFS.java**: File access abstraction used during editing or search operations.  \n- **MiscUtilities.java**: General-purpose utilities used in indentation, spacing, etc.  \n- **TextUtilities.java**: Core text manipulation routines used in selection and word operations.",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            }
        }
    }
}