{
    "time": 1749471156.4612248,
    "messages": [
        {
            "role": "system",
            "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
        },
        {
            "role": "user",
            "content": "The project you need to analyze is `jEdit`, a well-known Java open source project. The starting entity you need to deal with is Buffer.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
        },
        {
            "content": "",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_922dd71a7e7148fa9fac48",
                    "function": {
                        "arguments": "{\"entity\": \"Buffer.java\"}",
                        "name": "get_co_change_relationship"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "name": "get_co_change_relationship",
            "role": "tool",
            "content": "[[\"Autosave\", \"5\", \"0.023255813953488372\"], [\"SaveBackupOptionPane\", \"3\", \"0.013953488372093023\"], [\"BufferSaveRequest\", \"5\", \"0.023255813953488372\"], [\"MyActionListener\", \"2\", \"0.009302325581395349\"], [\"jEdit\", \"52\", \"0.24186046511627907\"], [\"View\", \"32\", \"0.14883720930232558\"], [\"ActionHandler\", \"27\", \"0.12558139534883722\"], [\"BufferSwitcher\", \"3\", \"0.013953488372093023\"], [\"EditPane\", \"26\", \"0.12093023255813953\"], [\"ViewOptionPane\", \"2\", \"0.009302325581395349\"], [\"GeneralOptionPane\", \"6\", \"0.027906976744186046\"], [\"WindowHandler\", \"4\", \"0.018604651162790697\"], [\"CloseDialog\", \"1\", \"0.004651162790697674\"], [\"ParserRuleSet\", \"6\", \"0.027906976744186046\"], [\"JEditTextArea\", \"125\", \"0.5813953488372093\"], [\"TextUtilities\", \"15\", \"0.06976744186046512\"], [\"FileVFS\", \"20\", \"0.09302325581395349\"], [\"VFSBrowser\", \"39\", \"0.1813953488372093\"], [\"BrowserView\", \"23\", \"0.10697674418604651\"], [\"XModeHandler\", \"9\", \"0.04186046511627907\"], [\"DocumentHandler\", \"2\", \"0.009302325581395349\"], [\"FoldVisibilityManager\", \"19\", \"0.08837209302325581\"], [\"BrowserJTree\", \"12\", \"0.05581395348837209\"], [\"SearchBar\", \"6\", \"0.027906976744186046\"], [\"TextAreaPainter\", \"34\", \"0.15813953488372093\"], [\"SyntaxStyle\", \"2\", \"0.009302325581395349\"], [\"SyntaxCharacterIterator\", \"2\", \"0.009302325581395349\"], [\"Chunk\", \"4\", \"0.018604651162790697\"], [\"MiscUtilities\", \"16\", \"0.07441860465116279\"], [\"BufferIORequest\", \"27\", \"0.12558139534883722\"], [\"Log\", \"4\", \"0.018604651162790697\"], [\"BufferOptions\", \"14\", \"0.06511627906976744\"], [\"CompleteWord\", \"4\", \"0.018604651162790697\"], [\"InstallPluginsDialog\", \"2\", \"0.009302325581395349\"], [\"Completion\", \"2\", \"0.009302325581395349\"], [\"KeyHandler\", \"6\", \"0.027906976744186046\"], [\"Renderer\", \"4\", \"0.018604651162790697\"], [\"ChunkCache\", \"39\", \"0.1813953488372093\"], [\"MouseHandler\", \"41\", \"0.19069767441860466\"], [\"Gutter\", \"13\", \"0.06046511627906977\"], [\"ModeOptionPane\", \"3\", \"0.013953488372093023\"], [\"MarkerHighlight\", \"5\", \"0.023255813953488372\"], [\"ModeProperties\", \"7\", \"0.03255813953488372\"], [\"EditingOptionPane\", \"7\", \"0.03255813953488372\"], [\"TextAreaExtension\", \"2\", \"0.009302325581395349\"], [\"BufferChangeHandler\", \"36\", \"0.16744186046511628\"], [\"OffsetManager\", \"41\", \"0.19069767441860466\"], [\"SearchDialog\", \"12\", \"0.05581395348837209\"], [\"ButtonActionHandler\", \"3\", \"0.013953488372093023\"], [\"BrowserOptionPane\", \"5\", \"0.023255813953488372\"], [\"Marker\", \"5\", \"0.023255813953488372\"], [\"BrowserCommandsMenu\", \"10\", \"0.046511627906976744\"], [\"DockableWindowManager\", \"16\", \"0.07441860465116279\"], [\"Macro\", \"6\", \"0.027906976744186046\"], [\"HyperSearchResults\", \"6\", \"0.027906976744186046\"], [\"GUIUtilities\", \"16\", \"0.07441860465116279\"], [\"Macros\", \"10\", \"0.046511627906976744\"], [\"ButtonLayout\", \"3\", \"0.013953488372093023\"], [\"InputHandler\", \"11\", \"0.05116279069767442\"], [\"DefaultInputHandler\", \"4\", \"0.018604651162790697\"], [\"DockableLayout\", \"3\", \"0.013953488372093023\"], [\"StatusBar\", \"6\", \"0.027906976744186046\"], [\"PaintSelection\", \"2\", \"0.009302325581395349\"], [\"BracketHighlight\", \"2\", \"0.009302325581395349\"], [\"UrlVFS\", \"2\", \"0.009302325581395349\"], [\"JARClassLoader\", \"5\", \"0.023255813953488372\"], [\"ActionListHandler\", \"4\", \"0.018604651162790697\"], [\"PluginListHandler\", \"2\", \"0.009302325581395349\"], [\"DockableListHandler\", \"2\", \"0.009302325581395349\"], [\"ModeCatalogHandler\", \"2\", \"0.009302325581395349\"], [\"RecentHandler\", \"2\", \"0.009302325581395349\"], [\"RotatedTextIcon\", \"4\", \"0.018604651162790697\"], [\"PanelWindowContainer\", \"10\", \"0.046511627906976744\"], [\"FileCellRenderer\", \"8\", \"0.037209302325581395\"], [\"BufferPrintable\", \"2\", \"0.009302325581395349\"], [\"JAR\", \"4\", \"0.018604651162790697\"], [\"ContentManager\", \"6\", \"0.027906976744186046\"], [\"SearchAndReplace\", \"11\", \"0.05116279069767442\"], [\"Install\", \"4\", \"0.018604651162790697\"], [\"ErrorListDialog\", \"2\", \"0.009302325581395349\"], [\"UndoManager\", \"9\", \"0.04186046511627907\"], [\"Abbrevs\", \"5\", \"0.023255813953488372\"], [\"Remove\", \"6\", \"0.027906976744186046\"], [\"BrowserIORequest\", \"9\", \"0.04186046511627907\"], [\"DirectoryMenu\", \"4\", \"0.018604651162790697\"], [\"HelpViewer\", \"7\", \"0.03255813953488372\"], [\"ParentDirectoryRenderer\", \"3\", \"0.013953488372093023\"], [\"ContextOptionPane\", \"2\", \"0.009302325581395349\"], [\"TokenMarker\", \"14\", \"0.06511627906976744\"], [\"ToolBarEditDialog\", \"2\", \"0.009302325581395349\"], [\"MacOSHandler\", \"2\", \"0.009302325581395349\"], [\"TextAreaOptionPane\", \"4\", \"0.018604651162790697\"], [\"RolloverButton\", \"2\", \"0.009302325581395349\"], [\"EnhancedButton\", \"2\", \"0.009302325581395349\"], [\"HelpIndex\", \"4\", \"0.018604651162790697\"], [\"ContextAddDialog\", \"2\", \"0.009302325581395349\"], [\"SyntaxHiliteOptionPane\", \"2\", \"0.009302325581395349\"], [\"FileRootsVFS\", \"4\", \"0.018604651162790697\"], [\"MarkersMenuItem\", \"4\", \"0.018604651162790697\"], [\"MarkersMenu\", \"4\", \"0.018604651162790697\"], [\"PluginResURLConnection\", \"3\", \"0.013953488372093023\"], [\"ActionSet\", \"1\", \"0.004651162790697674\"], [\"WizardLayout\", \"1\", \"0.004651162790697674\"], [\"HyperSearchRequest\", \"5\", \"0.023255813953488372\"], [\"TOCTree\", \"1\", \"0.004651162790697674\"], [\"BufferHistory\", \"3\", \"0.013953488372093023\"], [\"StyleEditor\", \"3\", \"0.013953488372093023\"], [\"SettingsReloader\", \"5\", \"0.023255813953488372\"], [\"Dependency\", \"1\", \"0.004651162790697674\"], [\"PluginManagerProgress\", \"1\", \"0.004651162790697674\"], [\"VFSFileChooserDialog\", \"8\", \"0.037209302325581395\"], [\"ConsoleInstall\", \"1\", \"0.004651162790697674\"], [\"NonInteractiveInstall\", \"1\", \"0.004651162790697674\"], [\"GlobalOptions\", \"4\", \"0.018604651162790697\"], [\"InstallThread\", \"2\", \"0.009302325581395349\"], [\"BeanShellErrorDialog\", \"4\", \"0.018604651162790697\"], [\"BeanShell\", \"7\", \"0.03255813953488372\"], [\"IntegerArray\", \"6\", \"0.027906976744186046\"], [\"LongArray\", \"2\", \"0.009302325581395349\"], [\"PluginOptions\", \"4\", \"0.018604651162790697\"], [\"SplashScreen\", \"4\", \"0.018604651162790697\"], [\"WorkThread\", \"3\", \"0.013953488372093023\"], [\"Insert\", \"2\", \"0.009302325581395349\"], [\"ActionBar\", \"6\", \"0.027906976744186046\"], [\"ActionTextField\", \"4\", \"0.018604651162790697\"], [\"LogListModel\", \"2\", \"0.009302325581395349\"], [\"LogViewer\", \"2\", \"0.009302325581395349\"], [\"LogList\", \"2\", \"0.009302325581395349\"], [\"LineContext\", \"6\", \"0.027906976744186046\"], [\"DisplayTokenHandler\", \"2\", \"0.009302325581395349\"], [\"FocusHandler\", \"8\", \"0.037209302325581395\"], [\"OptionsDialog\", \"5\", \"0.023255813953488372\"], [\"DisplayManager\", \"36\", \"0.16744186046511628\"], [\"EditAction\", \"2\", \"0.009302325581395349\"], [\"PluginTableModel\", \"6\", \"0.027906976744186046\"], [\"AbstractOptionPane\", \"2\", \"0.009302325581395349\"], [\"ListUpdater\", \"2\", \"0.009302325581395349\"], [\"InstallPanel\", \"4\", \"0.018604651162790697\"], [\"PluginManager\", \"2\", \"0.009302325581395349\"], [\"BeanShellAction\", \"4\", \"0.018604651162790697\"], [\"Anchor\", \"8\", \"0.037209302325581395\"], [\"ScrollLineCount\", \"14\", \"0.06511627906976744\"], [\"FirstLine\", \"20\", \"0.09302325581395349\"], [\"PaintLineBackground\", \"4\", \"0.018604651162790697\"], [\"MouseWheelHandler\", \"4\", \"0.018604651162790697\"], [\"Word\", \"2\", \"0.009302325581395349\"], [\"ViewConfig\", \"2\", \"0.009302325581395349\"], [\"PerspectiveHandler\", \"2\", \"0.009302325581395349\"], [\"EditServer\", \"4\", \"0.018604651162790697\"], [\"PerspectiveManager\", \"2\", \"0.009302325581395349\"], [\"Range\", \"3\", \"0.013953488372093023\"], [\"EnhancedCheckBoxMenuItem\", \"2\", \"0.009302325581395349\"], [\"EnhancedMenuItem\", \"2\", \"0.009302325581395349\"], [\"EBMessage\", \"2\", \"0.009302325581395349\"], [\"BufferChangeListener\", \"9\", \"0.04186046511627907\"], [\"BufferChangeAdapter\", \"9\", \"0.04186046511627907\"], [\"Rect\", \"3\", \"0.013953488372093023\"], [\"ListHandler\", \"2\", \"0.009302325581395349\"], [\"BrowserHandler\", \"6\", \"0.027906976744186046\"], [\"ManagePanel\", \"6\", \"0.027906976744186046\"], [\"VFSFileNameField\", \"6\", \"0.027906976744186046\"], [\"Debug\", \"5\", \"0.023255813953488372\"], [\"PluginsMenuButton\", \"2\", \"0.009302325581395349\"], [\"VFSDirectoryEntryTable\", \"10\", \"0.046511627906976744\"], [\"PluginManagerOptionPane\", \"2\", \"0.009302325581395349\"], [\"MirrorModel\", \"2\", \"0.009302325581395349\"], [\"DownloadMirrorsThread\", \"2\", \"0.009302325581395349\"], [\"MirrorList\", \"2\", \"0.009302325581395349\"], [\"VFSDirectoryEntryCellRenderer\", \"2\", \"0.009302325581395349\"], [\"VFSDirectoryEntryTableModel\", \"4\", \"0.018604651162790697\"], [\"VFS\", \"9\", \"0.04186046511627907\"], [\"VFSManager\", \"2\", \"0.009302325581395349\"], [\"DirectoryEntry\", \"5\", \"0.023255813953488372\"], [\"OperatingSystem\", \"2\", \"0.009302325581395349\"], [\"OptionGroup\", \"2\", \"0.009302325581395349\"], [\"OptionTreeModel\", \"2\", \"0.009302325581395349\"], [\"PaneNameRenderer\", \"2\", \"0.009302325581395349\"], [\"GetFileTypeRequest\", \"2\", \"0.009302325581395349\"], [\"QuickNotepadPlugin\", \"2\", \"0.009302325581395349\"], [\"HistoryModel\", \"4\", \"0.018604651162790697\"], [\"Listener\", \"2\", \"0.009302325581395349\"], [\"Recorder\", \"8\", \"0.037209302325581395\"], [\"Registers\", \"2\", \"0.009302325581395349\"], [\"EnhancedMenu\", \"2\", \"0.009302325581395349\"], [\"KeyEventWorkaround\", \"8\", \"0.037209302325581395\"], [\"WorkThreadPool\", \"2\", \"0.009302325581395349\"], [\"RingListModel\", \"2\", \"0.009302325581395349\"], [\"DirectoryLoadedAWTRequest\", \"4\", \"0.018604651162790697\"], [\"EditBusStub\", \"4\", \"0.018604651162790697\"], [\"CompoundEdit\", \"2\", \"0.009302325581395349\"], [\"RecentFilesProvider\", \"2\", \"0.009302325581395349\"], [\"PasteFromListDialog\", \"2\", \"0.009302325581395349\"], [\"PaintWrapGuide\", \"4\", \"0.018604651162790697\"], [\"KeywordMap\", \"2\", \"0.009302325581395349\"], [\"InputPane\", \"2\", \"0.009302325581395349\"], [\"PosBottomHalf\", \"5\", \"0.023255813953488372\"], [\"KeyEventTranslator\", \"5\", \"0.023255813953488372\"], [\"RemoveButton\", \"5\", \"0.023255813953488372\"], [\"PositionManager\", \"3\", \"0.013953488372093023\"], [\"StructureMatcher\", \"2\", \"0.009302325581395349\"], [\"ParentMouseHandler\", \"2\", \"0.009302325581395349\"], [\"NameSpace\", \"2\", \"0.009302325581395349\"], [\"CommandPathEntry\", \"2\", \"0.009302325581395349\"], [\"Factory\", \"2\", \"0.009302325581395349\"], [\"FavoritesEntry\", \"2\", \"0.009302325581395349\"], [\"DropHandler\", \"2\", \"0.009302325581395349\"], [\"TextAreaTransferHandler\", \"6\", \"0.027906976744186046\"], [\"Java14\", \"2\", \"0.009302325581395349\"], [\"TextAreaSelection\", \"2\", \"0.009302325581395349\"], [\"LocalDirectoryEntry\", \"2\", \"0.009302325581395349\"], [\"TextAreaDialog\", \"2\", \"0.009302325581395349\"], [\"TokenHandler\", \"2\", \"0.009302325581395349\"], [\"DefaultTokenHandler\", \"2\", \"0.009302325581395349\"], [\"DummyTokenHandler\", \"2\", \"0.009302325581395349\"], [\"LineInfo\", \"6\", \"0.027906976744186046\"], [\"WorkThreadHandler\", \"2\", \"0.009302325581395349\"], [\"XmlParser\", \"1\", \"0.004651162790697674\"], [\"BufferListSet\", \"1\", \"0.004651162790697674\"], [\"LineManager\", \"2\", \"0.009302325581395349\"], [\"HistoryTextArea\", \"2\", \"0.009302325581395349\"], [\"PaintText\", \"2\", \"0.009302325581395349\"], [\"Entry\", \"3\", \"0.013953488372093023\"], [\"LocalFile\", \"1\", \"0.004651162790697674\"], [\"BufferInsertRequest\", \"1\", \"0.004651162790697674\"], [\"BufferAutosaveRequest\", \"1\", \"0.004651162790697674\"], [\"BufferLoadRequest\", \"2\", \"0.009302325581395349\"], [\"IndentAction\", \"4\", \"0.018604651162790697\"], [\"FastRepaintManager\", \"2\", \"0.009302325581395349\"], [\"IndentRuleFactory\", \"4\", \"0.018604651162790697\"], [\"RegexpIndentRule\", \"6\", \"0.027906976744186046\"], [\"BracketIndentRule\", \"6\", \"0.027906976744186046\"], [\"IndentRule\", \"6\", \"0.027906976744186046\"], [\"CloseBracketIndentRule\", \"6\", \"0.027906976744186046\"], [\"OpenBracketIndentRule\", \"6\", \"0.027906976744186046\"], [\"Increase\", \"4\", \"0.018604651162790697\"], [\"AlignBracket\", \"4\", \"0.018604651162790697\"], [\"Decrease\", \"2\", \"0.009302325581395349\"], [\"Collapse\", \"2\", \"0.009302325581395349\"], [\"Reset\", \"2\", \"0.009302325581395349\"], [\"AbbrevsModel\", \"1\", \"0.004651162790697674\"], [\"TextAreaHighlight\", \"1\", \"0.004651162790697674\"], [\"AbbrevEditor\", \"1\", \"0.004651162790697674\"], [\"AddAbbrevDialog\", \"1\", \"0.004651162790697674\"], [\"AbbrevsOptionPane\", \"3\", \"0.013953488372093023\"], [\"EditAbbrevDialog\", \"1\", \"0.004651162790697674\"], [\"TreeSelectionHandler\", \"1\", \"0.004651162790697674\"], [\"SelectionHandler\", \"1\", \"0.004651162790697674\"], [\"ShortcutsOptionPane\", \"1\", \"0.004651162790697674\"], [\"HyperSearchResult\", \"3\", \"0.013953488372093023\"], [\"WindowTableModel\", \"1\", \"0.004651162790697674\"], [\"Token\", \"2\", \"0.009302325581395349\"], [\"SearchMatcher\", \"1\", \"0.004651162790697674\"], [\"SettingsActionHandler\", \"1\", \"0.004651162790697674\"], [\"BoyerMooreSearchMatcher\", \"1\", \"0.004651162790697674\"], [\"TokenList\", \"1\", \"0.004651162790697674\"], [\"RESearchMatcher\", \"1\", \"0.004651162790697674\"], [\"BrowserColorsModel\", \"1\", \"0.004651162790697674\"], [\"BrowserColorsOptionPane\", \"1\", \"0.004651162790697674\"], [\"FoldListener\", \"1\", \"0.004651162790697674\"], [\"FoldHandler\", \"1\", \"0.004651162790697674\"], [\"ExplicitFoldHandler\", \"1\", \"0.004651162790697674\"], [\"IndentFoldHandler\", \"1\", \"0.004651162790697674\"], [\"DummyFoldHandler\", \"1\", \"0.004651162790697674\"], [\"BufferUpdate\", \"2\", \"0.009302325581395349\"], [\"FoldVisibilityMap\", \"1\", \"0.004651162790697674\"], [\"CustomButton\", \"1\", \"0.004651162790697674\"], [\"LineElement\", \"1\", \"0.004651162790697674\"], [\"RootElement\", \"1\", \"0.004651162790697674\"], [\"ReadWriteLock\", \"2\", \"0.009302325581395349\"], [\"SegmentBuffer\", \"1\", \"0.004651162790697674\"], [\"SelectLineRange\", \"1\", \"0.004651162790697674\"], [\"FloatingWindowContainer\", \"1\", \"0.004651162790697674\"], [\"CurrentDirectoryMenu\", \"2\", \"0.009302325581395349\"], [\"RecentFilesMenu\", \"2\", \"0.009302325581395349\"], [\"RecentDirectoriesMenu\", \"2\", \"0.009302325581395349\"], [\"TreeHandler\", \"1\", \"0.004651162790697674\"], [\"LoadSaveOptionPane\", \"1\", \"0.004651162790697674\"], [\"SwingInstall\", \"2\", \"0.009302325581395349\"], [\"OpenWithEncodingMenu\", \"1\", \"0.004651162790697674\"], [\"TextPanel\", \"1\", \"0.004651162790697674\"], [\"ComponentHandler\", \"1\", \"0.004651162790697674\"], [\"MyFocusManager\", \"1\", \"0.004651162790697674\"], [\"TableMouseHandler\", \"1\", \"0.004651162790697674\"], [\"ClipboardRegister\", \"1\", \"0.004651162790697674\"], [\"MarkersSaveRequest\", \"1\", \"0.004651162790697674\"], [\"BufferOptionPane\", \"1\", \"0.004651162790697674\"], [\"ThreadAbortMonitor\", \"1\", \"0.004651162790697674\"]]"
        },
        {
            "content": "The co-change relationships for `Buffer.java` reveal several entities that are frequently modified together with `Buffer.java`. The confidence values indicate the likelihood of these files being changed in conjunction with `Buffer.java`. Based on this data, we should prioritize analyzing the impact of changes on entities with high confidence scores.\n\nHere are some observations from the results:\n1. **JEditTextArea (0.5814)**: This file has the highest confidence score, meaning it is highly coupled with `Buffer.java`. Changes to `Buffer.java` likely affect `JEditTextArea`.\n2. **jEdit (0.2419)**: As the core class of the application, it's expected to be tightly coupled with `Buffer.java`.\n3. **VFSBrowser (0.1814), ChunkCache (0.1814), MouseHandler (0.1907), OffsetManager (0.1907), DisplayManager (0.1674), BufferChangeHandler (0.1674)**: These classes have relatively high confidence values and may also need synchronization.\n4. **Others**: Many other files like `TextAreaPainter`, `EditPane`, etc., show moderate coupling and might also require analysis.\n\nTo proceed, I will analyze one of the most significant co-changed entities using additional tools to understand deeper dependencies. Let's first check coupling dependencies between `Buffer.java` and `JEditTextArea.java` since it has the highest confidence value.\n\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_f813d5b70d11482b8ba699",
                    "function": {
                        "arguments": "{\"entity1\": \"Buffer.java\", \"entity2\": \"JEditTextArea.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"There are no coupling dependencies between these two entities\"]"
        },
        {
            "content": "There are no direct coupling dependencies between `Buffer.java` and `JEditTextArea.java`. This suggests that the co-change relationship might be due to indirect interactions or shared functionality through other entities.\n\nLet's analyze the conceptual coupling (semantic similarity) between these two files to understand if they share common functionalities or themes. This can help determine why they are frequently co-changed.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_b35888c3b30c4a7b9c2660",
                    "function": {
                        "arguments": "{\"entity1\": \"Buffer.java\", \"entity2\": \"JEditTextArea.java\"}",
                        "name": "get_conceptual_coupling"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_conceptual_coupling",
            "content": "\"0.6836691\""
        },
        {
            "content": "The conceptual coupling (semantic similarity) between `Buffer.java` and `JEditTextArea.java` is approximately **0.6837**, which indicates a moderate level of semantic similarity. This suggests that, while there are no direct coupling dependencies, the two entities share some common themes or functionalities.\n\nThis moderate conceptual coupling could explain why these files are frequently co-changed\u2014changes in one might necessitate changes in the other due to shared logic or responsibilities, even if they do not directly reference each other.\n\nNext, let's examine the call graph for `Buffer.java` to understand what other entities it interacts with directly. This will help us identify potential ripple effects of a change in `Buffer.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_022dbe4b289e4e319ece0e",
                    "function": {
                        "arguments": "{\"entity\": \"Buffer.java\"}",
                        "name": "get_call_graph"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_call_graph",
            "content": "[\"RESearchMatcher\", \"VFSBrowser\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]"
        },
        {
            "content": "The call graph for `Buffer.java` shows that it directly interacts with entities such as `RESearchMatcher` and `VFSBrowser`. Some entries in the call graph appear to be empty or invalid, which could indicate parsing issues or lack of clear references.\n\nGiven this information, we should investigate the coupling dependencies between `Buffer.java` and `VFSBrowser.java`, as it is both a direct dependency (from the call graph) and shows a relatively high co-change confidence (0.1814). This will help us understand if there are direct structural dependencies between these two files.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_bafadb4c18cf42bd98a75a",
                    "function": {
                        "arguments": "{\"entity1\": \"Buffer.java\", \"entity2\": \"VFSBrowser.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"There are no coupling dependencies between these two entities\"]"
        },
        {
            "content": "Similar to the case with `JEditTextArea.java`, there are no direct coupling dependencies between `Buffer.java` and `VFSBrowser.java`. However, `VFSBrowser.java` appears in both the co-change relationships and the call graph of `Buffer.java`, suggesting an indirect or runtime dependency.\n\nTo better understand the potential impact of changes to `Buffer.java`, it would be useful to examine its source code. This will help identify any implicit dependencies, semantic overlaps, or runtime interactions that may not be captured by structural analysis tools.\n\nLet's retrieve the source code for `Buffer.java` now.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_a59e1990382e4a1d83afcc",
                    "function": {
                        "arguments": "{\"entity\": \"Buffer.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package org.gjt.sp.jedit;\\nimport gnu.regexp.*;\\nimport javax.swing.*;\\nimport javax.swing.text.*;\\nimport java.awt.Toolkit;\\nimport java.io.File;\\nimport java.io.IOException;\\nimport java.net.Socket;\\nimport java.util.*;\\nimport org.gjt.sp.jedit.browser.VFSBrowser;\\nimport org.gjt.sp.jedit.buffer.*;\\nimport org.gjt.sp.jedit.io.*;\\nimport org.gjt.sp.jedit.msg.*;\\nimport org.gjt.sp.jedit.search.RESearchMatcher;\\nimport org.gjt.sp.jedit.syntax.*;\\nimport org.gjt.sp.jedit.textarea.*;\\nimport org.gjt.sp.util.*;\\npublic class Buffer\\n{\\n\\tpublic static final String LINESEP = \\\"lineSeparator\\\";\\n\\tpublic static final String BACKED_UP = \\\"Buffer__backedUp\\\";\\n\\tpublic static final String CARET = \\\"Buffer__caret\\\";\\n\\tpublic static final String SELECTION = \\\"Buffer__selection\\\";\\n\\tpublic static final String SCROLL_VERT = \\\"Buffer__scrollVert\\\";\\n\\tpublic static final String SCROLL_HORIZ = \\\"Buffer__scrollHoriz\\\";\\n\\tpublic static final String ENCODING = \\\"encoding\\\";\\n\\tpublic static final String TRAILING_EOL = \\\"trailingEOL\\\";\\n\\tpublic static final String GZIPPED = \\\"gzipped\\\";\\n\\tpublic void showInsertFileDialog(View view)\\n\\t{\\n\\t\\tString[] files = GUIUtilities.showVFSFileDialog(view,null,\\n\\t\\t\\tVFSBrowser.OPEN_DIALOG,false);\\n\\t\\tif(files != null)\\n\\t\\t\\tinsertFile(view,files[0]);\\n\\t} \\n\\tpublic void reload(View view)\\n\\t{\\n\\t\\tif(getFlag(DIRTY))\\n\\t\\t{\\n\\t\\t\\tString[] args = { name };\\n\\t\\t\\tint result = GUIUtilities.confirm(view,\\\"changedreload\\\",\\n\\t\\t\\t\\targs,JOptionPane.YES_NO_OPTION,\\n\\t\\t\\t\\tJOptionPane.WARNING_MESSAGE);\\n\\t\\t\\tif(result != JOptionPane.YES_OPTION)\\n\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tview.getEditPane().saveCaretInfo();\\n\\t\\tload(view,true);\\n\\t} \\n\\tpublic boolean load(final View view, final boolean reload)\\n\\t{\\n\\t\\tif(isPerformingIO())\\n\\t\\t{\\n\\t\\t\\tGUIUtilities.error(view,\\\"buffer-multiple-io\\\",null);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tsetBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);\\n\\t\\tsetFlag(LOADING,true);\\n\\t\\t\\t\\t\\t\\t\\t\\tif(!getFlag(TEMPORARY))\\n\\t\\t\\tEditBus.send(new BufferUpdate(this,view,BufferUpdate.LOAD_STARTED));\\n\\t\\tfinal boolean loadAutosave;\\n\\t\\tif(reload || !getFlag(NEW_FILE))\\n\\t\\t{\\n\\t\\t\\tif(file != null)\\n\\t\\t\\t\\tmodTime = file.lastModified();\\n\\t\\t\\t\\t\\t\\tif(!reload && autosaveFile != null && autosaveFile.exists())\\n\\t\\t\\t\\tloadAutosave = recoverAutosave(view);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(autosaveFile != null)\\n\\t\\t\\t\\t\\tautosaveFile.delete();\\n\\t\\t\\t\\tloadAutosave = false;\\n\\t\\t\\t}\\n\\t\\t\\tif(!loadAutosave)\\n\\t\\t\\t{\\n\\t\\t\\t\\tVFS vfs = VFSManager.getVFSForPath(path);\\n\\t\\t\\t\\tif(!checkFileForLoad(view,vfs,path))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsetFlag(LOADING,false);\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(isNewFile())\\n\\t\\t\\t\\t\\t;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!vfs.load(view,this,path))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tsetFlag(LOADING,false);\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tloadAutosave = false;\\n\\t\\t\\t\\tRunnable runnable = new Runnable()\\n\\t\\t{\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\tString newPath = getStringProperty(\\n\\t\\t\\t\\t\\tBufferIORequest.NEW_PATH);\\n\\t\\t\\t\\tSegment seg = (Segment)getProperty(\\n\\t\\t\\t\\t\\tBufferIORequest.LOAD_DATA);\\n\\t\\t\\t\\tIntegerArray endOffsets = (IntegerArray)\\n\\t\\t\\t\\t\\tgetProperty(BufferIORequest.END_OFFSETS);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tboolean readOnly = isReadOnly();\\n\\t\\t\\t\\tsetFlag(READ_ONLY,false);\\n\\t\\t\\t\\t\\t\\t\\t\\tremove(0,getLength());\\n\\t\\t\\t\\tif(seg == null)\\n\\t\\t\\t\\t\\tseg = new Segment(new char[1024],0,0);\\n\\t\\t\\t\\tif(endOffsets == null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tendOffsets = new IntegerArray();\\n\\t\\t\\t\\t\\tendOffsets.add(1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twriteLock();\\n\\t\\t\\t\\t\\tif(contentMgr.getLength() != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tfirePreContentRemoved(0,0,\\n\\t\\t\\t\\t\\t\\t\\toffsetMgr.getLineCount(),\\n\\t\\t\\t\\t\\t\\t\\tcontentMgr.getLength() - 1);\\n\\t\\t\\t\\t\\t\\tfireContentRemoved(0,0,\\n\\t\\t\\t\\t\\t\\t\\toffsetMgr.getLineCount(),\\n\\t\\t\\t\\t\\t\\t\\tcontentMgr.getLength() - 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcontentMgr._setContent(seg.array,seg.count);\\n\\t\\t\\t\\t\\toffsetMgr._contentInserted(endOffsets);\\n\\t\\t\\t\\t\\tfireContentInserted(0,0,\\n\\t\\t\\t\\t\\t\\tendOffsets.getSize() - 1,\\n\\t\\t\\t\\t\\t\\tseg.count - 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfinally\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twriteUnlock();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsetFlag(READ_ONLY,readOnly);\\n\\t\\t\\t\\tunsetProperty(BufferIORequest.LOAD_DATA);\\n\\t\\t\\t\\tunsetProperty(BufferIORequest.END_OFFSETS);\\n\\t\\t\\t\\tunsetProperty(BufferIORequest.NEW_PATH);\\n\\t\\t\\t\\tundoMgr.clear();\\n\\t\\t\\t\\tundoMgr.setLimit(jEdit.getIntegerProperty(\\n\\t\\t\\t\\t\\t\\\"buffer.undoCount\\\",100));\\n\\t\\t\\t\\tif(!getFlag(TEMPORARY))\\n\\t\\t\\t\\t\\tfinishLoading();\\n\\t\\t\\t\\tsetFlag(LOADING,false);\\n\\t\\t\\t\\t\\t\\t\\t\\tif(reload)\\n\\t\\t\\t\\t\\tsetDirty(false);\\n\\t\\t\\t\\tif(!loadAutosave && newPath != null)\\n\\t\\t\\t\\t\\tsetPath(newPath);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(loadAutosave)\\n\\t\\t\\t\\t\\tsetFlag(DIRTY,true);\\n\\t\\t\\t\\t\\t\\t\\t\\tif(!getFlag(TEMPORARY))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tEditBus.send(new BufferUpdate(Buffer.this,\\n\\t\\t\\t\\t\\t\\tview,BufferUpdate.LOADED));\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}; \\n\\t\\tif(getFlag(TEMPORARY))\\n\\t\\t\\trunnable.run();\\n\\t\\telse\\n\\t\\t\\tVFSManager.runInAWTThread(runnable);\\n\\t\\treturn true;\\n\\t} \\n\\tpublic boolean insertFile(final View view, String path)\\n\\t{\\n\\t\\tif(isPerformingIO())\\n\\t\\t{\\n\\t\\t\\tGUIUtilities.error(view,\\\"buffer-multiple-io\\\",null);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tsetBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);\\n\\t\\tpath = MiscUtilities.constructPath(this.path,path);\\n\\t\\tBuffer buffer = jEdit.getBuffer(path);\\n\\t\\tif(buffer != null)\\n\\t\\t{\\n\\t\\t\\tview.getTextArea().setSelectedText(\\n\\t\\t\\t\\tbuffer.getText(0,buffer.getLength()));\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tVFS vfs = VFSManager.getVFSForPath(path);\\n\\t\\tsetFlag(IO,true);\\n\\t\\t\\t\\t\\t\\t\\t\\tif(!vfs.insert(view,this,path))\\n\\t\\t{\\n\\t\\t\\tsetFlag(IO,false);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\t\\tVFSManager.runInAWTThread(new Runnable()\\n\\t\\t{\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFlag(IO,false);\\n\\t\\t\\t\\tSegmentBuffer sbuf = (SegmentBuffer)getProperty(\\n\\t\\t\\t\\t\\tBufferIORequest.LOAD_DATA);\\n\\t\\t\\t\\tif(sbuf != null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tunsetProperty(BufferIORequest.LOAD_DATA);\\n\\t\\t\\t\\t\\tview.getTextArea().setSelectedText(sbuf.toString());\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\treturn true;\\n\\t} \\n\\tpublic void autosave()\\n\\t{\\n\\t\\tif(autosaveFile == null || !getFlag(AUTOSAVE_DIRTY)\\n\\t\\t\\t|| !getFlag(DIRTY)\\n\\t\\t\\t|| getFlag(LOADING)\\n\\t\\t\\t|| getFlag(IO))\\n\\t\\t\\treturn;\\n\\t\\tsetFlag(AUTOSAVE_DIRTY,false);\\n\\t\\tVFSManager.runInWorkThread(new BufferIORequest(\\n\\t\\t\\tBufferIORequest.AUTOSAVE,null,this,null,\\n\\t\\t\\tVFSManager.getFileVFS(),autosaveFile.getPath()));\\n\\t} \\n\\tpublic boolean saveAs(View view, boolean rename)\\n\\t{\\n\\t\\tString[] files = GUIUtilities.showVFSFileDialog(view,path,\\n\\t\\t\\tVFSBrowser.SAVE_DIALOG,false);\\n\\t\\t\\t\\t\\t\\tif(files == null)\\n\\t\\t\\treturn false;\\n\\t\\treturn save(view,files[0],rename);\\n\\t} \\n\\tpublic boolean save(View view, String path)\\n\\t{\\n\\t\\treturn save(view,path,true);\\n\\t} \\n\\tpublic boolean save(final View view, String path, final boolean rename)\\n\\t{\\n\\t\\tif(isPerformingIO())\\n\\t\\t{\\n\\t\\t\\tGUIUtilities.error(view,\\\"buffer-multiple-io\\\",null);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tsetBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);\\n\\t\\tif(path == null && getFlag(NEW_FILE))\\n\\t\\t\\treturn saveAs(view,rename);\\n\\t\\tif(path == null && file != null)\\n\\t\\t{\\n\\t\\t\\tlong newModTime = file.lastModified();\\n\\t\\t\\tif(newModTime != modTime\\n\\t\\t\\t\\t&& jEdit.getBooleanProperty(\\\"view.checkModStatus\\\"))\\n\\t\\t\\t{\\n\\t\\t\\t\\tObject[] args = { this.path };\\n\\t\\t\\t\\tint result = GUIUtilities.confirm(view,\\n\\t\\t\\t\\t\\t\\\"filechanged-save\\\",args,\\n\\t\\t\\t\\t\\tJOptionPane.YES_NO_OPTION,\\n\\t\\t\\t\\t\\tJOptionPane.WARNING_MESSAGE);\\n\\t\\t\\t\\tif(result != JOptionPane.YES_OPTION)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsetFlag(IO,true);\\n\\t\\tEditBus.send(new BufferUpdate(this,view,BufferUpdate.SAVING));\\n\\t\\tfinal String oldPath = this.path;\\n\\t\\tfinal String newPath = (path == null ? this.path : path);\\n\\t\\tVFS vfs = VFSManager.getVFSForPath(newPath);\\n\\t\\tif(!checkFileForSave(view,vfs,newPath))\\n\\t\\t{\\n\\t\\t\\tsetFlag(IO,false);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tif(!vfs.save(view,this,newPath))\\n\\t\\t{\\n\\t\\t\\tsetFlag(IO,false);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\t\\tVFSManager.runInAWTThread(new Runnable()\\n\\t\\t{\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFlag(IO,false);\\n\\t\\t\\t\\tfinishSaving(view,oldPath,newPath,rename,\\n\\t\\t\\t\\t\\tgetBooleanProperty(BufferIORequest\\n\\t\\t\\t\\t\\t.ERROR_OCCURRED));\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\treturn true;\\n\\t} \\n\\t\\tpublic static final int FILE_NOT_CHANGED = 0;\\n\\tpublic static final int FILE_CHANGED = 1;\\n\\tpublic static final int FILE_DELETED = 2;\\n\\tpublic int checkFileStatus(View view)\\n\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(!getFlag(IO) && !getFlag(LOADING) && file != null\\n\\t\\t\\t&& !getFlag(NEW_FILE))\\n\\t\\t{\\n\\t\\t\\tboolean newReadOnly = (file.exists() && !file.canWrite());\\n\\t\\t\\tif(newReadOnly != getFlag(READ_ONLY))\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFlag(READ_ONLY,newReadOnly);\\n\\t\\t\\t\\tEditBus.send(new BufferUpdate(this,null,\\n\\t\\t\\t\\t\\tBufferUpdate.DIRTY_CHANGED));\\n\\t\\t\\t}\\n\\t\\t\\tlong oldModTime = modTime;\\n\\t\\t\\tlong newModTime = file.lastModified();\\n\\t\\t\\tif(newModTime != oldModTime)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmodTime = newModTime;\\n\\t\\t\\t\\tif(!file.exists())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsetFlag(NEW_FILE,true);\\n\\t\\t\\t\\t\\tsetDirty(true);\\n\\t\\t\\t\\t\\treturn FILE_DELETED;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn FILE_CHANGED;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn FILE_NOT_CHANGED;\\n\\t} \\n\\tpublic long getLastModified()\\n\\t{\\n\\t\\treturn modTime;\\n\\t} \\n\\tpublic void setLastModified(long modTime)\\n\\t{\\n\\t\\tthis.modTime = modTime;\\n\\t} \\n\\tpublic VFS getVFS()\\n\\t{\\n\\t\\treturn VFSManager.getVFSForPath(path);\\n\\t} \\n\\tpublic final File getAutosaveFile()\\n\\t{\\n\\t\\treturn autosaveFile;\\n\\t} \\n\\tpublic final String getName()\\n\\t{\\n\\t\\treturn name;\\n\\t} \\n\\tpublic final String getPath()\\n\\t{\\n\\t\\treturn path;\\n\\t} \\n\\tpublic final String getSymlinkPath()\\n\\t{\\n\\t\\treturn symlinkPath;\\n\\t} \\n\\tpublic String getDirectory()\\n\\t{\\n\\t\\treturn directory;\\n\\t} \\n\\tpublic final boolean isClosed()\\n\\t{\\n\\t\\treturn getFlag(CLOSED);\\n\\t} \\n\\tpublic final boolean isLoaded()\\n\\t{\\n\\t\\treturn !getFlag(LOADING);\\n\\t} \\n\\tpublic final boolean isPerformingIO()\\n\\t{\\n\\t\\treturn getFlag(LOADING) || getFlag(IO);\\n\\t} \\n\\tpublic final boolean isNewFile()\\n\\t{\\n\\t\\treturn getFlag(NEW_FILE);\\n\\t} \\n\\tpublic final void setNewFile(boolean newFile)\\n\\t{\\n\\t\\tsetFlag(NEW_FILE,newFile);\\n\\t\\tif(!newFile)\\n\\t\\t\\tsetFlag(UNTITLED,false);\\n\\t} \\n\\tpublic final boolean isUntitled()\\n\\t{\\n\\t\\treturn getFlag(UNTITLED);\\n\\t} \\n\\tpublic final boolean isDirty()\\n\\t{\\n\\t\\treturn getFlag(DIRTY);\\n\\t} \\n\\tpublic final boolean isReadOnly()\\n\\t{\\n\\t\\treturn getFlag(READ_ONLY);\\n\\t} \\n\\tpublic final boolean isEditable()\\n\\t{\\n\\t\\treturn !(getFlag(READ_ONLY) || getFlag(IO) || getFlag(LOADING));\\n\\t} \\n\\tpublic final void setReadOnly(boolean readOnly)\\n\\t{\\n\\t\\tsetFlag(READ_ONLY,readOnly);\\n\\t} \\n\\tpublic void setDirty(boolean d)\\n\\t{\\n\\t\\tboolean old_d = getFlag(DIRTY);\\n\\t\\tif(d)\\n\\t\\t{\\n\\t\\t\\tif(getFlag(LOADING) || getFlag(READ_ONLY))\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(getFlag(DIRTY) && getFlag(AUTOSAVE_DIRTY))\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tsetFlag(DIRTY,true);\\n\\t\\t\\tsetFlag(AUTOSAVE_DIRTY,true);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tsetFlag(DIRTY,false);\\n\\t\\t\\tsetFlag(AUTOSAVE_DIRTY,false);\\n\\t\\t\\tif(autosaveFile != null)\\n\\t\\t\\t\\tautosaveFile.delete();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(!getFlag(UNDO_IN_PROGRESS))\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tundoMgr.bufferSaved();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(d != old_d)\\n\\t\\t{\\n\\t\\t\\tEditBus.send(new BufferUpdate(this,null,\\n\\t\\t\\t\\tBufferUpdate.DIRTY_CHANGED));\\n\\t\\t}\\n\\t} \\n\\tpublic boolean isTemporary()\\n\\t{\\n\\t\\treturn getFlag(TEMPORARY);\\n\\t} \\n\\tpublic Icon getIcon()\\n\\t{\\n\\t\\tif(getFlag(DIRTY))\\n\\t\\t\\treturn GUIUtilities.DIRTY_BUFFER_ICON;\\n\\t\\telse if(getFlag(READ_ONLY))\\n\\t\\t\\treturn GUIUtilities.READ_ONLY_BUFFER_ICON;\\n\\t\\telse if(getFlag(NEW_FILE))\\n\\t\\t\\treturn GUIUtilities.NEW_BUFFER_ICON;\\n\\t\\telse\\n\\t\\t\\treturn GUIUtilities.NORMAL_BUFFER_ICON;\\n\\t} \\n\\tpublic final void readLock()\\n\\t{\\n\\t\\tlock.readLock();\\n\\t} \\n\\tpublic final void readUnlock()\\n\\t{\\n\\t\\tlock.readUnlock();\\n\\t} \\n\\tpublic final void writeLock()\\n\\t{\\n\\t\\tlock.writeLock();\\n\\t} \\n\\tpublic final void writeUnlock()\\n\\t{\\n\\t\\tlock.writeUnlock();\\n\\t} \\n\\tpublic int getLength()\\n\\t{\\n\\t\\t\\t\\treturn contentMgr.getLength();\\n\\t} \\n\\tpublic int getLineCount()\\n\\t{\\n\\t\\t\\t\\treturn offsetMgr.getLineCount();\\n\\t} \\n\\tpublic final int getLineOfOffset(int offset)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tif(offset < 0 || offset > getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(offset);\\n\\t\\t\\treturn offsetMgr.getLineOfOffset(offset);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic int getLineStartOffset(int line)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tif(line < 0 || line >= offsetMgr.getLineCount())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(line);\\n\\t\\t\\telse if(line == 0)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\treturn offsetMgr.getLineEndOffset(line - 1);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic int getLineEndOffset(int line)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tif(line < 0 || line >= offsetMgr.getLineCount())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(line);\\n\\t\\t\\treturn offsetMgr.getLineEndOffset(line);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic int getLineLength(int line)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\treturn getLineEndOffset(line)\\n\\t\\t\\t\\t- getLineStartOffset(line) - 1;\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic String getLineText(int lineIndex)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\treturn getText(getLineStartOffset(lineIndex),\\n\\t\\t\\t\\tgetLineLength(lineIndex));\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void getLineText(int lineIndex, Segment segment)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tgetText(getLineStartOffset(lineIndex),\\n\\t\\t\\t\\tgetLineLength(lineIndex),segment);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic String getText(int start, int length)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tif(start < 0 || length < 0\\n\\t\\t\\t\\t|| start + length > contentMgr.getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(start + \\\":\\\" + length);\\n\\t\\t\\treturn contentMgr.getText(start,length);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void getText(int start, int length, Segment seg)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tif(start < 0 || length < 0\\n\\t\\t\\t\\t|| start + length > contentMgr.getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(start + \\\":\\\" + length);\\n\\t\\t\\tcontentMgr.getText(start,length,seg);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void insert(int offset, String str)\\n\\t{\\n\\t\\tif(str == null)\\n\\t\\t\\treturn;\\n\\t\\tint len = str.length();\\n\\t\\tif(len == 0)\\n\\t\\t\\treturn;\\n\\t\\tif(isReadOnly())\\n\\t\\t\\tthrow new RuntimeException(\\\"buffer read-only\\\");\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tif(offset < 0 || offset > contentMgr.getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(offset);\\n\\t\\t\\tcontentMgr.insert(offset,str);\\n\\t\\t\\tintegerArray.clear();\\n\\t\\t\\tfor(int i = 0; i < len; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(str.charAt(i) == '\\\\n')\\n\\t\\t\\t\\t\\tintegerArray.add(i + 1);\\n\\t\\t\\t}\\n\\t\\t\\tif(!getFlag(UNDO_IN_PROGRESS))\\n\\t\\t\\t{\\n\\t\\t\\t\\tundoMgr.contentInserted(offset,len,str,\\n\\t\\t\\t\\t\\t!getFlag(DIRTY));\\n\\t\\t\\t}\\n\\t\\t\\tcontentInserted(offset,len,integerArray);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void insert(int offset, Segment seg)\\n\\t{\\n\\t\\tif(seg.count == 0)\\n\\t\\t\\treturn;\\n\\t\\tif(isReadOnly())\\n\\t\\t\\tthrow new RuntimeException(\\\"buffer read-only\\\");\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tif(offset < 0 || offset > contentMgr.getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(offset);\\n\\t\\t\\tcontentMgr.insert(offset,seg);\\n\\t\\t\\tintegerArray.clear();\\n\\t\\t\\tfor(int i = 0; i < seg.count; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(seg.array[seg.offset + i] == '\\\\n')\\n\\t\\t\\t\\t\\tintegerArray.add(i + 1);\\n\\t\\t\\t}\\n\\t\\t\\tif(!getFlag(UNDO_IN_PROGRESS))\\n\\t\\t\\t{\\n\\t\\t\\t\\tundoMgr.contentInserted(offset,seg.count,\\n\\t\\t\\t\\t\\tseg.toString(),!getFlag(DIRTY));\\n\\t\\t\\t}\\n\\t\\t\\tcontentInserted(offset,seg.count,integerArray);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void remove(int offset, int length)\\n\\t{\\n\\t\\tif(length == 0)\\n\\t\\t\\treturn;\\n\\t\\tif(isReadOnly())\\n\\t\\t\\tthrow new RuntimeException(\\\"buffer read-only\\\");\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tif(offset < 0 || length < 0\\n\\t\\t\\t\\t|| offset + length > contentMgr.getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(offset + \\\":\\\" + length);\\n\\t\\t\\tint startLine = offsetMgr.getLineOfOffset(offset);\\n\\t\\t\\tcontentMgr.getText(offset,length,seg);\\n\\t\\t\\tint numLines = 0;\\n\\t\\t\\tfor(int i = 0; i < seg.count; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(seg.array[seg.offset + i] == '\\\\n')\\n\\t\\t\\t\\t\\tnumLines++;\\n\\t\\t\\t}\\n\\t\\t\\tif(!getFlag(UNDO_IN_PROGRESS))\\n\\t\\t\\t{\\n\\t\\t\\t\\tundoMgr.contentRemoved(offset,length,\\n\\t\\t\\t\\t\\tseg.toString(),!getFlag(DIRTY));\\n\\t\\t\\t}\\n\\t\\t\\tfirePreContentRemoved(startLine,offset,numLines,length);\\n\\t\\t\\tcontentMgr.remove(offset,length);\\n\\t\\t\\toffsetMgr.contentRemoved(startLine,offset,numLines,length);\\n\\t\\t\\tfireContentRemoved(startLine,offset,numLines,length);\\n\\t\\t\\tsetDirty(true);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void undo(JEditTextArea textArea)\\n\\t{\\n\\t\\tif(undoMgr == null)\\n\\t\\t\\treturn;\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\ttextArea.getToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tsetFlag(UNDO_IN_PROGRESS,true);\\n\\t\\t\\tif(!undoMgr.undo(textArea))\\n\\t\\t\\t\\ttextArea.getToolkit().beep();\\n\\t\\t\\tfireTransactionComplete();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tsetFlag(UNDO_IN_PROGRESS,false);\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void redo(JEditTextArea textArea)\\n\\t{\\n\\t\\tif(undoMgr == null)\\n\\t\\t\\treturn;\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tToolkit.getDefaultToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tsetFlag(UNDO_IN_PROGRESS,true);\\n\\t\\t\\tif(!undoMgr.redo(textArea))\\n\\t\\t\\t\\ttextArea.getToolkit().beep();\\n\\t\\t\\tfireTransactionComplete();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tsetFlag(UNDO_IN_PROGRESS,false);\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic boolean isTransactionInProgress()\\n\\t{\\n\\t\\treturn getFlag(UNDO_IN_PROGRESS) || insideCompoundEdit();\\n\\t} \\n\\tpublic void beginCompoundEdit()\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tundoMgr.beginCompoundEdit();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void endCompoundEdit()\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tundoMgr.endCompoundEdit();\\n\\t\\t\\tif(!insideCompoundEdit())\\n\\t\\t\\t\\tfireTransactionComplete();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t}\\n\\tpublic boolean insideCompoundEdit()\\n\\t{\\n\\t\\treturn undoMgr.insideCompoundEdit();\\n\\t} \\n\\t\\tpublic static final int NORMAL_PRIORITY = 0;\\n\\tpublic static final int HIGH_PRIORITY = 1;\\n\\tstatic class Listener\\n\\t{\\n\\t\\tBufferChangeListener listener;\\n\\t\\tint priority;\\n\\t\\tListener(BufferChangeListener listener, int priority)\\n\\t\\t{\\n\\t\\t\\tthis.listener = listener;\\n\\t\\t\\tthis.priority = priority;\\n\\t\\t}\\n\\t}\\n\\tpublic void addBufferChangeListener(BufferChangeListener listener,\\n\\t\\tint priority)\\n\\t{\\n\\t\\tListener l = new Listener(listener,priority);\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\tListener _l = (Listener)bufferListeners.get(i);\\n\\t\\t\\tif(_l.priority < priority)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbufferListeners.insertElementAt(l,i);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbufferListeners.addElement(l);\\n\\t} \\n\\tpublic void addBufferChangeListener(BufferChangeListener listener)\\n\\t{\\n\\t\\taddBufferChangeListener(listener,NORMAL_PRIORITY);\\n\\t} \\n\\tpublic void removeBufferChangeListener(BufferChangeListener listener)\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\tif(((Listener)bufferListeners.get(i)).listener == listener)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbufferListeners.removeElementAt(i);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic BufferChangeListener[] getBufferChangeListeners()\\n\\t{\\n\\t\\tBufferChangeListener[] returnValue\\n\\t\\t\\t= new BufferChangeListener[\\n\\t\\t\\tbufferListeners.size()];\\n\\t\\tfor(int i = 0; i < returnValue.length; i++)\\n\\t\\t{\\n\\t\\t\\treturnValue[i] = ((Listener)bufferListeners.get(i))\\n\\t\\t\\t\\t.listener;\\n\\t\\t}\\n\\t\\treturn returnValue;\\n\\t} \\n\\tpublic void propertiesChanged()\\n\\t{\\n\\t\\tString folding = getStringProperty(\\\"folding\\\");\\n\\t\\tFoldHandler handler = FoldHandler.getFoldHandler(folding);\\n\\t\\tif(handler != null)\\n\\t\\t{\\n\\t\\t\\tsetFoldHandler(handler);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif (folding != null)\\n\\t\\t\\t\\tLog.log(Log.WARNING, this, path + \\\": invalid 'folding' property: \\\" + folding); \\n\\t\\t\\tsetFoldHandler(new DummyFoldHandler());\\n\\t\\t}\\n\\t\\tEditBus.send(new BufferUpdate(this,null,BufferUpdate.PROPERTIES_CHANGED));\\n\\t\\tString newWrap = getStringProperty(\\\"wrap\\\");\\n\\t\\tif(wrap != null && !newWrap.equals(wrap))\\n\\t\\t{\\n\\t\\t\\toffsetMgr.invalidateScreenLineCounts();\\n\\t\\t\\tif(isLoaded())\\n\\t\\t\\t\\tfireWrapModeChanged();\\n\\t\\t}\\n\\t\\tthis.wrap = newWrap;\\n\\t} \\n\\tpublic int getTabSize()\\n\\t{\\n\\t\\treturn getIntegerProperty(\\\"tabSize\\\",8);\\n\\t} \\n\\tpublic final int getIndentSize()\\n\\t{\\n\\t\\treturn getIntegerProperty(\\\"indentSize\\\",8);\\n\\t} \\n\\tpublic Object getProperty(Object name)\\n\\t{\\n\\t\\tsynchronized(propertyLock)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tPropValue o = (PropValue)properties.get(name);\\n\\t\\t\\tif(o != null)\\n\\t\\t\\t\\treturn o.value;\\n\\t\\t\\t\\t\\t\\tif(!(name instanceof String))\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t\\t\\t\\tif(mode != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tObject retVal = mode.getProperty((String)name);\\n\\t\\t\\t\\tif(retVal == null)\\n\\t\\t\\t\\t\\treturn null;\\n\\t\\t\\t\\tproperties.put(name,new PropValue(retVal,true));\\n\\t\\t\\t\\treturn retVal;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tString value = jEdit.getProperty(\\\"buffer.\\\" + name);\\n\\t\\t\\t\\tif(value == null)\\n\\t\\t\\t\\t\\treturn null;\\n\\t\\t\\t\\t\\t\\t\\t\\tObject retVal;\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tretVal = new Integer(value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(NumberFormatException nf)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tretVal = value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tproperties.put(name,new PropValue(retVal,true));\\n\\t\\t\\t\\treturn retVal;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic void setProperty(String name, Object value)\\n\\t{\\n\\t\\tif(value == null)\\n\\t\\t\\tproperties.remove(name);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tPropValue test = (PropValue)properties.get(name);\\n\\t\\t\\tif(test == null)\\n\\t\\t\\t\\tproperties.put(name,new PropValue(value,false));\\n\\t\\t\\telse if(test.value.equals(value))\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\ttest.value = value;\\n\\t\\t\\t\\ttest.defaultValue = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic void unsetProperty(String name)\\n\\t{\\n\\t\\tproperties.remove(name);\\n\\t} \\n\\tpublic String getStringProperty(String name)\\n\\t{\\n\\t\\tObject obj = getProperty(name);\\n\\t\\tif(obj != null)\\n\\t\\t\\treturn obj.toString();\\n\\t\\telse\\n\\t\\t\\treturn null;\\n\\t} \\n\\tpublic void setStringProperty(String name, String value)\\n\\t{\\n\\t\\tsetProperty(name,value);\\n\\t} \\n\\tpublic boolean getBooleanProperty(String name)\\n\\t{\\n\\t\\tObject obj = getProperty(name);\\n\\t\\tif(obj instanceof Boolean)\\n\\t\\t\\treturn ((Boolean)obj).booleanValue();\\n\\t\\telse if(\\\"true\\\".equals(obj) || \\\"on\\\".equals(obj) || \\\"yes\\\".equals(obj))\\n\\t\\t\\treturn true;\\n\\t\\telse\\n\\t\\t\\treturn false;\\n\\t} \\n\\tpublic void setBooleanProperty(String name, boolean value)\\n\\t{\\n\\t\\tsetProperty(name,value ? Boolean.TRUE : Boolean.FALSE);\\n\\t} \\n\\tpublic int getIntegerProperty(String name, int defaultValue)\\n\\t{\\n\\t\\tboolean defaultValueFlag;\\n\\t\\tObject obj;\\n\\t\\tPropValue value = (PropValue)properties.get(name);\\n\\t\\tif(value != null)\\n\\t\\t{\\n\\t\\t\\tobj = value.value;\\n\\t\\t\\tdefaultValueFlag = value.defaultValue;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tobj = getProperty(name);\\n\\t\\t\\t\\t\\t\\tdefaultValueFlag = true;\\n\\t\\t}\\n\\t\\tif(obj == null)\\n\\t\\t\\treturn defaultValue;\\n\\t\\telse if(obj instanceof Number)\\n\\t\\t\\treturn ((Number)obj).intValue();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tint returnValue = Integer.parseInt(\\n\\t\\t\\t\\t\\tobj.toString().trim());\\n\\t\\t\\t\\tproperties.put(name,new PropValue(\\n\\t\\t\\t\\t\\tnew Integer(returnValue),\\n\\t\\t\\t\\t\\tdefaultValueFlag));\\n\\t\\t\\t\\treturn returnValue;\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Exception e)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn defaultValue;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic void setIntegerProperty(String name, int value)\\n\\t{\\n\\t\\tsetProperty(name,new Integer(value));\\n\\t} \\n\\tpublic RE getRegexpProperty(String name, int cflags,\\n\\t\\tRESyntax syntax) throws REException\\n\\t{\\n\\t\\tsynchronized(propertyLock)\\n\\t\\t{\\n\\t\\t\\tboolean defaultValueFlag;\\n\\t\\t\\tObject obj;\\n\\t\\t\\tPropValue value = (PropValue)properties.get(name);\\n\\t\\t\\tif(value != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tobj = value.value;\\n\\t\\t\\t\\tdefaultValueFlag = value.defaultValue;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tobj = getProperty(name);\\n\\t\\t\\t\\t\\t\\t\\t\\tdefaultValueFlag = true;\\n\\t\\t\\t}\\n\\t\\t\\tif(obj == null)\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\telse if(obj instanceof RE)\\n\\t\\t\\t\\treturn (RE)obj;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tRE re = new RE(obj.toString(),cflags,syntax);\\n\\t\\t\\t\\tproperties.put(name,new PropValue(re,\\n\\t\\t\\t\\t\\tdefaultValueFlag));\\n\\t\\t\\t\\treturn re;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic ParserRuleSet getRuleSetAtOffset(int offset)\\n\\t{\\n\\t\\tint line = getLineOfOffset(offset);\\n\\t\\toffset -= getLineStartOffset(line);\\n\\t\\tif(offset != 0)\\n\\t\\t\\toffset--;\\n\\t\\tDefaultTokenHandler tokens = new DefaultTokenHandler();\\n\\t\\tmarkTokens(line,tokens);\\n\\t\\tToken token = TextUtilities.getTokenAtOffset(tokens.getTokens(),offset);\\n\\t\\treturn token.rules;\\n\\t} \\n\\tpublic KeywordMap getKeywordMapAtOffset(int offset)\\n\\t{\\n\\t\\treturn getRuleSetAtOffset(offset).getKeywords();\\n\\t} \\n\\tpublic String getContextSensitiveProperty(int offset, String name)\\n\\t{\\n\\t\\tParserRuleSet rules = getRuleSetAtOffset(offset);\\n\\t\\tObject value = null;\\n\\t\\tHashtable rulesetProps = rules.getProperties();\\n\\t\\tif(rulesetProps != null)\\n\\t\\t\\tvalue = rulesetProps.get(name);\\n\\t\\tif(value == null)\\n\\t\\t{\\n\\t\\t\\tvalue = jEdit.getMode(rules.getModeName())\\n\\t\\t\\t\\t.getProperty(name);\\n\\t\\t\\tif(value == null)\\n\\t\\t\\t\\tvalue = mode.getProperty(name);\\n\\t\\t}\\n\\t\\tif(value == null)\\n\\t\\t\\treturn null;\\n\\t\\telse\\n\\t\\t\\treturn String.valueOf(value);\\n\\t} \\n\\t\\tstatic class PropValue\\n\\t{\\n\\t\\tPropValue(Object value, boolean defaultValue)\\n\\t\\t{\\n\\t\\t\\tif(value == null)\\n\\t\\t\\t\\tthrow new NullPointerException();\\n\\t\\t\\tthis.value = value;\\n\\t\\t\\tthis.defaultValue = defaultValue;\\n\\t\\t}\\n\\t\\tObject value;\\n\\t\\tboolean defaultValue;\\n\\t\\tpublic String toString()\\n\\t\\t{\\n\\t\\t\\treturn value.toString();\\n\\t\\t}\\n\\t} \\n\\tpublic void toggleWordWrap(View view)\\n\\t{\\n\\t\\tString wrap = getStringProperty(\\\"wrap\\\");\\n\\t\\tif(wrap.equals(\\\"none\\\"))\\n\\t\\t\\twrap = \\\"soft\\\";\\n\\t\\telse if(wrap.equals(\\\"soft\\\"))\\n\\t\\t\\twrap = \\\"hard\\\";\\n\\t\\telse if(wrap.equals(\\\"hard\\\"))\\n\\t\\t\\twrap = \\\"none\\\";\\n\\t\\tview.getStatus().setMessageAndClear(jEdit.getProperty(\\n\\t\\t\\t\\\"view.status.wrap-changed\\\",new String[] {\\n\\t\\t\\twrap }));\\n\\t\\tsetProperty(\\\"wrap\\\",wrap);\\n\\t\\tpropertiesChanged();\\n\\t} \\n\\tpublic void toggleLineSeparator(View view)\\n\\t{\\n\\t\\tString status = null;\\n\\t\\tString lineSep = getStringProperty(\\\"lineSeparator\\\");\\n\\t\\tif(\\\"\\\\n\\\".equals(lineSep))\\n\\t\\t{\\n\\t\\t\\tstatus = \\\"windows\\\";\\n\\t\\t\\tlineSep = \\\"\\\\r\\\\n\\\";\\n\\t\\t}\\n\\t\\telse if(\\\"\\\\r\\\\n\\\".equals(lineSep))\\n\\t\\t{\\n\\t\\t\\tstatus = \\\"mac\\\";\\n\\t\\t\\tlineSep = \\\"\\\\r\\\";\\n\\t\\t}\\n\\t\\telse if(\\\"\\\\r\\\".equals(lineSep))\\n\\t\\t{\\n\\t\\t\\tstatus = \\\"unix\\\";\\n\\t\\t\\tlineSep = \\\"\\\\n\\\";\\n\\t\\t}\\n\\t\\tview.getStatus().setMessageAndClear(jEdit.getProperty(\\n\\t\\t\\t\\\"view.status.linesep-changed\\\",new String[] {\\n\\t\\t\\tjEdit.getProperty(\\\"lineSep.\\\" + status) }));\\n\\t\\tsetProperty(\\\"lineSeparator\\\",lineSep);\\n\\t\\tsetDirty(true);\\n\\t\\tpropertiesChanged();\\n\\t} \\n\\tpublic final Mode getMode()\\n\\t{\\n\\t\\treturn mode;\\n\\t} \\n\\tpublic void setMode(String mode)\\n\\t{\\n\\t\\tsetMode(jEdit.getMode(mode));\\n\\t} \\n\\tpublic void setMode(Mode mode)\\n\\t{\\n\\t\\tif(mode == null)\\n\\t\\t\\tthrow new NullPointerException(\\\"Mode must be non-null\\\");\\n\\t\\tthis.mode = mode;\\n\\t\\ttextMode = \\\"text\\\".equals(mode.getName());\\n\\t\\tsetTokenMarker(mode.getTokenMarker());\\n\\t\\tresetCachedProperties();\\n\\t\\tpropertiesChanged();\\n\\t} \\n\\tpublic void setMode()\\n\\t{\\n\\t\\tString userMode = getStringProperty(\\\"mode\\\");\\n\\t\\tif(userMode != null)\\n\\t\\t{\\n\\t\\t\\tMode m = jEdit.getMode(userMode);\\n\\t\\t\\tif(m != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetMode(m);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tString nogzName = name.substring(0,name.length() -\\n\\t\\t\\t(name.endsWith(\\\".gz\\\") ? 3 : 0));\\n\\t\\tMode[] modes = jEdit.getModes();\\n\\t\\tString firstLine = getLineText(0);\\n\\t\\tfor(int i = 0; i < modes.length; i++)\\n\\t\\t{\\n\\t\\t\\tif(modes[i].accept(nogzName,firstLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetMode(modes[i]);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tMode defaultMode = jEdit.getMode(jEdit.getProperty(\\\"buffer.defaultMode\\\"));\\n\\t\\tif(defaultMode == null)\\n\\t\\t\\tdefaultMode = jEdit.getMode(\\\"text\\\");\\n\\t\\tsetMode(defaultMode);\\n\\t} \\n\\tpublic void markTokens(int lineIndex, TokenHandler tokenHandler)\\n\\t{\\n\\t\\tSegment seg;\\n\\t\\tif(SwingUtilities.isEventDispatchThread())\\n\\t\\t\\tseg = this.seg;\\n\\t\\telse\\n\\t\\t\\tseg = new Segment();\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tif(lineIndex < 0 || lineIndex >= offsetMgr.getLineCount())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(lineIndex);\\n\\t\\t\\tint firstInvalidLineContext = offsetMgr.getFirstInvalidLineContext();\\n\\t\\t\\tint start;\\n\\t\\t\\tif(textMode || firstInvalidLineContext == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart = lineIndex;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart = Math.min(firstInvalidLineContext,\\n\\t\\t\\t\\t\\tlineIndex);\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.TOKEN_MARKER_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"tokenize from \\\" + start + \\\" to \\\" + lineIndex);\\n\\t\\t\\tfor(int i = start; i <= lineIndex; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetLineText(i,seg);\\n\\t\\t\\t\\tTokenMarker.LineContext context = offsetMgr.getLineContext(i);\\n\\t\\t\\t\\tParserRule oldRule;\\n\\t\\t\\t\\tParserRuleSet oldRules;\\n\\t\\t\\t\\tString oldSpanEndSubst;\\n\\t\\t\\t\\tif(context == null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\toldRule = null;\\n\\t\\t\\t\\t\\toldRules = null;\\n\\t\\t\\t\\t\\toldSpanEndSubst = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\toldRule = context.inRule;\\n\\t\\t\\t\\t\\toldRules = context.rules;\\n\\t\\t\\t\\t\\toldSpanEndSubst = (context.parent != null\\n\\t\\t\\t\\t\\t\\t? context.parent.spanEndSubst\\n\\t\\t\\t\\t\\t\\t: null);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tTokenMarker.LineContext prevContext = (\\n\\t\\t\\t\\t\\t(i == 0 || textMode) ? null\\n\\t\\t\\t\\t\\t: offsetMgr.getLineContext(i - 1)\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\tcontext = tokenMarker.markTokens(prevContext,\\n\\t\\t\\t\\t\\t(i == lineIndex ? tokenHandler\\n\\t\\t\\t\\t\\t: DummyTokenHandler.INSTANCE),seg);\\n\\t\\t\\t\\toffsetMgr.setLineContext(i,context);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(oldRule != context.inRule)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnextLineRequested = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(oldRules != context.rules)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnextLineRequested = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(!MiscUtilities.objectsEqual(oldSpanEndSubst,\\n\\t\\t\\t\\t\\tcontext.spanEndSubst))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnextLineRequested = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint lineCount = offsetMgr.getLineCount();\\n\\t\\t\\tif(lineCount - 1 == lineIndex)\\n\\t\\t\\t\\toffsetMgr.setFirstInvalidLineContext(-1);\\n\\t\\t\\telse if(nextLineRequested)\\n\\t\\t\\t\\toffsetMgr.setFirstInvalidLineContext(lineIndex + 1);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\toffsetMgr.setFirstInvalidLineContext(Math.max(\\n\\t\\t\\t\\t\\tfirstInvalidLineContext,lineIndex + 1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic boolean isNextLineRequested()\\n\\t{\\n\\t\\tboolean retVal = nextLineRequested;\\n\\t\\tnextLineRequested = false;\\n\\t\\treturn retVal;\\n\\t} \\n\\tpublic void removeTrailingWhiteSpace(int[] lines)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbeginCompoundEdit();\\n\\t\\t\\tfor(int i = 0; i < lines.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint pos, lineStart, lineEnd, tail;\\n\\t\\t\\t\\tgetLineText(lines[i],seg);\\n\\t\\t\\t\\t\\t\\t\\t\\tif (seg.count == 0) continue;\\n\\t\\t\\t\\tlineStart = seg.offset;\\n\\t\\t\\t\\tlineEnd = seg.offset + seg.count - 1;\\n\\t\\t\\t\\tfor (pos = lineEnd; pos >= lineStart; pos--)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (!Character.isWhitespace(seg.array[pos]))\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttail = lineEnd - pos;\\n\\t\\t\\t\\t\\t\\t\\t\\tif (tail == 0) continue;\\n\\t\\t\\t\\tremove(getLineEndOffset(lines[i]) - 1 - tail,tail);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tendCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void shiftIndentLeft(int[] lines)\\n\\t{\\n\\t\\tint tabSize = getTabSize();\\n\\t\\tint indentSize = getIndentSize();\\n\\t\\tboolean noTabs = getBooleanProperty(\\\"noTabs\\\");\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbeginCompoundEdit();\\n\\t\\t\\tfor(int i = 0; i < lines.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint lineStart = getLineStartOffset(lines[i]);\\n\\t\\t\\t\\tString line = getLineText(lines[i]);\\n\\t\\t\\t\\tint whiteSpace = MiscUtilities\\n\\t\\t\\t\\t\\t.getLeadingWhiteSpace(line);\\n\\t\\t\\t\\tif(whiteSpace == 0)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tint whiteSpaceWidth = Math.max(0,MiscUtilities\\n\\t\\t\\t\\t\\t.getLeadingWhiteSpaceWidth(line,tabSize)\\n\\t\\t\\t\\t\\t- indentSize);\\n\\t\\t\\t\\tinsert(lineStart + whiteSpace,MiscUtilities\\n\\t\\t\\t\\t\\t.createWhiteSpace(whiteSpaceWidth,\\n\\t\\t\\t\\t\\t(noTabs ? 0 : tabSize)));\\n\\t\\t\\t\\tremove(lineStart,whiteSpace);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tendCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void shiftIndentRight(int[] lines)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbeginCompoundEdit();\\n\\t\\t\\tint tabSize = getTabSize();\\n\\t\\t\\tint indentSize = getIndentSize();\\n\\t\\t\\tboolean noTabs = getBooleanProperty(\\\"noTabs\\\");\\n\\t\\t\\tfor(int i = 0; i < lines.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint lineStart = getLineStartOffset(lines[i]);\\n\\t\\t\\t\\tString line = getLineText(lines[i]);\\n\\t\\t\\t\\tint whiteSpace = MiscUtilities\\n\\t\\t\\t\\t\\t.getLeadingWhiteSpace(line);\\n\\t\\t\\t\\tint whiteSpaceWidth = MiscUtilities\\n\\t\\t\\t\\t\\t.getLeadingWhiteSpaceWidth(\\n\\t\\t\\t\\t\\tline,tabSize) + indentSize;\\n\\t\\t\\t\\tinsert(lineStart + whiteSpace,MiscUtilities\\n\\t\\t\\t\\t\\t.createWhiteSpace(whiteSpaceWidth,\\n\\t\\t\\t\\t\\t(noTabs ? 0 : tabSize)));\\n\\t\\t\\t\\tremove(lineStart,whiteSpace);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tendCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic boolean indentLine(int lineIndex, boolean canIncreaseIndent,\\n\\t\\tboolean canDecreaseIndent)\\n\\t{\\n\\t\\treturn indentLine(lineIndex);\\n\\t} \\n\\tpublic boolean indentLine(int lineIndex, boolean canIncreaseIndent,\\n\\t\\tboolean canDecreaseIndent)\\n\\t{\\n\\t\\tgetLineText(lineIndex,seg);\\n\\t\\tint tabSize = getTabSize();\\n\\t\\tint whitespaceChars = 0;\\n\\t\\tint currentIndent = 0;\\nloop:\\t\\tfor(int i = 0; i < seg.count; i++)\\n\\t\\t{\\n\\t\\t\\tchar c = seg.array[seg.offset + i];\\n\\t\\t\\tswitch(c)\\n\\t\\t\\t{\\n\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcurrentIndent++;\\n\\t\\t\\t\\twhitespaceChars++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\tcurrentIndent += (tabSize - (currentIndent\\n\\t\\t\\t\\t\\t% tabSize));\\n\\t\\t\\t\\twhitespaceChars++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint idealIndent = getIndentForLine(lineIndex);\\n\\t\\tif(idealIndent == -1 || idealIndent == currentIndent)\\n\\t\\t\\treturn false;\\n\\t\\t\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbeginCompoundEdit();\\n\\t\\t\\tint start = getLineStartOffset(lineIndex);\\n\\t\\t\\tremove(start,whitespaceChars);\\n\\t\\t\\tinsert(start,MiscUtilities.createWhiteSpace(\\n\\t\\t\\t\\tidealIndent,(getBooleanProperty(\\\"noTabs\\\")\\n\\t\\t\\t\\t? 0 : tabSize)));\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tendCompoundEdit();\\n\\t\\t}\\n\\t\\treturn true;\\n\\t} \\n\\tpublic void indentLines(int start, int end)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbeginCompoundEdit();\\n\\t\\t\\tfor(int i = start; i <= end; i++)\\n\\t\\t\\t\\tindentLine(i);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tendCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void indentLines(int[] lines)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbeginCompoundEdit();\\n\\t\\t\\tfor(int i = 0; i < lines.length; i++)\\n\\t\\t\\t\\tindentLine(lines[i]);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tendCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic int getIndentForLine(int lineIndex)\\n\\t{\\n\\t\\tfinal String EXPLICIT_START = \\\"{{{\\\";\\n\\t\\tfinal String EXPLICIT_END = \\\"}}}\\\";\\n\\t\\tif(lineIndex == 0)\\n\\t\\t\\treturn -1;\\n\\t\\t\\t\\tString openBrackets = getStringProperty(\\\"indentOpenBrackets\\\");\\n\\t\\tif(openBrackets == null)\\n\\t\\t\\topenBrackets = \\\"\\\";\\n\\t\\tString closeBrackets = getStringProperty(\\\"indentCloseBrackets\\\");\\n\\t\\tif(closeBrackets == null)\\n\\t\\t\\tcloseBrackets = \\\"\\\";\\n\\t\\tRE indentNextLineRE;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tindentNextLineRE = getRegexpProperty(\\\"indentNextLine\\\",\\n\\t\\t\\t\\tRE.REG_ICASE,RESearchMatcher.RE_SYNTAX_JEDIT);\\n\\t\\t}\\n\\t\\tcatch(REException re)\\n\\t\\t{\\n\\t\\t\\tindentNextLineRE = null;\\n\\t\\t\\tLog.log(Log.ERROR,this,\\\"Invalid indentNextLine regexp\\\");\\n\\t\\t\\tLog.log(Log.ERROR,this,re);\\n\\t\\t}\\n\\t\\tRE indentNextLinesRE;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tindentNextLinesRE = getRegexpProperty(\\\"indentNextLines\\\",\\n\\t\\t\\t\\tRE.REG_ICASE,RESearchMatcher.RE_SYNTAX_JEDIT);\\n\\t\\t}\\n\\t\\tcatch(REException re)\\n\\t\\t{\\n\\t\\t\\tindentNextLinesRE = null;\\n\\t\\t\\tLog.log(Log.ERROR,this,\\\"Invalid indentNextLines regexp\\\");\\n\\t\\t\\tLog.log(Log.ERROR,this,re);\\n\\t\\t}\\n\\t\\tboolean doubleBracketIndent = getBooleanProperty(\\\"doubleBracketIndent\\\");\\n\\t\\tboolean lineUpClosingBracket = getBooleanProperty(\\\"lineUpClosingBracket\\\");\\n\\t\\tint tabSize = getTabSize();\\n\\t\\tint indentSize = getIndentSize();\\n\\t\\t\\t\\tint prevLineIndex = getPriorNonEmptyLine(lineIndex);\\n\\t\\tif(prevLineIndex == -1)\\n\\t\\t\\treturn -1;\\n\\t\\tString prevLine = getLineText(prevLineIndex);\\n\\t\\tboolean prevLineStart = true; \\t\\tint indent = 0; \\t\\tint prevLineBrackets = 0; \\t\\tint prevLineCloseBracketIndex = -1; \\t\\t                                    \\t\\t                                    \\t\\t                                    \\t\\t                                    \\t\\t                                    \\t\\t                                    \\t\\t                                    \\n\\t\\tfor(int i = 0; i < prevLine.length(); i++)\\n\\t\\t{\\n\\t\\t\\tchar c = prevLine.charAt(i);\\n\\t\\t\\tswitch(c)\\n\\t\\t\\t{\\n\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tif(prevLineStart)\\n\\t\\t\\t\\t\\tindent++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\tif(prevLineStart)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tindent += (tabSize\\n\\t\\t\\t\\t\\t\\t- (indent\\n\\t\\t\\t\\t\\t\\t% tabSize));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tprevLineStart = false;\\n\\t\\t\\t\\tif(closeBrackets.indexOf(c) != -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(prevLine.regionMatches(false,\\n\\t\\t\\t\\t\\t\\ti,EXPLICIT_END,0,3))\\n\\t\\t\\t\\t\\t\\ti += 2;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tprevLineBrackets--;\\n\\t\\t\\t\\t\\t\\tif(prevLineBrackets < 0)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(lineUpClosingBracket)\\n\\t\\t\\t\\t\\t\\t\\t\\tprevLineBrackets = 0;\\n\\t\\t\\t\\t\\t\\t\\tprevLineCloseBracketIndex = i;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(openBrackets.indexOf(c) != -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(prevLine.regionMatches(false,\\n\\t\\t\\t\\t\\t\\ti,EXPLICIT_START,0,3))\\n\\t\\t\\t\\t\\t\\ti += 2;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tprevLineBrackets++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tString line = getLineText(lineIndex);\\n\\t\\tint lineBrackets = 0; \\t\\tint closeBracketIndex = -1; \\t\\t\\t\\t\\tfor(int i = 0; i < line.length(); i++)\\n\\t\\t{\\n\\t\\t\\tchar c = line.charAt(i);\\n\\t\\t\\tif(closeBrackets.indexOf(c) != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(line.regionMatches(false,\\n\\t\\t\\t\\t\\ti,EXPLICIT_END,0,3))\\n\\t\\t\\t\\t\\ti += 2;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcloseBracketIndex = i;\\n\\t\\t\\t\\t\\tlineBrackets--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(openBrackets.indexOf(c) != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(line.regionMatches(false,\\n\\t\\t\\t\\t\\ti,EXPLICIT_START,0,3))\\n\\t\\t\\t\\t\\ti += 2;\\n\\t\\t\\t\\telse if(lineBrackets >= 0)\\n\\t\\t\\t\\t\\tlineBrackets++;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tif(prevLineBrackets > 0)\\n\\t\\t\\tindent += (indentSize * prevLineBrackets);\\n\\t\\tif(lineUpClosingBracket)\\n\\t\\t{\\n\\t\\t\\tif(lineBrackets < 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint offset = TextUtilities.findMatchingBracket(\\n\\t\\t\\t\\t\\tthis,lineIndex,closeBracketIndex);\\n\\t\\t\\t\\tif(offset != -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tString closeLine = getLineText(getLineOfOffset(offset));\\n\\t\\t\\t\\t\\tindent = MiscUtilities.getLeadingWhiteSpaceWidth(\\n\\t\\t\\t\\t\\t\\tcloseLine,tabSize);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(prevLineBrackets < 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint offset = TextUtilities.findMatchingBracket(\\n\\t\\t\\t\\t\\tthis,prevLineIndex,prevLineCloseBracketIndex);\\n\\t\\t\\t\\tif(offset != -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tString closeLine = getLineText(getLineOfOffset(offset));\\n\\t\\t\\t\\t\\tindent = MiscUtilities.getLeadingWhiteSpaceWidth(\\n\\t\\t\\t\\t\\t\\tcloseLine,tabSize);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tif(lineBrackets == 0 || (doubleBracketIndent && lineBrackets > 0))\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(indentNextLinesRE != null && indentNextLinesRE.isMatch(prevLine))\\n\\t\\t\\t\\tindent += indentSize;\\n\\t\\t\\telse if(indentNextLineRE != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(indentNextLineRE.isMatch(prevLine))\\n\\t\\t\\t\\t\\tindent += indentSize;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\telse if(prevLineBrackets == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tint prevPrevLineIndex;\\n\\t\\t\\t\\t\\t\\tprevPrevLineIndex = getPriorNonEmptyLine(prevLineIndex);\\n\\t\\t\\t\\t\\twhile(prevPrevLineIndex != -1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(indentNextLineRE.isMatch(getLineText(prevPrevLineIndex)))\\n\\t\\t\\t\\t\\t\\t\\tindent -= indentSize;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tprevPrevLineIndex = getPriorNonEmptyLine(prevPrevLineIndex);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\treturn indent;\\n\\t} \\n\\tpublic int getVirtualWidth(int line, int column)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tint start = getLineStartOffset(line);\\n\\t\\t\\tgetText(start,column,seg);\\n\\t\\t\\treturn MiscUtilities.getVirtualWidth(seg,getTabSize());\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic int getOffsetOfVirtualColumn(int line, int column,\\n\\t\\tint[] totalVirtualWidth)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tgetLineText(line,seg);\\n\\t\\t\\treturn MiscUtilities.getOffsetOfVirtualColumn(seg,\\n\\t\\t\\t\\tgetTabSize(),column,totalVirtualWidth);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void insertAtColumn(int line, int col, String str)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tint[] total = new int[1];\\n\\t\\t\\tint offset = getOffsetOfVirtualColumn(line,col,total);\\n\\t\\t\\tif(offset == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\toffset = getLineEndOffset(line) - 1;\\n\\t\\t\\t\\tstr = MiscUtilities.createWhiteSpace(col - total[0],0) + str;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\toffset += getLineStartOffset(line);\\n\\t\\t\\tinsert(offset,str);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void putProperty(Object name, Object value)\\n\\t{\\n\\t\\t\\t\\tif(!(name instanceof String))\\n\\t\\t\\treturn;\\n\\t\\tsetProperty((String)name,value);\\n\\t} \\n\\tpublic void putBooleanProperty(String name, boolean value)\\n\\t{\\n\\t\\tsetBooleanProperty(name,value);\\n\\t} \\n\\tpublic static class TokenList extends DefaultTokenHandler\\n\\t{\\n\\t\\tpublic Token getFirstToken()\\n\\t\\t{\\n\\t\\t\\treturn getTokens();\\n\\t\\t}\\n\\t}\\n\\tpublic TokenList markTokens(int lineIndex)\\n\\t{\\n\\t\\tTokenList list = new TokenList();\\n\\t\\tmarkTokens(lineIndex,list);\\n\\t\\treturn list;\\n\\t} \\n\\tpublic Element[] getRootElements()\\n\\t{\\n\\t\\treturn new Element[] { getDefaultRootElement() };\\n\\t} \\n\\tpublic Element getParagraphElement(int offset)\\n\\t{\\n\\t\\treturn new LineElement(this,getLineOfOffset(offset));\\n\\t} \\n\\tpublic Element getDefaultRootElement()\\n\\t{\\n\\t\\treturn new RootElement(this);\\n\\t} \\n\\tpublic void insertString(int offset, String str, AttributeSet attr)\\n\\t{\\n\\t\\tinsert(offset,str);\\n\\t} \\n\\tpublic final File getFile()\\n\\t{\\n\\t\\treturn file;\\n\\t} \\n\\tpublic boolean isFoldStart(int line)\\n\\t{\\n\\t\\treturn (line != getLineCount() - 1\\n\\t\\t\\t&& getFoldLevel(line) < getFoldLevel(line + 1));\\n\\t} \\n\\tpublic void invalidateCachedFoldLevels()\\n\\t{\\n\\t\\toffsetMgr.setFirstInvalidFoldLevel(0);\\n\\t\\tfireFoldLevelChanged(0,getLineCount());\\n\\t} \\n\\tpublic int getFoldLevel(int line)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tif(line < 0 || line >= offsetMgr.getLineCount())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(line);\\n\\t\\t\\tif(foldHandler instanceof DummyFoldHandler)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\tint firstInvalidFoldLevel = offsetMgr.getFirstInvalidFoldLevel();\\n\\t\\t\\tif(firstInvalidFoldLevel == -1 || line < firstInvalidFoldLevel)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn offsetMgr.getFoldLevel(line);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(Debug.FOLD_DEBUG)\\n\\t\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"Invalid fold levels from \\\" + firstInvalidFoldLevel + \\\" to \\\" + line);\\n\\t\\t\\t\\tint newFoldLevel = 0;\\n\\t\\t\\t\\tboolean changed = false;\\n\\t\\t\\t\\tfor(int i = firstInvalidFoldLevel; i <= line; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnewFoldLevel = foldHandler.getFoldLevel(this,i,seg);\\n\\t\\t\\t\\t\\tif(newFoldLevel != offsetMgr.getFoldLevel(i))\\n\\t\\t\\t\\t\\t\\tchanged = true;\\n\\t\\t\\t\\t\\toffsetMgr.setFoldLevel(i,newFoldLevel);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(line == offsetMgr.getLineCount() - 1)\\n\\t\\t\\t\\t\\toffsetMgr.setFirstInvalidFoldLevel(-1);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\toffsetMgr.setFirstInvalidFoldLevel(line + 1);\\n\\t\\t\\t\\tif(changed && !getFlag(INSIDE_INSERT))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfireFoldLevelChanged(firstInvalidFoldLevel,line);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn newFoldLevel;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic int[] getFoldAtLine(int line)\\n\\t{\\n\\t\\tint start, end;\\n\\t\\tif(isFoldStart(line))\\n\\t\\t{\\n\\t\\t\\tstart = line;\\n\\t\\t\\tint foldLevel = getFoldLevel(line);\\n\\t\\t\\tline++;\\n\\t\\t\\twhile(getFoldLevel(line) > foldLevel)\\n\\t\\t\\t{\\n\\t\\t\\t\\tline++;\\n\\t\\t\\t\\tif(line == getLineCount())\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tend = line - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstart = line;\\n\\t\\t\\tint foldLevel = getFoldLevel(line);\\n\\t\\t\\twhile(getFoldLevel(start) >= foldLevel)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(start == 0)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tstart--;\\n\\t\\t\\t}\\n\\t\\t\\tend = line;\\n\\t\\t\\twhile(getFoldLevel(end) >= foldLevel)\\n\\t\\t\\t{\\n\\t\\t\\t\\tend++;\\n\\t\\t\\t\\tif(end == getLineCount())\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tend--;\\n\\t\\t}\\n\\t\\twhile(getLineLength(end) == 0 && end > start)\\n\\t\\t\\tend--;\\n\\t\\treturn new int[] { start, end };\\n\\t} \\n\\tpublic FoldHandler getFoldHandler()\\n\\t{\\n\\t\\treturn foldHandler;\\n\\t} \\n\\tpublic void setFoldHandler(FoldHandler foldHandler)\\n\\t{\\n\\t\\tFoldHandler oldFoldHandler = this.foldHandler;\\n\\t\\tif(foldHandler.equals(oldFoldHandler))\\n\\t\\t\\treturn;\\n\\t\\tthis.foldHandler = foldHandler;\\n\\t\\toffsetMgr.setFirstInvalidFoldLevel(0);\\n\\t\\tfireFoldHandlerChanged();\\n\\t} \\n\\tpublic Position createPosition(int offset)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tif(offset < 0 || offset > contentMgr.getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(offset);\\n\\t\\t\\treturn offsetMgr.createPosition(offset);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic final Vector getMarkers()\\n\\t{\\n\\t\\treturn markers;\\n\\t} \\n\\tpublic void addOrRemoveMarker(char shortcut, int pos)\\n\\t{\\n\\t\\tint line = getLineOfOffset(pos);\\n\\t\\tif(getMarkerAtLine(line) != null)\\n\\t\\t\\tremoveMarker(line);\\n\\t\\telse\\n\\t\\t\\taddMarker(shortcut,pos);\\n\\t} \\n\\tpublic void addMarker(char shortcut, int pos)\\n\\t{\\n\\t\\tif(!getFlag(READ_ONLY) && jEdit.getBooleanProperty(\\\"persistentMarkers\\\"))\\n\\t\\t\\tsetDirty(true);\\n\\t\\tMarker markerN = new Marker(this,shortcut,pos);\\n\\t\\tboolean added = false;\\n\\t\\t\\t\\tif(!getFlag(LOADING))\\n\\t\\t{\\n\\t\\t\\tmarkerN.createPosition();\\n\\t\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\t\\tif(shortcut != '\\\\0' && marker.getShortcut() == shortcut)\\n\\t\\t\\t\\t\\tmarker.setShortcut('\\\\0');\\n\\t\\t\\t\\tif(marker.getPosition() == pos)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmarkers.removeElementAt(i);\\n\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\t\\tif(marker.getPosition() > pos)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmarkers.insertElementAt(markerN,i);\\n\\t\\t\\t\\t\\tadded = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(!added)\\n\\t\\t\\tmarkers.addElement(markerN);\\n\\t\\tif(!getFlag(LOADING) && !getFlag(TEMPORARY))\\n\\t\\t{\\n\\t\\t\\tEditBus.send(new BufferUpdate(this,null,\\n\\t\\t\\t\\tBufferUpdate.MARKERS_CHANGED));\\n\\t\\t}\\n\\t} \\n\\tpublic Marker getMarkerInRange(int start, int end)\\n\\t{\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tint pos = marker.getPosition();\\n\\t\\t\\tif(pos >= start && pos < end)\\n\\t\\t\\t\\treturn marker;\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic Marker getMarkerAtLine(int line)\\n\\t{\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tif(getLineOfOffset(marker.getPosition()) == line)\\n\\t\\t\\t\\treturn marker;\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic void removeMarker(int line)\\n\\t{\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tif(getLineOfOffset(marker.getPosition()) == line)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(!getFlag(READ_ONLY) && jEdit.getBooleanProperty(\\\"persistentMarkers\\\"))\\n\\t\\t\\t\\t\\tsetDirty(true);\\n\\t\\t\\t\\tmarker.removePosition();\\n\\t\\t\\t\\tmarkers.removeElementAt(i);\\n\\t\\t\\t\\ti--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tEditBus.send(new BufferUpdate(this,null,\\n\\t\\t\\tBufferUpdate.MARKERS_CHANGED));\\n\\t} \\n\\tpublic void removeAllMarkers()\\n\\t{\\n\\t\\tif(!getFlag(READ_ONLY) && jEdit.getBooleanProperty(\\\"persistentMarkers\\\"))\\n\\t\\t\\tsetDirty(true);\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t\\t((Marker)markers.elementAt(i)).removePosition();\\n\\t\\tmarkers.removeAllElements();\\n\\t\\tif(!getFlag(LOADING))\\n\\t\\t{\\n\\t\\t\\tEditBus.send(new BufferUpdate(this,null,\\n\\t\\t\\t\\tBufferUpdate.MARKERS_CHANGED));\\n\\t\\t}\\n\\t} \\n\\tpublic Marker getMarker(char shortcut)\\n\\t{\\n\\t\\tEnumeration enum = markers.elements();\\n\\t\\twhile(enum.hasMoreElements())\\n\\t\\t{\\n\\t\\t\\tMarker marker = (Marker)enum.nextElement();\\n\\t\\t\\tif(marker.getShortcut() == shortcut)\\n\\t\\t\\t\\treturn marker;\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic void setWaitSocket(Socket waitSocket)\\n\\t{\\n\\t\\tthis.waitSocket = waitSocket;\\n\\t} \\n\\tpublic final Buffer getNext()\\n\\t{\\n\\t\\treturn next;\\n\\t} \\n\\tpublic final Buffer getPrev()\\n\\t{\\n\\t\\treturn prev;\\n\\t} \\n\\tpublic final int getIndex()\\n\\t{\\n\\t\\tint count = 0;\\n\\t\\tBuffer buffer = prev;\\n\\t\\tfor(;;)\\n\\t\\t{\\n\\t\\t\\tif(buffer == null)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcount++;\\n\\t\\t\\tbuffer = buffer.prev;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t} \\n\\tpublic String toString()\\n\\t{\\n\\t\\treturn name + \\\" (\\\" + directory + \\\")\\\";\\n\\t} \\n\\tpublic OffsetManager _getOffsetManager()\\n\\t{\\n\\t\\treturn offsetMgr;\\n\\t} \\n\\t\\tBuffer prev;\\n\\tBuffer next;\\n\\t\\tBuffer(String path, boolean newFile, boolean temp, Hashtable props)\\n\\t{\\n\\t\\tlock = new ReadWriteLock();\\n\\t\\tpropertyLock = new Object();\\n\\t\\tcontentMgr = new ContentManager();\\n\\t\\toffsetMgr = new OffsetManager();\\n\\t\\tintegerArray = new IntegerArray();\\n\\t\\tundoMgr = new UndoManager(this);\\n\\t\\tbufferListeners = new Vector();\\n\\t\\tseg = new Segment();\\n\\t\\tmarkers = new Vector();\\n\\t\\tproperties = new HashMap();\\n\\t\\t\\t\\tEnumeration enum = props.keys();\\n\\t\\twhile(enum.hasMoreElements())\\n\\t\\t{\\n\\t\\t\\tObject key = enum.nextElement();\\n\\t\\t\\tObject value = props.get(key);\\n\\t\\t\\tproperties.put(key,new PropValue(value,false));\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tif(getProperty(ENCODING) == null)\\n\\t\\t\\tproperties.put(ENCODING,new PropValue(System.getProperty(\\\"file.encoding\\\"),false));\\n\\t\\tif(getProperty(LINESEP) == null)\\n\\t\\t\\tproperties.put(LINESEP,new PropValue(System.getProperty(\\\"line.separator\\\"),false));\\n\\t\\tsetFlag(TEMPORARY,temp);\\n\\t\\t\\t\\tsetPath(path);\\n\\t\\tsetFlag(UNTITLED,newFile);\\n\\t\\tsetFlag(NEW_FILE,newFile);\\n\\t} \\n\\t\\tvoid commitTemporary()\\n\\t{\\n\\t\\tsetFlag(TEMPORARY,false);\\n\\t\\tfinishLoading();\\n\\t} \\n\\t\\tvoid resetCachedProperties()\\n\\t{\\n\\t\\t\\t\\t\\t\\tIterator iter = properties.values().iterator();\\n\\t\\twhile(iter.hasNext())\\n\\t\\t{\\n\\t\\t\\tPropValue value = (PropValue)iter.next();\\n\\t\\t\\tif(value.defaultValue)\\n\\t\\t\\t\\titer.remove();\\n\\t\\t}\\n\\t} \\n\\t\\tvoid close()\\n\\t{\\n\\t\\tsetFlag(CLOSED,true);\\n\\t\\tif(autosaveFile != null)\\n\\t\\t\\tautosaveFile.delete();\\n\\t\\t\\t\\tif(waitSocket != null && !waitSocket.isClosed())\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\twaitSocket.getOutputStream().write('\\\\0');\\n\\t\\t\\t\\twaitSocket.getOutputStream().flush();\\n\\t\\t\\t\\twaitSocket.getInputStream().close();\\n\\t\\t\\t\\twaitSocket.getOutputStream().close();\\n\\t\\t\\t\\twaitSocket.close();\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void setFlag(int flag, boolean value)\\n\\t{\\n\\t\\tif(value)\\n\\t\\t\\tflags |= (1 << flag);\\n\\t\\telse\\n\\t\\t\\tflags &= ~(1 << flag);\\n\\t} \\n\\t\\tprivate boolean getFlag(int flag)\\n\\t{\\n\\t\\tint mask = (1 << flag);\\n\\t\\treturn (flags & mask) == mask;\\n\\t} \\n\\t\\tprivate static final int CLOSED = 0;\\n\\tprivate static final int LOADING = 1;\\n\\tprivate static final int IO = 2;\\n\\tprivate static final int NEW_FILE = 3;\\n\\tprivate static final int UNTITLED = 4;\\n\\tprivate static final int AUTOSAVE_DIRTY = 5;\\n\\tprivate static final int DIRTY = 6;\\n\\tprivate static final int READ_ONLY = 7;\\n\\tprivate static final int UNDO_IN_PROGRESS = 8;\\n\\tprivate static final int TEMPORARY = 9;\\n\\tprivate static final int INSIDE_INSERT = 10;\\n\\tprivate int flags;\\n\\t\\tprivate String path;\\n\\tprivate String symlinkPath;\\n\\tprivate String name;\\n\\tprivate String directory;\\n\\tprivate File file;\\n\\tprivate File autosaveFile;\\n\\tprivate long modTime;\\n\\tprivate Mode mode;\\n\\tprivate HashMap properties;\\n\\tprivate ReadWriteLock lock;\\n\\tprivate Object propertyLock;\\n\\tprivate ContentManager contentMgr;\\n\\tprivate OffsetManager offsetMgr;\\n\\tprivate IntegerArray integerArray;\\n\\tprivate UndoManager undoMgr;\\n\\tprivate Vector bufferListeners;\\n\\tprivate Vector markers;\\n\\t\\tprivate boolean textMode;\\n\\tprivate TokenMarker tokenMarker;\\n\\tprivate Segment seg;\\n\\tprivate boolean nextLineRequested;\\n\\tprivate FoldHandler foldHandler;\\n\\tprivate String wrap;\\n\\tprivate Socket waitSocket;\\n\\t\\tprivate void setPath(String path)\\n\\t{\\n\\t\\tthis.path = path;\\n\\t\\tthis.symlinkPath = path;\\n\\t\\tVFS vfs = VFSManager.getVFSForPath(path);\\n\\t\\tif((vfs.getCapabilities() & VFS.WRITE_CAP) == 0)\\n\\t\\t\\tsetReadOnly(true);\\n\\t\\tthis.name = vfs.getFileName(path);\\n\\t\\tthis.directory = vfs.getParentOfPath(path);\\n\\t\\tif(vfs instanceof FileVFS)\\n\\t\\t{\\n\\t\\t\\tfile = new File(path);\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tsymlinkPath = file.getCanonicalPath();\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,io);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(autosaveFile != null)\\n\\t\\t\\t\\tautosaveFile.delete();\\n\\t\\t\\tautosaveFile = new File(file.getParent(),'#' + name + '#');\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfile = null;\\n\\t\\t\\tautosaveFile = null;\\n\\t\\t}\\n\\t} \\n\\t\\tprivate boolean recoverAutosave(final View view)\\n\\t{\\n\\t\\tif(!autosaveFile.canRead())\\n\\t\\t\\treturn false;\\n\\t\\t\\t\\tGUIUtilities.hideSplashScreen();\\n\\t\\tfinal Object[] args = { autosaveFile.getPath() };\\n\\t\\tint result = GUIUtilities.confirm(view,\\\"autosave-found\\\",args,\\n\\t\\t\\tJOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE);\\n\\t\\tif(result == JOptionPane.YES_OPTION)\\n\\t\\t{\\n\\t\\t\\tVFSManager.getFileVFS().load(view,this,autosaveFile.getPath());\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tVFSManager.runInAWTThread(new Runnable()\\n\\t\\t\\t{\\n\\t\\t\\t\\tpublic void run()\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tGUIUtilities.message(view,\\\"autosave-loaded\\\",args);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn false;\\n\\t} \\n\\t\\tprivate boolean checkFileForLoad(View view, VFS vfs, String path)\\n\\t{\\n\\t\\tif((vfs.getCapabilities() & VFS.LOW_LATENCY_CAP) != 0)\\n\\t\\t{\\n\\t\\t\\tObject session = vfs.createVFSSession(path,view);\\n\\t\\t\\tif(session == null)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tVFS.DirectoryEntry file = vfs._getDirectoryEntry(session,path,view);\\n\\t\\t\\t\\tif(file == null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsetNewFile(true);\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!file.canRead)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror.no-read\\\",null);\\n\\t\\t\\t\\t\\tsetNewFile(false);\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsetReadOnly(!file.canWrite);\\n\\t\\t\\t\\tif(file.type != VFS.DirectoryEntry.FILE)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tVFSManager.error(view,path,\\n\\t\\t\\t\\t\\t\\t\\\"ioerror.open-directory\\\",null);\\n\\t\\t\\t\\t\\tsetNewFile(false);\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror\\\",\\n\\t\\t\\t\\t\\tnew String[] { io.toString() });\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvfs._endVFSSession(session,view);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror\\\",\\n\\t\\t\\t\\t\\t\\tnew String[] { io.toString() });\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t} \\n\\t\\tprivate boolean checkFileForSave(View view, VFS vfs, String path)\\n\\t{\\n\\t\\tif((vfs.getCapabilities() & VFS.LOW_LATENCY_CAP) != 0)\\n\\t\\t{\\n\\t\\t\\tObject session = vfs.createVFSSession(path,view);\\n\\t\\t\\tif(session == null)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tVFS.DirectoryEntry file = vfs._getDirectoryEntry(session,path,view);\\n\\t\\t\\t\\tif(file == null)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\tif(file.type != VFS.DirectoryEntry.FILE)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tVFSManager.error(view,path,\\n\\t\\t\\t\\t\\t\\t\\\"ioerror.save-directory\\\",null);\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror\\\",\\n\\t\\t\\t\\t\\tnew String[] { io.toString() });\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvfs._endVFSSession(session,view);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror\\\",\\n\\t\\t\\t\\t\\t\\tnew String[] { io.toString() });\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t} \\n\\t\\tprivate void finishLoading()\\n\\t{\\n\\t\\tparseBufferLocalProperties();\\n\\t\\t\\t\\t\\t\\tFoldHandler oldFoldHandler = foldHandler;\\n\\t\\tsetMode();\\n\\t\\tif(foldHandler == oldFoldHandler)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\toffsetMgr.setFirstInvalidFoldLevel(0);\\n\\t\\t\\tfireFoldHandlerChanged();\\n\\t\\t}\\n\\t\\t\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tint pos = marker.getPosition();\\n\\t\\t\\tif(pos > getLength())\\n\\t\\t\\t\\tmarker.setPosition(getLength());\\n\\t\\t\\tmarker.removePosition();\\n\\t\\t\\tmarker.createPosition();\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void finishSaving(View view, String oldPath, String path,\\n\\t\\tboolean rename, boolean error)\\n\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tif(!error && !path.equals(oldPath))\\n\\t\\t{\\n\\t\\t\\tBuffer buffer = jEdit.getBuffer(path);\\n\\t\\t\\tif(rename)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer != null && \\n\\t\\t\\t\\t\\t!buffer.getPath().equals(oldPath))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbuffer.setDirty(false);\\n\\t\\t\\t\\t\\tjEdit.closeBuffer(view,buffer);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsetPath(path);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer != null && \\n\\t\\t\\t\\t\\t!buffer.getPath().equals(oldPath))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbuffer.load(view,true);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tif(rename)\\n\\t\\t{\\n\\t\\t\\tif(file != null)\\n\\t\\t\\t\\tmodTime = file.lastModified();\\n\\t\\t\\tif(!error)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twriteLock();\\n\\t\\t\\t\\t\\tif(autosaveFile != null)\\n\\t\\t\\t\\t\\t\\tautosaveFile.delete();\\n\\t\\t\\t\\t\\tsetFlag(AUTOSAVE_DIRTY,false);\\n\\t\\t\\t\\t\\tsetFlag(READ_ONLY,false);\\n\\t\\t\\t\\t\\tsetFlag(NEW_FILE,false);\\n\\t\\t\\t\\t\\tsetFlag(UNTITLED,false);\\n\\t\\t\\t\\t\\tsetFlag(DIRTY,false);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tundoMgr.bufferSaved();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfinally\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twriteUnlock();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tparseBufferLocalProperties();\\n\\t\\t\\t\\tif(!getPath().equals(oldPath))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tjEdit.updatePosition(Buffer.this);\\n\\t\\t\\t\\t\\tsetMode();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tString newMode = getStringProperty(\\\"mode\\\");\\n\\t\\t\\t\\t\\tif(newMode != null &&\\n\\t\\t\\t\\t\\t\\t!newMode.equals(getMode()\\n\\t\\t\\t\\t\\t\\t.getName()))\\n\\t\\t\\t\\t\\t\\tsetMode();\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tpropertiesChanged();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tEditBus.send(new BufferUpdate(Buffer.this,\\n\\t\\t\\t\\t\\tview,BufferUpdate.DIRTY_CHANGED));\\n\\t\\t\\t\\t\\t\\t\\t\\tEditBus.send(new BufferUpdate(Buffer.this,\\n\\t\\t\\t\\t\\tview,BufferUpdate.SAVED));\\n\\t\\t\\t}\\n\\t\\t} \\t} \\n\\t\\tprivate void parseBufferLocalProperties()\\n\\t{\\n\\t\\tint lastLine = Math.min(9,getLineCount() - 1);\\n\\t\\tparseBufferLocalProperties(getText(0,getLineEndOffset(lastLine) - 1));\\n\\t\\t\\t\\t\\t\\tint firstLine = Math.max(lastLine + 1, getLineCount() - 10);\\n\\t\\tif(firstLine < getLineCount())\\n\\t\\t{\\n\\t\\t\\tint length = getLineEndOffset(getLineCount() - 1) \\n\\t\\t\\t\\t- (getLineStartOffset(firstLine) + 1);\\n\\t\\t\\tparseBufferLocalProperties(getText(getLineStartOffset(firstLine),length));\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void parseBufferLocalProperties(String prop)\\n\\t{\\n\\t\\tStringBuffer buf = new StringBuffer();\\n\\t\\tString name = null;\\n\\t\\tboolean escape = false;\\n\\t\\tfor(int i = 0; i < prop.length(); i++)\\n\\t\\t{\\n\\t\\t\\tchar c = prop.charAt(i);\\n\\t\\t\\tswitch(c)\\n\\t\\t\\t{\\n\\t\\t\\tcase ':':\\n\\t\\t\\t\\tif(escape)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tescape = false;\\n\\t\\t\\t\\t\\tbuf.append(':');\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(name != null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tproperties.put(name,new PropValue(buf.toString(),false));\\n\\t\\t\\t\\t\\tname = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbuf.setLength(0);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase '=':\\n\\t\\t\\t\\tif(escape)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tescape = false;\\n\\t\\t\\t\\t\\tbuf.append('=');\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tname = buf.toString();\\n\\t\\t\\t\\tbuf.setLength(0);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase '\\\\\\\\':\\n\\t\\t\\t\\tif(escape)\\n\\t\\t\\t\\t\\tbuf.append('\\\\\\\\');\\n\\t\\t\\t\\tescape = !escape;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 'n':\\n\\t\\t\\t\\tif(escape)\\n\\t\\t\\t\\t{\\tbuf.append('\\\\n');\\n\\t\\t\\t\\t\\tescape = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\tcase 'r':\\n\\t\\t\\t\\tif(escape)\\n\\t\\t\\t\\t{\\tbuf.append('\\\\r');\\n\\t\\t\\t\\t\\tescape = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\tcase 't':\\n\\t\\t\\t\\tif(escape)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbuf.append('\\\\t');\\n\\t\\t\\t\\t\\tescape = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tbuf.append(c);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void setTokenMarker(TokenMarker tokenMarker)\\n\\t{\\n\\t\\tTokenMarker oldTokenMarker = this.tokenMarker;\\n\\t\\tthis.tokenMarker = tokenMarker;\\n\\t\\t\\t\\tif(oldTokenMarker != null && tokenMarker != oldTokenMarker)\\n\\t\\t{\\n\\t\\t\\toffsetMgr.setFirstInvalidLineContext(0);\\n\\t\\t}\\n\\t} \\n\\tprivate int getPriorNonEmptyLine(int lineIndex)\\n\\t{\\n\\t\\tfor(int i = lineIndex - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(getLineLength(i) != 0)\\n\\t\\t\\t\\treturn i;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t} \\n\\t\\tprivate void contentInserted(int offset, int length,\\n\\t\\tIntegerArray endOffsets)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tsetFlag(INSIDE_INSERT,true);\\n\\t\\t\\tint startLine = offsetMgr.getLineOfOffset(offset);\\n\\t\\t\\tint numLines = endOffsets.getSize();\\n\\t\\t\\toffsetMgr.contentInserted(startLine,offset,numLines,length,\\n\\t\\t\\t\\tendOffsets);\\n\\t\\t\\tsetDirty(true);\\n\\t\\t\\tif(!getFlag(LOADING))\\n\\t\\t\\t\\tfireContentInserted(startLine,offset,numLines,length);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tsetFlag(INSIDE_INSERT,false);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate BufferChangeListener getListener(int index)\\n\\t{\\n\\t\\treturn ((Listener)bufferListeners.elementAt(index)).listener;\\n\\t} \\n\\t\\tprivate void fireFoldLevelChanged(int start, int end)\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).foldLevelChanged(this,start,end);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireContentInserted(int startLine, int offset,\\n\\t\\tint numLines, int length)\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).contentInserted(this,startLine,\\n\\t\\t\\t\\t\\toffset,numLines,length);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireContentRemoved(int startLine, int offset,\\n\\t\\tint numLines, int length)\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).contentRemoved(this,startLine,\\n\\t\\t\\t\\t\\toffset,numLines,length);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void firePreContentRemoved(int startLine, int offset,\\n\\t\\tint numLines, int length)\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).preContentRemoved(this,startLine,\\n\\t\\t\\t\\t\\toffset,numLines,length);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireTransactionComplete()\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).transactionComplete(this);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireFoldHandlerChanged()\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).foldHandlerChanged(this);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireWrapModeChanged()\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).wrapModeChanged(this);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t}\""
        },
        {
            "content": "The source code for `Buffer.java` reveals that it is a central class in the jEdit system, handling many core functionalities related to buffer management, file I/O, editing operations, and interactions with other components like `VFSBrowser`, `RESearchMatcher`, and `JEditTextArea`. Here are some key insights from the analysis:\n\n### Key Observations:\n1. **Core Responsibilities**:\n   - `Buffer.java` manages text content, including insertion, deletion, and retrieval.\n   - It handles file loading, saving, and autosaving, interacting with the file system via `VFSManager`.\n   - It maintains buffer state (e.g., dirty flags, read-only status) and supports undo/redo operations through `UndoManager`.\n\n2. **Key Dependencies**:\n   - **`VFSBrowser`**: Used for file browsing and selection operations.\n   - **`RESearchMatcher`**: Involved in search functionality.\n   - **`JEditTextArea`**: Although there's no direct coupling dependency, they share conceptual similarity due to frequent co-changes.\n\n3. **Runtime Interactions**:\n   - The call graph indicates that `Buffer.java` interacts directly with `RESearchMatcher` and `VFSBrowser`, even though structural coupling tools don't show direct dependencies.\n\n### Entities That Need Synchronization\nBased on the co-change relationships, conceptual coupling, and runtime dependencies, the following entities should be synchronized or carefully reviewed when modifying `Buffer.java`:\n\n- **`JEditTextArea.java`**: High co-change confidence (0.58), indicating shared responsibilities despite no direct coupling.\n- **`jEdit.java`**: Core application class with high co-change confidence (0.24).\n- **`VFSBrowser.java`**: Direct interaction in file operations and moderate co-change confidence.\n- **`RESearchMatcher.java`**: Direct usage in the source code.\n- **`View.java`, `EditPane.java`, `TextAreaPainter.java`, `DisplayManager.java`, `BufferChangeHandler.java`, `ChunkCache.java`, `MouseHandler.java`, `OffsetManager.java`**: These have relatively high co-change confidence and may be affected indirectly.\n\n### Next Steps\nIf you need more detailed information about any of these files or their dependencies, I can perform further analysis using available tools. For example, we could examine coupling dependencies for another file or analyze the conceptual coupling between additional pairs.\n\nWould you like to proceed with deeper analysis of one of these files?",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        },
        {
            "role": "user",
            "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
        },
        {
            "content": "Title: Diagnosis of starting entity `Buffer.java`\n\nChange set: [JEditTextArea, jEdit, VFSBrowser, View, EditPane, ActionHandler, TextAreaPainter, DisplayManager, BufferChangeHandler, MouseHandler, OffsetManager, ChunkCache, GeneralOptionPane, FileVFS, VFSManager, RESearchMatcher, SyntaxStyle, TextAreaExtension, UndoManager, BufferIORequest, BufferSwitcher, DocumentHandler, Gutter, ModeOptionPane, MarkerHighlight, BufferOptions, Marker, InputHandler, DefaultInputHandler, SearchDialog, TextAreaOptionPane, Macros, DockableWindowManager, GUIUtilities, BracketIndentRule, OpenBracketIndentRule, IndentRule, CloseBracketIndentRule, AlignBracket, Increase, Abbrevs, TextAreaTransferHandler]\n\nDetails:\n1. **JEditTextArea (Co-change confidence: 0.58)**: High conceptual coupling and frequent co-changes suggest shared responsibilities in text editing despite no direct structural dependency.\n2. **jEdit (0.24)**: Core application class that coordinates buffer and UI interactions; changes to buffer logic often affect global behavior.\n3. **VFSBrowser (0.18)**: Direct runtime interaction for file browsing and selection; involved in loading/saving operations.\n4. **View (0.15)**: Manages user interface components tied to buffers; likely affected due to view-buffer synchronization needs.\n5. **EditPane (0.12)**: Handles display of buffers; interacts directly with buffer state and content.\n6. **ActionHandler**: Coordinates actions involving buffer manipulation; high co-change suggests shared logic.\n7. **TextAreaPainter (0.16)**: Renders buffer content visually; tightly linked to buffer's visual representation.\n8. **DisplayManager (0.17)**: Manages how buffers are displayed; highly impacted by buffer state changes.\n9. **BufferChangeHandler (0.17)**: Responds to buffer change events; frequently co-changed indicates tight integration.\n10. **MouseHandler (0.19)**: Interacts with buffer during mouse-driven edits or selections.\n11. **OffsetManager**: Tracks line offsets and manages buffer structure; core dependency within buffer management logic.\n12. **ChunkCache (0.18)**: Caches buffer chunks; closely related to buffer storage and retrieval mechanisms.\n13. **GeneralOptionPane**: Configuration settings affecting buffer behavior; co-change implies shared preferences.\n14. **FileVFS**: Involved in low-level buffer file I/O; direct usage in loading/saving workflows.\n15. **VFSManager**: Central to file system abstraction used by buffer; co-change reflects shared I/O handling.\n16. **RESearchMatcher**: Used for regex-based search operations; referenced directly in buffer methods.\n17. **SyntaxStyle**: Impacts how buffer content is highlighted; co-change implies style-content dependencies.\n18. **TextAreaExtension**: Extends text area functionality; may interact with buffer during rendering or editing.\n19. **UndoManager**: Maintains edit history; tightly coupled with buffer modifications.\n20. **BufferIORequest**: Encapsulates I/O operations; co-change shows shared lifecycle.\n21. **BufferSwitcher**: Switches between buffers; affected by buffer state transitions.\n22. **DocumentHandler**: Manages document updates; interacts with buffer content changes.\n23. **Gutter**: Displays line numbers and annotations; relies on buffer metadata.\n24. **ModeOptionPane**: Configures buffer modes; co-change indicates mode-buffer dependencies.\n25. **MarkerHighlight**: Highlights markers in the buffer; depends on buffer marker logic.\n26. **BufferOptions**: Stores buffer-specific configuration; frequently adjusted alongside buffer state.\n27. **Marker**: Manages buffer bookmarks; buffer changes can affect marker positions.\n28. **InputHandler**: Processes input events; interacts with buffer during editing.\n29. **DefaultInputHandler**: Standard implementation of input handling; shares buffer event logic.\n30. **SearchDialog**: Initiates search operations; relies on buffer search capabilities.\n31. **TextAreaOptionPane**: Configures text area appearance; indirectly affects buffer display.\n32. **Macros**: Automates buffer operations; co-change implies macro-buffer integration.\n33. **DockableWindowManager**: Manages windows docked to buffer views; dependent on buffer context.\n34. **GUIUtilities**: Provides UI helpers; invoked by buffer during file and UI operations.\n35. **BracketIndentRule**: Affects indentation behavior; buffer uses it for formatting.\n36. **OpenBracketIndentRule**: Part of indentation logic; co-change indicates formatting integration.\n37. **IndentRule**: Governs indentation rules; buffer applies these during editing.\n38. **CloseBracketIndentRule**: Influences bracket closing behavior; used by buffer formatting.\n39. **AlignBracket**: Helps align brackets; buffer formatting depends on it.\n40. **Increase**: Likely involved in adjustment operations; co-change suggests interaction.\n41. **Abbrevs**: Expands abbreviations; buffer content triggers abbreviation logic.\n42. **TextAreaTransferHandler**: Handles drag-and-drop and clipboard operations; interacts with buffer content.\n\nAll entities listed above are derived from co-change relationships, conceptual coupling, and direct/indirect source code interactions. They represent a comprehensive recall-oriented set where even moderate co-change confidence or indirect involvement has been considered to ensure coverage.",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        }
    ],
    "interaction_records": {
        "step_histories": [
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4"
                ],
                "response_message": "m5"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6"
                ],
                "response_message": "m7"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8"
                ],
                "response_message": "m9"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10"
                ],
                "response_message": "m11"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m6"
                ],
                "response_message": "m12"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m6",
                    "m12",
                    "m13"
                ],
                "response_message": "m14"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m6",
                    "m12",
                    "m13",
                    "m14",
                    "m15"
                ],
                "response_message": "m16"
            }
        ],
        "mid_to_message": {
            "m1": {
                "role": "system",
                "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
            },
            "m2": {
                "role": "user",
                "content": "The project you need to analyze is `jEdit`, a well-known Java open source project. The starting entity you need to deal with is Buffer.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
            },
            "m3": {
                "content": "",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_922dd71a7e7148fa9fac48",
                        "function": {
                            "arguments": "{\"entity\": \"Buffer.java\"}",
                            "name": "get_co_change_relationship"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m4": {
                "name": "get_co_change_relationship",
                "role": "tool",
                "content": "[[\"Autosave\", \"5\", \"0.023255813953488372\"], [\"SaveBackupOptionPane\", \"3\", \"0.013953488372093023\"], [\"BufferSaveRequest\", \"5\", \"0.023255813953488372\"], [\"MyActionListener\", \"2\", \"0.009302325581395349\"], [\"jEdit\", \"52\", \"0.24186046511627907\"], [\"View\", \"32\", \"0.14883720930232558\"], [\"ActionHandler\", \"27\", \"0.12558139534883722\"], [\"BufferSwitcher\", \"3\", \"0.013953488372093023\"], [\"EditPane\", \"26\", \"0.12093023255813953\"], [\"ViewOptionPane\", \"2\", \"0.009302325581395349\"], [\"GeneralOptionPane\", \"6\", \"0.027906976744186046\"], [\"WindowHandler\", \"4\", \"0.018604651162790697\"], [\"CloseDialog\", \"1\", \"0.004651162790697674\"], [\"ParserRuleSet\", \"6\", \"0.027906976744186046\"], [\"JEditTextArea\", \"125\", \"0.5813953488372093\"], [\"TextUtilities\", \"15\", \"0.06976744186046512\"], [\"FileVFS\", \"20\", \"0.09302325581395349\"], [\"VFSBrowser\", \"39\", \"0.1813953488372093\"], [\"BrowserView\", \"23\", \"0.10697674418604651\"], [\"XModeHandler\", \"9\", \"0.04186046511627907\"], [\"DocumentHandler\", \"2\", \"0.009302325581395349\"], [\"FoldVisibilityManager\", \"19\", \"0.08837209302325581\"], [\"BrowserJTree\", \"12\", \"0.05581395348837209\"], [\"SearchBar\", \"6\", \"0.027906976744186046\"], [\"TextAreaPainter\", \"34\", \"0.15813953488372093\"], [\"SyntaxStyle\", \"2\", \"0.009302325581395349\"], [\"SyntaxCharacterIterator\", \"2\", \"0.009302325581395349\"], [\"Chunk\", \"4\", \"0.018604651162790697\"], [\"MiscUtilities\", \"16\", \"0.07441860465116279\"], [\"BufferIORequest\", \"27\", \"0.12558139534883722\"], [\"Log\", \"4\", \"0.018604651162790697\"], [\"BufferOptions\", \"14\", \"0.06511627906976744\"], [\"CompleteWord\", \"4\", \"0.018604651162790697\"], [\"InstallPluginsDialog\", \"2\", \"0.009302325581395349\"], [\"Completion\", \"2\", \"0.009302325581395349\"], [\"KeyHandler\", \"6\", \"0.027906976744186046\"], [\"Renderer\", \"4\", \"0.018604651162790697\"], [\"ChunkCache\", \"39\", \"0.1813953488372093\"], [\"MouseHandler\", \"41\", \"0.19069767441860466\"], [\"Gutter\", \"13\", \"0.06046511627906977\"], [\"ModeOptionPane\", \"3\", \"0.013953488372093023\"], [\"MarkerHighlight\", \"5\", \"0.023255813953488372\"], [\"ModeProperties\", \"7\", \"0.03255813953488372\"], [\"EditingOptionPane\", \"7\", \"0.03255813953488372\"], [\"TextAreaExtension\", \"2\", \"0.009302325581395349\"], [\"BufferChangeHandler\", \"36\", \"0.16744186046511628\"], [\"OffsetManager\", \"41\", \"0.19069767441860466\"], [\"SearchDialog\", \"12\", \"0.05581395348837209\"], [\"ButtonActionHandler\", \"3\", \"0.013953488372093023\"], [\"BrowserOptionPane\", \"5\", \"0.023255813953488372\"], [\"Marker\", \"5\", \"0.023255813953488372\"], [\"BrowserCommandsMenu\", \"10\", \"0.046511627906976744\"], [\"DockableWindowManager\", \"16\", \"0.07441860465116279\"], [\"Macro\", \"6\", \"0.027906976744186046\"], [\"HyperSearchResults\", \"6\", \"0.027906976744186046\"], [\"GUIUtilities\", \"16\", \"0.07441860465116279\"], [\"Macros\", \"10\", \"0.046511627906976744\"], [\"ButtonLayout\", \"3\", \"0.013953488372093023\"], [\"InputHandler\", \"11\", \"0.05116279069767442\"], [\"DefaultInputHandler\", \"4\", \"0.018604651162790697\"], [\"DockableLayout\", \"3\", \"0.013953488372093023\"], [\"StatusBar\", \"6\", \"0.027906976744186046\"], [\"PaintSelection\", \"2\", \"0.009302325581395349\"], [\"BracketHighlight\", \"2\", \"0.009302325581395349\"], [\"UrlVFS\", \"2\", \"0.009302325581395349\"], [\"JARClassLoader\", \"5\", \"0.023255813953488372\"], [\"ActionListHandler\", \"4\", \"0.018604651162790697\"], [\"PluginListHandler\", \"2\", \"0.009302325581395349\"], [\"DockableListHandler\", \"2\", \"0.009302325581395349\"], [\"ModeCatalogHandler\", \"2\", \"0.009302325581395349\"], [\"RecentHandler\", \"2\", \"0.009302325581395349\"], [\"RotatedTextIcon\", \"4\", \"0.018604651162790697\"], [\"PanelWindowContainer\", \"10\", \"0.046511627906976744\"], [\"FileCellRenderer\", \"8\", \"0.037209302325581395\"], [\"BufferPrintable\", \"2\", \"0.009302325581395349\"], [\"JAR\", \"4\", \"0.018604651162790697\"], [\"ContentManager\", \"6\", \"0.027906976744186046\"], [\"SearchAndReplace\", \"11\", \"0.05116279069767442\"], [\"Install\", \"4\", \"0.018604651162790697\"], [\"ErrorListDialog\", \"2\", \"0.009302325581395349\"], [\"UndoManager\", \"9\", \"0.04186046511627907\"], [\"Abbrevs\", \"5\", \"0.023255813953488372\"], [\"Remove\", \"6\", \"0.027906976744186046\"], [\"BrowserIORequest\", \"9\", \"0.04186046511627907\"], [\"DirectoryMenu\", \"4\", \"0.018604651162790697\"], [\"HelpViewer\", \"7\", \"0.03255813953488372\"], [\"ParentDirectoryRenderer\", \"3\", \"0.013953488372093023\"], [\"ContextOptionPane\", \"2\", \"0.009302325581395349\"], [\"TokenMarker\", \"14\", \"0.06511627906976744\"], [\"ToolBarEditDialog\", \"2\", \"0.009302325581395349\"], [\"MacOSHandler\", \"2\", \"0.009302325581395349\"], [\"TextAreaOptionPane\", \"4\", \"0.018604651162790697\"], [\"RolloverButton\", \"2\", \"0.009302325581395349\"], [\"EnhancedButton\", \"2\", \"0.009302325581395349\"], [\"HelpIndex\", \"4\", \"0.018604651162790697\"], [\"ContextAddDialog\", \"2\", \"0.009302325581395349\"], [\"SyntaxHiliteOptionPane\", \"2\", \"0.009302325581395349\"], [\"FileRootsVFS\", \"4\", \"0.018604651162790697\"], [\"MarkersMenuItem\", \"4\", \"0.018604651162790697\"], [\"MarkersMenu\", \"4\", \"0.018604651162790697\"], [\"PluginResURLConnection\", \"3\", \"0.013953488372093023\"], [\"ActionSet\", \"1\", \"0.004651162790697674\"], [\"WizardLayout\", \"1\", \"0.004651162790697674\"], [\"HyperSearchRequest\", \"5\", \"0.023255813953488372\"], [\"TOCTree\", \"1\", \"0.004651162790697674\"], [\"BufferHistory\", \"3\", \"0.013953488372093023\"], [\"StyleEditor\", \"3\", \"0.013953488372093023\"], [\"SettingsReloader\", \"5\", \"0.023255813953488372\"], [\"Dependency\", \"1\", \"0.004651162790697674\"], [\"PluginManagerProgress\", \"1\", \"0.004651162790697674\"], [\"VFSFileChooserDialog\", \"8\", \"0.037209302325581395\"], [\"ConsoleInstall\", \"1\", \"0.004651162790697674\"], [\"NonInteractiveInstall\", \"1\", \"0.004651162790697674\"], [\"GlobalOptions\", \"4\", \"0.018604651162790697\"], [\"InstallThread\", \"2\", \"0.009302325581395349\"], [\"BeanShellErrorDialog\", \"4\", \"0.018604651162790697\"], [\"BeanShell\", \"7\", \"0.03255813953488372\"], [\"IntegerArray\", \"6\", \"0.027906976744186046\"], [\"LongArray\", \"2\", \"0.009302325581395349\"], [\"PluginOptions\", \"4\", \"0.018604651162790697\"], [\"SplashScreen\", \"4\", \"0.018604651162790697\"], [\"WorkThread\", \"3\", \"0.013953488372093023\"], [\"Insert\", \"2\", \"0.009302325581395349\"], [\"ActionBar\", \"6\", \"0.027906976744186046\"], [\"ActionTextField\", \"4\", \"0.018604651162790697\"], [\"LogListModel\", \"2\", \"0.009302325581395349\"], [\"LogViewer\", \"2\", \"0.009302325581395349\"], [\"LogList\", \"2\", \"0.009302325581395349\"], [\"LineContext\", \"6\", \"0.027906976744186046\"], [\"DisplayTokenHandler\", \"2\", \"0.009302325581395349\"], [\"FocusHandler\", \"8\", \"0.037209302325581395\"], [\"OptionsDialog\", \"5\", \"0.023255813953488372\"], [\"DisplayManager\", \"36\", \"0.16744186046511628\"], [\"EditAction\", \"2\", \"0.009302325581395349\"], [\"PluginTableModel\", \"6\", \"0.027906976744186046\"], [\"AbstractOptionPane\", \"2\", \"0.009302325581395349\"], [\"ListUpdater\", \"2\", \"0.009302325581395349\"], [\"InstallPanel\", \"4\", \"0.018604651162790697\"], [\"PluginManager\", \"2\", \"0.009302325581395349\"], [\"BeanShellAction\", \"4\", \"0.018604651162790697\"], [\"Anchor\", \"8\", \"0.037209302325581395\"], [\"ScrollLineCount\", \"14\", \"0.06511627906976744\"], [\"FirstLine\", \"20\", \"0.09302325581395349\"], [\"PaintLineBackground\", \"4\", \"0.018604651162790697\"], [\"MouseWheelHandler\", \"4\", \"0.018604651162790697\"], [\"Word\", \"2\", \"0.009302325581395349\"], [\"ViewConfig\", \"2\", \"0.009302325581395349\"], [\"PerspectiveHandler\", \"2\", \"0.009302325581395349\"], [\"EditServer\", \"4\", \"0.018604651162790697\"], [\"PerspectiveManager\", \"2\", \"0.009302325581395349\"], [\"Range\", \"3\", \"0.013953488372093023\"], [\"EnhancedCheckBoxMenuItem\", \"2\", \"0.009302325581395349\"], [\"EnhancedMenuItem\", \"2\", \"0.009302325581395349\"], [\"EBMessage\", \"2\", \"0.009302325581395349\"], [\"BufferChangeListener\", \"9\", \"0.04186046511627907\"], [\"BufferChangeAdapter\", \"9\", \"0.04186046511627907\"], [\"Rect\", \"3\", \"0.013953488372093023\"], [\"ListHandler\", \"2\", \"0.009302325581395349\"], [\"BrowserHandler\", \"6\", \"0.027906976744186046\"], [\"ManagePanel\", \"6\", \"0.027906976744186046\"], [\"VFSFileNameField\", \"6\", \"0.027906976744186046\"], [\"Debug\", \"5\", \"0.023255813953488372\"], [\"PluginsMenuButton\", \"2\", \"0.009302325581395349\"], [\"VFSDirectoryEntryTable\", \"10\", \"0.046511627906976744\"], [\"PluginManagerOptionPane\", \"2\", \"0.009302325581395349\"], [\"MirrorModel\", \"2\", \"0.009302325581395349\"], [\"DownloadMirrorsThread\", \"2\", \"0.009302325581395349\"], [\"MirrorList\", \"2\", \"0.009302325581395349\"], [\"VFSDirectoryEntryCellRenderer\", \"2\", \"0.009302325581395349\"], [\"VFSDirectoryEntryTableModel\", \"4\", \"0.018604651162790697\"], [\"VFS\", \"9\", \"0.04186046511627907\"], [\"VFSManager\", \"2\", \"0.009302325581395349\"], [\"DirectoryEntry\", \"5\", \"0.023255813953488372\"], [\"OperatingSystem\", \"2\", \"0.009302325581395349\"], [\"OptionGroup\", \"2\", \"0.009302325581395349\"], [\"OptionTreeModel\", \"2\", \"0.009302325581395349\"], [\"PaneNameRenderer\", \"2\", \"0.009302325581395349\"], [\"GetFileTypeRequest\", \"2\", \"0.009302325581395349\"], [\"QuickNotepadPlugin\", \"2\", \"0.009302325581395349\"], [\"HistoryModel\", \"4\", \"0.018604651162790697\"], [\"Listener\", \"2\", \"0.009302325581395349\"], [\"Recorder\", \"8\", \"0.037209302325581395\"], [\"Registers\", \"2\", \"0.009302325581395349\"], [\"EnhancedMenu\", \"2\", \"0.009302325581395349\"], [\"KeyEventWorkaround\", \"8\", \"0.037209302325581395\"], [\"WorkThreadPool\", \"2\", \"0.009302325581395349\"], [\"RingListModel\", \"2\", \"0.009302325581395349\"], [\"DirectoryLoadedAWTRequest\", \"4\", \"0.018604651162790697\"], [\"EditBusStub\", \"4\", \"0.018604651162790697\"], [\"CompoundEdit\", \"2\", \"0.009302325581395349\"], [\"RecentFilesProvider\", \"2\", \"0.009302325581395349\"], [\"PasteFromListDialog\", \"2\", \"0.009302325581395349\"], [\"PaintWrapGuide\", \"4\", \"0.018604651162790697\"], [\"KeywordMap\", \"2\", \"0.009302325581395349\"], [\"InputPane\", \"2\", \"0.009302325581395349\"], [\"PosBottomHalf\", \"5\", \"0.023255813953488372\"], [\"KeyEventTranslator\", \"5\", \"0.023255813953488372\"], [\"RemoveButton\", \"5\", \"0.023255813953488372\"], [\"PositionManager\", \"3\", \"0.013953488372093023\"], [\"StructureMatcher\", \"2\", \"0.009302325581395349\"], [\"ParentMouseHandler\", \"2\", \"0.009302325581395349\"], [\"NameSpace\", \"2\", \"0.009302325581395349\"], [\"CommandPathEntry\", \"2\", \"0.009302325581395349\"], [\"Factory\", \"2\", \"0.009302325581395349\"], [\"FavoritesEntry\", \"2\", \"0.009302325581395349\"], [\"DropHandler\", \"2\", \"0.009302325581395349\"], [\"TextAreaTransferHandler\", \"6\", \"0.027906976744186046\"], [\"Java14\", \"2\", \"0.009302325581395349\"], [\"TextAreaSelection\", \"2\", \"0.009302325581395349\"], [\"LocalDirectoryEntry\", \"2\", \"0.009302325581395349\"], [\"TextAreaDialog\", \"2\", \"0.009302325581395349\"], [\"TokenHandler\", \"2\", \"0.009302325581395349\"], [\"DefaultTokenHandler\", \"2\", \"0.009302325581395349\"], [\"DummyTokenHandler\", \"2\", \"0.009302325581395349\"], [\"LineInfo\", \"6\", \"0.027906976744186046\"], [\"WorkThreadHandler\", \"2\", \"0.009302325581395349\"], [\"XmlParser\", \"1\", \"0.004651162790697674\"], [\"BufferListSet\", \"1\", \"0.004651162790697674\"], [\"LineManager\", \"2\", \"0.009302325581395349\"], [\"HistoryTextArea\", \"2\", \"0.009302325581395349\"], [\"PaintText\", \"2\", \"0.009302325581395349\"], [\"Entry\", \"3\", \"0.013953488372093023\"], [\"LocalFile\", \"1\", \"0.004651162790697674\"], [\"BufferInsertRequest\", \"1\", \"0.004651162790697674\"], [\"BufferAutosaveRequest\", \"1\", \"0.004651162790697674\"], [\"BufferLoadRequest\", \"2\", \"0.009302325581395349\"], [\"IndentAction\", \"4\", \"0.018604651162790697\"], [\"FastRepaintManager\", \"2\", \"0.009302325581395349\"], [\"IndentRuleFactory\", \"4\", \"0.018604651162790697\"], [\"RegexpIndentRule\", \"6\", \"0.027906976744186046\"], [\"BracketIndentRule\", \"6\", \"0.027906976744186046\"], [\"IndentRule\", \"6\", \"0.027906976744186046\"], [\"CloseBracketIndentRule\", \"6\", \"0.027906976744186046\"], [\"OpenBracketIndentRule\", \"6\", \"0.027906976744186046\"], [\"Increase\", \"4\", \"0.018604651162790697\"], [\"AlignBracket\", \"4\", \"0.018604651162790697\"], [\"Decrease\", \"2\", \"0.009302325581395349\"], [\"Collapse\", \"2\", \"0.009302325581395349\"], [\"Reset\", \"2\", \"0.009302325581395349\"], [\"AbbrevsModel\", \"1\", \"0.004651162790697674\"], [\"TextAreaHighlight\", \"1\", \"0.004651162790697674\"], [\"AbbrevEditor\", \"1\", \"0.004651162790697674\"], [\"AddAbbrevDialog\", \"1\", \"0.004651162790697674\"], [\"AbbrevsOptionPane\", \"3\", \"0.013953488372093023\"], [\"EditAbbrevDialog\", \"1\", \"0.004651162790697674\"], [\"TreeSelectionHandler\", \"1\", \"0.004651162790697674\"], [\"SelectionHandler\", \"1\", \"0.004651162790697674\"], [\"ShortcutsOptionPane\", \"1\", \"0.004651162790697674\"], [\"HyperSearchResult\", \"3\", \"0.013953488372093023\"], [\"WindowTableModel\", \"1\", \"0.004651162790697674\"], [\"Token\", \"2\", \"0.009302325581395349\"], [\"SearchMatcher\", \"1\", \"0.004651162790697674\"], [\"SettingsActionHandler\", \"1\", \"0.004651162790697674\"], [\"BoyerMooreSearchMatcher\", \"1\", \"0.004651162790697674\"], [\"TokenList\", \"1\", \"0.004651162790697674\"], [\"RESearchMatcher\", \"1\", \"0.004651162790697674\"], [\"BrowserColorsModel\", \"1\", \"0.004651162790697674\"], [\"BrowserColorsOptionPane\", \"1\", \"0.004651162790697674\"], [\"FoldListener\", \"1\", \"0.004651162790697674\"], [\"FoldHandler\", \"1\", \"0.004651162790697674\"], [\"ExplicitFoldHandler\", \"1\", \"0.004651162790697674\"], [\"IndentFoldHandler\", \"1\", \"0.004651162790697674\"], [\"DummyFoldHandler\", \"1\", \"0.004651162790697674\"], [\"BufferUpdate\", \"2\", \"0.009302325581395349\"], [\"FoldVisibilityMap\", \"1\", \"0.004651162790697674\"], [\"CustomButton\", \"1\", \"0.004651162790697674\"], [\"LineElement\", \"1\", \"0.004651162790697674\"], [\"RootElement\", \"1\", \"0.004651162790697674\"], [\"ReadWriteLock\", \"2\", \"0.009302325581395349\"], [\"SegmentBuffer\", \"1\", \"0.004651162790697674\"], [\"SelectLineRange\", \"1\", \"0.004651162790697674\"], [\"FloatingWindowContainer\", \"1\", \"0.004651162790697674\"], [\"CurrentDirectoryMenu\", \"2\", \"0.009302325581395349\"], [\"RecentFilesMenu\", \"2\", \"0.009302325581395349\"], [\"RecentDirectoriesMenu\", \"2\", \"0.009302325581395349\"], [\"TreeHandler\", \"1\", \"0.004651162790697674\"], [\"LoadSaveOptionPane\", \"1\", \"0.004651162790697674\"], [\"SwingInstall\", \"2\", \"0.009302325581395349\"], [\"OpenWithEncodingMenu\", \"1\", \"0.004651162790697674\"], [\"TextPanel\", \"1\", \"0.004651162790697674\"], [\"ComponentHandler\", \"1\", \"0.004651162790697674\"], [\"MyFocusManager\", \"1\", \"0.004651162790697674\"], [\"TableMouseHandler\", \"1\", \"0.004651162790697674\"], [\"ClipboardRegister\", \"1\", \"0.004651162790697674\"], [\"MarkersSaveRequest\", \"1\", \"0.004651162790697674\"], [\"BufferOptionPane\", \"1\", \"0.004651162790697674\"], [\"ThreadAbortMonitor\", \"1\", \"0.004651162790697674\"]]"
            },
            "m5": {
                "content": "The co-change relationships for `Buffer.java` reveal several entities that are frequently modified together with `Buffer.java`. The confidence values indicate the likelihood of these files being changed in conjunction with `Buffer.java`. Based on this data, we should prioritize analyzing the impact of changes on entities with high confidence scores.\n\nHere are some observations from the results:\n1. **JEditTextArea (0.5814)**: This file has the highest confidence score, meaning it is highly coupled with `Buffer.java`. Changes to `Buffer.java` likely affect `JEditTextArea`.\n2. **jEdit (0.2419)**: As the core class of the application, it's expected to be tightly coupled with `Buffer.java`.\n3. **VFSBrowser (0.1814), ChunkCache (0.1814), MouseHandler (0.1907), OffsetManager (0.1907), DisplayManager (0.1674), BufferChangeHandler (0.1674)**: These classes have relatively high confidence values and may also need synchronization.\n4. **Others**: Many other files like `TextAreaPainter`, `EditPane`, etc., show moderate coupling and might also require analysis.\n\nTo proceed, I will analyze one of the most significant co-changed entities using additional tools to understand deeper dependencies. Let's first check coupling dependencies between `Buffer.java` and `JEditTextArea.java` since it has the highest confidence value.\n\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_f813d5b70d11482b8ba699",
                        "function": {
                            "arguments": "{\"entity1\": \"Buffer.java\", \"entity2\": \"JEditTextArea.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m6": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"There are no coupling dependencies between these two entities\"]"
            },
            "m7": {
                "content": "There are no direct coupling dependencies between `Buffer.java` and `JEditTextArea.java`. This suggests that the co-change relationship might be due to indirect interactions or shared functionality through other entities.\n\nLet's analyze the conceptual coupling (semantic similarity) between these two files to understand if they share common functionalities or themes. This can help determine why they are frequently co-changed.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_b35888c3b30c4a7b9c2660",
                        "function": {
                            "arguments": "{\"entity1\": \"Buffer.java\", \"entity2\": \"JEditTextArea.java\"}",
                            "name": "get_conceptual_coupling"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m8": {
                "role": "tool",
                "name": "get_conceptual_coupling",
                "content": "\"0.6836691\""
            },
            "m9": {
                "content": "The conceptual coupling (semantic similarity) between `Buffer.java` and `JEditTextArea.java` is approximately **0.6837**, which indicates a moderate level of semantic similarity. This suggests that, while there are no direct coupling dependencies, the two entities share some common themes or functionalities.\n\nThis moderate conceptual coupling could explain why these files are frequently co-changed\u2014changes in one might necessitate changes in the other due to shared logic or responsibilities, even if they do not directly reference each other.\n\nNext, let's examine the call graph for `Buffer.java` to understand what other entities it interacts with directly. This will help us identify potential ripple effects of a change in `Buffer.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_022dbe4b289e4e319ece0e",
                        "function": {
                            "arguments": "{\"entity\": \"Buffer.java\"}",
                            "name": "get_call_graph"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m10": {
                "role": "tool",
                "name": "get_call_graph",
                "content": "[\"RESearchMatcher\", \"VFSBrowser\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]"
            },
            "m11": {
                "content": "The call graph for `Buffer.java` shows that it directly interacts with entities such as `RESearchMatcher` and `VFSBrowser`. Some entries in the call graph appear to be empty or invalid, which could indicate parsing issues or lack of clear references.\n\nGiven this information, we should investigate the coupling dependencies between `Buffer.java` and `VFSBrowser.java`, as it is both a direct dependency (from the call graph) and shows a relatively high co-change confidence (0.1814). This will help us understand if there are direct structural dependencies between these two files.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_bafadb4c18cf42bd98a75a",
                        "function": {
                            "arguments": "{\"entity1\": \"Buffer.java\", \"entity2\": \"VFSBrowser.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m12": {
                "content": "Similar to the case with `JEditTextArea.java`, there are no direct coupling dependencies between `Buffer.java` and `VFSBrowser.java`. However, `VFSBrowser.java` appears in both the co-change relationships and the call graph of `Buffer.java`, suggesting an indirect or runtime dependency.\n\nTo better understand the potential impact of changes to `Buffer.java`, it would be useful to examine its source code. This will help identify any implicit dependencies, semantic overlaps, or runtime interactions that may not be captured by structural analysis tools.\n\nLet's retrieve the source code for `Buffer.java` now.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_a59e1990382e4a1d83afcc",
                        "function": {
                            "arguments": "{\"entity\": \"Buffer.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m13": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package org.gjt.sp.jedit;\\nimport gnu.regexp.*;\\nimport javax.swing.*;\\nimport javax.swing.text.*;\\nimport java.awt.Toolkit;\\nimport java.io.File;\\nimport java.io.IOException;\\nimport java.net.Socket;\\nimport java.util.*;\\nimport org.gjt.sp.jedit.browser.VFSBrowser;\\nimport org.gjt.sp.jedit.buffer.*;\\nimport org.gjt.sp.jedit.io.*;\\nimport org.gjt.sp.jedit.msg.*;\\nimport org.gjt.sp.jedit.search.RESearchMatcher;\\nimport org.gjt.sp.jedit.syntax.*;\\nimport org.gjt.sp.jedit.textarea.*;\\nimport org.gjt.sp.util.*;\\npublic class Buffer\\n{\\n\\tpublic static final String LINESEP = \\\"lineSeparator\\\";\\n\\tpublic static final String BACKED_UP = \\\"Buffer__backedUp\\\";\\n\\tpublic static final String CARET = \\\"Buffer__caret\\\";\\n\\tpublic static final String SELECTION = \\\"Buffer__selection\\\";\\n\\tpublic static final String SCROLL_VERT = \\\"Buffer__scrollVert\\\";\\n\\tpublic static final String SCROLL_HORIZ = \\\"Buffer__scrollHoriz\\\";\\n\\tpublic static final String ENCODING = \\\"encoding\\\";\\n\\tpublic static final String TRAILING_EOL = \\\"trailingEOL\\\";\\n\\tpublic static final String GZIPPED = \\\"gzipped\\\";\\n\\tpublic void showInsertFileDialog(View view)\\n\\t{\\n\\t\\tString[] files = GUIUtilities.showVFSFileDialog(view,null,\\n\\t\\t\\tVFSBrowser.OPEN_DIALOG,false);\\n\\t\\tif(files != null)\\n\\t\\t\\tinsertFile(view,files[0]);\\n\\t} \\n\\tpublic void reload(View view)\\n\\t{\\n\\t\\tif(getFlag(DIRTY))\\n\\t\\t{\\n\\t\\t\\tString[] args = { name };\\n\\t\\t\\tint result = GUIUtilities.confirm(view,\\\"changedreload\\\",\\n\\t\\t\\t\\targs,JOptionPane.YES_NO_OPTION,\\n\\t\\t\\t\\tJOptionPane.WARNING_MESSAGE);\\n\\t\\t\\tif(result != JOptionPane.YES_OPTION)\\n\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tview.getEditPane().saveCaretInfo();\\n\\t\\tload(view,true);\\n\\t} \\n\\tpublic boolean load(final View view, final boolean reload)\\n\\t{\\n\\t\\tif(isPerformingIO())\\n\\t\\t{\\n\\t\\t\\tGUIUtilities.error(view,\\\"buffer-multiple-io\\\",null);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tsetBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);\\n\\t\\tsetFlag(LOADING,true);\\n\\t\\t\\t\\t\\t\\t\\t\\tif(!getFlag(TEMPORARY))\\n\\t\\t\\tEditBus.send(new BufferUpdate(this,view,BufferUpdate.LOAD_STARTED));\\n\\t\\tfinal boolean loadAutosave;\\n\\t\\tif(reload || !getFlag(NEW_FILE))\\n\\t\\t{\\n\\t\\t\\tif(file != null)\\n\\t\\t\\t\\tmodTime = file.lastModified();\\n\\t\\t\\t\\t\\t\\tif(!reload && autosaveFile != null && autosaveFile.exists())\\n\\t\\t\\t\\tloadAutosave = recoverAutosave(view);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(autosaveFile != null)\\n\\t\\t\\t\\t\\tautosaveFile.delete();\\n\\t\\t\\t\\tloadAutosave = false;\\n\\t\\t\\t}\\n\\t\\t\\tif(!loadAutosave)\\n\\t\\t\\t{\\n\\t\\t\\t\\tVFS vfs = VFSManager.getVFSForPath(path);\\n\\t\\t\\t\\tif(!checkFileForLoad(view,vfs,path))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsetFlag(LOADING,false);\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(isNewFile())\\n\\t\\t\\t\\t\\t;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!vfs.load(view,this,path))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tsetFlag(LOADING,false);\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tloadAutosave = false;\\n\\t\\t\\t\\tRunnable runnable = new Runnable()\\n\\t\\t{\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\tString newPath = getStringProperty(\\n\\t\\t\\t\\t\\tBufferIORequest.NEW_PATH);\\n\\t\\t\\t\\tSegment seg = (Segment)getProperty(\\n\\t\\t\\t\\t\\tBufferIORequest.LOAD_DATA);\\n\\t\\t\\t\\tIntegerArray endOffsets = (IntegerArray)\\n\\t\\t\\t\\t\\tgetProperty(BufferIORequest.END_OFFSETS);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tboolean readOnly = isReadOnly();\\n\\t\\t\\t\\tsetFlag(READ_ONLY,false);\\n\\t\\t\\t\\t\\t\\t\\t\\tremove(0,getLength());\\n\\t\\t\\t\\tif(seg == null)\\n\\t\\t\\t\\t\\tseg = new Segment(new char[1024],0,0);\\n\\t\\t\\t\\tif(endOffsets == null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tendOffsets = new IntegerArray();\\n\\t\\t\\t\\t\\tendOffsets.add(1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twriteLock();\\n\\t\\t\\t\\t\\tif(contentMgr.getLength() != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tfirePreContentRemoved(0,0,\\n\\t\\t\\t\\t\\t\\t\\toffsetMgr.getLineCount(),\\n\\t\\t\\t\\t\\t\\t\\tcontentMgr.getLength() - 1);\\n\\t\\t\\t\\t\\t\\tfireContentRemoved(0,0,\\n\\t\\t\\t\\t\\t\\t\\toffsetMgr.getLineCount(),\\n\\t\\t\\t\\t\\t\\t\\tcontentMgr.getLength() - 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcontentMgr._setContent(seg.array,seg.count);\\n\\t\\t\\t\\t\\toffsetMgr._contentInserted(endOffsets);\\n\\t\\t\\t\\t\\tfireContentInserted(0,0,\\n\\t\\t\\t\\t\\t\\tendOffsets.getSize() - 1,\\n\\t\\t\\t\\t\\t\\tseg.count - 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfinally\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twriteUnlock();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsetFlag(READ_ONLY,readOnly);\\n\\t\\t\\t\\tunsetProperty(BufferIORequest.LOAD_DATA);\\n\\t\\t\\t\\tunsetProperty(BufferIORequest.END_OFFSETS);\\n\\t\\t\\t\\tunsetProperty(BufferIORequest.NEW_PATH);\\n\\t\\t\\t\\tundoMgr.clear();\\n\\t\\t\\t\\tundoMgr.setLimit(jEdit.getIntegerProperty(\\n\\t\\t\\t\\t\\t\\\"buffer.undoCount\\\",100));\\n\\t\\t\\t\\tif(!getFlag(TEMPORARY))\\n\\t\\t\\t\\t\\tfinishLoading();\\n\\t\\t\\t\\tsetFlag(LOADING,false);\\n\\t\\t\\t\\t\\t\\t\\t\\tif(reload)\\n\\t\\t\\t\\t\\tsetDirty(false);\\n\\t\\t\\t\\tif(!loadAutosave && newPath != null)\\n\\t\\t\\t\\t\\tsetPath(newPath);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(loadAutosave)\\n\\t\\t\\t\\t\\tsetFlag(DIRTY,true);\\n\\t\\t\\t\\t\\t\\t\\t\\tif(!getFlag(TEMPORARY))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tEditBus.send(new BufferUpdate(Buffer.this,\\n\\t\\t\\t\\t\\t\\tview,BufferUpdate.LOADED));\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}; \\n\\t\\tif(getFlag(TEMPORARY))\\n\\t\\t\\trunnable.run();\\n\\t\\telse\\n\\t\\t\\tVFSManager.runInAWTThread(runnable);\\n\\t\\treturn true;\\n\\t} \\n\\tpublic boolean insertFile(final View view, String path)\\n\\t{\\n\\t\\tif(isPerformingIO())\\n\\t\\t{\\n\\t\\t\\tGUIUtilities.error(view,\\\"buffer-multiple-io\\\",null);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tsetBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);\\n\\t\\tpath = MiscUtilities.constructPath(this.path,path);\\n\\t\\tBuffer buffer = jEdit.getBuffer(path);\\n\\t\\tif(buffer != null)\\n\\t\\t{\\n\\t\\t\\tview.getTextArea().setSelectedText(\\n\\t\\t\\t\\tbuffer.getText(0,buffer.getLength()));\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tVFS vfs = VFSManager.getVFSForPath(path);\\n\\t\\tsetFlag(IO,true);\\n\\t\\t\\t\\t\\t\\t\\t\\tif(!vfs.insert(view,this,path))\\n\\t\\t{\\n\\t\\t\\tsetFlag(IO,false);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\t\\tVFSManager.runInAWTThread(new Runnable()\\n\\t\\t{\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFlag(IO,false);\\n\\t\\t\\t\\tSegmentBuffer sbuf = (SegmentBuffer)getProperty(\\n\\t\\t\\t\\t\\tBufferIORequest.LOAD_DATA);\\n\\t\\t\\t\\tif(sbuf != null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tunsetProperty(BufferIORequest.LOAD_DATA);\\n\\t\\t\\t\\t\\tview.getTextArea().setSelectedText(sbuf.toString());\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\treturn true;\\n\\t} \\n\\tpublic void autosave()\\n\\t{\\n\\t\\tif(autosaveFile == null || !getFlag(AUTOSAVE_DIRTY)\\n\\t\\t\\t|| !getFlag(DIRTY)\\n\\t\\t\\t|| getFlag(LOADING)\\n\\t\\t\\t|| getFlag(IO))\\n\\t\\t\\treturn;\\n\\t\\tsetFlag(AUTOSAVE_DIRTY,false);\\n\\t\\tVFSManager.runInWorkThread(new BufferIORequest(\\n\\t\\t\\tBufferIORequest.AUTOSAVE,null,this,null,\\n\\t\\t\\tVFSManager.getFileVFS(),autosaveFile.getPath()));\\n\\t} \\n\\tpublic boolean saveAs(View view, boolean rename)\\n\\t{\\n\\t\\tString[] files = GUIUtilities.showVFSFileDialog(view,path,\\n\\t\\t\\tVFSBrowser.SAVE_DIALOG,false);\\n\\t\\t\\t\\t\\t\\tif(files == null)\\n\\t\\t\\treturn false;\\n\\t\\treturn save(view,files[0],rename);\\n\\t} \\n\\tpublic boolean save(View view, String path)\\n\\t{\\n\\t\\treturn save(view,path,true);\\n\\t} \\n\\tpublic boolean save(final View view, String path, final boolean rename)\\n\\t{\\n\\t\\tif(isPerformingIO())\\n\\t\\t{\\n\\t\\t\\tGUIUtilities.error(view,\\\"buffer-multiple-io\\\",null);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tsetBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);\\n\\t\\tif(path == null && getFlag(NEW_FILE))\\n\\t\\t\\treturn saveAs(view,rename);\\n\\t\\tif(path == null && file != null)\\n\\t\\t{\\n\\t\\t\\tlong newModTime = file.lastModified();\\n\\t\\t\\tif(newModTime != modTime\\n\\t\\t\\t\\t&& jEdit.getBooleanProperty(\\\"view.checkModStatus\\\"))\\n\\t\\t\\t{\\n\\t\\t\\t\\tObject[] args = { this.path };\\n\\t\\t\\t\\tint result = GUIUtilities.confirm(view,\\n\\t\\t\\t\\t\\t\\\"filechanged-save\\\",args,\\n\\t\\t\\t\\t\\tJOptionPane.YES_NO_OPTION,\\n\\t\\t\\t\\t\\tJOptionPane.WARNING_MESSAGE);\\n\\t\\t\\t\\tif(result != JOptionPane.YES_OPTION)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsetFlag(IO,true);\\n\\t\\tEditBus.send(new BufferUpdate(this,view,BufferUpdate.SAVING));\\n\\t\\tfinal String oldPath = this.path;\\n\\t\\tfinal String newPath = (path == null ? this.path : path);\\n\\t\\tVFS vfs = VFSManager.getVFSForPath(newPath);\\n\\t\\tif(!checkFileForSave(view,vfs,newPath))\\n\\t\\t{\\n\\t\\t\\tsetFlag(IO,false);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tif(!vfs.save(view,this,newPath))\\n\\t\\t{\\n\\t\\t\\tsetFlag(IO,false);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\t\\tVFSManager.runInAWTThread(new Runnable()\\n\\t\\t{\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFlag(IO,false);\\n\\t\\t\\t\\tfinishSaving(view,oldPath,newPath,rename,\\n\\t\\t\\t\\t\\tgetBooleanProperty(BufferIORequest\\n\\t\\t\\t\\t\\t.ERROR_OCCURRED));\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\treturn true;\\n\\t} \\n\\t\\tpublic static final int FILE_NOT_CHANGED = 0;\\n\\tpublic static final int FILE_CHANGED = 1;\\n\\tpublic static final int FILE_DELETED = 2;\\n\\tpublic int checkFileStatus(View view)\\n\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(!getFlag(IO) && !getFlag(LOADING) && file != null\\n\\t\\t\\t&& !getFlag(NEW_FILE))\\n\\t\\t{\\n\\t\\t\\tboolean newReadOnly = (file.exists() && !file.canWrite());\\n\\t\\t\\tif(newReadOnly != getFlag(READ_ONLY))\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFlag(READ_ONLY,newReadOnly);\\n\\t\\t\\t\\tEditBus.send(new BufferUpdate(this,null,\\n\\t\\t\\t\\t\\tBufferUpdate.DIRTY_CHANGED));\\n\\t\\t\\t}\\n\\t\\t\\tlong oldModTime = modTime;\\n\\t\\t\\tlong newModTime = file.lastModified();\\n\\t\\t\\tif(newModTime != oldModTime)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmodTime = newModTime;\\n\\t\\t\\t\\tif(!file.exists())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsetFlag(NEW_FILE,true);\\n\\t\\t\\t\\t\\tsetDirty(true);\\n\\t\\t\\t\\t\\treturn FILE_DELETED;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn FILE_CHANGED;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn FILE_NOT_CHANGED;\\n\\t} \\n\\tpublic long getLastModified()\\n\\t{\\n\\t\\treturn modTime;\\n\\t} \\n\\tpublic void setLastModified(long modTime)\\n\\t{\\n\\t\\tthis.modTime = modTime;\\n\\t} \\n\\tpublic VFS getVFS()\\n\\t{\\n\\t\\treturn VFSManager.getVFSForPath(path);\\n\\t} \\n\\tpublic final File getAutosaveFile()\\n\\t{\\n\\t\\treturn autosaveFile;\\n\\t} \\n\\tpublic final String getName()\\n\\t{\\n\\t\\treturn name;\\n\\t} \\n\\tpublic final String getPath()\\n\\t{\\n\\t\\treturn path;\\n\\t} \\n\\tpublic final String getSymlinkPath()\\n\\t{\\n\\t\\treturn symlinkPath;\\n\\t} \\n\\tpublic String getDirectory()\\n\\t{\\n\\t\\treturn directory;\\n\\t} \\n\\tpublic final boolean isClosed()\\n\\t{\\n\\t\\treturn getFlag(CLOSED);\\n\\t} \\n\\tpublic final boolean isLoaded()\\n\\t{\\n\\t\\treturn !getFlag(LOADING);\\n\\t} \\n\\tpublic final boolean isPerformingIO()\\n\\t{\\n\\t\\treturn getFlag(LOADING) || getFlag(IO);\\n\\t} \\n\\tpublic final boolean isNewFile()\\n\\t{\\n\\t\\treturn getFlag(NEW_FILE);\\n\\t} \\n\\tpublic final void setNewFile(boolean newFile)\\n\\t{\\n\\t\\tsetFlag(NEW_FILE,newFile);\\n\\t\\tif(!newFile)\\n\\t\\t\\tsetFlag(UNTITLED,false);\\n\\t} \\n\\tpublic final boolean isUntitled()\\n\\t{\\n\\t\\treturn getFlag(UNTITLED);\\n\\t} \\n\\tpublic final boolean isDirty()\\n\\t{\\n\\t\\treturn getFlag(DIRTY);\\n\\t} \\n\\tpublic final boolean isReadOnly()\\n\\t{\\n\\t\\treturn getFlag(READ_ONLY);\\n\\t} \\n\\tpublic final boolean isEditable()\\n\\t{\\n\\t\\treturn !(getFlag(READ_ONLY) || getFlag(IO) || getFlag(LOADING));\\n\\t} \\n\\tpublic final void setReadOnly(boolean readOnly)\\n\\t{\\n\\t\\tsetFlag(READ_ONLY,readOnly);\\n\\t} \\n\\tpublic void setDirty(boolean d)\\n\\t{\\n\\t\\tboolean old_d = getFlag(DIRTY);\\n\\t\\tif(d)\\n\\t\\t{\\n\\t\\t\\tif(getFlag(LOADING) || getFlag(READ_ONLY))\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(getFlag(DIRTY) && getFlag(AUTOSAVE_DIRTY))\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tsetFlag(DIRTY,true);\\n\\t\\t\\tsetFlag(AUTOSAVE_DIRTY,true);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tsetFlag(DIRTY,false);\\n\\t\\t\\tsetFlag(AUTOSAVE_DIRTY,false);\\n\\t\\t\\tif(autosaveFile != null)\\n\\t\\t\\t\\tautosaveFile.delete();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(!getFlag(UNDO_IN_PROGRESS))\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tundoMgr.bufferSaved();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(d != old_d)\\n\\t\\t{\\n\\t\\t\\tEditBus.send(new BufferUpdate(this,null,\\n\\t\\t\\t\\tBufferUpdate.DIRTY_CHANGED));\\n\\t\\t}\\n\\t} \\n\\tpublic boolean isTemporary()\\n\\t{\\n\\t\\treturn getFlag(TEMPORARY);\\n\\t} \\n\\tpublic Icon getIcon()\\n\\t{\\n\\t\\tif(getFlag(DIRTY))\\n\\t\\t\\treturn GUIUtilities.DIRTY_BUFFER_ICON;\\n\\t\\telse if(getFlag(READ_ONLY))\\n\\t\\t\\treturn GUIUtilities.READ_ONLY_BUFFER_ICON;\\n\\t\\telse if(getFlag(NEW_FILE))\\n\\t\\t\\treturn GUIUtilities.NEW_BUFFER_ICON;\\n\\t\\telse\\n\\t\\t\\treturn GUIUtilities.NORMAL_BUFFER_ICON;\\n\\t} \\n\\tpublic final void readLock()\\n\\t{\\n\\t\\tlock.readLock();\\n\\t} \\n\\tpublic final void readUnlock()\\n\\t{\\n\\t\\tlock.readUnlock();\\n\\t} \\n\\tpublic final void writeLock()\\n\\t{\\n\\t\\tlock.writeLock();\\n\\t} \\n\\tpublic final void writeUnlock()\\n\\t{\\n\\t\\tlock.writeUnlock();\\n\\t} \\n\\tpublic int getLength()\\n\\t{\\n\\t\\t\\t\\treturn contentMgr.getLength();\\n\\t} \\n\\tpublic int getLineCount()\\n\\t{\\n\\t\\t\\t\\treturn offsetMgr.getLineCount();\\n\\t} \\n\\tpublic final int getLineOfOffset(int offset)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tif(offset < 0 || offset > getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(offset);\\n\\t\\t\\treturn offsetMgr.getLineOfOffset(offset);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic int getLineStartOffset(int line)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tif(line < 0 || line >= offsetMgr.getLineCount())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(line);\\n\\t\\t\\telse if(line == 0)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\treturn offsetMgr.getLineEndOffset(line - 1);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic int getLineEndOffset(int line)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tif(line < 0 || line >= offsetMgr.getLineCount())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(line);\\n\\t\\t\\treturn offsetMgr.getLineEndOffset(line);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic int getLineLength(int line)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\treturn getLineEndOffset(line)\\n\\t\\t\\t\\t- getLineStartOffset(line) - 1;\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic String getLineText(int lineIndex)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\treturn getText(getLineStartOffset(lineIndex),\\n\\t\\t\\t\\tgetLineLength(lineIndex));\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void getLineText(int lineIndex, Segment segment)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tgetText(getLineStartOffset(lineIndex),\\n\\t\\t\\t\\tgetLineLength(lineIndex),segment);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic String getText(int start, int length)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tif(start < 0 || length < 0\\n\\t\\t\\t\\t|| start + length > contentMgr.getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(start + \\\":\\\" + length);\\n\\t\\t\\treturn contentMgr.getText(start,length);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void getText(int start, int length, Segment seg)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tif(start < 0 || length < 0\\n\\t\\t\\t\\t|| start + length > contentMgr.getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(start + \\\":\\\" + length);\\n\\t\\t\\tcontentMgr.getText(start,length,seg);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void insert(int offset, String str)\\n\\t{\\n\\t\\tif(str == null)\\n\\t\\t\\treturn;\\n\\t\\tint len = str.length();\\n\\t\\tif(len == 0)\\n\\t\\t\\treturn;\\n\\t\\tif(isReadOnly())\\n\\t\\t\\tthrow new RuntimeException(\\\"buffer read-only\\\");\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tif(offset < 0 || offset > contentMgr.getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(offset);\\n\\t\\t\\tcontentMgr.insert(offset,str);\\n\\t\\t\\tintegerArray.clear();\\n\\t\\t\\tfor(int i = 0; i < len; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(str.charAt(i) == '\\\\n')\\n\\t\\t\\t\\t\\tintegerArray.add(i + 1);\\n\\t\\t\\t}\\n\\t\\t\\tif(!getFlag(UNDO_IN_PROGRESS))\\n\\t\\t\\t{\\n\\t\\t\\t\\tundoMgr.contentInserted(offset,len,str,\\n\\t\\t\\t\\t\\t!getFlag(DIRTY));\\n\\t\\t\\t}\\n\\t\\t\\tcontentInserted(offset,len,integerArray);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void insert(int offset, Segment seg)\\n\\t{\\n\\t\\tif(seg.count == 0)\\n\\t\\t\\treturn;\\n\\t\\tif(isReadOnly())\\n\\t\\t\\tthrow new RuntimeException(\\\"buffer read-only\\\");\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tif(offset < 0 || offset > contentMgr.getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(offset);\\n\\t\\t\\tcontentMgr.insert(offset,seg);\\n\\t\\t\\tintegerArray.clear();\\n\\t\\t\\tfor(int i = 0; i < seg.count; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(seg.array[seg.offset + i] == '\\\\n')\\n\\t\\t\\t\\t\\tintegerArray.add(i + 1);\\n\\t\\t\\t}\\n\\t\\t\\tif(!getFlag(UNDO_IN_PROGRESS))\\n\\t\\t\\t{\\n\\t\\t\\t\\tundoMgr.contentInserted(offset,seg.count,\\n\\t\\t\\t\\t\\tseg.toString(),!getFlag(DIRTY));\\n\\t\\t\\t}\\n\\t\\t\\tcontentInserted(offset,seg.count,integerArray);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void remove(int offset, int length)\\n\\t{\\n\\t\\tif(length == 0)\\n\\t\\t\\treturn;\\n\\t\\tif(isReadOnly())\\n\\t\\t\\tthrow new RuntimeException(\\\"buffer read-only\\\");\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tif(offset < 0 || length < 0\\n\\t\\t\\t\\t|| offset + length > contentMgr.getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(offset + \\\":\\\" + length);\\n\\t\\t\\tint startLine = offsetMgr.getLineOfOffset(offset);\\n\\t\\t\\tcontentMgr.getText(offset,length,seg);\\n\\t\\t\\tint numLines = 0;\\n\\t\\t\\tfor(int i = 0; i < seg.count; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(seg.array[seg.offset + i] == '\\\\n')\\n\\t\\t\\t\\t\\tnumLines++;\\n\\t\\t\\t}\\n\\t\\t\\tif(!getFlag(UNDO_IN_PROGRESS))\\n\\t\\t\\t{\\n\\t\\t\\t\\tundoMgr.contentRemoved(offset,length,\\n\\t\\t\\t\\t\\tseg.toString(),!getFlag(DIRTY));\\n\\t\\t\\t}\\n\\t\\t\\tfirePreContentRemoved(startLine,offset,numLines,length);\\n\\t\\t\\tcontentMgr.remove(offset,length);\\n\\t\\t\\toffsetMgr.contentRemoved(startLine,offset,numLines,length);\\n\\t\\t\\tfireContentRemoved(startLine,offset,numLines,length);\\n\\t\\t\\tsetDirty(true);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void undo(JEditTextArea textArea)\\n\\t{\\n\\t\\tif(undoMgr == null)\\n\\t\\t\\treturn;\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\ttextArea.getToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tsetFlag(UNDO_IN_PROGRESS,true);\\n\\t\\t\\tif(!undoMgr.undo(textArea))\\n\\t\\t\\t\\ttextArea.getToolkit().beep();\\n\\t\\t\\tfireTransactionComplete();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tsetFlag(UNDO_IN_PROGRESS,false);\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void redo(JEditTextArea textArea)\\n\\t{\\n\\t\\tif(undoMgr == null)\\n\\t\\t\\treturn;\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tToolkit.getDefaultToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tsetFlag(UNDO_IN_PROGRESS,true);\\n\\t\\t\\tif(!undoMgr.redo(textArea))\\n\\t\\t\\t\\ttextArea.getToolkit().beep();\\n\\t\\t\\tfireTransactionComplete();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tsetFlag(UNDO_IN_PROGRESS,false);\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic boolean isTransactionInProgress()\\n\\t{\\n\\t\\treturn getFlag(UNDO_IN_PROGRESS) || insideCompoundEdit();\\n\\t} \\n\\tpublic void beginCompoundEdit()\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tundoMgr.beginCompoundEdit();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void endCompoundEdit()\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tundoMgr.endCompoundEdit();\\n\\t\\t\\tif(!insideCompoundEdit())\\n\\t\\t\\t\\tfireTransactionComplete();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t}\\n\\tpublic boolean insideCompoundEdit()\\n\\t{\\n\\t\\treturn undoMgr.insideCompoundEdit();\\n\\t} \\n\\t\\tpublic static final int NORMAL_PRIORITY = 0;\\n\\tpublic static final int HIGH_PRIORITY = 1;\\n\\tstatic class Listener\\n\\t{\\n\\t\\tBufferChangeListener listener;\\n\\t\\tint priority;\\n\\t\\tListener(BufferChangeListener listener, int priority)\\n\\t\\t{\\n\\t\\t\\tthis.listener = listener;\\n\\t\\t\\tthis.priority = priority;\\n\\t\\t}\\n\\t}\\n\\tpublic void addBufferChangeListener(BufferChangeListener listener,\\n\\t\\tint priority)\\n\\t{\\n\\t\\tListener l = new Listener(listener,priority);\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\tListener _l = (Listener)bufferListeners.get(i);\\n\\t\\t\\tif(_l.priority < priority)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbufferListeners.insertElementAt(l,i);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbufferListeners.addElement(l);\\n\\t} \\n\\tpublic void addBufferChangeListener(BufferChangeListener listener)\\n\\t{\\n\\t\\taddBufferChangeListener(listener,NORMAL_PRIORITY);\\n\\t} \\n\\tpublic void removeBufferChangeListener(BufferChangeListener listener)\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\tif(((Listener)bufferListeners.get(i)).listener == listener)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbufferListeners.removeElementAt(i);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic BufferChangeListener[] getBufferChangeListeners()\\n\\t{\\n\\t\\tBufferChangeListener[] returnValue\\n\\t\\t\\t= new BufferChangeListener[\\n\\t\\t\\tbufferListeners.size()];\\n\\t\\tfor(int i = 0; i < returnValue.length; i++)\\n\\t\\t{\\n\\t\\t\\treturnValue[i] = ((Listener)bufferListeners.get(i))\\n\\t\\t\\t\\t.listener;\\n\\t\\t}\\n\\t\\treturn returnValue;\\n\\t} \\n\\tpublic void propertiesChanged()\\n\\t{\\n\\t\\tString folding = getStringProperty(\\\"folding\\\");\\n\\t\\tFoldHandler handler = FoldHandler.getFoldHandler(folding);\\n\\t\\tif(handler != null)\\n\\t\\t{\\n\\t\\t\\tsetFoldHandler(handler);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif (folding != null)\\n\\t\\t\\t\\tLog.log(Log.WARNING, this, path + \\\": invalid 'folding' property: \\\" + folding); \\n\\t\\t\\tsetFoldHandler(new DummyFoldHandler());\\n\\t\\t}\\n\\t\\tEditBus.send(new BufferUpdate(this,null,BufferUpdate.PROPERTIES_CHANGED));\\n\\t\\tString newWrap = getStringProperty(\\\"wrap\\\");\\n\\t\\tif(wrap != null && !newWrap.equals(wrap))\\n\\t\\t{\\n\\t\\t\\toffsetMgr.invalidateScreenLineCounts();\\n\\t\\t\\tif(isLoaded())\\n\\t\\t\\t\\tfireWrapModeChanged();\\n\\t\\t}\\n\\t\\tthis.wrap = newWrap;\\n\\t} \\n\\tpublic int getTabSize()\\n\\t{\\n\\t\\treturn getIntegerProperty(\\\"tabSize\\\",8);\\n\\t} \\n\\tpublic final int getIndentSize()\\n\\t{\\n\\t\\treturn getIntegerProperty(\\\"indentSize\\\",8);\\n\\t} \\n\\tpublic Object getProperty(Object name)\\n\\t{\\n\\t\\tsynchronized(propertyLock)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tPropValue o = (PropValue)properties.get(name);\\n\\t\\t\\tif(o != null)\\n\\t\\t\\t\\treturn o.value;\\n\\t\\t\\t\\t\\t\\tif(!(name instanceof String))\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t\\t\\t\\tif(mode != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tObject retVal = mode.getProperty((String)name);\\n\\t\\t\\t\\tif(retVal == null)\\n\\t\\t\\t\\t\\treturn null;\\n\\t\\t\\t\\tproperties.put(name,new PropValue(retVal,true));\\n\\t\\t\\t\\treturn retVal;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tString value = jEdit.getProperty(\\\"buffer.\\\" + name);\\n\\t\\t\\t\\tif(value == null)\\n\\t\\t\\t\\t\\treturn null;\\n\\t\\t\\t\\t\\t\\t\\t\\tObject retVal;\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tretVal = new Integer(value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(NumberFormatException nf)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tretVal = value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tproperties.put(name,new PropValue(retVal,true));\\n\\t\\t\\t\\treturn retVal;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic void setProperty(String name, Object value)\\n\\t{\\n\\t\\tif(value == null)\\n\\t\\t\\tproperties.remove(name);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tPropValue test = (PropValue)properties.get(name);\\n\\t\\t\\tif(test == null)\\n\\t\\t\\t\\tproperties.put(name,new PropValue(value,false));\\n\\t\\t\\telse if(test.value.equals(value))\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\ttest.value = value;\\n\\t\\t\\t\\ttest.defaultValue = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic void unsetProperty(String name)\\n\\t{\\n\\t\\tproperties.remove(name);\\n\\t} \\n\\tpublic String getStringProperty(String name)\\n\\t{\\n\\t\\tObject obj = getProperty(name);\\n\\t\\tif(obj != null)\\n\\t\\t\\treturn obj.toString();\\n\\t\\telse\\n\\t\\t\\treturn null;\\n\\t} \\n\\tpublic void setStringProperty(String name, String value)\\n\\t{\\n\\t\\tsetProperty(name,value);\\n\\t} \\n\\tpublic boolean getBooleanProperty(String name)\\n\\t{\\n\\t\\tObject obj = getProperty(name);\\n\\t\\tif(obj instanceof Boolean)\\n\\t\\t\\treturn ((Boolean)obj).booleanValue();\\n\\t\\telse if(\\\"true\\\".equals(obj) || \\\"on\\\".equals(obj) || \\\"yes\\\".equals(obj))\\n\\t\\t\\treturn true;\\n\\t\\telse\\n\\t\\t\\treturn false;\\n\\t} \\n\\tpublic void setBooleanProperty(String name, boolean value)\\n\\t{\\n\\t\\tsetProperty(name,value ? Boolean.TRUE : Boolean.FALSE);\\n\\t} \\n\\tpublic int getIntegerProperty(String name, int defaultValue)\\n\\t{\\n\\t\\tboolean defaultValueFlag;\\n\\t\\tObject obj;\\n\\t\\tPropValue value = (PropValue)properties.get(name);\\n\\t\\tif(value != null)\\n\\t\\t{\\n\\t\\t\\tobj = value.value;\\n\\t\\t\\tdefaultValueFlag = value.defaultValue;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tobj = getProperty(name);\\n\\t\\t\\t\\t\\t\\tdefaultValueFlag = true;\\n\\t\\t}\\n\\t\\tif(obj == null)\\n\\t\\t\\treturn defaultValue;\\n\\t\\telse if(obj instanceof Number)\\n\\t\\t\\treturn ((Number)obj).intValue();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tint returnValue = Integer.parseInt(\\n\\t\\t\\t\\t\\tobj.toString().trim());\\n\\t\\t\\t\\tproperties.put(name,new PropValue(\\n\\t\\t\\t\\t\\tnew Integer(returnValue),\\n\\t\\t\\t\\t\\tdefaultValueFlag));\\n\\t\\t\\t\\treturn returnValue;\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Exception e)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn defaultValue;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic void setIntegerProperty(String name, int value)\\n\\t{\\n\\t\\tsetProperty(name,new Integer(value));\\n\\t} \\n\\tpublic RE getRegexpProperty(String name, int cflags,\\n\\t\\tRESyntax syntax) throws REException\\n\\t{\\n\\t\\tsynchronized(propertyLock)\\n\\t\\t{\\n\\t\\t\\tboolean defaultValueFlag;\\n\\t\\t\\tObject obj;\\n\\t\\t\\tPropValue value = (PropValue)properties.get(name);\\n\\t\\t\\tif(value != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tobj = value.value;\\n\\t\\t\\t\\tdefaultValueFlag = value.defaultValue;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tobj = getProperty(name);\\n\\t\\t\\t\\t\\t\\t\\t\\tdefaultValueFlag = true;\\n\\t\\t\\t}\\n\\t\\t\\tif(obj == null)\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\telse if(obj instanceof RE)\\n\\t\\t\\t\\treturn (RE)obj;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tRE re = new RE(obj.toString(),cflags,syntax);\\n\\t\\t\\t\\tproperties.put(name,new PropValue(re,\\n\\t\\t\\t\\t\\tdefaultValueFlag));\\n\\t\\t\\t\\treturn re;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic ParserRuleSet getRuleSetAtOffset(int offset)\\n\\t{\\n\\t\\tint line = getLineOfOffset(offset);\\n\\t\\toffset -= getLineStartOffset(line);\\n\\t\\tif(offset != 0)\\n\\t\\t\\toffset--;\\n\\t\\tDefaultTokenHandler tokens = new DefaultTokenHandler();\\n\\t\\tmarkTokens(line,tokens);\\n\\t\\tToken token = TextUtilities.getTokenAtOffset(tokens.getTokens(),offset);\\n\\t\\treturn token.rules;\\n\\t} \\n\\tpublic KeywordMap getKeywordMapAtOffset(int offset)\\n\\t{\\n\\t\\treturn getRuleSetAtOffset(offset).getKeywords();\\n\\t} \\n\\tpublic String getContextSensitiveProperty(int offset, String name)\\n\\t{\\n\\t\\tParserRuleSet rules = getRuleSetAtOffset(offset);\\n\\t\\tObject value = null;\\n\\t\\tHashtable rulesetProps = rules.getProperties();\\n\\t\\tif(rulesetProps != null)\\n\\t\\t\\tvalue = rulesetProps.get(name);\\n\\t\\tif(value == null)\\n\\t\\t{\\n\\t\\t\\tvalue = jEdit.getMode(rules.getModeName())\\n\\t\\t\\t\\t.getProperty(name);\\n\\t\\t\\tif(value == null)\\n\\t\\t\\t\\tvalue = mode.getProperty(name);\\n\\t\\t}\\n\\t\\tif(value == null)\\n\\t\\t\\treturn null;\\n\\t\\telse\\n\\t\\t\\treturn String.valueOf(value);\\n\\t} \\n\\t\\tstatic class PropValue\\n\\t{\\n\\t\\tPropValue(Object value, boolean defaultValue)\\n\\t\\t{\\n\\t\\t\\tif(value == null)\\n\\t\\t\\t\\tthrow new NullPointerException();\\n\\t\\t\\tthis.value = value;\\n\\t\\t\\tthis.defaultValue = defaultValue;\\n\\t\\t}\\n\\t\\tObject value;\\n\\t\\tboolean defaultValue;\\n\\t\\tpublic String toString()\\n\\t\\t{\\n\\t\\t\\treturn value.toString();\\n\\t\\t}\\n\\t} \\n\\tpublic void toggleWordWrap(View view)\\n\\t{\\n\\t\\tString wrap = getStringProperty(\\\"wrap\\\");\\n\\t\\tif(wrap.equals(\\\"none\\\"))\\n\\t\\t\\twrap = \\\"soft\\\";\\n\\t\\telse if(wrap.equals(\\\"soft\\\"))\\n\\t\\t\\twrap = \\\"hard\\\";\\n\\t\\telse if(wrap.equals(\\\"hard\\\"))\\n\\t\\t\\twrap = \\\"none\\\";\\n\\t\\tview.getStatus().setMessageAndClear(jEdit.getProperty(\\n\\t\\t\\t\\\"view.status.wrap-changed\\\",new String[] {\\n\\t\\t\\twrap }));\\n\\t\\tsetProperty(\\\"wrap\\\",wrap);\\n\\t\\tpropertiesChanged();\\n\\t} \\n\\tpublic void toggleLineSeparator(View view)\\n\\t{\\n\\t\\tString status = null;\\n\\t\\tString lineSep = getStringProperty(\\\"lineSeparator\\\");\\n\\t\\tif(\\\"\\\\n\\\".equals(lineSep))\\n\\t\\t{\\n\\t\\t\\tstatus = \\\"windows\\\";\\n\\t\\t\\tlineSep = \\\"\\\\r\\\\n\\\";\\n\\t\\t}\\n\\t\\telse if(\\\"\\\\r\\\\n\\\".equals(lineSep))\\n\\t\\t{\\n\\t\\t\\tstatus = \\\"mac\\\";\\n\\t\\t\\tlineSep = \\\"\\\\r\\\";\\n\\t\\t}\\n\\t\\telse if(\\\"\\\\r\\\".equals(lineSep))\\n\\t\\t{\\n\\t\\t\\tstatus = \\\"unix\\\";\\n\\t\\t\\tlineSep = \\\"\\\\n\\\";\\n\\t\\t}\\n\\t\\tview.getStatus().setMessageAndClear(jEdit.getProperty(\\n\\t\\t\\t\\\"view.status.linesep-changed\\\",new String[] {\\n\\t\\t\\tjEdit.getProperty(\\\"lineSep.\\\" + status) }));\\n\\t\\tsetProperty(\\\"lineSeparator\\\",lineSep);\\n\\t\\tsetDirty(true);\\n\\t\\tpropertiesChanged();\\n\\t} \\n\\tpublic final Mode getMode()\\n\\t{\\n\\t\\treturn mode;\\n\\t} \\n\\tpublic void setMode(String mode)\\n\\t{\\n\\t\\tsetMode(jEdit.getMode(mode));\\n\\t} \\n\\tpublic void setMode(Mode mode)\\n\\t{\\n\\t\\tif(mode == null)\\n\\t\\t\\tthrow new NullPointerException(\\\"Mode must be non-null\\\");\\n\\t\\tthis.mode = mode;\\n\\t\\ttextMode = \\\"text\\\".equals(mode.getName());\\n\\t\\tsetTokenMarker(mode.getTokenMarker());\\n\\t\\tresetCachedProperties();\\n\\t\\tpropertiesChanged();\\n\\t} \\n\\tpublic void setMode()\\n\\t{\\n\\t\\tString userMode = getStringProperty(\\\"mode\\\");\\n\\t\\tif(userMode != null)\\n\\t\\t{\\n\\t\\t\\tMode m = jEdit.getMode(userMode);\\n\\t\\t\\tif(m != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetMode(m);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tString nogzName = name.substring(0,name.length() -\\n\\t\\t\\t(name.endsWith(\\\".gz\\\") ? 3 : 0));\\n\\t\\tMode[] modes = jEdit.getModes();\\n\\t\\tString firstLine = getLineText(0);\\n\\t\\tfor(int i = 0; i < modes.length; i++)\\n\\t\\t{\\n\\t\\t\\tif(modes[i].accept(nogzName,firstLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetMode(modes[i]);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tMode defaultMode = jEdit.getMode(jEdit.getProperty(\\\"buffer.defaultMode\\\"));\\n\\t\\tif(defaultMode == null)\\n\\t\\t\\tdefaultMode = jEdit.getMode(\\\"text\\\");\\n\\t\\tsetMode(defaultMode);\\n\\t} \\n\\tpublic void markTokens(int lineIndex, TokenHandler tokenHandler)\\n\\t{\\n\\t\\tSegment seg;\\n\\t\\tif(SwingUtilities.isEventDispatchThread())\\n\\t\\t\\tseg = this.seg;\\n\\t\\telse\\n\\t\\t\\tseg = new Segment();\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tif(lineIndex < 0 || lineIndex >= offsetMgr.getLineCount())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(lineIndex);\\n\\t\\t\\tint firstInvalidLineContext = offsetMgr.getFirstInvalidLineContext();\\n\\t\\t\\tint start;\\n\\t\\t\\tif(textMode || firstInvalidLineContext == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart = lineIndex;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart = Math.min(firstInvalidLineContext,\\n\\t\\t\\t\\t\\tlineIndex);\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.TOKEN_MARKER_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"tokenize from \\\" + start + \\\" to \\\" + lineIndex);\\n\\t\\t\\tfor(int i = start; i <= lineIndex; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetLineText(i,seg);\\n\\t\\t\\t\\tTokenMarker.LineContext context = offsetMgr.getLineContext(i);\\n\\t\\t\\t\\tParserRule oldRule;\\n\\t\\t\\t\\tParserRuleSet oldRules;\\n\\t\\t\\t\\tString oldSpanEndSubst;\\n\\t\\t\\t\\tif(context == null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\toldRule = null;\\n\\t\\t\\t\\t\\toldRules = null;\\n\\t\\t\\t\\t\\toldSpanEndSubst = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\toldRule = context.inRule;\\n\\t\\t\\t\\t\\toldRules = context.rules;\\n\\t\\t\\t\\t\\toldSpanEndSubst = (context.parent != null\\n\\t\\t\\t\\t\\t\\t? context.parent.spanEndSubst\\n\\t\\t\\t\\t\\t\\t: null);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tTokenMarker.LineContext prevContext = (\\n\\t\\t\\t\\t\\t(i == 0 || textMode) ? null\\n\\t\\t\\t\\t\\t: offsetMgr.getLineContext(i - 1)\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\tcontext = tokenMarker.markTokens(prevContext,\\n\\t\\t\\t\\t\\t(i == lineIndex ? tokenHandler\\n\\t\\t\\t\\t\\t: DummyTokenHandler.INSTANCE),seg);\\n\\t\\t\\t\\toffsetMgr.setLineContext(i,context);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(oldRule != context.inRule)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnextLineRequested = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(oldRules != context.rules)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnextLineRequested = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(!MiscUtilities.objectsEqual(oldSpanEndSubst,\\n\\t\\t\\t\\t\\tcontext.spanEndSubst))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnextLineRequested = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint lineCount = offsetMgr.getLineCount();\\n\\t\\t\\tif(lineCount - 1 == lineIndex)\\n\\t\\t\\t\\toffsetMgr.setFirstInvalidLineContext(-1);\\n\\t\\t\\telse if(nextLineRequested)\\n\\t\\t\\t\\toffsetMgr.setFirstInvalidLineContext(lineIndex + 1);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\toffsetMgr.setFirstInvalidLineContext(Math.max(\\n\\t\\t\\t\\t\\tfirstInvalidLineContext,lineIndex + 1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic boolean isNextLineRequested()\\n\\t{\\n\\t\\tboolean retVal = nextLineRequested;\\n\\t\\tnextLineRequested = false;\\n\\t\\treturn retVal;\\n\\t} \\n\\tpublic void removeTrailingWhiteSpace(int[] lines)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbeginCompoundEdit();\\n\\t\\t\\tfor(int i = 0; i < lines.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint pos, lineStart, lineEnd, tail;\\n\\t\\t\\t\\tgetLineText(lines[i],seg);\\n\\t\\t\\t\\t\\t\\t\\t\\tif (seg.count == 0) continue;\\n\\t\\t\\t\\tlineStart = seg.offset;\\n\\t\\t\\t\\tlineEnd = seg.offset + seg.count - 1;\\n\\t\\t\\t\\tfor (pos = lineEnd; pos >= lineStart; pos--)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (!Character.isWhitespace(seg.array[pos]))\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttail = lineEnd - pos;\\n\\t\\t\\t\\t\\t\\t\\t\\tif (tail == 0) continue;\\n\\t\\t\\t\\tremove(getLineEndOffset(lines[i]) - 1 - tail,tail);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tendCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void shiftIndentLeft(int[] lines)\\n\\t{\\n\\t\\tint tabSize = getTabSize();\\n\\t\\tint indentSize = getIndentSize();\\n\\t\\tboolean noTabs = getBooleanProperty(\\\"noTabs\\\");\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbeginCompoundEdit();\\n\\t\\t\\tfor(int i = 0; i < lines.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint lineStart = getLineStartOffset(lines[i]);\\n\\t\\t\\t\\tString line = getLineText(lines[i]);\\n\\t\\t\\t\\tint whiteSpace = MiscUtilities\\n\\t\\t\\t\\t\\t.getLeadingWhiteSpace(line);\\n\\t\\t\\t\\tif(whiteSpace == 0)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tint whiteSpaceWidth = Math.max(0,MiscUtilities\\n\\t\\t\\t\\t\\t.getLeadingWhiteSpaceWidth(line,tabSize)\\n\\t\\t\\t\\t\\t- indentSize);\\n\\t\\t\\t\\tinsert(lineStart + whiteSpace,MiscUtilities\\n\\t\\t\\t\\t\\t.createWhiteSpace(whiteSpaceWidth,\\n\\t\\t\\t\\t\\t(noTabs ? 0 : tabSize)));\\n\\t\\t\\t\\tremove(lineStart,whiteSpace);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tendCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void shiftIndentRight(int[] lines)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbeginCompoundEdit();\\n\\t\\t\\tint tabSize = getTabSize();\\n\\t\\t\\tint indentSize = getIndentSize();\\n\\t\\t\\tboolean noTabs = getBooleanProperty(\\\"noTabs\\\");\\n\\t\\t\\tfor(int i = 0; i < lines.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint lineStart = getLineStartOffset(lines[i]);\\n\\t\\t\\t\\tString line = getLineText(lines[i]);\\n\\t\\t\\t\\tint whiteSpace = MiscUtilities\\n\\t\\t\\t\\t\\t.getLeadingWhiteSpace(line);\\n\\t\\t\\t\\tint whiteSpaceWidth = MiscUtilities\\n\\t\\t\\t\\t\\t.getLeadingWhiteSpaceWidth(\\n\\t\\t\\t\\t\\tline,tabSize) + indentSize;\\n\\t\\t\\t\\tinsert(lineStart + whiteSpace,MiscUtilities\\n\\t\\t\\t\\t\\t.createWhiteSpace(whiteSpaceWidth,\\n\\t\\t\\t\\t\\t(noTabs ? 0 : tabSize)));\\n\\t\\t\\t\\tremove(lineStart,whiteSpace);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tendCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic boolean indentLine(int lineIndex, boolean canIncreaseIndent,\\n\\t\\tboolean canDecreaseIndent)\\n\\t{\\n\\t\\treturn indentLine(lineIndex);\\n\\t} \\n\\tpublic boolean indentLine(int lineIndex, boolean canIncreaseIndent,\\n\\t\\tboolean canDecreaseIndent)\\n\\t{\\n\\t\\tgetLineText(lineIndex,seg);\\n\\t\\tint tabSize = getTabSize();\\n\\t\\tint whitespaceChars = 0;\\n\\t\\tint currentIndent = 0;\\nloop:\\t\\tfor(int i = 0; i < seg.count; i++)\\n\\t\\t{\\n\\t\\t\\tchar c = seg.array[seg.offset + i];\\n\\t\\t\\tswitch(c)\\n\\t\\t\\t{\\n\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcurrentIndent++;\\n\\t\\t\\t\\twhitespaceChars++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\tcurrentIndent += (tabSize - (currentIndent\\n\\t\\t\\t\\t\\t% tabSize));\\n\\t\\t\\t\\twhitespaceChars++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint idealIndent = getIndentForLine(lineIndex);\\n\\t\\tif(idealIndent == -1 || idealIndent == currentIndent)\\n\\t\\t\\treturn false;\\n\\t\\t\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbeginCompoundEdit();\\n\\t\\t\\tint start = getLineStartOffset(lineIndex);\\n\\t\\t\\tremove(start,whitespaceChars);\\n\\t\\t\\tinsert(start,MiscUtilities.createWhiteSpace(\\n\\t\\t\\t\\tidealIndent,(getBooleanProperty(\\\"noTabs\\\")\\n\\t\\t\\t\\t? 0 : tabSize)));\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tendCompoundEdit();\\n\\t\\t}\\n\\t\\treturn true;\\n\\t} \\n\\tpublic void indentLines(int start, int end)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbeginCompoundEdit();\\n\\t\\t\\tfor(int i = start; i <= end; i++)\\n\\t\\t\\t\\tindentLine(i);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tendCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void indentLines(int[] lines)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbeginCompoundEdit();\\n\\t\\t\\tfor(int i = 0; i < lines.length; i++)\\n\\t\\t\\t\\tindentLine(lines[i]);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tendCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic int getIndentForLine(int lineIndex)\\n\\t{\\n\\t\\tfinal String EXPLICIT_START = \\\"{{{\\\";\\n\\t\\tfinal String EXPLICIT_END = \\\"}}}\\\";\\n\\t\\tif(lineIndex == 0)\\n\\t\\t\\treturn -1;\\n\\t\\t\\t\\tString openBrackets = getStringProperty(\\\"indentOpenBrackets\\\");\\n\\t\\tif(openBrackets == null)\\n\\t\\t\\topenBrackets = \\\"\\\";\\n\\t\\tString closeBrackets = getStringProperty(\\\"indentCloseBrackets\\\");\\n\\t\\tif(closeBrackets == null)\\n\\t\\t\\tcloseBrackets = \\\"\\\";\\n\\t\\tRE indentNextLineRE;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tindentNextLineRE = getRegexpProperty(\\\"indentNextLine\\\",\\n\\t\\t\\t\\tRE.REG_ICASE,RESearchMatcher.RE_SYNTAX_JEDIT);\\n\\t\\t}\\n\\t\\tcatch(REException re)\\n\\t\\t{\\n\\t\\t\\tindentNextLineRE = null;\\n\\t\\t\\tLog.log(Log.ERROR,this,\\\"Invalid indentNextLine regexp\\\");\\n\\t\\t\\tLog.log(Log.ERROR,this,re);\\n\\t\\t}\\n\\t\\tRE indentNextLinesRE;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tindentNextLinesRE = getRegexpProperty(\\\"indentNextLines\\\",\\n\\t\\t\\t\\tRE.REG_ICASE,RESearchMatcher.RE_SYNTAX_JEDIT);\\n\\t\\t}\\n\\t\\tcatch(REException re)\\n\\t\\t{\\n\\t\\t\\tindentNextLinesRE = null;\\n\\t\\t\\tLog.log(Log.ERROR,this,\\\"Invalid indentNextLines regexp\\\");\\n\\t\\t\\tLog.log(Log.ERROR,this,re);\\n\\t\\t}\\n\\t\\tboolean doubleBracketIndent = getBooleanProperty(\\\"doubleBracketIndent\\\");\\n\\t\\tboolean lineUpClosingBracket = getBooleanProperty(\\\"lineUpClosingBracket\\\");\\n\\t\\tint tabSize = getTabSize();\\n\\t\\tint indentSize = getIndentSize();\\n\\t\\t\\t\\tint prevLineIndex = getPriorNonEmptyLine(lineIndex);\\n\\t\\tif(prevLineIndex == -1)\\n\\t\\t\\treturn -1;\\n\\t\\tString prevLine = getLineText(prevLineIndex);\\n\\t\\tboolean prevLineStart = true; \\t\\tint indent = 0; \\t\\tint prevLineBrackets = 0; \\t\\tint prevLineCloseBracketIndex = -1; \\t\\t                                    \\t\\t                                    \\t\\t                                    \\t\\t                                    \\t\\t                                    \\t\\t                                    \\t\\t                                    \\n\\t\\tfor(int i = 0; i < prevLine.length(); i++)\\n\\t\\t{\\n\\t\\t\\tchar c = prevLine.charAt(i);\\n\\t\\t\\tswitch(c)\\n\\t\\t\\t{\\n\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tif(prevLineStart)\\n\\t\\t\\t\\t\\tindent++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\tif(prevLineStart)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tindent += (tabSize\\n\\t\\t\\t\\t\\t\\t- (indent\\n\\t\\t\\t\\t\\t\\t% tabSize));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tprevLineStart = false;\\n\\t\\t\\t\\tif(closeBrackets.indexOf(c) != -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(prevLine.regionMatches(false,\\n\\t\\t\\t\\t\\t\\ti,EXPLICIT_END,0,3))\\n\\t\\t\\t\\t\\t\\ti += 2;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tprevLineBrackets--;\\n\\t\\t\\t\\t\\t\\tif(prevLineBrackets < 0)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(lineUpClosingBracket)\\n\\t\\t\\t\\t\\t\\t\\t\\tprevLineBrackets = 0;\\n\\t\\t\\t\\t\\t\\t\\tprevLineCloseBracketIndex = i;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(openBrackets.indexOf(c) != -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(prevLine.regionMatches(false,\\n\\t\\t\\t\\t\\t\\ti,EXPLICIT_START,0,3))\\n\\t\\t\\t\\t\\t\\ti += 2;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tprevLineBrackets++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tString line = getLineText(lineIndex);\\n\\t\\tint lineBrackets = 0; \\t\\tint closeBracketIndex = -1; \\t\\t\\t\\t\\tfor(int i = 0; i < line.length(); i++)\\n\\t\\t{\\n\\t\\t\\tchar c = line.charAt(i);\\n\\t\\t\\tif(closeBrackets.indexOf(c) != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(line.regionMatches(false,\\n\\t\\t\\t\\t\\ti,EXPLICIT_END,0,3))\\n\\t\\t\\t\\t\\ti += 2;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcloseBracketIndex = i;\\n\\t\\t\\t\\t\\tlineBrackets--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(openBrackets.indexOf(c) != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(line.regionMatches(false,\\n\\t\\t\\t\\t\\ti,EXPLICIT_START,0,3))\\n\\t\\t\\t\\t\\ti += 2;\\n\\t\\t\\t\\telse if(lineBrackets >= 0)\\n\\t\\t\\t\\t\\tlineBrackets++;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tif(prevLineBrackets > 0)\\n\\t\\t\\tindent += (indentSize * prevLineBrackets);\\n\\t\\tif(lineUpClosingBracket)\\n\\t\\t{\\n\\t\\t\\tif(lineBrackets < 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint offset = TextUtilities.findMatchingBracket(\\n\\t\\t\\t\\t\\tthis,lineIndex,closeBracketIndex);\\n\\t\\t\\t\\tif(offset != -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tString closeLine = getLineText(getLineOfOffset(offset));\\n\\t\\t\\t\\t\\tindent = MiscUtilities.getLeadingWhiteSpaceWidth(\\n\\t\\t\\t\\t\\t\\tcloseLine,tabSize);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(prevLineBrackets < 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint offset = TextUtilities.findMatchingBracket(\\n\\t\\t\\t\\t\\tthis,prevLineIndex,prevLineCloseBracketIndex);\\n\\t\\t\\t\\tif(offset != -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tString closeLine = getLineText(getLineOfOffset(offset));\\n\\t\\t\\t\\t\\tindent = MiscUtilities.getLeadingWhiteSpaceWidth(\\n\\t\\t\\t\\t\\t\\tcloseLine,tabSize);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tif(lineBrackets == 0 || (doubleBracketIndent && lineBrackets > 0))\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(indentNextLinesRE != null && indentNextLinesRE.isMatch(prevLine))\\n\\t\\t\\t\\tindent += indentSize;\\n\\t\\t\\telse if(indentNextLineRE != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(indentNextLineRE.isMatch(prevLine))\\n\\t\\t\\t\\t\\tindent += indentSize;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\telse if(prevLineBrackets == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tint prevPrevLineIndex;\\n\\t\\t\\t\\t\\t\\tprevPrevLineIndex = getPriorNonEmptyLine(prevLineIndex);\\n\\t\\t\\t\\t\\twhile(prevPrevLineIndex != -1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(indentNextLineRE.isMatch(getLineText(prevPrevLineIndex)))\\n\\t\\t\\t\\t\\t\\t\\tindent -= indentSize;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tprevPrevLineIndex = getPriorNonEmptyLine(prevPrevLineIndex);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\treturn indent;\\n\\t} \\n\\tpublic int getVirtualWidth(int line, int column)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tint start = getLineStartOffset(line);\\n\\t\\t\\tgetText(start,column,seg);\\n\\t\\t\\treturn MiscUtilities.getVirtualWidth(seg,getTabSize());\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic int getOffsetOfVirtualColumn(int line, int column,\\n\\t\\tint[] totalVirtualWidth)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tgetLineText(line,seg);\\n\\t\\t\\treturn MiscUtilities.getOffsetOfVirtualColumn(seg,\\n\\t\\t\\t\\tgetTabSize(),column,totalVirtualWidth);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void insertAtColumn(int line, int col, String str)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tint[] total = new int[1];\\n\\t\\t\\tint offset = getOffsetOfVirtualColumn(line,col,total);\\n\\t\\t\\tif(offset == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\toffset = getLineEndOffset(line) - 1;\\n\\t\\t\\t\\tstr = MiscUtilities.createWhiteSpace(col - total[0],0) + str;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\toffset += getLineStartOffset(line);\\n\\t\\t\\tinsert(offset,str);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void putProperty(Object name, Object value)\\n\\t{\\n\\t\\t\\t\\tif(!(name instanceof String))\\n\\t\\t\\treturn;\\n\\t\\tsetProperty((String)name,value);\\n\\t} \\n\\tpublic void putBooleanProperty(String name, boolean value)\\n\\t{\\n\\t\\tsetBooleanProperty(name,value);\\n\\t} \\n\\tpublic static class TokenList extends DefaultTokenHandler\\n\\t{\\n\\t\\tpublic Token getFirstToken()\\n\\t\\t{\\n\\t\\t\\treturn getTokens();\\n\\t\\t}\\n\\t}\\n\\tpublic TokenList markTokens(int lineIndex)\\n\\t{\\n\\t\\tTokenList list = new TokenList();\\n\\t\\tmarkTokens(lineIndex,list);\\n\\t\\treturn list;\\n\\t} \\n\\tpublic Element[] getRootElements()\\n\\t{\\n\\t\\treturn new Element[] { getDefaultRootElement() };\\n\\t} \\n\\tpublic Element getParagraphElement(int offset)\\n\\t{\\n\\t\\treturn new LineElement(this,getLineOfOffset(offset));\\n\\t} \\n\\tpublic Element getDefaultRootElement()\\n\\t{\\n\\t\\treturn new RootElement(this);\\n\\t} \\n\\tpublic void insertString(int offset, String str, AttributeSet attr)\\n\\t{\\n\\t\\tinsert(offset,str);\\n\\t} \\n\\tpublic final File getFile()\\n\\t{\\n\\t\\treturn file;\\n\\t} \\n\\tpublic boolean isFoldStart(int line)\\n\\t{\\n\\t\\treturn (line != getLineCount() - 1\\n\\t\\t\\t&& getFoldLevel(line) < getFoldLevel(line + 1));\\n\\t} \\n\\tpublic void invalidateCachedFoldLevels()\\n\\t{\\n\\t\\toffsetMgr.setFirstInvalidFoldLevel(0);\\n\\t\\tfireFoldLevelChanged(0,getLineCount());\\n\\t} \\n\\tpublic int getFoldLevel(int line)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tif(line < 0 || line >= offsetMgr.getLineCount())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(line);\\n\\t\\t\\tif(foldHandler instanceof DummyFoldHandler)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\tint firstInvalidFoldLevel = offsetMgr.getFirstInvalidFoldLevel();\\n\\t\\t\\tif(firstInvalidFoldLevel == -1 || line < firstInvalidFoldLevel)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn offsetMgr.getFoldLevel(line);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(Debug.FOLD_DEBUG)\\n\\t\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"Invalid fold levels from \\\" + firstInvalidFoldLevel + \\\" to \\\" + line);\\n\\t\\t\\t\\tint newFoldLevel = 0;\\n\\t\\t\\t\\tboolean changed = false;\\n\\t\\t\\t\\tfor(int i = firstInvalidFoldLevel; i <= line; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnewFoldLevel = foldHandler.getFoldLevel(this,i,seg);\\n\\t\\t\\t\\t\\tif(newFoldLevel != offsetMgr.getFoldLevel(i))\\n\\t\\t\\t\\t\\t\\tchanged = true;\\n\\t\\t\\t\\t\\toffsetMgr.setFoldLevel(i,newFoldLevel);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(line == offsetMgr.getLineCount() - 1)\\n\\t\\t\\t\\t\\toffsetMgr.setFirstInvalidFoldLevel(-1);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\toffsetMgr.setFirstInvalidFoldLevel(line + 1);\\n\\t\\t\\t\\tif(changed && !getFlag(INSIDE_INSERT))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfireFoldLevelChanged(firstInvalidFoldLevel,line);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn newFoldLevel;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic int[] getFoldAtLine(int line)\\n\\t{\\n\\t\\tint start, end;\\n\\t\\tif(isFoldStart(line))\\n\\t\\t{\\n\\t\\t\\tstart = line;\\n\\t\\t\\tint foldLevel = getFoldLevel(line);\\n\\t\\t\\tline++;\\n\\t\\t\\twhile(getFoldLevel(line) > foldLevel)\\n\\t\\t\\t{\\n\\t\\t\\t\\tline++;\\n\\t\\t\\t\\tif(line == getLineCount())\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tend = line - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstart = line;\\n\\t\\t\\tint foldLevel = getFoldLevel(line);\\n\\t\\t\\twhile(getFoldLevel(start) >= foldLevel)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(start == 0)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tstart--;\\n\\t\\t\\t}\\n\\t\\t\\tend = line;\\n\\t\\t\\twhile(getFoldLevel(end) >= foldLevel)\\n\\t\\t\\t{\\n\\t\\t\\t\\tend++;\\n\\t\\t\\t\\tif(end == getLineCount())\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tend--;\\n\\t\\t}\\n\\t\\twhile(getLineLength(end) == 0 && end > start)\\n\\t\\t\\tend--;\\n\\t\\treturn new int[] { start, end };\\n\\t} \\n\\tpublic FoldHandler getFoldHandler()\\n\\t{\\n\\t\\treturn foldHandler;\\n\\t} \\n\\tpublic void setFoldHandler(FoldHandler foldHandler)\\n\\t{\\n\\t\\tFoldHandler oldFoldHandler = this.foldHandler;\\n\\t\\tif(foldHandler.equals(oldFoldHandler))\\n\\t\\t\\treturn;\\n\\t\\tthis.foldHandler = foldHandler;\\n\\t\\toffsetMgr.setFirstInvalidFoldLevel(0);\\n\\t\\tfireFoldHandlerChanged();\\n\\t} \\n\\tpublic Position createPosition(int offset)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tif(offset < 0 || offset > contentMgr.getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(offset);\\n\\t\\t\\treturn offsetMgr.createPosition(offset);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic final Vector getMarkers()\\n\\t{\\n\\t\\treturn markers;\\n\\t} \\n\\tpublic void addOrRemoveMarker(char shortcut, int pos)\\n\\t{\\n\\t\\tint line = getLineOfOffset(pos);\\n\\t\\tif(getMarkerAtLine(line) != null)\\n\\t\\t\\tremoveMarker(line);\\n\\t\\telse\\n\\t\\t\\taddMarker(shortcut,pos);\\n\\t} \\n\\tpublic void addMarker(char shortcut, int pos)\\n\\t{\\n\\t\\tif(!getFlag(READ_ONLY) && jEdit.getBooleanProperty(\\\"persistentMarkers\\\"))\\n\\t\\t\\tsetDirty(true);\\n\\t\\tMarker markerN = new Marker(this,shortcut,pos);\\n\\t\\tboolean added = false;\\n\\t\\t\\t\\tif(!getFlag(LOADING))\\n\\t\\t{\\n\\t\\t\\tmarkerN.createPosition();\\n\\t\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\t\\tif(shortcut != '\\\\0' && marker.getShortcut() == shortcut)\\n\\t\\t\\t\\t\\tmarker.setShortcut('\\\\0');\\n\\t\\t\\t\\tif(marker.getPosition() == pos)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmarkers.removeElementAt(i);\\n\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\t\\tif(marker.getPosition() > pos)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmarkers.insertElementAt(markerN,i);\\n\\t\\t\\t\\t\\tadded = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(!added)\\n\\t\\t\\tmarkers.addElement(markerN);\\n\\t\\tif(!getFlag(LOADING) && !getFlag(TEMPORARY))\\n\\t\\t{\\n\\t\\t\\tEditBus.send(new BufferUpdate(this,null,\\n\\t\\t\\t\\tBufferUpdate.MARKERS_CHANGED));\\n\\t\\t}\\n\\t} \\n\\tpublic Marker getMarkerInRange(int start, int end)\\n\\t{\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tint pos = marker.getPosition();\\n\\t\\t\\tif(pos >= start && pos < end)\\n\\t\\t\\t\\treturn marker;\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic Marker getMarkerAtLine(int line)\\n\\t{\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tif(getLineOfOffset(marker.getPosition()) == line)\\n\\t\\t\\t\\treturn marker;\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic void removeMarker(int line)\\n\\t{\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tif(getLineOfOffset(marker.getPosition()) == line)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(!getFlag(READ_ONLY) && jEdit.getBooleanProperty(\\\"persistentMarkers\\\"))\\n\\t\\t\\t\\t\\tsetDirty(true);\\n\\t\\t\\t\\tmarker.removePosition();\\n\\t\\t\\t\\tmarkers.removeElementAt(i);\\n\\t\\t\\t\\ti--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tEditBus.send(new BufferUpdate(this,null,\\n\\t\\t\\tBufferUpdate.MARKERS_CHANGED));\\n\\t} \\n\\tpublic void removeAllMarkers()\\n\\t{\\n\\t\\tif(!getFlag(READ_ONLY) && jEdit.getBooleanProperty(\\\"persistentMarkers\\\"))\\n\\t\\t\\tsetDirty(true);\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t\\t((Marker)markers.elementAt(i)).removePosition();\\n\\t\\tmarkers.removeAllElements();\\n\\t\\tif(!getFlag(LOADING))\\n\\t\\t{\\n\\t\\t\\tEditBus.send(new BufferUpdate(this,null,\\n\\t\\t\\t\\tBufferUpdate.MARKERS_CHANGED));\\n\\t\\t}\\n\\t} \\n\\tpublic Marker getMarker(char shortcut)\\n\\t{\\n\\t\\tEnumeration enum = markers.elements();\\n\\t\\twhile(enum.hasMoreElements())\\n\\t\\t{\\n\\t\\t\\tMarker marker = (Marker)enum.nextElement();\\n\\t\\t\\tif(marker.getShortcut() == shortcut)\\n\\t\\t\\t\\treturn marker;\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic void setWaitSocket(Socket waitSocket)\\n\\t{\\n\\t\\tthis.waitSocket = waitSocket;\\n\\t} \\n\\tpublic final Buffer getNext()\\n\\t{\\n\\t\\treturn next;\\n\\t} \\n\\tpublic final Buffer getPrev()\\n\\t{\\n\\t\\treturn prev;\\n\\t} \\n\\tpublic final int getIndex()\\n\\t{\\n\\t\\tint count = 0;\\n\\t\\tBuffer buffer = prev;\\n\\t\\tfor(;;)\\n\\t\\t{\\n\\t\\t\\tif(buffer == null)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcount++;\\n\\t\\t\\tbuffer = buffer.prev;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t} \\n\\tpublic String toString()\\n\\t{\\n\\t\\treturn name + \\\" (\\\" + directory + \\\")\\\";\\n\\t} \\n\\tpublic OffsetManager _getOffsetManager()\\n\\t{\\n\\t\\treturn offsetMgr;\\n\\t} \\n\\t\\tBuffer prev;\\n\\tBuffer next;\\n\\t\\tBuffer(String path, boolean newFile, boolean temp, Hashtable props)\\n\\t{\\n\\t\\tlock = new ReadWriteLock();\\n\\t\\tpropertyLock = new Object();\\n\\t\\tcontentMgr = new ContentManager();\\n\\t\\toffsetMgr = new OffsetManager();\\n\\t\\tintegerArray = new IntegerArray();\\n\\t\\tundoMgr = new UndoManager(this);\\n\\t\\tbufferListeners = new Vector();\\n\\t\\tseg = new Segment();\\n\\t\\tmarkers = new Vector();\\n\\t\\tproperties = new HashMap();\\n\\t\\t\\t\\tEnumeration enum = props.keys();\\n\\t\\twhile(enum.hasMoreElements())\\n\\t\\t{\\n\\t\\t\\tObject key = enum.nextElement();\\n\\t\\t\\tObject value = props.get(key);\\n\\t\\t\\tproperties.put(key,new PropValue(value,false));\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tif(getProperty(ENCODING) == null)\\n\\t\\t\\tproperties.put(ENCODING,new PropValue(System.getProperty(\\\"file.encoding\\\"),false));\\n\\t\\tif(getProperty(LINESEP) == null)\\n\\t\\t\\tproperties.put(LINESEP,new PropValue(System.getProperty(\\\"line.separator\\\"),false));\\n\\t\\tsetFlag(TEMPORARY,temp);\\n\\t\\t\\t\\tsetPath(path);\\n\\t\\tsetFlag(UNTITLED,newFile);\\n\\t\\tsetFlag(NEW_FILE,newFile);\\n\\t} \\n\\t\\tvoid commitTemporary()\\n\\t{\\n\\t\\tsetFlag(TEMPORARY,false);\\n\\t\\tfinishLoading();\\n\\t} \\n\\t\\tvoid resetCachedProperties()\\n\\t{\\n\\t\\t\\t\\t\\t\\tIterator iter = properties.values().iterator();\\n\\t\\twhile(iter.hasNext())\\n\\t\\t{\\n\\t\\t\\tPropValue value = (PropValue)iter.next();\\n\\t\\t\\tif(value.defaultValue)\\n\\t\\t\\t\\titer.remove();\\n\\t\\t}\\n\\t} \\n\\t\\tvoid close()\\n\\t{\\n\\t\\tsetFlag(CLOSED,true);\\n\\t\\tif(autosaveFile != null)\\n\\t\\t\\tautosaveFile.delete();\\n\\t\\t\\t\\tif(waitSocket != null && !waitSocket.isClosed())\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\twaitSocket.getOutputStream().write('\\\\0');\\n\\t\\t\\t\\twaitSocket.getOutputStream().flush();\\n\\t\\t\\t\\twaitSocket.getInputStream().close();\\n\\t\\t\\t\\twaitSocket.getOutputStream().close();\\n\\t\\t\\t\\twaitSocket.close();\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void setFlag(int flag, boolean value)\\n\\t{\\n\\t\\tif(value)\\n\\t\\t\\tflags |= (1 << flag);\\n\\t\\telse\\n\\t\\t\\tflags &= ~(1 << flag);\\n\\t} \\n\\t\\tprivate boolean getFlag(int flag)\\n\\t{\\n\\t\\tint mask = (1 << flag);\\n\\t\\treturn (flags & mask) == mask;\\n\\t} \\n\\t\\tprivate static final int CLOSED = 0;\\n\\tprivate static final int LOADING = 1;\\n\\tprivate static final int IO = 2;\\n\\tprivate static final int NEW_FILE = 3;\\n\\tprivate static final int UNTITLED = 4;\\n\\tprivate static final int AUTOSAVE_DIRTY = 5;\\n\\tprivate static final int DIRTY = 6;\\n\\tprivate static final int READ_ONLY = 7;\\n\\tprivate static final int UNDO_IN_PROGRESS = 8;\\n\\tprivate static final int TEMPORARY = 9;\\n\\tprivate static final int INSIDE_INSERT = 10;\\n\\tprivate int flags;\\n\\t\\tprivate String path;\\n\\tprivate String symlinkPath;\\n\\tprivate String name;\\n\\tprivate String directory;\\n\\tprivate File file;\\n\\tprivate File autosaveFile;\\n\\tprivate long modTime;\\n\\tprivate Mode mode;\\n\\tprivate HashMap properties;\\n\\tprivate ReadWriteLock lock;\\n\\tprivate Object propertyLock;\\n\\tprivate ContentManager contentMgr;\\n\\tprivate OffsetManager offsetMgr;\\n\\tprivate IntegerArray integerArray;\\n\\tprivate UndoManager undoMgr;\\n\\tprivate Vector bufferListeners;\\n\\tprivate Vector markers;\\n\\t\\tprivate boolean textMode;\\n\\tprivate TokenMarker tokenMarker;\\n\\tprivate Segment seg;\\n\\tprivate boolean nextLineRequested;\\n\\tprivate FoldHandler foldHandler;\\n\\tprivate String wrap;\\n\\tprivate Socket waitSocket;\\n\\t\\tprivate void setPath(String path)\\n\\t{\\n\\t\\tthis.path = path;\\n\\t\\tthis.symlinkPath = path;\\n\\t\\tVFS vfs = VFSManager.getVFSForPath(path);\\n\\t\\tif((vfs.getCapabilities() & VFS.WRITE_CAP) == 0)\\n\\t\\t\\tsetReadOnly(true);\\n\\t\\tthis.name = vfs.getFileName(path);\\n\\t\\tthis.directory = vfs.getParentOfPath(path);\\n\\t\\tif(vfs instanceof FileVFS)\\n\\t\\t{\\n\\t\\t\\tfile = new File(path);\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tsymlinkPath = file.getCanonicalPath();\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,io);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(autosaveFile != null)\\n\\t\\t\\t\\tautosaveFile.delete();\\n\\t\\t\\tautosaveFile = new File(file.getParent(),'#' + name + '#');\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfile = null;\\n\\t\\t\\tautosaveFile = null;\\n\\t\\t}\\n\\t} \\n\\t\\tprivate boolean recoverAutosave(final View view)\\n\\t{\\n\\t\\tif(!autosaveFile.canRead())\\n\\t\\t\\treturn false;\\n\\t\\t\\t\\tGUIUtilities.hideSplashScreen();\\n\\t\\tfinal Object[] args = { autosaveFile.getPath() };\\n\\t\\tint result = GUIUtilities.confirm(view,\\\"autosave-found\\\",args,\\n\\t\\t\\tJOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE);\\n\\t\\tif(result == JOptionPane.YES_OPTION)\\n\\t\\t{\\n\\t\\t\\tVFSManager.getFileVFS().load(view,this,autosaveFile.getPath());\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tVFSManager.runInAWTThread(new Runnable()\\n\\t\\t\\t{\\n\\t\\t\\t\\tpublic void run()\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tGUIUtilities.message(view,\\\"autosave-loaded\\\",args);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn false;\\n\\t} \\n\\t\\tprivate boolean checkFileForLoad(View view, VFS vfs, String path)\\n\\t{\\n\\t\\tif((vfs.getCapabilities() & VFS.LOW_LATENCY_CAP) != 0)\\n\\t\\t{\\n\\t\\t\\tObject session = vfs.createVFSSession(path,view);\\n\\t\\t\\tif(session == null)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tVFS.DirectoryEntry file = vfs._getDirectoryEntry(session,path,view);\\n\\t\\t\\t\\tif(file == null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsetNewFile(true);\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!file.canRead)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror.no-read\\\",null);\\n\\t\\t\\t\\t\\tsetNewFile(false);\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsetReadOnly(!file.canWrite);\\n\\t\\t\\t\\tif(file.type != VFS.DirectoryEntry.FILE)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tVFSManager.error(view,path,\\n\\t\\t\\t\\t\\t\\t\\\"ioerror.open-directory\\\",null);\\n\\t\\t\\t\\t\\tsetNewFile(false);\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror\\\",\\n\\t\\t\\t\\t\\tnew String[] { io.toString() });\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvfs._endVFSSession(session,view);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror\\\",\\n\\t\\t\\t\\t\\t\\tnew String[] { io.toString() });\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t} \\n\\t\\tprivate boolean checkFileForSave(View view, VFS vfs, String path)\\n\\t{\\n\\t\\tif((vfs.getCapabilities() & VFS.LOW_LATENCY_CAP) != 0)\\n\\t\\t{\\n\\t\\t\\tObject session = vfs.createVFSSession(path,view);\\n\\t\\t\\tif(session == null)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tVFS.DirectoryEntry file = vfs._getDirectoryEntry(session,path,view);\\n\\t\\t\\t\\tif(file == null)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\tif(file.type != VFS.DirectoryEntry.FILE)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tVFSManager.error(view,path,\\n\\t\\t\\t\\t\\t\\t\\\"ioerror.save-directory\\\",null);\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror\\\",\\n\\t\\t\\t\\t\\tnew String[] { io.toString() });\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvfs._endVFSSession(session,view);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror\\\",\\n\\t\\t\\t\\t\\t\\tnew String[] { io.toString() });\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t} \\n\\t\\tprivate void finishLoading()\\n\\t{\\n\\t\\tparseBufferLocalProperties();\\n\\t\\t\\t\\t\\t\\tFoldHandler oldFoldHandler = foldHandler;\\n\\t\\tsetMode();\\n\\t\\tif(foldHandler == oldFoldHandler)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\toffsetMgr.setFirstInvalidFoldLevel(0);\\n\\t\\t\\tfireFoldHandlerChanged();\\n\\t\\t}\\n\\t\\t\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tint pos = marker.getPosition();\\n\\t\\t\\tif(pos > getLength())\\n\\t\\t\\t\\tmarker.setPosition(getLength());\\n\\t\\t\\tmarker.removePosition();\\n\\t\\t\\tmarker.createPosition();\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void finishSaving(View view, String oldPath, String path,\\n\\t\\tboolean rename, boolean error)\\n\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tif(!error && !path.equals(oldPath))\\n\\t\\t{\\n\\t\\t\\tBuffer buffer = jEdit.getBuffer(path);\\n\\t\\t\\tif(rename)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer != null && \\n\\t\\t\\t\\t\\t!buffer.getPath().equals(oldPath))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbuffer.setDirty(false);\\n\\t\\t\\t\\t\\tjEdit.closeBuffer(view,buffer);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsetPath(path);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer != null && \\n\\t\\t\\t\\t\\t!buffer.getPath().equals(oldPath))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbuffer.load(view,true);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tif(rename)\\n\\t\\t{\\n\\t\\t\\tif(file != null)\\n\\t\\t\\t\\tmodTime = file.lastModified();\\n\\t\\t\\tif(!error)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twriteLock();\\n\\t\\t\\t\\t\\tif(autosaveFile != null)\\n\\t\\t\\t\\t\\t\\tautosaveFile.delete();\\n\\t\\t\\t\\t\\tsetFlag(AUTOSAVE_DIRTY,false);\\n\\t\\t\\t\\t\\tsetFlag(READ_ONLY,false);\\n\\t\\t\\t\\t\\tsetFlag(NEW_FILE,false);\\n\\t\\t\\t\\t\\tsetFlag(UNTITLED,false);\\n\\t\\t\\t\\t\\tsetFlag(DIRTY,false);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tundoMgr.bufferSaved();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfinally\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twriteUnlock();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tparseBufferLocalProperties();\\n\\t\\t\\t\\tif(!getPath().equals(oldPath))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tjEdit.updatePosition(Buffer.this);\\n\\t\\t\\t\\t\\tsetMode();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tString newMode = getStringProperty(\\\"mode\\\");\\n\\t\\t\\t\\t\\tif(newMode != null &&\\n\\t\\t\\t\\t\\t\\t!newMode.equals(getMode()\\n\\t\\t\\t\\t\\t\\t.getName()))\\n\\t\\t\\t\\t\\t\\tsetMode();\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tpropertiesChanged();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tEditBus.send(new BufferUpdate(Buffer.this,\\n\\t\\t\\t\\t\\tview,BufferUpdate.DIRTY_CHANGED));\\n\\t\\t\\t\\t\\t\\t\\t\\tEditBus.send(new BufferUpdate(Buffer.this,\\n\\t\\t\\t\\t\\tview,BufferUpdate.SAVED));\\n\\t\\t\\t}\\n\\t\\t} \\t} \\n\\t\\tprivate void parseBufferLocalProperties()\\n\\t{\\n\\t\\tint lastLine = Math.min(9,getLineCount() - 1);\\n\\t\\tparseBufferLocalProperties(getText(0,getLineEndOffset(lastLine) - 1));\\n\\t\\t\\t\\t\\t\\tint firstLine = Math.max(lastLine + 1, getLineCount() - 10);\\n\\t\\tif(firstLine < getLineCount())\\n\\t\\t{\\n\\t\\t\\tint length = getLineEndOffset(getLineCount() - 1) \\n\\t\\t\\t\\t- (getLineStartOffset(firstLine) + 1);\\n\\t\\t\\tparseBufferLocalProperties(getText(getLineStartOffset(firstLine),length));\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void parseBufferLocalProperties(String prop)\\n\\t{\\n\\t\\tStringBuffer buf = new StringBuffer();\\n\\t\\tString name = null;\\n\\t\\tboolean escape = false;\\n\\t\\tfor(int i = 0; i < prop.length(); i++)\\n\\t\\t{\\n\\t\\t\\tchar c = prop.charAt(i);\\n\\t\\t\\tswitch(c)\\n\\t\\t\\t{\\n\\t\\t\\tcase ':':\\n\\t\\t\\t\\tif(escape)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tescape = false;\\n\\t\\t\\t\\t\\tbuf.append(':');\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(name != null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tproperties.put(name,new PropValue(buf.toString(),false));\\n\\t\\t\\t\\t\\tname = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbuf.setLength(0);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase '=':\\n\\t\\t\\t\\tif(escape)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tescape = false;\\n\\t\\t\\t\\t\\tbuf.append('=');\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tname = buf.toString();\\n\\t\\t\\t\\tbuf.setLength(0);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase '\\\\\\\\':\\n\\t\\t\\t\\tif(escape)\\n\\t\\t\\t\\t\\tbuf.append('\\\\\\\\');\\n\\t\\t\\t\\tescape = !escape;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 'n':\\n\\t\\t\\t\\tif(escape)\\n\\t\\t\\t\\t{\\tbuf.append('\\\\n');\\n\\t\\t\\t\\t\\tescape = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\tcase 'r':\\n\\t\\t\\t\\tif(escape)\\n\\t\\t\\t\\t{\\tbuf.append('\\\\r');\\n\\t\\t\\t\\t\\tescape = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\tcase 't':\\n\\t\\t\\t\\tif(escape)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbuf.append('\\\\t');\\n\\t\\t\\t\\t\\tescape = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tbuf.append(c);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void setTokenMarker(TokenMarker tokenMarker)\\n\\t{\\n\\t\\tTokenMarker oldTokenMarker = this.tokenMarker;\\n\\t\\tthis.tokenMarker = tokenMarker;\\n\\t\\t\\t\\tif(oldTokenMarker != null && tokenMarker != oldTokenMarker)\\n\\t\\t{\\n\\t\\t\\toffsetMgr.setFirstInvalidLineContext(0);\\n\\t\\t}\\n\\t} \\n\\tprivate int getPriorNonEmptyLine(int lineIndex)\\n\\t{\\n\\t\\tfor(int i = lineIndex - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(getLineLength(i) != 0)\\n\\t\\t\\t\\treturn i;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t} \\n\\t\\tprivate void contentInserted(int offset, int length,\\n\\t\\tIntegerArray endOffsets)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tsetFlag(INSIDE_INSERT,true);\\n\\t\\t\\tint startLine = offsetMgr.getLineOfOffset(offset);\\n\\t\\t\\tint numLines = endOffsets.getSize();\\n\\t\\t\\toffsetMgr.contentInserted(startLine,offset,numLines,length,\\n\\t\\t\\t\\tendOffsets);\\n\\t\\t\\tsetDirty(true);\\n\\t\\t\\tif(!getFlag(LOADING))\\n\\t\\t\\t\\tfireContentInserted(startLine,offset,numLines,length);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tsetFlag(INSIDE_INSERT,false);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate BufferChangeListener getListener(int index)\\n\\t{\\n\\t\\treturn ((Listener)bufferListeners.elementAt(index)).listener;\\n\\t} \\n\\t\\tprivate void fireFoldLevelChanged(int start, int end)\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).foldLevelChanged(this,start,end);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireContentInserted(int startLine, int offset,\\n\\t\\tint numLines, int length)\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).contentInserted(this,startLine,\\n\\t\\t\\t\\t\\toffset,numLines,length);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireContentRemoved(int startLine, int offset,\\n\\t\\tint numLines, int length)\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).contentRemoved(this,startLine,\\n\\t\\t\\t\\t\\toffset,numLines,length);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void firePreContentRemoved(int startLine, int offset,\\n\\t\\tint numLines, int length)\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).preContentRemoved(this,startLine,\\n\\t\\t\\t\\t\\toffset,numLines,length);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireTransactionComplete()\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).transactionComplete(this);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireFoldHandlerChanged()\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).foldHandlerChanged(this);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireWrapModeChanged()\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).wrapModeChanged(this);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t}\""
            },
            "m14": {
                "content": "The source code for `Buffer.java` reveals that it is a central class in the jEdit system, handling many core functionalities related to buffer management, file I/O, editing operations, and interactions with other components like `VFSBrowser`, `RESearchMatcher`, and `JEditTextArea`. Here are some key insights from the analysis:\n\n### Key Observations:\n1. **Core Responsibilities**:\n   - `Buffer.java` manages text content, including insertion, deletion, and retrieval.\n   - It handles file loading, saving, and autosaving, interacting with the file system via `VFSManager`.\n   - It maintains buffer state (e.g., dirty flags, read-only status) and supports undo/redo operations through `UndoManager`.\n\n2. **Key Dependencies**:\n   - **`VFSBrowser`**: Used for file browsing and selection operations.\n   - **`RESearchMatcher`**: Involved in search functionality.\n   - **`JEditTextArea`**: Although there's no direct coupling dependency, they share conceptual similarity due to frequent co-changes.\n\n3. **Runtime Interactions**:\n   - The call graph indicates that `Buffer.java` interacts directly with `RESearchMatcher` and `VFSBrowser`, even though structural coupling tools don't show direct dependencies.\n\n### Entities That Need Synchronization\nBased on the co-change relationships, conceptual coupling, and runtime dependencies, the following entities should be synchronized or carefully reviewed when modifying `Buffer.java`:\n\n- **`JEditTextArea.java`**: High co-change confidence (0.58), indicating shared responsibilities despite no direct coupling.\n- **`jEdit.java`**: Core application class with high co-change confidence (0.24).\n- **`VFSBrowser.java`**: Direct interaction in file operations and moderate co-change confidence.\n- **`RESearchMatcher.java`**: Direct usage in the source code.\n- **`View.java`, `EditPane.java`, `TextAreaPainter.java`, `DisplayManager.java`, `BufferChangeHandler.java`, `ChunkCache.java`, `MouseHandler.java`, `OffsetManager.java`**: These have relatively high co-change confidence and may be affected indirectly.\n\n### Next Steps\nIf you need more detailed information about any of these files or their dependencies, I can perform further analysis using available tools. For example, we could examine coupling dependencies for another file or analyze the conceptual coupling between additional pairs.\n\nWould you like to proceed with deeper analysis of one of these files?",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            },
            "m15": {
                "role": "user",
                "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
            },
            "m16": {
                "content": "Title: Diagnosis of starting entity `Buffer.java`\n\nChange set: [JEditTextArea, jEdit, VFSBrowser, View, EditPane, ActionHandler, TextAreaPainter, DisplayManager, BufferChangeHandler, MouseHandler, OffsetManager, ChunkCache, GeneralOptionPane, FileVFS, VFSManager, RESearchMatcher, SyntaxStyle, TextAreaExtension, UndoManager, BufferIORequest, BufferSwitcher, DocumentHandler, Gutter, ModeOptionPane, MarkerHighlight, BufferOptions, Marker, InputHandler, DefaultInputHandler, SearchDialog, TextAreaOptionPane, Macros, DockableWindowManager, GUIUtilities, BracketIndentRule, OpenBracketIndentRule, IndentRule, CloseBracketIndentRule, AlignBracket, Increase, Abbrevs, TextAreaTransferHandler]\n\nDetails:\n1. **JEditTextArea (Co-change confidence: 0.58)**: High conceptual coupling and frequent co-changes suggest shared responsibilities in text editing despite no direct structural dependency.\n2. **jEdit (0.24)**: Core application class that coordinates buffer and UI interactions; changes to buffer logic often affect global behavior.\n3. **VFSBrowser (0.18)**: Direct runtime interaction for file browsing and selection; involved in loading/saving operations.\n4. **View (0.15)**: Manages user interface components tied to buffers; likely affected due to view-buffer synchronization needs.\n5. **EditPane (0.12)**: Handles display of buffers; interacts directly with buffer state and content.\n6. **ActionHandler**: Coordinates actions involving buffer manipulation; high co-change suggests shared logic.\n7. **TextAreaPainter (0.16)**: Renders buffer content visually; tightly linked to buffer's visual representation.\n8. **DisplayManager (0.17)**: Manages how buffers are displayed; highly impacted by buffer state changes.\n9. **BufferChangeHandler (0.17)**: Responds to buffer change events; frequently co-changed indicates tight integration.\n10. **MouseHandler (0.19)**: Interacts with buffer during mouse-driven edits or selections.\n11. **OffsetManager**: Tracks line offsets and manages buffer structure; core dependency within buffer management logic.\n12. **ChunkCache (0.18)**: Caches buffer chunks; closely related to buffer storage and retrieval mechanisms.\n13. **GeneralOptionPane**: Configuration settings affecting buffer behavior; co-change implies shared preferences.\n14. **FileVFS**: Involved in low-level buffer file I/O; direct usage in loading/saving workflows.\n15. **VFSManager**: Central to file system abstraction used by buffer; co-change reflects shared I/O handling.\n16. **RESearchMatcher**: Used for regex-based search operations; referenced directly in buffer methods.\n17. **SyntaxStyle**: Impacts how buffer content is highlighted; co-change implies style-content dependencies.\n18. **TextAreaExtension**: Extends text area functionality; may interact with buffer during rendering or editing.\n19. **UndoManager**: Maintains edit history; tightly coupled with buffer modifications.\n20. **BufferIORequest**: Encapsulates I/O operations; co-change shows shared lifecycle.\n21. **BufferSwitcher**: Switches between buffers; affected by buffer state transitions.\n22. **DocumentHandler**: Manages document updates; interacts with buffer content changes.\n23. **Gutter**: Displays line numbers and annotations; relies on buffer metadata.\n24. **ModeOptionPane**: Configures buffer modes; co-change indicates mode-buffer dependencies.\n25. **MarkerHighlight**: Highlights markers in the buffer; depends on buffer marker logic.\n26. **BufferOptions**: Stores buffer-specific configuration; frequently adjusted alongside buffer state.\n27. **Marker**: Manages buffer bookmarks; buffer changes can affect marker positions.\n28. **InputHandler**: Processes input events; interacts with buffer during editing.\n29. **DefaultInputHandler**: Standard implementation of input handling; shares buffer event logic.\n30. **SearchDialog**: Initiates search operations; relies on buffer search capabilities.\n31. **TextAreaOptionPane**: Configures text area appearance; indirectly affects buffer display.\n32. **Macros**: Automates buffer operations; co-change implies macro-buffer integration.\n33. **DockableWindowManager**: Manages windows docked to buffer views; dependent on buffer context.\n34. **GUIUtilities**: Provides UI helpers; invoked by buffer during file and UI operations.\n35. **BracketIndentRule**: Affects indentation behavior; buffer uses it for formatting.\n36. **OpenBracketIndentRule**: Part of indentation logic; co-change indicates formatting integration.\n37. **IndentRule**: Governs indentation rules; buffer applies these during editing.\n38. **CloseBracketIndentRule**: Influences bracket closing behavior; used by buffer formatting.\n39. **AlignBracket**: Helps align brackets; buffer formatting depends on it.\n40. **Increase**: Likely involved in adjustment operations; co-change suggests interaction.\n41. **Abbrevs**: Expands abbreviations; buffer content triggers abbreviation logic.\n42. **TextAreaTransferHandler**: Handles drag-and-drop and clipboard operations; interacts with buffer content.\n\nAll entities listed above are derived from co-change relationships, conceptual coupling, and direct/indirect source code interactions. They represent a comprehensive recall-oriented set where even moderate co-change confidence or indirect involvement has been considered to ensure coverage.",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            }
        }
    }
}