{
    "time": 1749535116.1248906,
    "messages": [
        {
            "role": "system",
            "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
        },
        {
            "role": "user",
            "content": "The project you need to analyze is `jEdit`, a well-known Java open source project. The starting entity you need to deal with is DisplayManager.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
        },
        {
            "content": "",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_b3f922d9b9ae4c76a8b330",
                    "function": {
                        "arguments": "{\"entity\": \"DisplayManager.java\"}",
                        "name": "get_co_change_relationship"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "name": "get_co_change_relationship",
            "role": "tool",
            "content": "[[\"FirstLine\", \"6\", \"0.375\"], [\"ScrollLineCount\", \"6\", \"0.375\"], [\"ChunkCache\", \"6\", \"0.375\"], [\"HelpIndex\", \"2\", \"0.125\"], [\"HelpTOCPanel\", \"2\", \"0.125\"], [\"View\", \"2\", \"0.125\"], [\"BufferChangeHandler\", \"9\", \"0.5625\"], [\"BufferIORequest\", \"4\", \"0.25\"], [\"RingListModel\", \"2\", \"0.125\"], [\"OffsetManager\", \"2\", \"0.125\"], [\"PosBottomHalf\", \"2\", \"0.125\"], [\"PositionManager\", \"2\", \"0.125\"], [\"PasteFromListDialog\", \"2\", \"0.125\"], [\"ListHandler\", \"2\", \"0.125\"], [\"KeyHandler\", \"2\", \"0.125\"], [\"FontSelector\", \"2\", \"0.125\"], [\"FontSelectorDialog\", \"2\", \"0.125\"], [\"TextAreaOptionPane\", \"2\", \"0.125\"], [\"ActionHandler\", \"2\", \"0.125\"], [\"JEditTextArea\", \"3\", \"0.1875\"], [\"TextAreaPainter\", \"2\", \"0.125\"], [\"EditPane\", \"2\", \"0.125\"], [\"BeanShell\", \"2\", \"0.125\"], [\"MouseHandler\", \"1\", \"0.0625\"], [\"Anchor\", \"1\", \"0.0625\"], [\"RangeMap\", \"1\", \"0.0625\"]]"
        },
        {
            "content": "From the co-change relationship analysis, we see that several files are frequently modified alongside `DisplayManager.java`. These relationships indicate potential dependencies or synchronized changes that could be impacted by modifications in `DisplayManager.java`.\n\nHere\u2019s how we can interpret some of the key results:\n- **BufferChangeHandler (support: 9, confidence: 0.5625)** and **FirstLine, ScrollLineCount, ChunkCache (support: 6, confidence: 0.375 each)** show significant co-change patterns.\n- Other files such as **JEditTextArea (support: 3, confidence: 0.1875)** and various UI/dialog-related components have lower but notable co-change associations.\n\nTo better understand which entities should be prioritized for synchronization, let's explore further. I'll examine the coupling dependencies between `DisplayManager.java` and some of its top co-changed files, particularly focusing on **BufferChangeHandler.java** and **FirstLine.java**, as they have high support and confidence values.\n\nI will proceed with calling the `get_coupling_dependencies` function for these pairs. \n\n1. Call `get_coupling_dependencies` for `DisplayManager.java` and `BufferChangeHandler.java`.\n2. Call `get_coupling_dependencies` for `DisplayManager.java` and `FirstLine.java`.\n\nThis will help us determine if there are direct dependencies between them. \n\nLet me start with the first step:\n\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_14ab9619ce58497789762b",
                    "function": {
                        "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"BufferChangeHandler.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"BufferChangeHandler has been removed from the project due to project version iteration\"]"
        },
        {
            "content": "It appears that `BufferChangeHandler.java` has been removed from the project due to version iterations, which explains the coupling dependency result. This means it is no longer actively dependent on `DisplayManager.java`.\n\nLet\u2019s proceed with the second step and analyze the coupling dependencies between `DisplayManager.java` and `FirstLine.java`. This will help us determine if there is any direct dependency with this co-changed file.\n\nI'll call the `get_coupling_dependencies` function for these two files:\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_7a7ab4b21f294f8eae61c5",
                    "function": {
                        "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"FirstLine.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"FirstLine has been removed from the project due to project version iteration\"]"
        },
        {
            "content": "Similar to `BufferChangeHandler.java`, the file `FirstLine.java` has also been removed from the project due to version iterations. This indicates that the co-change relationships we observed are based on historical modifications, and some of the related files may no longer exist in the current codebase.\n\nTo further analyze the impact of changes to `DisplayManager.java`, let's explore its direct dependencies by examining its call graph. This will help us identify which entities are currently being used or referenced by `DisplayManager.java`.\n\nI'll proceed by calling the `get_call_graph` function for `DisplayManager.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_7d0c535f579f4708bf54d4",
                    "function": {
                        "arguments": "{\"entity\": \"DisplayManager.java\"}",
                        "name": "get_call_graph"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_call_graph",
            "content": "[\"Log\", \"\", \"\"]"
        },
        {
            "content": "The call graph analysis for `DisplayManager.java` returned minimal information, showing only a reference to `Log`, which likely corresponds to logging functionality. This doesn't provide substantial insight into the dependencies or usage of `DisplayManager.java`.\n\nTo gain a deeper understanding, I will examine the source code of `DisplayManager.java` directly. This will allow us to analyze its structure, identify key components, and determine potential relationships with other entities.\n\nI'll proceed by calling the `get_origin_code` function to retrieve the source code of `DisplayManager.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_882ebabe5b444d74ae9b15",
                    "function": {
                        "arguments": "{\"entity\": \"DisplayManager.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package org.gjt.sp.jedit.textarea;\\nimport java.awt.Toolkit;\\nimport java.util.*;\\nimport org.gjt.sp.jedit.buffer.*;\\nimport org.gjt.sp.jedit.*;\\nimport org.gjt.sp.util.Log;\\npublic class DisplayManager\\n{\\n\\tpublic static long scanCount, scannedLines;\\n\\t\\tstatic DisplayManager getDisplayManager(Buffer buffer,\\n\\t\\tJEditTextArea textArea)\\n\\t{\\n\\t\\tList l = (List)bufferMap.get(buffer);\\n\\t\\tDisplayManager dmgr;\\n\\t\\tif(l == null)\\n\\t\\t{\\n\\t\\t\\tl = new LinkedList();\\n\\t\\t\\tbufferMap.put(buffer,l);\\n\\t\\t}\\n\\t\\tIterator liter = l.iterator();\\n\\t\\twhile(liter.hasNext())\\n\\t\\t{\\n\\t\\t\\tdmgr = (DisplayManager)liter.next();\\n\\t\\t\\tif(!dmgr.inUse && dmgr.textArea == textArea)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdmgr.inUse = true;\\n\\t\\t\\t\\treturn dmgr;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tdmgr = new DisplayManager(buffer,textArea);\\n\\t\\tdmgr.inUse = true;\\n\\t\\tl.add(dmgr);\\n\\t\\treturn dmgr;\\n\\t} \\n\\t\\tstatic void releaseDisplayManager(DisplayManager dmgr)\\n\\t{\\n\\t\\tdmgr.inUse = false;\\n\\t} \\n\\t\\tpublic static void bufferClosed(Buffer buffer)\\n\\t{\\n\\t\\tbufferMap.remove(buffer);\\n\\t} \\n\\t\\tstatic void textAreaDisposed(JEditTextArea textArea)\\n\\t{\\n\\t\\tIterator biter = bufferMap.values().iterator();\\n\\t\\twhile(biter.hasNext())\\n\\t\\t{\\n\\t\\t\\tList l = (List)biter.next();\\n\\t\\t\\tIterator liter = l.iterator();\\n\\t\\t\\twhile(liter.hasNext())\\n\\t\\t\\t{\\n\\t\\t\\t\\tDisplayManager dmgr = (DisplayManager)\\n\\t\\t\\t\\t\\tliter.next();\\n\\t\\t\\t\\tif(dmgr.textArea == textArea)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdmgr.dispose();\\n\\t\\t\\t\\t\\tliter.remove();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tprivate static Map bufferMap = new HashMap();\\n\\tpublic final boolean isLineVisible(int line)\\n\\t{\\n\\t\\treturn fvmget(line) % 2 == 0;\\n\\t} \\n\\tpublic int getFirstVisibleLine()\\n\\t{\\n\\t\\treturn fvm[0];\\n\\t} \\n\\tpublic int getLastVisibleLine()\\n\\t{\\n\\t\\treturn fvm[fvmcount - 1] - 1;\\n\\t} \\n\\tpublic int getNextVisibleLine(int line)\\n\\t{\\n\\t\\tif(line < 0 || line >= buffer.getLineCount())\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(line);\\n\\t\\tint index = fvmget(line);\\n\\t\\tif(index % 2 != 0)\\n\\t\\t{\\n\\t\\t\\tif(fvmcount == index + 1)\\n\\t\\t\\t\\treturn - 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn fvm[index + 1];\\n\\t\\t}\\n\\t\\telse if(line == fvm[index + 1] - 1)\\n\\t\\t{\\n\\t\\t\\tif(fvmcount == index + 2)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn fvm[index + 2];\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn line + 1;\\n\\t} \\n\\tpublic int getPrevVisibleLine(int line)\\n\\t{\\n\\t\\tif(line < 0 || line >= buffer.getLineCount())\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(line);\\n\\t\\tint index = fvmget(line);\\n\\t\\tif(index == -1)\\n\\t\\t\\treturn -1;\\n\\t\\telse if(index % 2 == 1)\\n\\t\\t{\\n\\t\\t\\treturn fvm[index] - 1;\\n\\t\\t}\\n\\t\\telse if(line == fvm[index])\\n\\t\\t{\\n\\t\\t\\tif(index == 0)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn fvm[index - 1] - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn line - 1;\\n\\t} \\n\\t\\tpublic final int getScreenLineCount(int line)\\n\\t{\\n\\t\\tif(!screenLineMgr.isScreenLineCountValid(line))\\n\\t\\t\\tthrow new RuntimeException(\\\"Invalid screen line count: \\\" + line);\\n\\t\\treturn screenLineMgr.getScreenLineCount(line);\\n\\t} \\n\\t\\tpublic final int getScrollLineCount()\\n\\t{\\n\\t\\treturn scrollLineCount.scrollLine;\\n\\t} \\n\\tpublic void collapseFold(int line)\\n\\t{\\n\\t\\tint lineCount = buffer.getLineCount();\\n\\t\\tint start = 0;\\n\\t\\tint end = lineCount - 1;\\n\\t\\t\\t\\t\\t\\tif(line != 0\\n\\t\\t\\t&& line != buffer.getLineCount() - 1\\n\\t\\t\\t&& buffer.isFoldStart(line)\\n\\t\\t\\t&& !isLineVisible(line + 1))\\n\\t\\t{\\n\\t\\t\\tline--;\\n\\t\\t}\\n\\t\\tint initialFoldLevel = buffer.getFoldLevel(line);\\n\\t\\t\\t\\tif(line != lineCount - 1\\n\\t\\t\\t&& buffer.getFoldLevel(line + 1) > initialFoldLevel)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tstart = line + 1;\\n\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.getFoldLevel(i) <= initialFoldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tboolean ok = false;\\n\\t\\t\\t\\t\\t\\tfor(int i = line - 1; i >= 0; i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstart = i + 1;\\n\\t\\t\\t\\t\\tok = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(!ok)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\thideLineRange(start,end);\\n\\t\\tnotifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic int expandFold(int line, boolean fully)\\n\\t{\\n\\t\\t\\t\\tint returnValue = -1;\\n\\t\\tint lineCount = buffer.getLineCount();\\n\\t\\tint start = 0;\\n\\t\\tint end = lineCount - 1;\\n\\t\\tint initialFoldLevel = buffer.getFoldLevel(line);\\n\\t\\t\\t\\tif(line != lineCount - 1\\n\\t\\t\\t&& isLineVisible(line)\\n\\t\\t\\t&& !isLineVisible(line + 1)\\n\\t\\t\\t&& buffer.getFoldLevel(line + 1) > initialFoldLevel)\\n\\t\\t{\\n\\t\\t\\tint index = fvmget(line + 1);\\n\\t\\t\\tif(index == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\texpandAllFolds();\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\tstart = fvm[index];\\n\\t\\t\\tif(index != fvmcount - 1)\\n\\t\\t\\t\\tend = fvm[index + 1] - 1;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart = line + 1;\\n\\t\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(\\n\\t\\t\\t\\t\\t\\tbuffer.getFoldLevel(i) <= initialFoldLevel)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint index = fvmget(line);\\n\\t\\t\\tif(index == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\texpandAllFolds();\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\tstart = fvm[index];\\n\\t\\t\\tif(index != fvmcount - 1)\\n\\t\\t\\t\\tend = fvm[index + 1] - 1;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif((isLineVisible(i) &&\\n\\t\\t\\t\\t\\t\\tbuffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t\\t\\t|| i == getLastVisibleLine())\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tif(fully)\\n\\t\\t{\\n\\t\\t\\tshowLineRange(start,end);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tinitialFoldLevel = buffer.getFoldLevel(start);\\n\\t\\t\\tint firstVisible = start;\\n\\t\\t\\tfor(int i = start; i <= end; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.getFoldLevel(i) > initialFoldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(returnValue == -1\\n\\t\\t\\t\\t\\t\\t&& i != 0\\n\\t\\t\\t\\t\\t\\t&& buffer.isFoldStart(i - 1))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturnValue = i - 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(firstVisible != i)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tshowLineRange(firstVisible,i - 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfirstVisible = i + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(firstVisible != end + 1)\\n\\t\\t\\t\\tshowLineRange(firstVisible,end);\\n\\t\\t\\tif(!isLineVisible(line))\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\texpandFold(line,false);\\n\\t\\t\\t\\treturn returnValue;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tnotifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t\\treturn returnValue;\\n\\t} \\n\\tpublic void expandAllFolds()\\n\\t{\\n\\t\\tshowLineRange(0,buffer.getLineCount() - 1);\\n\\t\\tnotifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic void expandFolds(char digit)\\n\\t{\\n\\t\\tif(digit < '1' || digit > '9')\\n\\t\\t{\\n\\t\\t\\tToolkit.getDefaultToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\texpandFolds((int)(digit - '1') + 1);\\n\\t} \\n\\tpublic void expandFolds(int foldLevel)\\n\\t{\\n\\t\\tif(buffer.getFoldHandler() instanceof IndentFoldHandler)\\n\\t\\t\\tfoldLevel = (foldLevel - 1) * buffer.getIndentSize() + 1;\\n\\t\\tshowLineRange(0,buffer.getLineCount() - 1);\\n\\t\\tboolean seenVisibleLine = false;\\n\\t\\tint firstInvisible = 0;\\n\\t\\tfor(int i = 0; i < buffer.getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tif(!seenVisibleLine || buffer.getFoldLevel(i) < foldLevel)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(firstInvisible != i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\thideLineRange(firstInvisible,\\n\\t\\t\\t\\t\\t\\ti - 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfirstInvisible = i + 1;\\n\\t\\t\\t\\tseenVisibleLine = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(firstInvisible != buffer.getLineCount())\\n\\t\\t\\thideLineRange(firstInvisible,buffer.getLineCount() - 1);\\n\\t\\tnotifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic void narrow(int start, int end)\\n\\t{\\n\\t\\tif(start > end || start < 0 || end >= buffer.getLineCount())\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(start + \\\", \\\" + end);\\n\\t\\tif(start < getFirstVisibleLine() || end > getLastVisibleLine())\\n\\t\\t\\texpandAllFolds();\\n\\t\\tif(start != 0)\\n\\t\\t\\thideLineRange(0,start - 1);\\n\\t\\tif(end != buffer.getLineCount() - 1)\\n\\t\\t\\thideLineRange(end + 1,buffer.getLineCount() - 1);\\n\\t\\t\\t\\tif(start != buffer.getLineCount() - 1\\n\\t\\t\\t&& !isLineVisible(start + 1))\\n\\t\\t\\texpandFold(start,false);\\n\\t\\t\\t\\t\\t\\tGUIUtilities.getView(textArea).getStatus().setMessageAndClear(\\n\\t\\t\\tjEdit.getProperty(\\\"view.status.narrow\\\"));\\n\\t\\tnotifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic void bufferLoaded()\\n\\t{\\n\\t\\tfvmreset();\\n\\t\\tscreenLineMgr.reset();\\n\\t\\tfirstLine.reset();\\n\\t\\tscrollLineCount.reset();\\n\\t\\tclearNotifyFlags();\\n\\t\\tint collapseFolds = buffer.getIntegerProperty(\\n\\t\\t\\t\\\"collapseFolds\\\",0);\\n\\t\\tif(collapseFolds != 0)\\n\\t\\t\\texpandFolds(collapseFolds);\\n\\t} \\n\\t\\tboolean softWrap;\\n\\tint wrapMargin;\\n\\tboolean wrapToWidth;\\n\\tFirstLine firstLine;\\n\\tScrollLineCount scrollLineCount;\\n\\t\\tvoid init()\\n\\t{\\n\\t\\tupdateWrapSettings();\\n\\t\\tif(initialized)\\n\\t\\t{\\n\\t\\t\\tif(buffer.isLoaded())\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.reset();\\n\\t\\t\\t\\tscrollLineCount.reset();\\n\\t\\t\\t\\tclearNotifyFlags();\\n\\t\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tinitialized = true;\\n\\t\\t\\tfvm = new int[2];\\n\\t\\t\\tif(buffer.isLoaded())\\n\\t\\t\\t\\tbufferChangeHandler.foldHandlerChanged(buffer);\\n\\t\\t\\telse\\n\\t\\t\\t\\tfvmreset();\\n\\t\\t\\tnotifyScreenLineChanges();\\n\\t\\t}\\n\\t} \\n\\t\\tvoid updateWrapSettings()\\n\\t{\\n\\t\\tString wrap = buffer.getStringProperty(\\\"wrap\\\");\\n\\t\\tsoftWrap = wrap.equals(\\\"soft\\\");\\n\\t\\tif(textArea.maxLineLen <= 0)\\n\\t\\t{\\n\\t\\t\\tif(softWrap)\\n\\t\\t\\t{\\n\\t\\t\\t\\twrapToWidth = true;\\n\\t\\t\\t\\twrapMargin = textArea.getPainter().getWidth()\\n\\t\\t\\t\\t\\t- textArea.charWidth * 3;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\twrapToWidth = false;\\n\\t\\t\\t\\twrapMargin = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tchar[] foo = new char[textArea.maxLineLen];\\n\\t\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfoo[i] = ' ';\\n\\t\\t\\t}\\n\\t\\t\\tTextAreaPainter painter = textArea.getPainter();\\n\\t\\t\\twrapToWidth = false;\\n\\t\\t\\twrapMargin = (int)painter.getFont().getStringBounds(\\n\\t\\t\\t\\tfoo,0,foo.length,\\n\\t\\t\\t\\tpainter.getFontRenderContext())\\n\\t\\t\\t\\t.getWidth();\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void clearNotifyFlags()\\n\\t{\\n\\t\\tfirstLine.callReset = firstLine.callChanged = false;\\n\\t\\tscrollLineCount.callReset = scrollLineCount.callChanged = false;\\n\\t} \\n\\t\\tvoid notifyScreenLineChanges()\\n\\t{\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"notifyScreenLineChanges()\\\");\\n\\t\\t\\t\\t\\t\\tif(textArea.getDisplayManager() != this)\\n\\t\\t\\treturn;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tif(firstLine.callReset)\\n\\t\\t\\t\\tfirstLine.reset();\\n\\t\\t\\telse if(firstLine.callChanged)\\n\\t\\t\\t\\tfirstLine.changed();\\n\\t\\t\\tif(scrollLineCount.callReset)\\n\\t\\t\\t\\tscrollLineCount.reset();\\n\\t\\t\\telse if(scrollLineCount.callChanged)\\n\\t\\t\\t\\tscrollLineCount.changed();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tclearNotifyFlags();\\n\\t\\t}\\n\\t} \\n\\t\\tvoid setFirstLine(int oldFirstLine, int firstLine)\\n\\t{\\n\\t\\tint visibleLines = textArea.getVisibleLines();\\n\\t\\tif(firstLine >= oldFirstLine + visibleLines)\\n\\t\\t{\\n\\t\\t\\tthis.firstLine.scrollDown(firstLine - oldFirstLine);\\n\\t\\t\\ttextArea.chunkCache.invalidateAll();\\n\\t\\t}\\n\\t\\telse if(firstLine <= oldFirstLine - visibleLines)\\n\\t\\t{\\n\\t\\t\\tthis.firstLine.scrollUp(oldFirstLine - firstLine);\\n\\t\\t\\ttextArea.chunkCache.invalidateAll();\\n\\t\\t}\\n\\t\\telse if(firstLine > oldFirstLine)\\n\\t\\t{\\n\\t\\t\\tthis.firstLine.scrollDown(firstLine - oldFirstLine);\\n\\t\\t\\ttextArea.chunkCache.scrollDown(firstLine - oldFirstLine);\\n\\t\\t}\\n\\t\\telse if(firstLine < oldFirstLine)\\n\\t\\t{\\n\\t\\t\\tthis.firstLine.scrollUp(oldFirstLine - firstLine);\\n\\t\\t\\ttextArea.chunkCache.scrollUp(oldFirstLine - firstLine);\\n\\t\\t}\\n\\t\\tnotifyScreenLineChanges();\\n\\t} \\t\\n\\t\\tvoid setFirstPhysicalLine(int amount, int skew)\\n\\t{\\n\\t\\tint oldFirstLine = textArea.getFirstLine();\\n\\t\\tif(amount == 0)\\n\\t\\t{\\n\\t\\t\\tskew -= this.firstLine.skew;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(skew < 0)\\n\\t\\t\\t\\tthis.firstLine.scrollUp(-skew);\\n\\t\\t\\telse if(skew > 0)\\n\\t\\t\\t\\tthis.firstLine.scrollDown(skew);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(amount > 0)\\n\\t\\t\\tthis.firstLine.physDown(amount,skew);\\n\\t\\telse if(amount < 0)\\n\\t\\t\\tthis.firstLine.physUp(-amount,skew);\\n\\t\\tint firstLine = textArea.getFirstLine();\\n\\t\\tint visibleLines = textArea.getVisibleLines();\\n\\t\\tif(firstLine == oldFirstLine)\\n\\t\\t\\t;\\n\\t\\telse if(firstLine >= oldFirstLine + visibleLines\\n\\t\\t\\t|| firstLine <= oldFirstLine - visibleLines)\\n\\t\\t{\\n\\t\\t\\ttextArea.chunkCache.invalidateAll();\\n\\t\\t}\\n\\t\\telse if(firstLine > oldFirstLine)\\n\\t\\t{\\n\\t\\t\\ttextArea.chunkCache.scrollDown(firstLine - oldFirstLine);\\n\\t\\t}\\n\\t\\telse if(firstLine < oldFirstLine)\\n\\t\\t{\\n\\t\\t\\ttextArea.chunkCache.scrollUp(oldFirstLine - firstLine);\\n\\t\\t}\\n\\t\\t\\t\\tnotifyScreenLineChanges();\\n\\t} \\n\\t\\tvoid invalidateScreenLineCounts()\\n\\t{\\n\\t\\tscreenLineMgr.invalidateScreenLineCounts();\\n\\t\\tfirstLine.callReset = true;\\n\\t\\tscrollLineCount.callReset = true;\\n\\t} \\n\\t\\tprivate boolean initialized;\\n\\tprivate boolean inUse;\\n\\tprivate Buffer buffer;\\n\\tprivate ScreenLineManager screenLineMgr;\\n\\tprivate JEditTextArea textArea;\\n\\tprivate BufferChangeHandler bufferChangeHandler;\\n\\tprivate int[] fvm;\\n\\tprivate int fvmcount;\\n\\tprivate int lastfvmget = -1;\\n\\t\\tprivate DisplayManager(Buffer buffer, JEditTextArea textArea)\\n\\t{\\n\\t\\tthis.buffer = buffer;\\n\\t\\tthis.screenLineMgr = new ScreenLineManager(this,buffer);\\n\\t\\tthis.textArea = textArea;\\n\\t\\tscrollLineCount = new ScrollLineCount();\\n\\t\\tfirstLine = new FirstLine();\\n\\t\\tbufferChangeHandler = new BufferChangeHandler();\\n\\t\\t\\t\\tbuffer.addBufferChangeListener(bufferChangeHandler,\\n\\t\\t\\tBuffer.HIGH_PRIORITY);\\n\\t} \\n\\t\\tprivate void dispose()\\n\\t{\\n\\t\\tbuffer.removeBufferChangeListener(bufferChangeHandler);\\n\\t} \\n\\t\\tprivate void fvmreset()\\n\\t{\\n\\t\\tlastfvmget = -1;\\n\\t\\tfvmcount = 2;\\n\\t\\tfvm[0] = 0;\\n\\t\\tfvm[1] = buffer.getLineCount();\\n\\t} \\n\\tprivate int fvmget(int line)\\n\\t{\\n\\t\\tscanCount++;\\n\\t\\tif(line < fvm[0])\\n\\t\\t\\treturn -1;\\n\\t\\tif(line >= fvm[fvmcount - 1])\\n\\t\\t\\treturn fvmcount - 1;\\n\\t\\tif(lastfvmget != -1)\\n\\t\\t{\\n\\t\\t\\tif(line >= fvm[lastfvmget])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(lastfvmget == fvmcount - 1\\n\\t\\t\\t\\t\\t|| line < fvm[lastfvmget + 1])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn lastfvmget;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint start = 0;\\n\\t\\tint end = fvmcount - 1;\\nloop:\\t\\tfor(;;)\\n\\t\\t{\\n\\t\\t\\tscannedLines++;\\n\\t\\t\\tswitch(end - start)\\n\\t\\t\\t{\\n\\t\\t\\tcase 0:\\n\\t\\t\\t\\tlastfvmget = start;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\tint value = fvm[end];\\n\\t\\t\\t\\tif(value <= line)\\n\\t\\t\\t\\t\\tlastfvmget = end;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tlastfvmget = start;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tint pivot = (end + start) / 2;\\n\\t\\t\\t\\tvalue = fvm[pivot];\\n\\t\\t\\t\\tif(value == line)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastfvmget = pivot;\\n\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(value < line)\\n\\t\\t\\t\\t\\tstart = pivot;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tend = pivot - 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn lastfvmget;\\n\\t} \\n\\tprivate void fvmput(int start, int end, int[] put)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tStringBuffer buf = new StringBuffer(\\\"{\\\");\\n\\t\\t\\tif(put != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i = 0; i < put.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(i != 0)\\n\\t\\t\\t\\t\\t\\tbuf.append(',');\\n\\t\\t\\t\\t\\tbuf.append(put[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tbuf.append(\\\"}\\\");\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"fvmput(\\\" + start + \\\",\\\"\\n\\t\\t\\t\\t+ end + \\\",\\\" + buf + \\\")\\\");\\n\\t\\t}\\n\\t\\tint putl = (put == null ? 0 : put.length);\\n\\t\\tint delta = putl - (end - start);\\n\\t\\tif(fvmcount + delta > fvm.length)\\n\\t\\t{\\n\\t\\t\\tint[] newfvm = new int[fvm.length * 2 + 1];\\n\\t\\t\\tSystem.arraycopy(fvm,0,newfvm,0,fvmcount);\\n\\t\\t\\tfvm = newfvm;\\n\\t\\t}\\n\\t\\tif(delta != 0)\\n\\t\\t{\\n\\t\\t\\tSystem.arraycopy(fvm,end,fvm,start + putl,\\n\\t\\t\\t\\tfvmcount - end);\\n\\t\\t}\\n\\t\\tif(putl != 0)\\n\\t\\t{\\n\\t\\t\\tSystem.arraycopy(put,0,fvm,start,put.length);\\n\\t\\t}\\n\\t\\tfvmcount += delta;\\n\\t\\tfvmdump();\\n\\t\\tif(fvmcount == 0)\\n\\t\\t\\tthrow new InternalError();\\n\\t} \\n\\tprivate void fvmput2(int starti, int endi, int start, int end)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"*fvmput2(\\\" + starti + \\\",\\\"\\n\\t\\t\\t\\t+ endi + \\\",\\\" + start + \\\",\\\" + end + \\\")\\\");\\n\\t\\t}\\n\\t\\tif(starti != -1 && fvm[starti] == start)\\n\\t\\t{\\n\\t\\t\\tif(endi <= fvmcount - 2 && fvm[endi + 1]\\n\\t\\t\\t\\t== end + 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti,endi + 2,null);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti,endi + 1,\\n\\t\\t\\t\\t\\tnew int[] { end + 1 });\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(endi != fvmcount - 1 && fvm[endi + 1]\\n\\t\\t\\t\\t== end + 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 2,\\n\\t\\t\\t\\t\\tnew int[] { start });\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 1,\\n\\t\\t\\t\\t\\tnew int[] { start,\\n\\t\\t\\t\\t\\tend + 1 });\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fvmdump()\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tStringBuffer buf = new StringBuffer(\\\"{\\\");\\n\\t\\t\\tfor(int i = 0; i < fvmcount; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i != 0)\\n\\t\\t\\t\\t\\tbuf.append(',');\\n\\t\\t\\t\\tbuf.append(fvm[i]);\\n\\t\\t\\t}\\n\\t\\t\\tbuf.append(\\\"}\\\");\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"fvm = \\\" + buf);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void showLineRange(int start, int end)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"showLineRange(\\\" + start\\n\\t\\t\\t\\t+ \\\",\\\" + end + \\\")\\\");\\n\\t\\t}\\n\\t\\tfor(int i = start; i <= end; i++)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(!isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tupdateScreenLineCount(i);\\n\\t\\t\\t\\tint screenLines = getScreenLineCount(i);\\n\\t\\t\\t\\tif(firstLine.physicalLine >= i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfirstLine.scrollLine += screenLines;\\n\\t\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tscrollLineCount.scrollLine += screenLines;\\n\\t\\t\\t\\tscrollLineCount.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint starti = fvmget(start);\\n\\t\\tint endi = fvmget(end);\\n\\t\\tif(starti % 2 == 0)\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 1,null);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(endi != fvmcount - 1\\n\\t\\t\\t\\t\\t&& fvm[endi + 1] == end + 1)\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi + 2,null);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\t\\tfvm[starti + 1] = end + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(starti != -1 && fvm[starti] == start)\\n\\t\\t\\t\\t\\tfvmput(starti,endi + 1,null);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\t\\tfvm[starti + 1] = start;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tfvmput2(starti,endi,start,end);\\n\\t\\t}\\n\\t\\tlastfvmget = -1;\\n\\t} \\n\\t\\tprivate void hideLineRange(int start, int end)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"hideLineRange(\\\" + start\\n\\t\\t\\t\\t+ \\\",\\\" + end + \\\")\\\");\\n\\t\\t}\\n\\t\\tint i = start;\\n\\t\\tif(!isLineVisible(i))\\n\\t\\t\\ti = getNextVisibleLine(i);\\n\\t\\twhile(i != -1 && i <= end)\\n\\t\\t{\\n\\t\\t\\tint screenLines = screenLineMgr.getScreenLineCount(i);\\n\\t\\t\\tif(i < firstLine.physicalLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.scrollLine -= screenLines;\\n\\t\\t\\t\\tfirstLine.skew = 0;\\n\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t\\tscrollLineCount.scrollLine -= screenLines;\\n\\t\\t\\tscrollLineCount.callChanged = true;\\n\\t\\t\\ti = getNextVisibleLine(i);\\n\\t\\t}\\n\\t\\tint starti = fvmget(start);\\n\\t\\tint endi = fvmget(end);\\n\\t\\tif(starti % 2 == 0)\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t\\tfvmput2(starti,endi,start,end);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(start == fvm[0])\\n\\t\\t\\t\\t\\tfvmput(starti,endi + 1,null);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\t\\tfvm[starti + 1] = start;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(end + 1 == fvm[fvmcount - 1])\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi + 2,null);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\t\\tfvm[starti + 1] = end + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 1,null);\\n\\t\\t}\\n\\t\\tlastfvmget = -1;\\n\\t\\tif(!isLineVisible(firstLine.physicalLine))\\n\\t\\t{\\n\\t\\t\\tint firstVisible = getFirstVisibleLine();\\n\\t\\t\\tif(firstLine.physicalLine < firstVisible)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.physicalLine = firstVisible;\\n\\t\\t\\t\\tfirstLine.scrollLine = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.physicalLine = getPrevVisibleLine(\\n\\t\\t\\t\\t\\tfirstLine.physicalLine);\\n\\t\\t\\t\\tfirstLine.scrollLine -=\\n\\t\\t\\t\\t\\tscreenLineMgr.getScreenLineCount(\\n\\t\\t\\t\\t\\tfirstLine.physicalLine);\\n\\t\\t\\t}\\n\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void updateScreenLineCount(int line)\\n\\t{\\n\\t\\tif(!screenLineMgr.isScreenLineCountValid(line))\\n\\t\\t{\\n\\t\\t\\tint newCount = textArea.chunkCache\\n\\t\\t\\t\\t.getLineSubregionCount(line);\\n\\t\\t\\tsetScreenLineCount(line,newCount);\\n\\t\\t}\\n\\t} \\n\\tprivate void setScreenLineCount(int line, int count)\\n\\t{\\n\\t\\tint oldCount = screenLineMgr.getScreenLineCount(line);\\n\\t\\tscreenLineMgr.setScreenLineCount(line,count);\\n\\t\\tif(count == oldCount)\\n\\t\\t\\treturn;\\n\\t\\tif(!isLineVisible(line))\\n\\t\\t\\treturn;\\n\\t\\tif(firstLine.physicalLine >= line)\\n\\t\\t{\\n\\t\\t\\tif(firstLine.physicalLine == line)\\n\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.scrollLine += (count - oldCount);\\n\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tscrollLineCount.scrollLine += (count - oldCount);\\n\\t\\tscrollLineCount.callChanged = true;\\n\\t} \\n\\t\\tstatic abstract class Anchor\\n\\t{\\n\\t\\tint physicalLine;\\n\\t\\tint scrollLine;\\n\\t\\tboolean callChanged;\\n\\t\\tboolean callReset;\\n\\t\\tabstract void reset();\\n\\t\\tabstract void changed();\\n\\t\\tpublic String toString()\\n\\t\\t{\\n\\t\\t\\treturn getClass().getName() + \\\"[\\\" + physicalLine + \\\",\\\"\\n\\t\\t\\t\\t+ scrollLine + \\\"]\\\";\\n\\t\\t}\\n\\t} \\n\\t\\tclass ScrollLineCount extends Anchor\\n\\t{\\n\\t\\t\\t\\tpublic void changed()\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"changed()\\\");\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t} \\n\\t\\t\\t\\tpublic void reset()\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"reset()\\\");\\n\\t\\t\\tphysicalLine = getFirstVisibleLine();\\n\\t\\t\\tint scrollLine = 0;\\n\\t\\t\\twhile(physicalLine != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tupdateScreenLineCount(physicalLine);\\n\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\tphysicalLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t}\\n\\t\\t\\tthis.scrollLine = scrollLine;\\n\\t\\t\\tphysicalLine = buffer.getLineCount();\\n\\t\\t\\tfirstLine.ensurePhysicalLineIsVisible();\\n\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t} \\t} \\n\\t\\tclass FirstLine extends Anchor\\n\\t{\\n\\t\\tint skew;\\n\\t\\t\\t\\tpublic void changed()\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"changed() before: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine\\n\\t\\t\\t\\t\\t+ \\\":\\\" + skew);\\n\\t\\t\\t} \\n\\t\\t\\tensurePhysicalLineIsVisible();\\n\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\tif(skew >= screenLines)\\n\\t\\t\\t\\tskew = screenLines - 1;\\n\\t\\t\\t\\t\\t\\tif(Debug.SCROLL_VERIFY)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSystem.err.println(\\\"SCROLL_VERIFY\\\");\\n\\t\\t\\t\\tint verifyScrollLine = 0;\\n\\t\\t\\t\\tfor(int i = 0; i < buffer.getLineCount(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!isLineVisible(i))\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\tif(i >= physicalLine)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tverifyScrollLine += getScreenLineCount(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(verifyScrollLine != scrollLine)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tException ex = new Exception(scrollLine + \\\":\\\" + verifyScrollLine);\\n\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,ex);\\n\\t\\t\\t\\t\\tnew org.gjt.sp.jedit.gui.BeanShellErrorDialog(null,ex);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"changed() after: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine\\n\\t\\t\\t\\t\\t+ \\\":\\\" + skew);\\n\\t\\t\\t} \\n\\t\\t\\tif(!scrollLineCount.callChanged\\n\\t\\t\\t\\t&& !scrollLineCount.callReset)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void reset()\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"reset()\\\");\\n\\t\\t\\tscrollLine = 0;\\n\\t\\t\\tint i = getFirstVisibleLine();\\n\\t\\t\\tfor(;;)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i >= physicalLine)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tupdateScreenLineCount(i);\\n\\t\\t\\t\\tscrollLine += getScreenLineCount(i);\\n\\t\\t\\t\\tint nextLine = getNextVisibleLine(i);\\n\\t\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\ti = nextLine;\\n\\t\\t\\t}\\n\\t\\t\\tphysicalLine = i;\\n\\t\\t\\tupdateScreenLineCount(i);\\n\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\tif(skew >= screenLines)\\n\\t\\t\\t\\tskew = screenLines - 1;\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid physDown(int amount, int screenAmount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physDown() start: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tskew = 0;\\n\\t\\t\\tif(!isLineVisible(physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint lastVisibleLine = getLastVisibleLine();\\n\\t\\t\\t\\tif(physicalLine > lastVisibleLine)\\n\\t\\t\\t\\t\\tphysicalLine = lastVisibleLine;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint nextPhysicalLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tamount -= (nextPhysicalLine - physicalLine);\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = nextPhysicalLine;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(;;)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint nextPhysicalLine = getNextVisibleLine(\\n\\t\\t\\t\\t\\tphysicalLine);\\n\\t\\t\\t\\tif(nextPhysicalLine == -1)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse if(nextPhysicalLine > physicalLine + amount)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t\\tamount -= (nextPhysicalLine - physicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = nextPhysicalLine;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physDown() end: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tcallChanged = true;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(screenAmount < 0)\\n\\t\\t\\t\\tscrollUp(-screenAmount);\\n\\t\\t\\telse if(screenAmount > 0)\\n\\t\\t\\t\\tscrollDown(screenAmount);\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid physUp(int amount, int screenAmount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physUp() start: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tskew = 0;\\n\\t\\t\\tif(!isLineVisible(physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint firstVisibleLine = getFirstVisibleLine();\\n\\t\\t\\t\\tif(physicalLine < firstVisibleLine)\\n\\t\\t\\t\\t\\tphysicalLine = firstVisibleLine;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint prevPhysicalLine = getPrevVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tamount -= (physicalLine - prevPhysicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(;;)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint prevPhysicalLine = getPrevVisibleLine(\\n\\t\\t\\t\\t\\tphysicalLine);\\n\\t\\t\\t\\tif(prevPhysicalLine == -1)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse if(prevPhysicalLine < physicalLine - amount)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tamount -= (physicalLine - prevPhysicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = prevPhysicalLine;\\n\\t\\t\\t\\t\\tscrollLine -= getScreenLineCount(\\n\\t\\t\\t\\t\\t\\tprevPhysicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physUp() end: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tcallChanged = true;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(screenAmount < 0)\\n\\t\\t\\t\\tscrollUp(-screenAmount);\\n\\t\\t\\telse if(screenAmount > 0)\\n\\t\\t\\t\\tscrollDown(screenAmount);\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid scrollDown(int amount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"scrollDown()\\\");\\n\\t\\t\\tensurePhysicalLineIsVisible();\\n\\t\\t\\tamount += skew;\\n\\t\\t\\tskew = 0;\\n\\t\\t\\twhile(amount > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\t\\tif(amount < screenLines)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tskew = amount;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint nextLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tboolean visible = isLineVisible(physicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = nextLine;\\n\\t\\t\\t\\t\\tif(visible)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tamount -= screenLines;\\n\\t\\t\\t\\t\\t\\tscrollLine += screenLines;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcallChanged = true;\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid scrollUp(int amount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"scrollUp()\\\");\\n\\t\\t\\tensurePhysicalLineIsVisible();\\n\\t\\t\\tif(amount <= skew)\\n\\t\\t\\t{\\n\\t\\t\\t\\tskew -= amount;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tamount -= skew;\\n\\t\\t\\t\\tskew = 0;\\n\\t\\t\\t\\twhile(amount > 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint prevLine = getPrevVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tif(prevLine == -1)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tphysicalLine = prevLine;\\n\\t\\t\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t\\tscrollLine -= screenLines;\\n\\t\\t\\t\\t\\tif(amount < screenLines)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tskew = screenLines - amount;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tamount -= screenLines;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcallChanged = true;\\n\\t\\t} \\n\\t\\t\\t\\tprivate void ensurePhysicalLineIsVisible()\\n\\t\\t{\\n\\t\\t\\tif(!isLineVisible(physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(physicalLine > getLastVisibleLine())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysicalLine = getLastVisibleLine();\\n\\t\\t\\t\\t\\tscrollLine = getScrollLineCount() - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(physicalLine < getFirstVisibleLine())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysicalLine = getFirstVisibleLine();\\n\\t\\t\\t\\t\\tscrollLine = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysicalLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\t} \\n\\tclass BufferChangeHandler extends BufferChangeAdapter\\n\\t{\\n\\t\\tboolean delayedUpdate;\\n\\t\\tboolean delayedMultilineUpdate;\\n\\t\\tint delayedUpdateStart;\\n\\t\\tint delayedUpdateEnd;\\n\\t\\t\\t\\tpublic void foldHandlerChanged(Buffer buffer)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tfvmreset();\\n\\t\\t\\tfirstLine.reset();\\n\\t\\t\\tscrollLineCount.reset();\\n\\t\\t\\tint collapseFolds = buffer.getIntegerProperty(\\n\\t\\t\\t\\t\\\"collapseFolds\\\",0);\\n\\t\\t\\tif(collapseFolds != 0)\\n\\t\\t\\t\\texpandFolds(collapseFolds);\\n\\t\\t} \\n\\t\\t\\t\\tpublic void foldLevelChanged(Buffer buffer, int start, int end)\\n\\t\\t{\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this\\n\\t\\t\\t\\t&& end != 0 && buffer.isLoaded())\\n\\t\\t\\t{\\n\\t\\t\\t\\ttextArea.invalidateLineRange(start - 1,\\n\\t\\t\\t\\t\\ttextArea.getLastPhysicalLine());\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void contentInserted(Buffer buffer, int startLine,\\n\\t\\t\\tint offset, int numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tscreenLineMgr.contentInserted(startLine,numLines);\\n\\t\\t\\tint endLine = startLine + numLines;\\n\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedMultilineUpdate = true;\\n\\t\\t\\t\\tint index = fvmget(startLine);\\n\\t\\t\\t\\tint start = index + 1;\\n\\t\\t\\t\\tfor(int i = start; i < fvmcount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvm[i] += numLines;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlastfvmget = -1;\\n\\t\\t\\t\\tfvmdump();\\n\\t\\t\\t}\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcontentInserted(firstLine,startLine,numLines);\\n\\t\\t\\t\\t\\tcontentInserted(scrollLineCount,startLine,numLines);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(delayedUpdateEnd >= startLine)\\n\\t\\t\\t\\t\\tdelayedUpdateEnd += numLines;\\n\\t\\t\\t\\tdelayedUpdate(startLine,endLine);\\n\\t\\t\\t\\t\\t\\t\\t\\tIterator iter = textArea.getSelectionIterator();\\n\\t\\t\\t\\twhile(iter.hasNext())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection s = (Selection)iter.next();\\n\\t\\t\\t\\t\\tif(s.contentInserted(buffer,startLine,offset,\\n\\t\\t\\t\\t\\t\\tnumLines,length))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdelayedUpdate(s.startLine,s.endLine);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tint caret = textArea.getCaretPosition();\\n\\t\\t\\t\\tif(caret >= offset)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.ELECTRIC_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(\\n\\t\\t\\t\\t\\t\\tcaret + length,scrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.NORMAL_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(\\n\\t\\t\\t\\t\\t\\tcaret,scrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void preContentRemoved(Buffer buffer, int startLine,\\n\\t\\t\\tint offset, int numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tdelayedMultilineUpdate = true;\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tpreContentRemoved(firstLine,startLine,numLines);\\n\\t\\t\\t\\t\\tpreContentRemoved(scrollLineCount,startLine,numLines);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(delayedUpdateEnd >= startLine)\\n\\t\\t\\t\\t\\tdelayedUpdateEnd -= numLines;\\n\\t\\t\\t\\tdelayedUpdate(startLine,startLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\t}\\n\\t\\t\\tif(numLines == 0)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tscreenLineMgr.contentRemoved(startLine,numLines);\\n\\t\\t\\tint endLine = startLine + numLines;\\n\\t\\t\\tint starti = fvmget(startLine);\\n\\t\\t\\tint endi = fvmget(endLine);\\n\\t\\t\\tif(Math.abs(starti % 2) == Math.abs(endi % 2))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(endi - starti == fvmcount)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfvmreset();\\n\\t\\t\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\t\\t\\tstarti = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi + 1,null);\\n\\t\\t\\t\\t\\tstarti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(starti != -1 && fvm[starti] == startLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(endi - starti == fvmcount - 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfvmreset();\\n\\t\\t\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\t\\t\\tstarti = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tfvmput(starti,endi + 1,null);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\tfvm[starti + 1] = startLine;\\n\\t\\t\\t\\tstarti += 2;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = starti; i < fvmcount; i++)\\n\\t\\t\\t\\tfvm[i] -= numLines;\\n\\t\\t\\tif(firstLine.physicalLine\\n\\t\\t\\t\\t> getLastVisibleLine()\\n\\t\\t\\t\\t|| firstLine.physicalLine\\n\\t\\t\\t\\t< getFirstVisibleLine())\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\telse if(!isLineVisible(\\n\\t\\t\\t\\tfirstLine.physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.physicalLine =\\n\\t\\t\\t\\t\\tgetNextVisibleLine(\\n\\t\\t\\t\\t\\tfirstLine.physicalLine);\\n\\t\\t\\t}\\n\\t\\t\\tlastfvmget = -1;\\n\\t\\t\\tfvmdump();\\n\\t\\t} \\n\\t\\t\\t\\tpublic void contentRemoved(Buffer buffer, int startLine,\\n\\t\\t\\tint start, int numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tIterator iter = textArea.getSelectionIterator();\\n\\t\\t\\t\\twhile(iter.hasNext())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection s = (Selection)iter.next();\\n\\t\\t\\t\\t\\tif(s.contentRemoved(buffer,startLine,\\n\\t\\t\\t\\t\\t\\tstart,numLines,length))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdelayedUpdate(s.startLine,s.endLine);\\n\\t\\t\\t\\t\\t\\tif(s.start == s.end)\\n\\t\\t\\t\\t\\t\\t\\titer.remove();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tint caret = textArea.getCaretPosition();\\n\\t\\t\\t\\tif(caret >= start + length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.ELECTRIC_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(\\n\\t\\t\\t\\t\\t\\tcaret - length,\\n\\t\\t\\t\\t\\t\\tscrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(caret >= start)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.ELECTRIC_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(\\n\\t\\t\\t\\t\\t\\tstart,scrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.NORMAL_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(caret,scrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tpublic void transactionComplete(Buffer buffer)\\n\\t\\t{\\n\\t\\t\\tif(textArea.getDisplayManager() != DisplayManager.this)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedUpdate = false;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(delayedUpdate)\\n\\t\\t\\t\\tdoDelayedUpdate();\\n\\t\\t\\ttextArea._finishCaretUpdate();\\n\\t\\t\\tdelayedUpdate = false;\\n\\t\\t\\t\\t\\t\\tif(Debug.SCROLL_VERIFY)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint scrollLineCount = 0;\\n\\t\\t\\t\\tint line = delayedUpdateStart;\\n\\t\\t\\t\\tif(!isLineVisible(line))\\n\\t\\t\\t\\t\\tline = getNextVisibleLine(line);\\n\\t\\t\\t\\tSystem.err.println(delayedUpdateStart + \\\":\\\" + delayedUpdateEnd + \\\":\\\" + textArea.getLineCount());\\n\\t\\t\\t\\twhile(line != -1 && line <= delayedUpdateEnd)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscrollLineCount += getScreenLineCount(line);\\n\\t\\t\\t\\t\\tline = getNextVisibleLine(line);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(scrollLineCount != getScrollLineCount())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tthrow new InternalError(scrollLineCount\\n\\t\\t\\t\\t\\t\\t+ \\\" != \\\"\\n\\t\\t\\t\\t\\t\\t+ getScrollLineCount());\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\t\\t} \\n\\t\\t\\t\\tprivate void doDelayedUpdate()\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tint _firstLine = textArea.getFirstPhysicalLine();\\n\\t\\t\\tint _lastLine = textArea.getLastPhysicalLine();\\n\\t\\t\\tint line = delayedUpdateStart;\\n\\t\\t\\tif(!isLineVisible(line))\\n\\t\\t\\t\\tline = getNextVisibleLine(line);\\n\\t\\t\\twhile(line != -1 && line <= delayedUpdateEnd)\\n\\t\\t\\t{\\n\\t\\t\\t\\tupdateScreenLineCount(line);\\n\\t\\t\\t\\tline = getNextVisibleLine(line);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnotifyScreenLineChanges();\\n\\t\\t\\tif(delayedMultilineUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttextArea.invalidateScreenLineRange(\\n\\t\\t\\t\\t\\ttextArea.chunkCache\\n\\t\\t\\t\\t\\t.getScreenLineOfOffset(\\n\\t\\t\\t\\t\\tdelayedUpdateStart,0),\\n\\t\\t\\t\\t\\ttextArea.getVisibleLines());\\n\\t\\t\\t\\tdelayedMultilineUpdate = false;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\ttextArea.invalidateLineRange(\\n\\t\\t\\t\\t\\tdelayedUpdateStart,\\n\\t\\t\\t\\t\\tdelayedUpdateEnd);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tint visibleLines = textArea.getVisibleLines();\\n\\t\\t\\tif(visibleLines != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttextArea.chunkCache.getLineInfo(\\n\\t\\t\\t\\t\\tvisibleLines - 1);\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.getFoldLevel(delayedUpdateEnd);\\n\\t\\t} \\n\\t\\t\\t\\tprivate void contentInserted(Anchor anchor, int startLine,\\n\\t\\t\\tint numLines)\\n\\t\\t{\\n\\t\\t\\tif(anchor.physicalLine >= startLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(anchor.physicalLine != startLine)\\n\\t\\t\\t\\t\\tanchor.physicalLine += numLines;\\n\\t\\t\\t\\tanchor.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void preContentRemoved(Anchor anchor, int startLine,\\n\\t\\t\\tint numLines)\\n\\t\\t{\\n\\t\\t\\tif(anchor.physicalLine >= startLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(anchor.physicalLine == startLine)\\n\\t\\t\\t\\t\\tanchor.callChanged = true;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint end = Math.min(startLine + numLines,\\n\\t\\t\\t\\t\\t\\tanchor.physicalLine);\\n\\t\\t\\t\\t\\tfor(int i = startLine; i < end; i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(isLineVisible(i))\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tanchor.scrollLine -=\\n\\t\\t\\t\\t\\t\\t\\t\\tscreenLineMgr\\n\\t\\t\\t\\t\\t\\t\\t\\t.getScreenLineCount(i);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tanchor.physicalLine -= (end - startLine);\\n\\t\\t\\t\\t\\tanchor.callChanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void delayedUpdate(int startLine, int endLine)\\n\\t\\t{\\n\\t\\t\\ttextArea.chunkCache.invalidateChunksFromPhys(startLine);\\n\\t\\t\\tif(!delayedUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedUpdateStart = startLine;\\n\\t\\t\\t\\tdelayedUpdateEnd = endLine;\\n\\t\\t\\t\\tdelayedUpdate = true;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedUpdateStart = Math.min(\\n\\t\\t\\t\\t\\tdelayedUpdateStart,\\n\\t\\t\\t\\t\\tstartLine);\\n\\t\\t\\t\\tdelayedUpdateEnd = Math.max(\\n\\t\\t\\t\\t\\tdelayedUpdateEnd,\\n\\t\\t\\t\\t\\tendLine);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tprivate boolean caretAutoScroll()\\n\\t\\t{\\n\\t\\t\\tView view = textArea.getView();\\n\\t\\t\\treturn view == jEdit.getActiveView()\\n\\t\\t\\t\\t&& view.getTextArea() == textArea;\\n\\t\\t} \\t} }\""
        },
        {
            "content": "From reviewing the source code of `DisplayManager.java`, here are some key observations:\n\n1. **Responsibility**:  \n   The `DisplayManager` class is primarily responsible for managing how text lines are displayed in a `JEditTextArea`. It handles functionalities such as:\n   - Managing visible and hidden line ranges (folding logic).\n   - Tracking scroll positions and screen-line calculations.\n   - Coordinating with other components like `BufferChangeHandler`, `FirstLine`, and `ScrollLineCount`.\n\n2. **Dependencies**:\n   - **JEditTextArea**: This is tightly coupled with the display logic, as it represents the UI component where the text is rendered.\n   - **FirstLine & ScrollLineCount**: These classes manage scrolling behavior and visible lines.\n   - **ScreenLineManager**: Handles screen-line calculations.\n   - **BufferChangeHandler**: Listens to buffer changes and updates the display accordingly.\n\n3. **Interaction Patterns**:\n   - Folding/Unfolding: Managed through methods like `collapseFold()`, `expandFold()`, and interactions with `BufferChangeHandler`.\n   - Scrolling: Handled by `FirstLine` and `ScrollLineCount` which update scroll positions based on user interaction or content changes.\n   - Line Visibility: Methods like `isLineVisible()` determine if a specific line should be shown or hidden.\n\n### Impact Analysis\n\nBased on this analysis, the following entities are likely affected by changes in `DisplayManager.java`:\n\n- **JEditTextArea.java**: Since `DisplayManager` directly interacts with it for rendering and scrolling.\n- **FirstLine.java** and **ScrollLineCount.java**: These are instantiated and used internally by `DisplayManager` for tracking scroll states.\n- **BufferChangeHandler.java**: Although removed in newer versions, it was tightly integrated with buffer change events tied to `DisplayManager`.\n- **ScreenLineManager.java**: Involved in screen-line calculations that affect the display state.\n\n### Next Steps\n\nTo validate these relationships and identify further dependencies, I will perform additional checks:\n\n1. Call `get_coupling_dependencies` between `DisplayManager.java` and `JEditTextArea.java`.\n2. Call `get_coupling_dependencies` between `DisplayManager.java` and `ScreenLineManager.java`.\n\nThis will help confirm direct coupling relationships with these critical components.\n\nLet me start with the first check:\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_5465111367d14317bc394c",
                    "function": {
                        "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"JEditTextArea.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"Class Member Variable Usage Variable (CMAUA): Coupling found in method getDisplayManager, at line: 61. Instance of JEditTextArea member variable textArea is used directly.  Coupling found in method getDisplayManager, at line: 69. Instance of JEditTextArea member variable textArea is used directly.  Coupling found in method textAreaDisposed, at line: 100. Instance of JEditTextArea member variable textArea is used directly.  Coupling found in method caretAutoScroll, at line: 2023. Instance of JEditTextArea member variable textArea is used directly.  \", \"Function Parameter Usage Variable (FPUA): Coupling found in method getDisplayManager, at line: 61. Instance of JEditTextArea parameter textArea is used directly.  Coupling found in method getDisplayManager, at line: 69. Instance of JEditTextArea parameter textArea is used directly.  Coupling found in method textAreaDisposed, at line: 100. Instance of JEditTextArea parameter textArea is used directly.  \", \"StaticVariableInvoking(SAI): Static Variable Invoking found: contentInserted invokes static variable ELECTRIC_SCROLL,  Static Variable Invoking found: contentInserted invokes static variable NO_SCROLL,  Static Variable Invoking found: contentInserted invokes static variable NORMAL_SCROLL,  Static Variable Invoking found: contentInserted invokes static variable NO_SCROLL,  Static Variable Invoking found: contentRemoved invokes static variable ELECTRIC_SCROLL,  Static Variable Invoking found: contentRemoved invokes static variable NO_SCROLL,  Static Variable Invoking found: contentRemoved invokes static variable ELECTRIC_SCROLL,  Static Variable Invoking found: contentRemoved invokes static variable NO_SCROLL,  Static Variable Invoking found: contentRemoved invokes static variable NORMAL_SCROLL,  Static Variable Invoking found: contentRemoved invokes static variable NO_SCROLL,  \", \"Class Member Variable Invoking Variable (CMAIA): Coupling found in method updateWrapSettings, at line: 597. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable maxLineLen.  Coupling found in method updateWrapSettings, at line: 603. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable charWidth.  Coupling found in method updateWrapSettings, at line: 614. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable maxLineLen.  Coupling found in method setFirstLine, at line: 672. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable chunkCache.  Coupling found in method setFirstLine, at line: 677. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable chunkCache.  Coupling found in method setFirstLine, at line: 682. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable chunkCache.  Coupling found in method setFirstLine, at line: 687. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable chunkCache.  Coupling found in method setFirstPhysicalLine, at line: 727. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable chunkCache.  Coupling found in method setFirstPhysicalLine, at line: 731. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable chunkCache.  Coupling found in method setFirstPhysicalLine, at line: 735. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable chunkCache.  Coupling found in method updateScreenLineCount, at line: 1139. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable chunkCache.  Coupling found in method doDelayedUpdate, at line: 1920. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable chunkCache.  Coupling found in method doDelayedUpdate, at line: 1937. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable chunkCache.  Coupling found in method delayedUpdate, at line: 1997. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable chunkCache.  \", \"ConstructorInvoking(CMAIM): Coupling found in method collapseFold, at line: 306. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method foldStructureChanged.  Coupling found in method expandFold, at line: 431. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method foldStructureChanged.  Coupling found in method expandAllFolds, at line: 445. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method foldStructureChanged.  Coupling found in method expandFolds, at line: 500. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method foldStructureChanged.  Coupling found in method narrow, at line: 535. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method foldStructureChanged.  Coupling found in method init, at line: 576. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method updateScrollBars.  Coupling found in method init, at line: 577. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method recalculateLastPhysicalLine.  Coupling found in method updateWrapSettings, at line: 602. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getPainter.  Coupling found in method updateWrapSettings, at line: 619. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getPainter.  Coupling found in method notifyScreenLineChanges, at line: 643. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getDisplayManager.  Coupling found in method setFirstLine, at line: 667. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getVisibleLines.  Coupling found in method setFirstPhysicalLine, at line: 696. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getFirstLine.  Coupling found in method setFirstPhysicalLine, at line: 719. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getFirstLine.  Coupling found in method setFirstPhysicalLine, at line: 720. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getVisibleLines.  Coupling found in method changed, at line: 1210. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method updateScrollBars.  Coupling found in method changed, at line: 1211. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method recalculateLastPhysicalLine.  Coupling found in method reset, at line: 1234. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method recalculateLastPhysicalLine.  Coupling found in method reset, at line: 1235. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method updateScrollBars.  Coupling found in method changed, at line: 1296. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method updateScrollBars.  Coupling found in method changed, at line: 1297. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method recalculateLastPhysicalLine.  Coupling found in method reset, at line: 1338. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method updateScrollBars.  Coupling found in method foldLevelChanged, at line: 1603. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getDisplayManager.  Coupling found in method foldLevelChanged, at line: 1606. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method invalidateLineRange.  Coupling found in method foldLevelChanged, at line: 1607. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getLastPhysicalLine.  Coupling found in method contentInserted, at line: 1639. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getDisplayManager.  Coupling found in method contentInserted, at line: 1652. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getSelectionIterator.  Coupling found in method contentInserted, at line: 1664. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getCaretPosition.  Coupling found in method contentInserted, at line: 1670. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method moveCaretPosition.  Coupling found in method contentInserted, at line: 1678. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method moveCaretPosition.  Coupling found in method preContentRemoved, at line: 1698. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getDisplayManager.  Coupling found in method contentRemoved, at line: 1807. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getDisplayManager.  Coupling found in method contentRemoved, at line: 1810. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getSelectionIterator.  Coupling found in method contentRemoved, at line: 1824. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getCaretPosition.  Coupling found in method contentRemoved, at line: 1831. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method moveCaretPosition.  Coupling found in method contentRemoved, at line: 1840. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method moveCaretPosition.  Coupling found in method contentRemoved, at line: 1848. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method moveCaretPosition.  Coupling found in method transactionComplete, at line: 1857. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getDisplayManager.  Coupling found in method transactionComplete, at line: 1866. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method _finishCaretUpdate.  Coupling found in method transactionComplete, at line: 1877. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getLineCount.  Coupling found in method doDelayedUpdate, at line: 1899. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getFirstPhysicalLine.  Coupling found in method doDelayedUpdate, at line: 1900. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getLastPhysicalLine.  Coupling found in method doDelayedUpdate, at line: 1919. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method invalidateScreenLineRange.  Coupling found in method doDelayedUpdate, at line: 1923. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getVisibleLines.  Coupling found in method doDelayedUpdate, at line: 1928. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method invalidateLineRange.  Coupling found in method doDelayedUpdate, at line: 1934. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getVisibleLines.  Coupling found in method caretAutoScroll, at line: 2021. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getView.\"]"
        },
        {
            "content": "The coupling analysis between `DisplayManager.java` and `JEditTextArea.java` reveals a **strong direct dependency**. Here's a breakdown of the findings:\n\n### Coupling Types Identified:\n1. **Class Member Variable Usage (CMAUA)**:\n   - The `textArea` member variable (of type `JEditTextArea`) is used directly in several methods, such as `getDisplayManager()`, `textAreaDisposed()`, and `caretAutoScroll()`.\n\n2. **Function Parameter Usage (FPUA)**:\n   - The `textArea` parameter passed to methods like `getDisplayManager()` is also directly used.\n\n3. **Static Variable Invoking (SAI)**:\n   - Static fields from `JEditTextArea` such as `ELECTRIC_SCROLL`, `NORMAL_SCROLL`, and `NO_SCROLL` are referenced.\n\n4. **Class Member Access Invoking (CMAIA)**:\n   - Several methods access member variables of `JEditTextArea`, such as `maxLineLen`, `charWidth`, and `chunkCache`.\n\n5. **Method Invoking (CMAIM)**:\n   - Multiple methods in `JEditTextArea` are called, including:\n     - `foldStructureChanged()`\n     - `updateScrollBars()`\n     - `getPainter()`\n     - `getVisibleLines()`\n     - `getFirstLine()`\n     - `getCaretPosition()`\n     - `moveCaretPosition()`\n     - `_finishCaretUpdate()`\n     - `invalidateLineRange()`\n\n### Implication:\nThis level of coupling means that any change in `DisplayManager.java` can significantly impact `JEditTextArea.java`, especially its rendering, scrolling, and caret behavior. Therefore, **synchronizing changes with `JEditTextArea.java` is critical**.\n\n---\n\n### Next Step:\nLet\u2019s analyze coupling dependencies between `DisplayManager.java` and `ScreenLineManager.java`, another key class used internally for screen-line calculations.\n\nI'll call:\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_e3610ba9d24e45a7a9c5f1",
                    "function": {
                        "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"ScreenLineManager.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"ConstructorInvoking(CMI): Construction Method Invoking found: new ScreenLineManager(this, buffer),  \", \"ConstructorInvoking(CMAIM): Coupling found in method getScreenLineCount, at line: 219. Instance of ScreenLineManager member variable screenLineMgr is used to call ScreenLineManager's method isScreenLineCountValid.  Coupling found in method getScreenLineCount, at line: 222. Instance of ScreenLineManager member variable screenLineMgr is used to call ScreenLineManager's method getScreenLineCount.  Coupling found in method bufferLoaded, at line: 545. Instance of ScreenLineManager member variable screenLineMgr is used to call ScreenLineManager's method reset.  Coupling found in method invalidateScreenLineCounts, at line: 745. Instance of ScreenLineManager member variable screenLineMgr is used to call ScreenLineManager's method invalidateScreenLineCounts.  Coupling found in method hideLineRange, at line: 1063. Instance of ScreenLineManager member variable screenLineMgr is used to call ScreenLineManager's method getScreenLineCount.  Coupling found in method hideLineRange, at line: 1127. Instance of ScreenLineManager member variable screenLineMgr is used to call ScreenLineManager's method getScreenLineCount.  Coupling found in method updateScreenLineCount, at line: 1137. Instance of ScreenLineManager member variable screenLineMgr is used to call ScreenLineManager's method isScreenLineCountValid.  Coupling found in method setScreenLineCount, at line: 1154. Instance of ScreenLineManager member variable screenLineMgr is used to call ScreenLineManager's method getScreenLineCount.  Coupling found in method setScreenLineCount, at line: 1159. Instance of ScreenLineManager member variable screenLineMgr is used to call ScreenLineManager's method setScreenLineCount.  Coupling found in method contentInserted, at line: 1618. Instance of ScreenLineManager member variable screenLineMgr is used to call ScreenLineManager's method contentInserted.  Coupling found in method preContentRemoved, at line: 1719. Instance of ScreenLineManager member variable screenLineMgr is used to call ScreenLineManager's method contentRemoved.  Coupling found in method preContentRemoved, at line: 1984. Instance of ScreenLineManager member variable screenLineMgr is used to call ScreenLineManager's method getScreenLineCount.\"]"
        },
        {
            "role": "user",
            "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
        },
        {
            "content": "Title: Diagnosis of starting entity `DisplayManager`\n\nChange set: [JEditTextArea, FirstLine, ScrollLineCount, ScreenLineManager, BufferChangeHandler, ChunkCache, HelpIndex, HelpTOCPanel, View, BufferIORequest, RingListModel, OffsetManager, PosBottomHalf, PositionManager, PasteFromListDialog, ListHandler, KeyHandler, FontSelector, FontSelectorDialog, TextAreaOptionPane, ActionHandler, BeanShell, TextAreaPainter, EditPane, MouseHandler, Anchor, RangeMap]\n\nDetails:\n1. **JEditTextArea**: DisplayManager heavily uses JEditTextArea for rendering, scrolling, caret positioning, and fold updates. Direct coupling through method calls and member access makes synchronization essential.\n2. **FirstLine**: Manages scroll positions and is directly used by DisplayManager to track visible lines. Co-change history and internal instantiation confirm its dependency.\n3. **ScrollLineCount**: Tightly involved in scroll bar updates and line counting. Coupled via internal usage and co-change data.\n4. **ScreenLineManager**: Responsible for screen-line calculations which are crucial for display logic. Created internally and invoked throughout the code.\n5. **BufferChangeHandler**: Handles buffer change events that affect display state. Instantiated and used directly by DisplayManager.\n6. **ChunkCache**: Used in line rendering and caching mechanisms. DisplayManager references it multiple times for visual updates.\n7. **HelpIndex**: Appears in co-change history with moderate support/confidence, indicating historical synchronized modifications.\n8. **HelpTOCPanel**: Frequent alongside DisplayManager historically; likely tied to UI rendering or help-related views.\n9. **View**: Central UI component in jEdit; changes in display logic may affect how the view renders text areas.\n10. **BufferIORequest**: Related to buffer input/output operations that can influence display behavior during file loading/editing.\n11. **RingListModel**: Possibly used in list-based UI components tied to display settings or selections.\n12. **OffsetManager**: Likely involved in tracking offsets within the text area; impacts display logic.\n13. **PosBottomHalf**: May be related to vertical positioning or viewport management.\n14. **PositionManager**: Could assist in tracking cursor or selection positions; relevant to display state.\n15. **PasteFromListDialog**: Possibly interacts with display when pasting from history or lists.\n16. **ListHandler**: May coordinate with display logic for list-like content presentation.\n17. **KeyHandler**: Involved in keyboard interactions that could affect display (e.g., scrolling, navigation).\n18. **FontSelector**: Affects rendering visuals; changes in display settings often require font adjustments.\n19. **FontSelectorDialog**: Tied to user configuration affecting display appearance.\n20. **TextAreaOptionPane**: Part of configuration UI for text area properties; affects display settings.\n21. **ActionHandler**: Coordinates actions that may impact display behavior (e.g., folds, scrolls).\n22. **BeanShell**: Potentially involved in scripting UI behaviors or dynamic display changes.\n23. **TextAreaPainter**: Directly responsible for painting the text area; tightly coupled with display logic.\n24. **EditPane**: Hosts the text area and display settings; changes in display may require layout updates.\n25. **MouseHandler**: Manages mouse events influencing display (selections, clicks, drags).\n26. **Anchor**: Internal class extended by FirstLine and ScrollLineCount; plays a role in scroll anchoring.\n27. **RangeMap**: Possibly manages line ranges or mappings relevant to visibility or folding.\n\nAdditional entities like **Anchor**, **RangeMap**, and others listed above appear in the co-change results with varying levels of confidence/support, indicating historical correlation with DisplayManager changes. Given the nature of CIA and recall prioritization, these should be included as potential candidates due to their semantic or historical ties.",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        }
    ],
    "interaction_records": {
        "step_histories": [
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4"
                ],
                "response_message": "m5"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6"
                ],
                "response_message": "m7"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8"
                ],
                "response_message": "m9"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10"
                ],
                "response_message": "m11"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12"
                ],
                "response_message": "m13"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14"
                ],
                "response_message": "m15"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14",
                    "m15",
                    "m16",
                    "m17"
                ],
                "response_message": "m18"
            }
        ],
        "mid_to_message": {
            "m1": {
                "role": "system",
                "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
            },
            "m2": {
                "role": "user",
                "content": "The project you need to analyze is `jEdit`, a well-known Java open source project. The starting entity you need to deal with is DisplayManager.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
            },
            "m3": {
                "content": "",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_b3f922d9b9ae4c76a8b330",
                        "function": {
                            "arguments": "{\"entity\": \"DisplayManager.java\"}",
                            "name": "get_co_change_relationship"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m4": {
                "name": "get_co_change_relationship",
                "role": "tool",
                "content": "[[\"FirstLine\", \"6\", \"0.375\"], [\"ScrollLineCount\", \"6\", \"0.375\"], [\"ChunkCache\", \"6\", \"0.375\"], [\"HelpIndex\", \"2\", \"0.125\"], [\"HelpTOCPanel\", \"2\", \"0.125\"], [\"View\", \"2\", \"0.125\"], [\"BufferChangeHandler\", \"9\", \"0.5625\"], [\"BufferIORequest\", \"4\", \"0.25\"], [\"RingListModel\", \"2\", \"0.125\"], [\"OffsetManager\", \"2\", \"0.125\"], [\"PosBottomHalf\", \"2\", \"0.125\"], [\"PositionManager\", \"2\", \"0.125\"], [\"PasteFromListDialog\", \"2\", \"0.125\"], [\"ListHandler\", \"2\", \"0.125\"], [\"KeyHandler\", \"2\", \"0.125\"], [\"FontSelector\", \"2\", \"0.125\"], [\"FontSelectorDialog\", \"2\", \"0.125\"], [\"TextAreaOptionPane\", \"2\", \"0.125\"], [\"ActionHandler\", \"2\", \"0.125\"], [\"JEditTextArea\", \"3\", \"0.1875\"], [\"TextAreaPainter\", \"2\", \"0.125\"], [\"EditPane\", \"2\", \"0.125\"], [\"BeanShell\", \"2\", \"0.125\"], [\"MouseHandler\", \"1\", \"0.0625\"], [\"Anchor\", \"1\", \"0.0625\"], [\"RangeMap\", \"1\", \"0.0625\"]]"
            },
            "m5": {
                "content": "From the co-change relationship analysis, we see that several files are frequently modified alongside `DisplayManager.java`. These relationships indicate potential dependencies or synchronized changes that could be impacted by modifications in `DisplayManager.java`.\n\nHere\u2019s how we can interpret some of the key results:\n- **BufferChangeHandler (support: 9, confidence: 0.5625)** and **FirstLine, ScrollLineCount, ChunkCache (support: 6, confidence: 0.375 each)** show significant co-change patterns.\n- Other files such as **JEditTextArea (support: 3, confidence: 0.1875)** and various UI/dialog-related components have lower but notable co-change associations.\n\nTo better understand which entities should be prioritized for synchronization, let's explore further. I'll examine the coupling dependencies between `DisplayManager.java` and some of its top co-changed files, particularly focusing on **BufferChangeHandler.java** and **FirstLine.java**, as they have high support and confidence values.\n\nI will proceed with calling the `get_coupling_dependencies` function for these pairs. \n\n1. Call `get_coupling_dependencies` for `DisplayManager.java` and `BufferChangeHandler.java`.\n2. Call `get_coupling_dependencies` for `DisplayManager.java` and `FirstLine.java`.\n\nThis will help us determine if there are direct dependencies between them. \n\nLet me start with the first step:\n\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_14ab9619ce58497789762b",
                        "function": {
                            "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"BufferChangeHandler.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m6": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"BufferChangeHandler has been removed from the project due to project version iteration\"]"
            },
            "m7": {
                "content": "It appears that `BufferChangeHandler.java` has been removed from the project due to version iterations, which explains the coupling dependency result. This means it is no longer actively dependent on `DisplayManager.java`.\n\nLet\u2019s proceed with the second step and analyze the coupling dependencies between `DisplayManager.java` and `FirstLine.java`. This will help us determine if there is any direct dependency with this co-changed file.\n\nI'll call the `get_coupling_dependencies` function for these two files:\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_7a7ab4b21f294f8eae61c5",
                        "function": {
                            "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"FirstLine.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m8": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"FirstLine has been removed from the project due to project version iteration\"]"
            },
            "m9": {
                "content": "Similar to `BufferChangeHandler.java`, the file `FirstLine.java` has also been removed from the project due to version iterations. This indicates that the co-change relationships we observed are based on historical modifications, and some of the related files may no longer exist in the current codebase.\n\nTo further analyze the impact of changes to `DisplayManager.java`, let's explore its direct dependencies by examining its call graph. This will help us identify which entities are currently being used or referenced by `DisplayManager.java`.\n\nI'll proceed by calling the `get_call_graph` function for `DisplayManager.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_7d0c535f579f4708bf54d4",
                        "function": {
                            "arguments": "{\"entity\": \"DisplayManager.java\"}",
                            "name": "get_call_graph"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m10": {
                "role": "tool",
                "name": "get_call_graph",
                "content": "[\"Log\", \"\", \"\"]"
            },
            "m11": {
                "content": "The call graph analysis for `DisplayManager.java` returned minimal information, showing only a reference to `Log`, which likely corresponds to logging functionality. This doesn't provide substantial insight into the dependencies or usage of `DisplayManager.java`.\n\nTo gain a deeper understanding, I will examine the source code of `DisplayManager.java` directly. This will allow us to analyze its structure, identify key components, and determine potential relationships with other entities.\n\nI'll proceed by calling the `get_origin_code` function to retrieve the source code of `DisplayManager.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_882ebabe5b444d74ae9b15",
                        "function": {
                            "arguments": "{\"entity\": \"DisplayManager.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m12": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package org.gjt.sp.jedit.textarea;\\nimport java.awt.Toolkit;\\nimport java.util.*;\\nimport org.gjt.sp.jedit.buffer.*;\\nimport org.gjt.sp.jedit.*;\\nimport org.gjt.sp.util.Log;\\npublic class DisplayManager\\n{\\n\\tpublic static long scanCount, scannedLines;\\n\\t\\tstatic DisplayManager getDisplayManager(Buffer buffer,\\n\\t\\tJEditTextArea textArea)\\n\\t{\\n\\t\\tList l = (List)bufferMap.get(buffer);\\n\\t\\tDisplayManager dmgr;\\n\\t\\tif(l == null)\\n\\t\\t{\\n\\t\\t\\tl = new LinkedList();\\n\\t\\t\\tbufferMap.put(buffer,l);\\n\\t\\t}\\n\\t\\tIterator liter = l.iterator();\\n\\t\\twhile(liter.hasNext())\\n\\t\\t{\\n\\t\\t\\tdmgr = (DisplayManager)liter.next();\\n\\t\\t\\tif(!dmgr.inUse && dmgr.textArea == textArea)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdmgr.inUse = true;\\n\\t\\t\\t\\treturn dmgr;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tdmgr = new DisplayManager(buffer,textArea);\\n\\t\\tdmgr.inUse = true;\\n\\t\\tl.add(dmgr);\\n\\t\\treturn dmgr;\\n\\t} \\n\\t\\tstatic void releaseDisplayManager(DisplayManager dmgr)\\n\\t{\\n\\t\\tdmgr.inUse = false;\\n\\t} \\n\\t\\tpublic static void bufferClosed(Buffer buffer)\\n\\t{\\n\\t\\tbufferMap.remove(buffer);\\n\\t} \\n\\t\\tstatic void textAreaDisposed(JEditTextArea textArea)\\n\\t{\\n\\t\\tIterator biter = bufferMap.values().iterator();\\n\\t\\twhile(biter.hasNext())\\n\\t\\t{\\n\\t\\t\\tList l = (List)biter.next();\\n\\t\\t\\tIterator liter = l.iterator();\\n\\t\\t\\twhile(liter.hasNext())\\n\\t\\t\\t{\\n\\t\\t\\t\\tDisplayManager dmgr = (DisplayManager)\\n\\t\\t\\t\\t\\tliter.next();\\n\\t\\t\\t\\tif(dmgr.textArea == textArea)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdmgr.dispose();\\n\\t\\t\\t\\t\\tliter.remove();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tprivate static Map bufferMap = new HashMap();\\n\\tpublic final boolean isLineVisible(int line)\\n\\t{\\n\\t\\treturn fvmget(line) % 2 == 0;\\n\\t} \\n\\tpublic int getFirstVisibleLine()\\n\\t{\\n\\t\\treturn fvm[0];\\n\\t} \\n\\tpublic int getLastVisibleLine()\\n\\t{\\n\\t\\treturn fvm[fvmcount - 1] - 1;\\n\\t} \\n\\tpublic int getNextVisibleLine(int line)\\n\\t{\\n\\t\\tif(line < 0 || line >= buffer.getLineCount())\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(line);\\n\\t\\tint index = fvmget(line);\\n\\t\\tif(index % 2 != 0)\\n\\t\\t{\\n\\t\\t\\tif(fvmcount == index + 1)\\n\\t\\t\\t\\treturn - 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn fvm[index + 1];\\n\\t\\t}\\n\\t\\telse if(line == fvm[index + 1] - 1)\\n\\t\\t{\\n\\t\\t\\tif(fvmcount == index + 2)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn fvm[index + 2];\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn line + 1;\\n\\t} \\n\\tpublic int getPrevVisibleLine(int line)\\n\\t{\\n\\t\\tif(line < 0 || line >= buffer.getLineCount())\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(line);\\n\\t\\tint index = fvmget(line);\\n\\t\\tif(index == -1)\\n\\t\\t\\treturn -1;\\n\\t\\telse if(index % 2 == 1)\\n\\t\\t{\\n\\t\\t\\treturn fvm[index] - 1;\\n\\t\\t}\\n\\t\\telse if(line == fvm[index])\\n\\t\\t{\\n\\t\\t\\tif(index == 0)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn fvm[index - 1] - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn line - 1;\\n\\t} \\n\\t\\tpublic final int getScreenLineCount(int line)\\n\\t{\\n\\t\\tif(!screenLineMgr.isScreenLineCountValid(line))\\n\\t\\t\\tthrow new RuntimeException(\\\"Invalid screen line count: \\\" + line);\\n\\t\\treturn screenLineMgr.getScreenLineCount(line);\\n\\t} \\n\\t\\tpublic final int getScrollLineCount()\\n\\t{\\n\\t\\treturn scrollLineCount.scrollLine;\\n\\t} \\n\\tpublic void collapseFold(int line)\\n\\t{\\n\\t\\tint lineCount = buffer.getLineCount();\\n\\t\\tint start = 0;\\n\\t\\tint end = lineCount - 1;\\n\\t\\t\\t\\t\\t\\tif(line != 0\\n\\t\\t\\t&& line != buffer.getLineCount() - 1\\n\\t\\t\\t&& buffer.isFoldStart(line)\\n\\t\\t\\t&& !isLineVisible(line + 1))\\n\\t\\t{\\n\\t\\t\\tline--;\\n\\t\\t}\\n\\t\\tint initialFoldLevel = buffer.getFoldLevel(line);\\n\\t\\t\\t\\tif(line != lineCount - 1\\n\\t\\t\\t&& buffer.getFoldLevel(line + 1) > initialFoldLevel)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tstart = line + 1;\\n\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.getFoldLevel(i) <= initialFoldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tboolean ok = false;\\n\\t\\t\\t\\t\\t\\tfor(int i = line - 1; i >= 0; i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstart = i + 1;\\n\\t\\t\\t\\t\\tok = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(!ok)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\thideLineRange(start,end);\\n\\t\\tnotifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic int expandFold(int line, boolean fully)\\n\\t{\\n\\t\\t\\t\\tint returnValue = -1;\\n\\t\\tint lineCount = buffer.getLineCount();\\n\\t\\tint start = 0;\\n\\t\\tint end = lineCount - 1;\\n\\t\\tint initialFoldLevel = buffer.getFoldLevel(line);\\n\\t\\t\\t\\tif(line != lineCount - 1\\n\\t\\t\\t&& isLineVisible(line)\\n\\t\\t\\t&& !isLineVisible(line + 1)\\n\\t\\t\\t&& buffer.getFoldLevel(line + 1) > initialFoldLevel)\\n\\t\\t{\\n\\t\\t\\tint index = fvmget(line + 1);\\n\\t\\t\\tif(index == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\texpandAllFolds();\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\tstart = fvm[index];\\n\\t\\t\\tif(index != fvmcount - 1)\\n\\t\\t\\t\\tend = fvm[index + 1] - 1;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart = line + 1;\\n\\t\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(\\n\\t\\t\\t\\t\\t\\tbuffer.getFoldLevel(i) <= initialFoldLevel)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint index = fvmget(line);\\n\\t\\t\\tif(index == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\texpandAllFolds();\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\tstart = fvm[index];\\n\\t\\t\\tif(index != fvmcount - 1)\\n\\t\\t\\t\\tend = fvm[index + 1] - 1;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif((isLineVisible(i) &&\\n\\t\\t\\t\\t\\t\\tbuffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t\\t\\t|| i == getLastVisibleLine())\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tif(fully)\\n\\t\\t{\\n\\t\\t\\tshowLineRange(start,end);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tinitialFoldLevel = buffer.getFoldLevel(start);\\n\\t\\t\\tint firstVisible = start;\\n\\t\\t\\tfor(int i = start; i <= end; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.getFoldLevel(i) > initialFoldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(returnValue == -1\\n\\t\\t\\t\\t\\t\\t&& i != 0\\n\\t\\t\\t\\t\\t\\t&& buffer.isFoldStart(i - 1))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturnValue = i - 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(firstVisible != i)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tshowLineRange(firstVisible,i - 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfirstVisible = i + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(firstVisible != end + 1)\\n\\t\\t\\t\\tshowLineRange(firstVisible,end);\\n\\t\\t\\tif(!isLineVisible(line))\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\texpandFold(line,false);\\n\\t\\t\\t\\treturn returnValue;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tnotifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t\\treturn returnValue;\\n\\t} \\n\\tpublic void expandAllFolds()\\n\\t{\\n\\t\\tshowLineRange(0,buffer.getLineCount() - 1);\\n\\t\\tnotifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic void expandFolds(char digit)\\n\\t{\\n\\t\\tif(digit < '1' || digit > '9')\\n\\t\\t{\\n\\t\\t\\tToolkit.getDefaultToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\texpandFolds((int)(digit - '1') + 1);\\n\\t} \\n\\tpublic void expandFolds(int foldLevel)\\n\\t{\\n\\t\\tif(buffer.getFoldHandler() instanceof IndentFoldHandler)\\n\\t\\t\\tfoldLevel = (foldLevel - 1) * buffer.getIndentSize() + 1;\\n\\t\\tshowLineRange(0,buffer.getLineCount() - 1);\\n\\t\\tboolean seenVisibleLine = false;\\n\\t\\tint firstInvisible = 0;\\n\\t\\tfor(int i = 0; i < buffer.getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tif(!seenVisibleLine || buffer.getFoldLevel(i) < foldLevel)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(firstInvisible != i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\thideLineRange(firstInvisible,\\n\\t\\t\\t\\t\\t\\ti - 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfirstInvisible = i + 1;\\n\\t\\t\\t\\tseenVisibleLine = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(firstInvisible != buffer.getLineCount())\\n\\t\\t\\thideLineRange(firstInvisible,buffer.getLineCount() - 1);\\n\\t\\tnotifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic void narrow(int start, int end)\\n\\t{\\n\\t\\tif(start > end || start < 0 || end >= buffer.getLineCount())\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(start + \\\", \\\" + end);\\n\\t\\tif(start < getFirstVisibleLine() || end > getLastVisibleLine())\\n\\t\\t\\texpandAllFolds();\\n\\t\\tif(start != 0)\\n\\t\\t\\thideLineRange(0,start - 1);\\n\\t\\tif(end != buffer.getLineCount() - 1)\\n\\t\\t\\thideLineRange(end + 1,buffer.getLineCount() - 1);\\n\\t\\t\\t\\tif(start != buffer.getLineCount() - 1\\n\\t\\t\\t&& !isLineVisible(start + 1))\\n\\t\\t\\texpandFold(start,false);\\n\\t\\t\\t\\t\\t\\tGUIUtilities.getView(textArea).getStatus().setMessageAndClear(\\n\\t\\t\\tjEdit.getProperty(\\\"view.status.narrow\\\"));\\n\\t\\tnotifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic void bufferLoaded()\\n\\t{\\n\\t\\tfvmreset();\\n\\t\\tscreenLineMgr.reset();\\n\\t\\tfirstLine.reset();\\n\\t\\tscrollLineCount.reset();\\n\\t\\tclearNotifyFlags();\\n\\t\\tint collapseFolds = buffer.getIntegerProperty(\\n\\t\\t\\t\\\"collapseFolds\\\",0);\\n\\t\\tif(collapseFolds != 0)\\n\\t\\t\\texpandFolds(collapseFolds);\\n\\t} \\n\\t\\tboolean softWrap;\\n\\tint wrapMargin;\\n\\tboolean wrapToWidth;\\n\\tFirstLine firstLine;\\n\\tScrollLineCount scrollLineCount;\\n\\t\\tvoid init()\\n\\t{\\n\\t\\tupdateWrapSettings();\\n\\t\\tif(initialized)\\n\\t\\t{\\n\\t\\t\\tif(buffer.isLoaded())\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.reset();\\n\\t\\t\\t\\tscrollLineCount.reset();\\n\\t\\t\\t\\tclearNotifyFlags();\\n\\t\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tinitialized = true;\\n\\t\\t\\tfvm = new int[2];\\n\\t\\t\\tif(buffer.isLoaded())\\n\\t\\t\\t\\tbufferChangeHandler.foldHandlerChanged(buffer);\\n\\t\\t\\telse\\n\\t\\t\\t\\tfvmreset();\\n\\t\\t\\tnotifyScreenLineChanges();\\n\\t\\t}\\n\\t} \\n\\t\\tvoid updateWrapSettings()\\n\\t{\\n\\t\\tString wrap = buffer.getStringProperty(\\\"wrap\\\");\\n\\t\\tsoftWrap = wrap.equals(\\\"soft\\\");\\n\\t\\tif(textArea.maxLineLen <= 0)\\n\\t\\t{\\n\\t\\t\\tif(softWrap)\\n\\t\\t\\t{\\n\\t\\t\\t\\twrapToWidth = true;\\n\\t\\t\\t\\twrapMargin = textArea.getPainter().getWidth()\\n\\t\\t\\t\\t\\t- textArea.charWidth * 3;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\twrapToWidth = false;\\n\\t\\t\\t\\twrapMargin = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tchar[] foo = new char[textArea.maxLineLen];\\n\\t\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfoo[i] = ' ';\\n\\t\\t\\t}\\n\\t\\t\\tTextAreaPainter painter = textArea.getPainter();\\n\\t\\t\\twrapToWidth = false;\\n\\t\\t\\twrapMargin = (int)painter.getFont().getStringBounds(\\n\\t\\t\\t\\tfoo,0,foo.length,\\n\\t\\t\\t\\tpainter.getFontRenderContext())\\n\\t\\t\\t\\t.getWidth();\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void clearNotifyFlags()\\n\\t{\\n\\t\\tfirstLine.callReset = firstLine.callChanged = false;\\n\\t\\tscrollLineCount.callReset = scrollLineCount.callChanged = false;\\n\\t} \\n\\t\\tvoid notifyScreenLineChanges()\\n\\t{\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"notifyScreenLineChanges()\\\");\\n\\t\\t\\t\\t\\t\\tif(textArea.getDisplayManager() != this)\\n\\t\\t\\treturn;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tif(firstLine.callReset)\\n\\t\\t\\t\\tfirstLine.reset();\\n\\t\\t\\telse if(firstLine.callChanged)\\n\\t\\t\\t\\tfirstLine.changed();\\n\\t\\t\\tif(scrollLineCount.callReset)\\n\\t\\t\\t\\tscrollLineCount.reset();\\n\\t\\t\\telse if(scrollLineCount.callChanged)\\n\\t\\t\\t\\tscrollLineCount.changed();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tclearNotifyFlags();\\n\\t\\t}\\n\\t} \\n\\t\\tvoid setFirstLine(int oldFirstLine, int firstLine)\\n\\t{\\n\\t\\tint visibleLines = textArea.getVisibleLines();\\n\\t\\tif(firstLine >= oldFirstLine + visibleLines)\\n\\t\\t{\\n\\t\\t\\tthis.firstLine.scrollDown(firstLine - oldFirstLine);\\n\\t\\t\\ttextArea.chunkCache.invalidateAll();\\n\\t\\t}\\n\\t\\telse if(firstLine <= oldFirstLine - visibleLines)\\n\\t\\t{\\n\\t\\t\\tthis.firstLine.scrollUp(oldFirstLine - firstLine);\\n\\t\\t\\ttextArea.chunkCache.invalidateAll();\\n\\t\\t}\\n\\t\\telse if(firstLine > oldFirstLine)\\n\\t\\t{\\n\\t\\t\\tthis.firstLine.scrollDown(firstLine - oldFirstLine);\\n\\t\\t\\ttextArea.chunkCache.scrollDown(firstLine - oldFirstLine);\\n\\t\\t}\\n\\t\\telse if(firstLine < oldFirstLine)\\n\\t\\t{\\n\\t\\t\\tthis.firstLine.scrollUp(oldFirstLine - firstLine);\\n\\t\\t\\ttextArea.chunkCache.scrollUp(oldFirstLine - firstLine);\\n\\t\\t}\\n\\t\\tnotifyScreenLineChanges();\\n\\t} \\t\\n\\t\\tvoid setFirstPhysicalLine(int amount, int skew)\\n\\t{\\n\\t\\tint oldFirstLine = textArea.getFirstLine();\\n\\t\\tif(amount == 0)\\n\\t\\t{\\n\\t\\t\\tskew -= this.firstLine.skew;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(skew < 0)\\n\\t\\t\\t\\tthis.firstLine.scrollUp(-skew);\\n\\t\\t\\telse if(skew > 0)\\n\\t\\t\\t\\tthis.firstLine.scrollDown(skew);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(amount > 0)\\n\\t\\t\\tthis.firstLine.physDown(amount,skew);\\n\\t\\telse if(amount < 0)\\n\\t\\t\\tthis.firstLine.physUp(-amount,skew);\\n\\t\\tint firstLine = textArea.getFirstLine();\\n\\t\\tint visibleLines = textArea.getVisibleLines();\\n\\t\\tif(firstLine == oldFirstLine)\\n\\t\\t\\t;\\n\\t\\telse if(firstLine >= oldFirstLine + visibleLines\\n\\t\\t\\t|| firstLine <= oldFirstLine - visibleLines)\\n\\t\\t{\\n\\t\\t\\ttextArea.chunkCache.invalidateAll();\\n\\t\\t}\\n\\t\\telse if(firstLine > oldFirstLine)\\n\\t\\t{\\n\\t\\t\\ttextArea.chunkCache.scrollDown(firstLine - oldFirstLine);\\n\\t\\t}\\n\\t\\telse if(firstLine < oldFirstLine)\\n\\t\\t{\\n\\t\\t\\ttextArea.chunkCache.scrollUp(oldFirstLine - firstLine);\\n\\t\\t}\\n\\t\\t\\t\\tnotifyScreenLineChanges();\\n\\t} \\n\\t\\tvoid invalidateScreenLineCounts()\\n\\t{\\n\\t\\tscreenLineMgr.invalidateScreenLineCounts();\\n\\t\\tfirstLine.callReset = true;\\n\\t\\tscrollLineCount.callReset = true;\\n\\t} \\n\\t\\tprivate boolean initialized;\\n\\tprivate boolean inUse;\\n\\tprivate Buffer buffer;\\n\\tprivate ScreenLineManager screenLineMgr;\\n\\tprivate JEditTextArea textArea;\\n\\tprivate BufferChangeHandler bufferChangeHandler;\\n\\tprivate int[] fvm;\\n\\tprivate int fvmcount;\\n\\tprivate int lastfvmget = -1;\\n\\t\\tprivate DisplayManager(Buffer buffer, JEditTextArea textArea)\\n\\t{\\n\\t\\tthis.buffer = buffer;\\n\\t\\tthis.screenLineMgr = new ScreenLineManager(this,buffer);\\n\\t\\tthis.textArea = textArea;\\n\\t\\tscrollLineCount = new ScrollLineCount();\\n\\t\\tfirstLine = new FirstLine();\\n\\t\\tbufferChangeHandler = new BufferChangeHandler();\\n\\t\\t\\t\\tbuffer.addBufferChangeListener(bufferChangeHandler,\\n\\t\\t\\tBuffer.HIGH_PRIORITY);\\n\\t} \\n\\t\\tprivate void dispose()\\n\\t{\\n\\t\\tbuffer.removeBufferChangeListener(bufferChangeHandler);\\n\\t} \\n\\t\\tprivate void fvmreset()\\n\\t{\\n\\t\\tlastfvmget = -1;\\n\\t\\tfvmcount = 2;\\n\\t\\tfvm[0] = 0;\\n\\t\\tfvm[1] = buffer.getLineCount();\\n\\t} \\n\\tprivate int fvmget(int line)\\n\\t{\\n\\t\\tscanCount++;\\n\\t\\tif(line < fvm[0])\\n\\t\\t\\treturn -1;\\n\\t\\tif(line >= fvm[fvmcount - 1])\\n\\t\\t\\treturn fvmcount - 1;\\n\\t\\tif(lastfvmget != -1)\\n\\t\\t{\\n\\t\\t\\tif(line >= fvm[lastfvmget])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(lastfvmget == fvmcount - 1\\n\\t\\t\\t\\t\\t|| line < fvm[lastfvmget + 1])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn lastfvmget;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint start = 0;\\n\\t\\tint end = fvmcount - 1;\\nloop:\\t\\tfor(;;)\\n\\t\\t{\\n\\t\\t\\tscannedLines++;\\n\\t\\t\\tswitch(end - start)\\n\\t\\t\\t{\\n\\t\\t\\tcase 0:\\n\\t\\t\\t\\tlastfvmget = start;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\tint value = fvm[end];\\n\\t\\t\\t\\tif(value <= line)\\n\\t\\t\\t\\t\\tlastfvmget = end;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tlastfvmget = start;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tint pivot = (end + start) / 2;\\n\\t\\t\\t\\tvalue = fvm[pivot];\\n\\t\\t\\t\\tif(value == line)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastfvmget = pivot;\\n\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(value < line)\\n\\t\\t\\t\\t\\tstart = pivot;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tend = pivot - 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn lastfvmget;\\n\\t} \\n\\tprivate void fvmput(int start, int end, int[] put)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tStringBuffer buf = new StringBuffer(\\\"{\\\");\\n\\t\\t\\tif(put != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i = 0; i < put.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(i != 0)\\n\\t\\t\\t\\t\\t\\tbuf.append(',');\\n\\t\\t\\t\\t\\tbuf.append(put[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tbuf.append(\\\"}\\\");\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"fvmput(\\\" + start + \\\",\\\"\\n\\t\\t\\t\\t+ end + \\\",\\\" + buf + \\\")\\\");\\n\\t\\t}\\n\\t\\tint putl = (put == null ? 0 : put.length);\\n\\t\\tint delta = putl - (end - start);\\n\\t\\tif(fvmcount + delta > fvm.length)\\n\\t\\t{\\n\\t\\t\\tint[] newfvm = new int[fvm.length * 2 + 1];\\n\\t\\t\\tSystem.arraycopy(fvm,0,newfvm,0,fvmcount);\\n\\t\\t\\tfvm = newfvm;\\n\\t\\t}\\n\\t\\tif(delta != 0)\\n\\t\\t{\\n\\t\\t\\tSystem.arraycopy(fvm,end,fvm,start + putl,\\n\\t\\t\\t\\tfvmcount - end);\\n\\t\\t}\\n\\t\\tif(putl != 0)\\n\\t\\t{\\n\\t\\t\\tSystem.arraycopy(put,0,fvm,start,put.length);\\n\\t\\t}\\n\\t\\tfvmcount += delta;\\n\\t\\tfvmdump();\\n\\t\\tif(fvmcount == 0)\\n\\t\\t\\tthrow new InternalError();\\n\\t} \\n\\tprivate void fvmput2(int starti, int endi, int start, int end)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"*fvmput2(\\\" + starti + \\\",\\\"\\n\\t\\t\\t\\t+ endi + \\\",\\\" + start + \\\",\\\" + end + \\\")\\\");\\n\\t\\t}\\n\\t\\tif(starti != -1 && fvm[starti] == start)\\n\\t\\t{\\n\\t\\t\\tif(endi <= fvmcount - 2 && fvm[endi + 1]\\n\\t\\t\\t\\t== end + 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti,endi + 2,null);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti,endi + 1,\\n\\t\\t\\t\\t\\tnew int[] { end + 1 });\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(endi != fvmcount - 1 && fvm[endi + 1]\\n\\t\\t\\t\\t== end + 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 2,\\n\\t\\t\\t\\t\\tnew int[] { start });\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 1,\\n\\t\\t\\t\\t\\tnew int[] { start,\\n\\t\\t\\t\\t\\tend + 1 });\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fvmdump()\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tStringBuffer buf = new StringBuffer(\\\"{\\\");\\n\\t\\t\\tfor(int i = 0; i < fvmcount; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i != 0)\\n\\t\\t\\t\\t\\tbuf.append(',');\\n\\t\\t\\t\\tbuf.append(fvm[i]);\\n\\t\\t\\t}\\n\\t\\t\\tbuf.append(\\\"}\\\");\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"fvm = \\\" + buf);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void showLineRange(int start, int end)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"showLineRange(\\\" + start\\n\\t\\t\\t\\t+ \\\",\\\" + end + \\\")\\\");\\n\\t\\t}\\n\\t\\tfor(int i = start; i <= end; i++)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(!isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tupdateScreenLineCount(i);\\n\\t\\t\\t\\tint screenLines = getScreenLineCount(i);\\n\\t\\t\\t\\tif(firstLine.physicalLine >= i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfirstLine.scrollLine += screenLines;\\n\\t\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tscrollLineCount.scrollLine += screenLines;\\n\\t\\t\\t\\tscrollLineCount.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint starti = fvmget(start);\\n\\t\\tint endi = fvmget(end);\\n\\t\\tif(starti % 2 == 0)\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 1,null);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(endi != fvmcount - 1\\n\\t\\t\\t\\t\\t&& fvm[endi + 1] == end + 1)\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi + 2,null);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\t\\tfvm[starti + 1] = end + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(starti != -1 && fvm[starti] == start)\\n\\t\\t\\t\\t\\tfvmput(starti,endi + 1,null);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\t\\tfvm[starti + 1] = start;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tfvmput2(starti,endi,start,end);\\n\\t\\t}\\n\\t\\tlastfvmget = -1;\\n\\t} \\n\\t\\tprivate void hideLineRange(int start, int end)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"hideLineRange(\\\" + start\\n\\t\\t\\t\\t+ \\\",\\\" + end + \\\")\\\");\\n\\t\\t}\\n\\t\\tint i = start;\\n\\t\\tif(!isLineVisible(i))\\n\\t\\t\\ti = getNextVisibleLine(i);\\n\\t\\twhile(i != -1 && i <= end)\\n\\t\\t{\\n\\t\\t\\tint screenLines = screenLineMgr.getScreenLineCount(i);\\n\\t\\t\\tif(i < firstLine.physicalLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.scrollLine -= screenLines;\\n\\t\\t\\t\\tfirstLine.skew = 0;\\n\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t\\tscrollLineCount.scrollLine -= screenLines;\\n\\t\\t\\tscrollLineCount.callChanged = true;\\n\\t\\t\\ti = getNextVisibleLine(i);\\n\\t\\t}\\n\\t\\tint starti = fvmget(start);\\n\\t\\tint endi = fvmget(end);\\n\\t\\tif(starti % 2 == 0)\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t\\tfvmput2(starti,endi,start,end);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(start == fvm[0])\\n\\t\\t\\t\\t\\tfvmput(starti,endi + 1,null);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\t\\tfvm[starti + 1] = start;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(end + 1 == fvm[fvmcount - 1])\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi + 2,null);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\t\\tfvm[starti + 1] = end + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 1,null);\\n\\t\\t}\\n\\t\\tlastfvmget = -1;\\n\\t\\tif(!isLineVisible(firstLine.physicalLine))\\n\\t\\t{\\n\\t\\t\\tint firstVisible = getFirstVisibleLine();\\n\\t\\t\\tif(firstLine.physicalLine < firstVisible)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.physicalLine = firstVisible;\\n\\t\\t\\t\\tfirstLine.scrollLine = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.physicalLine = getPrevVisibleLine(\\n\\t\\t\\t\\t\\tfirstLine.physicalLine);\\n\\t\\t\\t\\tfirstLine.scrollLine -=\\n\\t\\t\\t\\t\\tscreenLineMgr.getScreenLineCount(\\n\\t\\t\\t\\t\\tfirstLine.physicalLine);\\n\\t\\t\\t}\\n\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void updateScreenLineCount(int line)\\n\\t{\\n\\t\\tif(!screenLineMgr.isScreenLineCountValid(line))\\n\\t\\t{\\n\\t\\t\\tint newCount = textArea.chunkCache\\n\\t\\t\\t\\t.getLineSubregionCount(line);\\n\\t\\t\\tsetScreenLineCount(line,newCount);\\n\\t\\t}\\n\\t} \\n\\tprivate void setScreenLineCount(int line, int count)\\n\\t{\\n\\t\\tint oldCount = screenLineMgr.getScreenLineCount(line);\\n\\t\\tscreenLineMgr.setScreenLineCount(line,count);\\n\\t\\tif(count == oldCount)\\n\\t\\t\\treturn;\\n\\t\\tif(!isLineVisible(line))\\n\\t\\t\\treturn;\\n\\t\\tif(firstLine.physicalLine >= line)\\n\\t\\t{\\n\\t\\t\\tif(firstLine.physicalLine == line)\\n\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.scrollLine += (count - oldCount);\\n\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tscrollLineCount.scrollLine += (count - oldCount);\\n\\t\\tscrollLineCount.callChanged = true;\\n\\t} \\n\\t\\tstatic abstract class Anchor\\n\\t{\\n\\t\\tint physicalLine;\\n\\t\\tint scrollLine;\\n\\t\\tboolean callChanged;\\n\\t\\tboolean callReset;\\n\\t\\tabstract void reset();\\n\\t\\tabstract void changed();\\n\\t\\tpublic String toString()\\n\\t\\t{\\n\\t\\t\\treturn getClass().getName() + \\\"[\\\" + physicalLine + \\\",\\\"\\n\\t\\t\\t\\t+ scrollLine + \\\"]\\\";\\n\\t\\t}\\n\\t} \\n\\t\\tclass ScrollLineCount extends Anchor\\n\\t{\\n\\t\\t\\t\\tpublic void changed()\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"changed()\\\");\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t} \\n\\t\\t\\t\\tpublic void reset()\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"reset()\\\");\\n\\t\\t\\tphysicalLine = getFirstVisibleLine();\\n\\t\\t\\tint scrollLine = 0;\\n\\t\\t\\twhile(physicalLine != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tupdateScreenLineCount(physicalLine);\\n\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\tphysicalLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t}\\n\\t\\t\\tthis.scrollLine = scrollLine;\\n\\t\\t\\tphysicalLine = buffer.getLineCount();\\n\\t\\t\\tfirstLine.ensurePhysicalLineIsVisible();\\n\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t} \\t} \\n\\t\\tclass FirstLine extends Anchor\\n\\t{\\n\\t\\tint skew;\\n\\t\\t\\t\\tpublic void changed()\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"changed() before: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine\\n\\t\\t\\t\\t\\t+ \\\":\\\" + skew);\\n\\t\\t\\t} \\n\\t\\t\\tensurePhysicalLineIsVisible();\\n\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\tif(skew >= screenLines)\\n\\t\\t\\t\\tskew = screenLines - 1;\\n\\t\\t\\t\\t\\t\\tif(Debug.SCROLL_VERIFY)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSystem.err.println(\\\"SCROLL_VERIFY\\\");\\n\\t\\t\\t\\tint verifyScrollLine = 0;\\n\\t\\t\\t\\tfor(int i = 0; i < buffer.getLineCount(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!isLineVisible(i))\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\tif(i >= physicalLine)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tverifyScrollLine += getScreenLineCount(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(verifyScrollLine != scrollLine)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tException ex = new Exception(scrollLine + \\\":\\\" + verifyScrollLine);\\n\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,ex);\\n\\t\\t\\t\\t\\tnew org.gjt.sp.jedit.gui.BeanShellErrorDialog(null,ex);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"changed() after: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine\\n\\t\\t\\t\\t\\t+ \\\":\\\" + skew);\\n\\t\\t\\t} \\n\\t\\t\\tif(!scrollLineCount.callChanged\\n\\t\\t\\t\\t&& !scrollLineCount.callReset)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void reset()\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"reset()\\\");\\n\\t\\t\\tscrollLine = 0;\\n\\t\\t\\tint i = getFirstVisibleLine();\\n\\t\\t\\tfor(;;)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i >= physicalLine)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tupdateScreenLineCount(i);\\n\\t\\t\\t\\tscrollLine += getScreenLineCount(i);\\n\\t\\t\\t\\tint nextLine = getNextVisibleLine(i);\\n\\t\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\ti = nextLine;\\n\\t\\t\\t}\\n\\t\\t\\tphysicalLine = i;\\n\\t\\t\\tupdateScreenLineCount(i);\\n\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\tif(skew >= screenLines)\\n\\t\\t\\t\\tskew = screenLines - 1;\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid physDown(int amount, int screenAmount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physDown() start: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tskew = 0;\\n\\t\\t\\tif(!isLineVisible(physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint lastVisibleLine = getLastVisibleLine();\\n\\t\\t\\t\\tif(physicalLine > lastVisibleLine)\\n\\t\\t\\t\\t\\tphysicalLine = lastVisibleLine;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint nextPhysicalLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tamount -= (nextPhysicalLine - physicalLine);\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = nextPhysicalLine;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(;;)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint nextPhysicalLine = getNextVisibleLine(\\n\\t\\t\\t\\t\\tphysicalLine);\\n\\t\\t\\t\\tif(nextPhysicalLine == -1)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse if(nextPhysicalLine > physicalLine + amount)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t\\tamount -= (nextPhysicalLine - physicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = nextPhysicalLine;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physDown() end: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tcallChanged = true;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(screenAmount < 0)\\n\\t\\t\\t\\tscrollUp(-screenAmount);\\n\\t\\t\\telse if(screenAmount > 0)\\n\\t\\t\\t\\tscrollDown(screenAmount);\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid physUp(int amount, int screenAmount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physUp() start: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tskew = 0;\\n\\t\\t\\tif(!isLineVisible(physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint firstVisibleLine = getFirstVisibleLine();\\n\\t\\t\\t\\tif(physicalLine < firstVisibleLine)\\n\\t\\t\\t\\t\\tphysicalLine = firstVisibleLine;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint prevPhysicalLine = getPrevVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tamount -= (physicalLine - prevPhysicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(;;)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint prevPhysicalLine = getPrevVisibleLine(\\n\\t\\t\\t\\t\\tphysicalLine);\\n\\t\\t\\t\\tif(prevPhysicalLine == -1)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse if(prevPhysicalLine < physicalLine - amount)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tamount -= (physicalLine - prevPhysicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = prevPhysicalLine;\\n\\t\\t\\t\\t\\tscrollLine -= getScreenLineCount(\\n\\t\\t\\t\\t\\t\\tprevPhysicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physUp() end: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tcallChanged = true;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(screenAmount < 0)\\n\\t\\t\\t\\tscrollUp(-screenAmount);\\n\\t\\t\\telse if(screenAmount > 0)\\n\\t\\t\\t\\tscrollDown(screenAmount);\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid scrollDown(int amount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"scrollDown()\\\");\\n\\t\\t\\tensurePhysicalLineIsVisible();\\n\\t\\t\\tamount += skew;\\n\\t\\t\\tskew = 0;\\n\\t\\t\\twhile(amount > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\t\\tif(amount < screenLines)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tskew = amount;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint nextLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tboolean visible = isLineVisible(physicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = nextLine;\\n\\t\\t\\t\\t\\tif(visible)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tamount -= screenLines;\\n\\t\\t\\t\\t\\t\\tscrollLine += screenLines;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcallChanged = true;\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid scrollUp(int amount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"scrollUp()\\\");\\n\\t\\t\\tensurePhysicalLineIsVisible();\\n\\t\\t\\tif(amount <= skew)\\n\\t\\t\\t{\\n\\t\\t\\t\\tskew -= amount;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tamount -= skew;\\n\\t\\t\\t\\tskew = 0;\\n\\t\\t\\t\\twhile(amount > 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint prevLine = getPrevVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tif(prevLine == -1)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tphysicalLine = prevLine;\\n\\t\\t\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t\\tscrollLine -= screenLines;\\n\\t\\t\\t\\t\\tif(amount < screenLines)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tskew = screenLines - amount;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tamount -= screenLines;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcallChanged = true;\\n\\t\\t} \\n\\t\\t\\t\\tprivate void ensurePhysicalLineIsVisible()\\n\\t\\t{\\n\\t\\t\\tif(!isLineVisible(physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(physicalLine > getLastVisibleLine())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysicalLine = getLastVisibleLine();\\n\\t\\t\\t\\t\\tscrollLine = getScrollLineCount() - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(physicalLine < getFirstVisibleLine())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysicalLine = getFirstVisibleLine();\\n\\t\\t\\t\\t\\tscrollLine = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysicalLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\t} \\n\\tclass BufferChangeHandler extends BufferChangeAdapter\\n\\t{\\n\\t\\tboolean delayedUpdate;\\n\\t\\tboolean delayedMultilineUpdate;\\n\\t\\tint delayedUpdateStart;\\n\\t\\tint delayedUpdateEnd;\\n\\t\\t\\t\\tpublic void foldHandlerChanged(Buffer buffer)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tfvmreset();\\n\\t\\t\\tfirstLine.reset();\\n\\t\\t\\tscrollLineCount.reset();\\n\\t\\t\\tint collapseFolds = buffer.getIntegerProperty(\\n\\t\\t\\t\\t\\\"collapseFolds\\\",0);\\n\\t\\t\\tif(collapseFolds != 0)\\n\\t\\t\\t\\texpandFolds(collapseFolds);\\n\\t\\t} \\n\\t\\t\\t\\tpublic void foldLevelChanged(Buffer buffer, int start, int end)\\n\\t\\t{\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this\\n\\t\\t\\t\\t&& end != 0 && buffer.isLoaded())\\n\\t\\t\\t{\\n\\t\\t\\t\\ttextArea.invalidateLineRange(start - 1,\\n\\t\\t\\t\\t\\ttextArea.getLastPhysicalLine());\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void contentInserted(Buffer buffer, int startLine,\\n\\t\\t\\tint offset, int numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tscreenLineMgr.contentInserted(startLine,numLines);\\n\\t\\t\\tint endLine = startLine + numLines;\\n\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedMultilineUpdate = true;\\n\\t\\t\\t\\tint index = fvmget(startLine);\\n\\t\\t\\t\\tint start = index + 1;\\n\\t\\t\\t\\tfor(int i = start; i < fvmcount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvm[i] += numLines;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlastfvmget = -1;\\n\\t\\t\\t\\tfvmdump();\\n\\t\\t\\t}\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcontentInserted(firstLine,startLine,numLines);\\n\\t\\t\\t\\t\\tcontentInserted(scrollLineCount,startLine,numLines);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(delayedUpdateEnd >= startLine)\\n\\t\\t\\t\\t\\tdelayedUpdateEnd += numLines;\\n\\t\\t\\t\\tdelayedUpdate(startLine,endLine);\\n\\t\\t\\t\\t\\t\\t\\t\\tIterator iter = textArea.getSelectionIterator();\\n\\t\\t\\t\\twhile(iter.hasNext())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection s = (Selection)iter.next();\\n\\t\\t\\t\\t\\tif(s.contentInserted(buffer,startLine,offset,\\n\\t\\t\\t\\t\\t\\tnumLines,length))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdelayedUpdate(s.startLine,s.endLine);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tint caret = textArea.getCaretPosition();\\n\\t\\t\\t\\tif(caret >= offset)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.ELECTRIC_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(\\n\\t\\t\\t\\t\\t\\tcaret + length,scrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.NORMAL_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(\\n\\t\\t\\t\\t\\t\\tcaret,scrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void preContentRemoved(Buffer buffer, int startLine,\\n\\t\\t\\tint offset, int numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tdelayedMultilineUpdate = true;\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tpreContentRemoved(firstLine,startLine,numLines);\\n\\t\\t\\t\\t\\tpreContentRemoved(scrollLineCount,startLine,numLines);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(delayedUpdateEnd >= startLine)\\n\\t\\t\\t\\t\\tdelayedUpdateEnd -= numLines;\\n\\t\\t\\t\\tdelayedUpdate(startLine,startLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\t}\\n\\t\\t\\tif(numLines == 0)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tscreenLineMgr.contentRemoved(startLine,numLines);\\n\\t\\t\\tint endLine = startLine + numLines;\\n\\t\\t\\tint starti = fvmget(startLine);\\n\\t\\t\\tint endi = fvmget(endLine);\\n\\t\\t\\tif(Math.abs(starti % 2) == Math.abs(endi % 2))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(endi - starti == fvmcount)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfvmreset();\\n\\t\\t\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\t\\t\\tstarti = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi + 1,null);\\n\\t\\t\\t\\t\\tstarti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(starti != -1 && fvm[starti] == startLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(endi - starti == fvmcount - 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfvmreset();\\n\\t\\t\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\t\\t\\tstarti = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tfvmput(starti,endi + 1,null);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\tfvm[starti + 1] = startLine;\\n\\t\\t\\t\\tstarti += 2;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = starti; i < fvmcount; i++)\\n\\t\\t\\t\\tfvm[i] -= numLines;\\n\\t\\t\\tif(firstLine.physicalLine\\n\\t\\t\\t\\t> getLastVisibleLine()\\n\\t\\t\\t\\t|| firstLine.physicalLine\\n\\t\\t\\t\\t< getFirstVisibleLine())\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\telse if(!isLineVisible(\\n\\t\\t\\t\\tfirstLine.physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.physicalLine =\\n\\t\\t\\t\\t\\tgetNextVisibleLine(\\n\\t\\t\\t\\t\\tfirstLine.physicalLine);\\n\\t\\t\\t}\\n\\t\\t\\tlastfvmget = -1;\\n\\t\\t\\tfvmdump();\\n\\t\\t} \\n\\t\\t\\t\\tpublic void contentRemoved(Buffer buffer, int startLine,\\n\\t\\t\\tint start, int numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tIterator iter = textArea.getSelectionIterator();\\n\\t\\t\\t\\twhile(iter.hasNext())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection s = (Selection)iter.next();\\n\\t\\t\\t\\t\\tif(s.contentRemoved(buffer,startLine,\\n\\t\\t\\t\\t\\t\\tstart,numLines,length))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdelayedUpdate(s.startLine,s.endLine);\\n\\t\\t\\t\\t\\t\\tif(s.start == s.end)\\n\\t\\t\\t\\t\\t\\t\\titer.remove();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tint caret = textArea.getCaretPosition();\\n\\t\\t\\t\\tif(caret >= start + length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.ELECTRIC_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(\\n\\t\\t\\t\\t\\t\\tcaret - length,\\n\\t\\t\\t\\t\\t\\tscrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(caret >= start)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.ELECTRIC_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(\\n\\t\\t\\t\\t\\t\\tstart,scrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.NORMAL_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(caret,scrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tpublic void transactionComplete(Buffer buffer)\\n\\t\\t{\\n\\t\\t\\tif(textArea.getDisplayManager() != DisplayManager.this)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedUpdate = false;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(delayedUpdate)\\n\\t\\t\\t\\tdoDelayedUpdate();\\n\\t\\t\\ttextArea._finishCaretUpdate();\\n\\t\\t\\tdelayedUpdate = false;\\n\\t\\t\\t\\t\\t\\tif(Debug.SCROLL_VERIFY)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint scrollLineCount = 0;\\n\\t\\t\\t\\tint line = delayedUpdateStart;\\n\\t\\t\\t\\tif(!isLineVisible(line))\\n\\t\\t\\t\\t\\tline = getNextVisibleLine(line);\\n\\t\\t\\t\\tSystem.err.println(delayedUpdateStart + \\\":\\\" + delayedUpdateEnd + \\\":\\\" + textArea.getLineCount());\\n\\t\\t\\t\\twhile(line != -1 && line <= delayedUpdateEnd)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscrollLineCount += getScreenLineCount(line);\\n\\t\\t\\t\\t\\tline = getNextVisibleLine(line);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(scrollLineCount != getScrollLineCount())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tthrow new InternalError(scrollLineCount\\n\\t\\t\\t\\t\\t\\t+ \\\" != \\\"\\n\\t\\t\\t\\t\\t\\t+ getScrollLineCount());\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\t\\t} \\n\\t\\t\\t\\tprivate void doDelayedUpdate()\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tint _firstLine = textArea.getFirstPhysicalLine();\\n\\t\\t\\tint _lastLine = textArea.getLastPhysicalLine();\\n\\t\\t\\tint line = delayedUpdateStart;\\n\\t\\t\\tif(!isLineVisible(line))\\n\\t\\t\\t\\tline = getNextVisibleLine(line);\\n\\t\\t\\twhile(line != -1 && line <= delayedUpdateEnd)\\n\\t\\t\\t{\\n\\t\\t\\t\\tupdateScreenLineCount(line);\\n\\t\\t\\t\\tline = getNextVisibleLine(line);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnotifyScreenLineChanges();\\n\\t\\t\\tif(delayedMultilineUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttextArea.invalidateScreenLineRange(\\n\\t\\t\\t\\t\\ttextArea.chunkCache\\n\\t\\t\\t\\t\\t.getScreenLineOfOffset(\\n\\t\\t\\t\\t\\tdelayedUpdateStart,0),\\n\\t\\t\\t\\t\\ttextArea.getVisibleLines());\\n\\t\\t\\t\\tdelayedMultilineUpdate = false;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\ttextArea.invalidateLineRange(\\n\\t\\t\\t\\t\\tdelayedUpdateStart,\\n\\t\\t\\t\\t\\tdelayedUpdateEnd);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tint visibleLines = textArea.getVisibleLines();\\n\\t\\t\\tif(visibleLines != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttextArea.chunkCache.getLineInfo(\\n\\t\\t\\t\\t\\tvisibleLines - 1);\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.getFoldLevel(delayedUpdateEnd);\\n\\t\\t} \\n\\t\\t\\t\\tprivate void contentInserted(Anchor anchor, int startLine,\\n\\t\\t\\tint numLines)\\n\\t\\t{\\n\\t\\t\\tif(anchor.physicalLine >= startLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(anchor.physicalLine != startLine)\\n\\t\\t\\t\\t\\tanchor.physicalLine += numLines;\\n\\t\\t\\t\\tanchor.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void preContentRemoved(Anchor anchor, int startLine,\\n\\t\\t\\tint numLines)\\n\\t\\t{\\n\\t\\t\\tif(anchor.physicalLine >= startLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(anchor.physicalLine == startLine)\\n\\t\\t\\t\\t\\tanchor.callChanged = true;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint end = Math.min(startLine + numLines,\\n\\t\\t\\t\\t\\t\\tanchor.physicalLine);\\n\\t\\t\\t\\t\\tfor(int i = startLine; i < end; i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(isLineVisible(i))\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tanchor.scrollLine -=\\n\\t\\t\\t\\t\\t\\t\\t\\tscreenLineMgr\\n\\t\\t\\t\\t\\t\\t\\t\\t.getScreenLineCount(i);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tanchor.physicalLine -= (end - startLine);\\n\\t\\t\\t\\t\\tanchor.callChanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void delayedUpdate(int startLine, int endLine)\\n\\t\\t{\\n\\t\\t\\ttextArea.chunkCache.invalidateChunksFromPhys(startLine);\\n\\t\\t\\tif(!delayedUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedUpdateStart = startLine;\\n\\t\\t\\t\\tdelayedUpdateEnd = endLine;\\n\\t\\t\\t\\tdelayedUpdate = true;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedUpdateStart = Math.min(\\n\\t\\t\\t\\t\\tdelayedUpdateStart,\\n\\t\\t\\t\\t\\tstartLine);\\n\\t\\t\\t\\tdelayedUpdateEnd = Math.max(\\n\\t\\t\\t\\t\\tdelayedUpdateEnd,\\n\\t\\t\\t\\t\\tendLine);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tprivate boolean caretAutoScroll()\\n\\t\\t{\\n\\t\\t\\tView view = textArea.getView();\\n\\t\\t\\treturn view == jEdit.getActiveView()\\n\\t\\t\\t\\t&& view.getTextArea() == textArea;\\n\\t\\t} \\t} }\""
            },
            "m13": {
                "content": "From reviewing the source code of `DisplayManager.java`, here are some key observations:\n\n1. **Responsibility**:  \n   The `DisplayManager` class is primarily responsible for managing how text lines are displayed in a `JEditTextArea`. It handles functionalities such as:\n   - Managing visible and hidden line ranges (folding logic).\n   - Tracking scroll positions and screen-line calculations.\n   - Coordinating with other components like `BufferChangeHandler`, `FirstLine`, and `ScrollLineCount`.\n\n2. **Dependencies**:\n   - **JEditTextArea**: This is tightly coupled with the display logic, as it represents the UI component where the text is rendered.\n   - **FirstLine & ScrollLineCount**: These classes manage scrolling behavior and visible lines.\n   - **ScreenLineManager**: Handles screen-line calculations.\n   - **BufferChangeHandler**: Listens to buffer changes and updates the display accordingly.\n\n3. **Interaction Patterns**:\n   - Folding/Unfolding: Managed through methods like `collapseFold()`, `expandFold()`, and interactions with `BufferChangeHandler`.\n   - Scrolling: Handled by `FirstLine` and `ScrollLineCount` which update scroll positions based on user interaction or content changes.\n   - Line Visibility: Methods like `isLineVisible()` determine if a specific line should be shown or hidden.\n\n### Impact Analysis\n\nBased on this analysis, the following entities are likely affected by changes in `DisplayManager.java`:\n\n- **JEditTextArea.java**: Since `DisplayManager` directly interacts with it for rendering and scrolling.\n- **FirstLine.java** and **ScrollLineCount.java**: These are instantiated and used internally by `DisplayManager` for tracking scroll states.\n- **BufferChangeHandler.java**: Although removed in newer versions, it was tightly integrated with buffer change events tied to `DisplayManager`.\n- **ScreenLineManager.java**: Involved in screen-line calculations that affect the display state.\n\n### Next Steps\n\nTo validate these relationships and identify further dependencies, I will perform additional checks:\n\n1. Call `get_coupling_dependencies` between `DisplayManager.java` and `JEditTextArea.java`.\n2. Call `get_coupling_dependencies` between `DisplayManager.java` and `ScreenLineManager.java`.\n\nThis will help confirm direct coupling relationships with these critical components.\n\nLet me start with the first check:\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_5465111367d14317bc394c",
                        "function": {
                            "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"JEditTextArea.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m14": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"Class Member Variable Usage Variable (CMAUA): Coupling found in method getDisplayManager, at line: 61. Instance of JEditTextArea member variable textArea is used directly.  Coupling found in method getDisplayManager, at line: 69. Instance of JEditTextArea member variable textArea is used directly.  Coupling found in method textAreaDisposed, at line: 100. Instance of JEditTextArea member variable textArea is used directly.  Coupling found in method caretAutoScroll, at line: 2023. Instance of JEditTextArea member variable textArea is used directly.  \", \"Function Parameter Usage Variable (FPUA): Coupling found in method getDisplayManager, at line: 61. Instance of JEditTextArea parameter textArea is used directly.  Coupling found in method getDisplayManager, at line: 69. Instance of JEditTextArea parameter textArea is used directly.  Coupling found in method textAreaDisposed, at line: 100. Instance of JEditTextArea parameter textArea is used directly.  \", \"StaticVariableInvoking(SAI): Static Variable Invoking found: contentInserted invokes static variable ELECTRIC_SCROLL,  Static Variable Invoking found: contentInserted invokes static variable NO_SCROLL,  Static Variable Invoking found: contentInserted invokes static variable NORMAL_SCROLL,  Static Variable Invoking found: contentInserted invokes static variable NO_SCROLL,  Static Variable Invoking found: contentRemoved invokes static variable ELECTRIC_SCROLL,  Static Variable Invoking found: contentRemoved invokes static variable NO_SCROLL,  Static Variable Invoking found: contentRemoved invokes static variable ELECTRIC_SCROLL,  Static Variable Invoking found: contentRemoved invokes static variable NO_SCROLL,  Static Variable Invoking found: contentRemoved invokes static variable NORMAL_SCROLL,  Static Variable Invoking found: contentRemoved invokes static variable NO_SCROLL,  \", \"Class Member Variable Invoking Variable (CMAIA): Coupling found in method updateWrapSettings, at line: 597. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable maxLineLen.  Coupling found in method updateWrapSettings, at line: 603. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable charWidth.  Coupling found in method updateWrapSettings, at line: 614. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable maxLineLen.  Coupling found in method setFirstLine, at line: 672. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable chunkCache.  Coupling found in method setFirstLine, at line: 677. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable chunkCache.  Coupling found in method setFirstLine, at line: 682. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable chunkCache.  Coupling found in method setFirstLine, at line: 687. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable chunkCache.  Coupling found in method setFirstPhysicalLine, at line: 727. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable chunkCache.  Coupling found in method setFirstPhysicalLine, at line: 731. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable chunkCache.  Coupling found in method setFirstPhysicalLine, at line: 735. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable chunkCache.  Coupling found in method updateScreenLineCount, at line: 1139. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable chunkCache.  Coupling found in method doDelayedUpdate, at line: 1920. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable chunkCache.  Coupling found in method doDelayedUpdate, at line: 1937. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable chunkCache.  Coupling found in method delayedUpdate, at line: 1997. Instance of JEditTextArea member variable textArea is used to access JEditTextArea's member variable chunkCache.  \", \"ConstructorInvoking(CMAIM): Coupling found in method collapseFold, at line: 306. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method foldStructureChanged.  Coupling found in method expandFold, at line: 431. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method foldStructureChanged.  Coupling found in method expandAllFolds, at line: 445. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method foldStructureChanged.  Coupling found in method expandFolds, at line: 500. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method foldStructureChanged.  Coupling found in method narrow, at line: 535. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method foldStructureChanged.  Coupling found in method init, at line: 576. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method updateScrollBars.  Coupling found in method init, at line: 577. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method recalculateLastPhysicalLine.  Coupling found in method updateWrapSettings, at line: 602. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getPainter.  Coupling found in method updateWrapSettings, at line: 619. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getPainter.  Coupling found in method notifyScreenLineChanges, at line: 643. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getDisplayManager.  Coupling found in method setFirstLine, at line: 667. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getVisibleLines.  Coupling found in method setFirstPhysicalLine, at line: 696. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getFirstLine.  Coupling found in method setFirstPhysicalLine, at line: 719. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getFirstLine.  Coupling found in method setFirstPhysicalLine, at line: 720. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getVisibleLines.  Coupling found in method changed, at line: 1210. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method updateScrollBars.  Coupling found in method changed, at line: 1211. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method recalculateLastPhysicalLine.  Coupling found in method reset, at line: 1234. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method recalculateLastPhysicalLine.  Coupling found in method reset, at line: 1235. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method updateScrollBars.  Coupling found in method changed, at line: 1296. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method updateScrollBars.  Coupling found in method changed, at line: 1297. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method recalculateLastPhysicalLine.  Coupling found in method reset, at line: 1338. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method updateScrollBars.  Coupling found in method foldLevelChanged, at line: 1603. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getDisplayManager.  Coupling found in method foldLevelChanged, at line: 1606. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method invalidateLineRange.  Coupling found in method foldLevelChanged, at line: 1607. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getLastPhysicalLine.  Coupling found in method contentInserted, at line: 1639. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getDisplayManager.  Coupling found in method contentInserted, at line: 1652. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getSelectionIterator.  Coupling found in method contentInserted, at line: 1664. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getCaretPosition.  Coupling found in method contentInserted, at line: 1670. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method moveCaretPosition.  Coupling found in method contentInserted, at line: 1678. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method moveCaretPosition.  Coupling found in method preContentRemoved, at line: 1698. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getDisplayManager.  Coupling found in method contentRemoved, at line: 1807. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getDisplayManager.  Coupling found in method contentRemoved, at line: 1810. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getSelectionIterator.  Coupling found in method contentRemoved, at line: 1824. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getCaretPosition.  Coupling found in method contentRemoved, at line: 1831. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method moveCaretPosition.  Coupling found in method contentRemoved, at line: 1840. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method moveCaretPosition.  Coupling found in method contentRemoved, at line: 1848. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method moveCaretPosition.  Coupling found in method transactionComplete, at line: 1857. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getDisplayManager.  Coupling found in method transactionComplete, at line: 1866. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method _finishCaretUpdate.  Coupling found in method transactionComplete, at line: 1877. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getLineCount.  Coupling found in method doDelayedUpdate, at line: 1899. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getFirstPhysicalLine.  Coupling found in method doDelayedUpdate, at line: 1900. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getLastPhysicalLine.  Coupling found in method doDelayedUpdate, at line: 1919. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method invalidateScreenLineRange.  Coupling found in method doDelayedUpdate, at line: 1923. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getVisibleLines.  Coupling found in method doDelayedUpdate, at line: 1928. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method invalidateLineRange.  Coupling found in method doDelayedUpdate, at line: 1934. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getVisibleLines.  Coupling found in method caretAutoScroll, at line: 2021. Instance of JEditTextArea member variable textArea is used to call JEditTextArea's method getView.\"]"
            },
            "m15": {
                "content": "The coupling analysis between `DisplayManager.java` and `JEditTextArea.java` reveals a **strong direct dependency**. Here's a breakdown of the findings:\n\n### Coupling Types Identified:\n1. **Class Member Variable Usage (CMAUA)**:\n   - The `textArea` member variable (of type `JEditTextArea`) is used directly in several methods, such as `getDisplayManager()`, `textAreaDisposed()`, and `caretAutoScroll()`.\n\n2. **Function Parameter Usage (FPUA)**:\n   - The `textArea` parameter passed to methods like `getDisplayManager()` is also directly used.\n\n3. **Static Variable Invoking (SAI)**:\n   - Static fields from `JEditTextArea` such as `ELECTRIC_SCROLL`, `NORMAL_SCROLL`, and `NO_SCROLL` are referenced.\n\n4. **Class Member Access Invoking (CMAIA)**:\n   - Several methods access member variables of `JEditTextArea`, such as `maxLineLen`, `charWidth`, and `chunkCache`.\n\n5. **Method Invoking (CMAIM)**:\n   - Multiple methods in `JEditTextArea` are called, including:\n     - `foldStructureChanged()`\n     - `updateScrollBars()`\n     - `getPainter()`\n     - `getVisibleLines()`\n     - `getFirstLine()`\n     - `getCaretPosition()`\n     - `moveCaretPosition()`\n     - `_finishCaretUpdate()`\n     - `invalidateLineRange()`\n\n### Implication:\nThis level of coupling means that any change in `DisplayManager.java` can significantly impact `JEditTextArea.java`, especially its rendering, scrolling, and caret behavior. Therefore, **synchronizing changes with `JEditTextArea.java` is critical**.\n\n---\n\n### Next Step:\nLet\u2019s analyze coupling dependencies between `DisplayManager.java` and `ScreenLineManager.java`, another key class used internally for screen-line calculations.\n\nI'll call:\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_e3610ba9d24e45a7a9c5f1",
                        "function": {
                            "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"ScreenLineManager.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m16": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"ConstructorInvoking(CMI): Construction Method Invoking found: new ScreenLineManager(this, buffer),  \", \"ConstructorInvoking(CMAIM): Coupling found in method getScreenLineCount, at line: 219. Instance of ScreenLineManager member variable screenLineMgr is used to call ScreenLineManager's method isScreenLineCountValid.  Coupling found in method getScreenLineCount, at line: 222. Instance of ScreenLineManager member variable screenLineMgr is used to call ScreenLineManager's method getScreenLineCount.  Coupling found in method bufferLoaded, at line: 545. Instance of ScreenLineManager member variable screenLineMgr is used to call ScreenLineManager's method reset.  Coupling found in method invalidateScreenLineCounts, at line: 745. Instance of ScreenLineManager member variable screenLineMgr is used to call ScreenLineManager's method invalidateScreenLineCounts.  Coupling found in method hideLineRange, at line: 1063. Instance of ScreenLineManager member variable screenLineMgr is used to call ScreenLineManager's method getScreenLineCount.  Coupling found in method hideLineRange, at line: 1127. Instance of ScreenLineManager member variable screenLineMgr is used to call ScreenLineManager's method getScreenLineCount.  Coupling found in method updateScreenLineCount, at line: 1137. Instance of ScreenLineManager member variable screenLineMgr is used to call ScreenLineManager's method isScreenLineCountValid.  Coupling found in method setScreenLineCount, at line: 1154. Instance of ScreenLineManager member variable screenLineMgr is used to call ScreenLineManager's method getScreenLineCount.  Coupling found in method setScreenLineCount, at line: 1159. Instance of ScreenLineManager member variable screenLineMgr is used to call ScreenLineManager's method setScreenLineCount.  Coupling found in method contentInserted, at line: 1618. Instance of ScreenLineManager member variable screenLineMgr is used to call ScreenLineManager's method contentInserted.  Coupling found in method preContentRemoved, at line: 1719. Instance of ScreenLineManager member variable screenLineMgr is used to call ScreenLineManager's method contentRemoved.  Coupling found in method preContentRemoved, at line: 1984. Instance of ScreenLineManager member variable screenLineMgr is used to call ScreenLineManager's method getScreenLineCount.\"]"
            },
            "m17": {
                "role": "user",
                "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
            },
            "m18": {
                "content": "Title: Diagnosis of starting entity `DisplayManager`\n\nChange set: [JEditTextArea, FirstLine, ScrollLineCount, ScreenLineManager, BufferChangeHandler, ChunkCache, HelpIndex, HelpTOCPanel, View, BufferIORequest, RingListModel, OffsetManager, PosBottomHalf, PositionManager, PasteFromListDialog, ListHandler, KeyHandler, FontSelector, FontSelectorDialog, TextAreaOptionPane, ActionHandler, BeanShell, TextAreaPainter, EditPane, MouseHandler, Anchor, RangeMap]\n\nDetails:\n1. **JEditTextArea**: DisplayManager heavily uses JEditTextArea for rendering, scrolling, caret positioning, and fold updates. Direct coupling through method calls and member access makes synchronization essential.\n2. **FirstLine**: Manages scroll positions and is directly used by DisplayManager to track visible lines. Co-change history and internal instantiation confirm its dependency.\n3. **ScrollLineCount**: Tightly involved in scroll bar updates and line counting. Coupled via internal usage and co-change data.\n4. **ScreenLineManager**: Responsible for screen-line calculations which are crucial for display logic. Created internally and invoked throughout the code.\n5. **BufferChangeHandler**: Handles buffer change events that affect display state. Instantiated and used directly by DisplayManager.\n6. **ChunkCache**: Used in line rendering and caching mechanisms. DisplayManager references it multiple times for visual updates.\n7. **HelpIndex**: Appears in co-change history with moderate support/confidence, indicating historical synchronized modifications.\n8. **HelpTOCPanel**: Frequent alongside DisplayManager historically; likely tied to UI rendering or help-related views.\n9. **View**: Central UI component in jEdit; changes in display logic may affect how the view renders text areas.\n10. **BufferIORequest**: Related to buffer input/output operations that can influence display behavior during file loading/editing.\n11. **RingListModel**: Possibly used in list-based UI components tied to display settings or selections.\n12. **OffsetManager**: Likely involved in tracking offsets within the text area; impacts display logic.\n13. **PosBottomHalf**: May be related to vertical positioning or viewport management.\n14. **PositionManager**: Could assist in tracking cursor or selection positions; relevant to display state.\n15. **PasteFromListDialog**: Possibly interacts with display when pasting from history or lists.\n16. **ListHandler**: May coordinate with display logic for list-like content presentation.\n17. **KeyHandler**: Involved in keyboard interactions that could affect display (e.g., scrolling, navigation).\n18. **FontSelector**: Affects rendering visuals; changes in display settings often require font adjustments.\n19. **FontSelectorDialog**: Tied to user configuration affecting display appearance.\n20. **TextAreaOptionPane**: Part of configuration UI for text area properties; affects display settings.\n21. **ActionHandler**: Coordinates actions that may impact display behavior (e.g., folds, scrolls).\n22. **BeanShell**: Potentially involved in scripting UI behaviors or dynamic display changes.\n23. **TextAreaPainter**: Directly responsible for painting the text area; tightly coupled with display logic.\n24. **EditPane**: Hosts the text area and display settings; changes in display may require layout updates.\n25. **MouseHandler**: Manages mouse events influencing display (selections, clicks, drags).\n26. **Anchor**: Internal class extended by FirstLine and ScrollLineCount; plays a role in scroll anchoring.\n27. **RangeMap**: Possibly manages line ranges or mappings relevant to visibility or folding.\n\nAdditional entities like **Anchor**, **RangeMap**, and others listed above appear in the co-change results with varying levels of confidence/support, indicating historical correlation with DisplayManager changes. Given the nature of CIA and recall prioritization, these should be included as potential candidates due to their semantic or historical ties.",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            }
        }
    }
}