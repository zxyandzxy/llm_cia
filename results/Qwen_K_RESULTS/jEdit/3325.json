{
    "time": 1749535191.14695,
    "messages": [
        {
            "role": "system",
            "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
        },
        {
            "role": "user",
            "content": "The project you need to analyze is `jEdit`, a well-known Java open source project. The starting entity you need to deal with is DisplayManager.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
        },
        {
            "content": "",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_5e44046aebd74e10b30f16",
                    "function": {
                        "arguments": "{\"entity\": \"DisplayManager.java\"}",
                        "name": "get_co_change_relationship"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "name": "get_co_change_relationship",
            "role": "tool",
            "content": "[[\"FirstLine\", \"6\", \"0.375\"], [\"ScrollLineCount\", \"6\", \"0.375\"], [\"ChunkCache\", \"6\", \"0.375\"], [\"HelpIndex\", \"2\", \"0.125\"], [\"HelpTOCPanel\", \"2\", \"0.125\"], [\"View\", \"2\", \"0.125\"], [\"BufferChangeHandler\", \"9\", \"0.5625\"], [\"BufferIORequest\", \"4\", \"0.25\"], [\"RingListModel\", \"2\", \"0.125\"], [\"OffsetManager\", \"2\", \"0.125\"], [\"PosBottomHalf\", \"2\", \"0.125\"], [\"PositionManager\", \"2\", \"0.125\"], [\"PasteFromListDialog\", \"2\", \"0.125\"], [\"ListHandler\", \"2\", \"0.125\"], [\"KeyHandler\", \"2\", \"0.125\"], [\"FontSelector\", \"2\", \"0.125\"], [\"FontSelectorDialog\", \"2\", \"0.125\"], [\"TextAreaOptionPane\", \"2\", \"0.125\"], [\"ActionHandler\", \"2\", \"0.125\"], [\"JEditTextArea\", \"3\", \"0.1875\"], [\"TextAreaPainter\", \"2\", \"0.125\"], [\"EditPane\", \"2\", \"0.125\"], [\"BeanShell\", \"2\", \"0.125\"], [\"MouseHandler\", \"1\", \"0.0625\"], [\"Anchor\", \"1\", \"0.0625\"], [\"RangeMap\", \"1\", \"0.0625\"]]"
        },
        {
            "content": "The `get_co_change_relationship` function has returned a list of entities along with their support count and confidence value. This indicates how often these files were modified together with `DisplayManager.java`. \n\nFor synchronization purposes, we focus on entities with higher confidence values (closer to 1), as they indicate a stronger co-change relationship. Based on the results:\n\n- **BufferChangeHandler** has the highest confidence (0.5625) and strong support (9 modifications together). This entity likely needs synchronization.\n- **FirstLine**, **ScrollLineCount**, and **ChunkCache** have moderate confidence (0.375) and support (6 modifications together). These might also need synchronization but are less critical than BufferChangeHandler.\n- The rest of the entities (e.g., HelpIndex, View, RingListModel, etc.) have lower confidence values (0.125 or less), indicating weaker co-change relationships.\n\nTo further analyze whether these entities should be synchronized, I will examine the coupling dependencies between `DisplayManager.java` and the top candidates for synchronization: `BufferChangeHandler`, `FirstLine`, and `ChunkCache`.\n\nI will now call the `get_coupling_dependencies` function for each pair of `DisplayManager.java` with:\n1. `BufferChangeHandler.java`\n2. `FirstLine.java`\n3. `ChunkCache.java`\n\nThis will help determine if there are direct dependencies between them.\n\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_17a79509c3e141f8b8a710",
                    "function": {
                        "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"BufferChangeHandler.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"BufferChangeHandler has been removed from the project due to project version iteration\"]"
        },
        {
            "content": "It appears that `BufferChangeHandler.java` has been removed from the project due to version iteration. This means it is no longer part of the current codebase and likely does not require synchronization with `DisplayManager.java`.\n\nLet\u2019s proceed by examining the coupling dependencies between `DisplayManager.java` and the next candidates: **FirstLine.java** and **ChunkCache.java**.\n\nI will now call the `get_coupling_dependencies` function for:\n1. `DisplayManager.java` and `FirstLine.java`\n2. `DisplayManager.java` and `ChunkCache.java`\n\nThis will help determine if there are any direct dependencies between these entities.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_f050ca9ac1fe43c6bc5502",
                    "function": {
                        "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"FirstLine.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"FirstLine has been removed from the project due to project version iteration\"]"
        },
        {
            "content": "Similar to `BufferChangeHandler.java`, the file `FirstLine.java` has also been removed from the project due to version iteration. Therefore, it is no longer part of the current codebase and does not require synchronization.\n\nLet\u2019s now focus on the next candidate: **ChunkCache.java**. I will check the coupling dependencies between `DisplayManager.java` and `ChunkCache.java` to determine if there is a direct dependency.\n\nI will proceed with calling the `get_coupling_dependencies` function for:\n- `DisplayManager.java` and `ChunkCache.java`\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_d39766bd180c4757b11add",
                    "function": {
                        "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"ChunkCache.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"There are no coupling dependencies between these two entities\"]"
        },
        {
            "content": "The analysis so far has revealed the following:\n\n- **BufferChangeHandler.java**, **FirstLine.java**, and **ChunkCache.java**, which showed moderate-to-high co-change relationships with `DisplayManager.java`, are either removed from the project or have no direct coupling dependencies with it.\n  \nThis suggests that while these files historically changed together, there are no current direct code-level dependencies between them and `DisplayManager.java`.\n\nTo continue the impact analysis, we should now explore other types of relationships\u2014specifically, whether `DisplayManager.java` directly calls or references any other entities in the system. This can be achieved by analyzing its **call graph**.\n\nI will now call the `get_call_graph` function on `DisplayManager.java` to identify the entities it interacts with directly through method calls or variable references.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_c881f0b9ea3a4c728b7147",
                    "function": {
                        "arguments": "{\"entity\": \"DisplayManager.java\"}",
                        "name": "get_call_graph"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_call_graph",
            "content": "[\"Log\", \"\", \"\"]"
        },
        {
            "content": "The call graph for `DisplayManager.java` only returns \"Log\", which appears to be a utility class (possibly related to logging) used within `DisplayManager.java`. However, no additional entities are listed, indicating that `DisplayManager.java` does not directly call or reference many other entities in the system.\n\nThis suggests that `DisplayManager.java` may operate with minimal direct dependencies on other files, which aligns with the earlier findings from coupling dependency analysis.\n\nTo gain deeper insight into its functionality and potential indirect relationships, I will now retrieve the **source code** of `DisplayManager.java` using the `get_origin_code` function. This will allow me to examine its internal structure, identify any indirect interactions, and determine whether synchronization with other components might still be necessary.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_feb958e73d1243158a1b12",
                    "function": {
                        "arguments": "{\"entity\": \"DisplayManager.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package org.gjt.sp.jedit.textarea;\\nimport java.awt.Toolkit;\\nimport java.util.*;\\nimport org.gjt.sp.jedit.buffer.*;\\nimport org.gjt.sp.jedit.*;\\nimport org.gjt.sp.util.Log;\\npublic class DisplayManager\\n{\\n\\tpublic static long scanCount, scannedLines;\\n\\t\\tstatic DisplayManager getDisplayManager(Buffer buffer,\\n\\t\\tJEditTextArea textArea)\\n\\t{\\n\\t\\tList l = (List)bufferMap.get(buffer);\\n\\t\\tDisplayManager dmgr;\\n\\t\\tif(l == null)\\n\\t\\t{\\n\\t\\t\\tl = new LinkedList();\\n\\t\\t\\tbufferMap.put(buffer,l);\\n\\t\\t}\\n\\t\\tIterator liter = l.iterator();\\n\\t\\twhile(liter.hasNext())\\n\\t\\t{\\n\\t\\t\\tdmgr = (DisplayManager)liter.next();\\n\\t\\t\\tif(!dmgr.inUse && dmgr.textArea == textArea)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdmgr.inUse = true;\\n\\t\\t\\t\\treturn dmgr;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tdmgr = new DisplayManager(buffer,textArea);\\n\\t\\tdmgr.inUse = true;\\n\\t\\tl.add(dmgr);\\n\\t\\treturn dmgr;\\n\\t} \\n\\t\\tstatic void releaseDisplayManager(DisplayManager dmgr)\\n\\t{\\n\\t\\tdmgr.inUse = false;\\n\\t} \\n\\t\\tpublic static void bufferClosed(Buffer buffer)\\n\\t{\\n\\t\\tbufferMap.remove(buffer);\\n\\t} \\n\\t\\tstatic void textAreaDisposed(JEditTextArea textArea)\\n\\t{\\n\\t\\tIterator biter = bufferMap.values().iterator();\\n\\t\\twhile(biter.hasNext())\\n\\t\\t{\\n\\t\\t\\tList l = (List)biter.next();\\n\\t\\t\\tIterator liter = l.iterator();\\n\\t\\t\\twhile(liter.hasNext())\\n\\t\\t\\t{\\n\\t\\t\\t\\tDisplayManager dmgr = (DisplayManager)\\n\\t\\t\\t\\t\\tliter.next();\\n\\t\\t\\t\\tif(dmgr.textArea == textArea)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdmgr.dispose();\\n\\t\\t\\t\\t\\tliter.remove();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tprivate static Map bufferMap = new HashMap();\\n\\tpublic final boolean isLineVisible(int line)\\n\\t{\\n\\t\\treturn fvmget(line) % 2 == 0;\\n\\t} \\n\\tpublic int getFirstVisibleLine()\\n\\t{\\n\\t\\treturn fvm[0];\\n\\t} \\n\\tpublic int getLastVisibleLine()\\n\\t{\\n\\t\\treturn fvm[fvmcount - 1] - 1;\\n\\t} \\n\\tpublic int getNextVisibleLine(int line)\\n\\t{\\n\\t\\tif(line < 0 || line >= buffer.getLineCount())\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(line);\\n\\t\\tint index = fvmget(line);\\n\\t\\tif(index % 2 != 0)\\n\\t\\t{\\n\\t\\t\\tif(fvmcount == index + 1)\\n\\t\\t\\t\\treturn - 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn fvm[index + 1];\\n\\t\\t}\\n\\t\\telse if(line == fvm[index + 1] - 1)\\n\\t\\t{\\n\\t\\t\\tif(fvmcount == index + 2)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn fvm[index + 2];\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn line + 1;\\n\\t} \\n\\tpublic int getPrevVisibleLine(int line)\\n\\t{\\n\\t\\tif(line < 0 || line >= buffer.getLineCount())\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(line);\\n\\t\\tint index = fvmget(line);\\n\\t\\tif(index == -1)\\n\\t\\t\\treturn -1;\\n\\t\\telse if(index % 2 == 1)\\n\\t\\t{\\n\\t\\t\\treturn fvm[index] - 1;\\n\\t\\t}\\n\\t\\telse if(line == fvm[index])\\n\\t\\t{\\n\\t\\t\\tif(index == 0)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn fvm[index - 1] - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn line - 1;\\n\\t} \\n\\t\\tpublic final int getScreenLineCount(int line)\\n\\t{\\n\\t\\tif(!screenLineMgr.isScreenLineCountValid(line))\\n\\t\\t\\tthrow new RuntimeException(\\\"Invalid screen line count: \\\" + line);\\n\\t\\treturn screenLineMgr.getScreenLineCount(line);\\n\\t} \\n\\t\\tpublic final int getScrollLineCount()\\n\\t{\\n\\t\\treturn scrollLineCount.scrollLine;\\n\\t} \\n\\tpublic void collapseFold(int line)\\n\\t{\\n\\t\\tint lineCount = buffer.getLineCount();\\n\\t\\tint start = 0;\\n\\t\\tint end = lineCount - 1;\\n\\t\\t\\t\\t\\t\\tif(line != 0\\n\\t\\t\\t&& line != buffer.getLineCount() - 1\\n\\t\\t\\t&& buffer.isFoldStart(line)\\n\\t\\t\\t&& !isLineVisible(line + 1))\\n\\t\\t{\\n\\t\\t\\tline--;\\n\\t\\t}\\n\\t\\tint initialFoldLevel = buffer.getFoldLevel(line);\\n\\t\\t\\t\\tif(line != lineCount - 1\\n\\t\\t\\t&& buffer.getFoldLevel(line + 1) > initialFoldLevel)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tstart = line + 1;\\n\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.getFoldLevel(i) <= initialFoldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tboolean ok = false;\\n\\t\\t\\t\\t\\t\\tfor(int i = line - 1; i >= 0; i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstart = i + 1;\\n\\t\\t\\t\\t\\tok = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(!ok)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\thideLineRange(start,end);\\n\\t\\tnotifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic int expandFold(int line, boolean fully)\\n\\t{\\n\\t\\t\\t\\tint returnValue = -1;\\n\\t\\tint lineCount = buffer.getLineCount();\\n\\t\\tint start = 0;\\n\\t\\tint end = lineCount - 1;\\n\\t\\tint initialFoldLevel = buffer.getFoldLevel(line);\\n\\t\\t\\t\\tif(line != lineCount - 1\\n\\t\\t\\t&& isLineVisible(line)\\n\\t\\t\\t&& !isLineVisible(line + 1)\\n\\t\\t\\t&& buffer.getFoldLevel(line + 1) > initialFoldLevel)\\n\\t\\t{\\n\\t\\t\\tint index = fvmget(line + 1);\\n\\t\\t\\tif(index == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\texpandAllFolds();\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\tstart = fvm[index];\\n\\t\\t\\tif(index != fvmcount - 1)\\n\\t\\t\\t\\tend = fvm[index + 1] - 1;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart = line + 1;\\n\\t\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(\\n\\t\\t\\t\\t\\t\\tbuffer.getFoldLevel(i) <= initialFoldLevel)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint index = fvmget(line);\\n\\t\\t\\tif(index == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\texpandAllFolds();\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\tstart = fvm[index];\\n\\t\\t\\tif(index != fvmcount - 1)\\n\\t\\t\\t\\tend = fvm[index + 1] - 1;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif((isLineVisible(i) &&\\n\\t\\t\\t\\t\\t\\tbuffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t\\t\\t|| i == getLastVisibleLine())\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tif(fully)\\n\\t\\t{\\n\\t\\t\\tshowLineRange(start,end);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tinitialFoldLevel = buffer.getFoldLevel(start);\\n\\t\\t\\tint firstVisible = start;\\n\\t\\t\\tfor(int i = start; i <= end; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.getFoldLevel(i) > initialFoldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(returnValue == -1\\n\\t\\t\\t\\t\\t\\t&& i != 0\\n\\t\\t\\t\\t\\t\\t&& buffer.isFoldStart(i - 1))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturnValue = i - 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(firstVisible != i)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tshowLineRange(firstVisible,i - 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfirstVisible = i + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(firstVisible != end + 1)\\n\\t\\t\\t\\tshowLineRange(firstVisible,end);\\n\\t\\t\\tif(!isLineVisible(line))\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\texpandFold(line,false);\\n\\t\\t\\t\\treturn returnValue;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tnotifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t\\treturn returnValue;\\n\\t} \\n\\tpublic void expandAllFolds()\\n\\t{\\n\\t\\tshowLineRange(0,buffer.getLineCount() - 1);\\n\\t\\tnotifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic void expandFolds(char digit)\\n\\t{\\n\\t\\tif(digit < '1' || digit > '9')\\n\\t\\t{\\n\\t\\t\\tToolkit.getDefaultToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\texpandFolds((int)(digit - '1') + 1);\\n\\t} \\n\\tpublic void expandFolds(int foldLevel)\\n\\t{\\n\\t\\tif(buffer.getFoldHandler() instanceof IndentFoldHandler)\\n\\t\\t\\tfoldLevel = (foldLevel - 1) * buffer.getIndentSize() + 1;\\n\\t\\tshowLineRange(0,buffer.getLineCount() - 1);\\n\\t\\tboolean seenVisibleLine = false;\\n\\t\\tint firstInvisible = 0;\\n\\t\\tfor(int i = 0; i < buffer.getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tif(!seenVisibleLine || buffer.getFoldLevel(i) < foldLevel)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(firstInvisible != i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\thideLineRange(firstInvisible,\\n\\t\\t\\t\\t\\t\\ti - 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfirstInvisible = i + 1;\\n\\t\\t\\t\\tseenVisibleLine = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(firstInvisible != buffer.getLineCount())\\n\\t\\t\\thideLineRange(firstInvisible,buffer.getLineCount() - 1);\\n\\t\\tnotifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic void narrow(int start, int end)\\n\\t{\\n\\t\\tif(start > end || start < 0 || end >= buffer.getLineCount())\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(start + \\\", \\\" + end);\\n\\t\\tif(start < getFirstVisibleLine() || end > getLastVisibleLine())\\n\\t\\t\\texpandAllFolds();\\n\\t\\tif(start != 0)\\n\\t\\t\\thideLineRange(0,start - 1);\\n\\t\\tif(end != buffer.getLineCount() - 1)\\n\\t\\t\\thideLineRange(end + 1,buffer.getLineCount() - 1);\\n\\t\\t\\t\\tif(start != buffer.getLineCount() - 1\\n\\t\\t\\t&& !isLineVisible(start + 1))\\n\\t\\t\\texpandFold(start,false);\\n\\t\\t\\t\\t\\t\\tGUIUtilities.getView(textArea).getStatus().setMessageAndClear(\\n\\t\\t\\tjEdit.getProperty(\\\"view.status.narrow\\\"));\\n\\t\\tnotifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\t\\tboolean softWrap;\\n\\tint wrapMargin;\\n\\tboolean wrapToWidth;\\n\\tFirstLine firstLine;\\n\\tScrollLineCount scrollLineCount;\\n\\t\\tvoid init()\\n\\t{\\n\\t\\tif(!initialized)\\n\\t\\t{\\n\\t\\t\\tinitialized = true;\\n\\t\\t\\tfvm = new int[2];\\n\\t\\t\\tif(buffer.isLoaded())\\n\\t\\t\\t\\tbufferChangeHandler.foldHandlerChanged(buffer);\\n\\t\\t\\telse\\n\\t\\t\\t\\tfvmreset();\\n\\t\\t\\tnotifyScreenLineChanges();\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tupdateWrapSettings();\\n\\t\\t\\tif(buffer.isLoaded())\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.reset();\\n\\t\\t\\t\\tscrollLineCount.reset();\\n\\t\\t\\t\\tnotifyScreenLineChanges();\\n\\t\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tvoid updateWrapSettings()\\n\\t{\\n\\t\\tString wrap = buffer.getStringProperty(\\\"wrap\\\");\\n\\t\\tsoftWrap = wrap.equals(\\\"soft\\\");\\n\\t\\tif(textArea.maxLineLen <= 0)\\n\\t\\t{\\n\\t\\t\\tif(softWrap)\\n\\t\\t\\t{\\n\\t\\t\\t\\twrapToWidth = true;\\n\\t\\t\\t\\twrapMargin = textArea.getPainter().getWidth()\\n\\t\\t\\t\\t\\t- textArea.charWidth * 3;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\twrapToWidth = false;\\n\\t\\t\\t\\twrapMargin = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tchar[] foo = new char[textArea.maxLineLen];\\n\\t\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfoo[i] = ' ';\\n\\t\\t\\t}\\n\\t\\t\\tTextAreaPainter painter = textArea.getPainter();\\n\\t\\t\\twrapToWidth = false;\\n\\t\\t\\twrapMargin = (int)painter.getFont().getStringBounds(\\n\\t\\t\\t\\tfoo,0,foo.length,\\n\\t\\t\\t\\tpainter.getFontRenderContext())\\n\\t\\t\\t\\t.getWidth();\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void clearNotifyFlags()\\n\\t{\\n\\t\\tfirstLine.callReset = firstLine.callChanged = false;\\n\\t\\tscrollLineCount.callReset = scrollLineCount.callChanged = false;\\n\\t} \\n\\t\\tvoid notifyScreenLineChanges()\\n\\t{\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"notifyScreenLineChanges()\\\");\\n\\t\\t\\t\\t\\t\\tif(textArea.getDisplayManager() != this)\\n\\t\\t\\treturn;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tif(firstLine.callReset)\\n\\t\\t\\t\\tfirstLine.reset();\\n\\t\\t\\telse if(firstLine.callChanged)\\n\\t\\t\\t\\tfirstLine.changed();\\n\\t\\t\\tif(scrollLineCount.callReset)\\n\\t\\t\\t\\tscrollLineCount.reset();\\n\\t\\t\\telse if(scrollLineCount.callChanged)\\n\\t\\t\\t\\tscrollLineCount.changed();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tclearNotifyFlags();\\n\\t\\t}\\n\\t} \\n\\t\\tvoid setFirstLine(int oldFirstLine, int firstLine)\\n\\t{\\n\\t\\tint visibleLines = textArea.getVisibleLines();\\n\\t\\tif(firstLine >= oldFirstLine + visibleLines)\\n\\t\\t{\\n\\t\\t\\tthis.firstLine.scrollDown(firstLine - oldFirstLine);\\n\\t\\t\\ttextArea.chunkCache.invalidateAll();\\n\\t\\t}\\n\\t\\telse if(firstLine <= oldFirstLine - visibleLines)\\n\\t\\t{\\n\\t\\t\\tthis.firstLine.scrollUp(oldFirstLine - firstLine);\\n\\t\\t\\ttextArea.chunkCache.invalidateAll();\\n\\t\\t}\\n\\t\\telse if(firstLine > oldFirstLine)\\n\\t\\t{\\n\\t\\t\\tthis.firstLine.scrollDown(firstLine - oldFirstLine);\\n\\t\\t\\ttextArea.chunkCache.scrollDown(firstLine - oldFirstLine);\\n\\t\\t}\\n\\t\\telse if(firstLine < oldFirstLine)\\n\\t\\t{\\n\\t\\t\\tthis.firstLine.scrollUp(oldFirstLine - firstLine);\\n\\t\\t\\ttextArea.chunkCache.scrollUp(oldFirstLine - firstLine);\\n\\t\\t}\\n\\t\\tnotifyScreenLineChanges();\\n\\t} \\t\\n\\t\\tvoid setFirstPhysicalLine(int amount, int skew)\\n\\t{\\n\\t\\tint oldFirstLine = textArea.getFirstLine();\\n\\t\\tif(amount == 0)\\n\\t\\t{\\n\\t\\t\\tskew -= this.firstLine.skew;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(skew < 0)\\n\\t\\t\\t\\tthis.firstLine.scrollUp(-skew);\\n\\t\\t\\telse if(skew > 0)\\n\\t\\t\\t\\tthis.firstLine.scrollDown(skew);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(amount > 0)\\n\\t\\t\\tthis.firstLine.physDown(amount,skew);\\n\\t\\telse if(amount < 0)\\n\\t\\t\\tthis.firstLine.physUp(-amount,skew);\\n\\t\\tint firstLine = textArea.getFirstLine();\\n\\t\\tint visibleLines = textArea.getVisibleLines();\\n\\t\\tif(firstLine == oldFirstLine)\\n\\t\\t\\t;\\n\\t\\telse if(firstLine >= oldFirstLine + visibleLines\\n\\t\\t\\t|| firstLine <= oldFirstLine - visibleLines)\\n\\t\\t{\\n\\t\\t\\ttextArea.chunkCache.invalidateAll();\\n\\t\\t}\\n\\t\\telse if(firstLine > oldFirstLine)\\n\\t\\t{\\n\\t\\t\\ttextArea.chunkCache.scrollDown(firstLine - oldFirstLine);\\n\\t\\t}\\n\\t\\telse if(firstLine < oldFirstLine)\\n\\t\\t{\\n\\t\\t\\ttextArea.chunkCache.scrollUp(oldFirstLine - firstLine);\\n\\t\\t}\\n\\t\\t\\t\\tnotifyScreenLineChanges();\\n\\t} \\n\\t\\tvoid invalidateScreenLineCounts()\\n\\t{\\n\\t\\tscreenLineMgr.invalidateScreenLineCounts();\\n\\t\\tfirstLine.callReset = true;\\n\\t\\tscrollLineCount.callReset = true;\\n\\t} \\n\\t\\tprivate boolean initialized;\\n\\tprivate boolean inUse;\\n\\tprivate Buffer buffer;\\n\\tprivate ScreenLineManager screenLineMgr;\\n\\tprivate JEditTextArea textArea;\\n\\tprivate BufferChangeHandler bufferChangeHandler;\\n\\tprivate int[] fvm;\\n\\tprivate int fvmcount;\\n\\tprivate int lastfvmget = -1;\\n\\t\\tprivate DisplayManager(Buffer buffer, JEditTextArea textArea)\\n\\t{\\n\\t\\tthis.buffer = buffer;\\n\\t\\tthis.screenLineMgr = new ScreenLineManager(this,buffer);\\n\\t\\tthis.textArea = textArea;\\n\\t\\tscrollLineCount = new ScrollLineCount();\\n\\t\\tfirstLine = new FirstLine();\\n\\t\\tbufferChangeHandler = new BufferChangeHandler();\\n\\t\\t\\t\\tbuffer.addBufferChangeListener(bufferChangeHandler,\\n\\t\\t\\tBuffer.HIGH_PRIORITY);\\n\\t} \\n\\t\\tprivate void dispose()\\n\\t{\\n\\t\\tbuffer.removeBufferChangeListener(bufferChangeHandler);\\n\\t} \\n\\t\\tprivate void fvmreset()\\n\\t{\\n\\t\\tlastfvmget = -1;\\n\\t\\tfvmcount = 2;\\n\\t\\tfvm[0] = 0;\\n\\t\\tfvm[1] = buffer.getLineCount();\\n\\t} \\n\\tprivate int fvmget(int line)\\n\\t{\\n\\t\\tscanCount++;\\n\\t\\tif(line < fvm[0])\\n\\t\\t\\treturn -1;\\n\\t\\tif(line >= fvm[fvmcount - 1])\\n\\t\\t\\treturn fvmcount - 1;\\n\\t\\tif(lastfvmget != -1)\\n\\t\\t{\\n\\t\\t\\tif(line >= fvm[lastfvmget])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(lastfvmget == fvmcount - 1\\n\\t\\t\\t\\t\\t|| line < fvm[lastfvmget + 1])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn lastfvmget;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint start = 0;\\n\\t\\tint end = fvmcount - 1;\\nloop:\\t\\tfor(;;)\\n\\t\\t{\\n\\t\\t\\tscannedLines++;\\n\\t\\t\\tswitch(end - start)\\n\\t\\t\\t{\\n\\t\\t\\tcase 0:\\n\\t\\t\\t\\tlastfvmget = start;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\tint value = fvm[end];\\n\\t\\t\\t\\tif(value <= line)\\n\\t\\t\\t\\t\\tlastfvmget = end;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tlastfvmget = start;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tint pivot = (end + start) / 2;\\n\\t\\t\\t\\tvalue = fvm[pivot];\\n\\t\\t\\t\\tif(value == line)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastfvmget = pivot;\\n\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(value < line)\\n\\t\\t\\t\\t\\tstart = pivot;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tend = pivot - 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn lastfvmget;\\n\\t} \\n\\tprivate void fvmput(int start, int end, int[] put)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tStringBuffer buf = new StringBuffer(\\\"{\\\");\\n\\t\\t\\tif(put != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i = 0; i < put.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(i != 0)\\n\\t\\t\\t\\t\\t\\tbuf.append(',');\\n\\t\\t\\t\\t\\tbuf.append(put[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tbuf.append(\\\"}\\\");\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"fvmput(\\\" + start + \\\",\\\"\\n\\t\\t\\t\\t+ end + \\\",\\\" + buf + \\\")\\\");\\n\\t\\t}\\n\\t\\tint putl = (put == null ? 0 : put.length);\\n\\t\\tint delta = putl - (end - start);\\n\\t\\tif(fvmcount + delta > fvm.length)\\n\\t\\t{\\n\\t\\t\\tint[] newfvm = new int[fvm.length * 2 + 1];\\n\\t\\t\\tSystem.arraycopy(fvm,0,newfvm,0,fvmcount);\\n\\t\\t\\tfvm = newfvm;\\n\\t\\t}\\n\\t\\tif(delta != 0)\\n\\t\\t{\\n\\t\\t\\tSystem.arraycopy(fvm,end,fvm,start + putl,\\n\\t\\t\\t\\tfvmcount - end);\\n\\t\\t}\\n\\t\\tif(putl != 0)\\n\\t\\t{\\n\\t\\t\\tSystem.arraycopy(put,0,fvm,start,put.length);\\n\\t\\t}\\n\\t\\tfvmcount += delta;\\n\\t\\tfvmdump();\\n\\t\\tif(fvmcount == 0)\\n\\t\\t\\tthrow new InternalError();\\n\\t} \\n\\tprivate void fvmput2(int starti, int endi, int start, int end)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"*fvmput2(\\\" + starti + \\\",\\\"\\n\\t\\t\\t\\t+ endi + \\\",\\\" + start + \\\",\\\" + end + \\\")\\\");\\n\\t\\t}\\n\\t\\tif(starti != -1 && fvm[starti] == start)\\n\\t\\t{\\n\\t\\t\\tif(endi <= fvmcount - 2 && fvm[endi + 1]\\n\\t\\t\\t\\t== end + 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti,endi + 2,null);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti,endi + 1,\\n\\t\\t\\t\\t\\tnew int[] { end + 1 });\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(endi != fvmcount - 1 && fvm[endi + 1]\\n\\t\\t\\t\\t== end + 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 2,\\n\\t\\t\\t\\t\\tnew int[] { start });\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 1,\\n\\t\\t\\t\\t\\tnew int[] { start,\\n\\t\\t\\t\\t\\tend + 1 });\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fvmdump()\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tStringBuffer buf = new StringBuffer(\\\"{\\\");\\n\\t\\t\\tfor(int i = 0; i < fvmcount; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i != 0)\\n\\t\\t\\t\\t\\tbuf.append(',');\\n\\t\\t\\t\\tbuf.append(fvm[i]);\\n\\t\\t\\t}\\n\\t\\t\\tbuf.append(\\\"}\\\");\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"fvm = \\\" + buf);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void showLineRange(int start, int end)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"showLineRange(\\\" + start\\n\\t\\t\\t\\t+ \\\",\\\" + end + \\\")\\\");\\n\\t\\t}\\n\\t\\tfor(int i = start; i <= end; i++)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(!isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tupdateScreenLineCount(i);\\n\\t\\t\\t\\tint screenLines = getScreenLineCount(i);\\n\\t\\t\\t\\tif(firstLine.physicalLine >= i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfirstLine.scrollLine += screenLines;\\n\\t\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tscrollLineCount.scrollLine += screenLines;\\n\\t\\t\\t\\tscrollLineCount.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint starti = fvmget(start);\\n\\t\\tint endi = fvmget(end);\\n\\t\\tif(starti % 2 == 0)\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 1,null);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(endi != fvmcount - 1\\n\\t\\t\\t\\t\\t&& fvm[endi + 1] == end + 1)\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi + 2,null);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\t\\tfvm[starti + 1] = end + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(starti != -1 && fvm[starti] == start)\\n\\t\\t\\t\\t\\tfvmput(starti,endi + 1,null);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\t\\tfvm[starti + 1] = start;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tfvmput2(starti,endi,start,end);\\n\\t\\t}\\n\\t\\tlastfvmget = -1;\\n\\t} \\n\\t\\tprivate void hideLineRange(int start, int end)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"hideLineRange(\\\" + start\\n\\t\\t\\t\\t+ \\\",\\\" + end + \\\")\\\");\\n\\t\\t}\\n\\t\\tint i = start;\\n\\t\\tif(!isLineVisible(i))\\n\\t\\t\\ti = getNextVisibleLine(i);\\n\\t\\twhile(i != -1 && i <= end)\\n\\t\\t{\\n\\t\\t\\tint screenLines = screenLineMgr.getScreenLineCount(i);\\n\\t\\t\\tif(i < firstLine.physicalLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.scrollLine -= screenLines;\\n\\t\\t\\t\\tfirstLine.skew = 0;\\n\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t\\tscrollLineCount.scrollLine -= screenLines;\\n\\t\\t\\tscrollLineCount.callChanged = true;\\n\\t\\t\\ti = getNextVisibleLine(i);\\n\\t\\t}\\n\\t\\tint starti = fvmget(start);\\n\\t\\tint endi = fvmget(end);\\n\\t\\tif(starti % 2 == 0)\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t\\tfvmput2(starti,endi,start,end);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(start == fvm[0])\\n\\t\\t\\t\\t\\tfvmput(starti,endi + 1,null);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\t\\tfvm[starti + 1] = start;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(end + 1 == fvm[fvmcount - 1])\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi + 2,null);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\t\\tfvm[starti + 1] = end + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 1,null);\\n\\t\\t}\\n\\t\\tlastfvmget = -1;\\n\\t\\tif(!isLineVisible(firstLine.physicalLine))\\n\\t\\t{\\n\\t\\t\\tint firstVisible = getFirstVisibleLine();\\n\\t\\t\\tif(firstLine.physicalLine < firstVisible)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.physicalLine = firstVisible;\\n\\t\\t\\t\\tfirstLine.scrollLine = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.physicalLine = getPrevVisibleLine(\\n\\t\\t\\t\\t\\tfirstLine.physicalLine);\\n\\t\\t\\t\\tfirstLine.scrollLine -=\\n\\t\\t\\t\\t\\tscreenLineMgr.getScreenLineCount(\\n\\t\\t\\t\\t\\tfirstLine.physicalLine);\\n\\t\\t\\t}\\n\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void updateScreenLineCount(int line)\\n\\t{\\n\\t\\tif(!screenLineMgr.isScreenLineCountValid(line))\\n\\t\\t{\\n\\t\\t\\tint newCount = textArea.chunkCache\\n\\t\\t\\t\\t.getLineSubregionCount(line);\\n\\t\\t\\tsetScreenLineCount(line,newCount);\\n\\t\\t}\\n\\t} \\n\\tprivate void setScreenLineCount(int line, int count)\\n\\t{\\n\\t\\tint oldCount = screenLineMgr.getScreenLineCount(line);\\n\\t\\tscreenLineMgr.setScreenLineCount(line,count);\\n\\t\\tif(count == oldCount)\\n\\t\\t\\treturn;\\n\\t\\tif(!isLineVisible(line))\\n\\t\\t\\treturn;\\n\\t\\tif(firstLine.physicalLine >= line)\\n\\t\\t{\\n\\t\\t\\tif(firstLine.physicalLine == line)\\n\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.scrollLine += (count - oldCount);\\n\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tscrollLineCount.scrollLine += (count - oldCount);\\n\\t\\tscrollLineCount.callChanged = true;\\n\\t} \\n\\t\\tstatic abstract class Anchor\\n\\t{\\n\\t\\tint physicalLine;\\n\\t\\tint scrollLine;\\n\\t\\tboolean callChanged;\\n\\t\\tboolean callReset;\\n\\t\\tabstract void reset();\\n\\t\\tabstract void changed();\\n\\t\\tpublic String toString()\\n\\t\\t{\\n\\t\\t\\treturn getClass().getName() + \\\"[\\\" + physicalLine + \\\",\\\"\\n\\t\\t\\t\\t+ scrollLine + \\\"]\\\";\\n\\t\\t}\\n\\t} \\n\\t\\tclass ScrollLineCount extends Anchor\\n\\t{\\n\\t\\t\\t\\tpublic void changed()\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"changed()\\\");\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t} \\n\\t\\t\\t\\tpublic void reset()\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"reset()\\\");\\n\\t\\t\\tphysicalLine = getFirstVisibleLine();\\n\\t\\t\\tint scrollLine = 0;\\n\\t\\t\\twhile(physicalLine != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tupdateScreenLineCount(physicalLine);\\n\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\tphysicalLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t}\\n\\t\\t\\tthis.scrollLine = scrollLine;\\n\\t\\t\\tphysicalLine = buffer.getLineCount();\\n\\t\\t\\tfirstLine.ensurePhysicalLineIsVisible();\\n\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t} \\t} \\n\\t\\tclass FirstLine extends Anchor\\n\\t{\\n\\t\\tint skew;\\n\\t\\t\\t\\tpublic void changed()\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"changed() before: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine\\n\\t\\t\\t\\t\\t+ \\\":\\\" + skew);\\n\\t\\t\\t} \\n\\t\\t\\tensurePhysicalLineIsVisible();\\n\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\tif(skew >= screenLines)\\n\\t\\t\\t\\tskew = screenLines - 1;\\n\\t\\t\\t\\t\\t\\tif(Debug.SCROLL_VERIFY)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSystem.err.println(\\\"SCROLL_VERIFY\\\");\\n\\t\\t\\t\\tint verifyScrollLine = 0;\\n\\t\\t\\t\\tfor(int i = 0; i < buffer.getLineCount(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!isLineVisible(i))\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\tif(i >= physicalLine)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tverifyScrollLine += getScreenLineCount(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(verifyScrollLine != scrollLine)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tException ex = new Exception(scrollLine + \\\":\\\" + verifyScrollLine);\\n\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,ex);\\n\\t\\t\\t\\t\\tnew org.gjt.sp.jedit.gui.BeanShellErrorDialog(null,ex);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"changed() after: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine\\n\\t\\t\\t\\t\\t+ \\\":\\\" + skew);\\n\\t\\t\\t} \\n\\t\\t\\tif(!scrollLineCount.callChanged\\n\\t\\t\\t\\t&& !scrollLineCount.callReset)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void reset()\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"reset()\\\");\\n\\t\\t\\tString wrap = buffer.getStringProperty(\\\"wrap\\\");\\n\\t\\t\\tsoftWrap = wrap.equals(\\\"soft\\\");\\n\\t\\t\\tif(textArea.maxLineLen <= 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsoftWrap = false;\\n\\t\\t\\t\\twrapMargin = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tchar[] foo = new char[textArea.maxLineLen];\\n\\t\\t\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfoo[i] = ' ';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tTextAreaPainter painter = textArea.getPainter();\\n\\t\\t\\t\\twrapMargin = (int)painter.getFont().getStringBounds(\\n\\t\\t\\t\\t\\tfoo,0,foo.length,\\n\\t\\t\\t\\t\\tpainter.getFontRenderContext())\\n\\t\\t\\t\\t\\t.getWidth();\\n\\t\\t\\t}\\n\\t\\t\\tscrollLine = 0;\\n\\t\\t\\tint i = getFirstVisibleLine();\\n\\t\\t\\tfor(;;)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i >= physicalLine)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tupdateScreenLineCount(i);\\n\\t\\t\\t\\tscrollLine += getScreenLineCount(i);\\n\\t\\t\\t\\tint nextLine = getNextVisibleLine(i);\\n\\t\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\ti = nextLine;\\n\\t\\t\\t}\\n\\t\\t\\tphysicalLine = i;\\n\\t\\t\\tupdateScreenLineCount(i);\\n\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\tif(skew >= screenLines)\\n\\t\\t\\t\\tskew = screenLines - 1;\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid physDown(int amount, int screenAmount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physDown() start: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tskew = 0;\\n\\t\\t\\tif(!isLineVisible(physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint lastVisibleLine = getLastVisibleLine();\\n\\t\\t\\t\\tif(physicalLine > lastVisibleLine)\\n\\t\\t\\t\\t\\tphysicalLine = lastVisibleLine;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint nextPhysicalLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tamount -= (nextPhysicalLine - physicalLine);\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = nextPhysicalLine;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(;;)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint nextPhysicalLine = getNextVisibleLine(\\n\\t\\t\\t\\t\\tphysicalLine);\\n\\t\\t\\t\\tif(nextPhysicalLine == -1)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse if(nextPhysicalLine > physicalLine + amount)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t\\tamount -= (nextPhysicalLine - physicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = nextPhysicalLine;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physDown() end: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tcallChanged = true;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(screenAmount < 0)\\n\\t\\t\\t\\tscrollUp(-screenAmount);\\n\\t\\t\\telse if(screenAmount > 0)\\n\\t\\t\\t\\tscrollDown(screenAmount);\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid physUp(int amount, int screenAmount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physUp() start: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tskew = 0;\\n\\t\\t\\tif(!isLineVisible(physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint firstVisibleLine = getFirstVisibleLine();\\n\\t\\t\\t\\tif(physicalLine < firstVisibleLine)\\n\\t\\t\\t\\t\\tphysicalLine = firstVisibleLine;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint prevPhysicalLine = getPrevVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tamount -= (physicalLine - prevPhysicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(;;)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint prevPhysicalLine = getPrevVisibleLine(\\n\\t\\t\\t\\t\\tphysicalLine);\\n\\t\\t\\t\\tif(prevPhysicalLine == -1)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse if(prevPhysicalLine < physicalLine - amount)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tamount -= (physicalLine - prevPhysicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = prevPhysicalLine;\\n\\t\\t\\t\\t\\tscrollLine -= getScreenLineCount(\\n\\t\\t\\t\\t\\t\\tprevPhysicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physUp() end: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tcallChanged = true;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(screenAmount < 0)\\n\\t\\t\\t\\tscrollUp(-screenAmount);\\n\\t\\t\\telse if(screenAmount > 0)\\n\\t\\t\\t\\tscrollDown(screenAmount);\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid scrollDown(int amount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"scrollDown()\\\");\\n\\t\\t\\tensurePhysicalLineIsVisible();\\n\\t\\t\\tamount += skew;\\n\\t\\t\\tskew = 0;\\n\\t\\t\\twhile(amount > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\t\\tif(amount < screenLines)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tskew = amount;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint nextLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tboolean visible = isLineVisible(physicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = nextLine;\\n\\t\\t\\t\\t\\tif(visible)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tamount -= screenLines;\\n\\t\\t\\t\\t\\t\\tscrollLine += screenLines;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcallChanged = true;\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid scrollUp(int amount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"scrollUp()\\\");\\n\\t\\t\\tensurePhysicalLineIsVisible();\\n\\t\\t\\tif(amount <= skew)\\n\\t\\t\\t{\\n\\t\\t\\t\\tskew -= amount;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tamount -= skew;\\n\\t\\t\\t\\tskew = 0;\\n\\t\\t\\t\\twhile(amount > 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint prevLine = getPrevVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tif(prevLine == -1)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tphysicalLine = prevLine;\\n\\t\\t\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t\\tscrollLine -= screenLines;\\n\\t\\t\\t\\t\\tif(amount < screenLines)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tskew = screenLines - amount;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tamount -= screenLines;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcallChanged = true;\\n\\t\\t} \\n\\t\\t\\t\\tprivate void ensurePhysicalLineIsVisible()\\n\\t\\t{\\n\\t\\t\\tif(!isLineVisible(physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(physicalLine > getLastVisibleLine())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysicalLine = getLastVisibleLine();\\n\\t\\t\\t\\t\\tscrollLine = getScrollLineCount() - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(physicalLine < getFirstVisibleLine())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysicalLine = getFirstVisibleLine();\\n\\t\\t\\t\\t\\tscrollLine = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysicalLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\t} \\n\\tclass BufferChangeHandler extends BufferChangeAdapter\\n\\t{\\n\\t\\tboolean delayedUpdate;\\n\\t\\tboolean delayedMultilineUpdate;\\n\\t\\tint delayedUpdateStart;\\n\\t\\tint delayedUpdateEnd;\\n\\t\\t\\t\\tpublic void foldHandlerChanged(Buffer buffer)\\n\\t\\t{\\n\\t\\t\\tfvmreset();\\n\\t\\t\\tfirstLine.reset();\\n\\t\\t\\tscrollLineCount.reset();\\n\\t\\t\\tint collapseFolds = buffer.getIntegerProperty(\\n\\t\\t\\t\\t\\\"collapseFolds\\\",0);\\n\\t\\t\\tif(collapseFolds != 0)\\n\\t\\t\\t\\texpandFolds(collapseFolds);\\n\\t\\t} \\n\\t\\t\\t\\tpublic void foldLevelChanged(Buffer buffer, int start, int end)\\n\\t\\t{\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this\\n\\t\\t\\t\\t&& end != 0 && buffer.isLoaded())\\n\\t\\t\\t{\\n\\t\\t\\t\\ttextArea.invalidateLineRange(start - 1,\\n\\t\\t\\t\\t\\ttextArea.getLastPhysicalLine());\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void contentInserted(Buffer buffer, int startLine,\\n\\t\\t\\tint offset, int numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmreset();\\n\\t\\t\\t\\tscreenLineMgr.reset();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tscreenLineMgr.contentInserted(startLine,numLines);\\n\\t\\t\\tint endLine = startLine + numLines;\\n\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedMultilineUpdate = true;\\n\\t\\t\\t\\tint index = fvmget(startLine);\\n\\t\\t\\t\\tint start = index + 1;\\n\\t\\t\\t\\tfor(int i = start; i < fvmcount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvm[i] += numLines;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlastfvmget = -1;\\n\\t\\t\\t\\tfvmdump();\\n\\t\\t\\t}\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcontentInserted(firstLine,startLine,numLines);\\n\\t\\t\\t\\t\\tcontentInserted(scrollLineCount,startLine,numLines);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(delayedUpdateEnd >= startLine)\\n\\t\\t\\t\\t\\tdelayedUpdateEnd += numLines;\\n\\t\\t\\t\\tdelayedUpdate(startLine,endLine);\\n\\t\\t\\t\\t\\t\\t\\t\\tIterator iter = textArea.getSelectionIterator();\\n\\t\\t\\t\\twhile(iter.hasNext())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection s = (Selection)iter.next();\\n\\t\\t\\t\\t\\tif(s.contentInserted(buffer,startLine,offset,\\n\\t\\t\\t\\t\\t\\tnumLines,length))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdelayedUpdate(s.startLine,s.endLine);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tint caret = textArea.getCaretPosition();\\n\\t\\t\\t\\tif(caret >= offset)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.ELECTRIC_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(\\n\\t\\t\\t\\t\\t\\tcaret + length,scrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.NORMAL_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(\\n\\t\\t\\t\\t\\t\\tcaret,scrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void preContentRemoved(Buffer buffer, int startLine,\\n\\t\\t\\tint offset, int numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tdelayedMultilineUpdate = true;\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tpreContentRemoved(firstLine,startLine,numLines);\\n\\t\\t\\t\\t\\tpreContentRemoved(scrollLineCount,startLine,numLines);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(delayedUpdateEnd >= startLine)\\n\\t\\t\\t\\t\\tdelayedUpdateEnd -= numLines;\\n\\t\\t\\t\\tdelayedUpdate(startLine,startLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\t}\\n\\t\\t\\tif(numLines == 0)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tscreenLineMgr.contentRemoved(startLine,numLines);\\n\\t\\t\\tint endLine = startLine + numLines;\\n\\t\\t\\tint starti = fvmget(startLine);\\n\\t\\t\\tint endi = fvmget(endLine);\\n\\t\\t\\tif(Math.abs(starti % 2) == Math.abs(endi % 2))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(endi - starti == fvmcount)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfvmreset();\\n\\t\\t\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\t\\t\\tstarti = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi + 1,null);\\n\\t\\t\\t\\t\\tstarti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(starti != -1 && fvm[starti] == startLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(endi - starti == fvmcount - 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfvmreset();\\n\\t\\t\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\t\\t\\tstarti = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tfvmput(starti,endi + 1,null);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\tfvm[starti + 1] = startLine;\\n\\t\\t\\t\\tstarti += 2;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = starti; i < fvmcount; i++)\\n\\t\\t\\t\\tfvm[i] -= numLines;\\n\\t\\t\\tif(firstLine.physicalLine\\n\\t\\t\\t\\t> getLastVisibleLine()\\n\\t\\t\\t\\t|| firstLine.physicalLine\\n\\t\\t\\t\\t< getFirstVisibleLine())\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\telse if(!isLineVisible(\\n\\t\\t\\t\\tfirstLine.physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.physicalLine =\\n\\t\\t\\t\\t\\tgetNextVisibleLine(\\n\\t\\t\\t\\t\\tfirstLine.physicalLine);\\n\\t\\t\\t}\\n\\t\\t\\tlastfvmget = -1;\\n\\t\\t\\tfvmdump();\\n\\t\\t} \\n\\t\\t\\t\\tpublic void contentRemoved(Buffer buffer, int startLine,\\n\\t\\t\\tint start, int numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tIterator iter = textArea.getSelectionIterator();\\n\\t\\t\\t\\twhile(iter.hasNext())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection s = (Selection)iter.next();\\n\\t\\t\\t\\t\\tif(s.contentRemoved(buffer,startLine,\\n\\t\\t\\t\\t\\t\\tstart,numLines,length))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdelayedUpdate(s.startLine,s.endLine);\\n\\t\\t\\t\\t\\t\\tif(s.start == s.end)\\n\\t\\t\\t\\t\\t\\t\\titer.remove();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tint caret = textArea.getCaretPosition();\\n\\t\\t\\t\\tif(caret >= start + length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.ELECTRIC_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(\\n\\t\\t\\t\\t\\t\\tcaret - length,\\n\\t\\t\\t\\t\\t\\tscrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(caret >= start)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.ELECTRIC_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(\\n\\t\\t\\t\\t\\t\\tstart,scrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.NORMAL_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(caret,scrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tpublic void transactionComplete(Buffer buffer)\\n\\t\\t{\\n\\t\\t\\tif(textArea.getDisplayManager() != DisplayManager.this)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedUpdate = false;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(delayedUpdate)\\n\\t\\t\\t\\tdoDelayedUpdate();\\n\\t\\t\\ttextArea._finishCaretUpdate();\\n\\t\\t\\tdelayedUpdate = false;\\n\\t\\t\\t\\t\\t\\tif(Debug.SCROLL_VERIFY)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint scrollLineCount = 0;\\n\\t\\t\\t\\tint line = delayedUpdateStart;\\n\\t\\t\\t\\tif(!isLineVisible(line))\\n\\t\\t\\t\\t\\tline = getNextVisibleLine(line);\\n\\t\\t\\t\\tSystem.err.println(delayedUpdateStart + \\\":\\\" + delayedUpdateEnd + \\\":\\\" + textArea.getLineCount());\\n\\t\\t\\t\\twhile(line != -1 && line <= delayedUpdateEnd)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscrollLineCount += getScreenLineCount(line);\\n\\t\\t\\t\\t\\tline = getNextVisibleLine(line);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(scrollLineCount != getScrollLineCount())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tthrow new InternalError(scrollLineCount\\n\\t\\t\\t\\t\\t\\t+ \\\" != \\\"\\n\\t\\t\\t\\t\\t\\t+ getScrollLineCount());\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\t\\t} \\n\\t\\t\\t\\tprivate void doDelayedUpdate()\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tint _firstLine = textArea.getFirstPhysicalLine();\\n\\t\\t\\tint _lastLine = textArea.getLastPhysicalLine();\\n\\t\\t\\tint line = delayedUpdateStart;\\n\\t\\t\\tif(!isLineVisible(line))\\n\\t\\t\\t\\tline = getNextVisibleLine(line);\\n\\t\\t\\twhile(line != -1 && line <= delayedUpdateEnd)\\n\\t\\t\\t{\\n\\t\\t\\t\\tupdateScreenLineCount(line);\\n\\t\\t\\t\\tline = getNextVisibleLine(line);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnotifyScreenLineChanges();\\n\\t\\t\\tif(delayedMultilineUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttextArea.invalidateScreenLineRange(\\n\\t\\t\\t\\t\\ttextArea.chunkCache\\n\\t\\t\\t\\t\\t.getScreenLineOfOffset(\\n\\t\\t\\t\\t\\tdelayedUpdateStart,0),\\n\\t\\t\\t\\t\\ttextArea.getVisibleLines());\\n\\t\\t\\t\\tdelayedMultilineUpdate = false;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\ttextArea.invalidateLineRange(\\n\\t\\t\\t\\t\\tdelayedUpdateStart,\\n\\t\\t\\t\\t\\tdelayedUpdateEnd);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tint visibleLines = textArea.getVisibleLines();\\n\\t\\t\\tif(visibleLines != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttextArea.chunkCache.getLineInfo(\\n\\t\\t\\t\\t\\tvisibleLines - 1);\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.getFoldLevel(delayedUpdateEnd);\\n\\t\\t} \\n\\t\\t\\t\\tprivate void contentInserted(Anchor anchor, int startLine,\\n\\t\\t\\tint numLines)\\n\\t\\t{\\n\\t\\t\\tif(anchor.physicalLine >= startLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(anchor.physicalLine != startLine)\\n\\t\\t\\t\\t\\tanchor.physicalLine += numLines;\\n\\t\\t\\t\\tanchor.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void preContentRemoved(Anchor anchor, int startLine,\\n\\t\\t\\tint numLines)\\n\\t\\t{\\n\\t\\t\\tif(anchor.physicalLine >= startLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(anchor.physicalLine == startLine)\\n\\t\\t\\t\\t\\tanchor.callChanged = true;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint end = Math.min(startLine + numLines,\\n\\t\\t\\t\\t\\t\\tanchor.physicalLine);\\n\\t\\t\\t\\t\\tfor(int i = startLine; i < end; i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(isLineVisible(i))\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tanchor.scrollLine -=\\n\\t\\t\\t\\t\\t\\t\\t\\tscreenLineMgr\\n\\t\\t\\t\\t\\t\\t\\t\\t.getScreenLineCount(i);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tanchor.physicalLine -= (end - startLine);\\n\\t\\t\\t\\t\\tanchor.callChanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void delayedUpdate(int startLine, int endLine)\\n\\t\\t{\\n\\t\\t\\ttextArea.chunkCache.invalidateChunksFromPhys(startLine);\\n\\t\\t\\tif(!delayedUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedUpdateStart = startLine;\\n\\t\\t\\t\\tdelayedUpdateEnd = endLine;\\n\\t\\t\\t\\tdelayedUpdate = true;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedUpdateStart = Math.min(\\n\\t\\t\\t\\t\\tdelayedUpdateStart,\\n\\t\\t\\t\\t\\tstartLine);\\n\\t\\t\\t\\tdelayedUpdateEnd = Math.max(\\n\\t\\t\\t\\t\\tdelayedUpdateEnd,\\n\\t\\t\\t\\t\\tendLine);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tprivate boolean caretAutoScroll()\\n\\t\\t{\\n\\t\\t\\tView view = textArea.getView();\\n\\t\\t\\treturn view == jEdit.getActiveView()\\n\\t\\t\\t\\t&& view.getTextArea() == textArea;\\n\\t\\t} \\t} }\""
        },
        {
            "content": "After analyzing the source code of `DisplayManager.java`, here are key observations and conclusions:\n\n### Key Observations:\n1. **Purpose**:\n   - `DisplayManager` manages how lines of text are displayed in a `JEditTextArea`. It handles visibility, scrolling, folding (collapsing/expanding blocks of text), and screen-line calculations.\n\n2. **Core Dependencies**:\n   - Uses utility classes like `Log` for logging.\n   - Depends on several internal jEdit components such as:\n     - `Buffer`, `JEditTextArea`, `TextAreaPainter`\n     - Inner classes like `ScrollLineCount`, `FirstLine`, and `BufferChangeHandler`\n   - These dependencies are mostly instantiated or referenced internally within `DisplayManager`.\n\n3. **Coupling and Co-Change Insights**:\n   - Despite historical co-change relationships with files like `BufferChangeHandler.java`, `FirstLine.java`, and `ChunkCache.java`, there are no current direct coupling dependencies between them and `DisplayManager.java`.\n   - The only entities tightly coupled with `DisplayManager` are inner classes defined within it (e.g., `ScrollLineCount`, `FirstLine`, `BufferChangeHandler`), which do not require synchronization as they are encapsulated.\n\n4. **Call Graph**:\n   - Only calls `Log`, indicating minimal external interaction beyond its own logic and inner classes.\n\n### Conclusion:\nThere is **no need to synchronize any external entities** with `DisplayManager.java`. Its dependencies are either:\n- Internal (inner classes),\n- Removed from the project (`BufferChangeHandler`, `FirstLine`),\n- Or have no direct coupling (`ChunkCache`).\n\nThe class operates independently, maintaining its own state and logic for display behavior in `jEdit`.\n\nIf you'd like, we can proceed to analyze other entities or summarize this CIA task.",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        },
        {
            "role": "user",
            "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
        },
        {
            "content": "Title: Diagnosis of starting entity `DisplayManager`\n\nChange set: [BufferChangeHandler, FirstLine, ChunkCache, HelpIndex, HelpTOCPanel, View, RingListModel, OffsetManager, PosBottomHalf, PositionManager, PasteFromListDialog, ListHandler, KeyHandler, FontSelector, FontSelectorDialog, TextAreaOptionPane, ActionHandler, JEditTextArea, TextAreaPainter, EditPane, BeanShell, MouseHandler, Anchor, RangeMap, Log, ScreenLineManager, ScrollLineCount, BufferIORequest, Buffer, JEditTextArea, DisplayManager$ScrollLineCount, DisplayManager$FirstLine, DisplayManager$BufferChangeHandler, DisplayManager$Anchor]\n\nDetails:\n- **BufferChangeHandler**: Historically co-changed with high support (9) and confidence (0.5625), though removed in current version.\n- **FirstLine**: Frequently co-changed (support 6, confidence 0.375), but also removed in current version.\n- **ChunkCache**: Co-changed with moderate confidence (0.375), no coupling found, possibly involved in rendering or caching visible lines.\n- **HelpIndex, HelpTOCPanel, View**: Low confidence (0.125), may be involved in UI synchronization or event propagation.\n- **RingListModel, OffsetManager, PosBottomHalf, PositionManager, PasteFromListDialog, ListHandler, KeyHandler, FontSelector, FontSelectorDialog, TextAreaOptionPane, ActionHandler**: Low-to-moderate co-change values, possibly involved in UI interaction or configuration tied to display behavior.\n- **JEditTextArea, TextAreaPainter, EditPane**: Likely involved in direct rendering or text handling; part of the same package and tightly integrated with display logic.\n- **BeanShell, MouseHandler, Anchor, RangeMap**: Minimal impact, low co-change values, but referenced in code contextually (e.g., folding, selection).\n- **Log**: Appears in call graph; used for logging within display operations.\n- **ScreenLineManager**: Directly used by `DisplayManager` for screen-line calculations.\n- **ScrollLineCount**: Inner class managing scroll bar updates.\n- **Buffer**: Core dependency for line and fold data.\n- **DisplayManager$ScrollLineCount, DisplayManager$FirstLine, DisplayManager$BufferChangeHandler, DisplayManager$Anchor**: Internal classes directly manipulated by `DisplayManager`, subject to change if core logic is altered.\n- **BufferIORequest**: Co-changed moderately (support 4, confidence 0.25), possibly involved in buffer lifecycle events.\n\nThese entities are included based on historical co-change relationships, semantic coupling, or direct usage in managing text display, scrolling, and folding logic in jEdit.",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        }
    ],
    "interaction_records": {
        "step_histories": [
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4"
                ],
                "response_message": "m5"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6"
                ],
                "response_message": "m7"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8"
                ],
                "response_message": "m9"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10"
                ],
                "response_message": "m11"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12"
                ],
                "response_message": "m13"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14"
                ],
                "response_message": "m15"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14",
                    "m15",
                    "m16"
                ],
                "response_message": "m17"
            }
        ],
        "mid_to_message": {
            "m1": {
                "role": "system",
                "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
            },
            "m2": {
                "role": "user",
                "content": "The project you need to analyze is `jEdit`, a well-known Java open source project. The starting entity you need to deal with is DisplayManager.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
            },
            "m3": {
                "content": "",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_5e44046aebd74e10b30f16",
                        "function": {
                            "arguments": "{\"entity\": \"DisplayManager.java\"}",
                            "name": "get_co_change_relationship"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m4": {
                "name": "get_co_change_relationship",
                "role": "tool",
                "content": "[[\"FirstLine\", \"6\", \"0.375\"], [\"ScrollLineCount\", \"6\", \"0.375\"], [\"ChunkCache\", \"6\", \"0.375\"], [\"HelpIndex\", \"2\", \"0.125\"], [\"HelpTOCPanel\", \"2\", \"0.125\"], [\"View\", \"2\", \"0.125\"], [\"BufferChangeHandler\", \"9\", \"0.5625\"], [\"BufferIORequest\", \"4\", \"0.25\"], [\"RingListModel\", \"2\", \"0.125\"], [\"OffsetManager\", \"2\", \"0.125\"], [\"PosBottomHalf\", \"2\", \"0.125\"], [\"PositionManager\", \"2\", \"0.125\"], [\"PasteFromListDialog\", \"2\", \"0.125\"], [\"ListHandler\", \"2\", \"0.125\"], [\"KeyHandler\", \"2\", \"0.125\"], [\"FontSelector\", \"2\", \"0.125\"], [\"FontSelectorDialog\", \"2\", \"0.125\"], [\"TextAreaOptionPane\", \"2\", \"0.125\"], [\"ActionHandler\", \"2\", \"0.125\"], [\"JEditTextArea\", \"3\", \"0.1875\"], [\"TextAreaPainter\", \"2\", \"0.125\"], [\"EditPane\", \"2\", \"0.125\"], [\"BeanShell\", \"2\", \"0.125\"], [\"MouseHandler\", \"1\", \"0.0625\"], [\"Anchor\", \"1\", \"0.0625\"], [\"RangeMap\", \"1\", \"0.0625\"]]"
            },
            "m5": {
                "content": "The `get_co_change_relationship` function has returned a list of entities along with their support count and confidence value. This indicates how often these files were modified together with `DisplayManager.java`. \n\nFor synchronization purposes, we focus on entities with higher confidence values (closer to 1), as they indicate a stronger co-change relationship. Based on the results:\n\n- **BufferChangeHandler** has the highest confidence (0.5625) and strong support (9 modifications together). This entity likely needs synchronization.\n- **FirstLine**, **ScrollLineCount**, and **ChunkCache** have moderate confidence (0.375) and support (6 modifications together). These might also need synchronization but are less critical than BufferChangeHandler.\n- The rest of the entities (e.g., HelpIndex, View, RingListModel, etc.) have lower confidence values (0.125 or less), indicating weaker co-change relationships.\n\nTo further analyze whether these entities should be synchronized, I will examine the coupling dependencies between `DisplayManager.java` and the top candidates for synchronization: `BufferChangeHandler`, `FirstLine`, and `ChunkCache`.\n\nI will now call the `get_coupling_dependencies` function for each pair of `DisplayManager.java` with:\n1. `BufferChangeHandler.java`\n2. `FirstLine.java`\n3. `ChunkCache.java`\n\nThis will help determine if there are direct dependencies between them.\n\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_17a79509c3e141f8b8a710",
                        "function": {
                            "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"BufferChangeHandler.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m6": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"BufferChangeHandler has been removed from the project due to project version iteration\"]"
            },
            "m7": {
                "content": "It appears that `BufferChangeHandler.java` has been removed from the project due to version iteration. This means it is no longer part of the current codebase and likely does not require synchronization with `DisplayManager.java`.\n\nLet\u2019s proceed by examining the coupling dependencies between `DisplayManager.java` and the next candidates: **FirstLine.java** and **ChunkCache.java**.\n\nI will now call the `get_coupling_dependencies` function for:\n1. `DisplayManager.java` and `FirstLine.java`\n2. `DisplayManager.java` and `ChunkCache.java`\n\nThis will help determine if there are any direct dependencies between these entities.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_f050ca9ac1fe43c6bc5502",
                        "function": {
                            "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"FirstLine.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m8": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"FirstLine has been removed from the project due to project version iteration\"]"
            },
            "m9": {
                "content": "Similar to `BufferChangeHandler.java`, the file `FirstLine.java` has also been removed from the project due to version iteration. Therefore, it is no longer part of the current codebase and does not require synchronization.\n\nLet\u2019s now focus on the next candidate: **ChunkCache.java**. I will check the coupling dependencies between `DisplayManager.java` and `ChunkCache.java` to determine if there is a direct dependency.\n\nI will proceed with calling the `get_coupling_dependencies` function for:\n- `DisplayManager.java` and `ChunkCache.java`\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_d39766bd180c4757b11add",
                        "function": {
                            "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"ChunkCache.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m10": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"There are no coupling dependencies between these two entities\"]"
            },
            "m11": {
                "content": "The analysis so far has revealed the following:\n\n- **BufferChangeHandler.java**, **FirstLine.java**, and **ChunkCache.java**, which showed moderate-to-high co-change relationships with `DisplayManager.java`, are either removed from the project or have no direct coupling dependencies with it.\n  \nThis suggests that while these files historically changed together, there are no current direct code-level dependencies between them and `DisplayManager.java`.\n\nTo continue the impact analysis, we should now explore other types of relationships\u2014specifically, whether `DisplayManager.java` directly calls or references any other entities in the system. This can be achieved by analyzing its **call graph**.\n\nI will now call the `get_call_graph` function on `DisplayManager.java` to identify the entities it interacts with directly through method calls or variable references.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_c881f0b9ea3a4c728b7147",
                        "function": {
                            "arguments": "{\"entity\": \"DisplayManager.java\"}",
                            "name": "get_call_graph"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m12": {
                "role": "tool",
                "name": "get_call_graph",
                "content": "[\"Log\", \"\", \"\"]"
            },
            "m13": {
                "content": "The call graph for `DisplayManager.java` only returns \"Log\", which appears to be a utility class (possibly related to logging) used within `DisplayManager.java`. However, no additional entities are listed, indicating that `DisplayManager.java` does not directly call or reference many other entities in the system.\n\nThis suggests that `DisplayManager.java` may operate with minimal direct dependencies on other files, which aligns with the earlier findings from coupling dependency analysis.\n\nTo gain deeper insight into its functionality and potential indirect relationships, I will now retrieve the **source code** of `DisplayManager.java` using the `get_origin_code` function. This will allow me to examine its internal structure, identify any indirect interactions, and determine whether synchronization with other components might still be necessary.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_feb958e73d1243158a1b12",
                        "function": {
                            "arguments": "{\"entity\": \"DisplayManager.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m14": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package org.gjt.sp.jedit.textarea;\\nimport java.awt.Toolkit;\\nimport java.util.*;\\nimport org.gjt.sp.jedit.buffer.*;\\nimport org.gjt.sp.jedit.*;\\nimport org.gjt.sp.util.Log;\\npublic class DisplayManager\\n{\\n\\tpublic static long scanCount, scannedLines;\\n\\t\\tstatic DisplayManager getDisplayManager(Buffer buffer,\\n\\t\\tJEditTextArea textArea)\\n\\t{\\n\\t\\tList l = (List)bufferMap.get(buffer);\\n\\t\\tDisplayManager dmgr;\\n\\t\\tif(l == null)\\n\\t\\t{\\n\\t\\t\\tl = new LinkedList();\\n\\t\\t\\tbufferMap.put(buffer,l);\\n\\t\\t}\\n\\t\\tIterator liter = l.iterator();\\n\\t\\twhile(liter.hasNext())\\n\\t\\t{\\n\\t\\t\\tdmgr = (DisplayManager)liter.next();\\n\\t\\t\\tif(!dmgr.inUse && dmgr.textArea == textArea)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdmgr.inUse = true;\\n\\t\\t\\t\\treturn dmgr;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tdmgr = new DisplayManager(buffer,textArea);\\n\\t\\tdmgr.inUse = true;\\n\\t\\tl.add(dmgr);\\n\\t\\treturn dmgr;\\n\\t} \\n\\t\\tstatic void releaseDisplayManager(DisplayManager dmgr)\\n\\t{\\n\\t\\tdmgr.inUse = false;\\n\\t} \\n\\t\\tpublic static void bufferClosed(Buffer buffer)\\n\\t{\\n\\t\\tbufferMap.remove(buffer);\\n\\t} \\n\\t\\tstatic void textAreaDisposed(JEditTextArea textArea)\\n\\t{\\n\\t\\tIterator biter = bufferMap.values().iterator();\\n\\t\\twhile(biter.hasNext())\\n\\t\\t{\\n\\t\\t\\tList l = (List)biter.next();\\n\\t\\t\\tIterator liter = l.iterator();\\n\\t\\t\\twhile(liter.hasNext())\\n\\t\\t\\t{\\n\\t\\t\\t\\tDisplayManager dmgr = (DisplayManager)\\n\\t\\t\\t\\t\\tliter.next();\\n\\t\\t\\t\\tif(dmgr.textArea == textArea)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdmgr.dispose();\\n\\t\\t\\t\\t\\tliter.remove();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tprivate static Map bufferMap = new HashMap();\\n\\tpublic final boolean isLineVisible(int line)\\n\\t{\\n\\t\\treturn fvmget(line) % 2 == 0;\\n\\t} \\n\\tpublic int getFirstVisibleLine()\\n\\t{\\n\\t\\treturn fvm[0];\\n\\t} \\n\\tpublic int getLastVisibleLine()\\n\\t{\\n\\t\\treturn fvm[fvmcount - 1] - 1;\\n\\t} \\n\\tpublic int getNextVisibleLine(int line)\\n\\t{\\n\\t\\tif(line < 0 || line >= buffer.getLineCount())\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(line);\\n\\t\\tint index = fvmget(line);\\n\\t\\tif(index % 2 != 0)\\n\\t\\t{\\n\\t\\t\\tif(fvmcount == index + 1)\\n\\t\\t\\t\\treturn - 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn fvm[index + 1];\\n\\t\\t}\\n\\t\\telse if(line == fvm[index + 1] - 1)\\n\\t\\t{\\n\\t\\t\\tif(fvmcount == index + 2)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn fvm[index + 2];\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn line + 1;\\n\\t} \\n\\tpublic int getPrevVisibleLine(int line)\\n\\t{\\n\\t\\tif(line < 0 || line >= buffer.getLineCount())\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(line);\\n\\t\\tint index = fvmget(line);\\n\\t\\tif(index == -1)\\n\\t\\t\\treturn -1;\\n\\t\\telse if(index % 2 == 1)\\n\\t\\t{\\n\\t\\t\\treturn fvm[index] - 1;\\n\\t\\t}\\n\\t\\telse if(line == fvm[index])\\n\\t\\t{\\n\\t\\t\\tif(index == 0)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn fvm[index - 1] - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn line - 1;\\n\\t} \\n\\t\\tpublic final int getScreenLineCount(int line)\\n\\t{\\n\\t\\tif(!screenLineMgr.isScreenLineCountValid(line))\\n\\t\\t\\tthrow new RuntimeException(\\\"Invalid screen line count: \\\" + line);\\n\\t\\treturn screenLineMgr.getScreenLineCount(line);\\n\\t} \\n\\t\\tpublic final int getScrollLineCount()\\n\\t{\\n\\t\\treturn scrollLineCount.scrollLine;\\n\\t} \\n\\tpublic void collapseFold(int line)\\n\\t{\\n\\t\\tint lineCount = buffer.getLineCount();\\n\\t\\tint start = 0;\\n\\t\\tint end = lineCount - 1;\\n\\t\\t\\t\\t\\t\\tif(line != 0\\n\\t\\t\\t&& line != buffer.getLineCount() - 1\\n\\t\\t\\t&& buffer.isFoldStart(line)\\n\\t\\t\\t&& !isLineVisible(line + 1))\\n\\t\\t{\\n\\t\\t\\tline--;\\n\\t\\t}\\n\\t\\tint initialFoldLevel = buffer.getFoldLevel(line);\\n\\t\\t\\t\\tif(line != lineCount - 1\\n\\t\\t\\t&& buffer.getFoldLevel(line + 1) > initialFoldLevel)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tstart = line + 1;\\n\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.getFoldLevel(i) <= initialFoldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tboolean ok = false;\\n\\t\\t\\t\\t\\t\\tfor(int i = line - 1; i >= 0; i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstart = i + 1;\\n\\t\\t\\t\\t\\tok = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(!ok)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\thideLineRange(start,end);\\n\\t\\tnotifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic int expandFold(int line, boolean fully)\\n\\t{\\n\\t\\t\\t\\tint returnValue = -1;\\n\\t\\tint lineCount = buffer.getLineCount();\\n\\t\\tint start = 0;\\n\\t\\tint end = lineCount - 1;\\n\\t\\tint initialFoldLevel = buffer.getFoldLevel(line);\\n\\t\\t\\t\\tif(line != lineCount - 1\\n\\t\\t\\t&& isLineVisible(line)\\n\\t\\t\\t&& !isLineVisible(line + 1)\\n\\t\\t\\t&& buffer.getFoldLevel(line + 1) > initialFoldLevel)\\n\\t\\t{\\n\\t\\t\\tint index = fvmget(line + 1);\\n\\t\\t\\tif(index == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\texpandAllFolds();\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\tstart = fvm[index];\\n\\t\\t\\tif(index != fvmcount - 1)\\n\\t\\t\\t\\tend = fvm[index + 1] - 1;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart = line + 1;\\n\\t\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(\\n\\t\\t\\t\\t\\t\\tbuffer.getFoldLevel(i) <= initialFoldLevel)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint index = fvmget(line);\\n\\t\\t\\tif(index == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\texpandAllFolds();\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\tstart = fvm[index];\\n\\t\\t\\tif(index != fvmcount - 1)\\n\\t\\t\\t\\tend = fvm[index + 1] - 1;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif((isLineVisible(i) &&\\n\\t\\t\\t\\t\\t\\tbuffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t\\t\\t|| i == getLastVisibleLine())\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tif(fully)\\n\\t\\t{\\n\\t\\t\\tshowLineRange(start,end);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tinitialFoldLevel = buffer.getFoldLevel(start);\\n\\t\\t\\tint firstVisible = start;\\n\\t\\t\\tfor(int i = start; i <= end; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer.getFoldLevel(i) > initialFoldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(returnValue == -1\\n\\t\\t\\t\\t\\t\\t&& i != 0\\n\\t\\t\\t\\t\\t\\t&& buffer.isFoldStart(i - 1))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturnValue = i - 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(firstVisible != i)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tshowLineRange(firstVisible,i - 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfirstVisible = i + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(firstVisible != end + 1)\\n\\t\\t\\t\\tshowLineRange(firstVisible,end);\\n\\t\\t\\tif(!isLineVisible(line))\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\texpandFold(line,false);\\n\\t\\t\\t\\treturn returnValue;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tnotifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t\\treturn returnValue;\\n\\t} \\n\\tpublic void expandAllFolds()\\n\\t{\\n\\t\\tshowLineRange(0,buffer.getLineCount() - 1);\\n\\t\\tnotifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic void expandFolds(char digit)\\n\\t{\\n\\t\\tif(digit < '1' || digit > '9')\\n\\t\\t{\\n\\t\\t\\tToolkit.getDefaultToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\texpandFolds((int)(digit - '1') + 1);\\n\\t} \\n\\tpublic void expandFolds(int foldLevel)\\n\\t{\\n\\t\\tif(buffer.getFoldHandler() instanceof IndentFoldHandler)\\n\\t\\t\\tfoldLevel = (foldLevel - 1) * buffer.getIndentSize() + 1;\\n\\t\\tshowLineRange(0,buffer.getLineCount() - 1);\\n\\t\\tboolean seenVisibleLine = false;\\n\\t\\tint firstInvisible = 0;\\n\\t\\tfor(int i = 0; i < buffer.getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tif(!seenVisibleLine || buffer.getFoldLevel(i) < foldLevel)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(firstInvisible != i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\thideLineRange(firstInvisible,\\n\\t\\t\\t\\t\\t\\ti - 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfirstInvisible = i + 1;\\n\\t\\t\\t\\tseenVisibleLine = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(firstInvisible != buffer.getLineCount())\\n\\t\\t\\thideLineRange(firstInvisible,buffer.getLineCount() - 1);\\n\\t\\tnotifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic void narrow(int start, int end)\\n\\t{\\n\\t\\tif(start > end || start < 0 || end >= buffer.getLineCount())\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(start + \\\", \\\" + end);\\n\\t\\tif(start < getFirstVisibleLine() || end > getLastVisibleLine())\\n\\t\\t\\texpandAllFolds();\\n\\t\\tif(start != 0)\\n\\t\\t\\thideLineRange(0,start - 1);\\n\\t\\tif(end != buffer.getLineCount() - 1)\\n\\t\\t\\thideLineRange(end + 1,buffer.getLineCount() - 1);\\n\\t\\t\\t\\tif(start != buffer.getLineCount() - 1\\n\\t\\t\\t&& !isLineVisible(start + 1))\\n\\t\\t\\texpandFold(start,false);\\n\\t\\t\\t\\t\\t\\tGUIUtilities.getView(textArea).getStatus().setMessageAndClear(\\n\\t\\t\\tjEdit.getProperty(\\\"view.status.narrow\\\"));\\n\\t\\tnotifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\t\\tboolean softWrap;\\n\\tint wrapMargin;\\n\\tboolean wrapToWidth;\\n\\tFirstLine firstLine;\\n\\tScrollLineCount scrollLineCount;\\n\\t\\tvoid init()\\n\\t{\\n\\t\\tif(!initialized)\\n\\t\\t{\\n\\t\\t\\tinitialized = true;\\n\\t\\t\\tfvm = new int[2];\\n\\t\\t\\tif(buffer.isLoaded())\\n\\t\\t\\t\\tbufferChangeHandler.foldHandlerChanged(buffer);\\n\\t\\t\\telse\\n\\t\\t\\t\\tfvmreset();\\n\\t\\t\\tnotifyScreenLineChanges();\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tupdateWrapSettings();\\n\\t\\t\\tif(buffer.isLoaded())\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.reset();\\n\\t\\t\\t\\tscrollLineCount.reset();\\n\\t\\t\\t\\tnotifyScreenLineChanges();\\n\\t\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tvoid updateWrapSettings()\\n\\t{\\n\\t\\tString wrap = buffer.getStringProperty(\\\"wrap\\\");\\n\\t\\tsoftWrap = wrap.equals(\\\"soft\\\");\\n\\t\\tif(textArea.maxLineLen <= 0)\\n\\t\\t{\\n\\t\\t\\tif(softWrap)\\n\\t\\t\\t{\\n\\t\\t\\t\\twrapToWidth = true;\\n\\t\\t\\t\\twrapMargin = textArea.getPainter().getWidth()\\n\\t\\t\\t\\t\\t- textArea.charWidth * 3;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\twrapToWidth = false;\\n\\t\\t\\t\\twrapMargin = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tchar[] foo = new char[textArea.maxLineLen];\\n\\t\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfoo[i] = ' ';\\n\\t\\t\\t}\\n\\t\\t\\tTextAreaPainter painter = textArea.getPainter();\\n\\t\\t\\twrapToWidth = false;\\n\\t\\t\\twrapMargin = (int)painter.getFont().getStringBounds(\\n\\t\\t\\t\\tfoo,0,foo.length,\\n\\t\\t\\t\\tpainter.getFontRenderContext())\\n\\t\\t\\t\\t.getWidth();\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void clearNotifyFlags()\\n\\t{\\n\\t\\tfirstLine.callReset = firstLine.callChanged = false;\\n\\t\\tscrollLineCount.callReset = scrollLineCount.callChanged = false;\\n\\t} \\n\\t\\tvoid notifyScreenLineChanges()\\n\\t{\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"notifyScreenLineChanges()\\\");\\n\\t\\t\\t\\t\\t\\tif(textArea.getDisplayManager() != this)\\n\\t\\t\\treturn;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tif(firstLine.callReset)\\n\\t\\t\\t\\tfirstLine.reset();\\n\\t\\t\\telse if(firstLine.callChanged)\\n\\t\\t\\t\\tfirstLine.changed();\\n\\t\\t\\tif(scrollLineCount.callReset)\\n\\t\\t\\t\\tscrollLineCount.reset();\\n\\t\\t\\telse if(scrollLineCount.callChanged)\\n\\t\\t\\t\\tscrollLineCount.changed();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tclearNotifyFlags();\\n\\t\\t}\\n\\t} \\n\\t\\tvoid setFirstLine(int oldFirstLine, int firstLine)\\n\\t{\\n\\t\\tint visibleLines = textArea.getVisibleLines();\\n\\t\\tif(firstLine >= oldFirstLine + visibleLines)\\n\\t\\t{\\n\\t\\t\\tthis.firstLine.scrollDown(firstLine - oldFirstLine);\\n\\t\\t\\ttextArea.chunkCache.invalidateAll();\\n\\t\\t}\\n\\t\\telse if(firstLine <= oldFirstLine - visibleLines)\\n\\t\\t{\\n\\t\\t\\tthis.firstLine.scrollUp(oldFirstLine - firstLine);\\n\\t\\t\\ttextArea.chunkCache.invalidateAll();\\n\\t\\t}\\n\\t\\telse if(firstLine > oldFirstLine)\\n\\t\\t{\\n\\t\\t\\tthis.firstLine.scrollDown(firstLine - oldFirstLine);\\n\\t\\t\\ttextArea.chunkCache.scrollDown(firstLine - oldFirstLine);\\n\\t\\t}\\n\\t\\telse if(firstLine < oldFirstLine)\\n\\t\\t{\\n\\t\\t\\tthis.firstLine.scrollUp(oldFirstLine - firstLine);\\n\\t\\t\\ttextArea.chunkCache.scrollUp(oldFirstLine - firstLine);\\n\\t\\t}\\n\\t\\tnotifyScreenLineChanges();\\n\\t} \\t\\n\\t\\tvoid setFirstPhysicalLine(int amount, int skew)\\n\\t{\\n\\t\\tint oldFirstLine = textArea.getFirstLine();\\n\\t\\tif(amount == 0)\\n\\t\\t{\\n\\t\\t\\tskew -= this.firstLine.skew;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(skew < 0)\\n\\t\\t\\t\\tthis.firstLine.scrollUp(-skew);\\n\\t\\t\\telse if(skew > 0)\\n\\t\\t\\t\\tthis.firstLine.scrollDown(skew);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(amount > 0)\\n\\t\\t\\tthis.firstLine.physDown(amount,skew);\\n\\t\\telse if(amount < 0)\\n\\t\\t\\tthis.firstLine.physUp(-amount,skew);\\n\\t\\tint firstLine = textArea.getFirstLine();\\n\\t\\tint visibleLines = textArea.getVisibleLines();\\n\\t\\tif(firstLine == oldFirstLine)\\n\\t\\t\\t;\\n\\t\\telse if(firstLine >= oldFirstLine + visibleLines\\n\\t\\t\\t|| firstLine <= oldFirstLine - visibleLines)\\n\\t\\t{\\n\\t\\t\\ttextArea.chunkCache.invalidateAll();\\n\\t\\t}\\n\\t\\telse if(firstLine > oldFirstLine)\\n\\t\\t{\\n\\t\\t\\ttextArea.chunkCache.scrollDown(firstLine - oldFirstLine);\\n\\t\\t}\\n\\t\\telse if(firstLine < oldFirstLine)\\n\\t\\t{\\n\\t\\t\\ttextArea.chunkCache.scrollUp(oldFirstLine - firstLine);\\n\\t\\t}\\n\\t\\t\\t\\tnotifyScreenLineChanges();\\n\\t} \\n\\t\\tvoid invalidateScreenLineCounts()\\n\\t{\\n\\t\\tscreenLineMgr.invalidateScreenLineCounts();\\n\\t\\tfirstLine.callReset = true;\\n\\t\\tscrollLineCount.callReset = true;\\n\\t} \\n\\t\\tprivate boolean initialized;\\n\\tprivate boolean inUse;\\n\\tprivate Buffer buffer;\\n\\tprivate ScreenLineManager screenLineMgr;\\n\\tprivate JEditTextArea textArea;\\n\\tprivate BufferChangeHandler bufferChangeHandler;\\n\\tprivate int[] fvm;\\n\\tprivate int fvmcount;\\n\\tprivate int lastfvmget = -1;\\n\\t\\tprivate DisplayManager(Buffer buffer, JEditTextArea textArea)\\n\\t{\\n\\t\\tthis.buffer = buffer;\\n\\t\\tthis.screenLineMgr = new ScreenLineManager(this,buffer);\\n\\t\\tthis.textArea = textArea;\\n\\t\\tscrollLineCount = new ScrollLineCount();\\n\\t\\tfirstLine = new FirstLine();\\n\\t\\tbufferChangeHandler = new BufferChangeHandler();\\n\\t\\t\\t\\tbuffer.addBufferChangeListener(bufferChangeHandler,\\n\\t\\t\\tBuffer.HIGH_PRIORITY);\\n\\t} \\n\\t\\tprivate void dispose()\\n\\t{\\n\\t\\tbuffer.removeBufferChangeListener(bufferChangeHandler);\\n\\t} \\n\\t\\tprivate void fvmreset()\\n\\t{\\n\\t\\tlastfvmget = -1;\\n\\t\\tfvmcount = 2;\\n\\t\\tfvm[0] = 0;\\n\\t\\tfvm[1] = buffer.getLineCount();\\n\\t} \\n\\tprivate int fvmget(int line)\\n\\t{\\n\\t\\tscanCount++;\\n\\t\\tif(line < fvm[0])\\n\\t\\t\\treturn -1;\\n\\t\\tif(line >= fvm[fvmcount - 1])\\n\\t\\t\\treturn fvmcount - 1;\\n\\t\\tif(lastfvmget != -1)\\n\\t\\t{\\n\\t\\t\\tif(line >= fvm[lastfvmget])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(lastfvmget == fvmcount - 1\\n\\t\\t\\t\\t\\t|| line < fvm[lastfvmget + 1])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn lastfvmget;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint start = 0;\\n\\t\\tint end = fvmcount - 1;\\nloop:\\t\\tfor(;;)\\n\\t\\t{\\n\\t\\t\\tscannedLines++;\\n\\t\\t\\tswitch(end - start)\\n\\t\\t\\t{\\n\\t\\t\\tcase 0:\\n\\t\\t\\t\\tlastfvmget = start;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\tint value = fvm[end];\\n\\t\\t\\t\\tif(value <= line)\\n\\t\\t\\t\\t\\tlastfvmget = end;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tlastfvmget = start;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tint pivot = (end + start) / 2;\\n\\t\\t\\t\\tvalue = fvm[pivot];\\n\\t\\t\\t\\tif(value == line)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastfvmget = pivot;\\n\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(value < line)\\n\\t\\t\\t\\t\\tstart = pivot;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tend = pivot - 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn lastfvmget;\\n\\t} \\n\\tprivate void fvmput(int start, int end, int[] put)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tStringBuffer buf = new StringBuffer(\\\"{\\\");\\n\\t\\t\\tif(put != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i = 0; i < put.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(i != 0)\\n\\t\\t\\t\\t\\t\\tbuf.append(',');\\n\\t\\t\\t\\t\\tbuf.append(put[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tbuf.append(\\\"}\\\");\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"fvmput(\\\" + start + \\\",\\\"\\n\\t\\t\\t\\t+ end + \\\",\\\" + buf + \\\")\\\");\\n\\t\\t}\\n\\t\\tint putl = (put == null ? 0 : put.length);\\n\\t\\tint delta = putl - (end - start);\\n\\t\\tif(fvmcount + delta > fvm.length)\\n\\t\\t{\\n\\t\\t\\tint[] newfvm = new int[fvm.length * 2 + 1];\\n\\t\\t\\tSystem.arraycopy(fvm,0,newfvm,0,fvmcount);\\n\\t\\t\\tfvm = newfvm;\\n\\t\\t}\\n\\t\\tif(delta != 0)\\n\\t\\t{\\n\\t\\t\\tSystem.arraycopy(fvm,end,fvm,start + putl,\\n\\t\\t\\t\\tfvmcount - end);\\n\\t\\t}\\n\\t\\tif(putl != 0)\\n\\t\\t{\\n\\t\\t\\tSystem.arraycopy(put,0,fvm,start,put.length);\\n\\t\\t}\\n\\t\\tfvmcount += delta;\\n\\t\\tfvmdump();\\n\\t\\tif(fvmcount == 0)\\n\\t\\t\\tthrow new InternalError();\\n\\t} \\n\\tprivate void fvmput2(int starti, int endi, int start, int end)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"*fvmput2(\\\" + starti + \\\",\\\"\\n\\t\\t\\t\\t+ endi + \\\",\\\" + start + \\\",\\\" + end + \\\")\\\");\\n\\t\\t}\\n\\t\\tif(starti != -1 && fvm[starti] == start)\\n\\t\\t{\\n\\t\\t\\tif(endi <= fvmcount - 2 && fvm[endi + 1]\\n\\t\\t\\t\\t== end + 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti,endi + 2,null);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti,endi + 1,\\n\\t\\t\\t\\t\\tnew int[] { end + 1 });\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(endi != fvmcount - 1 && fvm[endi + 1]\\n\\t\\t\\t\\t== end + 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 2,\\n\\t\\t\\t\\t\\tnew int[] { start });\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 1,\\n\\t\\t\\t\\t\\tnew int[] { start,\\n\\t\\t\\t\\t\\tend + 1 });\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fvmdump()\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tStringBuffer buf = new StringBuffer(\\\"{\\\");\\n\\t\\t\\tfor(int i = 0; i < fvmcount; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i != 0)\\n\\t\\t\\t\\t\\tbuf.append(',');\\n\\t\\t\\t\\tbuf.append(fvm[i]);\\n\\t\\t\\t}\\n\\t\\t\\tbuf.append(\\\"}\\\");\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"fvm = \\\" + buf);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void showLineRange(int start, int end)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"showLineRange(\\\" + start\\n\\t\\t\\t\\t+ \\\",\\\" + end + \\\")\\\");\\n\\t\\t}\\n\\t\\tfor(int i = start; i <= end; i++)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(!isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tupdateScreenLineCount(i);\\n\\t\\t\\t\\tint screenLines = getScreenLineCount(i);\\n\\t\\t\\t\\tif(firstLine.physicalLine >= i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfirstLine.scrollLine += screenLines;\\n\\t\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tscrollLineCount.scrollLine += screenLines;\\n\\t\\t\\t\\tscrollLineCount.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint starti = fvmget(start);\\n\\t\\tint endi = fvmget(end);\\n\\t\\tif(starti % 2 == 0)\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 1,null);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(endi != fvmcount - 1\\n\\t\\t\\t\\t\\t&& fvm[endi + 1] == end + 1)\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi + 2,null);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\t\\tfvm[starti + 1] = end + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(starti != -1 && fvm[starti] == start)\\n\\t\\t\\t\\t\\tfvmput(starti,endi + 1,null);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\t\\tfvm[starti + 1] = start;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tfvmput2(starti,endi,start,end);\\n\\t\\t}\\n\\t\\tlastfvmget = -1;\\n\\t} \\n\\t\\tprivate void hideLineRange(int start, int end)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"hideLineRange(\\\" + start\\n\\t\\t\\t\\t+ \\\",\\\" + end + \\\")\\\");\\n\\t\\t}\\n\\t\\tint i = start;\\n\\t\\tif(!isLineVisible(i))\\n\\t\\t\\ti = getNextVisibleLine(i);\\n\\t\\twhile(i != -1 && i <= end)\\n\\t\\t{\\n\\t\\t\\tint screenLines = screenLineMgr.getScreenLineCount(i);\\n\\t\\t\\tif(i < firstLine.physicalLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.scrollLine -= screenLines;\\n\\t\\t\\t\\tfirstLine.skew = 0;\\n\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t\\tscrollLineCount.scrollLine -= screenLines;\\n\\t\\t\\tscrollLineCount.callChanged = true;\\n\\t\\t\\ti = getNextVisibleLine(i);\\n\\t\\t}\\n\\t\\tint starti = fvmget(start);\\n\\t\\tint endi = fvmget(end);\\n\\t\\tif(starti % 2 == 0)\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t\\tfvmput2(starti,endi,start,end);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(start == fvm[0])\\n\\t\\t\\t\\t\\tfvmput(starti,endi + 1,null);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\t\\tfvm[starti + 1] = start;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(end + 1 == fvm[fvmcount - 1])\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi + 2,null);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\t\\tfvm[starti + 1] = end + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 1,null);\\n\\t\\t}\\n\\t\\tlastfvmget = -1;\\n\\t\\tif(!isLineVisible(firstLine.physicalLine))\\n\\t\\t{\\n\\t\\t\\tint firstVisible = getFirstVisibleLine();\\n\\t\\t\\tif(firstLine.physicalLine < firstVisible)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.physicalLine = firstVisible;\\n\\t\\t\\t\\tfirstLine.scrollLine = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.physicalLine = getPrevVisibleLine(\\n\\t\\t\\t\\t\\tfirstLine.physicalLine);\\n\\t\\t\\t\\tfirstLine.scrollLine -=\\n\\t\\t\\t\\t\\tscreenLineMgr.getScreenLineCount(\\n\\t\\t\\t\\t\\tfirstLine.physicalLine);\\n\\t\\t\\t}\\n\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void updateScreenLineCount(int line)\\n\\t{\\n\\t\\tif(!screenLineMgr.isScreenLineCountValid(line))\\n\\t\\t{\\n\\t\\t\\tint newCount = textArea.chunkCache\\n\\t\\t\\t\\t.getLineSubregionCount(line);\\n\\t\\t\\tsetScreenLineCount(line,newCount);\\n\\t\\t}\\n\\t} \\n\\tprivate void setScreenLineCount(int line, int count)\\n\\t{\\n\\t\\tint oldCount = screenLineMgr.getScreenLineCount(line);\\n\\t\\tscreenLineMgr.setScreenLineCount(line,count);\\n\\t\\tif(count == oldCount)\\n\\t\\t\\treturn;\\n\\t\\tif(!isLineVisible(line))\\n\\t\\t\\treturn;\\n\\t\\tif(firstLine.physicalLine >= line)\\n\\t\\t{\\n\\t\\t\\tif(firstLine.physicalLine == line)\\n\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.scrollLine += (count - oldCount);\\n\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tscrollLineCount.scrollLine += (count - oldCount);\\n\\t\\tscrollLineCount.callChanged = true;\\n\\t} \\n\\t\\tstatic abstract class Anchor\\n\\t{\\n\\t\\tint physicalLine;\\n\\t\\tint scrollLine;\\n\\t\\tboolean callChanged;\\n\\t\\tboolean callReset;\\n\\t\\tabstract void reset();\\n\\t\\tabstract void changed();\\n\\t\\tpublic String toString()\\n\\t\\t{\\n\\t\\t\\treturn getClass().getName() + \\\"[\\\" + physicalLine + \\\",\\\"\\n\\t\\t\\t\\t+ scrollLine + \\\"]\\\";\\n\\t\\t}\\n\\t} \\n\\t\\tclass ScrollLineCount extends Anchor\\n\\t{\\n\\t\\t\\t\\tpublic void changed()\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"changed()\\\");\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t} \\n\\t\\t\\t\\tpublic void reset()\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"reset()\\\");\\n\\t\\t\\tphysicalLine = getFirstVisibleLine();\\n\\t\\t\\tint scrollLine = 0;\\n\\t\\t\\twhile(physicalLine != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tupdateScreenLineCount(physicalLine);\\n\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\tphysicalLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t}\\n\\t\\t\\tthis.scrollLine = scrollLine;\\n\\t\\t\\tphysicalLine = buffer.getLineCount();\\n\\t\\t\\tfirstLine.ensurePhysicalLineIsVisible();\\n\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t} \\t} \\n\\t\\tclass FirstLine extends Anchor\\n\\t{\\n\\t\\tint skew;\\n\\t\\t\\t\\tpublic void changed()\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"changed() before: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine\\n\\t\\t\\t\\t\\t+ \\\":\\\" + skew);\\n\\t\\t\\t} \\n\\t\\t\\tensurePhysicalLineIsVisible();\\n\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\tif(skew >= screenLines)\\n\\t\\t\\t\\tskew = screenLines - 1;\\n\\t\\t\\t\\t\\t\\tif(Debug.SCROLL_VERIFY)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSystem.err.println(\\\"SCROLL_VERIFY\\\");\\n\\t\\t\\t\\tint verifyScrollLine = 0;\\n\\t\\t\\t\\tfor(int i = 0; i < buffer.getLineCount(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!isLineVisible(i))\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\tif(i >= physicalLine)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tverifyScrollLine += getScreenLineCount(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(verifyScrollLine != scrollLine)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tException ex = new Exception(scrollLine + \\\":\\\" + verifyScrollLine);\\n\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,ex);\\n\\t\\t\\t\\t\\tnew org.gjt.sp.jedit.gui.BeanShellErrorDialog(null,ex);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"changed() after: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine\\n\\t\\t\\t\\t\\t+ \\\":\\\" + skew);\\n\\t\\t\\t} \\n\\t\\t\\tif(!scrollLineCount.callChanged\\n\\t\\t\\t\\t&& !scrollLineCount.callReset)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void reset()\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"reset()\\\");\\n\\t\\t\\tString wrap = buffer.getStringProperty(\\\"wrap\\\");\\n\\t\\t\\tsoftWrap = wrap.equals(\\\"soft\\\");\\n\\t\\t\\tif(textArea.maxLineLen <= 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsoftWrap = false;\\n\\t\\t\\t\\twrapMargin = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tchar[] foo = new char[textArea.maxLineLen];\\n\\t\\t\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfoo[i] = ' ';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tTextAreaPainter painter = textArea.getPainter();\\n\\t\\t\\t\\twrapMargin = (int)painter.getFont().getStringBounds(\\n\\t\\t\\t\\t\\tfoo,0,foo.length,\\n\\t\\t\\t\\t\\tpainter.getFontRenderContext())\\n\\t\\t\\t\\t\\t.getWidth();\\n\\t\\t\\t}\\n\\t\\t\\tscrollLine = 0;\\n\\t\\t\\tint i = getFirstVisibleLine();\\n\\t\\t\\tfor(;;)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i >= physicalLine)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tupdateScreenLineCount(i);\\n\\t\\t\\t\\tscrollLine += getScreenLineCount(i);\\n\\t\\t\\t\\tint nextLine = getNextVisibleLine(i);\\n\\t\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\ti = nextLine;\\n\\t\\t\\t}\\n\\t\\t\\tphysicalLine = i;\\n\\t\\t\\tupdateScreenLineCount(i);\\n\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\tif(skew >= screenLines)\\n\\t\\t\\t\\tskew = screenLines - 1;\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid physDown(int amount, int screenAmount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physDown() start: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tskew = 0;\\n\\t\\t\\tif(!isLineVisible(physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint lastVisibleLine = getLastVisibleLine();\\n\\t\\t\\t\\tif(physicalLine > lastVisibleLine)\\n\\t\\t\\t\\t\\tphysicalLine = lastVisibleLine;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint nextPhysicalLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tamount -= (nextPhysicalLine - physicalLine);\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = nextPhysicalLine;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(;;)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint nextPhysicalLine = getNextVisibleLine(\\n\\t\\t\\t\\t\\tphysicalLine);\\n\\t\\t\\t\\tif(nextPhysicalLine == -1)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse if(nextPhysicalLine > physicalLine + amount)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t\\tamount -= (nextPhysicalLine - physicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = nextPhysicalLine;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physDown() end: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tcallChanged = true;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(screenAmount < 0)\\n\\t\\t\\t\\tscrollUp(-screenAmount);\\n\\t\\t\\telse if(screenAmount > 0)\\n\\t\\t\\t\\tscrollDown(screenAmount);\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid physUp(int amount, int screenAmount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physUp() start: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tskew = 0;\\n\\t\\t\\tif(!isLineVisible(physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint firstVisibleLine = getFirstVisibleLine();\\n\\t\\t\\t\\tif(physicalLine < firstVisibleLine)\\n\\t\\t\\t\\t\\tphysicalLine = firstVisibleLine;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint prevPhysicalLine = getPrevVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tamount -= (physicalLine - prevPhysicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(;;)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint prevPhysicalLine = getPrevVisibleLine(\\n\\t\\t\\t\\t\\tphysicalLine);\\n\\t\\t\\t\\tif(prevPhysicalLine == -1)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse if(prevPhysicalLine < physicalLine - amount)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tamount -= (physicalLine - prevPhysicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = prevPhysicalLine;\\n\\t\\t\\t\\t\\tscrollLine -= getScreenLineCount(\\n\\t\\t\\t\\t\\t\\tprevPhysicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physUp() end: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tcallChanged = true;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(screenAmount < 0)\\n\\t\\t\\t\\tscrollUp(-screenAmount);\\n\\t\\t\\telse if(screenAmount > 0)\\n\\t\\t\\t\\tscrollDown(screenAmount);\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid scrollDown(int amount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"scrollDown()\\\");\\n\\t\\t\\tensurePhysicalLineIsVisible();\\n\\t\\t\\tamount += skew;\\n\\t\\t\\tskew = 0;\\n\\t\\t\\twhile(amount > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\t\\tif(amount < screenLines)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tskew = amount;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint nextLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tboolean visible = isLineVisible(physicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = nextLine;\\n\\t\\t\\t\\t\\tif(visible)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tamount -= screenLines;\\n\\t\\t\\t\\t\\t\\tscrollLine += screenLines;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcallChanged = true;\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid scrollUp(int amount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"scrollUp()\\\");\\n\\t\\t\\tensurePhysicalLineIsVisible();\\n\\t\\t\\tif(amount <= skew)\\n\\t\\t\\t{\\n\\t\\t\\t\\tskew -= amount;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tamount -= skew;\\n\\t\\t\\t\\tskew = 0;\\n\\t\\t\\t\\twhile(amount > 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint prevLine = getPrevVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tif(prevLine == -1)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tphysicalLine = prevLine;\\n\\t\\t\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t\\tscrollLine -= screenLines;\\n\\t\\t\\t\\t\\tif(amount < screenLines)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tskew = screenLines - amount;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tamount -= screenLines;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcallChanged = true;\\n\\t\\t} \\n\\t\\t\\t\\tprivate void ensurePhysicalLineIsVisible()\\n\\t\\t{\\n\\t\\t\\tif(!isLineVisible(physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(physicalLine > getLastVisibleLine())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysicalLine = getLastVisibleLine();\\n\\t\\t\\t\\t\\tscrollLine = getScrollLineCount() - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(physicalLine < getFirstVisibleLine())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysicalLine = getFirstVisibleLine();\\n\\t\\t\\t\\t\\tscrollLine = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysicalLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\t} \\n\\tclass BufferChangeHandler extends BufferChangeAdapter\\n\\t{\\n\\t\\tboolean delayedUpdate;\\n\\t\\tboolean delayedMultilineUpdate;\\n\\t\\tint delayedUpdateStart;\\n\\t\\tint delayedUpdateEnd;\\n\\t\\t\\t\\tpublic void foldHandlerChanged(Buffer buffer)\\n\\t\\t{\\n\\t\\t\\tfvmreset();\\n\\t\\t\\tfirstLine.reset();\\n\\t\\t\\tscrollLineCount.reset();\\n\\t\\t\\tint collapseFolds = buffer.getIntegerProperty(\\n\\t\\t\\t\\t\\\"collapseFolds\\\",0);\\n\\t\\t\\tif(collapseFolds != 0)\\n\\t\\t\\t\\texpandFolds(collapseFolds);\\n\\t\\t} \\n\\t\\t\\t\\tpublic void foldLevelChanged(Buffer buffer, int start, int end)\\n\\t\\t{\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this\\n\\t\\t\\t\\t&& end != 0 && buffer.isLoaded())\\n\\t\\t\\t{\\n\\t\\t\\t\\ttextArea.invalidateLineRange(start - 1,\\n\\t\\t\\t\\t\\ttextArea.getLastPhysicalLine());\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void contentInserted(Buffer buffer, int startLine,\\n\\t\\t\\tint offset, int numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmreset();\\n\\t\\t\\t\\tscreenLineMgr.reset();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tscreenLineMgr.contentInserted(startLine,numLines);\\n\\t\\t\\tint endLine = startLine + numLines;\\n\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedMultilineUpdate = true;\\n\\t\\t\\t\\tint index = fvmget(startLine);\\n\\t\\t\\t\\tint start = index + 1;\\n\\t\\t\\t\\tfor(int i = start; i < fvmcount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvm[i] += numLines;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlastfvmget = -1;\\n\\t\\t\\t\\tfvmdump();\\n\\t\\t\\t}\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcontentInserted(firstLine,startLine,numLines);\\n\\t\\t\\t\\t\\tcontentInserted(scrollLineCount,startLine,numLines);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(delayedUpdateEnd >= startLine)\\n\\t\\t\\t\\t\\tdelayedUpdateEnd += numLines;\\n\\t\\t\\t\\tdelayedUpdate(startLine,endLine);\\n\\t\\t\\t\\t\\t\\t\\t\\tIterator iter = textArea.getSelectionIterator();\\n\\t\\t\\t\\twhile(iter.hasNext())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection s = (Selection)iter.next();\\n\\t\\t\\t\\t\\tif(s.contentInserted(buffer,startLine,offset,\\n\\t\\t\\t\\t\\t\\tnumLines,length))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdelayedUpdate(s.startLine,s.endLine);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tint caret = textArea.getCaretPosition();\\n\\t\\t\\t\\tif(caret >= offset)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.ELECTRIC_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(\\n\\t\\t\\t\\t\\t\\tcaret + length,scrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.NORMAL_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(\\n\\t\\t\\t\\t\\t\\tcaret,scrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tpublic void preContentRemoved(Buffer buffer, int startLine,\\n\\t\\t\\tint offset, int numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tdelayedMultilineUpdate = true;\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tpreContentRemoved(firstLine,startLine,numLines);\\n\\t\\t\\t\\t\\tpreContentRemoved(scrollLineCount,startLine,numLines);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(delayedUpdateEnd >= startLine)\\n\\t\\t\\t\\t\\tdelayedUpdateEnd -= numLines;\\n\\t\\t\\t\\tdelayedUpdate(startLine,startLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\t}\\n\\t\\t\\tif(numLines == 0)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tscreenLineMgr.contentRemoved(startLine,numLines);\\n\\t\\t\\tint endLine = startLine + numLines;\\n\\t\\t\\tint starti = fvmget(startLine);\\n\\t\\t\\tint endi = fvmget(endLine);\\n\\t\\t\\tif(Math.abs(starti % 2) == Math.abs(endi % 2))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(endi - starti == fvmcount)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfvmreset();\\n\\t\\t\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\t\\t\\tstarti = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi + 1,null);\\n\\t\\t\\t\\t\\tstarti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(starti != -1 && fvm[starti] == startLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(endi - starti == fvmcount - 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfvmreset();\\n\\t\\t\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\t\\t\\tstarti = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tfvmput(starti,endi + 1,null);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\tfvm[starti + 1] = startLine;\\n\\t\\t\\t\\tstarti += 2;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = starti; i < fvmcount; i++)\\n\\t\\t\\t\\tfvm[i] -= numLines;\\n\\t\\t\\tif(firstLine.physicalLine\\n\\t\\t\\t\\t> getLastVisibleLine()\\n\\t\\t\\t\\t|| firstLine.physicalLine\\n\\t\\t\\t\\t< getFirstVisibleLine())\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\telse if(!isLineVisible(\\n\\t\\t\\t\\tfirstLine.physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.physicalLine =\\n\\t\\t\\t\\t\\tgetNextVisibleLine(\\n\\t\\t\\t\\t\\tfirstLine.physicalLine);\\n\\t\\t\\t}\\n\\t\\t\\tlastfvmget = -1;\\n\\t\\t\\tfvmdump();\\n\\t\\t} \\n\\t\\t\\t\\tpublic void contentRemoved(Buffer buffer, int startLine,\\n\\t\\t\\tint start, int numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(textArea.getDisplayManager() == DisplayManager.this)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tIterator iter = textArea.getSelectionIterator();\\n\\t\\t\\t\\twhile(iter.hasNext())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection s = (Selection)iter.next();\\n\\t\\t\\t\\t\\tif(s.contentRemoved(buffer,startLine,\\n\\t\\t\\t\\t\\t\\tstart,numLines,length))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdelayedUpdate(s.startLine,s.endLine);\\n\\t\\t\\t\\t\\t\\tif(s.start == s.end)\\n\\t\\t\\t\\t\\t\\t\\titer.remove();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tint caret = textArea.getCaretPosition();\\n\\t\\t\\t\\tif(caret >= start + length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.ELECTRIC_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(\\n\\t\\t\\t\\t\\t\\tcaret - length,\\n\\t\\t\\t\\t\\t\\tscrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(caret >= start)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.ELECTRIC_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(\\n\\t\\t\\t\\t\\t\\tstart,scrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint scrollMode = (caretAutoScroll()\\n\\t\\t\\t\\t\\t\\t? JEditTextArea.NORMAL_SCROLL\\n\\t\\t\\t\\t\\t\\t: JEditTextArea.NO_SCROLL);\\n\\t\\t\\t\\t\\ttextArea.moveCaretPosition(caret,scrollMode);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tpublic void transactionComplete(Buffer buffer)\\n\\t\\t{\\n\\t\\t\\tif(textArea.getDisplayManager() != DisplayManager.this)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedUpdate = false;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(delayedUpdate)\\n\\t\\t\\t\\tdoDelayedUpdate();\\n\\t\\t\\ttextArea._finishCaretUpdate();\\n\\t\\t\\tdelayedUpdate = false;\\n\\t\\t\\t\\t\\t\\tif(Debug.SCROLL_VERIFY)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint scrollLineCount = 0;\\n\\t\\t\\t\\tint line = delayedUpdateStart;\\n\\t\\t\\t\\tif(!isLineVisible(line))\\n\\t\\t\\t\\t\\tline = getNextVisibleLine(line);\\n\\t\\t\\t\\tSystem.err.println(delayedUpdateStart + \\\":\\\" + delayedUpdateEnd + \\\":\\\" + textArea.getLineCount());\\n\\t\\t\\t\\twhile(line != -1 && line <= delayedUpdateEnd)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscrollLineCount += getScreenLineCount(line);\\n\\t\\t\\t\\t\\tline = getNextVisibleLine(line);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(scrollLineCount != getScrollLineCount())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tthrow new InternalError(scrollLineCount\\n\\t\\t\\t\\t\\t\\t+ \\\" != \\\"\\n\\t\\t\\t\\t\\t\\t+ getScrollLineCount());\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\t\\t} \\n\\t\\t\\t\\tprivate void doDelayedUpdate()\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tint _firstLine = textArea.getFirstPhysicalLine();\\n\\t\\t\\tint _lastLine = textArea.getLastPhysicalLine();\\n\\t\\t\\tint line = delayedUpdateStart;\\n\\t\\t\\tif(!isLineVisible(line))\\n\\t\\t\\t\\tline = getNextVisibleLine(line);\\n\\t\\t\\twhile(line != -1 && line <= delayedUpdateEnd)\\n\\t\\t\\t{\\n\\t\\t\\t\\tupdateScreenLineCount(line);\\n\\t\\t\\t\\tline = getNextVisibleLine(line);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnotifyScreenLineChanges();\\n\\t\\t\\tif(delayedMultilineUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttextArea.invalidateScreenLineRange(\\n\\t\\t\\t\\t\\ttextArea.chunkCache\\n\\t\\t\\t\\t\\t.getScreenLineOfOffset(\\n\\t\\t\\t\\t\\tdelayedUpdateStart,0),\\n\\t\\t\\t\\t\\ttextArea.getVisibleLines());\\n\\t\\t\\t\\tdelayedMultilineUpdate = false;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\ttextArea.invalidateLineRange(\\n\\t\\t\\t\\t\\tdelayedUpdateStart,\\n\\t\\t\\t\\t\\tdelayedUpdateEnd);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tint visibleLines = textArea.getVisibleLines();\\n\\t\\t\\tif(visibleLines != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttextArea.chunkCache.getLineInfo(\\n\\t\\t\\t\\t\\tvisibleLines - 1);\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.getFoldLevel(delayedUpdateEnd);\\n\\t\\t} \\n\\t\\t\\t\\tprivate void contentInserted(Anchor anchor, int startLine,\\n\\t\\t\\tint numLines)\\n\\t\\t{\\n\\t\\t\\tif(anchor.physicalLine >= startLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(anchor.physicalLine != startLine)\\n\\t\\t\\t\\t\\tanchor.physicalLine += numLines;\\n\\t\\t\\t\\tanchor.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void preContentRemoved(Anchor anchor, int startLine,\\n\\t\\t\\tint numLines)\\n\\t\\t{\\n\\t\\t\\tif(anchor.physicalLine >= startLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(anchor.physicalLine == startLine)\\n\\t\\t\\t\\t\\tanchor.callChanged = true;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint end = Math.min(startLine + numLines,\\n\\t\\t\\t\\t\\t\\tanchor.physicalLine);\\n\\t\\t\\t\\t\\tfor(int i = startLine; i < end; i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(isLineVisible(i))\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tanchor.scrollLine -=\\n\\t\\t\\t\\t\\t\\t\\t\\tscreenLineMgr\\n\\t\\t\\t\\t\\t\\t\\t\\t.getScreenLineCount(i);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tanchor.physicalLine -= (end - startLine);\\n\\t\\t\\t\\t\\tanchor.callChanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void delayedUpdate(int startLine, int endLine)\\n\\t\\t{\\n\\t\\t\\ttextArea.chunkCache.invalidateChunksFromPhys(startLine);\\n\\t\\t\\tif(!delayedUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedUpdateStart = startLine;\\n\\t\\t\\t\\tdelayedUpdateEnd = endLine;\\n\\t\\t\\t\\tdelayedUpdate = true;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedUpdateStart = Math.min(\\n\\t\\t\\t\\t\\tdelayedUpdateStart,\\n\\t\\t\\t\\t\\tstartLine);\\n\\t\\t\\t\\tdelayedUpdateEnd = Math.max(\\n\\t\\t\\t\\t\\tdelayedUpdateEnd,\\n\\t\\t\\t\\t\\tendLine);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\tprivate boolean caretAutoScroll()\\n\\t\\t{\\n\\t\\t\\tView view = textArea.getView();\\n\\t\\t\\treturn view == jEdit.getActiveView()\\n\\t\\t\\t\\t&& view.getTextArea() == textArea;\\n\\t\\t} \\t} }\""
            },
            "m15": {
                "content": "After analyzing the source code of `DisplayManager.java`, here are key observations and conclusions:\n\n### Key Observations:\n1. **Purpose**:\n   - `DisplayManager` manages how lines of text are displayed in a `JEditTextArea`. It handles visibility, scrolling, folding (collapsing/expanding blocks of text), and screen-line calculations.\n\n2. **Core Dependencies**:\n   - Uses utility classes like `Log` for logging.\n   - Depends on several internal jEdit components such as:\n     - `Buffer`, `JEditTextArea`, `TextAreaPainter`\n     - Inner classes like `ScrollLineCount`, `FirstLine`, and `BufferChangeHandler`\n   - These dependencies are mostly instantiated or referenced internally within `DisplayManager`.\n\n3. **Coupling and Co-Change Insights**:\n   - Despite historical co-change relationships with files like `BufferChangeHandler.java`, `FirstLine.java`, and `ChunkCache.java`, there are no current direct coupling dependencies between them and `DisplayManager.java`.\n   - The only entities tightly coupled with `DisplayManager` are inner classes defined within it (e.g., `ScrollLineCount`, `FirstLine`, `BufferChangeHandler`), which do not require synchronization as they are encapsulated.\n\n4. **Call Graph**:\n   - Only calls `Log`, indicating minimal external interaction beyond its own logic and inner classes.\n\n### Conclusion:\nThere is **no need to synchronize any external entities** with `DisplayManager.java`. Its dependencies are either:\n- Internal (inner classes),\n- Removed from the project (`BufferChangeHandler`, `FirstLine`),\n- Or have no direct coupling (`ChunkCache`).\n\nThe class operates independently, maintaining its own state and logic for display behavior in `jEdit`.\n\nIf you'd like, we can proceed to analyze other entities or summarize this CIA task.",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            },
            "m16": {
                "role": "user",
                "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
            },
            "m17": {
                "content": "Title: Diagnosis of starting entity `DisplayManager`\n\nChange set: [BufferChangeHandler, FirstLine, ChunkCache, HelpIndex, HelpTOCPanel, View, RingListModel, OffsetManager, PosBottomHalf, PositionManager, PasteFromListDialog, ListHandler, KeyHandler, FontSelector, FontSelectorDialog, TextAreaOptionPane, ActionHandler, JEditTextArea, TextAreaPainter, EditPane, BeanShell, MouseHandler, Anchor, RangeMap, Log, ScreenLineManager, ScrollLineCount, BufferIORequest, Buffer, JEditTextArea, DisplayManager$ScrollLineCount, DisplayManager$FirstLine, DisplayManager$BufferChangeHandler, DisplayManager$Anchor]\n\nDetails:\n- **BufferChangeHandler**: Historically co-changed with high support (9) and confidence (0.5625), though removed in current version.\n- **FirstLine**: Frequently co-changed (support 6, confidence 0.375), but also removed in current version.\n- **ChunkCache**: Co-changed with moderate confidence (0.375), no coupling found, possibly involved in rendering or caching visible lines.\n- **HelpIndex, HelpTOCPanel, View**: Low confidence (0.125), may be involved in UI synchronization or event propagation.\n- **RingListModel, OffsetManager, PosBottomHalf, PositionManager, PasteFromListDialog, ListHandler, KeyHandler, FontSelector, FontSelectorDialog, TextAreaOptionPane, ActionHandler**: Low-to-moderate co-change values, possibly involved in UI interaction or configuration tied to display behavior.\n- **JEditTextArea, TextAreaPainter, EditPane**: Likely involved in direct rendering or text handling; part of the same package and tightly integrated with display logic.\n- **BeanShell, MouseHandler, Anchor, RangeMap**: Minimal impact, low co-change values, but referenced in code contextually (e.g., folding, selection).\n- **Log**: Appears in call graph; used for logging within display operations.\n- **ScreenLineManager**: Directly used by `DisplayManager` for screen-line calculations.\n- **ScrollLineCount**: Inner class managing scroll bar updates.\n- **Buffer**: Core dependency for line and fold data.\n- **DisplayManager$ScrollLineCount, DisplayManager$FirstLine, DisplayManager$BufferChangeHandler, DisplayManager$Anchor**: Internal classes directly manipulated by `DisplayManager`, subject to change if core logic is altered.\n- **BufferIORequest**: Co-changed moderately (support 4, confidence 0.25), possibly involved in buffer lifecycle events.\n\nThese entities are included based on historical co-change relationships, semantic coupling, or direct usage in managing text display, scrolling, and folding logic in jEdit.",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            }
        }
    }
}