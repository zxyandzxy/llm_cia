{
    "time": 1749459166.506761,
    "messages": [
        {
            "role": "system",
            "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
        },
        {
            "role": "user",
            "content": "The project you need to analyze is `jEdit`, a well-known Java open source project. The starting entity you need to deal with is jEdit.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
        },
        {
            "content": "",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_34d05ed295204d1c80b12e",
                    "function": {
                        "arguments": "{\"entity\": \"jEdit.java\"}",
                        "name": "get_co_change_relationship"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "name": "get_co_change_relationship",
            "role": "tool",
            "content": "[[\"Entry\", \"16\", \"0.053156146179401995\"], [\"BufferHistory\", \"15\", \"0.04983388704318937\"], [\"EditPane\", \"29\", \"0.09634551495016612\"], [\"RecentHandler\", \"5\", \"0.016611295681063124\"], [\"Buffer\", \"59\", \"0.19601328903654486\"], [\"SearchAndReplace\", \"19\", \"0.06312292358803986\"], [\"View\", \"47\", \"0.15614617940199335\"], [\"EditServer\", \"20\", \"0.0664451827242525\"], [\"WindowHandler\", \"5\", \"0.016611295681063124\"], [\"ActionHandler\", \"48\", \"0.15946843853820597\"], [\"GeneralOptionPane\", \"11\", \"0.036544850498338874\"], [\"JEditActionContext\", \"2\", \"0.006644518272425249\"], [\"ShortcutsOptionPane\", \"7\", \"0.023255813953488372\"], [\"ToolBarEditDialog\", \"9\", \"0.029900332225913623\"], [\"ActionContext\", \"5\", \"0.016611295681063124\"], [\"JEditVisitorAdapter\", \"1\", \"0.0033222591362126247\"], [\"JEditVisitor\", \"1\", \"0.0033222591362126247\"], [\"CompleteWord\", \"17\", \"0.05647840531561462\"], [\"SaveCaretInfoVisitor\", \"1\", \"0.0033222591362126247\"], [\"SetCursorVisitor\", \"1\", \"0.0033222591362126247\"], [\"GUIUtilities\", \"54\", \"0.17940199335548174\"], [\"RolloverButton\", \"3\", \"0.009966777408637873\"], [\"HyperSearchResults\", \"17\", \"0.05647840531561462\"], [\"ExpansionToggleBorder\", \"2\", \"0.006644518272425249\"], [\"PanelWindowContainer\", \"20\", \"0.0664451827242525\"], [\"AbbrevsOptionPane\", \"8\", \"0.026578073089700997\"], [\"FloatingWindowContainer\", \"13\", \"0.04318936877076412\"], [\"ToolBarOptionPane\", \"2\", \"0.006644518272425249\"], [\"PluginsMenuButton\", \"7\", \"0.023255813953488372\"], [\"CommandsMenuButton\", \"2\", \"0.006644518272425249\"], [\"FavoritesMenuButton\", \"4\", \"0.013289036544850499\"], [\"HistoryButton\", \"1\", \"0.0033222591362126247\"], [\"SaveButton\", \"1\", \"0.0033222591362126247\"], [\"ChoosePluginSet\", \"1\", \"0.0033222591362126247\"], [\"RestoreButton\", \"1\", \"0.0033222591362126247\"], [\"ClearPluginSet\", \"1\", \"0.0033222591362126247\"], [\"MouseOverHandler\", \"1\", \"0.0033222591362126247\"], [\"AppearanceOptionPane\", \"15\", \"0.04983388704318937\"], [\"IconTheme\", \"1\", \"0.0033222591362126247\"], [\"Debug\", \"7\", \"0.023255813953488372\"], [\"GrabKeyDialog\", \"5\", \"0.016611295681063124\"], [\"InputHandler\", \"6\", \"0.019933554817275746\"], [\"KeyEventWorkaround\", \"10\", \"0.03322259136212625\"], [\"TextAreaInputHandler\", \"1\", \"0.0033222591362126247\"], [\"KeyEventTranslator\", \"8\", \"0.026578073089700997\"], [\"MyFocusManager\", \"10\", \"0.03322259136212625\"], [\"InputPane\", \"7\", \"0.023255813953488372\"], [\"BufferSet\", \"1\", \"0.0033222591362126247\"], [\"BufferSetListener\", \"1\", \"0.0033222591362126247\"], [\"BufferSetManager\", \"4\", \"0.013289036544850499\"], [\"BufferSwitcher\", \"3\", \"0.009966777408637873\"], [\"BufferSetAdapter\", \"1\", \"0.0033222591362126247\"], [\"ViewOptionPane\", \"4\", \"0.013289036544850499\"], [\"DockableWindowContainer\", \"5\", \"0.016611295681063124\"], [\"DockableWindowManager\", \"51\", \"0.16943521594684385\"], [\"DockableWindowManagerImpl\", \"1\", \"0.0033222591362126247\"], [\"DockingArea\", \"1\", \"0.0033222591362126247\"], [\"DockingLayout\", \"2\", \"0.006644518272425249\"], [\"DockableLayout\", \"8\", \"0.026578073089700997\"], [\"DockBorder\", \"1\", \"0.0033222591362126247\"], [\"ButtonLayout\", \"4\", \"0.013289036544850499\"], [\"ViewConfig\", \"5\", \"0.016611295681063124\"], [\"DockablePanel\", \"3\", \"0.009966777408637873\"], [\"PerspectiveHandler\", \"6\", \"0.019933554817275746\"], [\"DockableWindowFactory\", \"5\", \"0.016611295681063124\"], [\"DockingLayoutManager\", \"2\", \"0.006644518272425249\"], [\"DockingLayoutSetter\", \"1\", \"0.0033222591362126247\"], [\"PerspectiveManager\", \"14\", \"0.046511627906976744\"], [\"SettingsXML\", \"1\", \"0.0033222591362126247\"], [\"DockingOptionPane\", \"2\", \"0.006644518272425249\"], [\"DockableWindowManagerProvider\", \"1\", \"0.0033222591362126247\"], [\"IDockingFrameworkProvider\", \"1\", \"0.0033222591362126247\"], [\"DockableWindowConfig\", \"1\", \"0.0033222591362126247\"], [\"LoadPerspectiveAction\", \"1\", \"0.0033222591362126247\"], [\"CloseDialog\", \"3\", \"0.009966777408637873\"], [\"SaveBackupOptionPane\", \"3\", \"0.009966777408637873\"], [\"Macros\", \"19\", \"0.06312292358803986\"], [\"DraggedURLLoader\", \"1\", \"0.0033222591362126247\"], [\"StringCompare\", \"2\", \"0.006644518272425249\"], [\"VFS\", \"17\", \"0.05647840531561462\"], [\"PluginTableModel\", \"24\", \"0.07973421926910298\"], [\"TableModelHandler\", \"3\", \"0.009966777408637873\"], [\"BufferOptionPane\", \"1\", \"0.0033222591362126247\"], [\"StyleTableModel\", \"6\", \"0.019933554817275746\"], [\"EditingOptionPane\", \"13\", \"0.04318936877076412\"], [\"EncodingsOptionPane\", \"1\", \"0.0033222591362126247\"], [\"ServiceFoldHandlerProvider\", \"1\", \"0.0033222591362126247\"], [\"RemoveButton\", \"7\", \"0.023255813953488372\"], [\"DirectoryProvider\", \"5\", \"0.016611295681063124\"], [\"SendVFSUpdatesSafely\", \"1\", \"0.0033222591362126247\"], [\"Mode\", \"7\", \"0.023255813953488372\"], [\"JEditTextArea\", \"74\", \"0.24584717607973422\"], [\"ParserRuleSet\", \"6\", \"0.019933554817275746\"], [\"VFSBrowser\", \"36\", \"0.11960132890365449\"], [\"HyperSearchResult\", \"7\", \"0.023255813953488372\"], [\"XModeHandler\", \"6\", \"0.019933554817275746\"], [\"DefaultInputHandler\", \"13\", \"0.04318936877076412\"], [\"PastePrevious\", \"3\", \"0.009966777408637873\"], [\"TokenMarker\", \"15\", \"0.04983388704318937\"], [\"JARClassLoader\", \"23\", \"0.07641196013289037\"], [\"PosBottomHalf\", \"4\", \"0.013289036544850499\"], [\"HyperSearchRequest\", \"11\", \"0.036544850498338874\"], [\"TextUtilities\", \"14\", \"0.046511627906976744\"], [\"Token\", \"1\", \"0.0033222591362126247\"], [\"OffsetManager\", \"17\", \"0.05647840531561462\"], [\"ModeOptionPane\", \"4\", \"0.013289036544850499\"], [\"TokenList\", \"1\", \"0.0033222591362126247\"], [\"CurrentDirectoryMenu\", \"2\", \"0.006644518272425249\"], [\"RecentDirectoriesMenu\", \"3\", \"0.009966777408637873\"], [\"ErrorEntry\", \"3\", \"0.009966777408637873\"], [\"MiscUtilities\", \"57\", \"0.1893687707641196\"], [\"OptionsDialog\", \"14\", \"0.046511627906976744\"], [\"FirewallOptionPane\", \"4\", \"0.013289036544850499\"], [\"Dependency\", \"9\", \"0.029900332225913623\"], [\"FirewallAuthenticator\", \"2\", \"0.006644518272425249\"], [\"OverviewOptionPane\", \"6\", \"0.019933554817275746\"], [\"BrowserJTree\", \"8\", \"0.026578073089700997\"], [\"HistoryTextField\", \"4\", \"0.013289036544850499\"], [\"BrowserView\", \"15\", \"0.04983388704318937\"], [\"PluginManagerProgress\", \"12\", \"0.03986710963455149\"], [\"MouseHandler\", \"45\", \"0.14950166112956811\"], [\"OperatingSystem\", \"12\", \"0.03986710963455149\"], [\"VFSManager\", \"3\", \"0.009966777408637873\"], [\"TextAreaPainter\", \"29\", \"0.09634551495016612\"], [\"BufferChangeHandler\", \"23\", \"0.07641196013289037\"], [\"FileVFS\", \"22\", \"0.07308970099667775\"], [\"StatusBar\", \"20\", \"0.0664451827242525\"], [\"SettingsReloader\", \"4\", \"0.013289036544850499\"], [\"LineInfo\", \"4\", \"0.013289036544850499\"], [\"ChunkCache\", \"18\", \"0.059800664451827246\"], [\"KeyHandler\", \"17\", \"0.05647840531561462\"], [\"EnhancedCheckBoxMenuItem\", \"7\", \"0.023255813953488372\"], [\"MarkersMenuItem\", \"2\", \"0.006644518272425249\"], [\"EnhancedMenuItem\", \"9\", \"0.029900332225913623\"], [\"BufferIORequest\", \"28\", \"0.09302325581395349\"], [\"InstallPluginsDialog\", \"14\", \"0.046511627906976744\"], [\"FileCellRenderer\", \"7\", \"0.023255813953488372\"], [\"PaneNameRenderer\", \"2\", \"0.006644518272425249\"], [\"FocusHandler\", \"2\", \"0.006644518272425249\"], [\"FoldVisibilityManager\", \"9\", \"0.029900332225913623\"], [\"Abbrevs\", \"10\", \"0.03322259136212625\"], [\"FavoritesVFS\", \"5\", \"0.016611295681063124\"], [\"CheckBoxListModel\", \"4\", \"0.013289036544850499\"], [\"BeanShell\", \"11\", \"0.036544850498338874\"], [\"MarkerHighlight\", \"3\", \"0.009966777408637873\"], [\"ListHandler\", \"2\", \"0.006644518272425249\"], [\"PluginList\", \"12\", \"0.03986710963455149\"], [\"WrapGuide\", \"2\", \"0.006644518272425249\"], [\"HelpViewer\", \"20\", \"0.0664451827242525\"], [\"BracketHighlight\", \"2\", \"0.006644518272425249\"], [\"AbstractOptionPane\", \"4\", \"0.013289036544850499\"], [\"SearchDialog\", \"18\", \"0.059800664451827246\"], [\"BufferOptions\", \"13\", \"0.04318936877076412\"], [\"ModeProperties\", \"8\", \"0.026578073089700997\"], [\"TOCHandler\", \"5\", \"0.016611295681063124\"], [\"TipOfTheDay\", \"6\", \"0.019933554817275746\"], [\"Gutter\", \"8\", \"0.026578073089700997\"], [\"ParentDirectoryRenderer\", \"3\", \"0.009966777408637873\"], [\"BufferPrintable\", \"8\", \"0.026578073089700997\"], [\"Handler\", \"8\", \"0.026578073089700997\"], [\"Macro\", \"11\", \"0.036544850498338874\"], [\"JAR\", \"18\", \"0.059800664451827246\"], [\"BeanShellHandler\", \"4\", \"0.013289036544850499\"], [\"ComponentHandler\", \"2\", \"0.006644518272425249\"], [\"PluginManager\", \"20\", \"0.0664451827242525\"], [\"JCheckBoxList\", \"4\", \"0.013289036544850499\"], [\"FileRootsVFS\", \"8\", \"0.026578073089700997\"], [\"EnhancedDialog\", \"2\", \"0.006644518272425249\"], [\"PluginListDownloadProgress\", \"2\", \"0.006644518272425249\"], [\"Wrapper\", \"5\", \"0.016611295681063124\"], [\"Rect\", \"7\", \"0.023255813953488372\"], [\"TOCTree\", \"3\", \"0.009966777408637873\"], [\"GlobalOptions\", \"10\", \"0.03322259136212625\"], [\"DownloadThread\", \"4\", \"0.013289036544850499\"], [\"MouseWheelHandler\", \"4\", \"0.013289036544850499\"], [\"BrowserColorsOptionPane\", \"2\", \"0.006644518272425249\"], [\"PropertyChangeHandler\", \"4\", \"0.013289036544850499\"], [\"HelpIndex\", \"10\", \"0.03322259136212625\"], [\"AnimatedIcon\", \"2\", \"0.006644518272425249\"], [\"SplashScreen\", \"7\", \"0.023255813953488372\"], [\"OSTask\", \"4\", \"0.013289036544850499\"], [\"Install\", \"16\", \"0.053156146179401995\"], [\"NonInteractiveInstall\", \"2\", \"0.006644518272425249\"], [\"SwingInstall\", \"4\", \"0.013289036544850499\"], [\"ConsoleInstall\", \"2\", \"0.006644518272425249\"], [\"GenerateTocXML\", \"2\", \"0.006644518272425249\"], [\"HelpTOCPanel\", \"12\", \"0.03986710963455149\"], [\"Chunk\", \"2\", \"0.006644518272425249\"], [\"RecentFilesMenu\", \"5\", \"0.016611295681063124\"], [\"DirectoryMenu\", \"2\", \"0.006644518272425249\"], [\"EnhancedMenu\", \"8\", \"0.026578073089700997\"], [\"MarkersMenu\", \"2\", \"0.006644518272425249\"], [\"MacrosMenu\", \"8\", \"0.026578073089700997\"], [\"HistoryModel\", \"17\", \"0.05647840531561462\"], [\"BeanShellAction\", \"5\", \"0.016611295681063124\"], [\"Registers\", \"18\", \"0.059800664451827246\"], [\"PaintSelection\", \"4\", \"0.013289036544850499\"], [\"RegistersHandler\", \"4\", \"0.013289036544850499\"], [\"TextAreaOptionPane\", \"9\", \"0.029900332225913623\"], [\"ActionTextField\", \"3\", \"0.009966777408637873\"], [\"Autosave\", \"4\", \"0.013289036544850499\"], [\"ActionBar\", \"10\", \"0.03322259136212625\"], [\"ExplicitFoldHandler\", \"2\", \"0.006644518272425249\"], [\"CompletionPopup\", \"6\", \"0.019933554817275746\"], [\"LogViewer\", \"7\", \"0.023255813953488372\"], [\"PaintLineBackground\", \"2\", \"0.006644518272425249\"], [\"Anchor\", \"2\", \"0.006644518272425249\"], [\"BufferChangeListener\", \"4\", \"0.013289036544850499\"], [\"PluginInfoBox\", \"4\", \"0.013289036544850499\"], [\"ListUpdater\", \"4\", \"0.013289036544850499\"], [\"BufferChangeAdapter\", \"4\", \"0.013289036544850499\"], [\"TextRenderer\", \"6\", \"0.019933554817275746\"], [\"InstallPanel\", \"6\", \"0.019933554817275746\"], [\"SizeLabel\", \"6\", \"0.019933554817275746\"], [\"ManagePanel\", \"9\", \"0.029900332225913623\"], [\"DirectoryEntryCompare\", \"4\", \"0.013289036544850499\"], [\"ActionSet\", \"33\", \"0.10963455149501661\"], [\"FirstLine\", \"10\", \"0.03322259136212625\"], [\"StatusBarOptionPane\", \"4\", \"0.013289036544850499\"], [\"LoadSaveOptionPane\", \"2\", \"0.006644518272425249\"], [\"QuickNotepad\", \"2\", \"0.006644518272425249\"], [\"DockableListHandler\", \"14\", \"0.046511627906976744\"], [\"Factory\", \"14\", \"0.046511627906976744\"], [\"ScrollLineCount\", \"2\", \"0.006644518272425249\"], [\"VFSFileNameField\", \"8\", \"0.026578073089700997\"], [\"DisplayManager\", \"12\", \"0.03986710963455149\"], [\"VFSFileChooserDialog\", \"9\", \"0.029900332225913623\"], [\"PluginManagerOptionPane\", \"4\", \"0.013289036544850499\"], [\"MirrorModel\", \"2\", \"0.006644518272425249\"], [\"BrowserOptionPane\", \"2\", \"0.006644518272425249\"], [\"DownloadMirrorsThread\", \"2\", \"0.006644518272425249\"], [\"BrowserHandler\", \"4\", \"0.013289036544850499\"], [\"ResourceCache\", \"9\", \"0.029900332225913623\"], [\"PaintBracketHighlight\", \"2\", \"0.006644518272425249\"], [\"PaintCaret\", \"6\", \"0.019933554817275746\"], [\"PaintText\", \"4\", \"0.013289036544850499\"], [\"PaintWrapGuide\", \"2\", \"0.006644518272425249\"], [\"FoldHandler\", \"4\", \"0.013289036544850499\"], [\"PluginCacheEntry\", \"15\", \"0.04983388704318937\"], [\"ServiceManager\", \"11\", \"0.036544850498338874\"], [\"ServiceListHandler\", \"8\", \"0.026578073089700997\"], [\"EditAction\", \"7\", \"0.023255813953488372\"], [\"Model\", \"3\", \"0.009966777408637873\"], [\"VFSDirectoryEntryTable\", \"5\", \"0.016611295681063124\"], [\"Remove\", \"18\", \"0.059800664451827246\"], [\"TableMouseHandler\", \"3\", \"0.009966777408637873\"], [\"VFSDirectoryEntryTableModel\", \"1\", \"0.0033222591362126247\"], [\"Descriptor\", \"3\", \"0.009966777408637873\"], [\"Deferred\", \"5\", \"0.016611295681063124\"], [\"EnhancedButton\", \"5\", \"0.016611295681063124\"], [\"PluginJAR\", \"65\", \"0.2159468438538206\"], [\"EditPlugin\", \"8\", \"0.026578073089700997\"], [\"Plugin\", \"8\", \"0.026578073089700997\"], [\"EBMessage\", \"4\", \"0.013289036544850499\"], [\"PluginResURLConnection\", \"2\", \"0.006644518272425249\"], [\"HelpButton\", \"11\", \"0.036544850498338874\"], [\"LatestVersionPlugin\", \"2\", \"0.006644518272425249\"], [\"PluginUpdate\", \"6\", \"0.019933554817275746\"], [\"BrowserCommandsMenu\", \"5\", \"0.016611295681063124\"], [\"VariableGridLayout\", \"2\", \"0.006644518272425249\"], [\"SearchBar\", \"5\", \"0.016611295681063124\"], [\"EditBus\", \"3\", \"0.009966777408637873\"], [\"EBPlugin\", \"2\", \"0.006644518272425249\"], [\"ThreadProgress\", \"2\", \"0.006644518272425249\"], [\"MarkersProvider\", \"2\", \"0.006644518272425249\"], [\"RecentDirectoriesProvider\", \"6\", \"0.019933554817275746\"], [\"RecentFilesProvider\", \"4\", \"0.013289036544850499\"], [\"DynamicMenuProvider\", \"2\", \"0.006644518272425249\"], [\"MacrosProvider\", \"2\", \"0.006644518272425249\"], [\"PluginsProvider\", \"2\", \"0.006644518272425249\"], [\"EvalError\", \"2\", \"0.006644518272425249\"], [\"PluginOptions\", \"2\", \"0.006644518272425249\"], [\"Roster\", \"8\", \"0.026578073089700997\"], [\"ScrollLayout\", \"4\", \"0.013289036544850499\"], [\"ExtensionManager\", \"2\", \"0.006644518272425249\"], [\"KillRing\", \"17\", \"0.05647840531561462\"], [\"UndoManager\", \"8\", \"0.026578073089700997\"], [\"Operation\", \"2\", \"0.006644518272425249\"], [\"InstallButton\", \"8\", \"0.026578073089700997\"], [\"RosterThread\", \"2\", \"0.006644518272425249\"], [\"LogList\", \"2\", \"0.006644518272425249\"], [\"IntegerArray\", \"3\", \"0.009966777408637873\"], [\"GutterOptionPane\", \"8\", \"0.026578073089700997\"], [\"EditAbbrevDialog\", \"4\", \"0.013289036544850499\"], [\"AbbrevsModel\", \"4\", \"0.013289036544850499\"], [\"BoyerMooreSearchMatcher\", \"8\", \"0.026578073089700997\"], [\"BrowserIORequest\", \"6\", \"0.019933554817275746\"], [\"EntryCompare\", \"3\", \"0.009966777408637873\"], [\"HeaderMouseHandler\", \"2\", \"0.006644518272425249\"], [\"BufferPrinter1_4\", \"2\", \"0.006644518272425249\"], [\"BufferPrinter1_3\", \"2\", \"0.006644518272425249\"], [\"PrintOptionPane\", \"6\", \"0.019933554817275746\"], [\"UnixWorkaround\", \"4\", \"0.013289036544850499\"], [\"InstallThread\", \"2\", \"0.006644518272425249\"], [\"OptionGroup\", \"2\", \"0.006644518272425249\"], [\"PositionManager\", \"2\", \"0.006644518272425249\"], [\"Highlight\", \"2\", \"0.006644518272425249\"], [\"Match\", \"2\", \"0.006644518272425249\"], [\"RESearchMatcher\", \"3\", \"0.009966777408637873\"], [\"MouseActions\", \"2\", \"0.006644518272425249\"], [\"Insert\", \"2\", \"0.006644518272425249\"], [\"KillRingHandler\", \"5\", \"0.016611295681063124\"], [\"NameSpace\", \"3\", \"0.009966777408637873\"], [\"SettingsActionHandler\", \"5\", \"0.016611295681063124\"], [\"TextAreaTransferHandler\", \"8\", \"0.026578073089700997\"], [\"TextAreaDialog\", \"5\", \"0.016611295681063124\"], [\"BeanShellErrorDialog\", \"2\", \"0.006644518272425249\"], [\"FilesChangedDialog\", \"6\", \"0.019933554817275746\"], [\"Renderer\", \"8\", \"0.026578073089700997\"], [\"TreeHandler\", \"2\", \"0.006644518272425249\"], [\"ButtonActionHandler\", \"2\", \"0.006644518272425249\"], [\"SelectallButton\", \"2\", \"0.006644518272425249\"], [\"RootsEntry\", \"4\", \"0.013289036544850499\"], [\"Delegate\", \"2\", \"0.006644518272425249\"], [\"ResultCellRenderer\", \"8\", \"0.026578073089700997\"], [\"MacOSPlugin\", \"2\", \"0.006644518272425249\"], [\"ErrorListCellRenderer\", \"2\", \"0.006644518272425249\"], [\"ShortcutsModel\", \"7\", \"0.023255813953488372\"], [\"BrowserActionContext\", \"2\", \"0.006644518272425249\"], [\"MemoryStatus\", \"8\", \"0.026578073089700997\"], [\"PropertyManager\", \"2\", \"0.006644518272425249\"], [\"Clock\", \"2\", \"0.006644518272425249\"], [\"DropHandler\", \"2\", \"0.006644518272425249\"], [\"RingListModel\", \"2\", \"0.006644518272425249\"], [\"KeywordMap\", \"2\", \"0.006644518272425249\"], [\"HelpFile\", \"2\", \"0.006644518272425249\"], [\"WorkThreadPool\", \"3\", \"0.009966777408637873\"], [\"DisplayTokenHandler\", \"2\", \"0.006644518272425249\"], [\"Windows\", \"2\", \"0.006644518272425249\"], [\"FontSelectorDialog\", \"3\", \"0.009966777408637873\"], [\"StyleEditor\", \"4\", \"0.013289036544850499\"], [\"SelectLineRange\", \"2\", \"0.006644518272425249\"], [\"ErrorListDialog\", \"2\", \"0.006644518272425249\"], [\"PasteFromListDialog\", \"4\", \"0.013289036544850499\"], [\"ContextAddDialog\", \"6\", \"0.019933554817275746\"], [\"AboutDialog\", \"2\", \"0.006644518272425249\"], [\"ViewRegisters\", \"2\", \"0.006644518272425249\"], [\"AddAbbrevDialog\", \"2\", \"0.006644518272425249\"], [\"ParserRule\", \"5\", \"0.016611295681063124\"], [\"JEditMetalTheme15\", \"2\", \"0.006644518272425249\"], [\"JEditMetalTheme14\", \"2\", \"0.006644518272425249\"], [\"TextAreaDropHandler\", \"2\", \"0.006644518272425249\"], [\"MyFocusTraversalPolicy\", \"2\", \"0.006644518272425249\"], [\"Broken\", \"2\", \"0.006644518272425249\"], [\"MarkerViewer\", \"2\", \"0.006644518272425249\"], [\"RegisterChanged\", \"2\", \"0.006644518272425249\"], [\"RegisterViewer\", \"2\", \"0.006644518272425249\"], [\"GoToNodeAction\", \"2\", \"0.006644518272425249\"], [\"HyperSearchFileNode\", \"2\", \"0.006644518272425249\"], [\"HyperSearchNode\", \"2\", \"0.006644518272425249\"], [\"MutableListModel\", \"2\", \"0.006644518272425249\"], [\"BufferLoadRequest\", \"2\", \"0.006644518272425249\"], [\"OpenBracketIndentRule\", \"2\", \"0.006644518272425249\"], [\"HelpViewerDialog\", \"2\", \"0.006644518272425249\"], [\"HelpViewerInterface\", \"2\", \"0.006644518272425249\"], [\"HelpSearchPanel\", \"2\", \"0.006644518272425249\"], [\"LinkHandler\", \"3\", \"0.009966777408637873\"], [\"BufferChanging\", \"2\", \"0.006644518272425249\"], [\"JEditBuffer\", \"2\", \"0.006644518272425249\"], [\"SegmentCharSequence\", \"2\", \"0.006644518272425249\"], [\"PluginListHandler\", \"2\", \"0.006644518272425249\"], [\"AllBufferSet\", \"2\", \"0.006644518272425249\"], [\"MirrorList\", \"4\", \"0.013289036544850499\"], [\"MirrorListHandler\", \"2\", \"0.006644518272425249\"], [\"SearchMatcher\", \"2\", \"0.006644518272425249\"], [\"DirectoryLoadedAWTRequest\", \"4\", \"0.013289036544850499\"], [\"ActionListHandler\", \"2\", \"0.006644518272425249\"], [\"ModeCatalogHandler\", \"2\", \"0.006644518272425249\"], [\"TagDecl\", \"3\", \"0.009966777408637873\"], [\"ColorEntry\", \"2\", \"0.006644518272425249\"], [\"PatternSearchMatcher\", \"2\", \"0.006644518272425249\"], [\"WindowTableModel\", \"4\", \"0.013289036544850499\"], [\"IOUtilities\", \"2\", \"0.006644518272425249\"], [\"FavoritesProvider\", \"2\", \"0.006644518272425249\"], [\"Branch\", \"2\", \"0.006644518272425249\"], [\"BufferListSet\", \"2\", \"0.006644518272425249\"], [\"StringICaseCompare\", \"3\", \"0.009966777408637873\"], [\"WindowCompare\", \"3\", \"0.009966777408637873\"], [\"AbbrevCompare\", \"3\", \"0.009966777408637873\"], [\"DockableWindowCompare\", \"2\", \"0.006644518272425249\"], [\"MenuItemCompare\", \"4\", \"0.013289036544850499\"], [\"ButtonCompare\", \"4\", \"0.013289036544850499\"], [\"PluginCompare\", \"2\", \"0.006644518272425249\"], [\"Log\", \"2\", \"0.006644518272425249\"], [\"Interpreter\", \"1\", \"0.0033222591362126247\"], [\"VICaretStatus\", \"2\", \"0.006644518272425249\"], [\"WorkThread\", \"3\", \"0.009966777408637873\"], [\"ColorTableModel\", \"4\", \"0.013289036544850499\"], [\"TabbedPane\", \"1\", \"0.0033222591362126247\"], [\"TipPanel\", \"1\", \"0.0033222591362126247\"], [\"StyleRenderer\", \"1\", \"0.0033222591362126247\"], [\"WorkThreadProgressListener\", \"1\", \"0.0033222591362126247\"], [\"WorkThreadHandler\", \"1\", \"0.0033222591362126247\"], [\"TOCCellRenderer\", \"1\", \"0.0033222591362126247\"], [\"HelpNode\", \"1\", \"0.0033222591362126247\"], [\"REMatch\", \"1\", \"0.0033222591362126247\"], [\"Button\", \"2\", \"0.006644518272425249\"], [\"ButtonCellRenderer\", \"1\", \"0.0033222591362126247\"], [\"MenuItem\", \"1\", \"0.0033222591362126247\"], [\"FileCompare\", \"1\", \"0.0033222591362126247\"], [\"FoldListener\", \"1\", \"0.0033222591362126247\"], [\"FoldEventHandler\", \"1\", \"0.0033222591362126247\"], [\"ContentManager\", \"1\", \"0.0033222591362126247\"], [\"ReadWriteLock\", \"1\", \"0.0033222591362126247\"], [\"PosTopHalf\", \"1\", \"0.0033222591362126247\"], [\"AboutPanel\", \"1\", \"0.0033222591362126247\"], [\"CompoundEdit\", \"1\", \"0.0033222591362126247\"], [\"BrowserColorsModel\", \"1\", \"0.0033222591362126247\"], [\"StyleChoice\", \"1\", \"0.0033222591362126247\"], [\"ColorChoice\", \"1\", \"0.0033222591362126247\"], [\"SizeSaver\", \"2\", \"0.006644518272425249\"], [\"MarkersSaveRequest\", \"1\", \"0.0033222591362126247\"], [\"BufferSaveRequest\", \"1\", \"0.0033222591362126247\"], [\"JEditKillRing\", \"1\", \"0.0033222591362126247\"]]"
        },
        {
            "content": "The co-change relationships for `jEdit.java` have been obtained, and they show a list of entities along with their support count and confidence level. These values indicate how often these files were modified together with `jEdit.java` in the past.\n\nHere are some key observations from the results:\n\n- Entities like `Buffer`, `View`, `ActionHandler`, `GUIUtilities`, `DockableWindowManager`, `MiscUtilities`, `JEditTextArea`, and `PluginJAR` have high confidence values (> 0.2), which means they are frequently changed together with `jEdit.java`. These should be considered as strong candidates for synchronization.\n  \n- Many other entities have relatively lower confidence values but still show significant coupling (e.g., `EditPane`, `SearchAndReplace`, `TextAreaPainter`, etc.). Depending on the nature of changes made to `jEdit.java`, these might also need to be reviewed.\n\nNow, let's dig deeper into one of these files to understand its role in the system and potential dependencies. A good candidate would be `Buffer.java`, as it has the highest confidence value (0.196) among the co-change relationships.\n\nI will call the `get_origin_code` function to retrieve the source code of `Buffer.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_1540c4573cc84f5c877c3e",
                    "function": {
                        "arguments": "{\"entity\": \"Buffer.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package org.gjt.sp.jedit;\\nimport gnu.regexp.*;\\nimport javax.swing.*;\\nimport javax.swing.text.*;\\nimport java.awt.Toolkit;\\nimport java.io.File;\\nimport java.io.IOException;\\nimport java.net.Socket;\\nimport java.util.*;\\nimport org.gjt.sp.jedit.browser.VFSBrowser;\\nimport org.gjt.sp.jedit.buffer.*;\\nimport org.gjt.sp.jedit.io.*;\\nimport org.gjt.sp.jedit.msg.*;\\nimport org.gjt.sp.jedit.search.RESearchMatcher;\\nimport org.gjt.sp.jedit.syntax.*;\\nimport org.gjt.sp.jedit.textarea.*;\\nimport org.gjt.sp.util.*;\\npublic class Buffer\\n{\\n\\tpublic static final String LINESEP = \\\"lineSeparator\\\";\\n\\tpublic static final String BACKED_UP = \\\"Buffer__backedUp\\\";\\n\\tpublic static final String CARET = \\\"Buffer__caret\\\";\\n\\tpublic static final String SELECTION = \\\"Buffer__selection\\\";\\n\\tpublic static final String SCROLL_VERT = \\\"Buffer__scrollVert\\\";\\n\\tpublic static final String SCROLL_HORIZ = \\\"Buffer__scrollHoriz\\\";\\n\\tpublic static final String ENCODING = \\\"encoding\\\";\\n\\tpublic static final String TRAILING_EOL = \\\"trailingEOL\\\";\\n\\tpublic static final String GZIPPED = \\\"gzipped\\\";\\n\\tpublic void showInsertFileDialog(View view)\\n\\t{\\n\\t\\tString[] files = GUIUtilities.showVFSFileDialog(view,null,\\n\\t\\t\\tVFSBrowser.OPEN_DIALOG,false);\\n\\t\\tif(files != null)\\n\\t\\t\\tinsertFile(view,files[0]);\\n\\t} \\n\\tpublic void reload(View view)\\n\\t{\\n\\t\\tif(getFlag(DIRTY))\\n\\t\\t{\\n\\t\\t\\tString[] args = { name };\\n\\t\\t\\tint result = GUIUtilities.confirm(view,\\\"changedreload\\\",\\n\\t\\t\\t\\targs,JOptionPane.YES_NO_OPTION,\\n\\t\\t\\t\\tJOptionPane.WARNING_MESSAGE);\\n\\t\\t\\tif(result != JOptionPane.YES_OPTION)\\n\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tview.getEditPane().saveCaretInfo();\\n\\t\\tload(view,true);\\n\\t} \\n\\tpublic boolean load(final View view, final boolean reload)\\n\\t{\\n\\t\\tif(isPerformingIO())\\n\\t\\t{\\n\\t\\t\\tGUIUtilities.error(view,\\\"buffer-multiple-io\\\",null);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tsetBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);\\n\\t\\tsetFlag(LOADING,true);\\n\\t\\t\\t\\t\\t\\t\\t\\tif(!getFlag(TEMPORARY))\\n\\t\\t\\tEditBus.send(new BufferUpdate(this,view,BufferUpdate.LOAD_STARTED));\\n\\t\\tfinal boolean loadAutosave;\\n\\t\\tif(reload || !getFlag(NEW_FILE))\\n\\t\\t{\\n\\t\\t\\tif(file != null)\\n\\t\\t\\t\\tmodTime = file.lastModified();\\n\\t\\t\\t\\t\\t\\tif(!reload && autosaveFile != null && autosaveFile.exists())\\n\\t\\t\\t\\tloadAutosave = recoverAutosave(view);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(autosaveFile != null)\\n\\t\\t\\t\\t\\tautosaveFile.delete();\\n\\t\\t\\t\\tloadAutosave = false;\\n\\t\\t\\t}\\n\\t\\t\\tif(!loadAutosave)\\n\\t\\t\\t{\\n\\t\\t\\t\\tVFS vfs = VFSManager.getVFSForPath(path);\\n\\t\\t\\t\\tif(!checkFileForLoad(view,vfs,path))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsetFlag(LOADING,false);\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(isNewFile())\\n\\t\\t\\t\\t\\t;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!vfs.load(view,this,path))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tsetFlag(LOADING,false);\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tloadAutosave = false;\\n\\t\\t\\t\\tRunnable runnable = new Runnable()\\n\\t\\t{\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\tString newPath = getStringProperty(\\n\\t\\t\\t\\t\\tBufferIORequest.NEW_PATH);\\n\\t\\t\\t\\tSegment seg = (Segment)getProperty(\\n\\t\\t\\t\\t\\tBufferIORequest.LOAD_DATA);\\n\\t\\t\\t\\tIntegerArray endOffsets = (IntegerArray)\\n\\t\\t\\t\\t\\tgetProperty(BufferIORequest.END_OFFSETS);\\n\\t\\t\\t\\tif(seg == null)\\n\\t\\t\\t\\t\\tseg = new Segment(new char[1024],0,0);\\n\\t\\t\\t\\tif(endOffsets == null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tendOffsets = new IntegerArray();\\n\\t\\t\\t\\t\\tendOffsets.add(1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twriteLock();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfirePreContentRemoved(0,0,getLineCount()\\n\\t\\t\\t\\t\\t\\t- 1,getLength());\\n\\t\\t\\t\\t\\tcontentMgr.remove(0,getLength());\\n\\t\\t\\t\\t\\tlineMgr.contentRemoved(0,0,getLineCount()\\n\\t\\t\\t\\t\\t\\t- 1,getLength());\\n\\t\\t\\t\\t\\tpositionMgr.contentRemoved(0,getLength());\\n\\t\\t\\t\\t\\tfireContentRemoved(0,0,getLineCount()\\n\\t\\t\\t\\t\\t\\t- 1,getLength());\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcontentMgr._setContent(seg.array,seg.count);\\n\\t\\t\\t\\t\\tlineMgr._contentInserted(endOffsets);\\n\\t\\t\\t\\t\\tpositionMgr.contentInserted(0,seg.count);\\n\\t\\t\\t\\t\\tfireContentInserted(0,0,\\n\\t\\t\\t\\t\\t\\tendOffsets.getSize() - 1,\\n\\t\\t\\t\\t\\t\\tseg.count - 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfinally\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twriteUnlock();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tunsetProperty(BufferIORequest.LOAD_DATA);\\n\\t\\t\\t\\tunsetProperty(BufferIORequest.END_OFFSETS);\\n\\t\\t\\t\\tunsetProperty(BufferIORequest.NEW_PATH);\\n\\t\\t\\t\\tundoMgr.clear();\\n\\t\\t\\t\\tundoMgr.setLimit(jEdit.getIntegerProperty(\\n\\t\\t\\t\\t\\t\\\"buffer.undoCount\\\",100));\\n\\t\\t\\t\\tif(!getFlag(TEMPORARY))\\n\\t\\t\\t\\t\\tfinishLoading();\\n\\t\\t\\t\\tsetFlag(LOADING,false);\\n\\t\\t\\t\\t\\t\\t\\t\\tif(reload)\\n\\t\\t\\t\\t\\tsetDirty(false);\\n\\t\\t\\t\\tif(!loadAutosave && newPath != null)\\n\\t\\t\\t\\t\\tsetPath(newPath);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(loadAutosave)\\n\\t\\t\\t\\t\\tsetFlag(DIRTY,true);\\n\\t\\t\\t\\t\\t\\t\\t\\tif(!getFlag(TEMPORARY))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tEditBus.send(new BufferUpdate(Buffer.this,\\n\\t\\t\\t\\t\\t\\tview,BufferUpdate.LOADED));\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}; \\n\\t\\tif(getFlag(TEMPORARY))\\n\\t\\t\\trunnable.run();\\n\\t\\telse\\n\\t\\t\\tVFSManager.runInAWTThread(runnable);\\n\\t\\treturn true;\\n\\t} \\n\\tpublic boolean insertFile(final View view, String path)\\n\\t{\\n\\t\\tif(isPerformingIO())\\n\\t\\t{\\n\\t\\t\\tGUIUtilities.error(view,\\\"buffer-multiple-io\\\",null);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tsetBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);\\n\\t\\tpath = MiscUtilities.constructPath(this.path,path);\\n\\t\\tBuffer buffer = jEdit.getBuffer(path);\\n\\t\\tif(buffer != null)\\n\\t\\t{\\n\\t\\t\\tview.getTextArea().setSelectedText(\\n\\t\\t\\t\\tbuffer.getText(0,buffer.getLength()));\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tVFS vfs = VFSManager.getVFSForPath(path);\\n\\t\\tsetFlag(IO,true);\\n\\t\\t\\t\\t\\t\\t\\t\\tif(!vfs.insert(view,this,path))\\n\\t\\t{\\n\\t\\t\\tsetFlag(IO,false);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\t\\tVFSManager.runInAWTThread(new Runnable()\\n\\t\\t{\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFlag(IO,false);\\n\\t\\t\\t\\tSegmentBuffer sbuf = (SegmentBuffer)getProperty(\\n\\t\\t\\t\\t\\tBufferIORequest.LOAD_DATA);\\n\\t\\t\\t\\tif(sbuf != null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tunsetProperty(BufferIORequest.LOAD_DATA);\\n\\t\\t\\t\\t\\tview.getTextArea().setSelectedText(sbuf.toString());\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\treturn true;\\n\\t} \\n\\tpublic void autosave()\\n\\t{\\n\\t\\tif(autosaveFile == null || !getFlag(AUTOSAVE_DIRTY)\\n\\t\\t\\t|| !getFlag(DIRTY)\\n\\t\\t\\t|| getFlag(LOADING)\\n\\t\\t\\t|| getFlag(IO))\\n\\t\\t\\treturn;\\n\\t\\tsetFlag(AUTOSAVE_DIRTY,false);\\n\\t\\tVFSManager.runInWorkThread(new BufferIORequest(\\n\\t\\t\\tBufferIORequest.AUTOSAVE,null,this,null,\\n\\t\\t\\tVFSManager.getFileVFS(),autosaveFile.getPath()));\\n\\t} \\n\\tpublic boolean saveAs(View view, boolean rename)\\n\\t{\\n\\t\\tString[] files = GUIUtilities.showVFSFileDialog(view,path,\\n\\t\\t\\tVFSBrowser.SAVE_DIALOG,false);\\n\\t\\t\\t\\t\\t\\tif(files == null)\\n\\t\\t\\treturn false;\\n\\t\\treturn save(view,files[0],rename);\\n\\t} \\n\\tpublic boolean save(View view, String path)\\n\\t{\\n\\t\\treturn save(view,path,true);\\n\\t} \\n\\tpublic boolean save(final View view, String path, final boolean rename)\\n\\t{\\n\\t\\tif(isPerformingIO())\\n\\t\\t{\\n\\t\\t\\tGUIUtilities.error(view,\\\"buffer-multiple-io\\\",null);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tsetBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);\\n\\t\\tif(path == null && getFlag(NEW_FILE))\\n\\t\\t\\treturn saveAs(view,rename);\\n\\t\\tif(path == null && file != null)\\n\\t\\t{\\n\\t\\t\\tlong newModTime = file.lastModified();\\n\\t\\t\\tif(newModTime != modTime\\n\\t\\t\\t\\t&& jEdit.getBooleanProperty(\\\"view.checkModStatus\\\"))\\n\\t\\t\\t{\\n\\t\\t\\t\\tObject[] args = { this.path };\\n\\t\\t\\t\\tint result = GUIUtilities.confirm(view,\\n\\t\\t\\t\\t\\t\\\"filechanged-save\\\",args,\\n\\t\\t\\t\\t\\tJOptionPane.YES_NO_OPTION,\\n\\t\\t\\t\\t\\tJOptionPane.WARNING_MESSAGE);\\n\\t\\t\\t\\tif(result != JOptionPane.YES_OPTION)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsetFlag(IO,true);\\n\\t\\tEditBus.send(new BufferUpdate(this,view,BufferUpdate.SAVING));\\n\\t\\tfinal String oldPath = this.path;\\n\\t\\tfinal String newPath = (path == null ? this.path : path);\\n\\t\\tVFS vfs = VFSManager.getVFSForPath(newPath);\\n\\t\\tif(!checkFileForSave(view,vfs,newPath))\\n\\t\\t{\\n\\t\\t\\tsetFlag(IO,false);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tif(!vfs.save(view,this,newPath))\\n\\t\\t{\\n\\t\\t\\tsetFlag(IO,false);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\t\\tVFSManager.runInAWTThread(new Runnable()\\n\\t\\t{\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFlag(IO,false);\\n\\t\\t\\t\\tfinishSaving(view,oldPath,newPath,rename,\\n\\t\\t\\t\\t\\tgetBooleanProperty(BufferIORequest\\n\\t\\t\\t\\t\\t.ERROR_OCCURRED));\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\treturn true;\\n\\t} \\n\\t\\tpublic static final int FILE_NOT_CHANGED = 0;\\n\\tpublic static final int FILE_CHANGED = 1;\\n\\tpublic static final int FILE_DELETED = 2;\\n\\tpublic int checkFileStatus(View view)\\n\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(!getFlag(IO) && !getFlag(LOADING) && file != null\\n\\t\\t\\t&& !getFlag(NEW_FILE))\\n\\t\\t{\\n\\t\\t\\tboolean newReadOnly = (file.exists() && !file.canWrite());\\n\\t\\t\\tif(newReadOnly != getFlag(READ_ONLY))\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFlag(READ_ONLY,newReadOnly);\\n\\t\\t\\t\\tEditBus.send(new BufferUpdate(this,null,\\n\\t\\t\\t\\t\\tBufferUpdate.DIRTY_CHANGED));\\n\\t\\t\\t}\\n\\t\\t\\tlong oldModTime = modTime;\\n\\t\\t\\tlong newModTime = file.lastModified();\\n\\t\\t\\tif(newModTime != oldModTime)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmodTime = newModTime;\\n\\t\\t\\t\\tif(!file.exists())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsetFlag(NEW_FILE,true);\\n\\t\\t\\t\\t\\tsetDirty(true);\\n\\t\\t\\t\\t\\treturn FILE_DELETED;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn FILE_CHANGED;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn FILE_NOT_CHANGED;\\n\\t} \\n\\tpublic long getLastModified()\\n\\t{\\n\\t\\treturn modTime;\\n\\t} \\n\\tpublic void setLastModified(long modTime)\\n\\t{\\n\\t\\tthis.modTime = modTime;\\n\\t} \\n\\tpublic VFS getVFS()\\n\\t{\\n\\t\\treturn VFSManager.getVFSForPath(path);\\n\\t} \\n\\tpublic File getAutosaveFile()\\n\\t{\\n\\t\\treturn autosaveFile;\\n\\t} \\n\\tpublic String getName()\\n\\t{\\n\\t\\treturn name;\\n\\t} \\n\\tpublic String getPath()\\n\\t{\\n\\t\\treturn path;\\n\\t} \\n\\tpublic String getSymlinkPath()\\n\\t{\\n\\t\\treturn symlinkPath;\\n\\t} \\n\\tpublic String getDirectory()\\n\\t{\\n\\t\\treturn directory;\\n\\t} \\n\\tpublic boolean isClosed()\\n\\t{\\n\\t\\treturn getFlag(CLOSED);\\n\\t} \\n\\tpublic boolean isLoaded()\\n\\t{\\n\\t\\treturn !getFlag(LOADING);\\n\\t} \\n\\tpublic boolean isPerformingIO()\\n\\t{\\n\\t\\treturn getFlag(LOADING) || getFlag(IO);\\n\\t} \\n\\tpublic boolean isNewFile()\\n\\t{\\n\\t\\treturn getFlag(NEW_FILE);\\n\\t} \\n\\tpublic void setNewFile(boolean newFile)\\n\\t{\\n\\t\\tsetFlag(NEW_FILE,newFile);\\n\\t\\tif(!newFile)\\n\\t\\t\\tsetFlag(UNTITLED,false);\\n\\t} \\n\\tpublic boolean isUntitled()\\n\\t{\\n\\t\\treturn getFlag(UNTITLED);\\n\\t} \\n\\tpublic boolean isDirty()\\n\\t{\\n\\t\\treturn getFlag(DIRTY);\\n\\t} \\n\\tpublic boolean isReadOnly()\\n\\t{\\n\\t\\treturn getFlag(READ_ONLY) || getFlag(READ_ONLY_OVERRIDE);\\n\\t} \\n\\tpublic boolean isEditable()\\n\\t{\\n\\t\\treturn !(getFlag(READ_ONLY) || getFlag(READ_ONLY_OVERRIDE)\\n\\t\\t\\t|| getFlag(IO) || getFlag(LOADING));\\n\\t} \\n\\tpublic void setReadOnly(boolean readOnly)\\n\\t{\\n\\t\\tsetFlag(READ_ONLY_OVERRIDE,readOnly);\\n\\t} \\n\\tpublic void setDirty(boolean d)\\n\\t{\\n\\t\\tboolean old_d = getFlag(DIRTY);\\n\\t\\tif(d)\\n\\t\\t{\\n\\t\\t\\tif(isEditable())\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFlag(DIRTY,true);\\n\\t\\t\\t\\tsetFlag(AUTOSAVE_DIRTY,true);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tsetFlag(DIRTY,false);\\n\\t\\t\\tsetFlag(AUTOSAVE_DIRTY,false);\\n\\t\\t\\tif(autosaveFile != null)\\n\\t\\t\\t\\tautosaveFile.delete();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(!getFlag(UNDO_IN_PROGRESS))\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tundoMgr.bufferSaved();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(d != old_d)\\n\\t\\t{\\n\\t\\t\\tEditBus.send(new BufferUpdate(this,null,\\n\\t\\t\\t\\tBufferUpdate.DIRTY_CHANGED));\\n\\t\\t}\\n\\t} \\n\\tpublic boolean isTemporary()\\n\\t{\\n\\t\\treturn getFlag(TEMPORARY);\\n\\t} \\n\\tpublic Icon getIcon()\\n\\t{\\n\\t\\tif(getFlag(DIRTY))\\n\\t\\t\\treturn GUIUtilities.DIRTY_BUFFER_ICON;\\n\\t\\telse if(getFlag(READ_ONLY) || getFlag(READ_ONLY_OVERRIDE))\\n\\t\\t\\treturn GUIUtilities.READ_ONLY_BUFFER_ICON;\\n\\t\\telse if(getFlag(NEW_FILE))\\n\\t\\t\\treturn GUIUtilities.NEW_BUFFER_ICON;\\n\\t\\telse\\n\\t\\t\\treturn GUIUtilities.NORMAL_BUFFER_ICON;\\n\\t} \\n\\tpublic void readLock()\\n\\t{\\n\\t\\tlock.readLock();\\n\\t} \\n\\tpublic void readUnlock()\\n\\t{\\n\\t\\tlock.readUnlock();\\n\\t} \\n\\tpublic void writeLock()\\n\\t{\\n\\t\\tlock.writeLock();\\n\\t} \\n\\tpublic void writeUnlock()\\n\\t{\\n\\t\\tlock.writeUnlock();\\n\\t} \\n\\tpublic int getLength()\\n\\t{\\n\\t\\t\\t\\treturn contentMgr.getLength();\\n\\t} \\n\\tpublic int getLineCount()\\n\\t{\\n\\t\\t\\t\\treturn lineMgr.getLineCount();\\n\\t} \\n\\tpublic int getLineOfOffset(int offset)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tif(offset < 0 || offset > getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(offset);\\n\\t\\t\\treturn lineMgr.getLineOfOffset(offset);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic int getLineStartOffset(int line)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tif(line < 0 || line >= lineMgr.getLineCount())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(line);\\n\\t\\t\\telse if(line == 0)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\treturn lineMgr.getLineEndOffset(line - 1);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic int getLineEndOffset(int line)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tif(line < 0 || line >= lineMgr.getLineCount())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(line);\\n\\t\\t\\treturn lineMgr.getLineEndOffset(line);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic int getLineLength(int line)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\treturn getLineEndOffset(line)\\n\\t\\t\\t\\t- getLineStartOffset(line) - 1;\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic String getLineText(int line)\\n\\t{\\n\\t\\tif(line < 0 || line >= lineMgr.getLineCount())\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(line);\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tint start = (line == 0 ? 0\\n\\t\\t\\t\\t: lineMgr.getLineEndOffset(line - 1));\\n\\t\\t\\tint end = lineMgr.getLineEndOffset(line);\\n\\t\\t\\treturn getText(start,end - start - 1);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void getLineText(int line, Segment segment)\\n\\t{\\n\\t\\tif(line < 0 || line >= lineMgr.getLineCount())\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(line);\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tint start = (line == 0 ? 0\\n\\t\\t\\t\\t: lineMgr.getLineEndOffset(line - 1));\\n\\t\\t\\tint end = lineMgr.getLineEndOffset(line);\\n\\t\\t\\tgetText(start,end - start - 1,segment);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic String getText(int start, int length)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tif(start < 0 || length < 0\\n\\t\\t\\t\\t|| start + length > contentMgr.getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(start + \\\":\\\" + length);\\n\\t\\t\\treturn contentMgr.getText(start,length);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void getText(int start, int length, Segment seg)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tif(start < 0 || length < 0\\n\\t\\t\\t\\t|| start + length > contentMgr.getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(start + \\\":\\\" + length);\\n\\t\\t\\tcontentMgr.getText(start,length,seg);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void insert(int offset, String str)\\n\\t{\\n\\t\\tif(str == null)\\n\\t\\t\\treturn;\\n\\t\\tint len = str.length();\\n\\t\\tif(len == 0)\\n\\t\\t\\treturn;\\n\\t\\tif(isReadOnly())\\n\\t\\t\\tthrow new RuntimeException(\\\"buffer read-only\\\");\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tif(offset < 0 || offset > contentMgr.getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(offset);\\n\\t\\t\\tcontentMgr.insert(offset,str);\\n\\t\\t\\tintegerArray.clear();\\n\\t\\t\\tfor(int i = 0; i < len; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(str.charAt(i) == '\\\\n')\\n\\t\\t\\t\\t\\tintegerArray.add(i + 1);\\n\\t\\t\\t}\\n\\t\\t\\tif(!getFlag(UNDO_IN_PROGRESS))\\n\\t\\t\\t{\\n\\t\\t\\t\\tundoMgr.contentInserted(offset,len,str,\\n\\t\\t\\t\\t\\t!getFlag(DIRTY));\\n\\t\\t\\t}\\n\\t\\t\\tcontentInserted(offset,len,integerArray);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void insert(int offset, Segment seg)\\n\\t{\\n\\t\\tif(seg.count == 0)\\n\\t\\t\\treturn;\\n\\t\\tif(isReadOnly())\\n\\t\\t\\tthrow new RuntimeException(\\\"buffer read-only\\\");\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tif(offset < 0 || offset > contentMgr.getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(offset);\\n\\t\\t\\tcontentMgr.insert(offset,seg);\\n\\t\\t\\tintegerArray.clear();\\n\\t\\t\\tfor(int i = 0; i < seg.count; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(seg.array[seg.offset + i] == '\\\\n')\\n\\t\\t\\t\\t\\tintegerArray.add(i + 1);\\n\\t\\t\\t}\\n\\t\\t\\tif(!getFlag(UNDO_IN_PROGRESS))\\n\\t\\t\\t{\\n\\t\\t\\t\\tundoMgr.contentInserted(offset,seg.count,\\n\\t\\t\\t\\t\\tseg.toString(),!getFlag(DIRTY));\\n\\t\\t\\t}\\n\\t\\t\\tcontentInserted(offset,seg.count,integerArray);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void remove(int offset, int length)\\n\\t{\\n\\t\\tif(length == 0)\\n\\t\\t\\treturn;\\n\\t\\tif(isReadOnly())\\n\\t\\t\\tthrow new RuntimeException(\\\"buffer read-only\\\");\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tif(offset < 0 || length < 0\\n\\t\\t\\t\\t|| offset + length > contentMgr.getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(offset + \\\":\\\" + length);\\n\\t\\t\\tint startLine = lineMgr.getLineOfOffset(offset);\\n\\t\\t\\tint endLine = lineMgr.getLineOfOffset(offset + length);\\n\\t\\t\\tint numLines = endLine - startLine;\\n\\t\\t\\tif(!getFlag(UNDO_IN_PROGRESS) && !getFlag(LOADING))\\n\\t\\t\\t{\\n\\t\\t\\t\\tundoMgr.contentRemoved(offset,length,\\n\\t\\t\\t\\t\\tgetText(offset,length),\\n\\t\\t\\t\\t\\t!getFlag(DIRTY));\\n\\t\\t\\t}\\n\\t\\t\\tfirePreContentRemoved(startLine,offset,numLines,length);\\n\\t\\t\\tcontentMgr.remove(offset,length);\\n\\t\\t\\tlineMgr.contentRemoved(startLine,offset,numLines,length);\\n\\t\\t\\tpositionMgr.contentRemoved(offset,length);\\n\\t\\t\\tfireContentRemoved(startLine,offset,numLines,length);\\n\\t\\t\\tsetDirty(true);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void undo(JEditTextArea textArea)\\n\\t{\\n\\t\\tif(undoMgr == null)\\n\\t\\t\\treturn;\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\ttextArea.getToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tsetFlag(UNDO_IN_PROGRESS,true);\\n\\t\\t\\tint caret = undoMgr.undo();\\n\\t\\t\\tif(caret == -1)\\n\\t\\t\\t\\ttextArea.getToolkit().beep();\\n\\t\\t\\telse\\n\\t\\t\\t\\ttextArea.setCaretPosition(caret);\\n\\t\\t\\tfireTransactionComplete();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tsetFlag(UNDO_IN_PROGRESS,false);\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void redo(JEditTextArea textArea)\\n\\t{\\n\\t\\tif(undoMgr == null)\\n\\t\\t\\treturn;\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tToolkit.getDefaultToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tsetFlag(UNDO_IN_PROGRESS,true);\\n\\t\\t\\tint caret = undoMgr.redo();\\n\\t\\t\\tif(caret == -1)\\n\\t\\t\\t\\ttextArea.getToolkit().beep();\\n\\t\\t\\telse\\n\\t\\t\\t\\ttextArea.setCaretPosition(caret);\\n\\t\\t\\tfireTransactionComplete();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tsetFlag(UNDO_IN_PROGRESS,false);\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic boolean isTransactionInProgress()\\n\\t{\\n\\t\\treturn getFlag(UNDO_IN_PROGRESS) || insideCompoundEdit();\\n\\t} \\n\\tpublic void beginCompoundEdit()\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tundoMgr.beginCompoundEdit();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void endCompoundEdit()\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tundoMgr.endCompoundEdit();\\n\\t\\t\\tif(!insideCompoundEdit())\\n\\t\\t\\t\\tfireTransactionComplete();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t}\\n\\tpublic boolean insideCompoundEdit()\\n\\t{\\n\\t\\treturn undoMgr.insideCompoundEdit();\\n\\t} \\n\\t\\tpublic static final int NORMAL_PRIORITY = 0;\\n\\tpublic static final int HIGH_PRIORITY = 1;\\n\\tstatic class Listener\\n\\t{\\n\\t\\tBufferChangeListener listener;\\n\\t\\tint priority;\\n\\t\\tListener(BufferChangeListener listener, int priority)\\n\\t\\t{\\n\\t\\t\\tthis.listener = listener;\\n\\t\\t\\tthis.priority = priority;\\n\\t\\t}\\n\\t}\\n\\tpublic void addBufferChangeListener(BufferChangeListener listener,\\n\\t\\tint priority)\\n\\t{\\n\\t\\tListener l = new Listener(listener,priority);\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\tListener _l = (Listener)bufferListeners.get(i);\\n\\t\\t\\tif(_l.priority < priority)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbufferListeners.insertElementAt(l,i);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbufferListeners.addElement(l);\\n\\t} \\n\\tpublic void addBufferChangeListener(BufferChangeListener listener)\\n\\t{\\n\\t\\taddBufferChangeListener(listener,NORMAL_PRIORITY);\\n\\t} \\n\\tpublic void removeBufferChangeListener(BufferChangeListener listener)\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\tif(((Listener)bufferListeners.get(i)).listener == listener)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbufferListeners.removeElementAt(i);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic BufferChangeListener[] getBufferChangeListeners()\\n\\t{\\n\\t\\tBufferChangeListener[] returnValue\\n\\t\\t\\t= new BufferChangeListener[\\n\\t\\t\\tbufferListeners.size()];\\n\\t\\tfor(int i = 0; i < returnValue.length; i++)\\n\\t\\t{\\n\\t\\t\\treturnValue[i] = ((Listener)bufferListeners.get(i))\\n\\t\\t\\t\\t.listener;\\n\\t\\t}\\n\\t\\treturn returnValue;\\n\\t} \\n\\tpublic void propertiesChanged()\\n\\t{\\n\\t\\tString folding = getStringProperty(\\\"folding\\\");\\n\\t\\tFoldHandler handler = FoldHandler.getFoldHandler(folding);\\n\\t\\tif(handler != null)\\n\\t\\t{\\n\\t\\t\\tsetFoldHandler(handler);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif (folding != null)\\n\\t\\t\\t\\tLog.log(Log.WARNING, this, path + \\\": invalid 'folding' property: \\\" + folding); \\n\\t\\t\\tsetFoldHandler(new DummyFoldHandler());\\n\\t\\t}\\n\\t\\tEditBus.send(new BufferUpdate(this,null,BufferUpdate.PROPERTIES_CHANGED));\\n\\t\\tString newWrap = getStringProperty(\\\"wrap\\\");\\n\\t\\tif(wrap != null && !newWrap.equals(wrap))\\n\\t\\t{\\n\\t\\t\\tlineMgr.invalidateScreenLineCounts();\\n\\t\\t\\tif(isLoaded())\\n\\t\\t\\t\\tfireWrapModeChanged();\\n\\t\\t}\\n\\t\\tthis.wrap = newWrap;\\n\\t} \\n\\tpublic int getTabSize()\\n\\t{\\n\\t\\treturn getIntegerProperty(\\\"tabSize\\\",8);\\n\\t} \\n\\tpublic int getIndentSize()\\n\\t{\\n\\t\\treturn getIntegerProperty(\\\"indentSize\\\",8);\\n\\t} \\n\\tpublic Object getProperty(Object name)\\n\\t{\\n\\t\\tsynchronized(propertyLock)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tPropValue o = (PropValue)properties.get(name);\\n\\t\\t\\tif(o != null)\\n\\t\\t\\t\\treturn o.value;\\n\\t\\t\\t\\t\\t\\tif(!(name instanceof String))\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t\\t\\t\\tif(mode != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tObject retVal = mode.getProperty((String)name);\\n\\t\\t\\t\\tif(retVal == null)\\n\\t\\t\\t\\t\\treturn null;\\n\\t\\t\\t\\tproperties.put(name,new PropValue(retVal,true));\\n\\t\\t\\t\\treturn retVal;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tString value = jEdit.getProperty(\\\"buffer.\\\" + name);\\n\\t\\t\\t\\tif(value == null)\\n\\t\\t\\t\\t\\treturn null;\\n\\t\\t\\t\\t\\t\\t\\t\\tObject retVal;\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tretVal = new Integer(value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(NumberFormatException nf)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tretVal = value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tproperties.put(name,new PropValue(retVal,true));\\n\\t\\t\\t\\treturn retVal;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic void setProperty(String name, Object value)\\n\\t{\\n\\t\\tif(value == null)\\n\\t\\t\\tproperties.remove(name);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tPropValue test = (PropValue)properties.get(name);\\n\\t\\t\\tif(test == null)\\n\\t\\t\\t\\tproperties.put(name,new PropValue(value,false));\\n\\t\\t\\telse if(test.value.equals(value))\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\ttest.value = value;\\n\\t\\t\\t\\ttest.defaultValue = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic void unsetProperty(String name)\\n\\t{\\n\\t\\tproperties.remove(name);\\n\\t} \\n\\tpublic String getStringProperty(String name)\\n\\t{\\n\\t\\tObject obj = getProperty(name);\\n\\t\\tif(obj != null)\\n\\t\\t\\treturn obj.toString();\\n\\t\\telse\\n\\t\\t\\treturn null;\\n\\t} \\n\\tpublic void setStringProperty(String name, String value)\\n\\t{\\n\\t\\tsetProperty(name,value);\\n\\t} \\n\\tpublic boolean getBooleanProperty(String name)\\n\\t{\\n\\t\\tObject obj = getProperty(name);\\n\\t\\tif(obj instanceof Boolean)\\n\\t\\t\\treturn ((Boolean)obj).booleanValue();\\n\\t\\telse if(\\\"true\\\".equals(obj) || \\\"on\\\".equals(obj) || \\\"yes\\\".equals(obj))\\n\\t\\t\\treturn true;\\n\\t\\telse\\n\\t\\t\\treturn false;\\n\\t} \\n\\tpublic void setBooleanProperty(String name, boolean value)\\n\\t{\\n\\t\\tsetProperty(name,value ? Boolean.TRUE : Boolean.FALSE);\\n\\t} \\n\\tpublic int getIntegerProperty(String name, int defaultValue)\\n\\t{\\n\\t\\tboolean defaultValueFlag;\\n\\t\\tObject obj;\\n\\t\\tPropValue value = (PropValue)properties.get(name);\\n\\t\\tif(value != null)\\n\\t\\t{\\n\\t\\t\\tobj = value.value;\\n\\t\\t\\tdefaultValueFlag = value.defaultValue;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tobj = getProperty(name);\\n\\t\\t\\t\\t\\t\\tdefaultValueFlag = true;\\n\\t\\t}\\n\\t\\tif(obj == null)\\n\\t\\t\\treturn defaultValue;\\n\\t\\telse if(obj instanceof Number)\\n\\t\\t\\treturn ((Number)obj).intValue();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tint returnValue = Integer.parseInt(\\n\\t\\t\\t\\t\\tobj.toString().trim());\\n\\t\\t\\t\\tproperties.put(name,new PropValue(\\n\\t\\t\\t\\t\\tnew Integer(returnValue),\\n\\t\\t\\t\\t\\tdefaultValueFlag));\\n\\t\\t\\t\\treturn returnValue;\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Exception e)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn defaultValue;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic void setIntegerProperty(String name, int value)\\n\\t{\\n\\t\\tsetProperty(name,new Integer(value));\\n\\t} \\n\\tpublic RE getRegexpProperty(String name, int cflags,\\n\\t\\tRESyntax syntax) throws REException\\n\\t{\\n\\t\\tsynchronized(propertyLock)\\n\\t\\t{\\n\\t\\t\\tboolean defaultValueFlag;\\n\\t\\t\\tObject obj;\\n\\t\\t\\tPropValue value = (PropValue)properties.get(name);\\n\\t\\t\\tif(value != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tobj = value.value;\\n\\t\\t\\t\\tdefaultValueFlag = value.defaultValue;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tobj = getProperty(name);\\n\\t\\t\\t\\t\\t\\t\\t\\tdefaultValueFlag = true;\\n\\t\\t\\t}\\n\\t\\t\\tif(obj == null)\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\telse if(obj instanceof RE)\\n\\t\\t\\t\\treturn (RE)obj;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tRE re = new RE(obj.toString(),cflags,syntax);\\n\\t\\t\\t\\tproperties.put(name,new PropValue(re,\\n\\t\\t\\t\\t\\tdefaultValueFlag));\\n\\t\\t\\t\\treturn re;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic ParserRuleSet getRuleSetAtOffset(int offset)\\n\\t{\\n\\t\\tint line = getLineOfOffset(offset);\\n\\t\\toffset -= getLineStartOffset(line);\\n\\t\\tif(offset != 0)\\n\\t\\t\\toffset--;\\n\\t\\tDefaultTokenHandler tokens = new DefaultTokenHandler();\\n\\t\\tmarkTokens(line,tokens);\\n\\t\\tToken token = TextUtilities.getTokenAtOffset(tokens.getTokens(),offset);\\n\\t\\treturn token.rules;\\n\\t} \\n\\tpublic KeywordMap getKeywordMapAtOffset(int offset)\\n\\t{\\n\\t\\treturn getRuleSetAtOffset(offset).getKeywords();\\n\\t} \\n\\tpublic String getContextSensitiveProperty(int offset, String name)\\n\\t{\\n\\t\\tParserRuleSet rules = getRuleSetAtOffset(offset);\\n\\t\\tObject value = null;\\n\\t\\tHashtable rulesetProps = rules.getProperties();\\n\\t\\tif(rulesetProps != null)\\n\\t\\t\\tvalue = rulesetProps.get(name);\\n\\t\\tif(value == null)\\n\\t\\t{\\n\\t\\t\\tvalue = jEdit.getMode(rules.getModeName())\\n\\t\\t\\t\\t.getProperty(name);\\n\\t\\t\\tif(value == null)\\n\\t\\t\\t\\tvalue = mode.getProperty(name);\\n\\t\\t}\\n\\t\\tif(value == null)\\n\\t\\t\\treturn null;\\n\\t\\telse\\n\\t\\t\\treturn String.valueOf(value);\\n\\t} \\n\\t\\tstatic class PropValue\\n\\t{\\n\\t\\tPropValue(Object value, boolean defaultValue)\\n\\t\\t{\\n\\t\\t\\tif(value == null)\\n\\t\\t\\t\\tthrow new NullPointerException();\\n\\t\\t\\tthis.value = value;\\n\\t\\t\\tthis.defaultValue = defaultValue;\\n\\t\\t}\\n\\t\\tObject value;\\n\\t\\tboolean defaultValue;\\n\\t\\tpublic String toString()\\n\\t\\t{\\n\\t\\t\\treturn value.toString();\\n\\t\\t}\\n\\t} \\n\\tpublic void toggleWordWrap(View view)\\n\\t{\\n\\t\\tString wrap = getStringProperty(\\\"wrap\\\");\\n\\t\\tif(wrap.equals(\\\"none\\\"))\\n\\t\\t\\twrap = \\\"soft\\\";\\n\\t\\telse if(wrap.equals(\\\"soft\\\"))\\n\\t\\t\\twrap = \\\"hard\\\";\\n\\t\\telse if(wrap.equals(\\\"hard\\\"))\\n\\t\\t\\twrap = \\\"none\\\";\\n\\t\\tview.getStatus().setMessageAndClear(jEdit.getProperty(\\n\\t\\t\\t\\\"view.status.wrap-changed\\\",new String[] {\\n\\t\\t\\twrap }));\\n\\t\\tsetProperty(\\\"wrap\\\",wrap);\\n\\t\\tpropertiesChanged();\\n\\t} \\n\\tpublic void toggleLineSeparator(View view)\\n\\t{\\n\\t\\tString status = null;\\n\\t\\tString lineSep = getStringProperty(\\\"lineSeparator\\\");\\n\\t\\tif(\\\"\\\\n\\\".equals(lineSep))\\n\\t\\t{\\n\\t\\t\\tstatus = \\\"windows\\\";\\n\\t\\t\\tlineSep = \\\"\\\\r\\\\n\\\";\\n\\t\\t}\\n\\t\\telse if(\\\"\\\\r\\\\n\\\".equals(lineSep))\\n\\t\\t{\\n\\t\\t\\tstatus = \\\"mac\\\";\\n\\t\\t\\tlineSep = \\\"\\\\r\\\";\\n\\t\\t}\\n\\t\\telse if(\\\"\\\\r\\\".equals(lineSep))\\n\\t\\t{\\n\\t\\t\\tstatus = \\\"unix\\\";\\n\\t\\t\\tlineSep = \\\"\\\\n\\\";\\n\\t\\t}\\n\\t\\tview.getStatus().setMessageAndClear(jEdit.getProperty(\\n\\t\\t\\t\\\"view.status.linesep-changed\\\",new String[] {\\n\\t\\t\\tjEdit.getProperty(\\\"lineSep.\\\" + status) }));\\n\\t\\tsetProperty(\\\"lineSeparator\\\",lineSep);\\n\\t\\tsetDirty(true);\\n\\t\\tpropertiesChanged();\\n\\t} \\n\\tpublic Mode getMode()\\n\\t{\\n\\t\\treturn mode;\\n\\t} \\n\\tpublic void setMode(String mode)\\n\\t{\\n\\t\\tsetMode(jEdit.getMode(mode));\\n\\t} \\n\\tpublic void setMode(Mode mode)\\n\\t{\\n\\t\\tif(mode == null)\\n\\t\\t\\tthrow new NullPointerException(\\\"Mode must be non-null\\\");\\n\\t\\tthis.mode = mode;\\n\\t\\ttextMode = \\\"text\\\".equals(mode.getName());\\n\\t\\tsetTokenMarker(mode.getTokenMarker());\\n\\t\\tresetCachedProperties();\\n\\t\\tpropertiesChanged();\\n\\t} \\n\\tpublic void setMode()\\n\\t{\\n\\t\\tString userMode = getStringProperty(\\\"mode\\\");\\n\\t\\tif(userMode != null)\\n\\t\\t{\\n\\t\\t\\tMode m = jEdit.getMode(userMode);\\n\\t\\t\\tif(m != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetMode(m);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tString nogzName = name.substring(0,name.length() -\\n\\t\\t\\t(name.endsWith(\\\".gz\\\") ? 3 : 0));\\n\\t\\tMode[] modes = jEdit.getModes();\\n\\t\\tString firstLine = getLineText(0);\\n\\t\\tfor(int i = 0; i < modes.length; i++)\\n\\t\\t{\\n\\t\\t\\tif(modes[i].accept(nogzName,firstLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetMode(modes[i]);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tMode defaultMode = jEdit.getMode(jEdit.getProperty(\\\"buffer.defaultMode\\\"));\\n\\t\\tif(defaultMode == null)\\n\\t\\t\\tdefaultMode = jEdit.getMode(\\\"text\\\");\\n\\t\\tsetMode(defaultMode);\\n\\t} \\n\\tpublic void markTokens(int lineIndex, TokenHandler tokenHandler)\\n\\t{\\n\\t\\tSegment seg;\\n\\t\\tif(SwingUtilities.isEventDispatchThread())\\n\\t\\t\\tseg = this.seg;\\n\\t\\telse\\n\\t\\t\\tseg = new Segment();\\n\\t\\tif(lineIndex < 0 || lineIndex >= lineMgr.getLineCount())\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(lineIndex);\\n\\t\\tint firstInvalidLineContext = lineMgr.getFirstInvalidLineContext();\\n\\t\\tint start;\\n\\t\\tif(textMode || firstInvalidLineContext == -1)\\n\\t\\t{\\n\\t\\t\\tstart = lineIndex;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstart = Math.min(firstInvalidLineContext,\\n\\t\\t\\t\\tlineIndex);\\n\\t\\t}\\n\\t\\tif(Debug.TOKEN_MARKER_DEBUG)\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"tokenize from \\\" + start + \\\" to \\\" + lineIndex);\\n\\t\\tfor(int i = start; i <= lineIndex; i++)\\n\\t\\t{\\n\\t\\t\\tgetLineText(i,seg);\\n\\t\\t\\tTokenMarker.LineContext context = lineMgr.getLineContext(i);\\n\\t\\t\\tParserRule oldRule;\\n\\t\\t\\tParserRuleSet oldRules;\\n\\t\\t\\tchar[] oldSpanEndSubst;\\n\\t\\t\\tif(context == null)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\toldRule = null;\\n\\t\\t\\t\\toldRules = null;\\n\\t\\t\\t\\toldSpanEndSubst = null;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\toldRule = context.inRule;\\n\\t\\t\\t\\toldRules = context.rules;\\n\\t\\t\\t\\toldSpanEndSubst = (context.parent != null\\n\\t\\t\\t\\t\\t? context.parent.spanEndSubst\\n\\t\\t\\t\\t\\t: null);\\n\\t\\t\\t}\\n\\t\\t\\tTokenMarker.LineContext prevContext = (\\n\\t\\t\\t\\t(i == 0 || textMode) ? null\\n\\t\\t\\t\\t: lineMgr.getLineContext(i - 1)\\n\\t\\t\\t);\\n\\t\\t\\tcontext = tokenMarker.markTokens(prevContext,\\n\\t\\t\\t\\t(i == lineIndex ? tokenHandler\\n\\t\\t\\t\\t: DummyTokenHandler.INSTANCE),seg);\\n\\t\\t\\tlineMgr.setLineContext(i,context);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(oldRule != context.inRule)\\n\\t\\t\\t{\\n\\t\\t\\t\\tnextLineRequested = true;\\n\\t\\t\\t}\\n\\t\\t\\telse if(oldRules != context.rules)\\n\\t\\t\\t{\\n\\t\\t\\t\\tnextLineRequested = true;\\n\\t\\t\\t}\\n\\t\\t\\telse if(!MiscUtilities.objectsEqual(oldSpanEndSubst,\\n\\t\\t\\t\\tcontext.spanEndSubst))\\n\\t\\t\\t{\\n\\t\\t\\t\\tnextLineRequested = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint lineCount = lineMgr.getLineCount();\\n\\t\\tif(lineCount - 1 == lineIndex)\\n\\t\\t\\tlineMgr.setFirstInvalidLineContext(-1);\\n\\t\\telse if(nextLineRequested)\\n\\t\\t\\tlineMgr.setFirstInvalidLineContext(lineIndex + 1);\\n\\t\\telse if(firstInvalidLineContext == -1)\\n\\t\\t\\t;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlineMgr.setFirstInvalidLineContext(Math.max(\\n\\t\\t\\t\\tfirstInvalidLineContext,lineIndex + 1));\\n\\t\\t}\\n\\t} \\n\\tpublic boolean isNextLineRequested()\\n\\t{\\n\\t\\tboolean retVal = nextLineRequested;\\n\\t\\tnextLineRequested = false;\\n\\t\\treturn retVal;\\n\\t} \\n\\tpublic void removeTrailingWhiteSpace(int[] lines)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbeginCompoundEdit();\\n\\t\\t\\tfor(int i = 0; i < lines.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint pos, lineStart, lineEnd, tail;\\n\\t\\t\\t\\tgetLineText(lines[i],seg);\\n\\t\\t\\t\\t\\t\\t\\t\\tif (seg.count == 0) continue;\\n\\t\\t\\t\\tlineStart = seg.offset;\\n\\t\\t\\t\\tlineEnd = seg.offset + seg.count - 1;\\n\\t\\t\\t\\tfor (pos = lineEnd; pos >= lineStart; pos--)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (!Character.isWhitespace(seg.array[pos]))\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttail = lineEnd - pos;\\n\\t\\t\\t\\t\\t\\t\\t\\tif (tail == 0) continue;\\n\\t\\t\\t\\tremove(getLineEndOffset(lines[i]) - 1 - tail,tail);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tendCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void shiftIndentLeft(int[] lines)\\n\\t{\\n\\t\\tint tabSize = getTabSize();\\n\\t\\tint indentSize = getIndentSize();\\n\\t\\tboolean noTabs = getBooleanProperty(\\\"noTabs\\\");\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbeginCompoundEdit();\\n\\t\\t\\tfor(int i = 0; i < lines.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint lineStart = getLineStartOffset(lines[i]);\\n\\t\\t\\t\\tString line = getLineText(lines[i]);\\n\\t\\t\\t\\tint whiteSpace = MiscUtilities\\n\\t\\t\\t\\t\\t.getLeadingWhiteSpace(line);\\n\\t\\t\\t\\tif(whiteSpace == 0)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tint whiteSpaceWidth = Math.max(0,MiscUtilities\\n\\t\\t\\t\\t\\t.getLeadingWhiteSpaceWidth(line,tabSize)\\n\\t\\t\\t\\t\\t- indentSize);\\n\\t\\t\\t\\tinsert(lineStart + whiteSpace,MiscUtilities\\n\\t\\t\\t\\t\\t.createWhiteSpace(whiteSpaceWidth,\\n\\t\\t\\t\\t\\t(noTabs ? 0 : tabSize)));\\n\\t\\t\\t\\tremove(lineStart,whiteSpace);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tendCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void shiftIndentRight(int[] lines)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbeginCompoundEdit();\\n\\t\\t\\tint tabSize = getTabSize();\\n\\t\\t\\tint indentSize = getIndentSize();\\n\\t\\t\\tboolean noTabs = getBooleanProperty(\\\"noTabs\\\");\\n\\t\\t\\tfor(int i = 0; i < lines.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint lineStart = getLineStartOffset(lines[i]);\\n\\t\\t\\t\\tString line = getLineText(lines[i]);\\n\\t\\t\\t\\tint whiteSpace = MiscUtilities\\n\\t\\t\\t\\t\\t.getLeadingWhiteSpace(line);\\n\\t\\t\\t\\tint whiteSpaceWidth = MiscUtilities\\n\\t\\t\\t\\t\\t.getLeadingWhiteSpaceWidth(\\n\\t\\t\\t\\t\\tline,tabSize) + indentSize;\\n\\t\\t\\t\\tinsert(lineStart + whiteSpace,MiscUtilities\\n\\t\\t\\t\\t\\t.createWhiteSpace(whiteSpaceWidth,\\n\\t\\t\\t\\t\\t(noTabs ? 0 : tabSize)));\\n\\t\\t\\t\\tremove(lineStart,whiteSpace);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tendCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void indentLines(int start, int end)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbeginCompoundEdit();\\n\\t\\t\\tfor(int i = start; i <= end; i++)\\n\\t\\t\\t\\tindentLine(i,true);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tendCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void indentLines(int[] lines)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbeginCompoundEdit();\\n\\t\\t\\tfor(int i = 0; i < lines.length; i++)\\n\\t\\t\\t\\tindentLine(lines[i],true);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tendCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic boolean indentLine(int lineIndex, boolean canIncreaseIndent,\\n\\t\\tboolean canDecreaseIndent)\\n\\t{\\n\\t\\treturn indentLine(lineIndex,canDecreaseIndent);\\n\\t} \\n\\tpublic boolean indentLine(int lineIndex, boolean canDecreaseIndent)\\n\\t{\\n\\t\\tint[] whitespaceChars = new int[1];\\n\\t\\tint currentIndent = getCurrentIdentForLine(lineIndex,\\n\\t\\t\\twhitespaceChars);\\n\\t\\tint idealIndent = getIdealIndentForLine(lineIndex);\\n\\t\\tif(idealIndent == -1 || idealIndent == currentIndent\\n\\t\\t\\t|| (!canDecreaseIndent && idealIndent < currentIndent))\\n\\t\\t\\treturn false;\\n\\t\\t\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbeginCompoundEdit();\\n\\t\\t\\tint start = getLineStartOffset(lineIndex);\\n\\t\\t\\tremove(start,whitespaceChars[0]);\\n\\t\\t\\tinsert(start,MiscUtilities.createWhiteSpace(\\n\\t\\t\\t\\tidealIndent,(getBooleanProperty(\\\"noTabs\\\")\\n\\t\\t\\t\\t? 0 : getTabSize())));\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tendCompoundEdit();\\n\\t\\t}\\n\\t\\treturn true;\\n\\t} \\n\\tpublic int getCurrentIdentForLine(int lineIndex, int[] whitespaceChars)\\n\\t{\\n\\t\\tgetLineText(lineIndex,seg);\\n\\t\\tint tabSize = getTabSize();\\n\\t\\tint currentIndent = 0;\\nloop:\\t\\tfor(int i = 0; i < seg.count; i++)\\n\\t\\t{\\n\\t\\t\\tchar c = seg.array[seg.offset + i];\\n\\t\\t\\tswitch(c)\\n\\t\\t\\t{\\n\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcurrentIndent++;\\n\\t\\t\\t\\twhitespaceChars[0]++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\tcurrentIndent += (tabSize - (currentIndent\\n\\t\\t\\t\\t\\t% tabSize));\\n\\t\\t\\t\\twhitespaceChars[0]++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn currentIndent;\\n\\t} \\n\\tpublic int getIdealIndentForLine(int lineIndex)\\n\\t{\\n\\t\\tfinal String EXPLICIT_START = \\\"{{{\\\";\\n\\t\\tfinal String EXPLICIT_END = \\\"}}}\\\";\\n\\t\\tif(lineIndex == 0)\\n\\t\\t\\treturn -1;\\n\\t\\t\\t\\tString openBrackets = getStringProperty(\\\"indentOpenBrackets\\\");\\n\\t\\tif(openBrackets == null)\\n\\t\\t\\topenBrackets = \\\"\\\";\\n\\t\\tString closeBrackets = getStringProperty(\\\"indentCloseBrackets\\\");\\n\\t\\tif(closeBrackets == null)\\n\\t\\t\\tcloseBrackets = \\\"\\\";\\n\\t\\tRE indentNextLineRE;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tindentNextLineRE = getRegexpProperty(\\\"indentNextLine\\\",\\n\\t\\t\\t\\tRE.REG_ICASE,RESearchMatcher.RE_SYNTAX_JEDIT);\\n\\t\\t}\\n\\t\\tcatch(REException re)\\n\\t\\t{\\n\\t\\t\\tindentNextLineRE = null;\\n\\t\\t\\tLog.log(Log.ERROR,this,\\\"Invalid indentNextLine regexp\\\");\\n\\t\\t\\tLog.log(Log.ERROR,this,re);\\n\\t\\t}\\n\\t\\tRE indentNextLinesRE;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tindentNextLinesRE = getRegexpProperty(\\\"indentNextLines\\\",\\n\\t\\t\\t\\tRE.REG_ICASE,RESearchMatcher.RE_SYNTAX_JEDIT);\\n\\t\\t}\\n\\t\\tcatch(REException re)\\n\\t\\t{\\n\\t\\t\\tindentNextLinesRE = null;\\n\\t\\t\\tLog.log(Log.ERROR,this,\\\"Invalid indentNextLines regexp\\\");\\n\\t\\t\\tLog.log(Log.ERROR,this,re);\\n\\t\\t}\\n\\t\\tboolean doubleBracketIndent = getBooleanProperty(\\\"doubleBracketIndent\\\");\\n\\t\\tboolean lineUpClosingBracket = getBooleanProperty(\\\"lineUpClosingBracket\\\");\\n\\t\\tint tabSize = getTabSize();\\n\\t\\tint indentSize = getIndentSize();\\n\\t\\t\\t\\tint prevLineIndex = getPriorNonEmptyLine(lineIndex);\\n\\t\\tif(prevLineIndex == -1)\\n\\t\\t\\treturn -1;\\n\\t\\tString prevLine = getLineText(prevLineIndex);\\n\\t\\tboolean prevLineStart = true; \\t\\tint indent = 0; \\t\\tint prevLineBrackets = 0; \\t\\tint prevLineCloseBracketIndex = -1; \\t\\t                                    \\t\\t                                    \\t\\t                                    \\t\\t                                    \\t\\t                                    \\t\\t                                    \\t\\t                                    \\t\\tint prevLineUnclosedParenIndex = -1; \\t\\tStack openParens = new Stack();\\n\\t\\tfor(int i = 0; i < prevLine.length(); i++)\\n\\t\\t{\\n\\t\\t\\tchar c = prevLine.charAt(i);\\n\\t\\t\\tswitch(c)\\n\\t\\t\\t{\\n\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tif(prevLineStart)\\n\\t\\t\\t\\t\\tindent++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\tif(prevLineStart)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tindent += (tabSize\\n\\t\\t\\t\\t\\t\\t- (indent\\n\\t\\t\\t\\t\\t\\t% tabSize));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase '(':\\n\\t\\t\\t\\topenParens.push(new Integer(i));\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase ')':\\n\\t\\t\\t\\tif(openParens.size() > 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\topenParens.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tprevLineStart = false;\\n\\t\\t\\t\\tif(closeBrackets.indexOf(c) != -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(prevLine.regionMatches(false,\\n\\t\\t\\t\\t\\t\\ti,EXPLICIT_END,0,3))\\n\\t\\t\\t\\t\\t\\ti += 2;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tprevLineBrackets--;\\n\\t\\t\\t\\t\\t\\tif(prevLineBrackets < 0)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(lineUpClosingBracket)\\n\\t\\t\\t\\t\\t\\t\\t\\tprevLineBrackets = 0;\\n\\t\\t\\t\\t\\t\\t\\tprevLineCloseBracketIndex = i;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(openBrackets.indexOf(c) != -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(prevLine.regionMatches(false,\\n\\t\\t\\t\\t\\t\\ti,EXPLICIT_START,0,3))\\n\\t\\t\\t\\t\\t\\ti += 2;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tprevLineBrackets++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(openParens.size() > 0)\\n\\t\\t{\\n\\t\\t\\tprevLineUnclosedParenIndex = ((Integer) openParens.pop()).intValue();\\n\\t\\t} \\n\\t\\t\\t\\tString line = getLineText(lineIndex);\\n\\t\\tint lineBrackets = 0; \\t\\tint closeBracketIndex = -1; \\t\\t\\t\\t\\tfor(int i = 0; i < line.length(); i++)\\n\\t\\t{\\n\\t\\t\\tchar c = line.charAt(i);\\n\\t\\t\\tif(closeBrackets.indexOf(c) != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(line.regionMatches(false,\\n\\t\\t\\t\\t\\ti,EXPLICIT_END,0,3))\\n\\t\\t\\t\\t\\ti += 2;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcloseBracketIndex = i;\\n\\t\\t\\t\\t\\tlineBrackets--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(openBrackets.indexOf(c) != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(line.regionMatches(false,\\n\\t\\t\\t\\t\\ti,EXPLICIT_START,0,3))\\n\\t\\t\\t\\t\\ti += 2;\\n\\t\\t\\t\\telse if(lineBrackets >= 0)\\n\\t\\t\\t\\t\\tlineBrackets++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(openParens.size() > 0)\\n\\t\\t{\\n\\t\\t\\tprevLineUnclosedParenIndex = ((Integer) openParens.pop()).intValue();\\n\\t\\t} \\n\\t\\t\\t\\tif(getBooleanProperty(\\\"deepIndent\\\"))\\n\\t\\t{\\n\\t\\t\\tif(prevLineUnclosedParenIndex != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tindent = prevLineUnclosedParenIndex;\\n\\t\\t\\t\\tfor(int i = 0; i < prevLine.length(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(prevLine.charAt(i) == '\\\\t')\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tindent += tabSize-1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tindent++;\\n\\t\\t\\t\\treturn indent;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tif(prevLineBrackets > 0)\\n\\t\\t\\tindent += (indentSize * prevLineBrackets);\\n\\t\\tif(lineUpClosingBracket)\\n\\t\\t{\\n\\t\\t\\tif(lineBrackets < 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint offset = TextUtilities.findMatchingBracket(\\n\\t\\t\\t\\t\\tthis,lineIndex,closeBracketIndex);\\n\\t\\t\\t\\tif(offset != -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tString closeLine = getLineText(getLineOfOffset(offset));\\n\\t\\t\\t\\t\\tindent = MiscUtilities.getLeadingWhiteSpaceWidth(\\n\\t\\t\\t\\t\\t\\tcloseLine,tabSize);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(prevLineBrackets < 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint offset = TextUtilities.findMatchingBracket(\\n\\t\\t\\t\\t\\tthis,prevLineIndex,prevLineCloseBracketIndex);\\n\\t\\t\\t\\tif(offset != -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tString closeLine = getLineText(getLineOfOffset(offset));\\n\\t\\t\\t\\t\\tindent = MiscUtilities.getLeadingWhiteSpaceWidth(\\n\\t\\t\\t\\t\\t\\tcloseLine,tabSize);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tif(lineBrackets >= 0)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif((lineBrackets == 0 || doubleBracketIndent)\\n\\t\\t\\t\\t&& indentNextLinesRE != null\\n\\t\\t\\t\\t&& indentNextLinesRE.isMatch(prevLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tindent += indentSize;\\n\\t\\t\\t}\\n\\t\\t\\telse if(indentNextLineRE != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((lineBrackets == 0 || doubleBracketIndent)\\n\\t\\t\\t\\t\\t&& indentNextLineRE.isMatch(prevLine))\\n\\t\\t\\t\\t\\tindent += indentSize;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\telse if(prevLineBrackets == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tint prevPrevLineIndex;\\n\\t\\t\\t\\t\\t\\tprevPrevLineIndex = getPriorNonEmptyLine(prevLineIndex);\\n\\t\\t\\t\\t\\twhile(prevPrevLineIndex != -1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(indentNextLineRE.isMatch(getLineText(prevPrevLineIndex)))\\n\\t\\t\\t\\t\\t\\t\\tindent -= indentSize;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tprevPrevLineIndex = getPriorNonEmptyLine(prevPrevLineIndex);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\treturn indent;\\n\\t} \\n\\tpublic int getVirtualWidth(int line, int column)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tint start = getLineStartOffset(line);\\n\\t\\t\\tgetText(start,column,seg);\\n\\t\\t\\treturn MiscUtilities.getVirtualWidth(seg,getTabSize());\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic int getOffsetOfVirtualColumn(int line, int column,\\n\\t\\tint[] totalVirtualWidth)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tgetLineText(line,seg);\\n\\t\\t\\treturn MiscUtilities.getOffsetOfVirtualColumn(seg,\\n\\t\\t\\t\\tgetTabSize(),column,totalVirtualWidth);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void insertAtColumn(int line, int col, String str)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tint[] total = new int[1];\\n\\t\\t\\tint offset = getOffsetOfVirtualColumn(line,col,total);\\n\\t\\t\\tif(offset == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\toffset = getLineEndOffset(line) - 1;\\n\\t\\t\\t\\tstr = MiscUtilities.createWhiteSpace(col - total[0],0) + str;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\toffset += getLineStartOffset(line);\\n\\t\\t\\tinsert(offset,str);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void putProperty(Object name, Object value)\\n\\t{\\n\\t\\t\\t\\tif(!(name instanceof String))\\n\\t\\t\\treturn;\\n\\t\\tsetProperty((String)name,value);\\n\\t} \\n\\tpublic void putBooleanProperty(String name, boolean value)\\n\\t{\\n\\t\\tsetBooleanProperty(name,value);\\n\\t} \\n\\tpublic static class TokenList extends DefaultTokenHandler\\n\\t{\\n\\t\\tpublic Token getFirstToken()\\n\\t\\t{\\n\\t\\t\\treturn getTokens();\\n\\t\\t}\\n\\t}\\n\\tpublic TokenList markTokens(int lineIndex)\\n\\t{\\n\\t\\tTokenList list = new TokenList();\\n\\t\\tmarkTokens(lineIndex,list);\\n\\t\\treturn list;\\n\\t} \\n\\tpublic Element[] getRootElements()\\n\\t{\\n\\t\\treturn new Element[] { getDefaultRootElement() };\\n\\t} \\n\\tpublic Element getParagraphElement(int offset)\\n\\t{\\n\\t\\treturn new LineElement(this,getLineOfOffset(offset));\\n\\t} \\n\\tpublic Element getDefaultRootElement()\\n\\t{\\n\\t\\treturn new RootElement(this);\\n\\t} \\n\\tpublic void insertString(int offset, String str, AttributeSet attr)\\n\\t{\\n\\t\\tinsert(offset,str);\\n\\t} \\n\\tpublic File getFile()\\n\\t{\\n\\t\\treturn file;\\n\\t} \\n\\tpublic boolean isFoldStart(int line)\\n\\t{\\n\\t\\treturn (line != getLineCount() - 1\\n\\t\\t\\t&& getFoldLevel(line) < getFoldLevel(line + 1));\\n\\t} \\n\\tpublic void invalidateCachedFoldLevels()\\n\\t{\\n\\t\\tlineMgr.setFirstInvalidFoldLevel(0);\\n\\t\\tfireFoldLevelChanged(0,getLineCount());\\n\\t} \\n\\tpublic int getFoldLevel(int line)\\n\\t{\\n\\t\\tif(line < 0 || line >= lineMgr.getLineCount())\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(line);\\n\\t\\tif(foldHandler instanceof DummyFoldHandler)\\n\\t\\t\\treturn 0;\\n\\t\\tint firstInvalidFoldLevel = lineMgr.getFirstInvalidFoldLevel();\\n\\t\\tif(firstInvalidFoldLevel == -1 || line < firstInvalidFoldLevel)\\n\\t\\t{\\n\\t\\t\\treturn lineMgr.getFoldLevel(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(Debug.FOLD_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"Invalid fold levels from \\\" + firstInvalidFoldLevel + \\\" to \\\" + line);\\n\\t\\t\\tint newFoldLevel = 0;\\n\\t\\t\\tboolean changed = false;\\n\\t\\t\\tfor(int i = firstInvalidFoldLevel; i <= line; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tnewFoldLevel = foldHandler.getFoldLevel(this,i,seg);\\n\\t\\t\\t\\tif(newFoldLevel != lineMgr.getFoldLevel(i))\\n\\t\\t\\t\\t\\tchanged = true;\\n\\t\\t\\t\\tlineMgr.setFoldLevel(i,newFoldLevel);\\n\\t\\t\\t}\\n\\t\\t\\tif(line == lineMgr.getLineCount() - 1)\\n\\t\\t\\t\\tlineMgr.setFirstInvalidFoldLevel(-1);\\n\\t\\t\\telse\\n\\t\\t\\t\\tlineMgr.setFirstInvalidFoldLevel(line + 1);\\n\\t\\t\\tif(changed && !getFlag(INSIDE_INSERT))\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tfireFoldLevelChanged(firstInvalidFoldLevel,line);\\n\\t\\t\\t}\\n\\t\\t\\treturn newFoldLevel;\\n\\t\\t}\\n\\t} \\n\\tpublic int[] getFoldAtLine(int line)\\n\\t{\\n\\t\\tint start, end;\\n\\t\\tif(isFoldStart(line))\\n\\t\\t{\\n\\t\\t\\tstart = line;\\n\\t\\t\\tint foldLevel = getFoldLevel(line);\\n\\t\\t\\tline++;\\n\\t\\t\\twhile(getFoldLevel(line) > foldLevel)\\n\\t\\t\\t{\\n\\t\\t\\t\\tline++;\\n\\t\\t\\t\\tif(line == getLineCount())\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tend = line - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstart = line;\\n\\t\\t\\tint foldLevel = getFoldLevel(line);\\n\\t\\t\\twhile(getFoldLevel(start) >= foldLevel)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(start == 0)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tstart--;\\n\\t\\t\\t}\\n\\t\\t\\tend = line;\\n\\t\\t\\twhile(getFoldLevel(end) >= foldLevel)\\n\\t\\t\\t{\\n\\t\\t\\t\\tend++;\\n\\t\\t\\t\\tif(end == getLineCount())\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tend--;\\n\\t\\t}\\n\\t\\twhile(getLineLength(end) == 0 && end > start)\\n\\t\\t\\tend--;\\n\\t\\treturn new int[] { start, end };\\n\\t} \\n\\tpublic FoldHandler getFoldHandler()\\n\\t{\\n\\t\\treturn foldHandler;\\n\\t} \\n\\tpublic void setFoldHandler(FoldHandler foldHandler)\\n\\t{\\n\\t\\tFoldHandler oldFoldHandler = this.foldHandler;\\n\\t\\tif(foldHandler.equals(oldFoldHandler))\\n\\t\\t\\treturn;\\n\\t\\tthis.foldHandler = foldHandler;\\n\\t\\tlineMgr.setFirstInvalidFoldLevel(0);\\n\\t\\tfireFoldHandlerChanged();\\n\\t} \\n\\tpublic Position createPosition(int offset)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tif(offset < 0 || offset > contentMgr.getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(offset);\\n\\t\\t\\treturn positionMgr.createPosition(offset);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic Vector getMarkers()\\n\\t{\\n\\t\\treturn markers;\\n\\t} \\n\\tpublic String getMarkerStatusPrompt(String action)\\n\\t{\\n\\t\\treturn jEdit.getProperty(\\\"view.status.\\\" + action,\\n\\t\\t\\tnew String[] { getMarkerNameString() });\\n\\t} \\n\\tpublic String getMarkerNameString()\\n\\t{\\n\\t\\tStringBuffer buf = new StringBuffer();\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tif(marker.getShortcut() != '\\\\0')\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buf.length() != 0)\\n\\t\\t\\t\\t\\tbuf.append(' ');\\n\\t\\t\\t\\tbuf.append(marker.getShortcut());\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(buf.length() == 0)\\n\\t\\t\\treturn jEdit.getProperty(\\\"view.status.no-markers\\\");\\n\\t\\telse\\n\\t\\t\\treturn buf.toString();\\n\\t} \\n\\tpublic void addOrRemoveMarker(char shortcut, int pos)\\n\\t{\\n\\t\\tint line = getLineOfOffset(pos);\\n\\t\\tif(getMarkerAtLine(line) != null)\\n\\t\\t\\tremoveMarker(line);\\n\\t\\telse\\n\\t\\t\\taddMarker(shortcut,pos);\\n\\t} \\n\\tpublic void addMarker(char shortcut, int pos)\\n\\t{\\n\\t\\tif(jEdit.getBooleanProperty(\\\"persistentMarkers\\\"))\\n\\t\\t\\tsetDirty(true);\\n\\t\\tMarker markerN = new Marker(this,shortcut,pos);\\n\\t\\tboolean added = false;\\n\\t\\t\\t\\tif(!getFlag(LOADING))\\n\\t\\t{\\n\\t\\t\\tmarkerN.createPosition();\\n\\t\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\t\\tif(shortcut != '\\\\0' && marker.getShortcut() == shortcut)\\n\\t\\t\\t\\t\\tmarker.setShortcut('\\\\0');\\n\\t\\t\\t\\tif(marker.getPosition() == pos)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmarkers.removeElementAt(i);\\n\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\t\\tif(marker.getPosition() > pos)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmarkers.insertElementAt(markerN,i);\\n\\t\\t\\t\\t\\tadded = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(!added)\\n\\t\\t\\tmarkers.addElement(markerN);\\n\\t\\tif(!getFlag(LOADING) && !getFlag(TEMPORARY))\\n\\t\\t{\\n\\t\\t\\tEditBus.send(new BufferUpdate(this,null,\\n\\t\\t\\t\\tBufferUpdate.MARKERS_CHANGED));\\n\\t\\t}\\n\\t} \\n\\tpublic Marker getMarkerInRange(int start, int end)\\n\\t{\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tint pos = marker.getPosition();\\n\\t\\t\\tif(pos >= start && pos < end)\\n\\t\\t\\t\\treturn marker;\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic Marker getMarkerAtLine(int line)\\n\\t{\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tif(getLineOfOffset(marker.getPosition()) == line)\\n\\t\\t\\t\\treturn marker;\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic void removeMarker(int line)\\n\\t{\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tif(getLineOfOffset(marker.getPosition()) == line)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(jEdit.getBooleanProperty(\\\"persistentMarkers\\\"))\\n\\t\\t\\t\\t\\tsetDirty(true);\\n\\t\\t\\t\\tmarker.removePosition();\\n\\t\\t\\t\\tmarkers.removeElementAt(i);\\n\\t\\t\\t\\ti--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tEditBus.send(new BufferUpdate(this,null,\\n\\t\\t\\tBufferUpdate.MARKERS_CHANGED));\\n\\t} \\n\\tpublic void removeAllMarkers()\\n\\t{\\n\\t\\tif(jEdit.getBooleanProperty(\\\"persistentMarkers\\\"))\\n\\t\\t\\tsetDirty(true);\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t\\t((Marker)markers.elementAt(i)).removePosition();\\n\\t\\tmarkers.removeAllElements();\\n\\t\\tif(!getFlag(LOADING))\\n\\t\\t{\\n\\t\\t\\tEditBus.send(new BufferUpdate(this,null,\\n\\t\\t\\t\\tBufferUpdate.MARKERS_CHANGED));\\n\\t\\t}\\n\\t} \\n\\tpublic Marker getMarker(char shortcut)\\n\\t{\\n\\t\\tEnumeration enum = markers.elements();\\n\\t\\twhile(enum.hasMoreElements())\\n\\t\\t{\\n\\t\\t\\tMarker marker = (Marker)enum.nextElement();\\n\\t\\t\\tif(marker.getShortcut() == shortcut)\\n\\t\\t\\t\\treturn marker;\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic void setWaitSocket(Socket waitSocket)\\n\\t{\\n\\t\\tthis.waitSocket = waitSocket;\\n\\t} \\n\\tpublic Buffer getNext()\\n\\t{\\n\\t\\treturn next;\\n\\t} \\n\\tpublic Buffer getPrev()\\n\\t{\\n\\t\\treturn prev;\\n\\t} \\n\\tpublic int getIndex()\\n\\t{\\n\\t\\tint count = 0;\\n\\t\\tBuffer buffer = prev;\\n\\t\\tfor(;;)\\n\\t\\t{\\n\\t\\t\\tif(buffer == null)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcount++;\\n\\t\\t\\tbuffer = buffer.prev;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t} \\n\\tpublic String toString()\\n\\t{\\n\\t\\treturn name + \\\" (\\\" + directory + \\\")\\\";\\n\\t} \\n\\tpublic LineManager _getLineManager()\\n\\t{\\n\\t\\treturn lineMgr;\\n\\t} \\n\\t\\tBuffer prev;\\n\\tBuffer next;\\n\\t\\tBuffer(String path, boolean newFile, boolean temp, Hashtable props)\\n\\t{\\n\\t\\tlock = new ReadWriteLock();\\n\\t\\tpropertyLock = new Object();\\n\\t\\tcontentMgr = new ContentManager();\\n\\t\\tlineMgr = new LineManager();\\n\\t\\tpositionMgr = new PositionManager();\\n\\t\\tintegerArray = new IntegerArray();\\n\\t\\tundoMgr = new UndoManager(this);\\n\\t\\tbufferListeners = new Vector();\\n\\t\\tseg = new Segment();\\n\\t\\tmarkers = new Vector();\\n\\t\\tproperties = new HashMap();\\n\\t\\t\\t\\tEnumeration enum = props.keys();\\n\\t\\twhile(enum.hasMoreElements())\\n\\t\\t{\\n\\t\\t\\tObject key = enum.nextElement();\\n\\t\\t\\tObject value = props.get(key);\\n\\t\\t\\tproperties.put(key,new PropValue(value,false));\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tif(getProperty(ENCODING) == null)\\n\\t\\t\\tproperties.put(ENCODING,new PropValue(System.getProperty(\\\"file.encoding\\\"),false));\\n\\t\\tif(getProperty(LINESEP) == null)\\n\\t\\t\\tproperties.put(LINESEP,new PropValue(System.getProperty(\\\"line.separator\\\"),false));\\n\\t\\tsetFlag(TEMPORARY,temp);\\n\\t\\t\\t\\tsetPath(path);\\n\\t\\tsetFlag(UNTITLED,newFile);\\n\\t\\tsetFlag(NEW_FILE,newFile);\\n\\t} \\n\\t\\tvoid commitTemporary()\\n\\t{\\n\\t\\tsetFlag(TEMPORARY,false);\\n\\t\\tfinishLoading();\\n\\t} \\n\\t\\tvoid resetCachedProperties()\\n\\t{\\n\\t\\t\\t\\t\\t\\tIterator iter = properties.values().iterator();\\n\\t\\twhile(iter.hasNext())\\n\\t\\t{\\n\\t\\t\\tPropValue value = (PropValue)iter.next();\\n\\t\\t\\tif(value.defaultValue)\\n\\t\\t\\t\\titer.remove();\\n\\t\\t}\\n\\t} \\n\\t\\tvoid close()\\n\\t{\\n\\t\\tsetFlag(CLOSED,true);\\n\\t\\tif(autosaveFile != null)\\n\\t\\t\\tautosaveFile.delete();\\n\\t\\t\\t\\tif(waitSocket != null)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\twaitSocket.getOutputStream().write('\\\\0');\\n\\t\\t\\t\\twaitSocket.getOutputStream().flush();\\n\\t\\t\\t\\twaitSocket.getInputStream().close();\\n\\t\\t\\t\\twaitSocket.getOutputStream().close();\\n\\t\\t\\t\\twaitSocket.close();\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void setFlag(int flag, boolean value)\\n\\t{\\n\\t\\tif(value)\\n\\t\\t\\tflags |= (1 << flag);\\n\\t\\telse\\n\\t\\t\\tflags &= ~(1 << flag);\\n\\t} \\n\\t\\tprivate boolean getFlag(int flag)\\n\\t{\\n\\t\\tint mask = (1 << flag);\\n\\t\\treturn (flags & mask) == mask;\\n\\t} \\n\\t\\tprivate static final int CLOSED = 0;\\n\\tprivate static final int LOADING = 1;\\n\\tprivate static final int IO = 2;\\n\\tprivate static final int NEW_FILE = 3;\\n\\tprivate static final int UNTITLED = 4;\\n\\tprivate static final int AUTOSAVE_DIRTY = 5;\\n\\tprivate static final int DIRTY = 6;\\n\\tprivate static final int READ_ONLY = 7;\\n\\tprivate static final int READ_ONLY_OVERRIDE = 8;\\n\\tprivate static final int UNDO_IN_PROGRESS = 9;\\n\\tprivate static final int TEMPORARY = 10;\\n\\tprivate static final int INSIDE_INSERT = 11;\\n\\tprivate int flags;\\n\\t\\tprivate String path;\\n\\tprivate String symlinkPath;\\n\\tprivate String name;\\n\\tprivate String directory;\\n\\tprivate File file;\\n\\tprivate File autosaveFile;\\n\\tprivate long modTime;\\n\\tprivate Mode mode;\\n\\tprivate HashMap properties;\\n\\tprivate ReadWriteLock lock;\\n\\tprivate Object propertyLock;\\n\\tprivate ContentManager contentMgr;\\n\\tprivate LineManager lineMgr;\\n\\tprivate PositionManager positionMgr;\\n\\tprivate IntegerArray integerArray;\\n\\tprivate UndoManager undoMgr;\\n\\tprivate Vector bufferListeners;\\n\\tprivate Vector markers;\\n\\t\\tprivate boolean textMode;\\n\\tprivate TokenMarker tokenMarker;\\n\\tprivate Segment seg;\\n\\tprivate boolean nextLineRequested;\\n\\tprivate FoldHandler foldHandler;\\n\\tprivate String wrap;\\n\\tprivate Socket waitSocket;\\n\\t\\tprivate void setPath(String path)\\n\\t{\\n\\t\\tthis.path = path;\\n\\t\\tthis.symlinkPath = path;\\n\\t\\tVFS vfs = VFSManager.getVFSForPath(path);\\n\\t\\tif((vfs.getCapabilities() & VFS.WRITE_CAP) == 0)\\n\\t\\t\\tsetFlag(READ_ONLY,true);\\n\\t\\tthis.name = vfs.getFileName(path);\\n\\t\\tthis.directory = vfs.getParentOfPath(path);\\n\\t\\tif(vfs instanceof FileVFS)\\n\\t\\t{\\n\\t\\t\\tfile = new File(path);\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tsymlinkPath = file.getCanonicalPath();\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,io);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(autosaveFile != null)\\n\\t\\t\\t\\tautosaveFile.delete();\\n\\t\\t\\tautosaveFile = new File(file.getParent(),'#' + name + '#');\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfile = null;\\n\\t\\t\\tautosaveFile = null;\\n\\t\\t}\\n\\t} \\n\\t\\tprivate boolean recoverAutosave(final View view)\\n\\t{\\n\\t\\tif(!autosaveFile.canRead())\\n\\t\\t\\treturn false;\\n\\t\\t\\t\\tGUIUtilities.hideSplashScreen();\\n\\t\\tfinal Object[] args = { autosaveFile.getPath() };\\n\\t\\tint result = GUIUtilities.confirm(view,\\\"autosave-found\\\",args,\\n\\t\\t\\tJOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE);\\n\\t\\tif(result == JOptionPane.YES_OPTION)\\n\\t\\t{\\n\\t\\t\\tVFSManager.getFileVFS().load(view,this,autosaveFile.getPath());\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tVFSManager.runInAWTThread(new Runnable()\\n\\t\\t\\t{\\n\\t\\t\\t\\tpublic void run()\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tGUIUtilities.message(view,\\\"autosave-loaded\\\",args);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn false;\\n\\t} \\n\\t\\tprivate boolean checkFileForLoad(View view, VFS vfs, String path)\\n\\t{\\n\\t\\tif((vfs.getCapabilities() & VFS.LOW_LATENCY_CAP) != 0)\\n\\t\\t{\\n\\t\\t\\tObject session = vfs.createVFSSession(path,view);\\n\\t\\t\\tif(session == null)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tVFS.DirectoryEntry file = vfs._getDirectoryEntry(session,path,view);\\n\\t\\t\\t\\tif(file == null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsetNewFile(true);\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!file.canRead)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror.no-read\\\",null);\\n\\t\\t\\t\\t\\tsetNewFile(false);\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsetFlag(READ_ONLY,!file.canWrite);\\n\\t\\t\\t\\tif(file.type != VFS.DirectoryEntry.FILE)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tVFSManager.error(view,path,\\n\\t\\t\\t\\t\\t\\t\\\"ioerror.open-directory\\\",null);\\n\\t\\t\\t\\t\\tsetNewFile(false);\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror\\\",\\n\\t\\t\\t\\t\\tnew String[] { io.toString() });\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvfs._endVFSSession(session,view);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror\\\",\\n\\t\\t\\t\\t\\t\\tnew String[] { io.toString() });\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t} \\n\\t\\tprivate boolean checkFileForSave(View view, VFS vfs, String path)\\n\\t{\\n\\t\\tif((vfs.getCapabilities() & VFS.LOW_LATENCY_CAP) != 0)\\n\\t\\t{\\n\\t\\t\\tObject session = vfs.createVFSSession(path,view);\\n\\t\\t\\tif(session == null)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tVFS.DirectoryEntry file = vfs._getDirectoryEntry(session,path,view);\\n\\t\\t\\t\\tif(file == null)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\tif(file.type != VFS.DirectoryEntry.FILE)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tVFSManager.error(view,path,\\n\\t\\t\\t\\t\\t\\t\\\"ioerror.save-directory\\\",null);\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror\\\",\\n\\t\\t\\t\\t\\tnew String[] { io.toString() });\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvfs._endVFSSession(session,view);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror\\\",\\n\\t\\t\\t\\t\\t\\tnew String[] { io.toString() });\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t} \\n\\t\\tprivate void finishLoading()\\n\\t{\\n\\t\\tparseBufferLocalProperties();\\n\\t\\t\\t\\t\\t\\tFoldHandler oldFoldHandler = foldHandler;\\n\\t\\tsetMode();\\n\\t\\tif(foldHandler == oldFoldHandler)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tlineMgr.setFirstInvalidFoldLevel(0);\\n\\t\\t\\tfireFoldHandlerChanged();\\n\\t\\t}\\n\\t\\t\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tmarker.removePosition();\\n\\t\\t\\tint pos = marker.getPosition();\\n\\t\\t\\tif(pos > getLength())\\n\\t\\t\\t\\tmarker.setPosition(getLength());\\n\\t\\t\\telse if(pos < 0)\\n\\t\\t\\t\\tmarker.setPosition(0);\\n\\t\\t\\tmarker.createPosition();\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void finishSaving(View view, String oldPath, String path,\\n\\t\\tboolean rename, boolean error)\\n\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tif(!error && !path.equals(oldPath))\\n\\t\\t{\\n\\t\\t\\tBuffer buffer = jEdit.getBuffer(path);\\n\\t\\t\\tif(rename)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer != null && \\n\\t\\t\\t\\t\\t!buffer.getPath().equals(oldPath))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbuffer.setDirty(false);\\n\\t\\t\\t\\t\\tjEdit.closeBuffer(view,buffer);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsetPath(path);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer != null && \\n\\t\\t\\t\\t\\t!buffer.getPath().equals(oldPath))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbuffer.load(view,true);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tif(rename)\\n\\t\\t{\\n\\t\\t\\tif(file != null)\\n\\t\\t\\t\\tmodTime = file.lastModified();\\n\\t\\t\\tif(!error)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twriteLock();\\n\\t\\t\\t\\t\\tif(autosaveFile != null)\\n\\t\\t\\t\\t\\t\\tautosaveFile.delete();\\n\\t\\t\\t\\t\\tsetFlag(AUTOSAVE_DIRTY,false);\\n\\t\\t\\t\\t\\tsetFlag(READ_ONLY,false);\\n\\t\\t\\t\\t\\tsetFlag(NEW_FILE,false);\\n\\t\\t\\t\\t\\tsetFlag(UNTITLED,false);\\n\\t\\t\\t\\t\\tsetFlag(DIRTY,false);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tundoMgr.bufferSaved();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfinally\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twriteUnlock();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tparseBufferLocalProperties();\\n\\t\\t\\t\\tif(!getPath().equals(oldPath))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tjEdit.updatePosition(oldPath,Buffer.this);\\n\\t\\t\\t\\t\\tsetMode();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tString newMode = getStringProperty(\\\"mode\\\");\\n\\t\\t\\t\\t\\tif(newMode != null &&\\n\\t\\t\\t\\t\\t\\t!newMode.equals(getMode()\\n\\t\\t\\t\\t\\t\\t.getName()))\\n\\t\\t\\t\\t\\t\\tsetMode();\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tpropertiesChanged();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tEditBus.send(new BufferUpdate(Buffer.this,\\n\\t\\t\\t\\t\\tview,BufferUpdate.DIRTY_CHANGED));\\n\\t\\t\\t\\t\\t\\t\\t\\tEditBus.send(new BufferUpdate(Buffer.this,\\n\\t\\t\\t\\t\\tview,BufferUpdate.SAVED));\\n\\t\\t\\t}\\n\\t\\t} \\t} \\n\\t\\tprivate void parseBufferLocalProperties()\\n\\t{\\n\\t\\tint lastLine = Math.min(9,getLineCount() - 1);\\n\\t\\tparseBufferLocalProperties(getText(0,getLineEndOffset(lastLine) - 1));\\n\\t\\t\\t\\t\\t\\tint firstLine = Math.max(lastLine + 1, getLineCount() - 10);\\n\\t\\tif(firstLine < getLineCount())\\n\\t\\t{\\n\\t\\t\\tint length = getLineEndOffset(getLineCount() - 1) \\n\\t\\t\\t\\t- (getLineStartOffset(firstLine) + 1);\\n\\t\\t\\tparseBufferLocalProperties(getText(getLineStartOffset(firstLine),length));\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void parseBufferLocalProperties(String prop)\\n\\t{\\n\\t\\tStringBuffer buf = new StringBuffer();\\n\\t\\tString name = null;\\n\\t\\tboolean escape = false;\\n\\t\\tfor(int i = 0; i < prop.length(); i++)\\n\\t\\t{\\n\\t\\t\\tchar c = prop.charAt(i);\\n\\t\\t\\tswitch(c)\\n\\t\\t\\t{\\n\\t\\t\\tcase ':':\\n\\t\\t\\t\\tif(escape)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tescape = false;\\n\\t\\t\\t\\t\\tbuf.append(':');\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(name != null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tproperties.put(name,new PropValue(buf.toString(),false));\\n\\t\\t\\t\\t\\tname = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbuf.setLength(0);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase '=':\\n\\t\\t\\t\\tif(escape)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tescape = false;\\n\\t\\t\\t\\t\\tbuf.append('=');\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tname = buf.toString();\\n\\t\\t\\t\\tbuf.setLength(0);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase '\\\\\\\\':\\n\\t\\t\\t\\tif(escape)\\n\\t\\t\\t\\t\\tbuf.append('\\\\\\\\');\\n\\t\\t\\t\\tescape = !escape;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 'n':\\n\\t\\t\\t\\tif(escape)\\n\\t\\t\\t\\t{\\tbuf.append('\\\\n');\\n\\t\\t\\t\\t\\tescape = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\tcase 'r':\\n\\t\\t\\t\\tif(escape)\\n\\t\\t\\t\\t{\\tbuf.append('\\\\r');\\n\\t\\t\\t\\t\\tescape = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\tcase 't':\\n\\t\\t\\t\\tif(escape)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbuf.append('\\\\t');\\n\\t\\t\\t\\t\\tescape = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tbuf.append(c);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void setTokenMarker(TokenMarker tokenMarker)\\n\\t{\\n\\t\\tTokenMarker oldTokenMarker = this.tokenMarker;\\n\\t\\tthis.tokenMarker = tokenMarker;\\n\\t\\t\\t\\tif(oldTokenMarker != null && tokenMarker != oldTokenMarker)\\n\\t\\t{\\n\\t\\t\\tlineMgr.setFirstInvalidLineContext(0);\\n\\t\\t}\\n\\t} \\n\\tprivate int getPriorNonEmptyLine(int lineIndex)\\n\\t{\\n\\t\\tfor(int i = lineIndex - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(getLineLength(i) != 0)\\n\\t\\t\\t\\treturn i;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t} \\n\\t\\tprivate void contentInserted(int offset, int length,\\n\\t\\tIntegerArray endOffsets)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tsetFlag(INSIDE_INSERT,true);\\n\\t\\t\\tint startLine = lineMgr.getLineOfOffset(offset);\\n\\t\\t\\tint numLines = endOffsets.getSize();\\n\\t\\t\\tlineMgr.contentInserted(startLine,offset,numLines,length,\\n\\t\\t\\t\\tendOffsets);\\n\\t\\t\\tpositionMgr.contentInserted(offset,length);\\n\\t\\t\\tsetDirty(true);\\n\\t\\t\\tif(!getFlag(LOADING))\\n\\t\\t\\t\\tfireContentInserted(startLine,offset,numLines,length);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tsetFlag(INSIDE_INSERT,false);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate BufferChangeListener getListener(int index)\\n\\t{\\n\\t\\treturn ((Listener)bufferListeners.elementAt(index)).listener;\\n\\t} \\n\\t\\tprivate void fireFoldLevelChanged(int start, int end)\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).foldLevelChanged(this,start,end);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireContentInserted(int startLine, int offset,\\n\\t\\tint numLines, int length)\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).contentInserted(this,startLine,\\n\\t\\t\\t\\t\\toffset,numLines,length);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireContentRemoved(int startLine, int offset,\\n\\t\\tint numLines, int length)\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).contentRemoved(this,startLine,\\n\\t\\t\\t\\t\\toffset,numLines,length);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void firePreContentRemoved(int startLine, int offset,\\n\\t\\tint numLines, int length)\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).preContentRemoved(this,startLine,\\n\\t\\t\\t\\t\\toffset,numLines,length);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireTransactionComplete()\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).transactionComplete(this);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireFoldHandlerChanged()\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).foldHandlerChanged(this);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireWrapModeChanged()\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).wrapModeChanged(this);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t}\""
        },
        {
            "content": "The source code of `Buffer.java` reveals that it plays a central role in managing text buffers within the jEdit application. It includes functionality for:\n\n- **Text manipulation**: Inserting, removing, and modifying text content.\n- **File I/O operations**: Loading and saving files, handling autosave, and managing file status (e.g., checking if a file has been modified externally).\n- **Buffer properties**: Managing buffer-specific settings such as encoding, indentation, line separators, and syntax highlighting.\n- **Undo/Redo support**: Maintaining an undo history and allowing transaction management.\n- **Syntax parsing and tokenization**: Supporting syntax highlighting through token markers and fold handlers.\n- **Marker management**: Supporting bookmarks or markers in the text buffer.\n\nGiven its high coupling confidence with `jEdit.java`, any changes to `jEdit.java` could potentially affect how `Buffer.java` is used or needs to be updated. To further understand potential ripple effects, we should investigate dependencies between these two classes.\n\nLet's now call the `get_coupling_dependencies` function to analyze the coupling between `jEdit.java` and `Buffer.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_20bd3bd3fef34bdbb9319b",
                    "function": {
                        "arguments": "{\"entity1\": \"jEdit.java\", \"entity2\": \"Buffer.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"There are no coupling dependencies between these two entities\"]"
        },
        {
            "content": "Interestingly, the analysis shows that there are **no direct coupling dependencies** between `jEdit.java` and `Buffer.java`, despite their high co-change confidence. This suggests that while these two files are often modified together, they do **not directly reference or depend on each other** in terms of code structure (e.g., method calls, inheritance, type usage).\n\nThis kind of relationship\u2014high co-change but low structural dependency\u2014is not uncommon in large evolving systems. It may indicate that both files are affected by the same **functional changes**, even though they operate at different abstraction levels.\n\nTo better understand why they are co-changed so frequently, we should look into how `jEdit.java` interacts with components that use `Buffer.java`. A good next step is to examine the call graph of `jEdit.java` to see which entities it directly uses, especially those that might mediate its interaction with `Buffer.java`.\n\nLet's proceed by calling the `get_call_graph` function on `jEdit.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_045e6a4ab3d943fb812f9f",
                    "function": {
                        "arguments": "{\"entity\": \"jEdit.java\"}",
                        "name": "get_call_graph"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_call_graph",
            "content": "[\"\", \"BufferIORequest\", \"PluginManager\", \"KillRing\", \"\", \"HelpViewer\", \"\", \"\", \"SearchAndReplace\", \"\", \"Log\", \"\"]"
        },
        {
            "content": "The call graph for `jEdit.java` reveals several entities that it directly interacts with. These include:\n\n- **BufferIORequest**\n- **PluginManager**\n- **KillRing**\n- **HelpViewer**\n- **SearchAndReplace**\n- **Log**\n\nInterestingly, while `Buffer.java` did not appear in the direct coupling analysis, some of these entities (like `BufferIORequest`) may act as intermediaries between `jEdit.java` and `Buffer.java`.\n\nTo understand how `jEdit.java` might indirectly depend on `Buffer.java`, we should investigate the role of such intermediary classes. A good candidate to examine next is `BufferIORequest.java`, since it likely handles I/O operations related to buffers and could mediate interactions between `jEdit.java` and `Buffer.java`.\n\nLet\u2019s retrieve the source code of `BufferIORequest.java` using the `get_origin_code` function.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_809e6923b3014e0b86b55b",
                    "function": {
                        "arguments": "{\"entity\": \"BufferIORequest.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package org.gjt.sp.jedit.buffer;\\nimport javax.swing.text.Segment;\\nimport java.io.*;\\nimport java.util.zip.*;\\nimport java.util.Vector;\\nimport org.gjt.sp.jedit.io.*;\\nimport org.gjt.sp.jedit.*;\\nimport org.gjt.sp.util.*;\\npublic class BufferIORequest extends WorkRequest\\n{\\n\\tpublic static final int IOBUFSIZE = 32768;\\n\\tpublic static final int PROGRESS_INTERVAL = 300;\\n\\tpublic static final String LOAD_DATA = \\\"BufferIORequest__loadData\\\";\\n\\tpublic static final String END_OFFSETS = \\\"BufferIORequest__endOffsets\\\";\\n\\tpublic static final String NEW_PATH = \\\"BufferIORequest__newPath\\\";\\n\\tpublic static final String ERROR_OCCURRED = \\\"BufferIORequest__error\\\";\\n\\tpublic static final int LOAD = 0;\\n\\tpublic static final int SAVE = 1;\\n\\tpublic static final int AUTOSAVE = 2;\\n\\tpublic static final int INSERT = 3;\\n\\tpublic static final int GZIP_MAGIC_1 = 0x1f;\\n\\tpublic static final int GZIP_MAGIC_2 = 0x8b;\\n\\tpublic static final int UNICODE_MAGIC_1 = 0xfe;\\n\\tpublic static final int UNICODE_MAGIC_2 = 0xff;\\n\\tpublic BufferIORequest(int type, View view, Buffer buffer,\\n\\t\\tObject session, VFS vfs, String path)\\n\\t{\\n\\t\\tthis.type = type;\\n\\t\\tthis.view = view;\\n\\t\\tthis.buffer = buffer;\\n\\t\\tthis.session = session;\\n\\t\\tthis.vfs = vfs;\\n\\t\\tthis.path = path;\\n\\t\\tmarkersPath = vfs.getParentOfPath(path)\\n\\t\\t\\t+ '.' + vfs.getFileName(path)\\n\\t\\t\\t+ \\\".marks\\\";\\n\\t} \\n\\t\\tpublic void run()\\n\\t{\\n\\t\\tswitch(type)\\n\\t\\t{\\n\\t\\tcase LOAD:\\n\\t\\t\\tload();\\n\\t\\t\\tbreak;\\n\\t\\tcase SAVE:\\n\\t\\t\\tsave();\\n\\t\\t\\tbreak;\\n\\t\\tcase AUTOSAVE:\\n\\t\\t\\tautosave();\\n\\t\\t\\tbreak;\\n\\t\\tcase INSERT:\\n\\t\\t\\tinsert();\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t} \\n\\t\\tpublic String toString()\\n\\t{\\n\\t\\tString typeString;\\n\\t\\tswitch(type)\\n\\t\\t{\\n\\t\\tcase LOAD:\\n\\t\\t\\ttypeString = \\\"LOAD\\\";\\n\\t\\t\\tbreak;\\n\\t\\tcase SAVE:\\n\\t\\t\\ttypeString = \\\"SAVE\\\";\\n\\t\\t\\tbreak;\\n\\t\\tcase AUTOSAVE:\\n\\t\\t\\ttypeString = \\\"AUTOSAVE\\\";\\n\\t\\t\\tbreak;\\n\\t\\tdefault:\\n\\t\\t\\ttypeString = \\\"UNKNOWN!!!\\\";\\n\\t\\t}\\n\\t\\treturn getClass().getName() + \\\"[type=\\\" + typeString\\n\\t\\t\\t+ \\\",buffer=\\\" + buffer + \\\"]\\\";\\n\\t} \\n\\t\\tprivate int type;\\n\\tprivate View view;\\n\\tprivate Buffer buffer;\\n\\tprivate Object session;\\n\\tprivate VFS vfs;\\n\\tprivate String path;\\n\\tprivate String markersPath;\\n\\t\\tprivate void load()\\n\\t{\\n\\t\\tInputStream in = null;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tString[] args = { vfs.getFileName(path) };\\n\\t\\t\\t\\tsetAbortable(true);\\n\\t\\t\\t\\tif(!buffer.isTemporary())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsetStatus(jEdit.getProperty(\\\"vfs.status.load\\\",args));\\n\\t\\t\\t\\t\\tsetProgressValue(0);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tpath = vfs._canonPath(session,path,view);\\n\\t\\t\\t\\tVFS.DirectoryEntry entry = vfs._getDirectoryEntry(\\n\\t\\t\\t\\t\\tsession,path,view);\\n\\t\\t\\t\\tlong length;\\n\\t\\t\\t\\tif(entry != null)\\n\\t\\t\\t\\t\\tlength = entry.length;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tlength = 0L;\\n\\t\\t\\t\\tin = vfs._createInputStream(session,path,false,view);\\n\\t\\t\\t\\tif(in == null)\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\tin = new BufferedInputStream(in);\\n\\t\\t\\t\\tif(in.markSupported())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tin.mark(2);\\n\\t\\t\\t\\t\\tint b1 = in.read();\\n\\t\\t\\t\\t\\tint b2 = in.read();\\n\\t\\t\\t\\t\\tin.reset();\\n\\t\\t\\t\\t\\tif(b1 == GZIP_MAGIC_1 && b2 == GZIP_MAGIC_2)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tin = new GZIPInputStream(in);\\n\\t\\t\\t\\t\\t\\tbuffer.setBooleanProperty(Buffer.GZIPPED,true);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if((b1 == UNICODE_MAGIC_1 && b2 == UNICODE_MAGIC_2)\\n\\t\\t\\t\\t\\t\\t|| (b1 == UNICODE_MAGIC_2 && b2 == UNICODE_MAGIC_1))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.setProperty(Buffer.ENCODING,\\\"Unicode\\\");\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(path.toLowerCase().endsWith(\\\".gz\\\"))\\n\\t\\t\\t\\t\\tin = new GZIPInputStream(in);\\n\\t\\t\\t\\tread(buffer,in,length);\\n\\t\\t\\t\\tbuffer.setNewFile(false);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(CharConversionException ch)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,ch);\\n\\t\\t\\t\\tObject[] pp = { buffer.getProperty(Buffer.ENCODING),\\n\\t\\t\\t\\t\\tch.toString() };\\n\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror.encoding-error\\\",pp);\\n\\t\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(UnsupportedEncodingException uu)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,uu);\\n\\t\\t\\t\\tObject[] pp = { buffer.getProperty(Buffer.ENCODING),\\n\\t\\t\\t\\t\\tuu.toString() };\\n\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror.encoding-error\\\",pp);\\n\\t\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,io);\\n\\t\\t\\t\\tObject[] pp = { io.toString() };\\n\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror.read-error\\\",pp);\\n\\t\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(OutOfMemoryError oom)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,oom);\\n\\t\\t\\t\\tVFSManager.error(view,path,\\\"out-of-memory-error\\\",null);\\n\\t\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t\\t}\\n\\t\\t\\tif(jEdit.getBooleanProperty(\\\"persistentMarkers\\\"))\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tString[] args = { vfs.getFileName(path) };\\n\\t\\t\\t\\t\\tif(!buffer.isTemporary())\\n\\t\\t\\t\\t\\t\\tsetStatus(jEdit.getProperty(\\\"vfs.status.load-markers\\\",args));\\n\\t\\t\\t\\t\\tsetAbortable(true);\\n\\t\\t\\t\\t\\tin = vfs._createInputStream(session,markersPath,true,view);\\n\\t\\t\\t\\t\\tif(in != null)\\n\\t\\t\\t\\t\\t\\treadMarkers(buffer,in);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcatch(WorkThread.Abort a)\\n\\t\\t{\\n\\t\\t\\tif(in != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tin.close();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tvfs._endVFSSession(session,view);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,io);\\n\\t\\t\\t\\tString[] pp = { io.toString() };\\n\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror.read-error\\\",pp);\\n\\t\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(WorkThread.Abort a)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void read(Buffer buffer, InputStream _in, long length)\\n\\t\\tthrows IOException\\n\\t{\\n\\t\\tIntegerArray endOffsets = new IntegerArray(\\n\\t\\t\\tMath.max(1,(int)(length / 50)));\\n\\t\\t\\t\\tboolean trackProgress = (!buffer.isTemporary() && length != 0);\\n\\t\\tif(trackProgress)\\n\\t\\t{\\n\\t\\t\\tsetProgressValue(0);\\n\\t\\t\\tsetProgressMaximum((int)length);\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(length == 0)\\n\\t\\t\\tlength = IOBUFSIZE;\\n\\t\\tSegmentBuffer seg = new SegmentBuffer((int)length + 1);\\n\\t\\tInputStreamReader in = new InputStreamReader(_in,\\n\\t\\t\\tbuffer.getStringProperty(Buffer.ENCODING));\\n\\t\\tchar[] buf = new char[IOBUFSIZE];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tint len;\\n\\t\\t\\t\\t\\t\\tboolean CRLF = false;\\n\\t\\t\\t\\tboolean CROnly = false;\\n\\t\\t\\t\\t\\t\\t\\t\\tboolean lastWasCR = false;\\n\\t\\t\\t\\t\\t\\tint lineCount = 0;\\n\\t\\twhile((len = in.read(buf,0,buf.length)) != -1)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tint lastLine = 0;\\n\\t\\t\\tfor(int i = 0; i < len; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tswitch(buf[i])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\r':\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(lastWasCR)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tCROnly = true;\\n\\t\\t\\t\\t\\t\\tCRLF = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tlastWasCR = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tseg.append(buf,lastLine,i -\\n\\t\\t\\t\\t\\t\\tlastLine);\\n\\t\\t\\t\\t\\tseg.append('\\\\n');\\n\\t\\t\\t\\t\\tendOffsets.add(seg.count);\\n\\t\\t\\t\\t\\tif(trackProgress && lineCount++ % PROGRESS_INTERVAL == 0)\\n\\t\\t\\t\\t\\t\\tsetProgressValue(seg.count);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tlastLine = i + 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase '\\\\n':\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(lastWasCR)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tCROnly = false;\\n\\t\\t\\t\\t\\t\\tCRLF = true;\\n\\t\\t\\t\\t\\t\\tlastWasCR = false;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tlastLine = i + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tCROnly = false;\\n\\t\\t\\t\\t\\t\\tCRLF = false;\\n\\t\\t\\t\\t\\t\\tseg.append(buf,lastLine,\\n\\t\\t\\t\\t\\t\\t\\ti - lastLine);\\n\\t\\t\\t\\t\\t\\tseg.append('\\\\n');\\n\\t\\t\\t\\t\\t\\tendOffsets.add(seg.count);\\n\\t\\t\\t\\t\\t\\tif(trackProgress && lineCount++ % PROGRESS_INTERVAL == 0)\\n\\t\\t\\t\\t\\t\\t\\tsetProgressValue(seg.count);\\n\\t\\t\\t\\t\\t\\tlastLine = i + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(lastWasCR)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tCROnly = true;\\n\\t\\t\\t\\t\\t\\tCRLF = false;\\n\\t\\t\\t\\t\\t\\tlastWasCR = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(trackProgress)\\n\\t\\t\\t\\tsetProgressValue(seg.count);\\n\\t\\t\\t\\t\\t\\tseg.append(buf,lastLine,len - lastLine);\\n\\t\\t}\\n\\t\\tsetAbortable(false);\\n\\t\\tString lineSeparator;\\n\\t\\tif(CRLF)\\n\\t\\t\\tlineSeparator = \\\"\\\\r\\\\n\\\";\\n\\t\\telse if(CROnly)\\n\\t\\t\\tlineSeparator = \\\"\\\\r\\\";\\n\\t\\telse\\n\\t\\t\\tlineSeparator = \\\"\\\\n\\\";\\n\\t\\tin.close();\\n\\t\\t\\t\\tint bufferLength = seg.count;\\n\\t\\tif(bufferLength != 0)\\n\\t\\t{\\n\\t\\t\\tchar ch = seg.array[bufferLength - 1];\\n\\t\\t\\tif(ch == 0x1a )\\n\\t\\t\\t\\tseg.count--;\\n\\t\\t}\\n\\t\\tbuffer.setBooleanProperty(Buffer.TRAILING_EOL,false);\\n\\t\\tif(bufferLength != 0 && jEdit.getBooleanProperty(\\\"stripTrailingEOL\\\"))\\n\\t\\t{\\n\\t\\t\\tchar ch = seg.array[bufferLength - 1];\\n\\t\\t\\tif(ch == '\\\\n')\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.setBooleanProperty(Buffer.TRAILING_EOL,true);\\n\\t\\t\\t\\tseg.count--;\\n\\t\\t\\t\\tendOffsets.setSize(endOffsets.getSize() - 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tendOffsets.add(seg.count + 1);\\n\\t\\t\\t\\t\\t\\t\\t\\tbuffer.setProperty(LOAD_DATA,seg);\\n\\t\\tbuffer.setProperty(END_OFFSETS,endOffsets);\\n\\t\\tbuffer.setProperty(NEW_PATH,path);\\n\\t\\tbuffer.setProperty(Buffer.LINESEP,lineSeparator);\\n\\t} \\n\\t\\tprivate void readMarkers(Buffer buffer, InputStream _in)\\n\\t\\tthrows IOException\\n\\t{\\n\\t\\t\\t\\tbuffer.removeAllMarkers();\\n\\t\\tBufferedReader in = new BufferedReader(new InputStreamReader(_in));\\n\\t\\tString line;\\n\\t\\twhile((line = in.readLine()) != null)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(!line.startsWith(\\\"!\\\"))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tchar shortcut = line.charAt(1);\\n\\t\\t\\tint start = line.indexOf(';');\\n\\t\\t\\tint end = line.indexOf(';',start + 1);\\n\\t\\t\\tint position = Integer.parseInt(line.substring(start + 1,end));\\n\\t\\t\\tbuffer.addMarker(shortcut,position);\\n\\t\\t}\\n\\t\\tin.close();\\n\\t} \\n\\t\\tprivate void save()\\n\\t{\\n\\t\\tOutputStream out = null;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tString[] args = { vfs.getFileName(path) };\\n\\t\\t\\tsetStatus(jEdit.getProperty(\\\"vfs.status.save\\\",args));\\n\\t\\t\\t\\t\\t\\tsetAbortable(true);\\n\\t\\t\\tpath = vfs._canonPath(session,path,view);\\t\\t\\tif(!MiscUtilities.isURL(path))\\n\\t\\t\\t\\tpath = MiscUtilities.resolveSymlinks(path);\\n\\t\\t\\t\\t\\t\\tif(buffer.getProperty(Buffer.BACKED_UP) == null\\n\\t\\t\\t\\t|| jEdit.getBooleanProperty(\\\"backupEverySave\\\"))\\n\\t\\t\\t{\\n\\t\\t\\t\\tvfs._backup(session,path,view);\\n\\t\\t\\t\\tbuffer.setBooleanProperty(Buffer.BACKED_UP,true);\\n\\t\\t\\t}\\n\\t\\t\\tString savePath;\\n\\t\\t\\tboolean twoStageSave = (vfs.getCapabilities() & VFS.RENAME_CAP) != 0\\n\\t\\t\\t\\t&& jEdit.getBooleanProperty(\\\"twoStageSave\\\");\\n\\t\\t\\tif(twoStageSave)\\n\\t\\t\\t\\tsavePath = vfs.getTwoStageSaveName(path);\\n\\t\\t\\telse\\n\\t\\t\\t\\tsavePath = path;\\n\\t\\t\\tout = vfs._createOutputStream(session,savePath,view);\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbuffer.readLock();\\n\\t\\t\\t\\tif(out != null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(savePath.endsWith(\\\".gz\\\"))\\n\\t\\t\\t\\t\\t\\tbuffer.setBooleanProperty(Buffer.GZIPPED,true);\\n\\t\\t\\t\\t\\tif(buffer.getBooleanProperty(Buffer.GZIPPED))\\n\\t\\t\\t\\t\\t\\tout = new GZIPOutputStream(out);\\n\\t\\t\\t\\t\\twrite(buffer,out);\\n\\t\\t\\t\\t\\tif(twoStageSave)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(!vfs._rename(session,savePath,path,view))\\n\\t\\t\\t\\t\\t\\t\\tthrow new IOException(savePath);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif((vfs.getCapabilities() & VFS.DELETE_CAP) != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(jEdit.getBooleanProperty(\\\"persistentMarkers\\\")\\n\\t\\t\\t\\t\\t\\t\\t&& buffer.getMarkers().size() != 0)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tsetStatus(jEdit.getProperty(\\\"vfs.status.save-markers\\\",args));\\n\\t\\t\\t\\t\\t\\t\\tsetProgressValue(0);\\n\\t\\t\\t\\t\\t\\t\\tout = vfs._createOutputStream(session,markersPath,view);\\n\\t\\t\\t\\t\\t\\t\\tif(out != null)\\n\\t\\t\\t\\t\\t\\t\\t\\twriteMarkers(buffer,out);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tvfs._delete(session,markersPath,view);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t\\t\\tif(!twoStageSave)\\n\\t\\t\\t\\t\\tVFSManager.sendVFSUpdate(vfs,path,true);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.readUnlock();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcatch(IOException io)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.ERROR,this,io);\\n\\t\\t\\tString[] pp = { io.toString() };\\n\\t\\t\\tVFSManager.error(view,path,\\\"ioerror.write-error\\\",pp);\\n\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t}\\n\\t\\tcatch(WorkThread.Abort a)\\n\\t\\t{\\n\\t\\t\\tif(out != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tout.close();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tvfs._saveComplete(session,buffer,path,view);\\n\\t\\t\\t\\tvfs._endVFSSession(session,view);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,io);\\n\\t\\t\\t\\tString[] pp = { io.toString() };\\n\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror.write-error\\\",pp);\\n\\t\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(WorkThread.Abort a)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void autosave()\\n\\t{\\n\\t\\tOutputStream out = null;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tString[] args = { vfs.getFileName(path) };\\n\\t\\t\\tsetStatus(jEdit.getProperty(\\\"vfs.status.autosave\\\",args));\\n\\t\\t\\t\\t\\t\\tsetAbortable(true);\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(!buffer.isDirty())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tout = vfs._createOutputStream(session,path,view);\\n\\t\\t\\t\\tif(out == null)\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\twrite(buffer,out);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Exception e)\\n\\t\\t\\t{\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcatch(WorkThread.Abort a)\\n\\t\\t{\\n\\t\\t\\tif(out != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tout.close();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void write(Buffer buffer, OutputStream _out)\\n\\t\\tthrows IOException\\n\\t{\\n\\t\\tBufferedWriter out = new BufferedWriter(\\n\\t\\t\\tnew OutputStreamWriter(_out,\\n\\t\\t\\t\\tbuffer.getStringProperty(Buffer.ENCODING)),\\n\\t\\t\\t\\tIOBUFSIZE);\\n\\t\\tSegment lineSegment = new Segment();\\n\\t\\tString newline = buffer.getStringProperty(Buffer.LINESEP);\\n\\t\\tif(newline == null)\\n\\t\\t\\tnewline = System.getProperty(\\\"line.separator\\\");\\n\\t\\tsetProgressMaximum(buffer.getLineCount() / PROGRESS_INTERVAL);\\n\\t\\tsetProgressValue(0);\\n\\t\\tint i = 0;\\n\\t\\twhile(i < buffer.getLineCount())\\n\\t\\t{\\n\\t\\t\\tbuffer.getLineText(i,lineSegment);\\n\\t\\t\\tout.write(lineSegment.array,lineSegment.offset,\\n\\t\\t\\t\\tlineSegment.count);\\n\\t\\t\\tif(i != buffer.getLineCount() - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tout.write(newline);\\n\\t\\t\\t}\\n\\t\\t\\tif(++i % PROGRESS_INTERVAL == 0)\\n\\t\\t\\t\\tsetProgressValue(i / PROGRESS_INTERVAL);\\n\\t\\t}\\n\\t\\tif(jEdit.getBooleanProperty(\\\"stripTrailingEOL\\\")\\n\\t\\t\\t&& buffer.getBooleanProperty(Buffer.TRAILING_EOL))\\n\\t\\t{\\n\\t\\t\\tout.write(newline);\\n\\t\\t}\\n\\t\\tout.close();\\n\\t} \\n\\t\\tprivate void writeMarkers(Buffer buffer, OutputStream out)\\n\\t\\tthrows IOException\\n\\t{\\n\\t\\tWriter o = new BufferedWriter(new OutputStreamWriter(out));\\n\\t\\tVector markers = buffer.getMarkers();\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\to.write('!');\\n\\t\\t\\to.write(marker.getShortcut());\\n\\t\\t\\to.write(';');\\n\\t\\t\\tString pos = String.valueOf(marker.getPosition());\\n\\t\\t\\to.write(pos);\\n\\t\\t\\to.write(';');\\n\\t\\t\\to.write(pos);\\n\\t\\t\\to.write('\\\\n');\\n\\t\\t}\\n\\t\\to.close();\\n\\t} \\n\\t\\tprivate void insert()\\n\\t{\\n\\t\\tInputStream in = null;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tString[] args = { vfs.getFileName(path) };\\n\\t\\t\\t\\tsetStatus(jEdit.getProperty(\\\"vfs.status.load\\\",args));\\n\\t\\t\\t\\tsetAbortable(true);\\n\\t\\t\\t\\tpath = vfs._canonPath(session,path,view);\\n\\t\\t\\t\\tVFS.DirectoryEntry entry = vfs._getDirectoryEntry(\\n\\t\\t\\t\\t\\tsession,path,view);\\n\\t\\t\\t\\tlong length;\\n\\t\\t\\t\\tif(entry != null)\\n\\t\\t\\t\\t\\tlength = entry.length;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tlength = 0L;\\n\\t\\t\\t\\tin = vfs._createInputStream(session,path,false,view);\\n\\t\\t\\t\\tif(in == null)\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\tif(path.endsWith(\\\".gz\\\"))\\n\\t\\t\\t\\t\\tin = new GZIPInputStream(in);\\n\\t\\t\\t\\tread(buffer,in,length);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,io);\\n\\t\\t\\t\\tString[] pp = { io.toString() };\\n\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror.read-error\\\",pp);\\n\\t\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcatch(WorkThread.Abort a)\\n\\t\\t{\\n\\t\\t\\tif(in != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tin.close();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tvfs._endVFSSession(session,view);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,io);\\n\\t\\t\\t\\tString[] pp = { io.toString() };\\n\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror.read-error\\\",pp);\\n\\t\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(WorkThread.Abort a)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t}\""
        },
        {
            "content": "The source code of `BufferIORequest.java` reveals that it is a critical component responsible for handling I/O operations related to `Buffer` instances in jEdit. It extends `WorkRequest`, which suggests it's executed asynchronously, likely in a background thread.\n\n### Key Responsibilities:\n1. **Loading Buffers**:\n   - Reads from a file or stream into a buffer.\n   - Handles different encodings and line separators.\n   - Supports GZIP-compressed files.\n   - Manages marker restoration (e.g., bookmarks).\n\n2. **Saving Buffers**:\n   - Writes buffer contents to a file.\n   - Supports GZIP compression.\n   - Optionally performs two-stage saving for safety.\n   - Saves markers persistently if enabled.\n\n3. **Autosaving**:\n   - Periodically writes the buffer state to a temporary file to prevent data loss.\n\n4. **Inserting File Content**:\n   - Loads content from another file into the current buffer.\n\n### Interaction with `jEdit.java`\n- `jEdit.java` initiates I/O operations (like loading or saving files), and these are handled by `BufferIORequest`.\n- Although there's no direct structural dependency between `jEdit.java` and `Buffer.java`, `BufferIORequest` serves as an intermediary that operates on `Buffer` instances\u2014suggesting that changes in `jEdit.java` related to file handling may indirectly affect how buffers are loaded/saved.\n\nTo better understand how `jEdit.java` interacts with `BufferIORequest`, we should examine whether there are coupling dependencies between them.\n\nLet\u2019s call the `get_coupling_dependencies` function between `jEdit.java` and `BufferIORequest.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_585e457da2fd4c4cb59121",
                    "function": {
                        "arguments": "{\"entity1\": \"jEdit.java\", \"entity2\": \"BufferIORequest.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"StaticVariableInvoking(SAI): Static Variable Invoking found: closeBuffer invokes static variable ERROR_OCCURRED,\"]"
        },
        {
            "content": "The coupling analysis between `jEdit.java` and `BufferIORequest.java` reveals a **static variable invocation** relationship:\n\n- **Static Variable Invoking (SAI)**: `jEdit.java` accesses the static field `ERROR_OCCURRED` from `BufferIORequest.java`.\n\nThis indicates that `jEdit.java` checks or uses this static variable\u2014likely to determine if an error occurred during buffer I/O operations.\n\n### Implications:\n- If changes in `jEdit.java` involve error handling or interaction with buffer I/O processes, they may indirectly affect how `BufferIORequest` is used.\n- Since `BufferIORequest` operates on `Buffer` instances, any logic in `jEdit.java` that affects file loading/saving could propagate changes through `BufferIORequest` to `Buffer`.\n\nGiven this chain of interaction and co-change history, the following entities should be considered for synchronization when modifying `jEdit.java`:\n\n---\n\n### \u2705 Entities to Synchronize\n\n| Entity                | Reason |\n|-----------------------|--------|\n| **Buffer.java**       | High co-change confidence (0.196). Although no direct coupling, it is central to buffer management and interacts via `BufferIORequest`. |\n| **BufferIORequest.java** | Direct coupling with `jEdit.java` via `ERROR_OCCURRED`. Mediates buffer I/O operations. |\n| **SearchAndReplace.java** | Appears in call graph; often involved in text manipulation that may affect buffers. |\n| **PluginManager.java** | Appears in call graph; plugins may interact with buffers or modify behavior tied to `jEdit.java`. |\n| **KillRing.java**     | Appears in call graph; related to clipboard operations involving buffers. |\n| **HelpViewer.java**   | Appears in call graph; changes in UI or event handling might affect help integration. |\n\n---\n\n### Next Steps\n\nTo ensure robust change impact analysis, we should also check for conceptual coupling (semantic similarity) between `jEdit.java` and `Buffer.java`, even though structural dependencies are absent.\n\nLet\u2019s call the `get_conceptual_coupling` function between `jEdit.java` and `Buffer.java` to assess their semantic similarity.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_443ea0913bda4f57b3f64b",
                    "function": {
                        "arguments": "{\"entity1\": \"jEdit.java\", \"entity2\": \"Buffer.java\"}",
                        "name": "get_conceptual_coupling"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_conceptual_coupling",
            "content": "\"0.6731524\""
        },
        {
            "role": "user",
            "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
        },
        {
            "content": "Title: Diagnosis of starting entity `jEdit.java`  \nChange set: [Buffer.java, PluginManager.java, BufferIORequest.java, SearchAndReplace.java, HelpViewer.java, KillRing.java, Log.java, GUIUtilities.java, VFSManager.java, EditBus.java, TextAreaPainter.java, DockableWindowManager.java, MiscUtilities.java, JEditTextArea.java, View.java, ActionHandler.java, UndoManager.java, LineManager.java, PositionManager.java, TokenMarker.java, FoldHandler.java, BufferSet.java, BufferSwitcher.java, Macros.java, VFS.java, PluginJAR.java, Mode.java, SyntaxStyle.java, EditPane.java, RecentFilesMenu.java, DirectoryMenu.java, EnhancedCheckBoxMenuItem.java, FileVFS.java, HyperSearchResults.java, OptionsDialog.java, PluginManagerOptionPane.java, TextAreaTransferHandler.java, BeanShell.java, MarkerHighlight.java, Abbrevs.java, InputHandler.java, TextAreaDialog.java, HistoryTextField.java, BrowserView.java, DockableWindowFactory.java, DisplayManager.java, VFSBrowser.java, BufferOptions.java]  \n\nDetails:  \n- **Buffer.java**: High co-change confidence (0.196), central to buffer management and indirectly used via `BufferIORequest`.  \n- **PluginManager.java**: Appears in call graph; manages plugins that may interact with jEdit core functionality.  \n- **BufferIORequest.java**: Direct coupling via static variable access and mediates I/O operations for buffers.  \n- **SearchAndReplace.java**: Appears in call graph; interacts with buffer content and selection.  \n- **HelpViewer.java**: Appears in call graph; involved in UI help integration tied to main editor.  \n- **KillRing.java**: Appears in call graph; involved in clipboard operations affecting buffer edits.  \n- **Log.java**: Appears in call graph; logging is integral to debugging and error handling in editor logic.  \n- **GUIUtilities.java**: High co-change support (0.179), contains UI helpers used throughout the application.  \n- **VFSManager.java**: Manages file systems and I/O coordination, tightly related to buffer loading/saving.  \n- **EditBus.java**: Core event bus for communication between components including buffers and views.  \n- **TextAreaPainter.java**: Renders visual elements over text area, likely affected by view/editor changes.  \n- **DockableWindowManager.java**: Manages window layout, often co-changed with UI-related updates.  \n- **MiscUtilities.java**: General utility functions used across modules, often co-changed with core files.  \n- **JEditTextArea.java**: Central UI component for editing, highly dependent on buffer and editor state.  \n- **View.java**: Represents a view into a buffer, frequently co-changed with editor-level logic.  \n- **ActionHandler.java**: Handles user actions, often tied to core editing behavior and buffer manipulation.  \n- **UndoManager.java**: Manages undo/redo stack, closely tied to buffer modification tracking.  \n- **LineManager.java**: Manages line data in buffer, likely affected by changes in buffer structure.  \n- **PositionManager.java**: Manages document positions, impacted by structural or edit-related changes.  \n- **TokenMarker.java**: Syntax highlighting core class, often affected by buffer and mode changes.  \n- **FoldHandler.java**: Controls code folding, frequently modified alongside buffer and view logic.  \n- **BufferSet.java**: Manages sets of buffers, likely affected by global buffer state changes.  \n- **BufferSwitcher.java**: Switches between buffers, co-changed when navigation or buffer logic evolves.  \n- **Macros.java**: Implements macro execution, interacts with buffers and editor context.  \n- **VFS.java**: Abstract base class for virtual file system, involved in I/O coordination.  \n- **PluginJAR.java**: Manages plugin JARs, often co-changed due to plugin-editor integration.  \n- **Mode.java**: Defines editing modes, impacts syntax and behavior tied to buffer and editor.  \n- **SyntaxStyle.java**: Defines syntax display styles, co-changed with token and mode-related logic.  \n- **EditPane.java**: Hosts editing UI components, frequently synchronized with editor logic changes.  \n- **RecentFilesMenu.java**: UI for recent files, likely changed when file/opening logic is updated.  \n- **DirectoryMenu.java**: Navigates directories, linked to file-open and project-related changes.  \n- **EnhancedCheckBoxMenuItem.java**: UI control used in options and settings, often synchronized.  \n- **FileVFS.java**: Concrete implementation of file system, co-changed during I/O logic updates.  \n- **HyperSearchResults.java**: Displays search results, interacts with buffer content and selections.  \n- **OptionsDialog.java**: Editor-wide configuration UI, often co-modified with global settings.  \n- **PluginManagerOptionPane.java**: Settings panel for plugins, co-changed when plugin APIs evolve.  \n- **TextAreaTransferHandler.java**: Handles drag/drop and clipboard, interacts with buffer content.  \n- **BeanShell.java**: Scripting interface, often modified alongside core editor functionality.  \n- **MarkerHighlight.java**: Highlights markers in the text area, affected by marker/buffer changes.  \n- **Abbrevs.java**: Manages abbreviations, interacts with buffer insertion and typing behavior.  \n- **InputHandler.java**: Processes keyboard input, co-changed with editing and command logic.  \n- **TextAreaDialog.java**: Base dialog for text input, often synchronized with buffer interaction.  \n- **HistoryTextField.java**: Input field with history, used in dialogs tied to buffer/file operations.  \n- **BrowserView.java**: File browser UI, often changed when file navigation logic is updated.  \n- **DockableWindowFactory.java**: Creates dockable windows, impacted by layout/UI evolution.  \n- **DisplayManager.java**: Manages screen line display, affected by buffer and rendering changes.  \n- **VFSBrowser.java**: UI for browsing files, co-changed with file I/O and navigation logic.  \n- **BufferOptions.java**: Configuration for buffer properties, often synchronized with buffer logic.",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        }
    ],
    "interaction_records": {
        "step_histories": [
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4"
                ],
                "response_message": "m5"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6"
                ],
                "response_message": "m7"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8"
                ],
                "response_message": "m9"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10"
                ],
                "response_message": "m11"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12"
                ],
                "response_message": "m13"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14"
                ],
                "response_message": "m15"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14",
                    "m15",
                    "m16",
                    "m17"
                ],
                "response_message": "m18"
            }
        ],
        "mid_to_message": {
            "m1": {
                "role": "system",
                "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
            },
            "m2": {
                "role": "user",
                "content": "The project you need to analyze is `jEdit`, a well-known Java open source project. The starting entity you need to deal with is jEdit.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
            },
            "m3": {
                "content": "",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_34d05ed295204d1c80b12e",
                        "function": {
                            "arguments": "{\"entity\": \"jEdit.java\"}",
                            "name": "get_co_change_relationship"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m4": {
                "name": "get_co_change_relationship",
                "role": "tool",
                "content": "[[\"Entry\", \"16\", \"0.053156146179401995\"], [\"BufferHistory\", \"15\", \"0.04983388704318937\"], [\"EditPane\", \"29\", \"0.09634551495016612\"], [\"RecentHandler\", \"5\", \"0.016611295681063124\"], [\"Buffer\", \"59\", \"0.19601328903654486\"], [\"SearchAndReplace\", \"19\", \"0.06312292358803986\"], [\"View\", \"47\", \"0.15614617940199335\"], [\"EditServer\", \"20\", \"0.0664451827242525\"], [\"WindowHandler\", \"5\", \"0.016611295681063124\"], [\"ActionHandler\", \"48\", \"0.15946843853820597\"], [\"GeneralOptionPane\", \"11\", \"0.036544850498338874\"], [\"JEditActionContext\", \"2\", \"0.006644518272425249\"], [\"ShortcutsOptionPane\", \"7\", \"0.023255813953488372\"], [\"ToolBarEditDialog\", \"9\", \"0.029900332225913623\"], [\"ActionContext\", \"5\", \"0.016611295681063124\"], [\"JEditVisitorAdapter\", \"1\", \"0.0033222591362126247\"], [\"JEditVisitor\", \"1\", \"0.0033222591362126247\"], [\"CompleteWord\", \"17\", \"0.05647840531561462\"], [\"SaveCaretInfoVisitor\", \"1\", \"0.0033222591362126247\"], [\"SetCursorVisitor\", \"1\", \"0.0033222591362126247\"], [\"GUIUtilities\", \"54\", \"0.17940199335548174\"], [\"RolloverButton\", \"3\", \"0.009966777408637873\"], [\"HyperSearchResults\", \"17\", \"0.05647840531561462\"], [\"ExpansionToggleBorder\", \"2\", \"0.006644518272425249\"], [\"PanelWindowContainer\", \"20\", \"0.0664451827242525\"], [\"AbbrevsOptionPane\", \"8\", \"0.026578073089700997\"], [\"FloatingWindowContainer\", \"13\", \"0.04318936877076412\"], [\"ToolBarOptionPane\", \"2\", \"0.006644518272425249\"], [\"PluginsMenuButton\", \"7\", \"0.023255813953488372\"], [\"CommandsMenuButton\", \"2\", \"0.006644518272425249\"], [\"FavoritesMenuButton\", \"4\", \"0.013289036544850499\"], [\"HistoryButton\", \"1\", \"0.0033222591362126247\"], [\"SaveButton\", \"1\", \"0.0033222591362126247\"], [\"ChoosePluginSet\", \"1\", \"0.0033222591362126247\"], [\"RestoreButton\", \"1\", \"0.0033222591362126247\"], [\"ClearPluginSet\", \"1\", \"0.0033222591362126247\"], [\"MouseOverHandler\", \"1\", \"0.0033222591362126247\"], [\"AppearanceOptionPane\", \"15\", \"0.04983388704318937\"], [\"IconTheme\", \"1\", \"0.0033222591362126247\"], [\"Debug\", \"7\", \"0.023255813953488372\"], [\"GrabKeyDialog\", \"5\", \"0.016611295681063124\"], [\"InputHandler\", \"6\", \"0.019933554817275746\"], [\"KeyEventWorkaround\", \"10\", \"0.03322259136212625\"], [\"TextAreaInputHandler\", \"1\", \"0.0033222591362126247\"], [\"KeyEventTranslator\", \"8\", \"0.026578073089700997\"], [\"MyFocusManager\", \"10\", \"0.03322259136212625\"], [\"InputPane\", \"7\", \"0.023255813953488372\"], [\"BufferSet\", \"1\", \"0.0033222591362126247\"], [\"BufferSetListener\", \"1\", \"0.0033222591362126247\"], [\"BufferSetManager\", \"4\", \"0.013289036544850499\"], [\"BufferSwitcher\", \"3\", \"0.009966777408637873\"], [\"BufferSetAdapter\", \"1\", \"0.0033222591362126247\"], [\"ViewOptionPane\", \"4\", \"0.013289036544850499\"], [\"DockableWindowContainer\", \"5\", \"0.016611295681063124\"], [\"DockableWindowManager\", \"51\", \"0.16943521594684385\"], [\"DockableWindowManagerImpl\", \"1\", \"0.0033222591362126247\"], [\"DockingArea\", \"1\", \"0.0033222591362126247\"], [\"DockingLayout\", \"2\", \"0.006644518272425249\"], [\"DockableLayout\", \"8\", \"0.026578073089700997\"], [\"DockBorder\", \"1\", \"0.0033222591362126247\"], [\"ButtonLayout\", \"4\", \"0.013289036544850499\"], [\"ViewConfig\", \"5\", \"0.016611295681063124\"], [\"DockablePanel\", \"3\", \"0.009966777408637873\"], [\"PerspectiveHandler\", \"6\", \"0.019933554817275746\"], [\"DockableWindowFactory\", \"5\", \"0.016611295681063124\"], [\"DockingLayoutManager\", \"2\", \"0.006644518272425249\"], [\"DockingLayoutSetter\", \"1\", \"0.0033222591362126247\"], [\"PerspectiveManager\", \"14\", \"0.046511627906976744\"], [\"SettingsXML\", \"1\", \"0.0033222591362126247\"], [\"DockingOptionPane\", \"2\", \"0.006644518272425249\"], [\"DockableWindowManagerProvider\", \"1\", \"0.0033222591362126247\"], [\"IDockingFrameworkProvider\", \"1\", \"0.0033222591362126247\"], [\"DockableWindowConfig\", \"1\", \"0.0033222591362126247\"], [\"LoadPerspectiveAction\", \"1\", \"0.0033222591362126247\"], [\"CloseDialog\", \"3\", \"0.009966777408637873\"], [\"SaveBackupOptionPane\", \"3\", \"0.009966777408637873\"], [\"Macros\", \"19\", \"0.06312292358803986\"], [\"DraggedURLLoader\", \"1\", \"0.0033222591362126247\"], [\"StringCompare\", \"2\", \"0.006644518272425249\"], [\"VFS\", \"17\", \"0.05647840531561462\"], [\"PluginTableModel\", \"24\", \"0.07973421926910298\"], [\"TableModelHandler\", \"3\", \"0.009966777408637873\"], [\"BufferOptionPane\", \"1\", \"0.0033222591362126247\"], [\"StyleTableModel\", \"6\", \"0.019933554817275746\"], [\"EditingOptionPane\", \"13\", \"0.04318936877076412\"], [\"EncodingsOptionPane\", \"1\", \"0.0033222591362126247\"], [\"ServiceFoldHandlerProvider\", \"1\", \"0.0033222591362126247\"], [\"RemoveButton\", \"7\", \"0.023255813953488372\"], [\"DirectoryProvider\", \"5\", \"0.016611295681063124\"], [\"SendVFSUpdatesSafely\", \"1\", \"0.0033222591362126247\"], [\"Mode\", \"7\", \"0.023255813953488372\"], [\"JEditTextArea\", \"74\", \"0.24584717607973422\"], [\"ParserRuleSet\", \"6\", \"0.019933554817275746\"], [\"VFSBrowser\", \"36\", \"0.11960132890365449\"], [\"HyperSearchResult\", \"7\", \"0.023255813953488372\"], [\"XModeHandler\", \"6\", \"0.019933554817275746\"], [\"DefaultInputHandler\", \"13\", \"0.04318936877076412\"], [\"PastePrevious\", \"3\", \"0.009966777408637873\"], [\"TokenMarker\", \"15\", \"0.04983388704318937\"], [\"JARClassLoader\", \"23\", \"0.07641196013289037\"], [\"PosBottomHalf\", \"4\", \"0.013289036544850499\"], [\"HyperSearchRequest\", \"11\", \"0.036544850498338874\"], [\"TextUtilities\", \"14\", \"0.046511627906976744\"], [\"Token\", \"1\", \"0.0033222591362126247\"], [\"OffsetManager\", \"17\", \"0.05647840531561462\"], [\"ModeOptionPane\", \"4\", \"0.013289036544850499\"], [\"TokenList\", \"1\", \"0.0033222591362126247\"], [\"CurrentDirectoryMenu\", \"2\", \"0.006644518272425249\"], [\"RecentDirectoriesMenu\", \"3\", \"0.009966777408637873\"], [\"ErrorEntry\", \"3\", \"0.009966777408637873\"], [\"MiscUtilities\", \"57\", \"0.1893687707641196\"], [\"OptionsDialog\", \"14\", \"0.046511627906976744\"], [\"FirewallOptionPane\", \"4\", \"0.013289036544850499\"], [\"Dependency\", \"9\", \"0.029900332225913623\"], [\"FirewallAuthenticator\", \"2\", \"0.006644518272425249\"], [\"OverviewOptionPane\", \"6\", \"0.019933554817275746\"], [\"BrowserJTree\", \"8\", \"0.026578073089700997\"], [\"HistoryTextField\", \"4\", \"0.013289036544850499\"], [\"BrowserView\", \"15\", \"0.04983388704318937\"], [\"PluginManagerProgress\", \"12\", \"0.03986710963455149\"], [\"MouseHandler\", \"45\", \"0.14950166112956811\"], [\"OperatingSystem\", \"12\", \"0.03986710963455149\"], [\"VFSManager\", \"3\", \"0.009966777408637873\"], [\"TextAreaPainter\", \"29\", \"0.09634551495016612\"], [\"BufferChangeHandler\", \"23\", \"0.07641196013289037\"], [\"FileVFS\", \"22\", \"0.07308970099667775\"], [\"StatusBar\", \"20\", \"0.0664451827242525\"], [\"SettingsReloader\", \"4\", \"0.013289036544850499\"], [\"LineInfo\", \"4\", \"0.013289036544850499\"], [\"ChunkCache\", \"18\", \"0.059800664451827246\"], [\"KeyHandler\", \"17\", \"0.05647840531561462\"], [\"EnhancedCheckBoxMenuItem\", \"7\", \"0.023255813953488372\"], [\"MarkersMenuItem\", \"2\", \"0.006644518272425249\"], [\"EnhancedMenuItem\", \"9\", \"0.029900332225913623\"], [\"BufferIORequest\", \"28\", \"0.09302325581395349\"], [\"InstallPluginsDialog\", \"14\", \"0.046511627906976744\"], [\"FileCellRenderer\", \"7\", \"0.023255813953488372\"], [\"PaneNameRenderer\", \"2\", \"0.006644518272425249\"], [\"FocusHandler\", \"2\", \"0.006644518272425249\"], [\"FoldVisibilityManager\", \"9\", \"0.029900332225913623\"], [\"Abbrevs\", \"10\", \"0.03322259136212625\"], [\"FavoritesVFS\", \"5\", \"0.016611295681063124\"], [\"CheckBoxListModel\", \"4\", \"0.013289036544850499\"], [\"BeanShell\", \"11\", \"0.036544850498338874\"], [\"MarkerHighlight\", \"3\", \"0.009966777408637873\"], [\"ListHandler\", \"2\", \"0.006644518272425249\"], [\"PluginList\", \"12\", \"0.03986710963455149\"], [\"WrapGuide\", \"2\", \"0.006644518272425249\"], [\"HelpViewer\", \"20\", \"0.0664451827242525\"], [\"BracketHighlight\", \"2\", \"0.006644518272425249\"], [\"AbstractOptionPane\", \"4\", \"0.013289036544850499\"], [\"SearchDialog\", \"18\", \"0.059800664451827246\"], [\"BufferOptions\", \"13\", \"0.04318936877076412\"], [\"ModeProperties\", \"8\", \"0.026578073089700997\"], [\"TOCHandler\", \"5\", \"0.016611295681063124\"], [\"TipOfTheDay\", \"6\", \"0.019933554817275746\"], [\"Gutter\", \"8\", \"0.026578073089700997\"], [\"ParentDirectoryRenderer\", \"3\", \"0.009966777408637873\"], [\"BufferPrintable\", \"8\", \"0.026578073089700997\"], [\"Handler\", \"8\", \"0.026578073089700997\"], [\"Macro\", \"11\", \"0.036544850498338874\"], [\"JAR\", \"18\", \"0.059800664451827246\"], [\"BeanShellHandler\", \"4\", \"0.013289036544850499\"], [\"ComponentHandler\", \"2\", \"0.006644518272425249\"], [\"PluginManager\", \"20\", \"0.0664451827242525\"], [\"JCheckBoxList\", \"4\", \"0.013289036544850499\"], [\"FileRootsVFS\", \"8\", \"0.026578073089700997\"], [\"EnhancedDialog\", \"2\", \"0.006644518272425249\"], [\"PluginListDownloadProgress\", \"2\", \"0.006644518272425249\"], [\"Wrapper\", \"5\", \"0.016611295681063124\"], [\"Rect\", \"7\", \"0.023255813953488372\"], [\"TOCTree\", \"3\", \"0.009966777408637873\"], [\"GlobalOptions\", \"10\", \"0.03322259136212625\"], [\"DownloadThread\", \"4\", \"0.013289036544850499\"], [\"MouseWheelHandler\", \"4\", \"0.013289036544850499\"], [\"BrowserColorsOptionPane\", \"2\", \"0.006644518272425249\"], [\"PropertyChangeHandler\", \"4\", \"0.013289036544850499\"], [\"HelpIndex\", \"10\", \"0.03322259136212625\"], [\"AnimatedIcon\", \"2\", \"0.006644518272425249\"], [\"SplashScreen\", \"7\", \"0.023255813953488372\"], [\"OSTask\", \"4\", \"0.013289036544850499\"], [\"Install\", \"16\", \"0.053156146179401995\"], [\"NonInteractiveInstall\", \"2\", \"0.006644518272425249\"], [\"SwingInstall\", \"4\", \"0.013289036544850499\"], [\"ConsoleInstall\", \"2\", \"0.006644518272425249\"], [\"GenerateTocXML\", \"2\", \"0.006644518272425249\"], [\"HelpTOCPanel\", \"12\", \"0.03986710963455149\"], [\"Chunk\", \"2\", \"0.006644518272425249\"], [\"RecentFilesMenu\", \"5\", \"0.016611295681063124\"], [\"DirectoryMenu\", \"2\", \"0.006644518272425249\"], [\"EnhancedMenu\", \"8\", \"0.026578073089700997\"], [\"MarkersMenu\", \"2\", \"0.006644518272425249\"], [\"MacrosMenu\", \"8\", \"0.026578073089700997\"], [\"HistoryModel\", \"17\", \"0.05647840531561462\"], [\"BeanShellAction\", \"5\", \"0.016611295681063124\"], [\"Registers\", \"18\", \"0.059800664451827246\"], [\"PaintSelection\", \"4\", \"0.013289036544850499\"], [\"RegistersHandler\", \"4\", \"0.013289036544850499\"], [\"TextAreaOptionPane\", \"9\", \"0.029900332225913623\"], [\"ActionTextField\", \"3\", \"0.009966777408637873\"], [\"Autosave\", \"4\", \"0.013289036544850499\"], [\"ActionBar\", \"10\", \"0.03322259136212625\"], [\"ExplicitFoldHandler\", \"2\", \"0.006644518272425249\"], [\"CompletionPopup\", \"6\", \"0.019933554817275746\"], [\"LogViewer\", \"7\", \"0.023255813953488372\"], [\"PaintLineBackground\", \"2\", \"0.006644518272425249\"], [\"Anchor\", \"2\", \"0.006644518272425249\"], [\"BufferChangeListener\", \"4\", \"0.013289036544850499\"], [\"PluginInfoBox\", \"4\", \"0.013289036544850499\"], [\"ListUpdater\", \"4\", \"0.013289036544850499\"], [\"BufferChangeAdapter\", \"4\", \"0.013289036544850499\"], [\"TextRenderer\", \"6\", \"0.019933554817275746\"], [\"InstallPanel\", \"6\", \"0.019933554817275746\"], [\"SizeLabel\", \"6\", \"0.019933554817275746\"], [\"ManagePanel\", \"9\", \"0.029900332225913623\"], [\"DirectoryEntryCompare\", \"4\", \"0.013289036544850499\"], [\"ActionSet\", \"33\", \"0.10963455149501661\"], [\"FirstLine\", \"10\", \"0.03322259136212625\"], [\"StatusBarOptionPane\", \"4\", \"0.013289036544850499\"], [\"LoadSaveOptionPane\", \"2\", \"0.006644518272425249\"], [\"QuickNotepad\", \"2\", \"0.006644518272425249\"], [\"DockableListHandler\", \"14\", \"0.046511627906976744\"], [\"Factory\", \"14\", \"0.046511627906976744\"], [\"ScrollLineCount\", \"2\", \"0.006644518272425249\"], [\"VFSFileNameField\", \"8\", \"0.026578073089700997\"], [\"DisplayManager\", \"12\", \"0.03986710963455149\"], [\"VFSFileChooserDialog\", \"9\", \"0.029900332225913623\"], [\"PluginManagerOptionPane\", \"4\", \"0.013289036544850499\"], [\"MirrorModel\", \"2\", \"0.006644518272425249\"], [\"BrowserOptionPane\", \"2\", \"0.006644518272425249\"], [\"DownloadMirrorsThread\", \"2\", \"0.006644518272425249\"], [\"BrowserHandler\", \"4\", \"0.013289036544850499\"], [\"ResourceCache\", \"9\", \"0.029900332225913623\"], [\"PaintBracketHighlight\", \"2\", \"0.006644518272425249\"], [\"PaintCaret\", \"6\", \"0.019933554817275746\"], [\"PaintText\", \"4\", \"0.013289036544850499\"], [\"PaintWrapGuide\", \"2\", \"0.006644518272425249\"], [\"FoldHandler\", \"4\", \"0.013289036544850499\"], [\"PluginCacheEntry\", \"15\", \"0.04983388704318937\"], [\"ServiceManager\", \"11\", \"0.036544850498338874\"], [\"ServiceListHandler\", \"8\", \"0.026578073089700997\"], [\"EditAction\", \"7\", \"0.023255813953488372\"], [\"Model\", \"3\", \"0.009966777408637873\"], [\"VFSDirectoryEntryTable\", \"5\", \"0.016611295681063124\"], [\"Remove\", \"18\", \"0.059800664451827246\"], [\"TableMouseHandler\", \"3\", \"0.009966777408637873\"], [\"VFSDirectoryEntryTableModel\", \"1\", \"0.0033222591362126247\"], [\"Descriptor\", \"3\", \"0.009966777408637873\"], [\"Deferred\", \"5\", \"0.016611295681063124\"], [\"EnhancedButton\", \"5\", \"0.016611295681063124\"], [\"PluginJAR\", \"65\", \"0.2159468438538206\"], [\"EditPlugin\", \"8\", \"0.026578073089700997\"], [\"Plugin\", \"8\", \"0.026578073089700997\"], [\"EBMessage\", \"4\", \"0.013289036544850499\"], [\"PluginResURLConnection\", \"2\", \"0.006644518272425249\"], [\"HelpButton\", \"11\", \"0.036544850498338874\"], [\"LatestVersionPlugin\", \"2\", \"0.006644518272425249\"], [\"PluginUpdate\", \"6\", \"0.019933554817275746\"], [\"BrowserCommandsMenu\", \"5\", \"0.016611295681063124\"], [\"VariableGridLayout\", \"2\", \"0.006644518272425249\"], [\"SearchBar\", \"5\", \"0.016611295681063124\"], [\"EditBus\", \"3\", \"0.009966777408637873\"], [\"EBPlugin\", \"2\", \"0.006644518272425249\"], [\"ThreadProgress\", \"2\", \"0.006644518272425249\"], [\"MarkersProvider\", \"2\", \"0.006644518272425249\"], [\"RecentDirectoriesProvider\", \"6\", \"0.019933554817275746\"], [\"RecentFilesProvider\", \"4\", \"0.013289036544850499\"], [\"DynamicMenuProvider\", \"2\", \"0.006644518272425249\"], [\"MacrosProvider\", \"2\", \"0.006644518272425249\"], [\"PluginsProvider\", \"2\", \"0.006644518272425249\"], [\"EvalError\", \"2\", \"0.006644518272425249\"], [\"PluginOptions\", \"2\", \"0.006644518272425249\"], [\"Roster\", \"8\", \"0.026578073089700997\"], [\"ScrollLayout\", \"4\", \"0.013289036544850499\"], [\"ExtensionManager\", \"2\", \"0.006644518272425249\"], [\"KillRing\", \"17\", \"0.05647840531561462\"], [\"UndoManager\", \"8\", \"0.026578073089700997\"], [\"Operation\", \"2\", \"0.006644518272425249\"], [\"InstallButton\", \"8\", \"0.026578073089700997\"], [\"RosterThread\", \"2\", \"0.006644518272425249\"], [\"LogList\", \"2\", \"0.006644518272425249\"], [\"IntegerArray\", \"3\", \"0.009966777408637873\"], [\"GutterOptionPane\", \"8\", \"0.026578073089700997\"], [\"EditAbbrevDialog\", \"4\", \"0.013289036544850499\"], [\"AbbrevsModel\", \"4\", \"0.013289036544850499\"], [\"BoyerMooreSearchMatcher\", \"8\", \"0.026578073089700997\"], [\"BrowserIORequest\", \"6\", \"0.019933554817275746\"], [\"EntryCompare\", \"3\", \"0.009966777408637873\"], [\"HeaderMouseHandler\", \"2\", \"0.006644518272425249\"], [\"BufferPrinter1_4\", \"2\", \"0.006644518272425249\"], [\"BufferPrinter1_3\", \"2\", \"0.006644518272425249\"], [\"PrintOptionPane\", \"6\", \"0.019933554817275746\"], [\"UnixWorkaround\", \"4\", \"0.013289036544850499\"], [\"InstallThread\", \"2\", \"0.006644518272425249\"], [\"OptionGroup\", \"2\", \"0.006644518272425249\"], [\"PositionManager\", \"2\", \"0.006644518272425249\"], [\"Highlight\", \"2\", \"0.006644518272425249\"], [\"Match\", \"2\", \"0.006644518272425249\"], [\"RESearchMatcher\", \"3\", \"0.009966777408637873\"], [\"MouseActions\", \"2\", \"0.006644518272425249\"], [\"Insert\", \"2\", \"0.006644518272425249\"], [\"KillRingHandler\", \"5\", \"0.016611295681063124\"], [\"NameSpace\", \"3\", \"0.009966777408637873\"], [\"SettingsActionHandler\", \"5\", \"0.016611295681063124\"], [\"TextAreaTransferHandler\", \"8\", \"0.026578073089700997\"], [\"TextAreaDialog\", \"5\", \"0.016611295681063124\"], [\"BeanShellErrorDialog\", \"2\", \"0.006644518272425249\"], [\"FilesChangedDialog\", \"6\", \"0.019933554817275746\"], [\"Renderer\", \"8\", \"0.026578073089700997\"], [\"TreeHandler\", \"2\", \"0.006644518272425249\"], [\"ButtonActionHandler\", \"2\", \"0.006644518272425249\"], [\"SelectallButton\", \"2\", \"0.006644518272425249\"], [\"RootsEntry\", \"4\", \"0.013289036544850499\"], [\"Delegate\", \"2\", \"0.006644518272425249\"], [\"ResultCellRenderer\", \"8\", \"0.026578073089700997\"], [\"MacOSPlugin\", \"2\", \"0.006644518272425249\"], [\"ErrorListCellRenderer\", \"2\", \"0.006644518272425249\"], [\"ShortcutsModel\", \"7\", \"0.023255813953488372\"], [\"BrowserActionContext\", \"2\", \"0.006644518272425249\"], [\"MemoryStatus\", \"8\", \"0.026578073089700997\"], [\"PropertyManager\", \"2\", \"0.006644518272425249\"], [\"Clock\", \"2\", \"0.006644518272425249\"], [\"DropHandler\", \"2\", \"0.006644518272425249\"], [\"RingListModel\", \"2\", \"0.006644518272425249\"], [\"KeywordMap\", \"2\", \"0.006644518272425249\"], [\"HelpFile\", \"2\", \"0.006644518272425249\"], [\"WorkThreadPool\", \"3\", \"0.009966777408637873\"], [\"DisplayTokenHandler\", \"2\", \"0.006644518272425249\"], [\"Windows\", \"2\", \"0.006644518272425249\"], [\"FontSelectorDialog\", \"3\", \"0.009966777408637873\"], [\"StyleEditor\", \"4\", \"0.013289036544850499\"], [\"SelectLineRange\", \"2\", \"0.006644518272425249\"], [\"ErrorListDialog\", \"2\", \"0.006644518272425249\"], [\"PasteFromListDialog\", \"4\", \"0.013289036544850499\"], [\"ContextAddDialog\", \"6\", \"0.019933554817275746\"], [\"AboutDialog\", \"2\", \"0.006644518272425249\"], [\"ViewRegisters\", \"2\", \"0.006644518272425249\"], [\"AddAbbrevDialog\", \"2\", \"0.006644518272425249\"], [\"ParserRule\", \"5\", \"0.016611295681063124\"], [\"JEditMetalTheme15\", \"2\", \"0.006644518272425249\"], [\"JEditMetalTheme14\", \"2\", \"0.006644518272425249\"], [\"TextAreaDropHandler\", \"2\", \"0.006644518272425249\"], [\"MyFocusTraversalPolicy\", \"2\", \"0.006644518272425249\"], [\"Broken\", \"2\", \"0.006644518272425249\"], [\"MarkerViewer\", \"2\", \"0.006644518272425249\"], [\"RegisterChanged\", \"2\", \"0.006644518272425249\"], [\"RegisterViewer\", \"2\", \"0.006644518272425249\"], [\"GoToNodeAction\", \"2\", \"0.006644518272425249\"], [\"HyperSearchFileNode\", \"2\", \"0.006644518272425249\"], [\"HyperSearchNode\", \"2\", \"0.006644518272425249\"], [\"MutableListModel\", \"2\", \"0.006644518272425249\"], [\"BufferLoadRequest\", \"2\", \"0.006644518272425249\"], [\"OpenBracketIndentRule\", \"2\", \"0.006644518272425249\"], [\"HelpViewerDialog\", \"2\", \"0.006644518272425249\"], [\"HelpViewerInterface\", \"2\", \"0.006644518272425249\"], [\"HelpSearchPanel\", \"2\", \"0.006644518272425249\"], [\"LinkHandler\", \"3\", \"0.009966777408637873\"], [\"BufferChanging\", \"2\", \"0.006644518272425249\"], [\"JEditBuffer\", \"2\", \"0.006644518272425249\"], [\"SegmentCharSequence\", \"2\", \"0.006644518272425249\"], [\"PluginListHandler\", \"2\", \"0.006644518272425249\"], [\"AllBufferSet\", \"2\", \"0.006644518272425249\"], [\"MirrorList\", \"4\", \"0.013289036544850499\"], [\"MirrorListHandler\", \"2\", \"0.006644518272425249\"], [\"SearchMatcher\", \"2\", \"0.006644518272425249\"], [\"DirectoryLoadedAWTRequest\", \"4\", \"0.013289036544850499\"], [\"ActionListHandler\", \"2\", \"0.006644518272425249\"], [\"ModeCatalogHandler\", \"2\", \"0.006644518272425249\"], [\"TagDecl\", \"3\", \"0.009966777408637873\"], [\"ColorEntry\", \"2\", \"0.006644518272425249\"], [\"PatternSearchMatcher\", \"2\", \"0.006644518272425249\"], [\"WindowTableModel\", \"4\", \"0.013289036544850499\"], [\"IOUtilities\", \"2\", \"0.006644518272425249\"], [\"FavoritesProvider\", \"2\", \"0.006644518272425249\"], [\"Branch\", \"2\", \"0.006644518272425249\"], [\"BufferListSet\", \"2\", \"0.006644518272425249\"], [\"StringICaseCompare\", \"3\", \"0.009966777408637873\"], [\"WindowCompare\", \"3\", \"0.009966777408637873\"], [\"AbbrevCompare\", \"3\", \"0.009966777408637873\"], [\"DockableWindowCompare\", \"2\", \"0.006644518272425249\"], [\"MenuItemCompare\", \"4\", \"0.013289036544850499\"], [\"ButtonCompare\", \"4\", \"0.013289036544850499\"], [\"PluginCompare\", \"2\", \"0.006644518272425249\"], [\"Log\", \"2\", \"0.006644518272425249\"], [\"Interpreter\", \"1\", \"0.0033222591362126247\"], [\"VICaretStatus\", \"2\", \"0.006644518272425249\"], [\"WorkThread\", \"3\", \"0.009966777408637873\"], [\"ColorTableModel\", \"4\", \"0.013289036544850499\"], [\"TabbedPane\", \"1\", \"0.0033222591362126247\"], [\"TipPanel\", \"1\", \"0.0033222591362126247\"], [\"StyleRenderer\", \"1\", \"0.0033222591362126247\"], [\"WorkThreadProgressListener\", \"1\", \"0.0033222591362126247\"], [\"WorkThreadHandler\", \"1\", \"0.0033222591362126247\"], [\"TOCCellRenderer\", \"1\", \"0.0033222591362126247\"], [\"HelpNode\", \"1\", \"0.0033222591362126247\"], [\"REMatch\", \"1\", \"0.0033222591362126247\"], [\"Button\", \"2\", \"0.006644518272425249\"], [\"ButtonCellRenderer\", \"1\", \"0.0033222591362126247\"], [\"MenuItem\", \"1\", \"0.0033222591362126247\"], [\"FileCompare\", \"1\", \"0.0033222591362126247\"], [\"FoldListener\", \"1\", \"0.0033222591362126247\"], [\"FoldEventHandler\", \"1\", \"0.0033222591362126247\"], [\"ContentManager\", \"1\", \"0.0033222591362126247\"], [\"ReadWriteLock\", \"1\", \"0.0033222591362126247\"], [\"PosTopHalf\", \"1\", \"0.0033222591362126247\"], [\"AboutPanel\", \"1\", \"0.0033222591362126247\"], [\"CompoundEdit\", \"1\", \"0.0033222591362126247\"], [\"BrowserColorsModel\", \"1\", \"0.0033222591362126247\"], [\"StyleChoice\", \"1\", \"0.0033222591362126247\"], [\"ColorChoice\", \"1\", \"0.0033222591362126247\"], [\"SizeSaver\", \"2\", \"0.006644518272425249\"], [\"MarkersSaveRequest\", \"1\", \"0.0033222591362126247\"], [\"BufferSaveRequest\", \"1\", \"0.0033222591362126247\"], [\"JEditKillRing\", \"1\", \"0.0033222591362126247\"]]"
            },
            "m5": {
                "content": "The co-change relationships for `jEdit.java` have been obtained, and they show a list of entities along with their support count and confidence level. These values indicate how often these files were modified together with `jEdit.java` in the past.\n\nHere are some key observations from the results:\n\n- Entities like `Buffer`, `View`, `ActionHandler`, `GUIUtilities`, `DockableWindowManager`, `MiscUtilities`, `JEditTextArea`, and `PluginJAR` have high confidence values (> 0.2), which means they are frequently changed together with `jEdit.java`. These should be considered as strong candidates for synchronization.\n  \n- Many other entities have relatively lower confidence values but still show significant coupling (e.g., `EditPane`, `SearchAndReplace`, `TextAreaPainter`, etc.). Depending on the nature of changes made to `jEdit.java`, these might also need to be reviewed.\n\nNow, let's dig deeper into one of these files to understand its role in the system and potential dependencies. A good candidate would be `Buffer.java`, as it has the highest confidence value (0.196) among the co-change relationships.\n\nI will call the `get_origin_code` function to retrieve the source code of `Buffer.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_1540c4573cc84f5c877c3e",
                        "function": {
                            "arguments": "{\"entity\": \"Buffer.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m6": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package org.gjt.sp.jedit;\\nimport gnu.regexp.*;\\nimport javax.swing.*;\\nimport javax.swing.text.*;\\nimport java.awt.Toolkit;\\nimport java.io.File;\\nimport java.io.IOException;\\nimport java.net.Socket;\\nimport java.util.*;\\nimport org.gjt.sp.jedit.browser.VFSBrowser;\\nimport org.gjt.sp.jedit.buffer.*;\\nimport org.gjt.sp.jedit.io.*;\\nimport org.gjt.sp.jedit.msg.*;\\nimport org.gjt.sp.jedit.search.RESearchMatcher;\\nimport org.gjt.sp.jedit.syntax.*;\\nimport org.gjt.sp.jedit.textarea.*;\\nimport org.gjt.sp.util.*;\\npublic class Buffer\\n{\\n\\tpublic static final String LINESEP = \\\"lineSeparator\\\";\\n\\tpublic static final String BACKED_UP = \\\"Buffer__backedUp\\\";\\n\\tpublic static final String CARET = \\\"Buffer__caret\\\";\\n\\tpublic static final String SELECTION = \\\"Buffer__selection\\\";\\n\\tpublic static final String SCROLL_VERT = \\\"Buffer__scrollVert\\\";\\n\\tpublic static final String SCROLL_HORIZ = \\\"Buffer__scrollHoriz\\\";\\n\\tpublic static final String ENCODING = \\\"encoding\\\";\\n\\tpublic static final String TRAILING_EOL = \\\"trailingEOL\\\";\\n\\tpublic static final String GZIPPED = \\\"gzipped\\\";\\n\\tpublic void showInsertFileDialog(View view)\\n\\t{\\n\\t\\tString[] files = GUIUtilities.showVFSFileDialog(view,null,\\n\\t\\t\\tVFSBrowser.OPEN_DIALOG,false);\\n\\t\\tif(files != null)\\n\\t\\t\\tinsertFile(view,files[0]);\\n\\t} \\n\\tpublic void reload(View view)\\n\\t{\\n\\t\\tif(getFlag(DIRTY))\\n\\t\\t{\\n\\t\\t\\tString[] args = { name };\\n\\t\\t\\tint result = GUIUtilities.confirm(view,\\\"changedreload\\\",\\n\\t\\t\\t\\targs,JOptionPane.YES_NO_OPTION,\\n\\t\\t\\t\\tJOptionPane.WARNING_MESSAGE);\\n\\t\\t\\tif(result != JOptionPane.YES_OPTION)\\n\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tview.getEditPane().saveCaretInfo();\\n\\t\\tload(view,true);\\n\\t} \\n\\tpublic boolean load(final View view, final boolean reload)\\n\\t{\\n\\t\\tif(isPerformingIO())\\n\\t\\t{\\n\\t\\t\\tGUIUtilities.error(view,\\\"buffer-multiple-io\\\",null);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tsetBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);\\n\\t\\tsetFlag(LOADING,true);\\n\\t\\t\\t\\t\\t\\t\\t\\tif(!getFlag(TEMPORARY))\\n\\t\\t\\tEditBus.send(new BufferUpdate(this,view,BufferUpdate.LOAD_STARTED));\\n\\t\\tfinal boolean loadAutosave;\\n\\t\\tif(reload || !getFlag(NEW_FILE))\\n\\t\\t{\\n\\t\\t\\tif(file != null)\\n\\t\\t\\t\\tmodTime = file.lastModified();\\n\\t\\t\\t\\t\\t\\tif(!reload && autosaveFile != null && autosaveFile.exists())\\n\\t\\t\\t\\tloadAutosave = recoverAutosave(view);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(autosaveFile != null)\\n\\t\\t\\t\\t\\tautosaveFile.delete();\\n\\t\\t\\t\\tloadAutosave = false;\\n\\t\\t\\t}\\n\\t\\t\\tif(!loadAutosave)\\n\\t\\t\\t{\\n\\t\\t\\t\\tVFS vfs = VFSManager.getVFSForPath(path);\\n\\t\\t\\t\\tif(!checkFileForLoad(view,vfs,path))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsetFlag(LOADING,false);\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(isNewFile())\\n\\t\\t\\t\\t\\t;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!vfs.load(view,this,path))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tsetFlag(LOADING,false);\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tloadAutosave = false;\\n\\t\\t\\t\\tRunnable runnable = new Runnable()\\n\\t\\t{\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\tString newPath = getStringProperty(\\n\\t\\t\\t\\t\\tBufferIORequest.NEW_PATH);\\n\\t\\t\\t\\tSegment seg = (Segment)getProperty(\\n\\t\\t\\t\\t\\tBufferIORequest.LOAD_DATA);\\n\\t\\t\\t\\tIntegerArray endOffsets = (IntegerArray)\\n\\t\\t\\t\\t\\tgetProperty(BufferIORequest.END_OFFSETS);\\n\\t\\t\\t\\tif(seg == null)\\n\\t\\t\\t\\t\\tseg = new Segment(new char[1024],0,0);\\n\\t\\t\\t\\tif(endOffsets == null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tendOffsets = new IntegerArray();\\n\\t\\t\\t\\t\\tendOffsets.add(1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twriteLock();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfirePreContentRemoved(0,0,getLineCount()\\n\\t\\t\\t\\t\\t\\t- 1,getLength());\\n\\t\\t\\t\\t\\tcontentMgr.remove(0,getLength());\\n\\t\\t\\t\\t\\tlineMgr.contentRemoved(0,0,getLineCount()\\n\\t\\t\\t\\t\\t\\t- 1,getLength());\\n\\t\\t\\t\\t\\tpositionMgr.contentRemoved(0,getLength());\\n\\t\\t\\t\\t\\tfireContentRemoved(0,0,getLineCount()\\n\\t\\t\\t\\t\\t\\t- 1,getLength());\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcontentMgr._setContent(seg.array,seg.count);\\n\\t\\t\\t\\t\\tlineMgr._contentInserted(endOffsets);\\n\\t\\t\\t\\t\\tpositionMgr.contentInserted(0,seg.count);\\n\\t\\t\\t\\t\\tfireContentInserted(0,0,\\n\\t\\t\\t\\t\\t\\tendOffsets.getSize() - 1,\\n\\t\\t\\t\\t\\t\\tseg.count - 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfinally\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twriteUnlock();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tunsetProperty(BufferIORequest.LOAD_DATA);\\n\\t\\t\\t\\tunsetProperty(BufferIORequest.END_OFFSETS);\\n\\t\\t\\t\\tunsetProperty(BufferIORequest.NEW_PATH);\\n\\t\\t\\t\\tundoMgr.clear();\\n\\t\\t\\t\\tundoMgr.setLimit(jEdit.getIntegerProperty(\\n\\t\\t\\t\\t\\t\\\"buffer.undoCount\\\",100));\\n\\t\\t\\t\\tif(!getFlag(TEMPORARY))\\n\\t\\t\\t\\t\\tfinishLoading();\\n\\t\\t\\t\\tsetFlag(LOADING,false);\\n\\t\\t\\t\\t\\t\\t\\t\\tif(reload)\\n\\t\\t\\t\\t\\tsetDirty(false);\\n\\t\\t\\t\\tif(!loadAutosave && newPath != null)\\n\\t\\t\\t\\t\\tsetPath(newPath);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(loadAutosave)\\n\\t\\t\\t\\t\\tsetFlag(DIRTY,true);\\n\\t\\t\\t\\t\\t\\t\\t\\tif(!getFlag(TEMPORARY))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tEditBus.send(new BufferUpdate(Buffer.this,\\n\\t\\t\\t\\t\\t\\tview,BufferUpdate.LOADED));\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}; \\n\\t\\tif(getFlag(TEMPORARY))\\n\\t\\t\\trunnable.run();\\n\\t\\telse\\n\\t\\t\\tVFSManager.runInAWTThread(runnable);\\n\\t\\treturn true;\\n\\t} \\n\\tpublic boolean insertFile(final View view, String path)\\n\\t{\\n\\t\\tif(isPerformingIO())\\n\\t\\t{\\n\\t\\t\\tGUIUtilities.error(view,\\\"buffer-multiple-io\\\",null);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tsetBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);\\n\\t\\tpath = MiscUtilities.constructPath(this.path,path);\\n\\t\\tBuffer buffer = jEdit.getBuffer(path);\\n\\t\\tif(buffer != null)\\n\\t\\t{\\n\\t\\t\\tview.getTextArea().setSelectedText(\\n\\t\\t\\t\\tbuffer.getText(0,buffer.getLength()));\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tVFS vfs = VFSManager.getVFSForPath(path);\\n\\t\\tsetFlag(IO,true);\\n\\t\\t\\t\\t\\t\\t\\t\\tif(!vfs.insert(view,this,path))\\n\\t\\t{\\n\\t\\t\\tsetFlag(IO,false);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\t\\tVFSManager.runInAWTThread(new Runnable()\\n\\t\\t{\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFlag(IO,false);\\n\\t\\t\\t\\tSegmentBuffer sbuf = (SegmentBuffer)getProperty(\\n\\t\\t\\t\\t\\tBufferIORequest.LOAD_DATA);\\n\\t\\t\\t\\tif(sbuf != null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tunsetProperty(BufferIORequest.LOAD_DATA);\\n\\t\\t\\t\\t\\tview.getTextArea().setSelectedText(sbuf.toString());\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\treturn true;\\n\\t} \\n\\tpublic void autosave()\\n\\t{\\n\\t\\tif(autosaveFile == null || !getFlag(AUTOSAVE_DIRTY)\\n\\t\\t\\t|| !getFlag(DIRTY)\\n\\t\\t\\t|| getFlag(LOADING)\\n\\t\\t\\t|| getFlag(IO))\\n\\t\\t\\treturn;\\n\\t\\tsetFlag(AUTOSAVE_DIRTY,false);\\n\\t\\tVFSManager.runInWorkThread(new BufferIORequest(\\n\\t\\t\\tBufferIORequest.AUTOSAVE,null,this,null,\\n\\t\\t\\tVFSManager.getFileVFS(),autosaveFile.getPath()));\\n\\t} \\n\\tpublic boolean saveAs(View view, boolean rename)\\n\\t{\\n\\t\\tString[] files = GUIUtilities.showVFSFileDialog(view,path,\\n\\t\\t\\tVFSBrowser.SAVE_DIALOG,false);\\n\\t\\t\\t\\t\\t\\tif(files == null)\\n\\t\\t\\treturn false;\\n\\t\\treturn save(view,files[0],rename);\\n\\t} \\n\\tpublic boolean save(View view, String path)\\n\\t{\\n\\t\\treturn save(view,path,true);\\n\\t} \\n\\tpublic boolean save(final View view, String path, final boolean rename)\\n\\t{\\n\\t\\tif(isPerformingIO())\\n\\t\\t{\\n\\t\\t\\tGUIUtilities.error(view,\\\"buffer-multiple-io\\\",null);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tsetBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);\\n\\t\\tif(path == null && getFlag(NEW_FILE))\\n\\t\\t\\treturn saveAs(view,rename);\\n\\t\\tif(path == null && file != null)\\n\\t\\t{\\n\\t\\t\\tlong newModTime = file.lastModified();\\n\\t\\t\\tif(newModTime != modTime\\n\\t\\t\\t\\t&& jEdit.getBooleanProperty(\\\"view.checkModStatus\\\"))\\n\\t\\t\\t{\\n\\t\\t\\t\\tObject[] args = { this.path };\\n\\t\\t\\t\\tint result = GUIUtilities.confirm(view,\\n\\t\\t\\t\\t\\t\\\"filechanged-save\\\",args,\\n\\t\\t\\t\\t\\tJOptionPane.YES_NO_OPTION,\\n\\t\\t\\t\\t\\tJOptionPane.WARNING_MESSAGE);\\n\\t\\t\\t\\tif(result != JOptionPane.YES_OPTION)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsetFlag(IO,true);\\n\\t\\tEditBus.send(new BufferUpdate(this,view,BufferUpdate.SAVING));\\n\\t\\tfinal String oldPath = this.path;\\n\\t\\tfinal String newPath = (path == null ? this.path : path);\\n\\t\\tVFS vfs = VFSManager.getVFSForPath(newPath);\\n\\t\\tif(!checkFileForSave(view,vfs,newPath))\\n\\t\\t{\\n\\t\\t\\tsetFlag(IO,false);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tif(!vfs.save(view,this,newPath))\\n\\t\\t{\\n\\t\\t\\tsetFlag(IO,false);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\t\\tVFSManager.runInAWTThread(new Runnable()\\n\\t\\t{\\n\\t\\t\\tpublic void run()\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFlag(IO,false);\\n\\t\\t\\t\\tfinishSaving(view,oldPath,newPath,rename,\\n\\t\\t\\t\\t\\tgetBooleanProperty(BufferIORequest\\n\\t\\t\\t\\t\\t.ERROR_OCCURRED));\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\treturn true;\\n\\t} \\n\\t\\tpublic static final int FILE_NOT_CHANGED = 0;\\n\\tpublic static final int FILE_CHANGED = 1;\\n\\tpublic static final int FILE_DELETED = 2;\\n\\tpublic int checkFileStatus(View view)\\n\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(!getFlag(IO) && !getFlag(LOADING) && file != null\\n\\t\\t\\t&& !getFlag(NEW_FILE))\\n\\t\\t{\\n\\t\\t\\tboolean newReadOnly = (file.exists() && !file.canWrite());\\n\\t\\t\\tif(newReadOnly != getFlag(READ_ONLY))\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFlag(READ_ONLY,newReadOnly);\\n\\t\\t\\t\\tEditBus.send(new BufferUpdate(this,null,\\n\\t\\t\\t\\t\\tBufferUpdate.DIRTY_CHANGED));\\n\\t\\t\\t}\\n\\t\\t\\tlong oldModTime = modTime;\\n\\t\\t\\tlong newModTime = file.lastModified();\\n\\t\\t\\tif(newModTime != oldModTime)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmodTime = newModTime;\\n\\t\\t\\t\\tif(!file.exists())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsetFlag(NEW_FILE,true);\\n\\t\\t\\t\\t\\tsetDirty(true);\\n\\t\\t\\t\\t\\treturn FILE_DELETED;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn FILE_CHANGED;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn FILE_NOT_CHANGED;\\n\\t} \\n\\tpublic long getLastModified()\\n\\t{\\n\\t\\treturn modTime;\\n\\t} \\n\\tpublic void setLastModified(long modTime)\\n\\t{\\n\\t\\tthis.modTime = modTime;\\n\\t} \\n\\tpublic VFS getVFS()\\n\\t{\\n\\t\\treturn VFSManager.getVFSForPath(path);\\n\\t} \\n\\tpublic File getAutosaveFile()\\n\\t{\\n\\t\\treturn autosaveFile;\\n\\t} \\n\\tpublic String getName()\\n\\t{\\n\\t\\treturn name;\\n\\t} \\n\\tpublic String getPath()\\n\\t{\\n\\t\\treturn path;\\n\\t} \\n\\tpublic String getSymlinkPath()\\n\\t{\\n\\t\\treturn symlinkPath;\\n\\t} \\n\\tpublic String getDirectory()\\n\\t{\\n\\t\\treturn directory;\\n\\t} \\n\\tpublic boolean isClosed()\\n\\t{\\n\\t\\treturn getFlag(CLOSED);\\n\\t} \\n\\tpublic boolean isLoaded()\\n\\t{\\n\\t\\treturn !getFlag(LOADING);\\n\\t} \\n\\tpublic boolean isPerformingIO()\\n\\t{\\n\\t\\treturn getFlag(LOADING) || getFlag(IO);\\n\\t} \\n\\tpublic boolean isNewFile()\\n\\t{\\n\\t\\treturn getFlag(NEW_FILE);\\n\\t} \\n\\tpublic void setNewFile(boolean newFile)\\n\\t{\\n\\t\\tsetFlag(NEW_FILE,newFile);\\n\\t\\tif(!newFile)\\n\\t\\t\\tsetFlag(UNTITLED,false);\\n\\t} \\n\\tpublic boolean isUntitled()\\n\\t{\\n\\t\\treturn getFlag(UNTITLED);\\n\\t} \\n\\tpublic boolean isDirty()\\n\\t{\\n\\t\\treturn getFlag(DIRTY);\\n\\t} \\n\\tpublic boolean isReadOnly()\\n\\t{\\n\\t\\treturn getFlag(READ_ONLY) || getFlag(READ_ONLY_OVERRIDE);\\n\\t} \\n\\tpublic boolean isEditable()\\n\\t{\\n\\t\\treturn !(getFlag(READ_ONLY) || getFlag(READ_ONLY_OVERRIDE)\\n\\t\\t\\t|| getFlag(IO) || getFlag(LOADING));\\n\\t} \\n\\tpublic void setReadOnly(boolean readOnly)\\n\\t{\\n\\t\\tsetFlag(READ_ONLY_OVERRIDE,readOnly);\\n\\t} \\n\\tpublic void setDirty(boolean d)\\n\\t{\\n\\t\\tboolean old_d = getFlag(DIRTY);\\n\\t\\tif(d)\\n\\t\\t{\\n\\t\\t\\tif(isEditable())\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFlag(DIRTY,true);\\n\\t\\t\\t\\tsetFlag(AUTOSAVE_DIRTY,true);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tsetFlag(DIRTY,false);\\n\\t\\t\\tsetFlag(AUTOSAVE_DIRTY,false);\\n\\t\\t\\tif(autosaveFile != null)\\n\\t\\t\\t\\tautosaveFile.delete();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(!getFlag(UNDO_IN_PROGRESS))\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tundoMgr.bufferSaved();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(d != old_d)\\n\\t\\t{\\n\\t\\t\\tEditBus.send(new BufferUpdate(this,null,\\n\\t\\t\\t\\tBufferUpdate.DIRTY_CHANGED));\\n\\t\\t}\\n\\t} \\n\\tpublic boolean isTemporary()\\n\\t{\\n\\t\\treturn getFlag(TEMPORARY);\\n\\t} \\n\\tpublic Icon getIcon()\\n\\t{\\n\\t\\tif(getFlag(DIRTY))\\n\\t\\t\\treturn GUIUtilities.DIRTY_BUFFER_ICON;\\n\\t\\telse if(getFlag(READ_ONLY) || getFlag(READ_ONLY_OVERRIDE))\\n\\t\\t\\treturn GUIUtilities.READ_ONLY_BUFFER_ICON;\\n\\t\\telse if(getFlag(NEW_FILE))\\n\\t\\t\\treturn GUIUtilities.NEW_BUFFER_ICON;\\n\\t\\telse\\n\\t\\t\\treturn GUIUtilities.NORMAL_BUFFER_ICON;\\n\\t} \\n\\tpublic void readLock()\\n\\t{\\n\\t\\tlock.readLock();\\n\\t} \\n\\tpublic void readUnlock()\\n\\t{\\n\\t\\tlock.readUnlock();\\n\\t} \\n\\tpublic void writeLock()\\n\\t{\\n\\t\\tlock.writeLock();\\n\\t} \\n\\tpublic void writeUnlock()\\n\\t{\\n\\t\\tlock.writeUnlock();\\n\\t} \\n\\tpublic int getLength()\\n\\t{\\n\\t\\t\\t\\treturn contentMgr.getLength();\\n\\t} \\n\\tpublic int getLineCount()\\n\\t{\\n\\t\\t\\t\\treturn lineMgr.getLineCount();\\n\\t} \\n\\tpublic int getLineOfOffset(int offset)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tif(offset < 0 || offset > getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(offset);\\n\\t\\t\\treturn lineMgr.getLineOfOffset(offset);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic int getLineStartOffset(int line)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tif(line < 0 || line >= lineMgr.getLineCount())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(line);\\n\\t\\t\\telse if(line == 0)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\treturn lineMgr.getLineEndOffset(line - 1);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic int getLineEndOffset(int line)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tif(line < 0 || line >= lineMgr.getLineCount())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(line);\\n\\t\\t\\treturn lineMgr.getLineEndOffset(line);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic int getLineLength(int line)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\treturn getLineEndOffset(line)\\n\\t\\t\\t\\t- getLineStartOffset(line) - 1;\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic String getLineText(int line)\\n\\t{\\n\\t\\tif(line < 0 || line >= lineMgr.getLineCount())\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(line);\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tint start = (line == 0 ? 0\\n\\t\\t\\t\\t: lineMgr.getLineEndOffset(line - 1));\\n\\t\\t\\tint end = lineMgr.getLineEndOffset(line);\\n\\t\\t\\treturn getText(start,end - start - 1);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void getLineText(int line, Segment segment)\\n\\t{\\n\\t\\tif(line < 0 || line >= lineMgr.getLineCount())\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(line);\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tint start = (line == 0 ? 0\\n\\t\\t\\t\\t: lineMgr.getLineEndOffset(line - 1));\\n\\t\\t\\tint end = lineMgr.getLineEndOffset(line);\\n\\t\\t\\tgetText(start,end - start - 1,segment);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic String getText(int start, int length)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tif(start < 0 || length < 0\\n\\t\\t\\t\\t|| start + length > contentMgr.getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(start + \\\":\\\" + length);\\n\\t\\t\\treturn contentMgr.getText(start,length);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void getText(int start, int length, Segment seg)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tif(start < 0 || length < 0\\n\\t\\t\\t\\t|| start + length > contentMgr.getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(start + \\\":\\\" + length);\\n\\t\\t\\tcontentMgr.getText(start,length,seg);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void insert(int offset, String str)\\n\\t{\\n\\t\\tif(str == null)\\n\\t\\t\\treturn;\\n\\t\\tint len = str.length();\\n\\t\\tif(len == 0)\\n\\t\\t\\treturn;\\n\\t\\tif(isReadOnly())\\n\\t\\t\\tthrow new RuntimeException(\\\"buffer read-only\\\");\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tif(offset < 0 || offset > contentMgr.getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(offset);\\n\\t\\t\\tcontentMgr.insert(offset,str);\\n\\t\\t\\tintegerArray.clear();\\n\\t\\t\\tfor(int i = 0; i < len; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(str.charAt(i) == '\\\\n')\\n\\t\\t\\t\\t\\tintegerArray.add(i + 1);\\n\\t\\t\\t}\\n\\t\\t\\tif(!getFlag(UNDO_IN_PROGRESS))\\n\\t\\t\\t{\\n\\t\\t\\t\\tundoMgr.contentInserted(offset,len,str,\\n\\t\\t\\t\\t\\t!getFlag(DIRTY));\\n\\t\\t\\t}\\n\\t\\t\\tcontentInserted(offset,len,integerArray);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void insert(int offset, Segment seg)\\n\\t{\\n\\t\\tif(seg.count == 0)\\n\\t\\t\\treturn;\\n\\t\\tif(isReadOnly())\\n\\t\\t\\tthrow new RuntimeException(\\\"buffer read-only\\\");\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tif(offset < 0 || offset > contentMgr.getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(offset);\\n\\t\\t\\tcontentMgr.insert(offset,seg);\\n\\t\\t\\tintegerArray.clear();\\n\\t\\t\\tfor(int i = 0; i < seg.count; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(seg.array[seg.offset + i] == '\\\\n')\\n\\t\\t\\t\\t\\tintegerArray.add(i + 1);\\n\\t\\t\\t}\\n\\t\\t\\tif(!getFlag(UNDO_IN_PROGRESS))\\n\\t\\t\\t{\\n\\t\\t\\t\\tundoMgr.contentInserted(offset,seg.count,\\n\\t\\t\\t\\t\\tseg.toString(),!getFlag(DIRTY));\\n\\t\\t\\t}\\n\\t\\t\\tcontentInserted(offset,seg.count,integerArray);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void remove(int offset, int length)\\n\\t{\\n\\t\\tif(length == 0)\\n\\t\\t\\treturn;\\n\\t\\tif(isReadOnly())\\n\\t\\t\\tthrow new RuntimeException(\\\"buffer read-only\\\");\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tif(offset < 0 || length < 0\\n\\t\\t\\t\\t|| offset + length > contentMgr.getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(offset + \\\":\\\" + length);\\n\\t\\t\\tint startLine = lineMgr.getLineOfOffset(offset);\\n\\t\\t\\tint endLine = lineMgr.getLineOfOffset(offset + length);\\n\\t\\t\\tint numLines = endLine - startLine;\\n\\t\\t\\tif(!getFlag(UNDO_IN_PROGRESS) && !getFlag(LOADING))\\n\\t\\t\\t{\\n\\t\\t\\t\\tundoMgr.contentRemoved(offset,length,\\n\\t\\t\\t\\t\\tgetText(offset,length),\\n\\t\\t\\t\\t\\t!getFlag(DIRTY));\\n\\t\\t\\t}\\n\\t\\t\\tfirePreContentRemoved(startLine,offset,numLines,length);\\n\\t\\t\\tcontentMgr.remove(offset,length);\\n\\t\\t\\tlineMgr.contentRemoved(startLine,offset,numLines,length);\\n\\t\\t\\tpositionMgr.contentRemoved(offset,length);\\n\\t\\t\\tfireContentRemoved(startLine,offset,numLines,length);\\n\\t\\t\\tsetDirty(true);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void undo(JEditTextArea textArea)\\n\\t{\\n\\t\\tif(undoMgr == null)\\n\\t\\t\\treturn;\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\ttextArea.getToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tsetFlag(UNDO_IN_PROGRESS,true);\\n\\t\\t\\tint caret = undoMgr.undo();\\n\\t\\t\\tif(caret == -1)\\n\\t\\t\\t\\ttextArea.getToolkit().beep();\\n\\t\\t\\telse\\n\\t\\t\\t\\ttextArea.setCaretPosition(caret);\\n\\t\\t\\tfireTransactionComplete();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tsetFlag(UNDO_IN_PROGRESS,false);\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void redo(JEditTextArea textArea)\\n\\t{\\n\\t\\tif(undoMgr == null)\\n\\t\\t\\treturn;\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tToolkit.getDefaultToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tsetFlag(UNDO_IN_PROGRESS,true);\\n\\t\\t\\tint caret = undoMgr.redo();\\n\\t\\t\\tif(caret == -1)\\n\\t\\t\\t\\ttextArea.getToolkit().beep();\\n\\t\\t\\telse\\n\\t\\t\\t\\ttextArea.setCaretPosition(caret);\\n\\t\\t\\tfireTransactionComplete();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tsetFlag(UNDO_IN_PROGRESS,false);\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic boolean isTransactionInProgress()\\n\\t{\\n\\t\\treturn getFlag(UNDO_IN_PROGRESS) || insideCompoundEdit();\\n\\t} \\n\\tpublic void beginCompoundEdit()\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tundoMgr.beginCompoundEdit();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void endCompoundEdit()\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tundoMgr.endCompoundEdit();\\n\\t\\t\\tif(!insideCompoundEdit())\\n\\t\\t\\t\\tfireTransactionComplete();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t}\\n\\tpublic boolean insideCompoundEdit()\\n\\t{\\n\\t\\treturn undoMgr.insideCompoundEdit();\\n\\t} \\n\\t\\tpublic static final int NORMAL_PRIORITY = 0;\\n\\tpublic static final int HIGH_PRIORITY = 1;\\n\\tstatic class Listener\\n\\t{\\n\\t\\tBufferChangeListener listener;\\n\\t\\tint priority;\\n\\t\\tListener(BufferChangeListener listener, int priority)\\n\\t\\t{\\n\\t\\t\\tthis.listener = listener;\\n\\t\\t\\tthis.priority = priority;\\n\\t\\t}\\n\\t}\\n\\tpublic void addBufferChangeListener(BufferChangeListener listener,\\n\\t\\tint priority)\\n\\t{\\n\\t\\tListener l = new Listener(listener,priority);\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\tListener _l = (Listener)bufferListeners.get(i);\\n\\t\\t\\tif(_l.priority < priority)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbufferListeners.insertElementAt(l,i);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbufferListeners.addElement(l);\\n\\t} \\n\\tpublic void addBufferChangeListener(BufferChangeListener listener)\\n\\t{\\n\\t\\taddBufferChangeListener(listener,NORMAL_PRIORITY);\\n\\t} \\n\\tpublic void removeBufferChangeListener(BufferChangeListener listener)\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\tif(((Listener)bufferListeners.get(i)).listener == listener)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbufferListeners.removeElementAt(i);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic BufferChangeListener[] getBufferChangeListeners()\\n\\t{\\n\\t\\tBufferChangeListener[] returnValue\\n\\t\\t\\t= new BufferChangeListener[\\n\\t\\t\\tbufferListeners.size()];\\n\\t\\tfor(int i = 0; i < returnValue.length; i++)\\n\\t\\t{\\n\\t\\t\\treturnValue[i] = ((Listener)bufferListeners.get(i))\\n\\t\\t\\t\\t.listener;\\n\\t\\t}\\n\\t\\treturn returnValue;\\n\\t} \\n\\tpublic void propertiesChanged()\\n\\t{\\n\\t\\tString folding = getStringProperty(\\\"folding\\\");\\n\\t\\tFoldHandler handler = FoldHandler.getFoldHandler(folding);\\n\\t\\tif(handler != null)\\n\\t\\t{\\n\\t\\t\\tsetFoldHandler(handler);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif (folding != null)\\n\\t\\t\\t\\tLog.log(Log.WARNING, this, path + \\\": invalid 'folding' property: \\\" + folding); \\n\\t\\t\\tsetFoldHandler(new DummyFoldHandler());\\n\\t\\t}\\n\\t\\tEditBus.send(new BufferUpdate(this,null,BufferUpdate.PROPERTIES_CHANGED));\\n\\t\\tString newWrap = getStringProperty(\\\"wrap\\\");\\n\\t\\tif(wrap != null && !newWrap.equals(wrap))\\n\\t\\t{\\n\\t\\t\\tlineMgr.invalidateScreenLineCounts();\\n\\t\\t\\tif(isLoaded())\\n\\t\\t\\t\\tfireWrapModeChanged();\\n\\t\\t}\\n\\t\\tthis.wrap = newWrap;\\n\\t} \\n\\tpublic int getTabSize()\\n\\t{\\n\\t\\treturn getIntegerProperty(\\\"tabSize\\\",8);\\n\\t} \\n\\tpublic int getIndentSize()\\n\\t{\\n\\t\\treturn getIntegerProperty(\\\"indentSize\\\",8);\\n\\t} \\n\\tpublic Object getProperty(Object name)\\n\\t{\\n\\t\\tsynchronized(propertyLock)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tPropValue o = (PropValue)properties.get(name);\\n\\t\\t\\tif(o != null)\\n\\t\\t\\t\\treturn o.value;\\n\\t\\t\\t\\t\\t\\tif(!(name instanceof String))\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t\\t\\t\\tif(mode != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tObject retVal = mode.getProperty((String)name);\\n\\t\\t\\t\\tif(retVal == null)\\n\\t\\t\\t\\t\\treturn null;\\n\\t\\t\\t\\tproperties.put(name,new PropValue(retVal,true));\\n\\t\\t\\t\\treturn retVal;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tString value = jEdit.getProperty(\\\"buffer.\\\" + name);\\n\\t\\t\\t\\tif(value == null)\\n\\t\\t\\t\\t\\treturn null;\\n\\t\\t\\t\\t\\t\\t\\t\\tObject retVal;\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tretVal = new Integer(value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(NumberFormatException nf)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tretVal = value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tproperties.put(name,new PropValue(retVal,true));\\n\\t\\t\\t\\treturn retVal;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic void setProperty(String name, Object value)\\n\\t{\\n\\t\\tif(value == null)\\n\\t\\t\\tproperties.remove(name);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tPropValue test = (PropValue)properties.get(name);\\n\\t\\t\\tif(test == null)\\n\\t\\t\\t\\tproperties.put(name,new PropValue(value,false));\\n\\t\\t\\telse if(test.value.equals(value))\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\ttest.value = value;\\n\\t\\t\\t\\ttest.defaultValue = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic void unsetProperty(String name)\\n\\t{\\n\\t\\tproperties.remove(name);\\n\\t} \\n\\tpublic String getStringProperty(String name)\\n\\t{\\n\\t\\tObject obj = getProperty(name);\\n\\t\\tif(obj != null)\\n\\t\\t\\treturn obj.toString();\\n\\t\\telse\\n\\t\\t\\treturn null;\\n\\t} \\n\\tpublic void setStringProperty(String name, String value)\\n\\t{\\n\\t\\tsetProperty(name,value);\\n\\t} \\n\\tpublic boolean getBooleanProperty(String name)\\n\\t{\\n\\t\\tObject obj = getProperty(name);\\n\\t\\tif(obj instanceof Boolean)\\n\\t\\t\\treturn ((Boolean)obj).booleanValue();\\n\\t\\telse if(\\\"true\\\".equals(obj) || \\\"on\\\".equals(obj) || \\\"yes\\\".equals(obj))\\n\\t\\t\\treturn true;\\n\\t\\telse\\n\\t\\t\\treturn false;\\n\\t} \\n\\tpublic void setBooleanProperty(String name, boolean value)\\n\\t{\\n\\t\\tsetProperty(name,value ? Boolean.TRUE : Boolean.FALSE);\\n\\t} \\n\\tpublic int getIntegerProperty(String name, int defaultValue)\\n\\t{\\n\\t\\tboolean defaultValueFlag;\\n\\t\\tObject obj;\\n\\t\\tPropValue value = (PropValue)properties.get(name);\\n\\t\\tif(value != null)\\n\\t\\t{\\n\\t\\t\\tobj = value.value;\\n\\t\\t\\tdefaultValueFlag = value.defaultValue;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tobj = getProperty(name);\\n\\t\\t\\t\\t\\t\\tdefaultValueFlag = true;\\n\\t\\t}\\n\\t\\tif(obj == null)\\n\\t\\t\\treturn defaultValue;\\n\\t\\telse if(obj instanceof Number)\\n\\t\\t\\treturn ((Number)obj).intValue();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tint returnValue = Integer.parseInt(\\n\\t\\t\\t\\t\\tobj.toString().trim());\\n\\t\\t\\t\\tproperties.put(name,new PropValue(\\n\\t\\t\\t\\t\\tnew Integer(returnValue),\\n\\t\\t\\t\\t\\tdefaultValueFlag));\\n\\t\\t\\t\\treturn returnValue;\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Exception e)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn defaultValue;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic void setIntegerProperty(String name, int value)\\n\\t{\\n\\t\\tsetProperty(name,new Integer(value));\\n\\t} \\n\\tpublic RE getRegexpProperty(String name, int cflags,\\n\\t\\tRESyntax syntax) throws REException\\n\\t{\\n\\t\\tsynchronized(propertyLock)\\n\\t\\t{\\n\\t\\t\\tboolean defaultValueFlag;\\n\\t\\t\\tObject obj;\\n\\t\\t\\tPropValue value = (PropValue)properties.get(name);\\n\\t\\t\\tif(value != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tobj = value.value;\\n\\t\\t\\t\\tdefaultValueFlag = value.defaultValue;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tobj = getProperty(name);\\n\\t\\t\\t\\t\\t\\t\\t\\tdefaultValueFlag = true;\\n\\t\\t\\t}\\n\\t\\t\\tif(obj == null)\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\telse if(obj instanceof RE)\\n\\t\\t\\t\\treturn (RE)obj;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tRE re = new RE(obj.toString(),cflags,syntax);\\n\\t\\t\\t\\tproperties.put(name,new PropValue(re,\\n\\t\\t\\t\\t\\tdefaultValueFlag));\\n\\t\\t\\t\\treturn re;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic ParserRuleSet getRuleSetAtOffset(int offset)\\n\\t{\\n\\t\\tint line = getLineOfOffset(offset);\\n\\t\\toffset -= getLineStartOffset(line);\\n\\t\\tif(offset != 0)\\n\\t\\t\\toffset--;\\n\\t\\tDefaultTokenHandler tokens = new DefaultTokenHandler();\\n\\t\\tmarkTokens(line,tokens);\\n\\t\\tToken token = TextUtilities.getTokenAtOffset(tokens.getTokens(),offset);\\n\\t\\treturn token.rules;\\n\\t} \\n\\tpublic KeywordMap getKeywordMapAtOffset(int offset)\\n\\t{\\n\\t\\treturn getRuleSetAtOffset(offset).getKeywords();\\n\\t} \\n\\tpublic String getContextSensitiveProperty(int offset, String name)\\n\\t{\\n\\t\\tParserRuleSet rules = getRuleSetAtOffset(offset);\\n\\t\\tObject value = null;\\n\\t\\tHashtable rulesetProps = rules.getProperties();\\n\\t\\tif(rulesetProps != null)\\n\\t\\t\\tvalue = rulesetProps.get(name);\\n\\t\\tif(value == null)\\n\\t\\t{\\n\\t\\t\\tvalue = jEdit.getMode(rules.getModeName())\\n\\t\\t\\t\\t.getProperty(name);\\n\\t\\t\\tif(value == null)\\n\\t\\t\\t\\tvalue = mode.getProperty(name);\\n\\t\\t}\\n\\t\\tif(value == null)\\n\\t\\t\\treturn null;\\n\\t\\telse\\n\\t\\t\\treturn String.valueOf(value);\\n\\t} \\n\\t\\tstatic class PropValue\\n\\t{\\n\\t\\tPropValue(Object value, boolean defaultValue)\\n\\t\\t{\\n\\t\\t\\tif(value == null)\\n\\t\\t\\t\\tthrow new NullPointerException();\\n\\t\\t\\tthis.value = value;\\n\\t\\t\\tthis.defaultValue = defaultValue;\\n\\t\\t}\\n\\t\\tObject value;\\n\\t\\tboolean defaultValue;\\n\\t\\tpublic String toString()\\n\\t\\t{\\n\\t\\t\\treturn value.toString();\\n\\t\\t}\\n\\t} \\n\\tpublic void toggleWordWrap(View view)\\n\\t{\\n\\t\\tString wrap = getStringProperty(\\\"wrap\\\");\\n\\t\\tif(wrap.equals(\\\"none\\\"))\\n\\t\\t\\twrap = \\\"soft\\\";\\n\\t\\telse if(wrap.equals(\\\"soft\\\"))\\n\\t\\t\\twrap = \\\"hard\\\";\\n\\t\\telse if(wrap.equals(\\\"hard\\\"))\\n\\t\\t\\twrap = \\\"none\\\";\\n\\t\\tview.getStatus().setMessageAndClear(jEdit.getProperty(\\n\\t\\t\\t\\\"view.status.wrap-changed\\\",new String[] {\\n\\t\\t\\twrap }));\\n\\t\\tsetProperty(\\\"wrap\\\",wrap);\\n\\t\\tpropertiesChanged();\\n\\t} \\n\\tpublic void toggleLineSeparator(View view)\\n\\t{\\n\\t\\tString status = null;\\n\\t\\tString lineSep = getStringProperty(\\\"lineSeparator\\\");\\n\\t\\tif(\\\"\\\\n\\\".equals(lineSep))\\n\\t\\t{\\n\\t\\t\\tstatus = \\\"windows\\\";\\n\\t\\t\\tlineSep = \\\"\\\\r\\\\n\\\";\\n\\t\\t}\\n\\t\\telse if(\\\"\\\\r\\\\n\\\".equals(lineSep))\\n\\t\\t{\\n\\t\\t\\tstatus = \\\"mac\\\";\\n\\t\\t\\tlineSep = \\\"\\\\r\\\";\\n\\t\\t}\\n\\t\\telse if(\\\"\\\\r\\\".equals(lineSep))\\n\\t\\t{\\n\\t\\t\\tstatus = \\\"unix\\\";\\n\\t\\t\\tlineSep = \\\"\\\\n\\\";\\n\\t\\t}\\n\\t\\tview.getStatus().setMessageAndClear(jEdit.getProperty(\\n\\t\\t\\t\\\"view.status.linesep-changed\\\",new String[] {\\n\\t\\t\\tjEdit.getProperty(\\\"lineSep.\\\" + status) }));\\n\\t\\tsetProperty(\\\"lineSeparator\\\",lineSep);\\n\\t\\tsetDirty(true);\\n\\t\\tpropertiesChanged();\\n\\t} \\n\\tpublic Mode getMode()\\n\\t{\\n\\t\\treturn mode;\\n\\t} \\n\\tpublic void setMode(String mode)\\n\\t{\\n\\t\\tsetMode(jEdit.getMode(mode));\\n\\t} \\n\\tpublic void setMode(Mode mode)\\n\\t{\\n\\t\\tif(mode == null)\\n\\t\\t\\tthrow new NullPointerException(\\\"Mode must be non-null\\\");\\n\\t\\tthis.mode = mode;\\n\\t\\ttextMode = \\\"text\\\".equals(mode.getName());\\n\\t\\tsetTokenMarker(mode.getTokenMarker());\\n\\t\\tresetCachedProperties();\\n\\t\\tpropertiesChanged();\\n\\t} \\n\\tpublic void setMode()\\n\\t{\\n\\t\\tString userMode = getStringProperty(\\\"mode\\\");\\n\\t\\tif(userMode != null)\\n\\t\\t{\\n\\t\\t\\tMode m = jEdit.getMode(userMode);\\n\\t\\t\\tif(m != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetMode(m);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tString nogzName = name.substring(0,name.length() -\\n\\t\\t\\t(name.endsWith(\\\".gz\\\") ? 3 : 0));\\n\\t\\tMode[] modes = jEdit.getModes();\\n\\t\\tString firstLine = getLineText(0);\\n\\t\\tfor(int i = 0; i < modes.length; i++)\\n\\t\\t{\\n\\t\\t\\tif(modes[i].accept(nogzName,firstLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetMode(modes[i]);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tMode defaultMode = jEdit.getMode(jEdit.getProperty(\\\"buffer.defaultMode\\\"));\\n\\t\\tif(defaultMode == null)\\n\\t\\t\\tdefaultMode = jEdit.getMode(\\\"text\\\");\\n\\t\\tsetMode(defaultMode);\\n\\t} \\n\\tpublic void markTokens(int lineIndex, TokenHandler tokenHandler)\\n\\t{\\n\\t\\tSegment seg;\\n\\t\\tif(SwingUtilities.isEventDispatchThread())\\n\\t\\t\\tseg = this.seg;\\n\\t\\telse\\n\\t\\t\\tseg = new Segment();\\n\\t\\tif(lineIndex < 0 || lineIndex >= lineMgr.getLineCount())\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(lineIndex);\\n\\t\\tint firstInvalidLineContext = lineMgr.getFirstInvalidLineContext();\\n\\t\\tint start;\\n\\t\\tif(textMode || firstInvalidLineContext == -1)\\n\\t\\t{\\n\\t\\t\\tstart = lineIndex;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstart = Math.min(firstInvalidLineContext,\\n\\t\\t\\t\\tlineIndex);\\n\\t\\t}\\n\\t\\tif(Debug.TOKEN_MARKER_DEBUG)\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"tokenize from \\\" + start + \\\" to \\\" + lineIndex);\\n\\t\\tfor(int i = start; i <= lineIndex; i++)\\n\\t\\t{\\n\\t\\t\\tgetLineText(i,seg);\\n\\t\\t\\tTokenMarker.LineContext context = lineMgr.getLineContext(i);\\n\\t\\t\\tParserRule oldRule;\\n\\t\\t\\tParserRuleSet oldRules;\\n\\t\\t\\tchar[] oldSpanEndSubst;\\n\\t\\t\\tif(context == null)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\toldRule = null;\\n\\t\\t\\t\\toldRules = null;\\n\\t\\t\\t\\toldSpanEndSubst = null;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\toldRule = context.inRule;\\n\\t\\t\\t\\toldRules = context.rules;\\n\\t\\t\\t\\toldSpanEndSubst = (context.parent != null\\n\\t\\t\\t\\t\\t? context.parent.spanEndSubst\\n\\t\\t\\t\\t\\t: null);\\n\\t\\t\\t}\\n\\t\\t\\tTokenMarker.LineContext prevContext = (\\n\\t\\t\\t\\t(i == 0 || textMode) ? null\\n\\t\\t\\t\\t: lineMgr.getLineContext(i - 1)\\n\\t\\t\\t);\\n\\t\\t\\tcontext = tokenMarker.markTokens(prevContext,\\n\\t\\t\\t\\t(i == lineIndex ? tokenHandler\\n\\t\\t\\t\\t: DummyTokenHandler.INSTANCE),seg);\\n\\t\\t\\tlineMgr.setLineContext(i,context);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(oldRule != context.inRule)\\n\\t\\t\\t{\\n\\t\\t\\t\\tnextLineRequested = true;\\n\\t\\t\\t}\\n\\t\\t\\telse if(oldRules != context.rules)\\n\\t\\t\\t{\\n\\t\\t\\t\\tnextLineRequested = true;\\n\\t\\t\\t}\\n\\t\\t\\telse if(!MiscUtilities.objectsEqual(oldSpanEndSubst,\\n\\t\\t\\t\\tcontext.spanEndSubst))\\n\\t\\t\\t{\\n\\t\\t\\t\\tnextLineRequested = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint lineCount = lineMgr.getLineCount();\\n\\t\\tif(lineCount - 1 == lineIndex)\\n\\t\\t\\tlineMgr.setFirstInvalidLineContext(-1);\\n\\t\\telse if(nextLineRequested)\\n\\t\\t\\tlineMgr.setFirstInvalidLineContext(lineIndex + 1);\\n\\t\\telse if(firstInvalidLineContext == -1)\\n\\t\\t\\t;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlineMgr.setFirstInvalidLineContext(Math.max(\\n\\t\\t\\t\\tfirstInvalidLineContext,lineIndex + 1));\\n\\t\\t}\\n\\t} \\n\\tpublic boolean isNextLineRequested()\\n\\t{\\n\\t\\tboolean retVal = nextLineRequested;\\n\\t\\tnextLineRequested = false;\\n\\t\\treturn retVal;\\n\\t} \\n\\tpublic void removeTrailingWhiteSpace(int[] lines)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbeginCompoundEdit();\\n\\t\\t\\tfor(int i = 0; i < lines.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint pos, lineStart, lineEnd, tail;\\n\\t\\t\\t\\tgetLineText(lines[i],seg);\\n\\t\\t\\t\\t\\t\\t\\t\\tif (seg.count == 0) continue;\\n\\t\\t\\t\\tlineStart = seg.offset;\\n\\t\\t\\t\\tlineEnd = seg.offset + seg.count - 1;\\n\\t\\t\\t\\tfor (pos = lineEnd; pos >= lineStart; pos--)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (!Character.isWhitespace(seg.array[pos]))\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttail = lineEnd - pos;\\n\\t\\t\\t\\t\\t\\t\\t\\tif (tail == 0) continue;\\n\\t\\t\\t\\tremove(getLineEndOffset(lines[i]) - 1 - tail,tail);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tendCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void shiftIndentLeft(int[] lines)\\n\\t{\\n\\t\\tint tabSize = getTabSize();\\n\\t\\tint indentSize = getIndentSize();\\n\\t\\tboolean noTabs = getBooleanProperty(\\\"noTabs\\\");\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbeginCompoundEdit();\\n\\t\\t\\tfor(int i = 0; i < lines.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint lineStart = getLineStartOffset(lines[i]);\\n\\t\\t\\t\\tString line = getLineText(lines[i]);\\n\\t\\t\\t\\tint whiteSpace = MiscUtilities\\n\\t\\t\\t\\t\\t.getLeadingWhiteSpace(line);\\n\\t\\t\\t\\tif(whiteSpace == 0)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tint whiteSpaceWidth = Math.max(0,MiscUtilities\\n\\t\\t\\t\\t\\t.getLeadingWhiteSpaceWidth(line,tabSize)\\n\\t\\t\\t\\t\\t- indentSize);\\n\\t\\t\\t\\tinsert(lineStart + whiteSpace,MiscUtilities\\n\\t\\t\\t\\t\\t.createWhiteSpace(whiteSpaceWidth,\\n\\t\\t\\t\\t\\t(noTabs ? 0 : tabSize)));\\n\\t\\t\\t\\tremove(lineStart,whiteSpace);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tendCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void shiftIndentRight(int[] lines)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbeginCompoundEdit();\\n\\t\\t\\tint tabSize = getTabSize();\\n\\t\\t\\tint indentSize = getIndentSize();\\n\\t\\t\\tboolean noTabs = getBooleanProperty(\\\"noTabs\\\");\\n\\t\\t\\tfor(int i = 0; i < lines.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint lineStart = getLineStartOffset(lines[i]);\\n\\t\\t\\t\\tString line = getLineText(lines[i]);\\n\\t\\t\\t\\tint whiteSpace = MiscUtilities\\n\\t\\t\\t\\t\\t.getLeadingWhiteSpace(line);\\n\\t\\t\\t\\tint whiteSpaceWidth = MiscUtilities\\n\\t\\t\\t\\t\\t.getLeadingWhiteSpaceWidth(\\n\\t\\t\\t\\t\\tline,tabSize) + indentSize;\\n\\t\\t\\t\\tinsert(lineStart + whiteSpace,MiscUtilities\\n\\t\\t\\t\\t\\t.createWhiteSpace(whiteSpaceWidth,\\n\\t\\t\\t\\t\\t(noTabs ? 0 : tabSize)));\\n\\t\\t\\t\\tremove(lineStart,whiteSpace);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tendCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void indentLines(int start, int end)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbeginCompoundEdit();\\n\\t\\t\\tfor(int i = start; i <= end; i++)\\n\\t\\t\\t\\tindentLine(i,true);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tendCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void indentLines(int[] lines)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbeginCompoundEdit();\\n\\t\\t\\tfor(int i = 0; i < lines.length; i++)\\n\\t\\t\\t\\tindentLine(lines[i],true);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tendCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic boolean indentLine(int lineIndex, boolean canIncreaseIndent,\\n\\t\\tboolean canDecreaseIndent)\\n\\t{\\n\\t\\treturn indentLine(lineIndex,canDecreaseIndent);\\n\\t} \\n\\tpublic boolean indentLine(int lineIndex, boolean canDecreaseIndent)\\n\\t{\\n\\t\\tint[] whitespaceChars = new int[1];\\n\\t\\tint currentIndent = getCurrentIdentForLine(lineIndex,\\n\\t\\t\\twhitespaceChars);\\n\\t\\tint idealIndent = getIdealIndentForLine(lineIndex);\\n\\t\\tif(idealIndent == -1 || idealIndent == currentIndent\\n\\t\\t\\t|| (!canDecreaseIndent && idealIndent < currentIndent))\\n\\t\\t\\treturn false;\\n\\t\\t\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbeginCompoundEdit();\\n\\t\\t\\tint start = getLineStartOffset(lineIndex);\\n\\t\\t\\tremove(start,whitespaceChars[0]);\\n\\t\\t\\tinsert(start,MiscUtilities.createWhiteSpace(\\n\\t\\t\\t\\tidealIndent,(getBooleanProperty(\\\"noTabs\\\")\\n\\t\\t\\t\\t? 0 : getTabSize())));\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tendCompoundEdit();\\n\\t\\t}\\n\\t\\treturn true;\\n\\t} \\n\\tpublic int getCurrentIdentForLine(int lineIndex, int[] whitespaceChars)\\n\\t{\\n\\t\\tgetLineText(lineIndex,seg);\\n\\t\\tint tabSize = getTabSize();\\n\\t\\tint currentIndent = 0;\\nloop:\\t\\tfor(int i = 0; i < seg.count; i++)\\n\\t\\t{\\n\\t\\t\\tchar c = seg.array[seg.offset + i];\\n\\t\\t\\tswitch(c)\\n\\t\\t\\t{\\n\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcurrentIndent++;\\n\\t\\t\\t\\twhitespaceChars[0]++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\tcurrentIndent += (tabSize - (currentIndent\\n\\t\\t\\t\\t\\t% tabSize));\\n\\t\\t\\t\\twhitespaceChars[0]++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn currentIndent;\\n\\t} \\n\\tpublic int getIdealIndentForLine(int lineIndex)\\n\\t{\\n\\t\\tfinal String EXPLICIT_START = \\\"{{{\\\";\\n\\t\\tfinal String EXPLICIT_END = \\\"}}}\\\";\\n\\t\\tif(lineIndex == 0)\\n\\t\\t\\treturn -1;\\n\\t\\t\\t\\tString openBrackets = getStringProperty(\\\"indentOpenBrackets\\\");\\n\\t\\tif(openBrackets == null)\\n\\t\\t\\topenBrackets = \\\"\\\";\\n\\t\\tString closeBrackets = getStringProperty(\\\"indentCloseBrackets\\\");\\n\\t\\tif(closeBrackets == null)\\n\\t\\t\\tcloseBrackets = \\\"\\\";\\n\\t\\tRE indentNextLineRE;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tindentNextLineRE = getRegexpProperty(\\\"indentNextLine\\\",\\n\\t\\t\\t\\tRE.REG_ICASE,RESearchMatcher.RE_SYNTAX_JEDIT);\\n\\t\\t}\\n\\t\\tcatch(REException re)\\n\\t\\t{\\n\\t\\t\\tindentNextLineRE = null;\\n\\t\\t\\tLog.log(Log.ERROR,this,\\\"Invalid indentNextLine regexp\\\");\\n\\t\\t\\tLog.log(Log.ERROR,this,re);\\n\\t\\t}\\n\\t\\tRE indentNextLinesRE;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tindentNextLinesRE = getRegexpProperty(\\\"indentNextLines\\\",\\n\\t\\t\\t\\tRE.REG_ICASE,RESearchMatcher.RE_SYNTAX_JEDIT);\\n\\t\\t}\\n\\t\\tcatch(REException re)\\n\\t\\t{\\n\\t\\t\\tindentNextLinesRE = null;\\n\\t\\t\\tLog.log(Log.ERROR,this,\\\"Invalid indentNextLines regexp\\\");\\n\\t\\t\\tLog.log(Log.ERROR,this,re);\\n\\t\\t}\\n\\t\\tboolean doubleBracketIndent = getBooleanProperty(\\\"doubleBracketIndent\\\");\\n\\t\\tboolean lineUpClosingBracket = getBooleanProperty(\\\"lineUpClosingBracket\\\");\\n\\t\\tint tabSize = getTabSize();\\n\\t\\tint indentSize = getIndentSize();\\n\\t\\t\\t\\tint prevLineIndex = getPriorNonEmptyLine(lineIndex);\\n\\t\\tif(prevLineIndex == -1)\\n\\t\\t\\treturn -1;\\n\\t\\tString prevLine = getLineText(prevLineIndex);\\n\\t\\tboolean prevLineStart = true; \\t\\tint indent = 0; \\t\\tint prevLineBrackets = 0; \\t\\tint prevLineCloseBracketIndex = -1; \\t\\t                                    \\t\\t                                    \\t\\t                                    \\t\\t                                    \\t\\t                                    \\t\\t                                    \\t\\t                                    \\t\\tint prevLineUnclosedParenIndex = -1; \\t\\tStack openParens = new Stack();\\n\\t\\tfor(int i = 0; i < prevLine.length(); i++)\\n\\t\\t{\\n\\t\\t\\tchar c = prevLine.charAt(i);\\n\\t\\t\\tswitch(c)\\n\\t\\t\\t{\\n\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tif(prevLineStart)\\n\\t\\t\\t\\t\\tindent++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\tif(prevLineStart)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tindent += (tabSize\\n\\t\\t\\t\\t\\t\\t- (indent\\n\\t\\t\\t\\t\\t\\t% tabSize));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase '(':\\n\\t\\t\\t\\topenParens.push(new Integer(i));\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase ')':\\n\\t\\t\\t\\tif(openParens.size() > 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\topenParens.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tprevLineStart = false;\\n\\t\\t\\t\\tif(closeBrackets.indexOf(c) != -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(prevLine.regionMatches(false,\\n\\t\\t\\t\\t\\t\\ti,EXPLICIT_END,0,3))\\n\\t\\t\\t\\t\\t\\ti += 2;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tprevLineBrackets--;\\n\\t\\t\\t\\t\\t\\tif(prevLineBrackets < 0)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(lineUpClosingBracket)\\n\\t\\t\\t\\t\\t\\t\\t\\tprevLineBrackets = 0;\\n\\t\\t\\t\\t\\t\\t\\tprevLineCloseBracketIndex = i;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(openBrackets.indexOf(c) != -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(prevLine.regionMatches(false,\\n\\t\\t\\t\\t\\t\\ti,EXPLICIT_START,0,3))\\n\\t\\t\\t\\t\\t\\ti += 2;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tprevLineBrackets++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(openParens.size() > 0)\\n\\t\\t{\\n\\t\\t\\tprevLineUnclosedParenIndex = ((Integer) openParens.pop()).intValue();\\n\\t\\t} \\n\\t\\t\\t\\tString line = getLineText(lineIndex);\\n\\t\\tint lineBrackets = 0; \\t\\tint closeBracketIndex = -1; \\t\\t\\t\\t\\tfor(int i = 0; i < line.length(); i++)\\n\\t\\t{\\n\\t\\t\\tchar c = line.charAt(i);\\n\\t\\t\\tif(closeBrackets.indexOf(c) != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(line.regionMatches(false,\\n\\t\\t\\t\\t\\ti,EXPLICIT_END,0,3))\\n\\t\\t\\t\\t\\ti += 2;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcloseBracketIndex = i;\\n\\t\\t\\t\\t\\tlineBrackets--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(openBrackets.indexOf(c) != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(line.regionMatches(false,\\n\\t\\t\\t\\t\\ti,EXPLICIT_START,0,3))\\n\\t\\t\\t\\t\\ti += 2;\\n\\t\\t\\t\\telse if(lineBrackets >= 0)\\n\\t\\t\\t\\t\\tlineBrackets++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(openParens.size() > 0)\\n\\t\\t{\\n\\t\\t\\tprevLineUnclosedParenIndex = ((Integer) openParens.pop()).intValue();\\n\\t\\t} \\n\\t\\t\\t\\tif(getBooleanProperty(\\\"deepIndent\\\"))\\n\\t\\t{\\n\\t\\t\\tif(prevLineUnclosedParenIndex != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tindent = prevLineUnclosedParenIndex;\\n\\t\\t\\t\\tfor(int i = 0; i < prevLine.length(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(prevLine.charAt(i) == '\\\\t')\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tindent += tabSize-1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tindent++;\\n\\t\\t\\t\\treturn indent;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tif(prevLineBrackets > 0)\\n\\t\\t\\tindent += (indentSize * prevLineBrackets);\\n\\t\\tif(lineUpClosingBracket)\\n\\t\\t{\\n\\t\\t\\tif(lineBrackets < 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint offset = TextUtilities.findMatchingBracket(\\n\\t\\t\\t\\t\\tthis,lineIndex,closeBracketIndex);\\n\\t\\t\\t\\tif(offset != -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tString closeLine = getLineText(getLineOfOffset(offset));\\n\\t\\t\\t\\t\\tindent = MiscUtilities.getLeadingWhiteSpaceWidth(\\n\\t\\t\\t\\t\\t\\tcloseLine,tabSize);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(prevLineBrackets < 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint offset = TextUtilities.findMatchingBracket(\\n\\t\\t\\t\\t\\tthis,prevLineIndex,prevLineCloseBracketIndex);\\n\\t\\t\\t\\tif(offset != -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tString closeLine = getLineText(getLineOfOffset(offset));\\n\\t\\t\\t\\t\\tindent = MiscUtilities.getLeadingWhiteSpaceWidth(\\n\\t\\t\\t\\t\\t\\tcloseLine,tabSize);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tif(lineBrackets >= 0)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif((lineBrackets == 0 || doubleBracketIndent)\\n\\t\\t\\t\\t&& indentNextLinesRE != null\\n\\t\\t\\t\\t&& indentNextLinesRE.isMatch(prevLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tindent += indentSize;\\n\\t\\t\\t}\\n\\t\\t\\telse if(indentNextLineRE != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((lineBrackets == 0 || doubleBracketIndent)\\n\\t\\t\\t\\t\\t&& indentNextLineRE.isMatch(prevLine))\\n\\t\\t\\t\\t\\tindent += indentSize;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\telse if(prevLineBrackets == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tint prevPrevLineIndex;\\n\\t\\t\\t\\t\\t\\tprevPrevLineIndex = getPriorNonEmptyLine(prevLineIndex);\\n\\t\\t\\t\\t\\twhile(prevPrevLineIndex != -1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(indentNextLineRE.isMatch(getLineText(prevPrevLineIndex)))\\n\\t\\t\\t\\t\\t\\t\\tindent -= indentSize;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tprevPrevLineIndex = getPriorNonEmptyLine(prevPrevLineIndex);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\treturn indent;\\n\\t} \\n\\tpublic int getVirtualWidth(int line, int column)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tint start = getLineStartOffset(line);\\n\\t\\t\\tgetText(start,column,seg);\\n\\t\\t\\treturn MiscUtilities.getVirtualWidth(seg,getTabSize());\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic int getOffsetOfVirtualColumn(int line, int column,\\n\\t\\tint[] totalVirtualWidth)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tgetLineText(line,seg);\\n\\t\\t\\treturn MiscUtilities.getOffsetOfVirtualColumn(seg,\\n\\t\\t\\t\\tgetTabSize(),column,totalVirtualWidth);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void insertAtColumn(int line, int col, String str)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\twriteLock();\\n\\t\\t\\tint[] total = new int[1];\\n\\t\\t\\tint offset = getOffsetOfVirtualColumn(line,col,total);\\n\\t\\t\\tif(offset == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\toffset = getLineEndOffset(line) - 1;\\n\\t\\t\\t\\tstr = MiscUtilities.createWhiteSpace(col - total[0],0) + str;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\toffset += getLineStartOffset(line);\\n\\t\\t\\tinsert(offset,str);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\twriteUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic void putProperty(Object name, Object value)\\n\\t{\\n\\t\\t\\t\\tif(!(name instanceof String))\\n\\t\\t\\treturn;\\n\\t\\tsetProperty((String)name,value);\\n\\t} \\n\\tpublic void putBooleanProperty(String name, boolean value)\\n\\t{\\n\\t\\tsetBooleanProperty(name,value);\\n\\t} \\n\\tpublic static class TokenList extends DefaultTokenHandler\\n\\t{\\n\\t\\tpublic Token getFirstToken()\\n\\t\\t{\\n\\t\\t\\treturn getTokens();\\n\\t\\t}\\n\\t}\\n\\tpublic TokenList markTokens(int lineIndex)\\n\\t{\\n\\t\\tTokenList list = new TokenList();\\n\\t\\tmarkTokens(lineIndex,list);\\n\\t\\treturn list;\\n\\t} \\n\\tpublic Element[] getRootElements()\\n\\t{\\n\\t\\treturn new Element[] { getDefaultRootElement() };\\n\\t} \\n\\tpublic Element getParagraphElement(int offset)\\n\\t{\\n\\t\\treturn new LineElement(this,getLineOfOffset(offset));\\n\\t} \\n\\tpublic Element getDefaultRootElement()\\n\\t{\\n\\t\\treturn new RootElement(this);\\n\\t} \\n\\tpublic void insertString(int offset, String str, AttributeSet attr)\\n\\t{\\n\\t\\tinsert(offset,str);\\n\\t} \\n\\tpublic File getFile()\\n\\t{\\n\\t\\treturn file;\\n\\t} \\n\\tpublic boolean isFoldStart(int line)\\n\\t{\\n\\t\\treturn (line != getLineCount() - 1\\n\\t\\t\\t&& getFoldLevel(line) < getFoldLevel(line + 1));\\n\\t} \\n\\tpublic void invalidateCachedFoldLevels()\\n\\t{\\n\\t\\tlineMgr.setFirstInvalidFoldLevel(0);\\n\\t\\tfireFoldLevelChanged(0,getLineCount());\\n\\t} \\n\\tpublic int getFoldLevel(int line)\\n\\t{\\n\\t\\tif(line < 0 || line >= lineMgr.getLineCount())\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(line);\\n\\t\\tif(foldHandler instanceof DummyFoldHandler)\\n\\t\\t\\treturn 0;\\n\\t\\tint firstInvalidFoldLevel = lineMgr.getFirstInvalidFoldLevel();\\n\\t\\tif(firstInvalidFoldLevel == -1 || line < firstInvalidFoldLevel)\\n\\t\\t{\\n\\t\\t\\treturn lineMgr.getFoldLevel(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(Debug.FOLD_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"Invalid fold levels from \\\" + firstInvalidFoldLevel + \\\" to \\\" + line);\\n\\t\\t\\tint newFoldLevel = 0;\\n\\t\\t\\tboolean changed = false;\\n\\t\\t\\tfor(int i = firstInvalidFoldLevel; i <= line; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tnewFoldLevel = foldHandler.getFoldLevel(this,i,seg);\\n\\t\\t\\t\\tif(newFoldLevel != lineMgr.getFoldLevel(i))\\n\\t\\t\\t\\t\\tchanged = true;\\n\\t\\t\\t\\tlineMgr.setFoldLevel(i,newFoldLevel);\\n\\t\\t\\t}\\n\\t\\t\\tif(line == lineMgr.getLineCount() - 1)\\n\\t\\t\\t\\tlineMgr.setFirstInvalidFoldLevel(-1);\\n\\t\\t\\telse\\n\\t\\t\\t\\tlineMgr.setFirstInvalidFoldLevel(line + 1);\\n\\t\\t\\tif(changed && !getFlag(INSIDE_INSERT))\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tfireFoldLevelChanged(firstInvalidFoldLevel,line);\\n\\t\\t\\t}\\n\\t\\t\\treturn newFoldLevel;\\n\\t\\t}\\n\\t} \\n\\tpublic int[] getFoldAtLine(int line)\\n\\t{\\n\\t\\tint start, end;\\n\\t\\tif(isFoldStart(line))\\n\\t\\t{\\n\\t\\t\\tstart = line;\\n\\t\\t\\tint foldLevel = getFoldLevel(line);\\n\\t\\t\\tline++;\\n\\t\\t\\twhile(getFoldLevel(line) > foldLevel)\\n\\t\\t\\t{\\n\\t\\t\\t\\tline++;\\n\\t\\t\\t\\tif(line == getLineCount())\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tend = line - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstart = line;\\n\\t\\t\\tint foldLevel = getFoldLevel(line);\\n\\t\\t\\twhile(getFoldLevel(start) >= foldLevel)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(start == 0)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tstart--;\\n\\t\\t\\t}\\n\\t\\t\\tend = line;\\n\\t\\t\\twhile(getFoldLevel(end) >= foldLevel)\\n\\t\\t\\t{\\n\\t\\t\\t\\tend++;\\n\\t\\t\\t\\tif(end == getLineCount())\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tend--;\\n\\t\\t}\\n\\t\\twhile(getLineLength(end) == 0 && end > start)\\n\\t\\t\\tend--;\\n\\t\\treturn new int[] { start, end };\\n\\t} \\n\\tpublic FoldHandler getFoldHandler()\\n\\t{\\n\\t\\treturn foldHandler;\\n\\t} \\n\\tpublic void setFoldHandler(FoldHandler foldHandler)\\n\\t{\\n\\t\\tFoldHandler oldFoldHandler = this.foldHandler;\\n\\t\\tif(foldHandler.equals(oldFoldHandler))\\n\\t\\t\\treturn;\\n\\t\\tthis.foldHandler = foldHandler;\\n\\t\\tlineMgr.setFirstInvalidFoldLevel(0);\\n\\t\\tfireFoldHandlerChanged();\\n\\t} \\n\\tpublic Position createPosition(int offset)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\treadLock();\\n\\t\\t\\tif(offset < 0 || offset > contentMgr.getLength())\\n\\t\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(offset);\\n\\t\\t\\treturn positionMgr.createPosition(offset);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\treadUnlock();\\n\\t\\t}\\n\\t} \\n\\tpublic Vector getMarkers()\\n\\t{\\n\\t\\treturn markers;\\n\\t} \\n\\tpublic String getMarkerStatusPrompt(String action)\\n\\t{\\n\\t\\treturn jEdit.getProperty(\\\"view.status.\\\" + action,\\n\\t\\t\\tnew String[] { getMarkerNameString() });\\n\\t} \\n\\tpublic String getMarkerNameString()\\n\\t{\\n\\t\\tStringBuffer buf = new StringBuffer();\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tif(marker.getShortcut() != '\\\\0')\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buf.length() != 0)\\n\\t\\t\\t\\t\\tbuf.append(' ');\\n\\t\\t\\t\\tbuf.append(marker.getShortcut());\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(buf.length() == 0)\\n\\t\\t\\treturn jEdit.getProperty(\\\"view.status.no-markers\\\");\\n\\t\\telse\\n\\t\\t\\treturn buf.toString();\\n\\t} \\n\\tpublic void addOrRemoveMarker(char shortcut, int pos)\\n\\t{\\n\\t\\tint line = getLineOfOffset(pos);\\n\\t\\tif(getMarkerAtLine(line) != null)\\n\\t\\t\\tremoveMarker(line);\\n\\t\\telse\\n\\t\\t\\taddMarker(shortcut,pos);\\n\\t} \\n\\tpublic void addMarker(char shortcut, int pos)\\n\\t{\\n\\t\\tif(jEdit.getBooleanProperty(\\\"persistentMarkers\\\"))\\n\\t\\t\\tsetDirty(true);\\n\\t\\tMarker markerN = new Marker(this,shortcut,pos);\\n\\t\\tboolean added = false;\\n\\t\\t\\t\\tif(!getFlag(LOADING))\\n\\t\\t{\\n\\t\\t\\tmarkerN.createPosition();\\n\\t\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\t\\tif(shortcut != '\\\\0' && marker.getShortcut() == shortcut)\\n\\t\\t\\t\\t\\tmarker.setShortcut('\\\\0');\\n\\t\\t\\t\\tif(marker.getPosition() == pos)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmarkers.removeElementAt(i);\\n\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\t\\tif(marker.getPosition() > pos)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmarkers.insertElementAt(markerN,i);\\n\\t\\t\\t\\t\\tadded = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(!added)\\n\\t\\t\\tmarkers.addElement(markerN);\\n\\t\\tif(!getFlag(LOADING) && !getFlag(TEMPORARY))\\n\\t\\t{\\n\\t\\t\\tEditBus.send(new BufferUpdate(this,null,\\n\\t\\t\\t\\tBufferUpdate.MARKERS_CHANGED));\\n\\t\\t}\\n\\t} \\n\\tpublic Marker getMarkerInRange(int start, int end)\\n\\t{\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tint pos = marker.getPosition();\\n\\t\\t\\tif(pos >= start && pos < end)\\n\\t\\t\\t\\treturn marker;\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic Marker getMarkerAtLine(int line)\\n\\t{\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tif(getLineOfOffset(marker.getPosition()) == line)\\n\\t\\t\\t\\treturn marker;\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic void removeMarker(int line)\\n\\t{\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tif(getLineOfOffset(marker.getPosition()) == line)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(jEdit.getBooleanProperty(\\\"persistentMarkers\\\"))\\n\\t\\t\\t\\t\\tsetDirty(true);\\n\\t\\t\\t\\tmarker.removePosition();\\n\\t\\t\\t\\tmarkers.removeElementAt(i);\\n\\t\\t\\t\\ti--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tEditBus.send(new BufferUpdate(this,null,\\n\\t\\t\\tBufferUpdate.MARKERS_CHANGED));\\n\\t} \\n\\tpublic void removeAllMarkers()\\n\\t{\\n\\t\\tif(jEdit.getBooleanProperty(\\\"persistentMarkers\\\"))\\n\\t\\t\\tsetDirty(true);\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t\\t((Marker)markers.elementAt(i)).removePosition();\\n\\t\\tmarkers.removeAllElements();\\n\\t\\tif(!getFlag(LOADING))\\n\\t\\t{\\n\\t\\t\\tEditBus.send(new BufferUpdate(this,null,\\n\\t\\t\\t\\tBufferUpdate.MARKERS_CHANGED));\\n\\t\\t}\\n\\t} \\n\\tpublic Marker getMarker(char shortcut)\\n\\t{\\n\\t\\tEnumeration enum = markers.elements();\\n\\t\\twhile(enum.hasMoreElements())\\n\\t\\t{\\n\\t\\t\\tMarker marker = (Marker)enum.nextElement();\\n\\t\\t\\tif(marker.getShortcut() == shortcut)\\n\\t\\t\\t\\treturn marker;\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic void setWaitSocket(Socket waitSocket)\\n\\t{\\n\\t\\tthis.waitSocket = waitSocket;\\n\\t} \\n\\tpublic Buffer getNext()\\n\\t{\\n\\t\\treturn next;\\n\\t} \\n\\tpublic Buffer getPrev()\\n\\t{\\n\\t\\treturn prev;\\n\\t} \\n\\tpublic int getIndex()\\n\\t{\\n\\t\\tint count = 0;\\n\\t\\tBuffer buffer = prev;\\n\\t\\tfor(;;)\\n\\t\\t{\\n\\t\\t\\tif(buffer == null)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcount++;\\n\\t\\t\\tbuffer = buffer.prev;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t} \\n\\tpublic String toString()\\n\\t{\\n\\t\\treturn name + \\\" (\\\" + directory + \\\")\\\";\\n\\t} \\n\\tpublic LineManager _getLineManager()\\n\\t{\\n\\t\\treturn lineMgr;\\n\\t} \\n\\t\\tBuffer prev;\\n\\tBuffer next;\\n\\t\\tBuffer(String path, boolean newFile, boolean temp, Hashtable props)\\n\\t{\\n\\t\\tlock = new ReadWriteLock();\\n\\t\\tpropertyLock = new Object();\\n\\t\\tcontentMgr = new ContentManager();\\n\\t\\tlineMgr = new LineManager();\\n\\t\\tpositionMgr = new PositionManager();\\n\\t\\tintegerArray = new IntegerArray();\\n\\t\\tundoMgr = new UndoManager(this);\\n\\t\\tbufferListeners = new Vector();\\n\\t\\tseg = new Segment();\\n\\t\\tmarkers = new Vector();\\n\\t\\tproperties = new HashMap();\\n\\t\\t\\t\\tEnumeration enum = props.keys();\\n\\t\\twhile(enum.hasMoreElements())\\n\\t\\t{\\n\\t\\t\\tObject key = enum.nextElement();\\n\\t\\t\\tObject value = props.get(key);\\n\\t\\t\\tproperties.put(key,new PropValue(value,false));\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tif(getProperty(ENCODING) == null)\\n\\t\\t\\tproperties.put(ENCODING,new PropValue(System.getProperty(\\\"file.encoding\\\"),false));\\n\\t\\tif(getProperty(LINESEP) == null)\\n\\t\\t\\tproperties.put(LINESEP,new PropValue(System.getProperty(\\\"line.separator\\\"),false));\\n\\t\\tsetFlag(TEMPORARY,temp);\\n\\t\\t\\t\\tsetPath(path);\\n\\t\\tsetFlag(UNTITLED,newFile);\\n\\t\\tsetFlag(NEW_FILE,newFile);\\n\\t} \\n\\t\\tvoid commitTemporary()\\n\\t{\\n\\t\\tsetFlag(TEMPORARY,false);\\n\\t\\tfinishLoading();\\n\\t} \\n\\t\\tvoid resetCachedProperties()\\n\\t{\\n\\t\\t\\t\\t\\t\\tIterator iter = properties.values().iterator();\\n\\t\\twhile(iter.hasNext())\\n\\t\\t{\\n\\t\\t\\tPropValue value = (PropValue)iter.next();\\n\\t\\t\\tif(value.defaultValue)\\n\\t\\t\\t\\titer.remove();\\n\\t\\t}\\n\\t} \\n\\t\\tvoid close()\\n\\t{\\n\\t\\tsetFlag(CLOSED,true);\\n\\t\\tif(autosaveFile != null)\\n\\t\\t\\tautosaveFile.delete();\\n\\t\\t\\t\\tif(waitSocket != null)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\twaitSocket.getOutputStream().write('\\\\0');\\n\\t\\t\\t\\twaitSocket.getOutputStream().flush();\\n\\t\\t\\t\\twaitSocket.getInputStream().close();\\n\\t\\t\\t\\twaitSocket.getOutputStream().close();\\n\\t\\t\\t\\twaitSocket.close();\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void setFlag(int flag, boolean value)\\n\\t{\\n\\t\\tif(value)\\n\\t\\t\\tflags |= (1 << flag);\\n\\t\\telse\\n\\t\\t\\tflags &= ~(1 << flag);\\n\\t} \\n\\t\\tprivate boolean getFlag(int flag)\\n\\t{\\n\\t\\tint mask = (1 << flag);\\n\\t\\treturn (flags & mask) == mask;\\n\\t} \\n\\t\\tprivate static final int CLOSED = 0;\\n\\tprivate static final int LOADING = 1;\\n\\tprivate static final int IO = 2;\\n\\tprivate static final int NEW_FILE = 3;\\n\\tprivate static final int UNTITLED = 4;\\n\\tprivate static final int AUTOSAVE_DIRTY = 5;\\n\\tprivate static final int DIRTY = 6;\\n\\tprivate static final int READ_ONLY = 7;\\n\\tprivate static final int READ_ONLY_OVERRIDE = 8;\\n\\tprivate static final int UNDO_IN_PROGRESS = 9;\\n\\tprivate static final int TEMPORARY = 10;\\n\\tprivate static final int INSIDE_INSERT = 11;\\n\\tprivate int flags;\\n\\t\\tprivate String path;\\n\\tprivate String symlinkPath;\\n\\tprivate String name;\\n\\tprivate String directory;\\n\\tprivate File file;\\n\\tprivate File autosaveFile;\\n\\tprivate long modTime;\\n\\tprivate Mode mode;\\n\\tprivate HashMap properties;\\n\\tprivate ReadWriteLock lock;\\n\\tprivate Object propertyLock;\\n\\tprivate ContentManager contentMgr;\\n\\tprivate LineManager lineMgr;\\n\\tprivate PositionManager positionMgr;\\n\\tprivate IntegerArray integerArray;\\n\\tprivate UndoManager undoMgr;\\n\\tprivate Vector bufferListeners;\\n\\tprivate Vector markers;\\n\\t\\tprivate boolean textMode;\\n\\tprivate TokenMarker tokenMarker;\\n\\tprivate Segment seg;\\n\\tprivate boolean nextLineRequested;\\n\\tprivate FoldHandler foldHandler;\\n\\tprivate String wrap;\\n\\tprivate Socket waitSocket;\\n\\t\\tprivate void setPath(String path)\\n\\t{\\n\\t\\tthis.path = path;\\n\\t\\tthis.symlinkPath = path;\\n\\t\\tVFS vfs = VFSManager.getVFSForPath(path);\\n\\t\\tif((vfs.getCapabilities() & VFS.WRITE_CAP) == 0)\\n\\t\\t\\tsetFlag(READ_ONLY,true);\\n\\t\\tthis.name = vfs.getFileName(path);\\n\\t\\tthis.directory = vfs.getParentOfPath(path);\\n\\t\\tif(vfs instanceof FileVFS)\\n\\t\\t{\\n\\t\\t\\tfile = new File(path);\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tsymlinkPath = file.getCanonicalPath();\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,io);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(autosaveFile != null)\\n\\t\\t\\t\\tautosaveFile.delete();\\n\\t\\t\\tautosaveFile = new File(file.getParent(),'#' + name + '#');\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfile = null;\\n\\t\\t\\tautosaveFile = null;\\n\\t\\t}\\n\\t} \\n\\t\\tprivate boolean recoverAutosave(final View view)\\n\\t{\\n\\t\\tif(!autosaveFile.canRead())\\n\\t\\t\\treturn false;\\n\\t\\t\\t\\tGUIUtilities.hideSplashScreen();\\n\\t\\tfinal Object[] args = { autosaveFile.getPath() };\\n\\t\\tint result = GUIUtilities.confirm(view,\\\"autosave-found\\\",args,\\n\\t\\t\\tJOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE);\\n\\t\\tif(result == JOptionPane.YES_OPTION)\\n\\t\\t{\\n\\t\\t\\tVFSManager.getFileVFS().load(view,this,autosaveFile.getPath());\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tVFSManager.runInAWTThread(new Runnable()\\n\\t\\t\\t{\\n\\t\\t\\t\\tpublic void run()\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tGUIUtilities.message(view,\\\"autosave-loaded\\\",args);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn false;\\n\\t} \\n\\t\\tprivate boolean checkFileForLoad(View view, VFS vfs, String path)\\n\\t{\\n\\t\\tif((vfs.getCapabilities() & VFS.LOW_LATENCY_CAP) != 0)\\n\\t\\t{\\n\\t\\t\\tObject session = vfs.createVFSSession(path,view);\\n\\t\\t\\tif(session == null)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tVFS.DirectoryEntry file = vfs._getDirectoryEntry(session,path,view);\\n\\t\\t\\t\\tif(file == null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsetNewFile(true);\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!file.canRead)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror.no-read\\\",null);\\n\\t\\t\\t\\t\\tsetNewFile(false);\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsetFlag(READ_ONLY,!file.canWrite);\\n\\t\\t\\t\\tif(file.type != VFS.DirectoryEntry.FILE)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tVFSManager.error(view,path,\\n\\t\\t\\t\\t\\t\\t\\\"ioerror.open-directory\\\",null);\\n\\t\\t\\t\\t\\tsetNewFile(false);\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror\\\",\\n\\t\\t\\t\\t\\tnew String[] { io.toString() });\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvfs._endVFSSession(session,view);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror\\\",\\n\\t\\t\\t\\t\\t\\tnew String[] { io.toString() });\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t} \\n\\t\\tprivate boolean checkFileForSave(View view, VFS vfs, String path)\\n\\t{\\n\\t\\tif((vfs.getCapabilities() & VFS.LOW_LATENCY_CAP) != 0)\\n\\t\\t{\\n\\t\\t\\tObject session = vfs.createVFSSession(path,view);\\n\\t\\t\\tif(session == null)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tVFS.DirectoryEntry file = vfs._getDirectoryEntry(session,path,view);\\n\\t\\t\\t\\tif(file == null)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\tif(file.type != VFS.DirectoryEntry.FILE)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tVFSManager.error(view,path,\\n\\t\\t\\t\\t\\t\\t\\\"ioerror.save-directory\\\",null);\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror\\\",\\n\\t\\t\\t\\t\\tnew String[] { io.toString() });\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvfs._endVFSSession(session,view);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror\\\",\\n\\t\\t\\t\\t\\t\\tnew String[] { io.toString() });\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t} \\n\\t\\tprivate void finishLoading()\\n\\t{\\n\\t\\tparseBufferLocalProperties();\\n\\t\\t\\t\\t\\t\\tFoldHandler oldFoldHandler = foldHandler;\\n\\t\\tsetMode();\\n\\t\\tif(foldHandler == oldFoldHandler)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tlineMgr.setFirstInvalidFoldLevel(0);\\n\\t\\t\\tfireFoldHandlerChanged();\\n\\t\\t}\\n\\t\\t\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tmarker.removePosition();\\n\\t\\t\\tint pos = marker.getPosition();\\n\\t\\t\\tif(pos > getLength())\\n\\t\\t\\t\\tmarker.setPosition(getLength());\\n\\t\\t\\telse if(pos < 0)\\n\\t\\t\\t\\tmarker.setPosition(0);\\n\\t\\t\\tmarker.createPosition();\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void finishSaving(View view, String oldPath, String path,\\n\\t\\tboolean rename, boolean error)\\n\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tif(!error && !path.equals(oldPath))\\n\\t\\t{\\n\\t\\t\\tBuffer buffer = jEdit.getBuffer(path);\\n\\t\\t\\tif(rename)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer != null && \\n\\t\\t\\t\\t\\t!buffer.getPath().equals(oldPath))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbuffer.setDirty(false);\\n\\t\\t\\t\\t\\tjEdit.closeBuffer(view,buffer);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsetPath(path);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(buffer != null && \\n\\t\\t\\t\\t\\t!buffer.getPath().equals(oldPath))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbuffer.load(view,true);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tif(rename)\\n\\t\\t{\\n\\t\\t\\tif(file != null)\\n\\t\\t\\t\\tmodTime = file.lastModified();\\n\\t\\t\\tif(!error)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twriteLock();\\n\\t\\t\\t\\t\\tif(autosaveFile != null)\\n\\t\\t\\t\\t\\t\\tautosaveFile.delete();\\n\\t\\t\\t\\t\\tsetFlag(AUTOSAVE_DIRTY,false);\\n\\t\\t\\t\\t\\tsetFlag(READ_ONLY,false);\\n\\t\\t\\t\\t\\tsetFlag(NEW_FILE,false);\\n\\t\\t\\t\\t\\tsetFlag(UNTITLED,false);\\n\\t\\t\\t\\t\\tsetFlag(DIRTY,false);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tundoMgr.bufferSaved();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfinally\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twriteUnlock();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tparseBufferLocalProperties();\\n\\t\\t\\t\\tif(!getPath().equals(oldPath))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tjEdit.updatePosition(oldPath,Buffer.this);\\n\\t\\t\\t\\t\\tsetMode();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tString newMode = getStringProperty(\\\"mode\\\");\\n\\t\\t\\t\\t\\tif(newMode != null &&\\n\\t\\t\\t\\t\\t\\t!newMode.equals(getMode()\\n\\t\\t\\t\\t\\t\\t.getName()))\\n\\t\\t\\t\\t\\t\\tsetMode();\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tpropertiesChanged();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tEditBus.send(new BufferUpdate(Buffer.this,\\n\\t\\t\\t\\t\\tview,BufferUpdate.DIRTY_CHANGED));\\n\\t\\t\\t\\t\\t\\t\\t\\tEditBus.send(new BufferUpdate(Buffer.this,\\n\\t\\t\\t\\t\\tview,BufferUpdate.SAVED));\\n\\t\\t\\t}\\n\\t\\t} \\t} \\n\\t\\tprivate void parseBufferLocalProperties()\\n\\t{\\n\\t\\tint lastLine = Math.min(9,getLineCount() - 1);\\n\\t\\tparseBufferLocalProperties(getText(0,getLineEndOffset(lastLine) - 1));\\n\\t\\t\\t\\t\\t\\tint firstLine = Math.max(lastLine + 1, getLineCount() - 10);\\n\\t\\tif(firstLine < getLineCount())\\n\\t\\t{\\n\\t\\t\\tint length = getLineEndOffset(getLineCount() - 1) \\n\\t\\t\\t\\t- (getLineStartOffset(firstLine) + 1);\\n\\t\\t\\tparseBufferLocalProperties(getText(getLineStartOffset(firstLine),length));\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void parseBufferLocalProperties(String prop)\\n\\t{\\n\\t\\tStringBuffer buf = new StringBuffer();\\n\\t\\tString name = null;\\n\\t\\tboolean escape = false;\\n\\t\\tfor(int i = 0; i < prop.length(); i++)\\n\\t\\t{\\n\\t\\t\\tchar c = prop.charAt(i);\\n\\t\\t\\tswitch(c)\\n\\t\\t\\t{\\n\\t\\t\\tcase ':':\\n\\t\\t\\t\\tif(escape)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tescape = false;\\n\\t\\t\\t\\t\\tbuf.append(':');\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(name != null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tproperties.put(name,new PropValue(buf.toString(),false));\\n\\t\\t\\t\\t\\tname = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbuf.setLength(0);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase '=':\\n\\t\\t\\t\\tif(escape)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tescape = false;\\n\\t\\t\\t\\t\\tbuf.append('=');\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tname = buf.toString();\\n\\t\\t\\t\\tbuf.setLength(0);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase '\\\\\\\\':\\n\\t\\t\\t\\tif(escape)\\n\\t\\t\\t\\t\\tbuf.append('\\\\\\\\');\\n\\t\\t\\t\\tescape = !escape;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 'n':\\n\\t\\t\\t\\tif(escape)\\n\\t\\t\\t\\t{\\tbuf.append('\\\\n');\\n\\t\\t\\t\\t\\tescape = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\tcase 'r':\\n\\t\\t\\t\\tif(escape)\\n\\t\\t\\t\\t{\\tbuf.append('\\\\r');\\n\\t\\t\\t\\t\\tescape = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\tcase 't':\\n\\t\\t\\t\\tif(escape)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbuf.append('\\\\t');\\n\\t\\t\\t\\t\\tescape = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tbuf.append(c);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void setTokenMarker(TokenMarker tokenMarker)\\n\\t{\\n\\t\\tTokenMarker oldTokenMarker = this.tokenMarker;\\n\\t\\tthis.tokenMarker = tokenMarker;\\n\\t\\t\\t\\tif(oldTokenMarker != null && tokenMarker != oldTokenMarker)\\n\\t\\t{\\n\\t\\t\\tlineMgr.setFirstInvalidLineContext(0);\\n\\t\\t}\\n\\t} \\n\\tprivate int getPriorNonEmptyLine(int lineIndex)\\n\\t{\\n\\t\\tfor(int i = lineIndex - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(getLineLength(i) != 0)\\n\\t\\t\\t\\treturn i;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t} \\n\\t\\tprivate void contentInserted(int offset, int length,\\n\\t\\tIntegerArray endOffsets)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tsetFlag(INSIDE_INSERT,true);\\n\\t\\t\\tint startLine = lineMgr.getLineOfOffset(offset);\\n\\t\\t\\tint numLines = endOffsets.getSize();\\n\\t\\t\\tlineMgr.contentInserted(startLine,offset,numLines,length,\\n\\t\\t\\t\\tendOffsets);\\n\\t\\t\\tpositionMgr.contentInserted(offset,length);\\n\\t\\t\\tsetDirty(true);\\n\\t\\t\\tif(!getFlag(LOADING))\\n\\t\\t\\t\\tfireContentInserted(startLine,offset,numLines,length);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tsetFlag(INSIDE_INSERT,false);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate BufferChangeListener getListener(int index)\\n\\t{\\n\\t\\treturn ((Listener)bufferListeners.elementAt(index)).listener;\\n\\t} \\n\\t\\tprivate void fireFoldLevelChanged(int start, int end)\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).foldLevelChanged(this,start,end);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireContentInserted(int startLine, int offset,\\n\\t\\tint numLines, int length)\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).contentInserted(this,startLine,\\n\\t\\t\\t\\t\\toffset,numLines,length);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireContentRemoved(int startLine, int offset,\\n\\t\\tint numLines, int length)\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).contentRemoved(this,startLine,\\n\\t\\t\\t\\t\\toffset,numLines,length);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void firePreContentRemoved(int startLine, int offset,\\n\\t\\tint numLines, int length)\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).preContentRemoved(this,startLine,\\n\\t\\t\\t\\t\\toffset,numLines,length);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireTransactionComplete()\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).transactionComplete(this);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireFoldHandlerChanged()\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).foldHandlerChanged(this);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireWrapModeChanged()\\n\\t{\\n\\t\\tfor(int i = 0; i < bufferListeners.size(); i++)\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetListener(i).wrapModeChanged(this);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Exception while sending buffer event:\\\");\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t}\""
            },
            "m7": {
                "content": "The source code of `Buffer.java` reveals that it plays a central role in managing text buffers within the jEdit application. It includes functionality for:\n\n- **Text manipulation**: Inserting, removing, and modifying text content.\n- **File I/O operations**: Loading and saving files, handling autosave, and managing file status (e.g., checking if a file has been modified externally).\n- **Buffer properties**: Managing buffer-specific settings such as encoding, indentation, line separators, and syntax highlighting.\n- **Undo/Redo support**: Maintaining an undo history and allowing transaction management.\n- **Syntax parsing and tokenization**: Supporting syntax highlighting through token markers and fold handlers.\n- **Marker management**: Supporting bookmarks or markers in the text buffer.\n\nGiven its high coupling confidence with `jEdit.java`, any changes to `jEdit.java` could potentially affect how `Buffer.java` is used or needs to be updated. To further understand potential ripple effects, we should investigate dependencies between these two classes.\n\nLet's now call the `get_coupling_dependencies` function to analyze the coupling between `jEdit.java` and `Buffer.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_20bd3bd3fef34bdbb9319b",
                        "function": {
                            "arguments": "{\"entity1\": \"jEdit.java\", \"entity2\": \"Buffer.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m8": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"There are no coupling dependencies between these two entities\"]"
            },
            "m9": {
                "content": "Interestingly, the analysis shows that there are **no direct coupling dependencies** between `jEdit.java` and `Buffer.java`, despite their high co-change confidence. This suggests that while these two files are often modified together, they do **not directly reference or depend on each other** in terms of code structure (e.g., method calls, inheritance, type usage).\n\nThis kind of relationship\u2014high co-change but low structural dependency\u2014is not uncommon in large evolving systems. It may indicate that both files are affected by the same **functional changes**, even though they operate at different abstraction levels.\n\nTo better understand why they are co-changed so frequently, we should look into how `jEdit.java` interacts with components that use `Buffer.java`. A good next step is to examine the call graph of `jEdit.java` to see which entities it directly uses, especially those that might mediate its interaction with `Buffer.java`.\n\nLet's proceed by calling the `get_call_graph` function on `jEdit.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_045e6a4ab3d943fb812f9f",
                        "function": {
                            "arguments": "{\"entity\": \"jEdit.java\"}",
                            "name": "get_call_graph"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m10": {
                "role": "tool",
                "name": "get_call_graph",
                "content": "[\"\", \"BufferIORequest\", \"PluginManager\", \"KillRing\", \"\", \"HelpViewer\", \"\", \"\", \"SearchAndReplace\", \"\", \"Log\", \"\"]"
            },
            "m11": {
                "content": "The call graph for `jEdit.java` reveals several entities that it directly interacts with. These include:\n\n- **BufferIORequest**\n- **PluginManager**\n- **KillRing**\n- **HelpViewer**\n- **SearchAndReplace**\n- **Log**\n\nInterestingly, while `Buffer.java` did not appear in the direct coupling analysis, some of these entities (like `BufferIORequest`) may act as intermediaries between `jEdit.java` and `Buffer.java`.\n\nTo understand how `jEdit.java` might indirectly depend on `Buffer.java`, we should investigate the role of such intermediary classes. A good candidate to examine next is `BufferIORequest.java`, since it likely handles I/O operations related to buffers and could mediate interactions between `jEdit.java` and `Buffer.java`.\n\nLet\u2019s retrieve the source code of `BufferIORequest.java` using the `get_origin_code` function.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_809e6923b3014e0b86b55b",
                        "function": {
                            "arguments": "{\"entity\": \"BufferIORequest.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m12": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package org.gjt.sp.jedit.buffer;\\nimport javax.swing.text.Segment;\\nimport java.io.*;\\nimport java.util.zip.*;\\nimport java.util.Vector;\\nimport org.gjt.sp.jedit.io.*;\\nimport org.gjt.sp.jedit.*;\\nimport org.gjt.sp.util.*;\\npublic class BufferIORequest extends WorkRequest\\n{\\n\\tpublic static final int IOBUFSIZE = 32768;\\n\\tpublic static final int PROGRESS_INTERVAL = 300;\\n\\tpublic static final String LOAD_DATA = \\\"BufferIORequest__loadData\\\";\\n\\tpublic static final String END_OFFSETS = \\\"BufferIORequest__endOffsets\\\";\\n\\tpublic static final String NEW_PATH = \\\"BufferIORequest__newPath\\\";\\n\\tpublic static final String ERROR_OCCURRED = \\\"BufferIORequest__error\\\";\\n\\tpublic static final int LOAD = 0;\\n\\tpublic static final int SAVE = 1;\\n\\tpublic static final int AUTOSAVE = 2;\\n\\tpublic static final int INSERT = 3;\\n\\tpublic static final int GZIP_MAGIC_1 = 0x1f;\\n\\tpublic static final int GZIP_MAGIC_2 = 0x8b;\\n\\tpublic static final int UNICODE_MAGIC_1 = 0xfe;\\n\\tpublic static final int UNICODE_MAGIC_2 = 0xff;\\n\\tpublic BufferIORequest(int type, View view, Buffer buffer,\\n\\t\\tObject session, VFS vfs, String path)\\n\\t{\\n\\t\\tthis.type = type;\\n\\t\\tthis.view = view;\\n\\t\\tthis.buffer = buffer;\\n\\t\\tthis.session = session;\\n\\t\\tthis.vfs = vfs;\\n\\t\\tthis.path = path;\\n\\t\\tmarkersPath = vfs.getParentOfPath(path)\\n\\t\\t\\t+ '.' + vfs.getFileName(path)\\n\\t\\t\\t+ \\\".marks\\\";\\n\\t} \\n\\t\\tpublic void run()\\n\\t{\\n\\t\\tswitch(type)\\n\\t\\t{\\n\\t\\tcase LOAD:\\n\\t\\t\\tload();\\n\\t\\t\\tbreak;\\n\\t\\tcase SAVE:\\n\\t\\t\\tsave();\\n\\t\\t\\tbreak;\\n\\t\\tcase AUTOSAVE:\\n\\t\\t\\tautosave();\\n\\t\\t\\tbreak;\\n\\t\\tcase INSERT:\\n\\t\\t\\tinsert();\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t} \\n\\t\\tpublic String toString()\\n\\t{\\n\\t\\tString typeString;\\n\\t\\tswitch(type)\\n\\t\\t{\\n\\t\\tcase LOAD:\\n\\t\\t\\ttypeString = \\\"LOAD\\\";\\n\\t\\t\\tbreak;\\n\\t\\tcase SAVE:\\n\\t\\t\\ttypeString = \\\"SAVE\\\";\\n\\t\\t\\tbreak;\\n\\t\\tcase AUTOSAVE:\\n\\t\\t\\ttypeString = \\\"AUTOSAVE\\\";\\n\\t\\t\\tbreak;\\n\\t\\tdefault:\\n\\t\\t\\ttypeString = \\\"UNKNOWN!!!\\\";\\n\\t\\t}\\n\\t\\treturn getClass().getName() + \\\"[type=\\\" + typeString\\n\\t\\t\\t+ \\\",buffer=\\\" + buffer + \\\"]\\\";\\n\\t} \\n\\t\\tprivate int type;\\n\\tprivate View view;\\n\\tprivate Buffer buffer;\\n\\tprivate Object session;\\n\\tprivate VFS vfs;\\n\\tprivate String path;\\n\\tprivate String markersPath;\\n\\t\\tprivate void load()\\n\\t{\\n\\t\\tInputStream in = null;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tString[] args = { vfs.getFileName(path) };\\n\\t\\t\\t\\tsetAbortable(true);\\n\\t\\t\\t\\tif(!buffer.isTemporary())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsetStatus(jEdit.getProperty(\\\"vfs.status.load\\\",args));\\n\\t\\t\\t\\t\\tsetProgressValue(0);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tpath = vfs._canonPath(session,path,view);\\n\\t\\t\\t\\tVFS.DirectoryEntry entry = vfs._getDirectoryEntry(\\n\\t\\t\\t\\t\\tsession,path,view);\\n\\t\\t\\t\\tlong length;\\n\\t\\t\\t\\tif(entry != null)\\n\\t\\t\\t\\t\\tlength = entry.length;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tlength = 0L;\\n\\t\\t\\t\\tin = vfs._createInputStream(session,path,false,view);\\n\\t\\t\\t\\tif(in == null)\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\tin = new BufferedInputStream(in);\\n\\t\\t\\t\\tif(in.markSupported())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tin.mark(2);\\n\\t\\t\\t\\t\\tint b1 = in.read();\\n\\t\\t\\t\\t\\tint b2 = in.read();\\n\\t\\t\\t\\t\\tin.reset();\\n\\t\\t\\t\\t\\tif(b1 == GZIP_MAGIC_1 && b2 == GZIP_MAGIC_2)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tin = new GZIPInputStream(in);\\n\\t\\t\\t\\t\\t\\tbuffer.setBooleanProperty(Buffer.GZIPPED,true);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if((b1 == UNICODE_MAGIC_1 && b2 == UNICODE_MAGIC_2)\\n\\t\\t\\t\\t\\t\\t|| (b1 == UNICODE_MAGIC_2 && b2 == UNICODE_MAGIC_1))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.setProperty(Buffer.ENCODING,\\\"Unicode\\\");\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(path.toLowerCase().endsWith(\\\".gz\\\"))\\n\\t\\t\\t\\t\\tin = new GZIPInputStream(in);\\n\\t\\t\\t\\tread(buffer,in,length);\\n\\t\\t\\t\\tbuffer.setNewFile(false);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(CharConversionException ch)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,ch);\\n\\t\\t\\t\\tObject[] pp = { buffer.getProperty(Buffer.ENCODING),\\n\\t\\t\\t\\t\\tch.toString() };\\n\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror.encoding-error\\\",pp);\\n\\t\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(UnsupportedEncodingException uu)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,uu);\\n\\t\\t\\t\\tObject[] pp = { buffer.getProperty(Buffer.ENCODING),\\n\\t\\t\\t\\t\\tuu.toString() };\\n\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror.encoding-error\\\",pp);\\n\\t\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,io);\\n\\t\\t\\t\\tObject[] pp = { io.toString() };\\n\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror.read-error\\\",pp);\\n\\t\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(OutOfMemoryError oom)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,oom);\\n\\t\\t\\t\\tVFSManager.error(view,path,\\\"out-of-memory-error\\\",null);\\n\\t\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t\\t}\\n\\t\\t\\tif(jEdit.getBooleanProperty(\\\"persistentMarkers\\\"))\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tString[] args = { vfs.getFileName(path) };\\n\\t\\t\\t\\t\\tif(!buffer.isTemporary())\\n\\t\\t\\t\\t\\t\\tsetStatus(jEdit.getProperty(\\\"vfs.status.load-markers\\\",args));\\n\\t\\t\\t\\t\\tsetAbortable(true);\\n\\t\\t\\t\\t\\tin = vfs._createInputStream(session,markersPath,true,view);\\n\\t\\t\\t\\t\\tif(in != null)\\n\\t\\t\\t\\t\\t\\treadMarkers(buffer,in);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcatch(WorkThread.Abort a)\\n\\t\\t{\\n\\t\\t\\tif(in != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tin.close();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tvfs._endVFSSession(session,view);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,io);\\n\\t\\t\\t\\tString[] pp = { io.toString() };\\n\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror.read-error\\\",pp);\\n\\t\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(WorkThread.Abort a)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void read(Buffer buffer, InputStream _in, long length)\\n\\t\\tthrows IOException\\n\\t{\\n\\t\\tIntegerArray endOffsets = new IntegerArray(\\n\\t\\t\\tMath.max(1,(int)(length / 50)));\\n\\t\\t\\t\\tboolean trackProgress = (!buffer.isTemporary() && length != 0);\\n\\t\\tif(trackProgress)\\n\\t\\t{\\n\\t\\t\\tsetProgressValue(0);\\n\\t\\t\\tsetProgressMaximum((int)length);\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(length == 0)\\n\\t\\t\\tlength = IOBUFSIZE;\\n\\t\\tSegmentBuffer seg = new SegmentBuffer((int)length + 1);\\n\\t\\tInputStreamReader in = new InputStreamReader(_in,\\n\\t\\t\\tbuffer.getStringProperty(Buffer.ENCODING));\\n\\t\\tchar[] buf = new char[IOBUFSIZE];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tint len;\\n\\t\\t\\t\\t\\t\\tboolean CRLF = false;\\n\\t\\t\\t\\tboolean CROnly = false;\\n\\t\\t\\t\\t\\t\\t\\t\\tboolean lastWasCR = false;\\n\\t\\t\\t\\t\\t\\tint lineCount = 0;\\n\\t\\twhile((len = in.read(buf,0,buf.length)) != -1)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tint lastLine = 0;\\n\\t\\t\\tfor(int i = 0; i < len; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tswitch(buf[i])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\r':\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(lastWasCR)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tCROnly = true;\\n\\t\\t\\t\\t\\t\\tCRLF = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tlastWasCR = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tseg.append(buf,lastLine,i -\\n\\t\\t\\t\\t\\t\\tlastLine);\\n\\t\\t\\t\\t\\tseg.append('\\\\n');\\n\\t\\t\\t\\t\\tendOffsets.add(seg.count);\\n\\t\\t\\t\\t\\tif(trackProgress && lineCount++ % PROGRESS_INTERVAL == 0)\\n\\t\\t\\t\\t\\t\\tsetProgressValue(seg.count);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tlastLine = i + 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase '\\\\n':\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(lastWasCR)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tCROnly = false;\\n\\t\\t\\t\\t\\t\\tCRLF = true;\\n\\t\\t\\t\\t\\t\\tlastWasCR = false;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tlastLine = i + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tCROnly = false;\\n\\t\\t\\t\\t\\t\\tCRLF = false;\\n\\t\\t\\t\\t\\t\\tseg.append(buf,lastLine,\\n\\t\\t\\t\\t\\t\\t\\ti - lastLine);\\n\\t\\t\\t\\t\\t\\tseg.append('\\\\n');\\n\\t\\t\\t\\t\\t\\tendOffsets.add(seg.count);\\n\\t\\t\\t\\t\\t\\tif(trackProgress && lineCount++ % PROGRESS_INTERVAL == 0)\\n\\t\\t\\t\\t\\t\\t\\tsetProgressValue(seg.count);\\n\\t\\t\\t\\t\\t\\tlastLine = i + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(lastWasCR)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tCROnly = true;\\n\\t\\t\\t\\t\\t\\tCRLF = false;\\n\\t\\t\\t\\t\\t\\tlastWasCR = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(trackProgress)\\n\\t\\t\\t\\tsetProgressValue(seg.count);\\n\\t\\t\\t\\t\\t\\tseg.append(buf,lastLine,len - lastLine);\\n\\t\\t}\\n\\t\\tsetAbortable(false);\\n\\t\\tString lineSeparator;\\n\\t\\tif(CRLF)\\n\\t\\t\\tlineSeparator = \\\"\\\\r\\\\n\\\";\\n\\t\\telse if(CROnly)\\n\\t\\t\\tlineSeparator = \\\"\\\\r\\\";\\n\\t\\telse\\n\\t\\t\\tlineSeparator = \\\"\\\\n\\\";\\n\\t\\tin.close();\\n\\t\\t\\t\\tint bufferLength = seg.count;\\n\\t\\tif(bufferLength != 0)\\n\\t\\t{\\n\\t\\t\\tchar ch = seg.array[bufferLength - 1];\\n\\t\\t\\tif(ch == 0x1a )\\n\\t\\t\\t\\tseg.count--;\\n\\t\\t}\\n\\t\\tbuffer.setBooleanProperty(Buffer.TRAILING_EOL,false);\\n\\t\\tif(bufferLength != 0 && jEdit.getBooleanProperty(\\\"stripTrailingEOL\\\"))\\n\\t\\t{\\n\\t\\t\\tchar ch = seg.array[bufferLength - 1];\\n\\t\\t\\tif(ch == '\\\\n')\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.setBooleanProperty(Buffer.TRAILING_EOL,true);\\n\\t\\t\\t\\tseg.count--;\\n\\t\\t\\t\\tendOffsets.setSize(endOffsets.getSize() - 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tendOffsets.add(seg.count + 1);\\n\\t\\t\\t\\t\\t\\t\\t\\tbuffer.setProperty(LOAD_DATA,seg);\\n\\t\\tbuffer.setProperty(END_OFFSETS,endOffsets);\\n\\t\\tbuffer.setProperty(NEW_PATH,path);\\n\\t\\tbuffer.setProperty(Buffer.LINESEP,lineSeparator);\\n\\t} \\n\\t\\tprivate void readMarkers(Buffer buffer, InputStream _in)\\n\\t\\tthrows IOException\\n\\t{\\n\\t\\t\\t\\tbuffer.removeAllMarkers();\\n\\t\\tBufferedReader in = new BufferedReader(new InputStreamReader(_in));\\n\\t\\tString line;\\n\\t\\twhile((line = in.readLine()) != null)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(!line.startsWith(\\\"!\\\"))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tchar shortcut = line.charAt(1);\\n\\t\\t\\tint start = line.indexOf(';');\\n\\t\\t\\tint end = line.indexOf(';',start + 1);\\n\\t\\t\\tint position = Integer.parseInt(line.substring(start + 1,end));\\n\\t\\t\\tbuffer.addMarker(shortcut,position);\\n\\t\\t}\\n\\t\\tin.close();\\n\\t} \\n\\t\\tprivate void save()\\n\\t{\\n\\t\\tOutputStream out = null;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tString[] args = { vfs.getFileName(path) };\\n\\t\\t\\tsetStatus(jEdit.getProperty(\\\"vfs.status.save\\\",args));\\n\\t\\t\\t\\t\\t\\tsetAbortable(true);\\n\\t\\t\\tpath = vfs._canonPath(session,path,view);\\t\\t\\tif(!MiscUtilities.isURL(path))\\n\\t\\t\\t\\tpath = MiscUtilities.resolveSymlinks(path);\\n\\t\\t\\t\\t\\t\\tif(buffer.getProperty(Buffer.BACKED_UP) == null\\n\\t\\t\\t\\t|| jEdit.getBooleanProperty(\\\"backupEverySave\\\"))\\n\\t\\t\\t{\\n\\t\\t\\t\\tvfs._backup(session,path,view);\\n\\t\\t\\t\\tbuffer.setBooleanProperty(Buffer.BACKED_UP,true);\\n\\t\\t\\t}\\n\\t\\t\\tString savePath;\\n\\t\\t\\tboolean twoStageSave = (vfs.getCapabilities() & VFS.RENAME_CAP) != 0\\n\\t\\t\\t\\t&& jEdit.getBooleanProperty(\\\"twoStageSave\\\");\\n\\t\\t\\tif(twoStageSave)\\n\\t\\t\\t\\tsavePath = vfs.getTwoStageSaveName(path);\\n\\t\\t\\telse\\n\\t\\t\\t\\tsavePath = path;\\n\\t\\t\\tout = vfs._createOutputStream(session,savePath,view);\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbuffer.readLock();\\n\\t\\t\\t\\tif(out != null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(savePath.endsWith(\\\".gz\\\"))\\n\\t\\t\\t\\t\\t\\tbuffer.setBooleanProperty(Buffer.GZIPPED,true);\\n\\t\\t\\t\\t\\tif(buffer.getBooleanProperty(Buffer.GZIPPED))\\n\\t\\t\\t\\t\\t\\tout = new GZIPOutputStream(out);\\n\\t\\t\\t\\t\\twrite(buffer,out);\\n\\t\\t\\t\\t\\tif(twoStageSave)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(!vfs._rename(session,savePath,path,view))\\n\\t\\t\\t\\t\\t\\t\\tthrow new IOException(savePath);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif((vfs.getCapabilities() & VFS.DELETE_CAP) != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(jEdit.getBooleanProperty(\\\"persistentMarkers\\\")\\n\\t\\t\\t\\t\\t\\t\\t&& buffer.getMarkers().size() != 0)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tsetStatus(jEdit.getProperty(\\\"vfs.status.save-markers\\\",args));\\n\\t\\t\\t\\t\\t\\t\\tsetProgressValue(0);\\n\\t\\t\\t\\t\\t\\t\\tout = vfs._createOutputStream(session,markersPath,view);\\n\\t\\t\\t\\t\\t\\t\\tif(out != null)\\n\\t\\t\\t\\t\\t\\t\\t\\twriteMarkers(buffer,out);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tvfs._delete(session,markersPath,view);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t\\t\\tif(!twoStageSave)\\n\\t\\t\\t\\t\\tVFSManager.sendVFSUpdate(vfs,path,true);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.readUnlock();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcatch(IOException io)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.ERROR,this,io);\\n\\t\\t\\tString[] pp = { io.toString() };\\n\\t\\t\\tVFSManager.error(view,path,\\\"ioerror.write-error\\\",pp);\\n\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t}\\n\\t\\tcatch(WorkThread.Abort a)\\n\\t\\t{\\n\\t\\t\\tif(out != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tout.close();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tvfs._saveComplete(session,buffer,path,view);\\n\\t\\t\\t\\tvfs._endVFSSession(session,view);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,io);\\n\\t\\t\\t\\tString[] pp = { io.toString() };\\n\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror.write-error\\\",pp);\\n\\t\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(WorkThread.Abort a)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void autosave()\\n\\t{\\n\\t\\tOutputStream out = null;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tString[] args = { vfs.getFileName(path) };\\n\\t\\t\\tsetStatus(jEdit.getProperty(\\\"vfs.status.autosave\\\",args));\\n\\t\\t\\t\\t\\t\\tsetAbortable(true);\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(!buffer.isDirty())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tout = vfs._createOutputStream(session,path,view);\\n\\t\\t\\t\\tif(out == null)\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\twrite(buffer,out);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(Exception e)\\n\\t\\t\\t{\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcatch(WorkThread.Abort a)\\n\\t\\t{\\n\\t\\t\\tif(out != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tout.close();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void write(Buffer buffer, OutputStream _out)\\n\\t\\tthrows IOException\\n\\t{\\n\\t\\tBufferedWriter out = new BufferedWriter(\\n\\t\\t\\tnew OutputStreamWriter(_out,\\n\\t\\t\\t\\tbuffer.getStringProperty(Buffer.ENCODING)),\\n\\t\\t\\t\\tIOBUFSIZE);\\n\\t\\tSegment lineSegment = new Segment();\\n\\t\\tString newline = buffer.getStringProperty(Buffer.LINESEP);\\n\\t\\tif(newline == null)\\n\\t\\t\\tnewline = System.getProperty(\\\"line.separator\\\");\\n\\t\\tsetProgressMaximum(buffer.getLineCount() / PROGRESS_INTERVAL);\\n\\t\\tsetProgressValue(0);\\n\\t\\tint i = 0;\\n\\t\\twhile(i < buffer.getLineCount())\\n\\t\\t{\\n\\t\\t\\tbuffer.getLineText(i,lineSegment);\\n\\t\\t\\tout.write(lineSegment.array,lineSegment.offset,\\n\\t\\t\\t\\tlineSegment.count);\\n\\t\\t\\tif(i != buffer.getLineCount() - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tout.write(newline);\\n\\t\\t\\t}\\n\\t\\t\\tif(++i % PROGRESS_INTERVAL == 0)\\n\\t\\t\\t\\tsetProgressValue(i / PROGRESS_INTERVAL);\\n\\t\\t}\\n\\t\\tif(jEdit.getBooleanProperty(\\\"stripTrailingEOL\\\")\\n\\t\\t\\t&& buffer.getBooleanProperty(Buffer.TRAILING_EOL))\\n\\t\\t{\\n\\t\\t\\tout.write(newline);\\n\\t\\t}\\n\\t\\tout.close();\\n\\t} \\n\\t\\tprivate void writeMarkers(Buffer buffer, OutputStream out)\\n\\t\\tthrows IOException\\n\\t{\\n\\t\\tWriter o = new BufferedWriter(new OutputStreamWriter(out));\\n\\t\\tVector markers = buffer.getMarkers();\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker marker = (Marker)markers.elementAt(i);\\n\\t\\t\\to.write('!');\\n\\t\\t\\to.write(marker.getShortcut());\\n\\t\\t\\to.write(';');\\n\\t\\t\\tString pos = String.valueOf(marker.getPosition());\\n\\t\\t\\to.write(pos);\\n\\t\\t\\to.write(';');\\n\\t\\t\\to.write(pos);\\n\\t\\t\\to.write('\\\\n');\\n\\t\\t}\\n\\t\\to.close();\\n\\t} \\n\\t\\tprivate void insert()\\n\\t{\\n\\t\\tInputStream in = null;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tString[] args = { vfs.getFileName(path) };\\n\\t\\t\\t\\tsetStatus(jEdit.getProperty(\\\"vfs.status.load\\\",args));\\n\\t\\t\\t\\tsetAbortable(true);\\n\\t\\t\\t\\tpath = vfs._canonPath(session,path,view);\\n\\t\\t\\t\\tVFS.DirectoryEntry entry = vfs._getDirectoryEntry(\\n\\t\\t\\t\\t\\tsession,path,view);\\n\\t\\t\\t\\tlong length;\\n\\t\\t\\t\\tif(entry != null)\\n\\t\\t\\t\\t\\tlength = entry.length;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tlength = 0L;\\n\\t\\t\\t\\tin = vfs._createInputStream(session,path,false,view);\\n\\t\\t\\t\\tif(in == null)\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\tif(path.endsWith(\\\".gz\\\"))\\n\\t\\t\\t\\t\\tin = new GZIPInputStream(in);\\n\\t\\t\\t\\tread(buffer,in,length);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,io);\\n\\t\\t\\t\\tString[] pp = { io.toString() };\\n\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror.read-error\\\",pp);\\n\\t\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcatch(WorkThread.Abort a)\\n\\t\\t{\\n\\t\\t\\tif(in != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tin.close();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tvfs._endVFSSession(session,view);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(IOException io)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,io);\\n\\t\\t\\t\\tString[] pp = { io.toString() };\\n\\t\\t\\t\\tVFSManager.error(view,path,\\\"ioerror.read-error\\\",pp);\\n\\t\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t\\t}\\n\\t\\t\\tcatch(WorkThread.Abort a)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.setBooleanProperty(ERROR_OCCURRED,true);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t}\""
            },
            "m13": {
                "content": "The source code of `BufferIORequest.java` reveals that it is a critical component responsible for handling I/O operations related to `Buffer` instances in jEdit. It extends `WorkRequest`, which suggests it's executed asynchronously, likely in a background thread.\n\n### Key Responsibilities:\n1. **Loading Buffers**:\n   - Reads from a file or stream into a buffer.\n   - Handles different encodings and line separators.\n   - Supports GZIP-compressed files.\n   - Manages marker restoration (e.g., bookmarks).\n\n2. **Saving Buffers**:\n   - Writes buffer contents to a file.\n   - Supports GZIP compression.\n   - Optionally performs two-stage saving for safety.\n   - Saves markers persistently if enabled.\n\n3. **Autosaving**:\n   - Periodically writes the buffer state to a temporary file to prevent data loss.\n\n4. **Inserting File Content**:\n   - Loads content from another file into the current buffer.\n\n### Interaction with `jEdit.java`\n- `jEdit.java` initiates I/O operations (like loading or saving files), and these are handled by `BufferIORequest`.\n- Although there's no direct structural dependency between `jEdit.java` and `Buffer.java`, `BufferIORequest` serves as an intermediary that operates on `Buffer` instances\u2014suggesting that changes in `jEdit.java` related to file handling may indirectly affect how buffers are loaded/saved.\n\nTo better understand how `jEdit.java` interacts with `BufferIORequest`, we should examine whether there are coupling dependencies between them.\n\nLet\u2019s call the `get_coupling_dependencies` function between `jEdit.java` and `BufferIORequest.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_585e457da2fd4c4cb59121",
                        "function": {
                            "arguments": "{\"entity1\": \"jEdit.java\", \"entity2\": \"BufferIORequest.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m14": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"StaticVariableInvoking(SAI): Static Variable Invoking found: closeBuffer invokes static variable ERROR_OCCURRED,\"]"
            },
            "m15": {
                "content": "The coupling analysis between `jEdit.java` and `BufferIORequest.java` reveals a **static variable invocation** relationship:\n\n- **Static Variable Invoking (SAI)**: `jEdit.java` accesses the static field `ERROR_OCCURRED` from `BufferIORequest.java`.\n\nThis indicates that `jEdit.java` checks or uses this static variable\u2014likely to determine if an error occurred during buffer I/O operations.\n\n### Implications:\n- If changes in `jEdit.java` involve error handling or interaction with buffer I/O processes, they may indirectly affect how `BufferIORequest` is used.\n- Since `BufferIORequest` operates on `Buffer` instances, any logic in `jEdit.java` that affects file loading/saving could propagate changes through `BufferIORequest` to `Buffer`.\n\nGiven this chain of interaction and co-change history, the following entities should be considered for synchronization when modifying `jEdit.java`:\n\n---\n\n### \u2705 Entities to Synchronize\n\n| Entity                | Reason |\n|-----------------------|--------|\n| **Buffer.java**       | High co-change confidence (0.196). Although no direct coupling, it is central to buffer management and interacts via `BufferIORequest`. |\n| **BufferIORequest.java** | Direct coupling with `jEdit.java` via `ERROR_OCCURRED`. Mediates buffer I/O operations. |\n| **SearchAndReplace.java** | Appears in call graph; often involved in text manipulation that may affect buffers. |\n| **PluginManager.java** | Appears in call graph; plugins may interact with buffers or modify behavior tied to `jEdit.java`. |\n| **KillRing.java**     | Appears in call graph; related to clipboard operations involving buffers. |\n| **HelpViewer.java**   | Appears in call graph; changes in UI or event handling might affect help integration. |\n\n---\n\n### Next Steps\n\nTo ensure robust change impact analysis, we should also check for conceptual coupling (semantic similarity) between `jEdit.java` and `Buffer.java`, even though structural dependencies are absent.\n\nLet\u2019s call the `get_conceptual_coupling` function between `jEdit.java` and `Buffer.java` to assess their semantic similarity.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_443ea0913bda4f57b3f64b",
                        "function": {
                            "arguments": "{\"entity1\": \"jEdit.java\", \"entity2\": \"Buffer.java\"}",
                            "name": "get_conceptual_coupling"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m16": {
                "role": "tool",
                "name": "get_conceptual_coupling",
                "content": "\"0.6731524\""
            },
            "m17": {
                "role": "user",
                "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
            },
            "m18": {
                "content": "Title: Diagnosis of starting entity `jEdit.java`  \nChange set: [Buffer.java, PluginManager.java, BufferIORequest.java, SearchAndReplace.java, HelpViewer.java, KillRing.java, Log.java, GUIUtilities.java, VFSManager.java, EditBus.java, TextAreaPainter.java, DockableWindowManager.java, MiscUtilities.java, JEditTextArea.java, View.java, ActionHandler.java, UndoManager.java, LineManager.java, PositionManager.java, TokenMarker.java, FoldHandler.java, BufferSet.java, BufferSwitcher.java, Macros.java, VFS.java, PluginJAR.java, Mode.java, SyntaxStyle.java, EditPane.java, RecentFilesMenu.java, DirectoryMenu.java, EnhancedCheckBoxMenuItem.java, FileVFS.java, HyperSearchResults.java, OptionsDialog.java, PluginManagerOptionPane.java, TextAreaTransferHandler.java, BeanShell.java, MarkerHighlight.java, Abbrevs.java, InputHandler.java, TextAreaDialog.java, HistoryTextField.java, BrowserView.java, DockableWindowFactory.java, DisplayManager.java, VFSBrowser.java, BufferOptions.java]  \n\nDetails:  \n- **Buffer.java**: High co-change confidence (0.196), central to buffer management and indirectly used via `BufferIORequest`.  \n- **PluginManager.java**: Appears in call graph; manages plugins that may interact with jEdit core functionality.  \n- **BufferIORequest.java**: Direct coupling via static variable access and mediates I/O operations for buffers.  \n- **SearchAndReplace.java**: Appears in call graph; interacts with buffer content and selection.  \n- **HelpViewer.java**: Appears in call graph; involved in UI help integration tied to main editor.  \n- **KillRing.java**: Appears in call graph; involved in clipboard operations affecting buffer edits.  \n- **Log.java**: Appears in call graph; logging is integral to debugging and error handling in editor logic.  \n- **GUIUtilities.java**: High co-change support (0.179), contains UI helpers used throughout the application.  \n- **VFSManager.java**: Manages file systems and I/O coordination, tightly related to buffer loading/saving.  \n- **EditBus.java**: Core event bus for communication between components including buffers and views.  \n- **TextAreaPainter.java**: Renders visual elements over text area, likely affected by view/editor changes.  \n- **DockableWindowManager.java**: Manages window layout, often co-changed with UI-related updates.  \n- **MiscUtilities.java**: General utility functions used across modules, often co-changed with core files.  \n- **JEditTextArea.java**: Central UI component for editing, highly dependent on buffer and editor state.  \n- **View.java**: Represents a view into a buffer, frequently co-changed with editor-level logic.  \n- **ActionHandler.java**: Handles user actions, often tied to core editing behavior and buffer manipulation.  \n- **UndoManager.java**: Manages undo/redo stack, closely tied to buffer modification tracking.  \n- **LineManager.java**: Manages line data in buffer, likely affected by changes in buffer structure.  \n- **PositionManager.java**: Manages document positions, impacted by structural or edit-related changes.  \n- **TokenMarker.java**: Syntax highlighting core class, often affected by buffer and mode changes.  \n- **FoldHandler.java**: Controls code folding, frequently modified alongside buffer and view logic.  \n- **BufferSet.java**: Manages sets of buffers, likely affected by global buffer state changes.  \n- **BufferSwitcher.java**: Switches between buffers, co-changed when navigation or buffer logic evolves.  \n- **Macros.java**: Implements macro execution, interacts with buffers and editor context.  \n- **VFS.java**: Abstract base class for virtual file system, involved in I/O coordination.  \n- **PluginJAR.java**: Manages plugin JARs, often co-changed due to plugin-editor integration.  \n- **Mode.java**: Defines editing modes, impacts syntax and behavior tied to buffer and editor.  \n- **SyntaxStyle.java**: Defines syntax display styles, co-changed with token and mode-related logic.  \n- **EditPane.java**: Hosts editing UI components, frequently synchronized with editor logic changes.  \n- **RecentFilesMenu.java**: UI for recent files, likely changed when file/opening logic is updated.  \n- **DirectoryMenu.java**: Navigates directories, linked to file-open and project-related changes.  \n- **EnhancedCheckBoxMenuItem.java**: UI control used in options and settings, often synchronized.  \n- **FileVFS.java**: Concrete implementation of file system, co-changed during I/O logic updates.  \n- **HyperSearchResults.java**: Displays search results, interacts with buffer content and selections.  \n- **OptionsDialog.java**: Editor-wide configuration UI, often co-modified with global settings.  \n- **PluginManagerOptionPane.java**: Settings panel for plugins, co-changed when plugin APIs evolve.  \n- **TextAreaTransferHandler.java**: Handles drag/drop and clipboard, interacts with buffer content.  \n- **BeanShell.java**: Scripting interface, often modified alongside core editor functionality.  \n- **MarkerHighlight.java**: Highlights markers in the text area, affected by marker/buffer changes.  \n- **Abbrevs.java**: Manages abbreviations, interacts with buffer insertion and typing behavior.  \n- **InputHandler.java**: Processes keyboard input, co-changed with editing and command logic.  \n- **TextAreaDialog.java**: Base dialog for text input, often synchronized with buffer interaction.  \n- **HistoryTextField.java**: Input field with history, used in dialogs tied to buffer/file operations.  \n- **BrowserView.java**: File browser UI, often changed when file navigation logic is updated.  \n- **DockableWindowFactory.java**: Creates dockable windows, impacted by layout/UI evolution.  \n- **DisplayManager.java**: Manages screen line display, affected by buffer and rendering changes.  \n- **VFSBrowser.java**: UI for browsing files, co-changed with file I/O and navigation logic.  \n- **BufferOptions.java**: Configuration for buffer properties, often synchronized with buffer logic.",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            }
        }
    }
}