{
    "time": 1749368236.0638902,
    "messages": [
        {
            "role": "system",
            "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
        },
        {
            "role": "user",
            "content": "The project you need to analyze is `OmegaT`, a well-known Java open source project. The starting entity you need to deal with is RealProject.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
        },
        {
            "content": "",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_decc899f496a4858bb2b7c",
                    "function": {
                        "arguments": "{\"entity\": \"RealProject.java\"}",
                        "name": "get_co_change_relationship"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "name": "get_co_change_relationship",
            "role": "tool",
            "content": "[[\"Core\", \"1\", \"0.03125\"], [\"SaveThread\", \"1\", \"0.03125\"], [\"IAutoSave\", \"1\", \"0.03125\"], [\"ITokenizer\", \"1\", \"0.03125\"], [\"Tokenizer\", \"1\", \"0.03125\"], [\"ProjectFrame\", \"2\", \"0.0625\"], [\"ProjectUICommands\", \"2\", \"0.0625\"], [\"TMXWriter\", \"4\", \"0.125\"], [\"RuntimePreferences\", \"3\", \"0.09375\"], [\"Main\", \"10\", \"0.3125\"], [\"SourceTextEntry\", \"3\", \"0.09375\"], [\"StringEntry\", \"1\", \"0.03125\"], [\"LoadFilesCallback\", \"1\", \"0.03125\"], [\"ParseEntry\", \"1\", \"0.03125\"], [\"FileInfo\", \"1\", \"0.03125\"], [\"SourceEntry\", \"1\", \"0.03125\"], [\"IEditor\", \"1\", \"0.03125\"], [\"EditorController\", \"1\", \"0.03125\"], [\"FilterMaster\", \"1\", \"0.03125\"], [\"AlignFilesCallback\", \"2\", \"0.0625\"], [\"ProjectFactory\", \"4\", \"0.125\"], [\"TransEntry\", \"1\", \"0.03125\"], [\"DateParser\", \"1\", \"0.03125\"], [\"InvalidDateException\", \"1\", \"0.03125\"], [\"SegmentBuilder\", \"3\", \"0.09375\"], [\"ProjectTMX\", \"3\", \"0.09375\"], [\"FileUtil\", \"1\", \"0.03125\"], [\"Loader\", \"3\", \"0.09375\"], [\"FindMatchesThread\", \"1\", \"0.03125\"], [\"EntryInfoSearchThread\", \"1\", \"0.03125\"], [\"TMXWriter2\", \"1\", \"0.03125\"], [\"TMXReader2\", \"2\", \"0.0625\"], [\"ExternalTMX\", \"1\", \"0.03125\"], [\"TmxSegmentationTest\", \"1\", \"0.03125\"], [\"TmxComplianceTests\", \"1\", \"0.03125\"], [\"TmxComplianceBase\", \"1\", \"0.03125\"], [\"MainWindowMenu\", \"1\", \"0.03125\"], [\"IMainMenu\", \"1\", \"0.03125\"], [\"IRemoteRepository\", \"1\", \"0.03125\"], [\"SVNRemoteRepository\", \"3\", \"0.09375\"], [\"GITRemoteRepository\", \"3\", \"0.09375\"], [\"ProjectTeamTMX\", \"1\", \"0.03125\"], [\"Log\", \"1\", \"0.03125\"], [\"ImportFromAutoTMX\", \"1\", \"0.03125\"], [\"OConsts\", \"1\", \"0.03125\"], [\"Scores\", \"1\", \"0.03125\"], [\"Preferences\", \"1\", \"0.03125\"], [\"ExternalTMXMatchesDialog\", \"1\", \"0.03125\"], [\"NearString\", \"1\", \"0.03125\"], [\"TestTeamIntegration\", \"1\", \"0.03125\"], [\"TestTeamIntegrationChild\", \"1\", \"0.03125\"], [\"TestCoreInitializer\", \"1\", \"0.03125\"], [\"TestRealProject\", \"1\", \"0.03125\"], [\"StaticUtils\", \"2\", \"0.0625\"], [\"StaticUtilsTest\", \"1\", \"0.03125\"]]"
        },
        {
            "content": "The co-change relationships have been obtained for the starting entity `RealProject.java`. In co-change analysis, the confidence value indicates how often other files were modified together with the target file (`RealProject.java`) over its history. Higher confidence values suggest a stronger likelihood of synchronization requirements.\n\nFrom the results:\n- The highest confidence value is `0.3125` (Main.java, support: 10), which suggests that `Main.java` has a significant relationship with `RealProject.java`.\n- Other entities like `TMXWriter`, `RuntimePreferences`, `ProjectFactory`, `SVNRemoteRepository`, and others also show relatively higher confidence than most.\n\n### Next Steps\nTo narrow down the list of entities that are most likely to be impacted:\n1. Filter out entities with low confidence (e.g., below 0.0625) since they are less likely to have strong dependencies.\n2. Analyze coupling or conceptual dependencies for the remaining entities with `RealProject.java`.\n\nLet\u2019s first analyze coupling dependencies between `RealProject.java` and the entities with high confidence, such as `Main.java`. I will call the `get_coupling_dependencies` function for this purpose.\n\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_b2fd0e7870a64e41852df1",
                    "function": {
                        "arguments": "{\"entity1\": \"RealProject.java\", \"entity2\": \"Main.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"There are no coupling dependencies between these two entities\"]"
        },
        {
            "content": "There are no direct coupling dependencies between `RealProject.java` and `Main.java`, despite their high co-change confidence. This suggests that the synchronization relationship may be due to indirect interactions rather than direct code-level dependencies.\n\n### Next Step:\nTo further investigate, we should analyze **conceptual coupling** (semantic similarity) between `RealProject.java` and these co-changed files, starting with `TMXWriter.java`, which has a relatively high confidence value (`0.125`) and may provide more meaningful insights.\n\nLet\u2019s proceed by calling the `get_conceptual_coupling` function between `RealProject.java` and `TMXWriter.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_529591bf7762478b89491c",
                    "function": {
                        "arguments": "{\"entity1\": \"RealProject.java\", \"entity2\": \"TMXWriter.java\"}",
                        "name": "get_conceptual_coupling"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_conceptual_coupling",
            "content": "\"0.83868736\""
        },
        {
            "content": "The conceptual coupling (semantic similarity) between `RealProject.java` and `TMXWriter.java` is quite high at approximately **0.839**, indicating a strong semantic relationship between these two entities.\n\nThis suggests that even if there are no direct coupling dependencies, changes in `RealProject.java` may still impact `TMXWriter.java` due to shared concepts or functionality.\n\n### Next Steps:\nTo better understand how `RealProject.java` interacts with other components:\n1. We should examine the **call graph** of `RealProject.java` to identify which entities it directly references or uses.\n2. This will help us uncover additional entities that are tightly coupled through method calls or variable usage.\n\nLet\u2019s now call the `get_call_graph` function for `RealProject.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_ad841668583b43e4b34f19",
                    "function": {
                        "arguments": "{\"entity\": \"RealProject.java\"}",
                        "name": "get_call_graph"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_call_graph",
            "content": "[\"Filters\", \"Statistics\", \"TranslationException\", \"GlossaryReaderTSV\", \"StaticUtils\", \"IAlignCallback\", \"IFilter\", \"FileUtil\", \"IProjectEventListener\", \"StringUtil\", \"TagUtil\", \"OStrings\", \"KnownException\", \"DefaultTokenizer\", \"FilterContext\", \"OConsts\", \"ProjectFileStorage\", \"FilterMaster\", \"CommandMonitor\", \"ITokenizer\", \"CLIParameters\", \"IRemoteRepository\", \"UIThreadsUtil\", \"RepositoryUtils\", \"DirectoryMonitor\", \"Language\", \"RuntimePreferences\", \"GlossaryEntry\", \"SRX\", \"StatisticsInfo\", \"Core\", \"CoreEvents\", \"Preferences\", \"CalcStandardStatistics\", \"PatternConsts\", \"Log\"]"
        },
        {
            "content": "The call graph of `RealProject.java` includes several entities that it directly references or interacts with, such as:\n- **Core**\n- **RuntimePreferences**\n- **Preferences**\n- **StaticUtils**\n- **FileUtil**\n- **IRemoteRepository**\n- **FilterMaster**\n- **ITokenizer**\n- **OConsts**\n- **Language**\n- **Log**\n\nThese entities are likely to be more tightly coupled to `RealProject.java` compared to others in the co-change list.\n\n### Summary of Entities That May Need Synchronization\n\nCombining all the information gathered so far, here is a consolidated list of entities that may need synchronization when `RealProject.java` changes:\n\n1. **Co-change + High Conceptual Coupling:**\n   - `TMXWriter.java` (high conceptual coupling and co-change confidence 0.125)\n   \n2. **Call Graph Entities (direct usage):**\n   - `Core.java`\n   - `RuntimePreferences.java`\n   - `Preferences.java`\n   - `StaticUtils.java`\n   - `FileUtil.java`\n   - `FilterMaster.java`\n   - `ITokenizer.java` (interface used)\n   - `OConsts.java`\n   - `Language.java`\n   - `Log.java`\n   - `IRemoteRepository.java`\n\n3. **High Co-change Confidence (even without coupling):**\n   - `Main.java` (highest co-change confidence 0.3125)\n   - `ProjectFactory.java` (confidence 0.125)\n   - `SVNRemoteRepository.java` (confidence 0.09375)\n   - `GITRemoteRepository.java` (confidence 0.09375)\n\n### Next Step\nTo confirm the nature of interactions, we can examine the actual code of `RealProject.java`. This will help us understand how these dependencies are used and whether they are critical for synchronization.\n\nLet\u2019s retrieve the original code of `RealProject.java` using the `get_origin_code` function.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_a14caed6fa544a899f4af2",
                    "function": {
                        "arguments": "{\"entity\": \"RealProject.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package org.omegat.core.data;\\nimport java.io.BufferedReader;\\nimport java.io.BufferedWriter;\\nimport java.io.File;\\nimport java.io.FileInputStream;\\nimport java.io.FileOutputStream;\\nimport java.io.IOException;\\nimport java.io.InputStreamReader;\\nimport java.io.OutputStreamWriter;\\nimport java.io.RandomAccessFile;\\nimport java.nio.channels.FileChannel;\\nimport java.nio.channels.FileLock;\\nimport java.text.SimpleDateFormat;\\nimport java.util.ArrayList;\\nimport java.util.Collections;\\nimport java.util.Date;\\nimport java.util.HashMap;\\nimport java.util.HashSet;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.Set;\\nimport java.util.Stack;\\nimport java.util.TreeMap;\\nimport java.util.logging.Logger;\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\nimport javax.swing.SwingUtilities;\\nimport org.apache.lucene.util.Version;\\nimport org.madlonkay.supertmxmerge.StmProperties;\\nimport org.madlonkay.supertmxmerge.SuperTmxMerge;\\nimport org.omegat.CLIParameters;\\nimport org.omegat.core.Core;\\nimport org.omegat.core.CoreEvents;\\nimport org.omegat.core.KnownException;\\nimport org.omegat.core.data.TMXEntry.ExternalLinked;\\nimport org.omegat.core.events.IProjectEventListener;\\nimport org.omegat.core.segmentation.SRX;\\nimport org.omegat.core.statistics.CalcStandardStatistics;\\nimport org.omegat.core.statistics.Statistics;\\nimport org.omegat.core.statistics.StatisticsInfo;\\nimport org.omegat.core.team.IRemoteRepository;\\nimport org.omegat.core.team.RepositoryUtils;\\nimport org.omegat.core.threads.CommandMonitor;\\nimport org.omegat.filters2.FilterContext;\\nimport org.omegat.filters2.IAlignCallback;\\nimport org.omegat.filters2.IFilter;\\nimport org.omegat.filters2.TranslationException;\\nimport org.omegat.filters2.master.FilterMaster;\\nimport org.omegat.gui.glossary.GlossaryEntry;\\nimport org.omegat.gui.glossary.GlossaryReaderTSV;\\nimport org.omegat.tokenizer.DefaultTokenizer;\\nimport org.omegat.tokenizer.ITokenizer;\\nimport org.omegat.util.DirectoryMonitor;\\nimport org.omegat.util.FileUtil;\\nimport org.omegat.util.Language;\\nimport org.omegat.util.Log;\\nimport org.omegat.util.OConsts;\\nimport org.omegat.util.OStrings;\\nimport org.omegat.util.PatternConsts;\\nimport org.omegat.util.Preferences;\\nimport org.omegat.util.ProjectFileStorage;\\nimport org.omegat.util.RuntimePreferences;\\nimport org.omegat.util.StaticUtils;\\nimport org.omegat.util.StringUtil;\\nimport org.omegat.util.TagUtil;\\nimport org.omegat.util.gui.UIThreadsUtil;\\nimport org.xml.sax.SAXParseException;\\nimport gen.core.filters.Filters;\\npublic class RealProject implements IProject {\\n    private static final Logger LOGGER = Logger.getLogger(RealProject.class.getName());\\n    protected final ProjectProperties m_config;\\n    private final IRemoteRepository repository;\\n    private boolean isOnlineMode;\\n    private RandomAccessFile raFile;\\n    private FileChannel lockChannel;\\n    private FileLock lock;\\n    private boolean m_modifiedFlag;\\n    protected List<SourceTextEntry> allProjectEntries = new ArrayList<SourceTextEntry>(4096);\\n    protected ImportFromAutoTMX importHandler;\\n    private final StatisticsInfo hotStat = new StatisticsInfo();\\n    private final ITokenizer sourceTokenizer, targetTokenizer;\\n    private DirectoryMonitor tmMonitor;\\n    private DirectoryMonitor tmOtherLanguagesMonitor;\\n    private boolean isSaving = false;\\n    private Map<String, ExternalTMX> transMemories = new TreeMap<String, ExternalTMX>();\\n    private Map<Language, ProjectTMX> otherTargetLangTMs = new TreeMap<Language, ProjectTMX>();\\n    protected ProjectTMX projectTMX;\\n    private boolean loaded = false;\\n        private Set<String> existSource = new HashSet<String>();\\n    private Set<EntryKey> existKeys = new HashSet<EntryKey>();\\n    protected List<FileInfo> projectFilesList = new ArrayList<FileInfo>();\\n    private final TMXEntry EMPTY_TRANSLATION;\\n    private boolean allowTranslationEqualToSource = Preferences.isPreference(Preferences.ALLOW_TRANS_EQUAL_TO_SRC);\\n    private Stack<Process> processCache = new Stack<Process>();\\n    public RealProject(final ProjectProperties props) {\\n        this(props, null);\\n    }\\n    public RealProject(final ProjectProperties props, IRemoteRepository repository) {\\n        PrepareTMXEntry empty = new PrepareTMXEntry();\\n        empty.source = \\\"\\\";\\n        EMPTY_TRANSLATION = new TMXEntry(empty, true, null);\\n        m_config = props;\\n        this.repository = repository;\\n        sourceTokenizer = createTokenizer(Core.getParams().get(CLIParameters.TOKENIZER_SOURCE), props.getSourceTokenizer());\\n        configTokenizer(Core.getParams().get(CLIParameters.TOKENIZER_BEHAVIOR_SOURCE), sourceTokenizer);\\n        Log.log(\\\"Source tokenizer: \\\" + sourceTokenizer.getClass().getName() + \\\" (\\\" + sourceTokenizer.getBehavior() + \\\")\\\");\\n        targetTokenizer = createTokenizer(Core.getParams().get(CLIParameters.TOKENIZER_TARGET), props.getTargetTokenizer());\\n        configTokenizer(Core.getParams().get(CLIParameters.TOKENIZER_BEHAVIOR_TARGET), targetTokenizer);\\n        Log.log(\\\"Target tokenizer: \\\" + targetTokenizer.getClass().getName() + \\\" (\\\" + targetTokenizer.getBehavior() + \\\")\\\");\\n    }\\n    public IRemoteRepository getRepository() {\\n        return repository;\\n    }\\n    public void saveProjectProperties() throws Exception {\\n        unlockProject();\\n        try {\\n            ProjectFileStorage.writeProjectFile(m_config);\\n        } finally {\\n            lockProject();\\n        }\\n        Preferences.setPreference(Preferences.SOURCE_LOCALE, m_config.getSourceLanguage().toString());\\n        Preferences.setPreference(Preferences.TARGET_LOCALE, m_config.getTargetLanguage().toString());\\n    }\\n    public void createProject() {\\n        Log.logInfoRB(\\\"LOG_DATAENGINE_CREATE_START\\\");\\n        UIThreadsUtil.mustNotBeSwingThread();\\n        try {\\n            if (!lockProject()) {\\n                throw new KnownException(\\\"PROJECT_LOCKED\\\");\\n            }\\n            createDirectory(m_config.getProjectRoot(), null);\\n            createDirectory(m_config.getProjectInternal(), OConsts.DEFAULT_INTERNAL);\\n            createDirectory(m_config.getSourceRoot(), OConsts.DEFAULT_SOURCE);\\n            createDirectory(m_config.getGlossaryRoot(), OConsts.DEFAULT_GLOSSARY);\\n            createDirectory(m_config.getTMRoot(), OConsts.DEFAULT_TM);\\n            createDirectory(m_config.getTMAutoRoot(), OConsts.AUTO_TM);\\n            createDirectory(m_config.getDictRoot(), OConsts.DEFAULT_DICT);\\n            createDirectory(m_config.getTargetRoot(), OConsts.DEFAULT_TARGET);\\n            saveProjectProperties();\\n                                    SRX srx = m_config.getProjectSRX();\\n            Core.getSegmenter().setSRX(srx == null ? Preferences.getSRX() : srx);\\n            loadTranslations();\\n            setProjectModified(true);\\n            saveProject(false);\\n            allProjectEntries = Collections.unmodifiableList(allProjectEntries);\\n            importHandler = new ImportFromAutoTMX(this, allProjectEntries);\\n            loadTM();\\n            loadOtherLanguages();\\n            loaded = true;\\n                        Core.getMainWindow().showStatusMessageRB(null);\\n        } catch (Exception e) {\\n                        Log.logErrorRB(e, \\\"CT_ERROR_CREATING_PROJECT\\\");\\n            Core.getMainWindow().displayErrorRB(e, \\\"CT_ERROR_CREATING_PROJECT\\\");\\n        }\\n        Log.logInfoRB(\\\"LOG_DATAENGINE_CREATE_END\\\");\\n    }\\n    public void loadProject(boolean onlineMode) {\\n        Log.logInfoRB(\\\"LOG_DATAENGINE_LOAD_START\\\");\\n        UIThreadsUtil.mustNotBeSwingThread();\\n                try {\\n            if (!lockProject()) {\\n                throw new KnownException(\\\"PROJECT_LOCKED\\\");\\n            }\\n            isOnlineMode = onlineMode;\\n            if (RuntimePreferences.isLocationSaveEnabled()) {\\n                Preferences.setPreference(Preferences.CURRENT_FOLDER, new File(m_config.getProjectRoot())\\n                        .getParentFile().getAbsolutePath());\\n                Preferences.save();\\n            }\\n            Core.getMainWindow().showStatusMessageRB(\\\"CT_LOADING_PROJECT\\\");\\n                        Filters filterMasterConfig = FilterMaster.loadConfig(m_config.getProjectInternal());\\n            if (filterMasterConfig == null) {\\n                filterMasterConfig = FilterMaster.loadConfig(StaticUtils.getConfigDir());\\n            }\\n            if (filterMasterConfig == null) {\\n                filterMasterConfig = FilterMaster.createDefaultFiltersConfig();\\n            }\\n            Core.setFilterMaster(new FilterMaster(filterMasterConfig));\\n            EntryKey.setIgnoreFileContext(filterMasterConfig.isIgnoreFileContext());\\n                                    SRX srx = m_config.getProjectSRX();\\n            Core.getSegmenter().setSRX(srx == null ? Preferences.getSRX() : srx);\\n            loadSourceFiles();\\n            loadTranslations();\\n            allProjectEntries = Collections.unmodifiableList(allProjectEntries);\\n            importHandler = new ImportFromAutoTMX(this, allProjectEntries);\\n            importTranslationsFromSources();\\n            loadTM();\\n            loadOtherLanguages();\\n                        String stat = CalcStandardStatistics.buildProjectStats(this, hotStat);\\n            String fn = m_config.getProjectInternal() + OConsts.STATS_FILENAME;\\n            Statistics.writeStat(fn, stat);\\n            loaded = true;\\n                        Core.getMainWindow().showStatusMessageRB(null);\\n            setProjectModified(false);\\n        } catch (Exception e) {\\n            Log.logErrorRB(e, \\\"TF_LOAD_ERROR\\\");\\n            Core.getMainWindow().displayErrorRB(e, \\\"TF_LOAD_ERROR\\\");\\n            if (!loaded) {\\n                unlockProject();\\n            }\\n        }\\n                        catch (OutOfMemoryError oome) {\\n                                                            allProjectEntries.clear();\\n            projectFilesList.clear();\\n            transMemories.clear();\\n            projectTMX = null;\\n                        System.gc();\\n                        long memory = Runtime.getRuntime().maxMemory() / 1024 / 1024;\\n            Log.logErrorRB(\\\"OUT_OF_MEMORY\\\", memory);\\n            Log.log(oome);\\n            Core.getMainWindow().showErrorDialogRB(\\\"TF_ERROR\\\", \\\"OUT_OF_MEMORY\\\", memory);\\n                        System.exit(0);\\n        }\\n        Log.logInfoRB(\\\"LOG_DATAENGINE_LOAD_END\\\");\\n    }\\n    public Map<String, TMXEntry> align(final ProjectProperties props, final File translatedDir)\\n            throws Exception {\\n        FilterMaster fm = Core.getFilterMaster();\\n        File root = new File(m_config.getSourceRoot());\\n        List<File> srcFileList = StaticUtils.buildFileList(root, true);\\n        AlignFilesCallback alignFilesCallback = new AlignFilesCallback(props);\\n        String srcRoot = m_config.getSourceRoot();\\n        for (File file : srcFileList) {\\n                        String midName = file.getPath().substring(srcRoot.length());\\n            fm.alignFile(srcRoot, midName, translatedDir.getPath(), new FilterContext(props),\\n                    alignFilesCallback);\\n        }\\n        return alignFilesCallback.data;\\n    }\\n    public boolean isProjectLoaded() {\\n        return loaded;\\n    }\\n    public StatisticsInfo getStatistics() {\\n        return hotStat;\\n    }\\n    public void closeProject() {\\n        loaded = false;\\n        flushProcessCache();\\n        tmMonitor.fin();\\n        tmOtherLanguagesMonitor.fin();\\n        unlockProject();\\n        Log.logInfoRB(\\\"LOG_DATAENGINE_CLOSE\\\");\\n    }\\n    protected boolean lockProject() {\\n        if (!RuntimePreferences.isProjectLockingEnabled()) {\\n            return true;\\n        }\\n        if (repository != null) {\\n            if (!repository.isFilesLockingAllowed()) {\\n                return true;\\n            }\\n        }\\n        try {\\n            File lockFile = new File(m_config.getProjectRoot(), OConsts.FILE_PROJECT);\\n            raFile = new RandomAccessFile(lockFile, \\\"rw\\\");\\n            lockChannel = raFile.getChannel();\\n            lock = lockChannel.tryLock();\\n        } catch (Throwable ex) {\\n            Log.log(ex);\\n        }\\n        if (lock == null) {\\n            try {\\n                lockChannel.close();\\n            } catch (Throwable ex) {\\n            }\\n            lockChannel = null;\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n    protected void unlockProject() {\\n        if (!RuntimePreferences.isProjectLockingEnabled()) {\\n            return;\\n        }\\n        if (repository != null) {\\n            if (!repository.isFilesLockingAllowed()) {\\n                return;\\n            }\\n        }\\n        try {\\n            if (lock != null) {\\n                lock.release();\\n            }\\n            if (lockChannel != null) {\\n                lockChannel.close();\\n            }\\n            if (raFile != null) {\\n                raFile.close();\\n            }\\n        } catch (Throwable ex) {\\n            Log.log(ex);\\n        }\\n    }\\n    public void compileProject(String sourcePattern) throws IOException, TranslationException {\\n        compileProject(sourcePattern, true);\\n    }\\n    public void compileProject(String sourcePattern, boolean doPostProcessing) throws IOException, TranslationException {\\n        Log.logInfoRB(\\\"LOG_DATAENGINE_COMPILE_START\\\");\\n        UIThreadsUtil.mustNotBeSwingThread();\\n        Pattern FILE_PATTERN = Pattern.compile(sourcePattern);\\n                                        try {\\n                        String fname = m_config.getProjectRoot() + m_config.getProjectName() + OConsts.OMEGAT_TMX\\n                    + OConsts.TMX_EXTENSION;\\n            projectTMX.exportTMX(m_config, new File(fname), false, false, false);\\n                        fname = m_config.getProjectRoot() + m_config.getProjectName() + OConsts.LEVEL1_TMX\\n                    + OConsts.TMX_EXTENSION;\\n            projectTMX.exportTMX(m_config, new File(fname), true, false, false);\\n                        fname = m_config.getProjectRoot() + m_config.getProjectName() + OConsts.LEVEL2_TMX\\n                    + OConsts.TMX_EXTENSION;\\n            projectTMX.exportTMX(m_config, new File(fname), false, true, false);\\n        } catch (Exception e) {\\n            Log.logErrorRB(\\\"CT_ERROR_CREATING_TMX\\\");\\n            Log.log(e);\\n            throw new IOException(OStrings.getString(\\\"CT_ERROR_CREATING_TMX\\\") + \\\"\\\\n\\\" + e.getMessage());\\n        }\\n        String srcRoot = m_config.getSourceRoot();\\n        String locRoot = m_config.getTargetRoot();\\n                FilterMaster fm = Core.getFilterMaster();\\n        List<File> fileList;\\n        try {\\n            fileList = StaticUtils.buildFileList(new File(srcRoot), true);\\n        } catch (Exception e) {\\n            Log.logErrorRB(\\\"CT_ERROR_CREATING_TMX\\\");\\n            Log.log(e);\\n            throw new IOException(OStrings.getString(\\\"CT_ERROR_CREATING_TMX\\\") + \\\"\\\\n\\\" + e.getMessage());\\n        }\\n        List<String> pathList = new ArrayList<String>(fileList.size());\\n        for (File file : fileList) {\\n            pathList.add(file.getPath().substring(m_config.getSourceRoot().length()).replace('\\\\\\\\', '/'));\\n        }\\n        StaticUtils.removeFilesByMasks(pathList, m_config.getSourceRootExcludes());\\n        TranslateFilesCallback translateFilesCallback = new TranslateFilesCallback();\\n        int numberOfCompiled = 0;\\n        for (String midName : pathList) {\\n                        Matcher fileMatch = FILE_PATTERN.matcher(midName);\\n            if (fileMatch.matches()) {\\n                File fn = new File(locRoot, midName);\\n                if (!fn.getParentFile().exists()) {\\n                                        if (!fn.getParentFile().mkdirs()) {\\n                        throw new IOException(OStrings.getString(\\\"CT_ERROR_CREATING_TARGET_DIR\\\") + fn.getParentFile());\\n                    }\\n                }\\n                Core.getMainWindow().showStatusMessageRB(\\\"CT_COMPILE_FILE_MX\\\", midName);\\n                translateFilesCallback.fileStarted(midName);\\n                fm.translateFile(srcRoot, midName, locRoot, new FilterContext(m_config),\\n                        translateFilesCallback);\\n                translateFilesCallback.fileFinished();\\n                numberOfCompiled++;\\n            }\\n        }\\n        if (numberOfCompiled == 1) {\\n            Core.getMainWindow().showStatusMessageRB(\\\"CT_COMPILE_DONE_MX_SINGULAR\\\");\\n        } else {\\n            Core.getMainWindow().showStatusMessageRB(\\\"CT_COMPILE_DONE_MX\\\");\\n        }\\n        CoreEvents.fireProjectChange(IProjectEventListener.PROJECT_CHANGE_TYPE.COMPILE);\\n        if (doPostProcessing) {\\n                        flushProcessCache();\\n            if (Preferences.isPreference(Preferences.ALLOW_PROJECT_EXTERN_CMD)) {\\n                doExternalCommand(m_config.getExternalCommand());\\n            }\\n            doExternalCommand(Preferences.getPreference(Preferences.EXTERNAL_COMMAND));\\n        }\\n        Log.logInfoRB(\\\"LOG_DATAENGINE_COMPILE_END\\\");\\n    }\\n    private void doExternalCommand(String command) {\\n        if (StringUtil.isEmpty(command)) {\\n            return;\\n        }\\n        Core.getMainWindow().showStatusMessageRB(\\\"CT_START_EXTERNAL_CMD\\\");\\n        CommandVarExpansion expander = new CommandVarExpansion(command);\\n        command = expander.expandVariables(m_config);\\n        Log.log(\\\"Executing command: \\\" + command);\\n        try {\\n            Process p = Runtime.getRuntime().exec(StaticUtils.parseCLICommand(command));\\n            processCache.push(p);\\n            CommandMonitor stdout = CommandMonitor.newStdoutMonitor(p);\\n            CommandMonitor stderr = CommandMonitor.newStderrMonitor(p);\\n            stdout.start();\\n            stderr.start();\\n        } catch (IOException e) {\\n            String message;\\n            Throwable cause = e.getCause();\\n            if (cause == null) {\\n                message = e.getLocalizedMessage();\\n            } else {\\n                message = cause.getLocalizedMessage();\\n            }\\n            Core.getMainWindow().showStatusMessageRB(\\\"CT_ERROR_STARTING_EXTERNAL_CMD\\\", message);\\n        }\\n    }\\n    private void flushProcessCache() {\\n        while (!processCache.isEmpty()) {\\n            Process p = processCache.pop();\\n            try {\\n                p.exitValue();\\n            } catch (IllegalThreadStateException ex) {\\n                p.destroy();\\n            }\\n        }\\n    }\\n    public synchronized void saveProject() {\\n        saveProject(true);\\n    }\\n    public synchronized void saveProject(boolean doTeamSync) {\\n        if (isSaving) {\\n            return;\\n        }\\n        isSaving = true;\\n        Log.logInfoRB(\\\"LOG_DATAENGINE_SAVE_START\\\");\\n        UIThreadsUtil.mustNotBeSwingThread();\\n        Core.getAutoSave().disable();\\n        try {\\n            Core.getMainWindow().getMainMenu().getProjectMenu().setEnabled(false);\\n            try {\\n                Preferences.save();\\n                String s = m_config.getProjectInternal() + OConsts.STATUS_EXTENSION;\\n                try {\\n                    saveProjectProperties();\\n                    projectTMX.save(m_config, s, isProjectModified());\\n                    if (repository != null && doTeamSync) {\\n                        Core.getMainWindow().showStatusMessageRB(\\\"TEAM_SYNCHRONIZE\\\");\\n                        rebaseProject();\\n                    }\\n                    setProjectModified(false);\\n                } catch (KnownException ex) {\\n                    throw ex;\\n                } catch (Exception e) {\\n                    Log.logErrorRB(e, \\\"CT_ERROR_SAVING_PROJ\\\");\\n                    Core.getMainWindow().displayErrorRB(e, \\\"CT_ERROR_SAVING_PROJ\\\");\\n                }\\n                LastSegmentManager.saveLastSegment();\\n                                String stat = CalcStandardStatistics.buildProjectStats(this, hotStat);\\n                String fn = m_config.getProjectInternal() + OConsts.STATS_FILENAME;\\n                Statistics.writeStat(fn, stat);\\n            } finally {\\n                Core.getMainWindow().getMainMenu().getProjectMenu().setEnabled(true);\\n            }\\n            CoreEvents.fireProjectChange(IProjectEventListener.PROJECT_CHANGE_TYPE.SAVE);\\n        } finally {\\n            Core.getAutoSave().enable();\\n        }\\n        Log.logInfoRB(\\\"LOG_DATAENGINE_SAVE_END\\\");\\n        isSaving = false;\\n    }\\n    private void rebaseProject() throws Exception {\\n        File filenameTMXwithLocalChangesOnBase, filenameTMXwithLocalChangesOnHead;\\n        ProjectTMX baseTMX, headTMX;\\n        File filenameGlossarywithLocalChangesOnBase, filenameGlossarywithLocalChangesOnHead;\\n        List<GlossaryEntry> glossaryEntries = null;\\n        List<GlossaryEntry> baseGlossaryEntries = null;\\n        List<GlossaryEntry> headGlossaryEntries = null;\\n        final boolean updateGlossary;\\n        Log.logInfoRB(\\\"TEAM_REBASE_START\\\");\\n        final String projectTMXFilename = m_config.getProjectInternal() + OConsts.STATUS_EXTENSION;\\n        final File projectTMXFile = new File(projectTMXFilename);\\n                File[] modifiedFiles;\\n                boolean needUpload = false;\\n        final StringBuilder commitDetails = new StringBuilder();\\n        final String glossaryFilename = m_config.getWriteableGlossary();\\n        final File glossaryFile = new File(glossaryFilename);\\n                                        if (repository.isUnderVersionControl(glossaryFile)) {\\n            Log.logDebug(LOGGER, \\\"rebaseProject: glossary file {0} is under version control\\\", glossaryFile);\\n                        modifiedFiles = new File[]{projectTMXFile, glossaryFile};\\n            updateGlossary = true;\\n        } else {\\n            Log.logDebug(LOGGER, \\\"rebaseProject: glossary file {0} is not under version control\\\", glossaryFile);\\n            modifiedFiles = new File[]{projectTMXFile};\\n            updateGlossary = false;\\n        }\\n        if (isProjectModified() || repository.isChanged(glossaryFile) || repository.isChanged(projectTMXFile)) {\\n            needUpload = true;\\n        }\\n        while (true) {\\n            boolean again = false;\\n            if (updateGlossary) {\\n                                glossaryEntries = GlossaryReaderTSV.read(glossaryFile, true);\\n            }\\n                        String baseRevTMX = repository.getBaseRevisionId(projectTMXFile);\\n            Log.logDebug(LOGGER, \\\"rebaseProject: TMX base revision: {0}\\\", baseRevTMX);\\n            String baseRevGlossary = null;\\n            if (updateGlossary) {\\n                baseRevGlossary = repository.getBaseRevisionId(glossaryFile);\\n                Log.logDebug(LOGGER, \\\"rebaseProject: glossary base revision: {0}\\\", baseRevGlossary);\\n            }\\n                                    filenameTMXwithLocalChangesOnBase = new File(projectTMXFilename + \\\"-based_on_\\\" + baseRevTMX + OConsts.NEWFILE_EXTENSION);\\n            filenameGlossarywithLocalChangesOnBase = null;\\n            projectTMX.exportTMX(m_config, filenameTMXwithLocalChangesOnBase, false, false, true);             if (System.getProperty(\\\"team.supersafe\\\") != null) {\\n                                File bak = new File(projectTMXFilename + \\\"-based_on_\\\" + baseRevTMX + \\\"_at_\\\"\\n                        + new SimpleDateFormat(\\\"MMdd-HHmmss\\\").format(new Date()) + OConsts.BACKUP_EXTENSION);\\n                projectTMX.exportTMX(m_config, bak, false, false, true);\\n            }\\n            if (updateGlossary) {\\n                filenameGlossarywithLocalChangesOnBase = new File(glossaryFilename + \\\"-based_on_\\\" + baseRevGlossary + OConsts.NEWFILE_EXTENSION);\\n                if (filenameGlossarywithLocalChangesOnBase.exists()) {\\n                                        filenameGlossarywithLocalChangesOnBase.delete();\\n                }\\n                filenameGlossarywithLocalChangesOnBase.createNewFile();\\n                for (GlossaryEntry ge : glossaryEntries) {\\n                    GlossaryReaderTSV.append(filenameGlossarywithLocalChangesOnBase, ge);\\n                }\\n            }\\n                        repository.restoreBase(modifiedFiles);\\n                        baseTMX = new ProjectTMX(m_config.getSourceLanguage(), m_config.getTargetLanguage(), m_config.isSentenceSegmentingEnabled(), projectTMXFile, null);\\n            if (updateGlossary) {\\n                baseGlossaryEntries = GlossaryReaderTSV.read(glossaryFile, true);\\n            }\\n                                                                                    unlockProject();             try {\\n                repository.reset();\\n            } finally {\\n                lockProject();             }\\n                        try {\\n                                                repository.download(modifiedFiles);\\n                                setOnlineMode();\\n            } catch (IRemoteRepository.NetworkException ex) {\\n                                setOfflineMode();\\n                                needUpload = false;\\n                            } catch (Exception ex) {\\n                                needUpload = false;\\n                            }\\n            String headRevTMX = repository.getBaseRevisionId(projectTMXFile);\\n            Log.logDebug(LOGGER, \\\"rebaseProject: TMX head revision: {0}\\\", headRevTMX);\\n            if (headRevTMX.equals(baseRevTMX)) {\\n                Log.logDebug(LOGGER, \\\"rebaseProject: head equals base\\\");\\n                                filenameTMXwithLocalChangesOnHead = filenameTMXwithLocalChangesOnBase;\\n                filenameTMXwithLocalChangesOnBase = null;\\n                                baseTMX = null;\\n            } else {\\n                Log.logDebug(LOGGER, \\\"rebaseProject: real rebase\\\");\\n                                again = true;\\n                headTMX = new ProjectTMX(m_config.getSourceLanguage(), m_config.getTargetLanguage(), m_config.isSentenceSegmentingEnabled(), projectTMXFile, null);\\n                mergeTMX(baseTMX, headTMX, commitDetails);\\n                                SwingUtilities.invokeAndWait(new Runnable() {\\n                    @Override\\n                    public void run() {\\n                        Core.getEditor().refreshView(false);\\n                    }\\n                });\\n                filenameTMXwithLocalChangesOnHead = new File(projectTMXFilename + \\\"-based_on_\\\" + headRevTMX + OConsts.NEWFILE_EXTENSION);\\n                projectTMX.exportTMX(m_config, filenameTMXwithLocalChangesOnHead, false, false, true);\\n                if (System.getProperty(\\\"team.supersafe\\\") != null) {\\n                                        File bak = new File(projectTMXFilename + \\\"-merged_on_\\\" + headRevTMX + \\\"_at_\\\"\\n                            + new SimpleDateFormat(\\\"MMdd-HHmmss\\\").format(new Date())\\n                            + OConsts.BACKUP_EXTENSION);\\n                    projectTMX.exportTMX(m_config, bak, false, false, true);\\n                }\\n                                headTMX = null;\\n            }\\n            if (updateGlossary) {\\n                String headRevGlossary = repository.getBaseRevisionId(glossaryFile);\\n                Log.logDebug(LOGGER, \\\"rebaseProject: glossary head revision: {0}\\\", headRevGlossary);\\n                if (headRevGlossary.equals(baseRevGlossary)) {\\n                                        filenameGlossarywithLocalChangesOnHead = filenameGlossarywithLocalChangesOnBase;\\n                    filenameGlossarywithLocalChangesOnBase = null;\\n                                        baseGlossaryEntries = null;\\n                } else {\\n                    again = true;\\n                    headGlossaryEntries = GlossaryReaderTSV.read(glossaryFile, true);\\n                    List<GlossaryEntry> deltaAddedGlossaryLocal = new ArrayList<GlossaryEntry>(glossaryEntries);\\n                    deltaAddedGlossaryLocal.removeAll(baseGlossaryEntries);\\n                    List<GlossaryEntry> deltaRemovedGlossaryLocal = new ArrayList<GlossaryEntry>(baseGlossaryEntries);\\n                    deltaRemovedGlossaryLocal.removeAll(glossaryEntries);\\n                    headGlossaryEntries.addAll(deltaAddedGlossaryLocal);\\n                    headGlossaryEntries.removeAll(deltaRemovedGlossaryLocal);\\n                    filenameGlossarywithLocalChangesOnHead = new File(glossaryFilename + \\\"-based_on_\\\" + headRevGlossary + OConsts.NEWFILE_EXTENSION);\\n                    filenameGlossarywithLocalChangesOnHead.createNewFile();\\n                    for (GlossaryEntry ge : headGlossaryEntries) {\\n                        GlossaryReaderTSV.append(filenameGlossarywithLocalChangesOnHead, ge);\\n                    }\\n                                        headGlossaryEntries = null;\\n                    baseGlossaryEntries = null;\\n                }\\n            } else {\\n                filenameGlossarywithLocalChangesOnHead = null;\\n            }\\n            projectTMXFile.delete();                         FileUtil.rename(filenameTMXwithLocalChangesOnHead, projectTMXFile);\\n            if (filenameTMXwithLocalChangesOnBase != null) {\\n                                if (!filenameTMXwithLocalChangesOnBase.delete()) {\\n                    throw new IOException(\\\"Error remove old file\\\");\\n                }\\n            }\\n            if (updateGlossary) {\\n                glossaryFile.delete();\\n                FileUtil.rename(filenameGlossarywithLocalChangesOnHead, glossaryFile);\\n                if (filenameGlossarywithLocalChangesOnBase != null) {\\n                                        if (!filenameGlossarywithLocalChangesOnBase.delete()) {\\n                        throw new IOException(\\\"Error remove old glossary file\\\");\\n                    }\\n                }\\n            }\\n            if (!again) {\\n                                glossaryEntries = null;\\n                break;\\n            }\\n        }\\n                if (needUpload) {\\n            final String author = Preferences.getPreferenceDefault(Preferences.TEAM_AUTHOR,\\n                    System.getProperty(\\\"user.name\\\"));\\n            try {\\n                new RepositoryUtils.AskCredentials() {\\n                    public void callRepository() throws Exception {\\n                        repository.upload(projectTMXFile,\\n                                \\\"Translated by \\\" + author + commitDetails.toString());\\n                        if (updateGlossary) {\\n                            repository.upload(glossaryFile, \\\"Added glossaryitem(s) by \\\" + author);\\n                        }\\n                    }\\n                }.execute(repository);\\n                setOnlineMode();\\n            } catch (IRemoteRepository.NetworkException ex) {\\n                setOfflineMode();\\n            } catch (Exception ex) {\\n                throw new KnownException(ex, \\\"TEAM_SYNCHRONIZATION_ERROR\\\");\\n            }\\n        }\\n        Log.logInfoRB(\\\"TEAM_REBASE_END\\\");\\n    }\\n    protected void mergeTMX(ProjectTMX baseTMX, ProjectTMX headTMX, StringBuilder commitDetails) {\\n        StmProperties props = new StmProperties().setBaseTmxName(OStrings.getString(\\\"TMX_MERGE_BASE\\\"))\\n                .setTmx1Name(OStrings.getString(\\\"TMX_MERGE_MINE\\\"))\\n                .setTmx2Name(OStrings.getString(\\\"TMX_MERGE_THEIRS\\\"))\\n                .setLanguageResource(OStrings.getResourceBundle())\\n                .setParentWindow(Core.getMainWindow().getApplicationFrame())\\n                                .setListViewThreshold(5);\\n        ProjectTMX mergedTMX = SuperTmxMerge.merge(baseTMX, projectTMX, headTMX, m_config.getSourceLanguage()\\n                .getLanguage(), m_config.getTargetLanguage().getLanguage(), props);\\n        projectTMX.replaceContent(mergedTMX);\\n        Log.logDebug(LOGGER, \\\"Merge report: {0}\\\", props.getReport());\\n        commitDetails.append('\\\\n');\\n        commitDetails.append(props.getReport().toString());\\n    }\\n    private void createDirectory(final String dir, final String dirType) throws IOException {\\n        File d = new File(dir);\\n        if (!d.isDirectory()) {\\n            if (!d.mkdirs()) {\\n                StringBuilder msg = new StringBuilder(OStrings.getString(\\\"CT_ERROR_CREATE\\\"));\\n                if (dirType != null) {\\n                    msg.append(\\\"\\\\n(.../\\\").append(dirType).append(\\\"/)\\\");\\n                }\\n                throw new IOException(msg.toString());\\n            }\\n        }\\n    }\\n    private void loadTranslations() throws Exception {\\n        final File tmxFile = new File(m_config.getProjectInternal() + OConsts.STATUS_EXTENSION);\\n        try {\\n            Core.getMainWindow().showStatusMessageRB(\\\"CT_LOAD_TMX\\\");\\n            projectTMX = new ProjectTMX(m_config.getSourceLanguage(), m_config.getTargetLanguage(), m_config.isSentenceSegmentingEnabled(), tmxFile, checkOrphanedCallback);\\n            if (tmxFile.exists()) {\\n                                FileUtil.backupFile(tmxFile);\\n                FileUtil.removeOldBackups(tmxFile, System.getProperty(\\\"team.supersafe\\\") != null ? 300\\n                        : OConsts.MAX_BACKUPS);\\n            }\\n        } catch (SAXParseException ex) {\\n            Log.logErrorRB(ex, \\\"TMXR_FATAL_ERROR_WHILE_PARSING\\\", ex.getLineNumber(), ex.getColumnNumber());\\n            throw ex;\\n        } catch (Exception ex) {\\n            Log.logErrorRB(ex, \\\"TMXR_EXCEPTION_WHILE_PARSING\\\", tmxFile.getAbsolutePath(),\\n                    Log.getLogLocation());\\n            throw ex;\\n        }\\n    }\\n    private void loadSourceFiles() throws Exception {\\n        long st = System.currentTimeMillis();\\n        FilterMaster fm = Core.getFilterMaster();\\n        File root = new File(m_config.getSourceRoot());\\n        List<File> srcFileList = StaticUtils.buildFileList(root, true);\\n        List<String> srcPathList = new ArrayList<String>(srcFileList.size());\\n        for (File file : srcFileList) {\\n            srcPathList.add(file.getPath().substring(m_config.getSourceRoot().length()).replace('\\\\\\\\', '/'));\\n        }\\n        StaticUtils.removeFilesByMasks(srcPathList, m_config.getSourceRootExcludes());\\n        StaticUtils.sortByList(srcPathList, getSourceFilesOrder());\\n        for (String filepath : srcPathList) {\\n            Core.getMainWindow().showStatusMessageRB(\\\"CT_LOAD_FILE_MX\\\", filepath);\\n            LoadFilesCallback loadFilesCallback = new LoadFilesCallback(existSource, existKeys);\\n            FileInfo fi = new FileInfo();\\n            fi.filePath = filepath;\\n            loadFilesCallback.setCurrentFile(fi);\\n            IFilter filter = fm.loadFile(m_config.getSourceRoot() + filepath, new FilterContext(m_config),\\n                    loadFilesCallback);\\n            loadFilesCallback.fileFinished();\\n            if (filter != null && !fi.entries.isEmpty()) {\\n                fi.filterClass = filter.getClass();                                                                                                                         fi.filterFileFormatName = filter.getFileFormatName();\\n                try {\\n                    fi.fileEncoding = filter.getInEncodingLastParsedFile();\\n                } catch (Error e) {                     fi.fileEncoding = \\\"\\\";\\n                }\\n                projectFilesList.add(fi);\\n            }\\n        }\\n        findNonUniqueSegments();\\n        Core.getMainWindow().showStatusMessageRB(\\\"CT_LOAD_SRC_COMPLETE\\\");\\n        long en = System.currentTimeMillis();\\n        Log.log(\\\"Load project source files: \\\" + (en - st) + \\\"ms\\\");\\n    }\\n    protected void findNonUniqueSegments() {\\n        Map<String, SourceTextEntry> exists = new HashMap<String, SourceTextEntry>(16384);\\n        for (FileInfo fi : projectFilesList) {\\n            for (int i = 0; i < fi.entries.size(); i++) {\\n                SourceTextEntry ste = fi.entries.get(i);\\n                SourceTextEntry prevSte = exists.get(ste.getSrcText());\\n                if (prevSte == null) {\\n                                        exists.put(ste.getSrcText(), ste);\\n                } else {\\n                                        if (prevSte.duplicates == null) {\\n                        prevSte.duplicates = new ArrayList<SourceTextEntry>();\\n                    }\\n                    prevSte.duplicates.add(ste);\\n                    ste.firstInstance = prevSte;\\n                }\\n            }\\n        }\\n    }\\n    void importTranslationsFromSources() {\\n                        Map<String, String> allowToImport = new HashMap<String, String>();\\n        for (FileInfo fi : projectFilesList) {\\n            for (int i = 0; i < fi.entries.size(); i++) {\\n                SourceTextEntry ste = fi.entries.get(i);\\n                if (ste.getSourceTranslation() == null || ste.isSourceTranslationFuzzy() ||\\n                   ste.getSrcText().equals(ste.getSourceTranslation()) && !allowTranslationEqualToSource) {\\n                                                            continue;\\n                }\\n                PrepareTMXEntry prepare = new PrepareTMXEntry();\\n                prepare.source = ste.getSrcText();\\n                                if (m_config.isSupportDefaultTranslations()) {\\n                                        TMXEntry enDefault = projectTMX.getDefaultTranslation(ste.getSrcText());\\n                    if (enDefault == null) {\\n                                                prepare.translation = ste.getSourceTranslation();\\n                        projectTMX.setTranslation(ste, new TMXEntry(prepare, true, null), true);\\n                        allowToImport.put(ste.getSrcText(), ste.getSourceTranslation());\\n                    } else {\\n                                                                        String justImported = allowToImport.get(ste.getSrcText());\\n                                                if (justImported != null && !ste.getSourceTranslation().equals(justImported)) {\\n                                                                                    prepare.translation = ste.getSourceTranslation();\\n                            projectTMX.setTranslation(ste, new TMXEntry(prepare, false, null), false);\\n                        }\\n                    }\\n                } else {                                         TMXEntry en = projectTMX.getMultipleTranslation(ste.getKey());\\n                    if (en == null) {\\n                                                prepare.translation = ste.getSourceTranslation();\\n                        projectTMX.setTranslation(ste, new TMXEntry(prepare, false, null), false);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    private void loadTM() throws IOException {\\n        final File tmRoot = new File(m_config.getTMRoot());\\n        tmMonitor = new DirectoryMonitor(tmRoot, new DirectoryMonitor.Callback() {\\n            public void fileChanged(File file) {\\n                if (!file.getName().endsWith(OConsts.TMX_EXTENSION)\\n                        && !file.getName().endsWith(OConsts.TMX_GZ_EXTENSION)) {\\n                                        return;\\n                }\\n                if (file.getPath().startsWith(m_config.getTMOtherLangRoot()) ) {\\n                                        return;\\n                }\\n                                Map<String, ExternalTMX> newTransMemories = new TreeMap<String, ExternalTMX>(transMemories);\\n                if (file.exists()) {\\n                    try {\\n                        ExternalTMX newTMX = new ExternalTMX(m_config, file,\\n                                Preferences.isPreference(Preferences.EXT_TMX_SHOW_LEVEL2),\\n                                Preferences.isPreference(Preferences.EXT_TMX_USE_SLASH));\\n                        newTransMemories.put(file.getPath(), newTMX);\\n                                                                                                                        if (FileUtil.computeRelativePath(tmRoot, file).startsWith(OConsts.AUTO_TM + \\\"/\\\")) {                         \\n                            appendFromAutoTMX(newTMX, false);\\n                        } else if (FileUtil.computeRelativePath(tmRoot, file).startsWith(OConsts.AUTO_ENFORCE_TM + '/')) {\\n                            appendFromAutoTMX(newTMX, true);\\n                        }                          \\n                    } catch (Exception e) {\\n                        String filename = file.getPath();\\n                        Log.logErrorRB(e, \\\"TF_TM_LOAD_ERROR\\\", filename);\\n                        Core.getMainWindow().displayErrorRB(e, \\\"TF_TM_LOAD_ERROR\\\", filename);\\n                    }\\n                } else {\\n                    newTransMemories.remove(file.getPath());\\n                }\\n                transMemories = newTransMemories;\\n            }\\n        });\\n        tmMonitor.checkChanges();\\n        tmMonitor.start();\\n    }\\n    private void loadOtherLanguages() throws IOException {\\n        final File tmOtherLanguagesRoot = new File(m_config.getTMOtherLangRoot());\\n        tmOtherLanguagesMonitor = new DirectoryMonitor(tmOtherLanguagesRoot, new DirectoryMonitor.Callback() {\\n            public void fileChanged(File file) {\\n                if (!file.getName().matches(\\\"[A-Z]{2}([-_][A-Z]{2})?\\\\\\\\.tmx\\\")) {\\n                                        return;\\n                }\\n                Language targetLanguage = new Language(file.getName().substring(0, file.getName().length()-4));\\n                                Map<Language, ProjectTMX> newOtherTargetLangTMs = new TreeMap<Language, ProjectTMX>(otherTargetLangTMs);\\n                if (file.exists()) {\\n                    try {\\n                        ProjectTMX newTMX = new ProjectTMX(m_config.getSourceLanguage(), targetLanguage,\\n                            m_config.isSentenceSegmentingEnabled(), file, checkOrphanedCallback);\\n                        newOtherTargetLangTMs.put(targetLanguage, newTMX);\\n                    } catch (Exception e) {\\n                        String filename = file.getPath();\\n                        Log.logErrorRB(e, \\\"TF_TM_LOAD_ERROR\\\", filename);\\n                        Core.getMainWindow().displayErrorRB(e, \\\"TF_TM_LOAD_ERROR\\\", filename);\\n                    }\\n                } else {\\n                    newOtherTargetLangTMs.remove(targetLanguage);\\n                }\\n                otherTargetLangTMs = newOtherTargetLangTMs;\\n            }\\n        });\\n        tmOtherLanguagesMonitor.checkChanges();\\n        tmOtherLanguagesMonitor.start();\\n    }\\n    void appendFromAutoTMX(ExternalTMX tmx, boolean isEnforcedTMX) {\\n        synchronized (projectTMX) {\\n            importHandler.process(tmx, isEnforcedTMX);\\n        }\\n    }\\n    public List<SourceTextEntry> getAllEntries() {\\n        return allProjectEntries;\\n    }\\n    public TMXEntry getTranslationInfo(SourceTextEntry ste) {\\n        TMXEntry r = projectTMX.getMultipleTranslation(ste.getKey());\\n        if (r == null) {\\n            r = projectTMX.getDefaultTranslation(ste.getSrcText());\\n        }\\n        if (r == null) {\\n            r = EMPTY_TRANSLATION;\\n        }\\n        return r;\\n    }\\n    public AllTranslations getAllTranslations(SourceTextEntry ste) {\\n        AllTranslations r = new AllTranslations();\\n        synchronized (projectTMX) {\\n            r.defaultTranslation = projectTMX.getDefaultTranslation(ste.getSrcText());\\n            r.alternativeTranslation = projectTMX.getMultipleTranslation(ste.getKey());\\n            if (r.alternativeTranslation != null) {\\n                r.currentTranslation = r.alternativeTranslation;\\n            } else if (r.defaultTranslation != null) {\\n                r.currentTranslation = r.defaultTranslation;\\n            } else {\\n                r.currentTranslation = EMPTY_TRANSLATION;\\n            }\\n            if (r.defaultTranslation == null) {\\n                r.defaultTranslation = EMPTY_TRANSLATION;\\n            }\\n            if (r.alternativeTranslation == null) {\\n                r.alternativeTranslation = EMPTY_TRANSLATION;\\n            }\\n        }\\n        return r;\\n    }\\n    public ProjectProperties getProjectProperties() {\\n        return m_config;\\n    }\\n    public boolean isProjectModified() {\\n        return m_modifiedFlag;\\n    }\\n    private void setProjectModified(boolean isModified) {\\n        m_modifiedFlag = isModified;\\n        if (isModified) {\\n            CoreEvents.fireProjectChange(IProjectEventListener.PROJECT_CHANGE_TYPE.MODIFIED);\\n        }\\n    }\\n    @Override\\n    public void setTranslation(SourceTextEntry entry, PrepareTMXEntry trans, boolean defaultTranslation,\\n            ExternalLinked externalLinked, AllTranslations previous) throws OptimisticLockingFail {\\n        if (trans == null) {\\n            throw new IllegalArgumentException(\\\"RealProject.setTranslation(tr) can't be null\\\");\\n        }\\n        synchronized (projectTMX) {\\n            AllTranslations current = getAllTranslations(entry);\\n            boolean wasAlternative = current.alternativeTranslation.isTranslated();\\n            if (defaultTranslation) {\\n                if (!current.defaultTranslation.equals(previous.defaultTranslation)) {\\n                    throw new OptimisticLockingFail(previous.getDefaultTranslation().translation,\\n                            current.getDefaultTranslation().translation, current);\\n                }\\n                if (wasAlternative) {\\n                                        if (!current.alternativeTranslation.equals(previous.alternativeTranslation)) {\\n                        throw new OptimisticLockingFail(previous.getAlternativeTranslation().translation,\\n                                current.getAlternativeTranslation().translation, current);\\n                    }\\n                                        setTranslation(entry, new PrepareTMXEntry(), false, null);\\n                }\\n            } else {\\n                                if (!current.alternativeTranslation.equals(previous.alternativeTranslation)) {\\n                    throw new OptimisticLockingFail(previous.getAlternativeTranslation().translation,\\n                            current.getAlternativeTranslation().translation, current);\\n                }\\n            }\\n            setTranslation(entry, trans, defaultTranslation, externalLinked);\\n        }\\n    }\\n    @Override\\n    public void setTranslation(final SourceTextEntry entry, final PrepareTMXEntry trans, boolean defaultTranslation, TMXEntry.ExternalLinked externalLinked) {\\n        if (trans == null) {\\n            throw new IllegalArgumentException(\\\"RealProject.setTranslation(tr) can't be null\\\");\\n        }\\n        TMXEntry prevTrEntry = defaultTranslation ? projectTMX.getDefaultTranslation(entry.getSrcText())\\n                : projectTMX.getMultipleTranslation(entry.getKey());\\n        trans.changer = Preferences.getPreferenceDefault(Preferences.TEAM_AUTHOR,\\n                System.getProperty(\\\"user.name\\\"));\\n        trans.changeDate = System.currentTimeMillis();\\n        if (prevTrEntry == null) {\\n                        prevTrEntry = EMPTY_TRANSLATION;\\n            trans.creationDate = trans.changeDate;\\n            trans.creator = trans.changer;\\n        } else {\\n            trans.creationDate = prevTrEntry.creationDate;\\n            trans.creator = prevTrEntry.creator;\\n        }\\n        if (StringUtil.isEmpty(trans.note)) {\\n            trans.note = null;\\n        }\\n        trans.source = entry.getSrcText();\\n        TMXEntry newTrEntry;\\n        if (trans.translation == null && trans.note == null) {\\n                        newTrEntry = null;\\n        } else {\\n            newTrEntry = new TMXEntry(trans, defaultTranslation, externalLinked);\\n        }\\n        setProjectModified(true);\\n        projectTMX.setTranslation(entry, newTrEntry, defaultTranslation);\\n        int diff = prevTrEntry.translation == null ? 0 : -1;\\n        diff += trans.translation == null ? 0 : +1;\\n        hotStat.numberofTranslatedSegments = Math.max(0, \\n                Math.min(hotStat.numberOfUniqueSegments, hotStat.numberofTranslatedSegments + diff));\\n    }\\n    @Override\\n    public void setNote(final SourceTextEntry entry, final TMXEntry oldTE, String note) {\\n        if (oldTE == null) {\\n            throw new IllegalArgumentException(\\\"RealProject.setNote(tr) can't be null\\\");\\n        }\\n                if (note != null && note.isEmpty()) {\\n            note = null;\\n        }\\n        TMXEntry prevTrEntry = oldTE.defaultTranslation ? projectTMX\\n                .getDefaultTranslation(entry.getSrcText()) : projectTMX\\n                .getMultipleTranslation(entry.getKey());\\n        if (prevTrEntry != null) {\\n            PrepareTMXEntry en = new PrepareTMXEntry(prevTrEntry);\\n            en.note = note;\\n            projectTMX.setTranslation(entry, new TMXEntry(en, prevTrEntry.defaultTranslation,\\n                    prevTrEntry.linked), prevTrEntry.defaultTranslation);\\n        } else {\\n            PrepareTMXEntry en = new PrepareTMXEntry();\\n            en.source = entry.getSrcText();\\n            en.note = note;\\n            en.translation = null;\\n            projectTMX.setTranslation(entry, new TMXEntry(en, true, null), true);\\n        }\\n        setProjectModified(true);\\n    }\\n    @SuppressWarnings(\\\"unchecked\\\")\\n    public void iterateByDefaultTranslations(DefaultTranslationsIterator it) {\\n        Map.Entry<String, TMXEntry>[] entries;\\n        synchronized (projectTMX) {\\n            Set<Map.Entry<String, TMXEntry>> set = projectTMX.defaults.entrySet();\\n            entries = set.toArray(new Map.Entry[set.size()]);\\n        }\\n        for (Map.Entry<String, TMXEntry> en : entries) {\\n            it.iterate(en.getKey(), en.getValue());\\n        }\\n    }\\n    @SuppressWarnings(\\\"unchecked\\\")\\n    public void iterateByMultipleTranslations(MultipleTranslationsIterator it) {\\n        Map.Entry<EntryKey, TMXEntry>[] entries;\\n        synchronized (projectTMX) {\\n            Set<Map.Entry<EntryKey, TMXEntry>> set = projectTMX.alternatives.entrySet();\\n            entries = set.toArray(new Map.Entry[set.size()]);\\n        }\\n        for (Map.Entry<EntryKey, TMXEntry> en : entries) {\\n            it.iterate(en.getKey(), en.getValue());\\n        }\\n    }\\n    public boolean isOrphaned(String source) {\\n        return !checkOrphanedCallback.existSourceInProject(source);\\n    }\\n    public boolean isOrphaned(EntryKey entry) {\\n        return !checkOrphanedCallback.existEntryInProject(entry);\\n    }\\n    public Map<String, ExternalTMX> getTransMemories() {\\n        return transMemories;\\n    }\\n    public Map<Language, ProjectTMX> getOtherTargetLanguageTMs() {\\n        return otherTargetLangTMs;\\n    }\\n    public ITokenizer getSourceTokenizer() {\\n        return sourceTokenizer;\\n    }\\n    public ITokenizer getTargetTokenizer() {\\n        return targetTokenizer;\\n    }\\n    protected ITokenizer createTokenizer(String cmdLine, Class<?> projectPref) {\\n        if (!StringUtil.isEmpty(cmdLine)) {\\n            try {\\n                return (ITokenizer) this.getClass().getClassLoader().loadClass(cmdLine).newInstance();\\n            } catch (ClassNotFoundException e) {\\n                Log.log(e.toString());\\n            } catch (Throwable e) {\\n                throw new RuntimeException(e);\\n            }\\n        }\\n        try {\\n            return (ITokenizer) projectPref.newInstance();\\n        } catch (Throwable e) {\\n            Log.log(e);\\n        }\\n        return new DefaultTokenizer();\\n    }\\n    protected void configTokenizer(String cmdLine, ITokenizer tokenizer) {\\n                if (!StringUtil.isEmpty(cmdLine)) {\\n            try {\\n                tokenizer.setBehavior(Version.valueOf(cmdLine));\\n                return;\\n            } catch (Throwable e) {\\n                throw new RuntimeException(e);\\n            }\\n        }\\n                String vString = Preferences.getPreferenceDefault(\\n                Preferences.TOK_BEHAVIOR_PREFIX + tokenizer.getClass().getName(),\\n                null);\\n         if (!StringUtil.isEmpty(vString)) {\\n             try {\\n                 tokenizer.setBehavior(Version.valueOf(vString));\\n                 return;\\n             }  catch (Throwable e) {\\n                 throw new RuntimeException(e);\\n             }\\n         }\\n             }\\n    public List<FileInfo> getProjectFiles() {\\n        return Collections.unmodifiableList(projectFilesList);\\n    }\\n    @Override\\n    public String getTargetPathForSourceFile(String currentSource) {\\n        if (StringUtil.isEmpty(currentSource)) {\\n            return null;\\n        }\\n        try {\\n            return Core.getFilterMaster().getTargetForSource(m_config.getSourceRoot(),\\n                    currentSource, new FilterContext(m_config));\\n        } catch (Exception e) {\\n            Log.log(e);\\n        }\\n        return null;\\n    }\\n    @Override\\n    public List<String> getSourceFilesOrder() {\\n        final String file = m_config.getProjectInternal() + OConsts.FILES_ORDER_FILENAME;\\n        try {\\n            BufferedReader rd = new BufferedReader(new InputStreamReader(new FileInputStream(file), \\\"UTF-8\\\"));\\n            List<String> result = new ArrayList<String>();\\n            String s;\\n            while ((s = rd.readLine()) != null) {\\n                result.add(s);\\n            }\\n            rd.close();\\n            return result;\\n        } catch (Exception ex) {\\n            return null;\\n        }\\n    }\\n    @Override\\n    public void setSourceFilesOrder(List<String> filesList) {\\n        final String file = m_config.getProjectInternal() + OConsts.FILES_ORDER_FILENAME;\\n        try {\\n            BufferedWriter wr = new BufferedWriter(\\n                    new OutputStreamWriter(new FileOutputStream(file), \\\"UTF-8\\\"));\\n            for (String f : filesList) {\\n                wr.write(f);\\n                wr.write('\\\\n');\\n            }\\n            wr.close();\\n        } catch (Exception ex) {\\n            Log.log(ex);\\n        }\\n    }\\n    protected String patchFileNameForEntryKey(String filename) {\\n        String f = Core.getParams().get(CLIParameters.ALTERNATE_FILENAME_FROM);\\n        String t = Core.getParams().get(CLIParameters.ALTERNATE_FILENAME_TO);\\n        String fn = filename.replace('\\\\\\\\', '/');\\n        if (f != null && t != null) {\\n            fn = fn.replaceAll(f, t);\\n        }\\n        return fn;\\n    }\\n    protected class LoadFilesCallback extends ParseEntry {\\n        private FileInfo fileInfo;\\n        private String entryKeyFilename;\\n        private final Set<String> existSource;\\n        private final Set<EntryKey> existKeys;\\n        public LoadFilesCallback(final Set<String> existSource, final Set<EntryKey> existKeys) {\\n            super(m_config);\\n            this.existSource = existSource;\\n            this.existKeys = existKeys;\\n        }\\n        public void setCurrentFile(FileInfo fi) {\\n            fileInfo = fi;\\n            super.setCurrentFile(fi);\\n            entryKeyFilename = patchFileNameForEntryKey(fileInfo.filePath);\\n        }\\n        public void fileFinished() {\\n            super.fileFinished();\\n            fileInfo = null;\\n        }\\n        protected void addSegment(String id, short segmentIndex, String segmentSource,\\n                List<ProtectedPart> protectedParts, String segmentTranslation, boolean segmentTranslationFuzzy,\\n                String comment, String prevSegment, String nextSegment, String path) {\\n                        if (segmentSource.trim().isEmpty()) {\\n                throw new RuntimeException(\\\"Segment must not be empty\\\");\\n            }\\n            EntryKey ek = new EntryKey(entryKeyFilename, segmentSource, id, prevSegment, nextSegment, path);\\n            protectedParts = TagUtil.applyCustomProtectedParts(segmentSource,\\n                    PatternConsts.getPlaceholderPattern(), protectedParts);\\n                        if (ek.sourceText.equals(segmentTranslation) && \\n                    !allowTranslationEqualToSource) {\\n                segmentTranslation = null;\\n            }\\n            SourceTextEntry srcTextEntry = new SourceTextEntry(ek, allProjectEntries.size() + 1, comment,\\n                    segmentTranslation, protectedParts);\\n            srcTextEntry.setSourceTranslationFuzzy(segmentTranslationFuzzy);\\n            allProjectEntries.add(srcTextEntry);\\n            fileInfo.entries.add(srcTextEntry);\\n            existSource.add(segmentSource);\\n            existKeys.add(srcTextEntry.getKey());\\n        }\\n    };\\n    private class TranslateFilesCallback extends TranslateEntry {\\n        private String currentFile;\\n        @Override\\n        protected String getCurrentFile(){\\n            return currentFile;\\n        }\\n        public TranslateFilesCallback() {\\n            super(m_config);\\n        }\\n        protected void fileStarted(String fn) {\\n            currentFile = patchFileNameForEntryKey(fn);\\n            super.fileStarted();\\n        }\\n        protected String getSegmentTranslation(String id, int segmentIndex, String segmentSource,\\n                String prevSegment, String nextSegment, String path) {\\n            EntryKey ek = new EntryKey(currentFile, segmentSource, id, prevSegment, nextSegment, path);\\n            TMXEntry tr = projectTMX.getMultipleTranslation(ek);\\n            if (tr == null) {\\n                tr = projectTMX.getDefaultTranslation(ek.sourceText);\\n            }\\n            return tr != null ? tr.translation : null;\\n        }\\n    };\\n    static class AlignFilesCallback implements IAlignCallback {\\n        public AlignFilesCallback(ProjectProperties props) {\\n            super();\\n            this.config = props;\\n        }\\n        Map<String, TMXEntry> data = new HashMap<String, TMXEntry>();\\n        private ProjectProperties config;\\n        @Override\\n        public void addTranslation(String id, String source, String translation, boolean isFuzzy, String path,\\n                IFilter filter) {\\n            if (source != null && translation != null) {\\n                ParseEntry.ParseEntryResult spr = new ParseEntry.ParseEntryResult();\\n                boolean removeSpaces = Core.getFilterMaster().getConfig().isRemoveSpacesNonseg();\\n                String sourceS = ParseEntry.stripSomeChars(source, spr, config.isRemoveTags(), removeSpaces);\\n                String transS = ParseEntry.stripSomeChars(translation, spr, config.isRemoveTags(), removeSpaces);\\n                PrepareTMXEntry tr = new PrepareTMXEntry();\\n                if (config.isSentenceSegmentingEnabled()) {\\n                    List<String> segmentsSource = Core.getSegmenter().segment(config.getSourceLanguage(), sourceS, null,\\n                            null);\\n                    List<String> segmentsTranslation = Core.getSegmenter()\\n                            .segment(config.getTargetLanguage(), transS, null, null);\\n                    if (segmentsTranslation.size() != segmentsSource.size()) {\\n                        if (isFuzzy) {\\n                            transS = \\\"[\\\" + filter.getFuzzyMark() + \\\"] \\\" + transS;\\n                        }\\n                        tr.source = sourceS;\\n                        tr.translation = transS;\\n                        data.put(sourceS, new TMXEntry(tr, true, null));\\n                    } else {\\n                        for (short i = 0; i < segmentsSource.size(); i++) {\\n                            String oneSrc = segmentsSource.get(i);\\n                            String oneTrans = segmentsTranslation.get(i);\\n                            if (isFuzzy) {\\n                                oneTrans = \\\"[\\\" + filter.getFuzzyMark() + \\\"] \\\" + oneTrans;\\n                            }\\n                            tr.source = oneSrc;\\n                            tr.translation = oneTrans;\\n                            data.put(sourceS, new TMXEntry(tr, true, null));\\n                        }\\n                    }\\n                } else {\\n                    if (isFuzzy) {\\n                        transS = \\\"[\\\" + filter.getFuzzyMark() + \\\"] \\\" + transS;\\n                    }\\n                    tr.source = sourceS;\\n                    tr.translation = transS;\\n                    data.put(sourceS, new TMXEntry(tr, true, null));\\n                }\\n            }\\n        }\\n    }\\n    ProjectTMX.CheckOrphanedCallback checkOrphanedCallback = new ProjectTMX.CheckOrphanedCallback() {\\n        public boolean existSourceInProject(String src) {\\n            return existSource.contains(src);\\n        }\\n        public boolean existEntryInProject(EntryKey key) {\\n            return existKeys.contains(key);\\n        }\\n    };\\n    void setOnlineMode() {\\n        if (!isOnlineMode) {\\n            Log.logInfoRB(\\\"VCS_ONLINE\\\");\\n            Core.getMainWindow().displayWarningRB(\\\"VCS_ONLINE\\\", \\\"VCS_OFFLINE\\\");\\n        }\\n        isOnlineMode = true;\\n    }\\n    void setOfflineMode() {\\n        if (isOnlineMode) {\\n            Log.logInfoRB(\\\"VCS_OFFLINE\\\");\\n            Core.getMainWindow().displayWarningRB(\\\"VCS_OFFLINE\\\", \\\"VCS_ONLINE\\\");\\n        }\\n        isOnlineMode = false;\\n    }\\n}\""
        },
        {
            "content": "The source code of `RealProject.java` has been successfully retrieved and contains a comprehensive implementation related to project management, translation handling, file I/O, and integration with version control systems (e.g., SVN, Git).\n\n### Key Observations from the Code:\n1. **Core Responsibilities**:\n   - `RealProject` is responsible for managing translation memory (`TMXEntry`, `ProjectTMX`), glossaries, source files, and synchronization with remote repositories.\n   - It interacts heavily with configuration, preferences, logging, and file utilities.\n\n2. **Key Dependencies**:\n   - **`Core`**: Used for accessing global application functionality like filters, segmentation, and UI components.\n   - **`Preferences` / `RuntimePreferences`**: Stores and retrieves user/project-specific settings.\n   - **`FileUtil` / `StaticUtils`**: Utility classes for file manipulation and general-purpose functions.\n   - **`IRemoteRepository` implementations (SVNRemoteRepository, GITRemoteRepository)**: For team collaboration and synchronization.\n   - **`FilterMaster` / `ITokenizer`**: Text processing components used in parsing and translating content.\n   - **`Log`**: Logging system.\n   - **`OConsts`**: Constants used across the application.\n\n3. **Interactions with Other Entities**:\n   - The class frequently uses entities such as `TMXWriter`, `ProjectTMX`, `SourceTextEntry`, `TranslationException`, `IAlignCallback`, etc., indicating deeper conceptual or functional ties.\n\n### Final List of Entities That Need Synchronization\nBased on all gathered data (co-change relationships, call graph, conceptual coupling, and actual code usage), here are the key files that may need synchronized changes when modifying `RealProject.java`:\n\n#### 1. High Co-Change + Conceptual Coupling:\n- `TMXWriter.java` (high conceptual coupling)\n\n#### 2. Direct Call Graph Dependencies:\n- `Core.java`\n- `Preferences.java`\n- `RuntimePreferences.java`\n- `FileUtil.java`\n- `StaticUtils.java`\n- `FilterMaster.java`\n- `ITokenizer.java`\n- `OConsts.java`\n- `Language.java`\n- `Log.java`\n- `IRemoteRepository.java`\n\n#### 3. Strong Co-Change Relationships:\n- `Main.java` (highest co-change confidence)\n- `SVNRemoteRepository.java`\n- `GITRemoteRepository.java`\n- `ProjectFactory.java`\n\n#### 4. Entities Frequently Used in Code:\n- `ProjectTMX.java`\n- `SourceTextEntry.java`\n- `TranslationException.java`\n- `IAlignCallback.java`\n- `TMXEntry.java`\n- `FileInfo.java`\n- `FilterContext.java`\n\n---\n\n### Conclusion:\nModifying `RealProject.java` will likely require synchronizing changes with these dependent files to maintain consistency and prevent regressions.\n\nWould you like me to summarize this into a structured report or focus on any specific entity for further analysis?",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        },
        {
            "role": "user",
            "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example, without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
        },
        {
            "content": "Title: Diagnosis of starting entity `RealProject.java`\n\nChange set: [TMXWriter, Core, RuntimePreferences, Preferences, StaticUtils, FilterMaster, IRemoteRepository, ITokenizer, OConsts, Language, Log, Main, SVNRemoteRepository, GITRemoteRepository, ProjectFactory, ProjectTMX, SourceTextEntry, TranslationException, IAlignCallback, TMXEntry, FileInfo, FilterContext, GlossaryReaderTSV, DefaultTokenizer, DirectoryMonitor, StringUtil, TagUtil, OStrings, KnownException, SRX, StatisticsInfo, CalcStandardStatistics, PatternConsts, ProjectFileStorage, CLIParameters, RepositoryUtils, UIThreadsUtil, CommandMonitor, ExternalTMX, EntryKey, ProjectUICommands, LoadFilesCallback, AlignFilesCallback, TMXWriter2, TMXReader2, ExternalTMXMatchesDialog]\n\nDetails:\n- **TMXWriter**: Strong conceptual coupling and frequent interaction in translation memory export/import.\n- **Core**: Used throughout for global access to filters, UI, and segmentation.\n- **RuntimePreferences / Preferences**: Central to reading/writing configuration settings.\n- **StaticUtils / FileUtil**: Utility functions used extensively for file operations.\n- **FilterMaster / ITokenizer**: Critical for parsing and tokenizing source content.\n- **OConsts**: Constants referenced across the project lifecycle.\n- **Language / Log**: Language handling and logging are fundamental to functionality.\n- **IRemoteRepository**: Base interface for team collaboration; tightly integrated.\n- **Main**: High co-change confidence suggests historical synchronization needs.\n- **SVNRemoteRepository / GITRemoteRepository**: Common VCS integrations that evolve with project structure.\n- **ProjectFactory**: Involved in project creation/loading workflows.\n- **ProjectTMX**: Manages translation memory, frequently accessed by RealProject.\n- **SourceTextEntry**: Represents core translation units managed in the project.\n- **TranslationException**: Exception handling is tightly coupled with file processing.\n- **IAlignCallback**: Used during alignment processes triggered from RealProject.\n- **TMXEntry**: Represents individual entries in translation memory.\n- **FileInfo**: Tracks file metadata and entries during loading.\n- **FilterContext**: Passed through filter operations during file processing.\n- **GlossaryReaderTSV / DefaultTokenizer**: Used in glossary and text segmentation logic.\n- **DirectoryMonitor**: Monitors translation memory and glossary directories.\n- **StringUtil / TagUtil / OStrings**: String manipulation utilities used throughout.\n- **KnownException**: Custom exceptions thrown during project operations.\n- **SRX / StatisticsInfo / CalcStandardStatistics**: Related to segmentation and statistics tracking.\n- **PatternConsts / ProjectFileStorage**: Used in file path and pattern handling.\n- **CLIParameters / RepositoryUtils / UIThreadsUtil**: Utilities for command-line, version control, and threading.\n- **CommandMonitor**: Used when executing external commands.\n- **ExternalTMX / EntryKey**: Represent external translation memories and unique entry identifiers.\n- **ProjectUICommands**: Likely involved in UI-triggered project actions.\n- **LoadFilesCallback / AlignFilesCallback**: Callback handlers for file loading/alignment tasks.\n- **TMXWriter2 / TMXReader2 / ExternalTMXMatchesDialog**: Secondary or related components in TMX handling.\n- **TestRealProject / TestTeamIntegration / TestCoreInitializer**: Test classes may need updates if internal APIs change.\n\nThese entities were selected based on co-change history, call graph analysis, conceptual coupling, and direct code usage. They represent the most likely candidates for synchronized changes alongside `RealProject.java`.",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        }
    ],
    "interaction_records": {
        "step_histories": [
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4"
                ],
                "response_message": "m5"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6"
                ],
                "response_message": "m7"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8"
                ],
                "response_message": "m9"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10"
                ],
                "response_message": "m11"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12"
                ],
                "response_message": "m13"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14"
                ],
                "response_message": "m15"
            }
        ],
        "mid_to_message": {
            "m1": {
                "role": "system",
                "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
            },
            "m2": {
                "role": "user",
                "content": "The project you need to analyze is `OmegaT`, a well-known Java open source project. The starting entity you need to deal with is RealProject.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
            },
            "m3": {
                "content": "",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_decc899f496a4858bb2b7c",
                        "function": {
                            "arguments": "{\"entity\": \"RealProject.java\"}",
                            "name": "get_co_change_relationship"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m4": {
                "name": "get_co_change_relationship",
                "role": "tool",
                "content": "[[\"Core\", \"1\", \"0.03125\"], [\"SaveThread\", \"1\", \"0.03125\"], [\"IAutoSave\", \"1\", \"0.03125\"], [\"ITokenizer\", \"1\", \"0.03125\"], [\"Tokenizer\", \"1\", \"0.03125\"], [\"ProjectFrame\", \"2\", \"0.0625\"], [\"ProjectUICommands\", \"2\", \"0.0625\"], [\"TMXWriter\", \"4\", \"0.125\"], [\"RuntimePreferences\", \"3\", \"0.09375\"], [\"Main\", \"10\", \"0.3125\"], [\"SourceTextEntry\", \"3\", \"0.09375\"], [\"StringEntry\", \"1\", \"0.03125\"], [\"LoadFilesCallback\", \"1\", \"0.03125\"], [\"ParseEntry\", \"1\", \"0.03125\"], [\"FileInfo\", \"1\", \"0.03125\"], [\"SourceEntry\", \"1\", \"0.03125\"], [\"IEditor\", \"1\", \"0.03125\"], [\"EditorController\", \"1\", \"0.03125\"], [\"FilterMaster\", \"1\", \"0.03125\"], [\"AlignFilesCallback\", \"2\", \"0.0625\"], [\"ProjectFactory\", \"4\", \"0.125\"], [\"TransEntry\", \"1\", \"0.03125\"], [\"DateParser\", \"1\", \"0.03125\"], [\"InvalidDateException\", \"1\", \"0.03125\"], [\"SegmentBuilder\", \"3\", \"0.09375\"], [\"ProjectTMX\", \"3\", \"0.09375\"], [\"FileUtil\", \"1\", \"0.03125\"], [\"Loader\", \"3\", \"0.09375\"], [\"FindMatchesThread\", \"1\", \"0.03125\"], [\"EntryInfoSearchThread\", \"1\", \"0.03125\"], [\"TMXWriter2\", \"1\", \"0.03125\"], [\"TMXReader2\", \"2\", \"0.0625\"], [\"ExternalTMX\", \"1\", \"0.03125\"], [\"TmxSegmentationTest\", \"1\", \"0.03125\"], [\"TmxComplianceTests\", \"1\", \"0.03125\"], [\"TmxComplianceBase\", \"1\", \"0.03125\"], [\"MainWindowMenu\", \"1\", \"0.03125\"], [\"IMainMenu\", \"1\", \"0.03125\"], [\"IRemoteRepository\", \"1\", \"0.03125\"], [\"SVNRemoteRepository\", \"3\", \"0.09375\"], [\"GITRemoteRepository\", \"3\", \"0.09375\"], [\"ProjectTeamTMX\", \"1\", \"0.03125\"], [\"Log\", \"1\", \"0.03125\"], [\"ImportFromAutoTMX\", \"1\", \"0.03125\"], [\"OConsts\", \"1\", \"0.03125\"], [\"Scores\", \"1\", \"0.03125\"], [\"Preferences\", \"1\", \"0.03125\"], [\"ExternalTMXMatchesDialog\", \"1\", \"0.03125\"], [\"NearString\", \"1\", \"0.03125\"], [\"TestTeamIntegration\", \"1\", \"0.03125\"], [\"TestTeamIntegrationChild\", \"1\", \"0.03125\"], [\"TestCoreInitializer\", \"1\", \"0.03125\"], [\"TestRealProject\", \"1\", \"0.03125\"], [\"StaticUtils\", \"2\", \"0.0625\"], [\"StaticUtilsTest\", \"1\", \"0.03125\"]]"
            },
            "m5": {
                "content": "The co-change relationships have been obtained for the starting entity `RealProject.java`. In co-change analysis, the confidence value indicates how often other files were modified together with the target file (`RealProject.java`) over its history. Higher confidence values suggest a stronger likelihood of synchronization requirements.\n\nFrom the results:\n- The highest confidence value is `0.3125` (Main.java, support: 10), which suggests that `Main.java` has a significant relationship with `RealProject.java`.\n- Other entities like `TMXWriter`, `RuntimePreferences`, `ProjectFactory`, `SVNRemoteRepository`, and others also show relatively higher confidence than most.\n\n### Next Steps\nTo narrow down the list of entities that are most likely to be impacted:\n1. Filter out entities with low confidence (e.g., below 0.0625) since they are less likely to have strong dependencies.\n2. Analyze coupling or conceptual dependencies for the remaining entities with `RealProject.java`.\n\nLet\u2019s first analyze coupling dependencies between `RealProject.java` and the entities with high confidence, such as `Main.java`. I will call the `get_coupling_dependencies` function for this purpose.\n\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_b2fd0e7870a64e41852df1",
                        "function": {
                            "arguments": "{\"entity1\": \"RealProject.java\", \"entity2\": \"Main.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m6": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"There are no coupling dependencies between these two entities\"]"
            },
            "m7": {
                "content": "There are no direct coupling dependencies between `RealProject.java` and `Main.java`, despite their high co-change confidence. This suggests that the synchronization relationship may be due to indirect interactions rather than direct code-level dependencies.\n\n### Next Step:\nTo further investigate, we should analyze **conceptual coupling** (semantic similarity) between `RealProject.java` and these co-changed files, starting with `TMXWriter.java`, which has a relatively high confidence value (`0.125`) and may provide more meaningful insights.\n\nLet\u2019s proceed by calling the `get_conceptual_coupling` function between `RealProject.java` and `TMXWriter.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_529591bf7762478b89491c",
                        "function": {
                            "arguments": "{\"entity1\": \"RealProject.java\", \"entity2\": \"TMXWriter.java\"}",
                            "name": "get_conceptual_coupling"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m8": {
                "role": "tool",
                "name": "get_conceptual_coupling",
                "content": "\"0.83868736\""
            },
            "m9": {
                "content": "The conceptual coupling (semantic similarity) between `RealProject.java` and `TMXWriter.java` is quite high at approximately **0.839**, indicating a strong semantic relationship between these two entities.\n\nThis suggests that even if there are no direct coupling dependencies, changes in `RealProject.java` may still impact `TMXWriter.java` due to shared concepts or functionality.\n\n### Next Steps:\nTo better understand how `RealProject.java` interacts with other components:\n1. We should examine the **call graph** of `RealProject.java` to identify which entities it directly references or uses.\n2. This will help us uncover additional entities that are tightly coupled through method calls or variable usage.\n\nLet\u2019s now call the `get_call_graph` function for `RealProject.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_ad841668583b43e4b34f19",
                        "function": {
                            "arguments": "{\"entity\": \"RealProject.java\"}",
                            "name": "get_call_graph"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m10": {
                "role": "tool",
                "name": "get_call_graph",
                "content": "[\"Filters\", \"Statistics\", \"TranslationException\", \"GlossaryReaderTSV\", \"StaticUtils\", \"IAlignCallback\", \"IFilter\", \"FileUtil\", \"IProjectEventListener\", \"StringUtil\", \"TagUtil\", \"OStrings\", \"KnownException\", \"DefaultTokenizer\", \"FilterContext\", \"OConsts\", \"ProjectFileStorage\", \"FilterMaster\", \"CommandMonitor\", \"ITokenizer\", \"CLIParameters\", \"IRemoteRepository\", \"UIThreadsUtil\", \"RepositoryUtils\", \"DirectoryMonitor\", \"Language\", \"RuntimePreferences\", \"GlossaryEntry\", \"SRX\", \"StatisticsInfo\", \"Core\", \"CoreEvents\", \"Preferences\", \"CalcStandardStatistics\", \"PatternConsts\", \"Log\"]"
            },
            "m11": {
                "content": "The call graph of `RealProject.java` includes several entities that it directly references or interacts with, such as:\n- **Core**\n- **RuntimePreferences**\n- **Preferences**\n- **StaticUtils**\n- **FileUtil**\n- **IRemoteRepository**\n- **FilterMaster**\n- **ITokenizer**\n- **OConsts**\n- **Language**\n- **Log**\n\nThese entities are likely to be more tightly coupled to `RealProject.java` compared to others in the co-change list.\n\n### Summary of Entities That May Need Synchronization\n\nCombining all the information gathered so far, here is a consolidated list of entities that may need synchronization when `RealProject.java` changes:\n\n1. **Co-change + High Conceptual Coupling:**\n   - `TMXWriter.java` (high conceptual coupling and co-change confidence 0.125)\n   \n2. **Call Graph Entities (direct usage):**\n   - `Core.java`\n   - `RuntimePreferences.java`\n   - `Preferences.java`\n   - `StaticUtils.java`\n   - `FileUtil.java`\n   - `FilterMaster.java`\n   - `ITokenizer.java` (interface used)\n   - `OConsts.java`\n   - `Language.java`\n   - `Log.java`\n   - `IRemoteRepository.java`\n\n3. **High Co-change Confidence (even without coupling):**\n   - `Main.java` (highest co-change confidence 0.3125)\n   - `ProjectFactory.java` (confidence 0.125)\n   - `SVNRemoteRepository.java` (confidence 0.09375)\n   - `GITRemoteRepository.java` (confidence 0.09375)\n\n### Next Step\nTo confirm the nature of interactions, we can examine the actual code of `RealProject.java`. This will help us understand how these dependencies are used and whether they are critical for synchronization.\n\nLet\u2019s retrieve the original code of `RealProject.java` using the `get_origin_code` function.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_a14caed6fa544a899f4af2",
                        "function": {
                            "arguments": "{\"entity\": \"RealProject.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m12": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package org.omegat.core.data;\\nimport java.io.BufferedReader;\\nimport java.io.BufferedWriter;\\nimport java.io.File;\\nimport java.io.FileInputStream;\\nimport java.io.FileOutputStream;\\nimport java.io.IOException;\\nimport java.io.InputStreamReader;\\nimport java.io.OutputStreamWriter;\\nimport java.io.RandomAccessFile;\\nimport java.nio.channels.FileChannel;\\nimport java.nio.channels.FileLock;\\nimport java.text.SimpleDateFormat;\\nimport java.util.ArrayList;\\nimport java.util.Collections;\\nimport java.util.Date;\\nimport java.util.HashMap;\\nimport java.util.HashSet;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.Set;\\nimport java.util.Stack;\\nimport java.util.TreeMap;\\nimport java.util.logging.Logger;\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\nimport javax.swing.SwingUtilities;\\nimport org.apache.lucene.util.Version;\\nimport org.madlonkay.supertmxmerge.StmProperties;\\nimport org.madlonkay.supertmxmerge.SuperTmxMerge;\\nimport org.omegat.CLIParameters;\\nimport org.omegat.core.Core;\\nimport org.omegat.core.CoreEvents;\\nimport org.omegat.core.KnownException;\\nimport org.omegat.core.data.TMXEntry.ExternalLinked;\\nimport org.omegat.core.events.IProjectEventListener;\\nimport org.omegat.core.segmentation.SRX;\\nimport org.omegat.core.statistics.CalcStandardStatistics;\\nimport org.omegat.core.statistics.Statistics;\\nimport org.omegat.core.statistics.StatisticsInfo;\\nimport org.omegat.core.team.IRemoteRepository;\\nimport org.omegat.core.team.RepositoryUtils;\\nimport org.omegat.core.threads.CommandMonitor;\\nimport org.omegat.filters2.FilterContext;\\nimport org.omegat.filters2.IAlignCallback;\\nimport org.omegat.filters2.IFilter;\\nimport org.omegat.filters2.TranslationException;\\nimport org.omegat.filters2.master.FilterMaster;\\nimport org.omegat.gui.glossary.GlossaryEntry;\\nimport org.omegat.gui.glossary.GlossaryReaderTSV;\\nimport org.omegat.tokenizer.DefaultTokenizer;\\nimport org.omegat.tokenizer.ITokenizer;\\nimport org.omegat.util.DirectoryMonitor;\\nimport org.omegat.util.FileUtil;\\nimport org.omegat.util.Language;\\nimport org.omegat.util.Log;\\nimport org.omegat.util.OConsts;\\nimport org.omegat.util.OStrings;\\nimport org.omegat.util.PatternConsts;\\nimport org.omegat.util.Preferences;\\nimport org.omegat.util.ProjectFileStorage;\\nimport org.omegat.util.RuntimePreferences;\\nimport org.omegat.util.StaticUtils;\\nimport org.omegat.util.StringUtil;\\nimport org.omegat.util.TagUtil;\\nimport org.omegat.util.gui.UIThreadsUtil;\\nimport org.xml.sax.SAXParseException;\\nimport gen.core.filters.Filters;\\npublic class RealProject implements IProject {\\n    private static final Logger LOGGER = Logger.getLogger(RealProject.class.getName());\\n    protected final ProjectProperties m_config;\\n    private final IRemoteRepository repository;\\n    private boolean isOnlineMode;\\n    private RandomAccessFile raFile;\\n    private FileChannel lockChannel;\\n    private FileLock lock;\\n    private boolean m_modifiedFlag;\\n    protected List<SourceTextEntry> allProjectEntries = new ArrayList<SourceTextEntry>(4096);\\n    protected ImportFromAutoTMX importHandler;\\n    private final StatisticsInfo hotStat = new StatisticsInfo();\\n    private final ITokenizer sourceTokenizer, targetTokenizer;\\n    private DirectoryMonitor tmMonitor;\\n    private DirectoryMonitor tmOtherLanguagesMonitor;\\n    private boolean isSaving = false;\\n    private Map<String, ExternalTMX> transMemories = new TreeMap<String, ExternalTMX>();\\n    private Map<Language, ProjectTMX> otherTargetLangTMs = new TreeMap<Language, ProjectTMX>();\\n    protected ProjectTMX projectTMX;\\n    private boolean loaded = false;\\n        private Set<String> existSource = new HashSet<String>();\\n    private Set<EntryKey> existKeys = new HashSet<EntryKey>();\\n    protected List<FileInfo> projectFilesList = new ArrayList<FileInfo>();\\n    private final TMXEntry EMPTY_TRANSLATION;\\n    private boolean allowTranslationEqualToSource = Preferences.isPreference(Preferences.ALLOW_TRANS_EQUAL_TO_SRC);\\n    private Stack<Process> processCache = new Stack<Process>();\\n    public RealProject(final ProjectProperties props) {\\n        this(props, null);\\n    }\\n    public RealProject(final ProjectProperties props, IRemoteRepository repository) {\\n        PrepareTMXEntry empty = new PrepareTMXEntry();\\n        empty.source = \\\"\\\";\\n        EMPTY_TRANSLATION = new TMXEntry(empty, true, null);\\n        m_config = props;\\n        this.repository = repository;\\n        sourceTokenizer = createTokenizer(Core.getParams().get(CLIParameters.TOKENIZER_SOURCE), props.getSourceTokenizer());\\n        configTokenizer(Core.getParams().get(CLIParameters.TOKENIZER_BEHAVIOR_SOURCE), sourceTokenizer);\\n        Log.log(\\\"Source tokenizer: \\\" + sourceTokenizer.getClass().getName() + \\\" (\\\" + sourceTokenizer.getBehavior() + \\\")\\\");\\n        targetTokenizer = createTokenizer(Core.getParams().get(CLIParameters.TOKENIZER_TARGET), props.getTargetTokenizer());\\n        configTokenizer(Core.getParams().get(CLIParameters.TOKENIZER_BEHAVIOR_TARGET), targetTokenizer);\\n        Log.log(\\\"Target tokenizer: \\\" + targetTokenizer.getClass().getName() + \\\" (\\\" + targetTokenizer.getBehavior() + \\\")\\\");\\n    }\\n    public IRemoteRepository getRepository() {\\n        return repository;\\n    }\\n    public void saveProjectProperties() throws Exception {\\n        unlockProject();\\n        try {\\n            ProjectFileStorage.writeProjectFile(m_config);\\n        } finally {\\n            lockProject();\\n        }\\n        Preferences.setPreference(Preferences.SOURCE_LOCALE, m_config.getSourceLanguage().toString());\\n        Preferences.setPreference(Preferences.TARGET_LOCALE, m_config.getTargetLanguage().toString());\\n    }\\n    public void createProject() {\\n        Log.logInfoRB(\\\"LOG_DATAENGINE_CREATE_START\\\");\\n        UIThreadsUtil.mustNotBeSwingThread();\\n        try {\\n            if (!lockProject()) {\\n                throw new KnownException(\\\"PROJECT_LOCKED\\\");\\n            }\\n            createDirectory(m_config.getProjectRoot(), null);\\n            createDirectory(m_config.getProjectInternal(), OConsts.DEFAULT_INTERNAL);\\n            createDirectory(m_config.getSourceRoot(), OConsts.DEFAULT_SOURCE);\\n            createDirectory(m_config.getGlossaryRoot(), OConsts.DEFAULT_GLOSSARY);\\n            createDirectory(m_config.getTMRoot(), OConsts.DEFAULT_TM);\\n            createDirectory(m_config.getTMAutoRoot(), OConsts.AUTO_TM);\\n            createDirectory(m_config.getDictRoot(), OConsts.DEFAULT_DICT);\\n            createDirectory(m_config.getTargetRoot(), OConsts.DEFAULT_TARGET);\\n            saveProjectProperties();\\n                                    SRX srx = m_config.getProjectSRX();\\n            Core.getSegmenter().setSRX(srx == null ? Preferences.getSRX() : srx);\\n            loadTranslations();\\n            setProjectModified(true);\\n            saveProject(false);\\n            allProjectEntries = Collections.unmodifiableList(allProjectEntries);\\n            importHandler = new ImportFromAutoTMX(this, allProjectEntries);\\n            loadTM();\\n            loadOtherLanguages();\\n            loaded = true;\\n                        Core.getMainWindow().showStatusMessageRB(null);\\n        } catch (Exception e) {\\n                        Log.logErrorRB(e, \\\"CT_ERROR_CREATING_PROJECT\\\");\\n            Core.getMainWindow().displayErrorRB(e, \\\"CT_ERROR_CREATING_PROJECT\\\");\\n        }\\n        Log.logInfoRB(\\\"LOG_DATAENGINE_CREATE_END\\\");\\n    }\\n    public void loadProject(boolean onlineMode) {\\n        Log.logInfoRB(\\\"LOG_DATAENGINE_LOAD_START\\\");\\n        UIThreadsUtil.mustNotBeSwingThread();\\n                try {\\n            if (!lockProject()) {\\n                throw new KnownException(\\\"PROJECT_LOCKED\\\");\\n            }\\n            isOnlineMode = onlineMode;\\n            if (RuntimePreferences.isLocationSaveEnabled()) {\\n                Preferences.setPreference(Preferences.CURRENT_FOLDER, new File(m_config.getProjectRoot())\\n                        .getParentFile().getAbsolutePath());\\n                Preferences.save();\\n            }\\n            Core.getMainWindow().showStatusMessageRB(\\\"CT_LOADING_PROJECT\\\");\\n                        Filters filterMasterConfig = FilterMaster.loadConfig(m_config.getProjectInternal());\\n            if (filterMasterConfig == null) {\\n                filterMasterConfig = FilterMaster.loadConfig(StaticUtils.getConfigDir());\\n            }\\n            if (filterMasterConfig == null) {\\n                filterMasterConfig = FilterMaster.createDefaultFiltersConfig();\\n            }\\n            Core.setFilterMaster(new FilterMaster(filterMasterConfig));\\n            EntryKey.setIgnoreFileContext(filterMasterConfig.isIgnoreFileContext());\\n                                    SRX srx = m_config.getProjectSRX();\\n            Core.getSegmenter().setSRX(srx == null ? Preferences.getSRX() : srx);\\n            loadSourceFiles();\\n            loadTranslations();\\n            allProjectEntries = Collections.unmodifiableList(allProjectEntries);\\n            importHandler = new ImportFromAutoTMX(this, allProjectEntries);\\n            importTranslationsFromSources();\\n            loadTM();\\n            loadOtherLanguages();\\n                        String stat = CalcStandardStatistics.buildProjectStats(this, hotStat);\\n            String fn = m_config.getProjectInternal() + OConsts.STATS_FILENAME;\\n            Statistics.writeStat(fn, stat);\\n            loaded = true;\\n                        Core.getMainWindow().showStatusMessageRB(null);\\n            setProjectModified(false);\\n        } catch (Exception e) {\\n            Log.logErrorRB(e, \\\"TF_LOAD_ERROR\\\");\\n            Core.getMainWindow().displayErrorRB(e, \\\"TF_LOAD_ERROR\\\");\\n            if (!loaded) {\\n                unlockProject();\\n            }\\n        }\\n                        catch (OutOfMemoryError oome) {\\n                                                            allProjectEntries.clear();\\n            projectFilesList.clear();\\n            transMemories.clear();\\n            projectTMX = null;\\n                        System.gc();\\n                        long memory = Runtime.getRuntime().maxMemory() / 1024 / 1024;\\n            Log.logErrorRB(\\\"OUT_OF_MEMORY\\\", memory);\\n            Log.log(oome);\\n            Core.getMainWindow().showErrorDialogRB(\\\"TF_ERROR\\\", \\\"OUT_OF_MEMORY\\\", memory);\\n                        System.exit(0);\\n        }\\n        Log.logInfoRB(\\\"LOG_DATAENGINE_LOAD_END\\\");\\n    }\\n    public Map<String, TMXEntry> align(final ProjectProperties props, final File translatedDir)\\n            throws Exception {\\n        FilterMaster fm = Core.getFilterMaster();\\n        File root = new File(m_config.getSourceRoot());\\n        List<File> srcFileList = StaticUtils.buildFileList(root, true);\\n        AlignFilesCallback alignFilesCallback = new AlignFilesCallback(props);\\n        String srcRoot = m_config.getSourceRoot();\\n        for (File file : srcFileList) {\\n                        String midName = file.getPath().substring(srcRoot.length());\\n            fm.alignFile(srcRoot, midName, translatedDir.getPath(), new FilterContext(props),\\n                    alignFilesCallback);\\n        }\\n        return alignFilesCallback.data;\\n    }\\n    public boolean isProjectLoaded() {\\n        return loaded;\\n    }\\n    public StatisticsInfo getStatistics() {\\n        return hotStat;\\n    }\\n    public void closeProject() {\\n        loaded = false;\\n        flushProcessCache();\\n        tmMonitor.fin();\\n        tmOtherLanguagesMonitor.fin();\\n        unlockProject();\\n        Log.logInfoRB(\\\"LOG_DATAENGINE_CLOSE\\\");\\n    }\\n    protected boolean lockProject() {\\n        if (!RuntimePreferences.isProjectLockingEnabled()) {\\n            return true;\\n        }\\n        if (repository != null) {\\n            if (!repository.isFilesLockingAllowed()) {\\n                return true;\\n            }\\n        }\\n        try {\\n            File lockFile = new File(m_config.getProjectRoot(), OConsts.FILE_PROJECT);\\n            raFile = new RandomAccessFile(lockFile, \\\"rw\\\");\\n            lockChannel = raFile.getChannel();\\n            lock = lockChannel.tryLock();\\n        } catch (Throwable ex) {\\n            Log.log(ex);\\n        }\\n        if (lock == null) {\\n            try {\\n                lockChannel.close();\\n            } catch (Throwable ex) {\\n            }\\n            lockChannel = null;\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n    protected void unlockProject() {\\n        if (!RuntimePreferences.isProjectLockingEnabled()) {\\n            return;\\n        }\\n        if (repository != null) {\\n            if (!repository.isFilesLockingAllowed()) {\\n                return;\\n            }\\n        }\\n        try {\\n            if (lock != null) {\\n                lock.release();\\n            }\\n            if (lockChannel != null) {\\n                lockChannel.close();\\n            }\\n            if (raFile != null) {\\n                raFile.close();\\n            }\\n        } catch (Throwable ex) {\\n            Log.log(ex);\\n        }\\n    }\\n    public void compileProject(String sourcePattern) throws IOException, TranslationException {\\n        compileProject(sourcePattern, true);\\n    }\\n    public void compileProject(String sourcePattern, boolean doPostProcessing) throws IOException, TranslationException {\\n        Log.logInfoRB(\\\"LOG_DATAENGINE_COMPILE_START\\\");\\n        UIThreadsUtil.mustNotBeSwingThread();\\n        Pattern FILE_PATTERN = Pattern.compile(sourcePattern);\\n                                        try {\\n                        String fname = m_config.getProjectRoot() + m_config.getProjectName() + OConsts.OMEGAT_TMX\\n                    + OConsts.TMX_EXTENSION;\\n            projectTMX.exportTMX(m_config, new File(fname), false, false, false);\\n                        fname = m_config.getProjectRoot() + m_config.getProjectName() + OConsts.LEVEL1_TMX\\n                    + OConsts.TMX_EXTENSION;\\n            projectTMX.exportTMX(m_config, new File(fname), true, false, false);\\n                        fname = m_config.getProjectRoot() + m_config.getProjectName() + OConsts.LEVEL2_TMX\\n                    + OConsts.TMX_EXTENSION;\\n            projectTMX.exportTMX(m_config, new File(fname), false, true, false);\\n        } catch (Exception e) {\\n            Log.logErrorRB(\\\"CT_ERROR_CREATING_TMX\\\");\\n            Log.log(e);\\n            throw new IOException(OStrings.getString(\\\"CT_ERROR_CREATING_TMX\\\") + \\\"\\\\n\\\" + e.getMessage());\\n        }\\n        String srcRoot = m_config.getSourceRoot();\\n        String locRoot = m_config.getTargetRoot();\\n                FilterMaster fm = Core.getFilterMaster();\\n        List<File> fileList;\\n        try {\\n            fileList = StaticUtils.buildFileList(new File(srcRoot), true);\\n        } catch (Exception e) {\\n            Log.logErrorRB(\\\"CT_ERROR_CREATING_TMX\\\");\\n            Log.log(e);\\n            throw new IOException(OStrings.getString(\\\"CT_ERROR_CREATING_TMX\\\") + \\\"\\\\n\\\" + e.getMessage());\\n        }\\n        List<String> pathList = new ArrayList<String>(fileList.size());\\n        for (File file : fileList) {\\n            pathList.add(file.getPath().substring(m_config.getSourceRoot().length()).replace('\\\\\\\\', '/'));\\n        }\\n        StaticUtils.removeFilesByMasks(pathList, m_config.getSourceRootExcludes());\\n        TranslateFilesCallback translateFilesCallback = new TranslateFilesCallback();\\n        int numberOfCompiled = 0;\\n        for (String midName : pathList) {\\n                        Matcher fileMatch = FILE_PATTERN.matcher(midName);\\n            if (fileMatch.matches()) {\\n                File fn = new File(locRoot, midName);\\n                if (!fn.getParentFile().exists()) {\\n                                        if (!fn.getParentFile().mkdirs()) {\\n                        throw new IOException(OStrings.getString(\\\"CT_ERROR_CREATING_TARGET_DIR\\\") + fn.getParentFile());\\n                    }\\n                }\\n                Core.getMainWindow().showStatusMessageRB(\\\"CT_COMPILE_FILE_MX\\\", midName);\\n                translateFilesCallback.fileStarted(midName);\\n                fm.translateFile(srcRoot, midName, locRoot, new FilterContext(m_config),\\n                        translateFilesCallback);\\n                translateFilesCallback.fileFinished();\\n                numberOfCompiled++;\\n            }\\n        }\\n        if (numberOfCompiled == 1) {\\n            Core.getMainWindow().showStatusMessageRB(\\\"CT_COMPILE_DONE_MX_SINGULAR\\\");\\n        } else {\\n            Core.getMainWindow().showStatusMessageRB(\\\"CT_COMPILE_DONE_MX\\\");\\n        }\\n        CoreEvents.fireProjectChange(IProjectEventListener.PROJECT_CHANGE_TYPE.COMPILE);\\n        if (doPostProcessing) {\\n                        flushProcessCache();\\n            if (Preferences.isPreference(Preferences.ALLOW_PROJECT_EXTERN_CMD)) {\\n                doExternalCommand(m_config.getExternalCommand());\\n            }\\n            doExternalCommand(Preferences.getPreference(Preferences.EXTERNAL_COMMAND));\\n        }\\n        Log.logInfoRB(\\\"LOG_DATAENGINE_COMPILE_END\\\");\\n    }\\n    private void doExternalCommand(String command) {\\n        if (StringUtil.isEmpty(command)) {\\n            return;\\n        }\\n        Core.getMainWindow().showStatusMessageRB(\\\"CT_START_EXTERNAL_CMD\\\");\\n        CommandVarExpansion expander = new CommandVarExpansion(command);\\n        command = expander.expandVariables(m_config);\\n        Log.log(\\\"Executing command: \\\" + command);\\n        try {\\n            Process p = Runtime.getRuntime().exec(StaticUtils.parseCLICommand(command));\\n            processCache.push(p);\\n            CommandMonitor stdout = CommandMonitor.newStdoutMonitor(p);\\n            CommandMonitor stderr = CommandMonitor.newStderrMonitor(p);\\n            stdout.start();\\n            stderr.start();\\n        } catch (IOException e) {\\n            String message;\\n            Throwable cause = e.getCause();\\n            if (cause == null) {\\n                message = e.getLocalizedMessage();\\n            } else {\\n                message = cause.getLocalizedMessage();\\n            }\\n            Core.getMainWindow().showStatusMessageRB(\\\"CT_ERROR_STARTING_EXTERNAL_CMD\\\", message);\\n        }\\n    }\\n    private void flushProcessCache() {\\n        while (!processCache.isEmpty()) {\\n            Process p = processCache.pop();\\n            try {\\n                p.exitValue();\\n            } catch (IllegalThreadStateException ex) {\\n                p.destroy();\\n            }\\n        }\\n    }\\n    public synchronized void saveProject() {\\n        saveProject(true);\\n    }\\n    public synchronized void saveProject(boolean doTeamSync) {\\n        if (isSaving) {\\n            return;\\n        }\\n        isSaving = true;\\n        Log.logInfoRB(\\\"LOG_DATAENGINE_SAVE_START\\\");\\n        UIThreadsUtil.mustNotBeSwingThread();\\n        Core.getAutoSave().disable();\\n        try {\\n            Core.getMainWindow().getMainMenu().getProjectMenu().setEnabled(false);\\n            try {\\n                Preferences.save();\\n                String s = m_config.getProjectInternal() + OConsts.STATUS_EXTENSION;\\n                try {\\n                    saveProjectProperties();\\n                    projectTMX.save(m_config, s, isProjectModified());\\n                    if (repository != null && doTeamSync) {\\n                        Core.getMainWindow().showStatusMessageRB(\\\"TEAM_SYNCHRONIZE\\\");\\n                        rebaseProject();\\n                    }\\n                    setProjectModified(false);\\n                } catch (KnownException ex) {\\n                    throw ex;\\n                } catch (Exception e) {\\n                    Log.logErrorRB(e, \\\"CT_ERROR_SAVING_PROJ\\\");\\n                    Core.getMainWindow().displayErrorRB(e, \\\"CT_ERROR_SAVING_PROJ\\\");\\n                }\\n                LastSegmentManager.saveLastSegment();\\n                                String stat = CalcStandardStatistics.buildProjectStats(this, hotStat);\\n                String fn = m_config.getProjectInternal() + OConsts.STATS_FILENAME;\\n                Statistics.writeStat(fn, stat);\\n            } finally {\\n                Core.getMainWindow().getMainMenu().getProjectMenu().setEnabled(true);\\n            }\\n            CoreEvents.fireProjectChange(IProjectEventListener.PROJECT_CHANGE_TYPE.SAVE);\\n        } finally {\\n            Core.getAutoSave().enable();\\n        }\\n        Log.logInfoRB(\\\"LOG_DATAENGINE_SAVE_END\\\");\\n        isSaving = false;\\n    }\\n    private void rebaseProject() throws Exception {\\n        File filenameTMXwithLocalChangesOnBase, filenameTMXwithLocalChangesOnHead;\\n        ProjectTMX baseTMX, headTMX;\\n        File filenameGlossarywithLocalChangesOnBase, filenameGlossarywithLocalChangesOnHead;\\n        List<GlossaryEntry> glossaryEntries = null;\\n        List<GlossaryEntry> baseGlossaryEntries = null;\\n        List<GlossaryEntry> headGlossaryEntries = null;\\n        final boolean updateGlossary;\\n        Log.logInfoRB(\\\"TEAM_REBASE_START\\\");\\n        final String projectTMXFilename = m_config.getProjectInternal() + OConsts.STATUS_EXTENSION;\\n        final File projectTMXFile = new File(projectTMXFilename);\\n                File[] modifiedFiles;\\n                boolean needUpload = false;\\n        final StringBuilder commitDetails = new StringBuilder();\\n        final String glossaryFilename = m_config.getWriteableGlossary();\\n        final File glossaryFile = new File(glossaryFilename);\\n                                        if (repository.isUnderVersionControl(glossaryFile)) {\\n            Log.logDebug(LOGGER, \\\"rebaseProject: glossary file {0} is under version control\\\", glossaryFile);\\n                        modifiedFiles = new File[]{projectTMXFile, glossaryFile};\\n            updateGlossary = true;\\n        } else {\\n            Log.logDebug(LOGGER, \\\"rebaseProject: glossary file {0} is not under version control\\\", glossaryFile);\\n            modifiedFiles = new File[]{projectTMXFile};\\n            updateGlossary = false;\\n        }\\n        if (isProjectModified() || repository.isChanged(glossaryFile) || repository.isChanged(projectTMXFile)) {\\n            needUpload = true;\\n        }\\n        while (true) {\\n            boolean again = false;\\n            if (updateGlossary) {\\n                                glossaryEntries = GlossaryReaderTSV.read(glossaryFile, true);\\n            }\\n                        String baseRevTMX = repository.getBaseRevisionId(projectTMXFile);\\n            Log.logDebug(LOGGER, \\\"rebaseProject: TMX base revision: {0}\\\", baseRevTMX);\\n            String baseRevGlossary = null;\\n            if (updateGlossary) {\\n                baseRevGlossary = repository.getBaseRevisionId(glossaryFile);\\n                Log.logDebug(LOGGER, \\\"rebaseProject: glossary base revision: {0}\\\", baseRevGlossary);\\n            }\\n                                    filenameTMXwithLocalChangesOnBase = new File(projectTMXFilename + \\\"-based_on_\\\" + baseRevTMX + OConsts.NEWFILE_EXTENSION);\\n            filenameGlossarywithLocalChangesOnBase = null;\\n            projectTMX.exportTMX(m_config, filenameTMXwithLocalChangesOnBase, false, false, true);             if (System.getProperty(\\\"team.supersafe\\\") != null) {\\n                                File bak = new File(projectTMXFilename + \\\"-based_on_\\\" + baseRevTMX + \\\"_at_\\\"\\n                        + new SimpleDateFormat(\\\"MMdd-HHmmss\\\").format(new Date()) + OConsts.BACKUP_EXTENSION);\\n                projectTMX.exportTMX(m_config, bak, false, false, true);\\n            }\\n            if (updateGlossary) {\\n                filenameGlossarywithLocalChangesOnBase = new File(glossaryFilename + \\\"-based_on_\\\" + baseRevGlossary + OConsts.NEWFILE_EXTENSION);\\n                if (filenameGlossarywithLocalChangesOnBase.exists()) {\\n                                        filenameGlossarywithLocalChangesOnBase.delete();\\n                }\\n                filenameGlossarywithLocalChangesOnBase.createNewFile();\\n                for (GlossaryEntry ge : glossaryEntries) {\\n                    GlossaryReaderTSV.append(filenameGlossarywithLocalChangesOnBase, ge);\\n                }\\n            }\\n                        repository.restoreBase(modifiedFiles);\\n                        baseTMX = new ProjectTMX(m_config.getSourceLanguage(), m_config.getTargetLanguage(), m_config.isSentenceSegmentingEnabled(), projectTMXFile, null);\\n            if (updateGlossary) {\\n                baseGlossaryEntries = GlossaryReaderTSV.read(glossaryFile, true);\\n            }\\n                                                                                    unlockProject();             try {\\n                repository.reset();\\n            } finally {\\n                lockProject();             }\\n                        try {\\n                                                repository.download(modifiedFiles);\\n                                setOnlineMode();\\n            } catch (IRemoteRepository.NetworkException ex) {\\n                                setOfflineMode();\\n                                needUpload = false;\\n                            } catch (Exception ex) {\\n                                needUpload = false;\\n                            }\\n            String headRevTMX = repository.getBaseRevisionId(projectTMXFile);\\n            Log.logDebug(LOGGER, \\\"rebaseProject: TMX head revision: {0}\\\", headRevTMX);\\n            if (headRevTMX.equals(baseRevTMX)) {\\n                Log.logDebug(LOGGER, \\\"rebaseProject: head equals base\\\");\\n                                filenameTMXwithLocalChangesOnHead = filenameTMXwithLocalChangesOnBase;\\n                filenameTMXwithLocalChangesOnBase = null;\\n                                baseTMX = null;\\n            } else {\\n                Log.logDebug(LOGGER, \\\"rebaseProject: real rebase\\\");\\n                                again = true;\\n                headTMX = new ProjectTMX(m_config.getSourceLanguage(), m_config.getTargetLanguage(), m_config.isSentenceSegmentingEnabled(), projectTMXFile, null);\\n                mergeTMX(baseTMX, headTMX, commitDetails);\\n                                SwingUtilities.invokeAndWait(new Runnable() {\\n                    @Override\\n                    public void run() {\\n                        Core.getEditor().refreshView(false);\\n                    }\\n                });\\n                filenameTMXwithLocalChangesOnHead = new File(projectTMXFilename + \\\"-based_on_\\\" + headRevTMX + OConsts.NEWFILE_EXTENSION);\\n                projectTMX.exportTMX(m_config, filenameTMXwithLocalChangesOnHead, false, false, true);\\n                if (System.getProperty(\\\"team.supersafe\\\") != null) {\\n                                        File bak = new File(projectTMXFilename + \\\"-merged_on_\\\" + headRevTMX + \\\"_at_\\\"\\n                            + new SimpleDateFormat(\\\"MMdd-HHmmss\\\").format(new Date())\\n                            + OConsts.BACKUP_EXTENSION);\\n                    projectTMX.exportTMX(m_config, bak, false, false, true);\\n                }\\n                                headTMX = null;\\n            }\\n            if (updateGlossary) {\\n                String headRevGlossary = repository.getBaseRevisionId(glossaryFile);\\n                Log.logDebug(LOGGER, \\\"rebaseProject: glossary head revision: {0}\\\", headRevGlossary);\\n                if (headRevGlossary.equals(baseRevGlossary)) {\\n                                        filenameGlossarywithLocalChangesOnHead = filenameGlossarywithLocalChangesOnBase;\\n                    filenameGlossarywithLocalChangesOnBase = null;\\n                                        baseGlossaryEntries = null;\\n                } else {\\n                    again = true;\\n                    headGlossaryEntries = GlossaryReaderTSV.read(glossaryFile, true);\\n                    List<GlossaryEntry> deltaAddedGlossaryLocal = new ArrayList<GlossaryEntry>(glossaryEntries);\\n                    deltaAddedGlossaryLocal.removeAll(baseGlossaryEntries);\\n                    List<GlossaryEntry> deltaRemovedGlossaryLocal = new ArrayList<GlossaryEntry>(baseGlossaryEntries);\\n                    deltaRemovedGlossaryLocal.removeAll(glossaryEntries);\\n                    headGlossaryEntries.addAll(deltaAddedGlossaryLocal);\\n                    headGlossaryEntries.removeAll(deltaRemovedGlossaryLocal);\\n                    filenameGlossarywithLocalChangesOnHead = new File(glossaryFilename + \\\"-based_on_\\\" + headRevGlossary + OConsts.NEWFILE_EXTENSION);\\n                    filenameGlossarywithLocalChangesOnHead.createNewFile();\\n                    for (GlossaryEntry ge : headGlossaryEntries) {\\n                        GlossaryReaderTSV.append(filenameGlossarywithLocalChangesOnHead, ge);\\n                    }\\n                                        headGlossaryEntries = null;\\n                    baseGlossaryEntries = null;\\n                }\\n            } else {\\n                filenameGlossarywithLocalChangesOnHead = null;\\n            }\\n            projectTMXFile.delete();                         FileUtil.rename(filenameTMXwithLocalChangesOnHead, projectTMXFile);\\n            if (filenameTMXwithLocalChangesOnBase != null) {\\n                                if (!filenameTMXwithLocalChangesOnBase.delete()) {\\n                    throw new IOException(\\\"Error remove old file\\\");\\n                }\\n            }\\n            if (updateGlossary) {\\n                glossaryFile.delete();\\n                FileUtil.rename(filenameGlossarywithLocalChangesOnHead, glossaryFile);\\n                if (filenameGlossarywithLocalChangesOnBase != null) {\\n                                        if (!filenameGlossarywithLocalChangesOnBase.delete()) {\\n                        throw new IOException(\\\"Error remove old glossary file\\\");\\n                    }\\n                }\\n            }\\n            if (!again) {\\n                                glossaryEntries = null;\\n                break;\\n            }\\n        }\\n                if (needUpload) {\\n            final String author = Preferences.getPreferenceDefault(Preferences.TEAM_AUTHOR,\\n                    System.getProperty(\\\"user.name\\\"));\\n            try {\\n                new RepositoryUtils.AskCredentials() {\\n                    public void callRepository() throws Exception {\\n                        repository.upload(projectTMXFile,\\n                                \\\"Translated by \\\" + author + commitDetails.toString());\\n                        if (updateGlossary) {\\n                            repository.upload(glossaryFile, \\\"Added glossaryitem(s) by \\\" + author);\\n                        }\\n                    }\\n                }.execute(repository);\\n                setOnlineMode();\\n            } catch (IRemoteRepository.NetworkException ex) {\\n                setOfflineMode();\\n            } catch (Exception ex) {\\n                throw new KnownException(ex, \\\"TEAM_SYNCHRONIZATION_ERROR\\\");\\n            }\\n        }\\n        Log.logInfoRB(\\\"TEAM_REBASE_END\\\");\\n    }\\n    protected void mergeTMX(ProjectTMX baseTMX, ProjectTMX headTMX, StringBuilder commitDetails) {\\n        StmProperties props = new StmProperties().setBaseTmxName(OStrings.getString(\\\"TMX_MERGE_BASE\\\"))\\n                .setTmx1Name(OStrings.getString(\\\"TMX_MERGE_MINE\\\"))\\n                .setTmx2Name(OStrings.getString(\\\"TMX_MERGE_THEIRS\\\"))\\n                .setLanguageResource(OStrings.getResourceBundle())\\n                .setParentWindow(Core.getMainWindow().getApplicationFrame())\\n                                .setListViewThreshold(5);\\n        ProjectTMX mergedTMX = SuperTmxMerge.merge(baseTMX, projectTMX, headTMX, m_config.getSourceLanguage()\\n                .getLanguage(), m_config.getTargetLanguage().getLanguage(), props);\\n        projectTMX.replaceContent(mergedTMX);\\n        Log.logDebug(LOGGER, \\\"Merge report: {0}\\\", props.getReport());\\n        commitDetails.append('\\\\n');\\n        commitDetails.append(props.getReport().toString());\\n    }\\n    private void createDirectory(final String dir, final String dirType) throws IOException {\\n        File d = new File(dir);\\n        if (!d.isDirectory()) {\\n            if (!d.mkdirs()) {\\n                StringBuilder msg = new StringBuilder(OStrings.getString(\\\"CT_ERROR_CREATE\\\"));\\n                if (dirType != null) {\\n                    msg.append(\\\"\\\\n(.../\\\").append(dirType).append(\\\"/)\\\");\\n                }\\n                throw new IOException(msg.toString());\\n            }\\n        }\\n    }\\n    private void loadTranslations() throws Exception {\\n        final File tmxFile = new File(m_config.getProjectInternal() + OConsts.STATUS_EXTENSION);\\n        try {\\n            Core.getMainWindow().showStatusMessageRB(\\\"CT_LOAD_TMX\\\");\\n            projectTMX = new ProjectTMX(m_config.getSourceLanguage(), m_config.getTargetLanguage(), m_config.isSentenceSegmentingEnabled(), tmxFile, checkOrphanedCallback);\\n            if (tmxFile.exists()) {\\n                                FileUtil.backupFile(tmxFile);\\n                FileUtil.removeOldBackups(tmxFile, System.getProperty(\\\"team.supersafe\\\") != null ? 300\\n                        : OConsts.MAX_BACKUPS);\\n            }\\n        } catch (SAXParseException ex) {\\n            Log.logErrorRB(ex, \\\"TMXR_FATAL_ERROR_WHILE_PARSING\\\", ex.getLineNumber(), ex.getColumnNumber());\\n            throw ex;\\n        } catch (Exception ex) {\\n            Log.logErrorRB(ex, \\\"TMXR_EXCEPTION_WHILE_PARSING\\\", tmxFile.getAbsolutePath(),\\n                    Log.getLogLocation());\\n            throw ex;\\n        }\\n    }\\n    private void loadSourceFiles() throws Exception {\\n        long st = System.currentTimeMillis();\\n        FilterMaster fm = Core.getFilterMaster();\\n        File root = new File(m_config.getSourceRoot());\\n        List<File> srcFileList = StaticUtils.buildFileList(root, true);\\n        List<String> srcPathList = new ArrayList<String>(srcFileList.size());\\n        for (File file : srcFileList) {\\n            srcPathList.add(file.getPath().substring(m_config.getSourceRoot().length()).replace('\\\\\\\\', '/'));\\n        }\\n        StaticUtils.removeFilesByMasks(srcPathList, m_config.getSourceRootExcludes());\\n        StaticUtils.sortByList(srcPathList, getSourceFilesOrder());\\n        for (String filepath : srcPathList) {\\n            Core.getMainWindow().showStatusMessageRB(\\\"CT_LOAD_FILE_MX\\\", filepath);\\n            LoadFilesCallback loadFilesCallback = new LoadFilesCallback(existSource, existKeys);\\n            FileInfo fi = new FileInfo();\\n            fi.filePath = filepath;\\n            loadFilesCallback.setCurrentFile(fi);\\n            IFilter filter = fm.loadFile(m_config.getSourceRoot() + filepath, new FilterContext(m_config),\\n                    loadFilesCallback);\\n            loadFilesCallback.fileFinished();\\n            if (filter != null && !fi.entries.isEmpty()) {\\n                fi.filterClass = filter.getClass();                                                                                                                         fi.filterFileFormatName = filter.getFileFormatName();\\n                try {\\n                    fi.fileEncoding = filter.getInEncodingLastParsedFile();\\n                } catch (Error e) {                     fi.fileEncoding = \\\"\\\";\\n                }\\n                projectFilesList.add(fi);\\n            }\\n        }\\n        findNonUniqueSegments();\\n        Core.getMainWindow().showStatusMessageRB(\\\"CT_LOAD_SRC_COMPLETE\\\");\\n        long en = System.currentTimeMillis();\\n        Log.log(\\\"Load project source files: \\\" + (en - st) + \\\"ms\\\");\\n    }\\n    protected void findNonUniqueSegments() {\\n        Map<String, SourceTextEntry> exists = new HashMap<String, SourceTextEntry>(16384);\\n        for (FileInfo fi : projectFilesList) {\\n            for (int i = 0; i < fi.entries.size(); i++) {\\n                SourceTextEntry ste = fi.entries.get(i);\\n                SourceTextEntry prevSte = exists.get(ste.getSrcText());\\n                if (prevSte == null) {\\n                                        exists.put(ste.getSrcText(), ste);\\n                } else {\\n                                        if (prevSte.duplicates == null) {\\n                        prevSte.duplicates = new ArrayList<SourceTextEntry>();\\n                    }\\n                    prevSte.duplicates.add(ste);\\n                    ste.firstInstance = prevSte;\\n                }\\n            }\\n        }\\n    }\\n    void importTranslationsFromSources() {\\n                        Map<String, String> allowToImport = new HashMap<String, String>();\\n        for (FileInfo fi : projectFilesList) {\\n            for (int i = 0; i < fi.entries.size(); i++) {\\n                SourceTextEntry ste = fi.entries.get(i);\\n                if (ste.getSourceTranslation() == null || ste.isSourceTranslationFuzzy() ||\\n                   ste.getSrcText().equals(ste.getSourceTranslation()) && !allowTranslationEqualToSource) {\\n                                                            continue;\\n                }\\n                PrepareTMXEntry prepare = new PrepareTMXEntry();\\n                prepare.source = ste.getSrcText();\\n                                if (m_config.isSupportDefaultTranslations()) {\\n                                        TMXEntry enDefault = projectTMX.getDefaultTranslation(ste.getSrcText());\\n                    if (enDefault == null) {\\n                                                prepare.translation = ste.getSourceTranslation();\\n                        projectTMX.setTranslation(ste, new TMXEntry(prepare, true, null), true);\\n                        allowToImport.put(ste.getSrcText(), ste.getSourceTranslation());\\n                    } else {\\n                                                                        String justImported = allowToImport.get(ste.getSrcText());\\n                                                if (justImported != null && !ste.getSourceTranslation().equals(justImported)) {\\n                                                                                    prepare.translation = ste.getSourceTranslation();\\n                            projectTMX.setTranslation(ste, new TMXEntry(prepare, false, null), false);\\n                        }\\n                    }\\n                } else {                                         TMXEntry en = projectTMX.getMultipleTranslation(ste.getKey());\\n                    if (en == null) {\\n                                                prepare.translation = ste.getSourceTranslation();\\n                        projectTMX.setTranslation(ste, new TMXEntry(prepare, false, null), false);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    private void loadTM() throws IOException {\\n        final File tmRoot = new File(m_config.getTMRoot());\\n        tmMonitor = new DirectoryMonitor(tmRoot, new DirectoryMonitor.Callback() {\\n            public void fileChanged(File file) {\\n                if (!file.getName().endsWith(OConsts.TMX_EXTENSION)\\n                        && !file.getName().endsWith(OConsts.TMX_GZ_EXTENSION)) {\\n                                        return;\\n                }\\n                if (file.getPath().startsWith(m_config.getTMOtherLangRoot()) ) {\\n                                        return;\\n                }\\n                                Map<String, ExternalTMX> newTransMemories = new TreeMap<String, ExternalTMX>(transMemories);\\n                if (file.exists()) {\\n                    try {\\n                        ExternalTMX newTMX = new ExternalTMX(m_config, file,\\n                                Preferences.isPreference(Preferences.EXT_TMX_SHOW_LEVEL2),\\n                                Preferences.isPreference(Preferences.EXT_TMX_USE_SLASH));\\n                        newTransMemories.put(file.getPath(), newTMX);\\n                                                                                                                        if (FileUtil.computeRelativePath(tmRoot, file).startsWith(OConsts.AUTO_TM + \\\"/\\\")) {                         \\n                            appendFromAutoTMX(newTMX, false);\\n                        } else if (FileUtil.computeRelativePath(tmRoot, file).startsWith(OConsts.AUTO_ENFORCE_TM + '/')) {\\n                            appendFromAutoTMX(newTMX, true);\\n                        }                          \\n                    } catch (Exception e) {\\n                        String filename = file.getPath();\\n                        Log.logErrorRB(e, \\\"TF_TM_LOAD_ERROR\\\", filename);\\n                        Core.getMainWindow().displayErrorRB(e, \\\"TF_TM_LOAD_ERROR\\\", filename);\\n                    }\\n                } else {\\n                    newTransMemories.remove(file.getPath());\\n                }\\n                transMemories = newTransMemories;\\n            }\\n        });\\n        tmMonitor.checkChanges();\\n        tmMonitor.start();\\n    }\\n    private void loadOtherLanguages() throws IOException {\\n        final File tmOtherLanguagesRoot = new File(m_config.getTMOtherLangRoot());\\n        tmOtherLanguagesMonitor = new DirectoryMonitor(tmOtherLanguagesRoot, new DirectoryMonitor.Callback() {\\n            public void fileChanged(File file) {\\n                if (!file.getName().matches(\\\"[A-Z]{2}([-_][A-Z]{2})?\\\\\\\\.tmx\\\")) {\\n                                        return;\\n                }\\n                Language targetLanguage = new Language(file.getName().substring(0, file.getName().length()-4));\\n                                Map<Language, ProjectTMX> newOtherTargetLangTMs = new TreeMap<Language, ProjectTMX>(otherTargetLangTMs);\\n                if (file.exists()) {\\n                    try {\\n                        ProjectTMX newTMX = new ProjectTMX(m_config.getSourceLanguage(), targetLanguage,\\n                            m_config.isSentenceSegmentingEnabled(), file, checkOrphanedCallback);\\n                        newOtherTargetLangTMs.put(targetLanguage, newTMX);\\n                    } catch (Exception e) {\\n                        String filename = file.getPath();\\n                        Log.logErrorRB(e, \\\"TF_TM_LOAD_ERROR\\\", filename);\\n                        Core.getMainWindow().displayErrorRB(e, \\\"TF_TM_LOAD_ERROR\\\", filename);\\n                    }\\n                } else {\\n                    newOtherTargetLangTMs.remove(targetLanguage);\\n                }\\n                otherTargetLangTMs = newOtherTargetLangTMs;\\n            }\\n        });\\n        tmOtherLanguagesMonitor.checkChanges();\\n        tmOtherLanguagesMonitor.start();\\n    }\\n    void appendFromAutoTMX(ExternalTMX tmx, boolean isEnforcedTMX) {\\n        synchronized (projectTMX) {\\n            importHandler.process(tmx, isEnforcedTMX);\\n        }\\n    }\\n    public List<SourceTextEntry> getAllEntries() {\\n        return allProjectEntries;\\n    }\\n    public TMXEntry getTranslationInfo(SourceTextEntry ste) {\\n        TMXEntry r = projectTMX.getMultipleTranslation(ste.getKey());\\n        if (r == null) {\\n            r = projectTMX.getDefaultTranslation(ste.getSrcText());\\n        }\\n        if (r == null) {\\n            r = EMPTY_TRANSLATION;\\n        }\\n        return r;\\n    }\\n    public AllTranslations getAllTranslations(SourceTextEntry ste) {\\n        AllTranslations r = new AllTranslations();\\n        synchronized (projectTMX) {\\n            r.defaultTranslation = projectTMX.getDefaultTranslation(ste.getSrcText());\\n            r.alternativeTranslation = projectTMX.getMultipleTranslation(ste.getKey());\\n            if (r.alternativeTranslation != null) {\\n                r.currentTranslation = r.alternativeTranslation;\\n            } else if (r.defaultTranslation != null) {\\n                r.currentTranslation = r.defaultTranslation;\\n            } else {\\n                r.currentTranslation = EMPTY_TRANSLATION;\\n            }\\n            if (r.defaultTranslation == null) {\\n                r.defaultTranslation = EMPTY_TRANSLATION;\\n            }\\n            if (r.alternativeTranslation == null) {\\n                r.alternativeTranslation = EMPTY_TRANSLATION;\\n            }\\n        }\\n        return r;\\n    }\\n    public ProjectProperties getProjectProperties() {\\n        return m_config;\\n    }\\n    public boolean isProjectModified() {\\n        return m_modifiedFlag;\\n    }\\n    private void setProjectModified(boolean isModified) {\\n        m_modifiedFlag = isModified;\\n        if (isModified) {\\n            CoreEvents.fireProjectChange(IProjectEventListener.PROJECT_CHANGE_TYPE.MODIFIED);\\n        }\\n    }\\n    @Override\\n    public void setTranslation(SourceTextEntry entry, PrepareTMXEntry trans, boolean defaultTranslation,\\n            ExternalLinked externalLinked, AllTranslations previous) throws OptimisticLockingFail {\\n        if (trans == null) {\\n            throw new IllegalArgumentException(\\\"RealProject.setTranslation(tr) can't be null\\\");\\n        }\\n        synchronized (projectTMX) {\\n            AllTranslations current = getAllTranslations(entry);\\n            boolean wasAlternative = current.alternativeTranslation.isTranslated();\\n            if (defaultTranslation) {\\n                if (!current.defaultTranslation.equals(previous.defaultTranslation)) {\\n                    throw new OptimisticLockingFail(previous.getDefaultTranslation().translation,\\n                            current.getDefaultTranslation().translation, current);\\n                }\\n                if (wasAlternative) {\\n                                        if (!current.alternativeTranslation.equals(previous.alternativeTranslation)) {\\n                        throw new OptimisticLockingFail(previous.getAlternativeTranslation().translation,\\n                                current.getAlternativeTranslation().translation, current);\\n                    }\\n                                        setTranslation(entry, new PrepareTMXEntry(), false, null);\\n                }\\n            } else {\\n                                if (!current.alternativeTranslation.equals(previous.alternativeTranslation)) {\\n                    throw new OptimisticLockingFail(previous.getAlternativeTranslation().translation,\\n                            current.getAlternativeTranslation().translation, current);\\n                }\\n            }\\n            setTranslation(entry, trans, defaultTranslation, externalLinked);\\n        }\\n    }\\n    @Override\\n    public void setTranslation(final SourceTextEntry entry, final PrepareTMXEntry trans, boolean defaultTranslation, TMXEntry.ExternalLinked externalLinked) {\\n        if (trans == null) {\\n            throw new IllegalArgumentException(\\\"RealProject.setTranslation(tr) can't be null\\\");\\n        }\\n        TMXEntry prevTrEntry = defaultTranslation ? projectTMX.getDefaultTranslation(entry.getSrcText())\\n                : projectTMX.getMultipleTranslation(entry.getKey());\\n        trans.changer = Preferences.getPreferenceDefault(Preferences.TEAM_AUTHOR,\\n                System.getProperty(\\\"user.name\\\"));\\n        trans.changeDate = System.currentTimeMillis();\\n        if (prevTrEntry == null) {\\n                        prevTrEntry = EMPTY_TRANSLATION;\\n            trans.creationDate = trans.changeDate;\\n            trans.creator = trans.changer;\\n        } else {\\n            trans.creationDate = prevTrEntry.creationDate;\\n            trans.creator = prevTrEntry.creator;\\n        }\\n        if (StringUtil.isEmpty(trans.note)) {\\n            trans.note = null;\\n        }\\n        trans.source = entry.getSrcText();\\n        TMXEntry newTrEntry;\\n        if (trans.translation == null && trans.note == null) {\\n                        newTrEntry = null;\\n        } else {\\n            newTrEntry = new TMXEntry(trans, defaultTranslation, externalLinked);\\n        }\\n        setProjectModified(true);\\n        projectTMX.setTranslation(entry, newTrEntry, defaultTranslation);\\n        int diff = prevTrEntry.translation == null ? 0 : -1;\\n        diff += trans.translation == null ? 0 : +1;\\n        hotStat.numberofTranslatedSegments = Math.max(0, \\n                Math.min(hotStat.numberOfUniqueSegments, hotStat.numberofTranslatedSegments + diff));\\n    }\\n    @Override\\n    public void setNote(final SourceTextEntry entry, final TMXEntry oldTE, String note) {\\n        if (oldTE == null) {\\n            throw new IllegalArgumentException(\\\"RealProject.setNote(tr) can't be null\\\");\\n        }\\n                if (note != null && note.isEmpty()) {\\n            note = null;\\n        }\\n        TMXEntry prevTrEntry = oldTE.defaultTranslation ? projectTMX\\n                .getDefaultTranslation(entry.getSrcText()) : projectTMX\\n                .getMultipleTranslation(entry.getKey());\\n        if (prevTrEntry != null) {\\n            PrepareTMXEntry en = new PrepareTMXEntry(prevTrEntry);\\n            en.note = note;\\n            projectTMX.setTranslation(entry, new TMXEntry(en, prevTrEntry.defaultTranslation,\\n                    prevTrEntry.linked), prevTrEntry.defaultTranslation);\\n        } else {\\n            PrepareTMXEntry en = new PrepareTMXEntry();\\n            en.source = entry.getSrcText();\\n            en.note = note;\\n            en.translation = null;\\n            projectTMX.setTranslation(entry, new TMXEntry(en, true, null), true);\\n        }\\n        setProjectModified(true);\\n    }\\n    @SuppressWarnings(\\\"unchecked\\\")\\n    public void iterateByDefaultTranslations(DefaultTranslationsIterator it) {\\n        Map.Entry<String, TMXEntry>[] entries;\\n        synchronized (projectTMX) {\\n            Set<Map.Entry<String, TMXEntry>> set = projectTMX.defaults.entrySet();\\n            entries = set.toArray(new Map.Entry[set.size()]);\\n        }\\n        for (Map.Entry<String, TMXEntry> en : entries) {\\n            it.iterate(en.getKey(), en.getValue());\\n        }\\n    }\\n    @SuppressWarnings(\\\"unchecked\\\")\\n    public void iterateByMultipleTranslations(MultipleTranslationsIterator it) {\\n        Map.Entry<EntryKey, TMXEntry>[] entries;\\n        synchronized (projectTMX) {\\n            Set<Map.Entry<EntryKey, TMXEntry>> set = projectTMX.alternatives.entrySet();\\n            entries = set.toArray(new Map.Entry[set.size()]);\\n        }\\n        for (Map.Entry<EntryKey, TMXEntry> en : entries) {\\n            it.iterate(en.getKey(), en.getValue());\\n        }\\n    }\\n    public boolean isOrphaned(String source) {\\n        return !checkOrphanedCallback.existSourceInProject(source);\\n    }\\n    public boolean isOrphaned(EntryKey entry) {\\n        return !checkOrphanedCallback.existEntryInProject(entry);\\n    }\\n    public Map<String, ExternalTMX> getTransMemories() {\\n        return transMemories;\\n    }\\n    public Map<Language, ProjectTMX> getOtherTargetLanguageTMs() {\\n        return otherTargetLangTMs;\\n    }\\n    public ITokenizer getSourceTokenizer() {\\n        return sourceTokenizer;\\n    }\\n    public ITokenizer getTargetTokenizer() {\\n        return targetTokenizer;\\n    }\\n    protected ITokenizer createTokenizer(String cmdLine, Class<?> projectPref) {\\n        if (!StringUtil.isEmpty(cmdLine)) {\\n            try {\\n                return (ITokenizer) this.getClass().getClassLoader().loadClass(cmdLine).newInstance();\\n            } catch (ClassNotFoundException e) {\\n                Log.log(e.toString());\\n            } catch (Throwable e) {\\n                throw new RuntimeException(e);\\n            }\\n        }\\n        try {\\n            return (ITokenizer) projectPref.newInstance();\\n        } catch (Throwable e) {\\n            Log.log(e);\\n        }\\n        return new DefaultTokenizer();\\n    }\\n    protected void configTokenizer(String cmdLine, ITokenizer tokenizer) {\\n                if (!StringUtil.isEmpty(cmdLine)) {\\n            try {\\n                tokenizer.setBehavior(Version.valueOf(cmdLine));\\n                return;\\n            } catch (Throwable e) {\\n                throw new RuntimeException(e);\\n            }\\n        }\\n                String vString = Preferences.getPreferenceDefault(\\n                Preferences.TOK_BEHAVIOR_PREFIX + tokenizer.getClass().getName(),\\n                null);\\n         if (!StringUtil.isEmpty(vString)) {\\n             try {\\n                 tokenizer.setBehavior(Version.valueOf(vString));\\n                 return;\\n             }  catch (Throwable e) {\\n                 throw new RuntimeException(e);\\n             }\\n         }\\n             }\\n    public List<FileInfo> getProjectFiles() {\\n        return Collections.unmodifiableList(projectFilesList);\\n    }\\n    @Override\\n    public String getTargetPathForSourceFile(String currentSource) {\\n        if (StringUtil.isEmpty(currentSource)) {\\n            return null;\\n        }\\n        try {\\n            return Core.getFilterMaster().getTargetForSource(m_config.getSourceRoot(),\\n                    currentSource, new FilterContext(m_config));\\n        } catch (Exception e) {\\n            Log.log(e);\\n        }\\n        return null;\\n    }\\n    @Override\\n    public List<String> getSourceFilesOrder() {\\n        final String file = m_config.getProjectInternal() + OConsts.FILES_ORDER_FILENAME;\\n        try {\\n            BufferedReader rd = new BufferedReader(new InputStreamReader(new FileInputStream(file), \\\"UTF-8\\\"));\\n            List<String> result = new ArrayList<String>();\\n            String s;\\n            while ((s = rd.readLine()) != null) {\\n                result.add(s);\\n            }\\n            rd.close();\\n            return result;\\n        } catch (Exception ex) {\\n            return null;\\n        }\\n    }\\n    @Override\\n    public void setSourceFilesOrder(List<String> filesList) {\\n        final String file = m_config.getProjectInternal() + OConsts.FILES_ORDER_FILENAME;\\n        try {\\n            BufferedWriter wr = new BufferedWriter(\\n                    new OutputStreamWriter(new FileOutputStream(file), \\\"UTF-8\\\"));\\n            for (String f : filesList) {\\n                wr.write(f);\\n                wr.write('\\\\n');\\n            }\\n            wr.close();\\n        } catch (Exception ex) {\\n            Log.log(ex);\\n        }\\n    }\\n    protected String patchFileNameForEntryKey(String filename) {\\n        String f = Core.getParams().get(CLIParameters.ALTERNATE_FILENAME_FROM);\\n        String t = Core.getParams().get(CLIParameters.ALTERNATE_FILENAME_TO);\\n        String fn = filename.replace('\\\\\\\\', '/');\\n        if (f != null && t != null) {\\n            fn = fn.replaceAll(f, t);\\n        }\\n        return fn;\\n    }\\n    protected class LoadFilesCallback extends ParseEntry {\\n        private FileInfo fileInfo;\\n        private String entryKeyFilename;\\n        private final Set<String> existSource;\\n        private final Set<EntryKey> existKeys;\\n        public LoadFilesCallback(final Set<String> existSource, final Set<EntryKey> existKeys) {\\n            super(m_config);\\n            this.existSource = existSource;\\n            this.existKeys = existKeys;\\n        }\\n        public void setCurrentFile(FileInfo fi) {\\n            fileInfo = fi;\\n            super.setCurrentFile(fi);\\n            entryKeyFilename = patchFileNameForEntryKey(fileInfo.filePath);\\n        }\\n        public void fileFinished() {\\n            super.fileFinished();\\n            fileInfo = null;\\n        }\\n        protected void addSegment(String id, short segmentIndex, String segmentSource,\\n                List<ProtectedPart> protectedParts, String segmentTranslation, boolean segmentTranslationFuzzy,\\n                String comment, String prevSegment, String nextSegment, String path) {\\n                        if (segmentSource.trim().isEmpty()) {\\n                throw new RuntimeException(\\\"Segment must not be empty\\\");\\n            }\\n            EntryKey ek = new EntryKey(entryKeyFilename, segmentSource, id, prevSegment, nextSegment, path);\\n            protectedParts = TagUtil.applyCustomProtectedParts(segmentSource,\\n                    PatternConsts.getPlaceholderPattern(), protectedParts);\\n                        if (ek.sourceText.equals(segmentTranslation) && \\n                    !allowTranslationEqualToSource) {\\n                segmentTranslation = null;\\n            }\\n            SourceTextEntry srcTextEntry = new SourceTextEntry(ek, allProjectEntries.size() + 1, comment,\\n                    segmentTranslation, protectedParts);\\n            srcTextEntry.setSourceTranslationFuzzy(segmentTranslationFuzzy);\\n            allProjectEntries.add(srcTextEntry);\\n            fileInfo.entries.add(srcTextEntry);\\n            existSource.add(segmentSource);\\n            existKeys.add(srcTextEntry.getKey());\\n        }\\n    };\\n    private class TranslateFilesCallback extends TranslateEntry {\\n        private String currentFile;\\n        @Override\\n        protected String getCurrentFile(){\\n            return currentFile;\\n        }\\n        public TranslateFilesCallback() {\\n            super(m_config);\\n        }\\n        protected void fileStarted(String fn) {\\n            currentFile = patchFileNameForEntryKey(fn);\\n            super.fileStarted();\\n        }\\n        protected String getSegmentTranslation(String id, int segmentIndex, String segmentSource,\\n                String prevSegment, String nextSegment, String path) {\\n            EntryKey ek = new EntryKey(currentFile, segmentSource, id, prevSegment, nextSegment, path);\\n            TMXEntry tr = projectTMX.getMultipleTranslation(ek);\\n            if (tr == null) {\\n                tr = projectTMX.getDefaultTranslation(ek.sourceText);\\n            }\\n            return tr != null ? tr.translation : null;\\n        }\\n    };\\n    static class AlignFilesCallback implements IAlignCallback {\\n        public AlignFilesCallback(ProjectProperties props) {\\n            super();\\n            this.config = props;\\n        }\\n        Map<String, TMXEntry> data = new HashMap<String, TMXEntry>();\\n        private ProjectProperties config;\\n        @Override\\n        public void addTranslation(String id, String source, String translation, boolean isFuzzy, String path,\\n                IFilter filter) {\\n            if (source != null && translation != null) {\\n                ParseEntry.ParseEntryResult spr = new ParseEntry.ParseEntryResult();\\n                boolean removeSpaces = Core.getFilterMaster().getConfig().isRemoveSpacesNonseg();\\n                String sourceS = ParseEntry.stripSomeChars(source, spr, config.isRemoveTags(), removeSpaces);\\n                String transS = ParseEntry.stripSomeChars(translation, spr, config.isRemoveTags(), removeSpaces);\\n                PrepareTMXEntry tr = new PrepareTMXEntry();\\n                if (config.isSentenceSegmentingEnabled()) {\\n                    List<String> segmentsSource = Core.getSegmenter().segment(config.getSourceLanguage(), sourceS, null,\\n                            null);\\n                    List<String> segmentsTranslation = Core.getSegmenter()\\n                            .segment(config.getTargetLanguage(), transS, null, null);\\n                    if (segmentsTranslation.size() != segmentsSource.size()) {\\n                        if (isFuzzy) {\\n                            transS = \\\"[\\\" + filter.getFuzzyMark() + \\\"] \\\" + transS;\\n                        }\\n                        tr.source = sourceS;\\n                        tr.translation = transS;\\n                        data.put(sourceS, new TMXEntry(tr, true, null));\\n                    } else {\\n                        for (short i = 0; i < segmentsSource.size(); i++) {\\n                            String oneSrc = segmentsSource.get(i);\\n                            String oneTrans = segmentsTranslation.get(i);\\n                            if (isFuzzy) {\\n                                oneTrans = \\\"[\\\" + filter.getFuzzyMark() + \\\"] \\\" + oneTrans;\\n                            }\\n                            tr.source = oneSrc;\\n                            tr.translation = oneTrans;\\n                            data.put(sourceS, new TMXEntry(tr, true, null));\\n                        }\\n                    }\\n                } else {\\n                    if (isFuzzy) {\\n                        transS = \\\"[\\\" + filter.getFuzzyMark() + \\\"] \\\" + transS;\\n                    }\\n                    tr.source = sourceS;\\n                    tr.translation = transS;\\n                    data.put(sourceS, new TMXEntry(tr, true, null));\\n                }\\n            }\\n        }\\n    }\\n    ProjectTMX.CheckOrphanedCallback checkOrphanedCallback = new ProjectTMX.CheckOrphanedCallback() {\\n        public boolean existSourceInProject(String src) {\\n            return existSource.contains(src);\\n        }\\n        public boolean existEntryInProject(EntryKey key) {\\n            return existKeys.contains(key);\\n        }\\n    };\\n    void setOnlineMode() {\\n        if (!isOnlineMode) {\\n            Log.logInfoRB(\\\"VCS_ONLINE\\\");\\n            Core.getMainWindow().displayWarningRB(\\\"VCS_ONLINE\\\", \\\"VCS_OFFLINE\\\");\\n        }\\n        isOnlineMode = true;\\n    }\\n    void setOfflineMode() {\\n        if (isOnlineMode) {\\n            Log.logInfoRB(\\\"VCS_OFFLINE\\\");\\n            Core.getMainWindow().displayWarningRB(\\\"VCS_OFFLINE\\\", \\\"VCS_ONLINE\\\");\\n        }\\n        isOnlineMode = false;\\n    }\\n}\""
            },
            "m13": {
                "content": "The source code of `RealProject.java` has been successfully retrieved and contains a comprehensive implementation related to project management, translation handling, file I/O, and integration with version control systems (e.g., SVN, Git).\n\n### Key Observations from the Code:\n1. **Core Responsibilities**:\n   - `RealProject` is responsible for managing translation memory (`TMXEntry`, `ProjectTMX`), glossaries, source files, and synchronization with remote repositories.\n   - It interacts heavily with configuration, preferences, logging, and file utilities.\n\n2. **Key Dependencies**:\n   - **`Core`**: Used for accessing global application functionality like filters, segmentation, and UI components.\n   - **`Preferences` / `RuntimePreferences`**: Stores and retrieves user/project-specific settings.\n   - **`FileUtil` / `StaticUtils`**: Utility classes for file manipulation and general-purpose functions.\n   - **`IRemoteRepository` implementations (SVNRemoteRepository, GITRemoteRepository)**: For team collaboration and synchronization.\n   - **`FilterMaster` / `ITokenizer`**: Text processing components used in parsing and translating content.\n   - **`Log`**: Logging system.\n   - **`OConsts`**: Constants used across the application.\n\n3. **Interactions with Other Entities**:\n   - The class frequently uses entities such as `TMXWriter`, `ProjectTMX`, `SourceTextEntry`, `TranslationException`, `IAlignCallback`, etc., indicating deeper conceptual or functional ties.\n\n### Final List of Entities That Need Synchronization\nBased on all gathered data (co-change relationships, call graph, conceptual coupling, and actual code usage), here are the key files that may need synchronized changes when modifying `RealProject.java`:\n\n#### 1. High Co-Change + Conceptual Coupling:\n- `TMXWriter.java` (high conceptual coupling)\n\n#### 2. Direct Call Graph Dependencies:\n- `Core.java`\n- `Preferences.java`\n- `RuntimePreferences.java`\n- `FileUtil.java`\n- `StaticUtils.java`\n- `FilterMaster.java`\n- `ITokenizer.java`\n- `OConsts.java`\n- `Language.java`\n- `Log.java`\n- `IRemoteRepository.java`\n\n#### 3. Strong Co-Change Relationships:\n- `Main.java` (highest co-change confidence)\n- `SVNRemoteRepository.java`\n- `GITRemoteRepository.java`\n- `ProjectFactory.java`\n\n#### 4. Entities Frequently Used in Code:\n- `ProjectTMX.java`\n- `SourceTextEntry.java`\n- `TranslationException.java`\n- `IAlignCallback.java`\n- `TMXEntry.java`\n- `FileInfo.java`\n- `FilterContext.java`\n\n---\n\n### Conclusion:\nModifying `RealProject.java` will likely require synchronizing changes with these dependent files to maintain consistency and prevent regressions.\n\nWould you like me to summarize this into a structured report or focus on any specific entity for further analysis?",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            },
            "m14": {
                "role": "user",
                "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example, without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
            },
            "m15": {
                "content": "Title: Diagnosis of starting entity `RealProject.java`\n\nChange set: [TMXWriter, Core, RuntimePreferences, Preferences, StaticUtils, FilterMaster, IRemoteRepository, ITokenizer, OConsts, Language, Log, Main, SVNRemoteRepository, GITRemoteRepository, ProjectFactory, ProjectTMX, SourceTextEntry, TranslationException, IAlignCallback, TMXEntry, FileInfo, FilterContext, GlossaryReaderTSV, DefaultTokenizer, DirectoryMonitor, StringUtil, TagUtil, OStrings, KnownException, SRX, StatisticsInfo, CalcStandardStatistics, PatternConsts, ProjectFileStorage, CLIParameters, RepositoryUtils, UIThreadsUtil, CommandMonitor, ExternalTMX, EntryKey, ProjectUICommands, LoadFilesCallback, AlignFilesCallback, TMXWriter2, TMXReader2, ExternalTMXMatchesDialog]\n\nDetails:\n- **TMXWriter**: Strong conceptual coupling and frequent interaction in translation memory export/import.\n- **Core**: Used throughout for global access to filters, UI, and segmentation.\n- **RuntimePreferences / Preferences**: Central to reading/writing configuration settings.\n- **StaticUtils / FileUtil**: Utility functions used extensively for file operations.\n- **FilterMaster / ITokenizer**: Critical for parsing and tokenizing source content.\n- **OConsts**: Constants referenced across the project lifecycle.\n- **Language / Log**: Language handling and logging are fundamental to functionality.\n- **IRemoteRepository**: Base interface for team collaboration; tightly integrated.\n- **Main**: High co-change confidence suggests historical synchronization needs.\n- **SVNRemoteRepository / GITRemoteRepository**: Common VCS integrations that evolve with project structure.\n- **ProjectFactory**: Involved in project creation/loading workflows.\n- **ProjectTMX**: Manages translation memory, frequently accessed by RealProject.\n- **SourceTextEntry**: Represents core translation units managed in the project.\n- **TranslationException**: Exception handling is tightly coupled with file processing.\n- **IAlignCallback**: Used during alignment processes triggered from RealProject.\n- **TMXEntry**: Represents individual entries in translation memory.\n- **FileInfo**: Tracks file metadata and entries during loading.\n- **FilterContext**: Passed through filter operations during file processing.\n- **GlossaryReaderTSV / DefaultTokenizer**: Used in glossary and text segmentation logic.\n- **DirectoryMonitor**: Monitors translation memory and glossary directories.\n- **StringUtil / TagUtil / OStrings**: String manipulation utilities used throughout.\n- **KnownException**: Custom exceptions thrown during project operations.\n- **SRX / StatisticsInfo / CalcStandardStatistics**: Related to segmentation and statistics tracking.\n- **PatternConsts / ProjectFileStorage**: Used in file path and pattern handling.\n- **CLIParameters / RepositoryUtils / UIThreadsUtil**: Utilities for command-line, version control, and threading.\n- **CommandMonitor**: Used when executing external commands.\n- **ExternalTMX / EntryKey**: Represent external translation memories and unique entry identifiers.\n- **ProjectUICommands**: Likely involved in UI-triggered project actions.\n- **LoadFilesCallback / AlignFilesCallback**: Callback handlers for file loading/alignment tasks.\n- **TMXWriter2 / TMXReader2 / ExternalTMXMatchesDialog**: Secondary or related components in TMX handling.\n- **TestRealProject / TestTeamIntegration / TestCoreInitializer**: Test classes may need updates if internal APIs change.\n\nThese entities were selected based on co-change history, call graph analysis, conceptual coupling, and direct code usage. They represent the most likely candidates for synchronized changes alongside `RealProject.java`.",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            }
        }
    }
}