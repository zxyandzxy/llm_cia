{
    "time": 1749508878.574525,
    "messages": [
        {
            "role": "system",
            "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
        },
        {
            "role": "user",
            "content": "The project you need to analyze is `freecol`, a well-known Java open source project. The starting entity you need to deal with is GUI.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
        },
        {
            "content": "",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_f38bbaaea9634182adaede",
                    "function": {
                        "arguments": "{\"entity\": \"GUI.java\"}",
                        "name": "get_co_change_relationship"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "name": "get_co_change_relationship",
            "role": "tool",
            "content": "[[\"ImageLibrary\", \"4\", \"0.05263157894736842\"], [\"MiniMap\", \"7\", \"0.09210526315789473\"], [\"MapControls\", \"5\", \"0.06578947368421052\"], [\"FreeColLookAndFeel\", \"2\", \"0.02631578947368421\"], [\"ActionManager\", \"9\", \"0.11842105263157894\"], [\"ChatAction\", \"1\", \"0.013157894736842105\"], [\"EndTurnAction\", \"1\", \"0.013157894736842105\"], [\"CanvasKeyListener\", \"2\", \"0.02631578947368421\"], [\"FreeColMenuBar\", \"5\", \"0.06578947368421052\"], [\"InGameController\", \"12\", \"0.15789473684210525\"], [\"ClientOptions\", \"4\", \"0.05263157894736842\"], [\"ReportContinentalCongressPanel\", \"1\", \"0.013157894736842105\"], [\"FreeColClient\", \"4\", \"0.05263157894736842\"], [\"InGameInputHandler\", \"3\", \"0.039473684210526314\"], [\"PreGameController\", \"4\", \"0.05263157894736842\"], [\"ViewMode\", \"3\", \"0.039473684210526314\"], [\"InfoPanel\", \"3\", \"0.039473684210526314\"], [\"TileInfoPanel\", \"4\", \"0.05263157894736842\"], [\"DisplayTileOwnersAction\", \"3\", \"0.039473684210526314\"], [\"ImageProvider\", \"2\", \"0.02631578947368421\"], [\"UnitLabel\", \"10\", \"0.13157894736842105\"], [\"CanvasMapEditorMouseListener\", \"6\", \"0.07894736842105263\"], [\"CanvasMouseListener\", \"4\", \"0.05263157894736842\"], [\"ProductionLabel\", \"8\", \"0.10526315789473684\"], [\"ProductionPanel\", \"2\", \"0.02631578947368421\"], [\"TileImprovement\", \"1\", \"0.013157894736842105\"], [\"TileType\", \"1\", \"0.013157894736842105\"], [\"TerrainGenerator\", \"1\", \"0.013157894736842105\"], [\"TilePanel\", \"5\", \"0.06578947368421052\"], [\"InGameMenuBar\", \"7\", \"0.09210526315789473\"], [\"MapEditorMenuBar\", \"4\", \"0.05263157894736842\"], [\"Animation\", \"1\", \"0.013157894736842105\"], [\"UnitMoveAnimation\", \"11\", \"0.14473684210526316\"], [\"Canvas\", \"9\", \"0.11842105263157894\"], [\"MapControlsAction\", \"2\", \"0.02631578947368421\"], [\"DisplayTileNamesAction\", \"2\", \"0.02631578947368421\"], [\"DisplayRegionAction\", \"1\", \"0.013157894736842105\"], [\"GotoAction\", \"1\", \"0.013157894736842105\"], [\"CanvasMouseMotionListener\", \"1\", \"0.013157894736842105\"], [\"DisplayTileEmptyAction\", \"1\", \"0.013157894736842105\"], [\"DisplayTileRegionsAction\", \"1\", \"0.013157894736842105\"], [\"DisplayBordersAction\", \"2\", \"0.02631578947368421\"], [\"ProductionMultiplesLabel\", \"6\", \"0.07894736842105263\"], [\"OutForAnimationCallback\", \"1\", \"0.013157894736842105\"], [\"UnitImageAnimation\", \"5\", \"0.06578947368421052\"], [\"CombatOdds\", \"1\", \"0.013157894736842105\"], [\"CombatModel\", \"1\", \"0.013157894736842105\"], [\"Animations\", \"4\", \"0.05263157894736842\"], [\"CombatResult\", \"1\", \"0.013157894736842105\"], [\"IndianSettlementPanel\", \"2\", \"0.02631578947368421\"], [\"TilePopup\", \"2\", \"0.02631578947368421\"], [\"UnitMoveAnimationCanvasSwingTask\", \"3\", \"0.039473684210526314\"], [\"DisplayGridAction\", \"1\", \"0.013157894736842105\"], [\"ZoomOutAction\", \"2\", \"0.02631578947368421\"], [\"ZoomInAction\", \"2\", \"0.02631578947368421\"], [\"MapEditorController\", \"9\", \"0.11842105263157894\"], [\"GoodsLabel\", \"2\", \"0.02631578947368421\"], [\"MarketLabel\", \"1\", \"0.013157894736842105\"], [\"FreeColPanel\", \"3\", \"0.039473684210526314\"], [\"FreeColProgressBar\", \"1\", \"0.013157894736842105\"], [\"DebugMenu\", \"5\", \"0.06578947368421052\"], [\"PlayersTable\", \"2\", \"0.02631578947368421\"], [\"MapGenerator\", \"1\", \"0.013157894736842105\"], [\"BuildQueuePanel\", \"2\", \"0.02631578947368421\"], [\"Market\", \"1\", \"0.013157894736842105\"], [\"FreeColDialog\", \"3\", \"0.039473684210526314\"], [\"EuropePanel\", \"1\", \"0.013157894736842105\"], [\"PlayersTableModel\", \"1\", \"0.013157894736842105\"], [\"EmigrationPanel\", \"1\", \"0.013157894736842105\"], [\"PlayerCellEditor\", \"1\", \"0.013157894736842105\"], [\"ReportTurnPanel\", \"2\", \"0.02631578947368421\"], [\"InformationDialog\", \"1\", \"0.013157894736842105\"], [\"FindSettlementDialog\", \"4\", \"0.05263157894736842\"], [\"ColonyPanel\", \"5\", \"0.06578947368421052\"], [\"ReportColonyPanel\", \"1\", \"0.013157894736842105\"], [\"ChipResource\", \"2\", \"0.02631578947368421\"], [\"ResourceManager\", \"3\", \"0.039473684210526314\"], [\"ImageResource\", \"1\", \"0.013157894736842105\"], [\"DisplayTileTextAction\", \"2\", \"0.02631578947368421\"], [\"MoveAction\", \"3\", \"0.039473684210526314\"], [\"MapboardAction\", \"2\", \"0.02631578947368421\"], [\"FreeColAction\", \"2\", \"0.02631578947368421\"], [\"SelectableAction\", \"2\", \"0.02631578947368421\"], [\"ColopediaAction\", \"3\", \"0.039473684210526314\"], [\"WorkProductionPanel\", \"2\", \"0.02631578947368421\"], [\"ColonyPlan\", \"1\", \"0.013157894736842105\"], [\"AIColony\", \"1\", \"0.013157894736842105\"], [\"ServerPlayer\", \"1\", \"0.013157894736842105\"], [\"DifficultyDialog\", \"1\", \"0.013157894736842105\"], [\"ClientOptionsDialog\", \"2\", \"0.02631578947368421\"], [\"FreeColListUI\", \"1\", \"0.013157894736842105\"], [\"FreeColTextFieldUI\", \"1\", \"0.013157894736842105\"], [\"FreeColTextAreaUI\", \"1\", \"0.013157894736842105\"], [\"MainPanel\", \"1\", \"0.013157894736842105\"], [\"FreeColPopupMenuUI\", \"1\", \"0.013157894736842105\"], [\"FreeColMenuBarUI\", \"1\", \"0.013157894736842105\"], [\"FreeColPanelUI\", \"1\", \"0.013157894736842105\"], [\"VictoryPanel\", \"1\", \"0.013157894736842105\"], [\"ConnectController\", \"4\", \"0.05263157894736842\"], [\"ScaleMapAction\", \"1\", \"0.013157894736842105\"], [\"ScrollThread\", \"2\", \"0.02631578947368421\"], [\"NewEmptyMapAction\", \"3\", \"0.039473684210526314\"], [\"TilePopupAction\", \"2\", \"0.02631578947368421\"], [\"ReportPanel\", \"4\", \"0.05263157894736842\"], [\"UnitAttackAnimationCanvasSwingTask\", \"2\", \"0.02631578947368421\"], [\"ServerPlayerTest\", \"1\", \"0.013157894736842105\"], [\"ServerIndianSettlementTest\", \"1\", \"0.013157894736842105\"], [\"StartGamePanel\", \"1\", \"0.013157894736842105\"], [\"ShowGameOptionsAction\", \"1\", \"0.013157894736842105\"], [\"EndTurnDialog\", \"2\", \"0.02631578947368421\"], [\"ChangeAction\", \"2\", \"0.02631578947368421\"], [\"UnitAttackAnimation\", \"1\", \"0.013157894736842105\"], [\"LoadAction\", \"1\", \"0.013157894736842105\"], [\"AssignTradeRouteAction\", \"1\", \"0.013157894736842105\"], [\"UnloadAction\", \"1\", \"0.013157894736842105\"], [\"PreCombatDialog\", \"1\", \"0.013157894736842105\"], [\"ShowInformationMessageSwingTask\", \"1\", \"0.013157894736842105\"], [\"DestinationPanel\", \"1\", \"0.013157894736842105\"], [\"ShowConfirmDialogSwingTask\", \"1\", \"0.013157894736842105\"], [\"EditSettlementDialog\", \"1\", \"0.013157894736842105\"], [\"NewLandNameSwingTask\", \"1\", \"0.013157894736842105\"], [\"ShowMainAction\", \"1\", \"0.013157894736842105\"], [\"OptionsDialog\", \"1\", \"0.013157894736842105\"], [\"NewPanel\", \"1\", \"0.013157894736842105\"], [\"CompactLabourReport\", \"1\", \"0.013157894736842105\"], [\"SpyColonySwingTask\", \"1\", \"0.013157894736842105\"], [\"RefreshCanvasSwingTask\", \"1\", \"0.013157894736842105\"], [\"DragListener\", \"1\", \"0.013157894736842105\"], [\"BuildQueueMouseAdapter\", \"1\", \"0.013157894736842105\"], [\"MonarchPanel\", \"1\", \"0.013157894736842105\"], [\"ConstructionPanel\", \"1\", \"0.013157894736842105\"], [\"BuildingsPanel\", \"1\", \"0.013157894736842105\"]]"
        },
        {
            "content": "The `get_co_change_relationship` function has provided a list of entities that are frequently co-changed with **GUI.java** along with their support count and confidence score. The confidence score indicates the probability that a particular entity was modified alongside GUI.java in previous commits.\n\n### Interpretation:\n- **Support Count**: Number of times an entity was modified together with GUI.java.\n- **Confidence Score**: Calculated as (support count) / (total number of GUI.java modifications). A higher value means stronger correlation.\n\n### Next Steps:\nTo determine which entities should be synchronized or investigated further, we can focus on those with high confidence scores and support counts. These represent strong correlations to changes in `GUI.java`.\n\n#### Top 5 Entities with Highest Confidence Scores:\n1. **InGameController** - Support: 12, Confidence: **0.1578**\n2. **UnitMoveAnimation** - Support: 11, Confidence: **0.1447**\n3. **ActionManager** - Support: 9, Confidence: **0.1184**\n4. **Canvas** - Support: 9, Confidence: **0.1184**\n5. **MapEditorController** - Support: 9, Confidence: **0.1184**\n\nThese five seem most likely to be impacted by or related to changes in `GUI.java`. To understand why these relationships exist, I'll examine one of these files to see how it relates semantically or structurally to `GUI.java`.\n\nLet\u2019s start by analyzing the code of **InGameController.java**, as it has the highest confidence score.\n\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_3509e01f30a046bbb9f815",
                    "function": {
                        "arguments": "{\"entity\": \"InGameController.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package net.sf.freecol.server.control;\\nimport java.io.IOException;\\nimport java.util.ArrayList;\\nimport java.util.EnumMap;\\nimport java.util.HashMap;\\nimport java.util.Iterator;\\nimport java.util.List;\\nimport java.util.Timer;\\nimport java.util.TimerTask;\\nimport java.util.logging.Level;\\nimport java.util.logging.Logger;\\nimport net.sf.freecol.FreeCol;\\nimport net.sf.freecol.common.Specification;\\nimport net.sf.freecol.common.model.AbstractUnit;\\nimport net.sf.freecol.common.model.Colony;\\nimport net.sf.freecol.common.model.CombatModel;\\nimport net.sf.freecol.common.model.EquipmentType;\\nimport net.sf.freecol.common.model.FoundingFather;\\nimport net.sf.freecol.common.model.GameOptions;\\nimport net.sf.freecol.common.model.Goods;\\nimport net.sf.freecol.common.model.GoodsType;\\nimport net.sf.freecol.common.model.IndianSettlement;\\nimport net.sf.freecol.common.model.Location;\\nimport net.sf.freecol.common.model.Map;\\nimport net.sf.freecol.common.model.Market;\\nimport net.sf.freecol.common.model.ModelController;\\nimport net.sf.freecol.common.model.Modifier;\\nimport net.sf.freecol.common.model.Monarch;\\nimport net.sf.freecol.common.model.Nation;\\nimport net.sf.freecol.common.model.Player;\\nimport net.sf.freecol.common.model.Settlement;\\nimport net.sf.freecol.common.model.Tension;\\nimport net.sf.freecol.common.model.Tile;\\nimport net.sf.freecol.common.model.Unit;\\nimport net.sf.freecol.common.model.UnitType;\\nimport net.sf.freecol.common.model.FoundingFather.FoundingFatherType;\\nimport net.sf.freecol.common.model.Map.Direction;\\nimport net.sf.freecol.common.model.Map.Position;\\nimport net.sf.freecol.common.model.Monarch.MonarchAction;\\nimport net.sf.freecol.common.model.Player.PlayerType;\\nimport net.sf.freecol.common.model.Player.Stance;\\nimport net.sf.freecol.common.model.Unit.UnitState;\\nimport net.sf.freecol.common.networking.Message;\\nimport net.sf.freecol.server.FreeColServer;\\nimport net.sf.freecol.server.model.ServerPlayer;\\nimport org.w3c.dom.Element;\\npublic final class InGameController extends Controller {\\n    private static Logger logger = Logger.getLogger(InGameController.class.getName());\\n    public int debugOnlyAITurns = 0;\\n    private java.util.Map<String,java.util.Map<String, java.util.Map<String,Object>>> transactionSessions;\\n    public InGameController(FreeColServer freeColServer) {\\n        super(freeColServer);\\n        transactionSessions = new HashMap<String,java.util.Map<String, java.util.Map<String,Object>>>();\\n    }\\n    public void endTurn(ServerPlayer player) {\\n        try {\\n            Thread.sleep(100);\\n        } catch (InterruptedException e) {}\\n        FreeColServer freeColServer = getFreeColServer();\\n        ServerPlayer oldPlayer = (ServerPlayer) getGame().getCurrentPlayer();\\n        if (oldPlayer != player) {\\n            logger.warning(\\\"It is not \\\" + player.getName() + \\\"'s turn!\\\");\\n            throw new IllegalArgumentException(\\\"It is not \\\" + player.getName() + \\\"'s turn!\\\");\\n        }\\n        player.clearModelMessages();\\n        freeColServer.getModelController().clearTaskRegister();\\n        Player winner = checkForWinner();\\n        if (winner != null && (!freeColServer.isSingleplayer() || !winner.isAI())) {\\n            Element gameEndedElement = Message.createNewRootElement(\\\"gameEnded\\\");\\n            gameEndedElement.setAttribute(\\\"winner\\\", winner.getId());\\n            freeColServer.getServer().sendToAll(gameEndedElement, null);\\n                        if (FreeCol.getFreeColClient() == null) {\\n                new Timer(true).schedule(new TimerTask() {\\n                    @Override\\n                    public void run() {\\n                        System.exit(0);\\n                    }\\n                }, 20000);\\n            }\\n            return;\\n        }\\n        ServerPlayer newPlayer = (ServerPlayer) nextPlayer();\\n        if (newPlayer != null \\n            && !newPlayer.isAI()\\n            && (!newPlayer.isConnected() || debugOnlyAITurns > 0)) {\\n            endTurn(newPlayer);\\n            return;\\n        }\\n    }\\n    private Player nextPlayer() {\\n        final FreeColServer freeColServer = getFreeColServer();\\n        if (!isHumanPlayersLeft()) {\\n            getGame().setCurrentPlayer(null);\\n            return null;\\n        }\\n        if (getGame().isNextPlayerInNewTurn()) {\\n            getGame().newTurn();\\n            if (debugOnlyAITurns > 0) {\\n                debugOnlyAITurns--;\\n            }\\n            Element newTurnElement = Message.createNewRootElement(\\\"newTurn\\\");\\n            freeColServer.getServer().sendToAll(newTurnElement, null);\\n        }\\n        ServerPlayer newPlayer = (ServerPlayer) getGame().getNextPlayer();\\n        getGame().setCurrentPlayer(newPlayer);\\n        if (newPlayer == null) {\\n            getGame().setCurrentPlayer(null);\\n            return null;\\n        }\\n        synchronized (newPlayer) {\\n            if (checkForDeath(newPlayer)) {\\n                newPlayer.setDead(true);\\n                Element setDeadElement = Message.createNewRootElement(\\\"setDead\\\");\\n                setDeadElement.setAttribute(\\\"player\\\", newPlayer.getId());\\n                freeColServer.getServer().sendToAll(setDeadElement, null);\\n                return nextPlayer();\\n            }\\n        }\\n        if (newPlayer.isEuropean()) {\\n            try {        \\n                Market market = newPlayer.getMarket();\\n                                List<GoodsType> goodsTypes = FreeCol.getSpecification().getGoodsTypeList();\\n                GoodsType typeToRemove = goodsTypes.get(getPseudoRandom().nextInt(goodsTypes.size()));\\n                if (typeToRemove.isStorable()) {\\n                    int amountToRemove = getPseudoRandom().nextInt(21);\\n                    market.remove(typeToRemove, amountToRemove);\\n                    Element updateElement = Message.createNewRootElement(\\\"marketElement\\\");\\n                    updateElement.setAttribute(\\\"type\\\", typeToRemove.getId());\\n                    updateElement.setAttribute(\\\"amount\\\", String.valueOf(-amountToRemove));\\n                    newPlayer.getConnection().send(updateElement);\\n                }\\n            } catch (IOException e) {\\n                logger.warning(\\\"Could not send message to: \\\" + newPlayer.getName() +\\n                               \\\" with connection \\\" + newPlayer.getConnection());\\n            }\\n            if (newPlayer.getCurrentFather() == null && newPlayer.getSettlements().size() > 0) {\\n                chooseFoundingFather(newPlayer);\\n            }\\n            if (newPlayer.getMonarch() != null) {\\n                monarchAction(newPlayer);\\n            }\\n            bombardEnemyShips(newPlayer);\\n        }\\n        else if (newPlayer.isIndian()) {\\n            for (IndianSettlement indianSettlement: newPlayer.getIndianSettlements()) {\\n                if (indianSettlement.checkForNewMissionaryConvert()) {\\n                                        Unit missionary = indianSettlement.getMissionary();\\n                    ServerPlayer european = (ServerPlayer) missionary.getOwner();\\n                                        Tile settlementTile = indianSettlement.getTile();\\n                    Tile targetTile = null;\\n                    Iterator<Position> ffi = getGame().getMap().getFloodFillIterator(settlementTile.getPosition());\\n                    while (ffi.hasNext()) {\\n                        Tile t = getGame().getMap().getTile(ffi.next());\\n                        if (settlementTile.getDistanceTo(t) > IndianSettlement.MAX_CONVERT_DISTANCE) {\\n                            break;\\n                        }\\n                        if (t.getSettlement() != null && t.getSettlement().getOwner() == european) {\\n                            targetTile = t;\\n                            break;\\n                        }\\n                    }\\n                    if (targetTile != null) {\\n                        List<UnitType> converts = FreeCol.getSpecification().getUnitTypesWithAbility(\\\"model.ability.convert\\\");\\n                        if (converts.size() > 0) {\\n                                                        Unit brave = indianSettlement.getUnitIterator().next();\\n                            String nationId = brave.getOwner().getNationID();\\n                            brave.dispose();\\n                            ModelController modelController = getGame().getModelController();\\n                            int random = modelController.getRandom(indianSettlement.getId() + \\\"getNewConvertType\\\", converts.size());\\n                            UnitType unitType = converts.get(random);\\n                            Unit unit = modelController.createUnit(indianSettlement.getId() + \\\"newTurn100missionary\\\", targetTile,\\n                                    european, unitType);\\n                                                        try {\\n                                Element updateElement = Message.createNewRootElement(\\\"newConvert\\\");\\n                                updateElement.setAttribute(\\\"nation\\\", nationId);\\n                                updateElement.setAttribute(\\\"colonyTile\\\", targetTile.getId());\\n                                updateElement.appendChild(unit.toXMLElement(european,updateElement.getOwnerDocument()));\\n                                european.getConnection().send(updateElement);\\n                                logger.info(\\\"New convert created for \\\" + european.getName() + \\\" with ID=\\\" + unit.getId());\\n                            } catch (IOException e) {\\n                                logger.warning(\\\"Could not send message to: \\\" + european.getName());\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        Element setCurrentPlayerElement = Message.createNewRootElement(\\\"setCurrentPlayer\\\");\\n        setCurrentPlayerElement.setAttribute(\\\"player\\\", newPlayer.getId());\\n        freeColServer.getServer().sendToAll(setCurrentPlayerElement, null);\\n        return newPlayer;\\n    }\\n    private boolean isHumanPlayersLeft() {\\n        for (Player player : getFreeColServer().getGame().getPlayers()) {\\n            if (!player.isDead() && !player.isAI() && ((ServerPlayer) player).isConnected()) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    private void chooseFoundingFather(ServerPlayer player) {\\n        final ServerPlayer nextPlayer = player;\\n        Thread t = new Thread(FreeCol.SERVER_THREAD+\\\"FoundingFather-thread\\\") {\\n                public void run() {\\n                    List<FoundingFather> randomFoundingFathers = getRandomFoundingFathers(nextPlayer);\\n                    boolean atLeastOneChoice = false;\\n                    Element chooseFoundingFatherElement = Message.createNewRootElement(\\\"chooseFoundingFather\\\");\\n                    for (FoundingFather father : randomFoundingFathers) {\\n                        chooseFoundingFatherElement.setAttribute(father.getType().toString(),\\n                                                                 father.getId());\\n                        atLeastOneChoice = true;\\n                    }\\n                    if (!atLeastOneChoice) {\\n                        nextPlayer.setCurrentFather(null);\\n                    } else {\\n                        try {\\n                            Element reply = nextPlayer.getConnection().ask(chooseFoundingFatherElement);\\n                            FoundingFather father = FreeCol.getSpecification().\\n                                getFoundingFather(reply.getAttribute(\\\"foundingFather\\\"));\\n                            if (!randomFoundingFathers.contains(father)) {\\n                                throw new IllegalArgumentException();\\n                            }\\n                            nextPlayer.setCurrentFather(father);\\n                        } catch (IOException e) {\\n                            logger.warning(\\\"Could not send message to: \\\" + nextPlayer.getName());\\n                        }\\n                    }\\n                }\\n            };\\n        t.start();\\n    }\\n    private List<FoundingFather> getRandomFoundingFathers(Player player) {\\n        int age = getGame().getTurn().getAge();\\n        List<FoundingFather> randomFoundingFathers = new ArrayList<FoundingFather>();\\n        EnumMap<FoundingFatherType, Integer> weightSums = new\\n            EnumMap<FoundingFatherType, Integer>(FoundingFatherType.class);\\n        for (FoundingFather father : FreeCol.getSpecification().getFoundingFathers()) {\\n            if (!player.hasFather(father) && father.isAvailableTo(player)) {\\n                Integer weightSum = weightSums.get(father.getType());\\n                if (weightSum == null) {\\n                    weightSum = new Integer(0);\\n                }\\n                weightSums.put(father.getType(), weightSum + father.getWeight(age));\\n            }\\n        }\\n        for (java.util.Map.Entry<FoundingFatherType, Integer> entry : weightSums.entrySet()) {\\n            if (entry.getValue() != 0) {\\n                int r = getPseudoRandom().nextInt(entry.getValue()) + 1;\\n                int weightSum = 0;\\n                for (FoundingFather father : FreeCol.getSpecification().getFoundingFathers()) {\\n                    if (!player.hasFather(father) && father.getType() == entry.getKey()) {\\n                        weightSum += father.getWeight(age);\\n                        if (weightSum >= r) {\\n                            randomFoundingFathers.add(father);\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return randomFoundingFathers;\\n    }\\n    public Player checkForWinner() {\\n        List<Player> players = getGame().getPlayers();\\n        GameOptions go = getGame().getGameOptions();\\n        if (go.getBoolean(GameOptions.VICTORY_DEFEAT_REF)) {\\n            for (Player player : players) {\\n                if (!player.isAI() && player.getPlayerType() == PlayerType.INDEPENDENT) {\\n                    return player;\\n                }\\n            }\\n        }\\n        if (go.getBoolean(GameOptions.VICTORY_DEFEAT_EUROPEANS)) {\\n            Player winner = null;\\n            for (Player player : players) {\\n                if (!player.isDead() && player.isEuropean() && !player.isREF()) {\\n                    if (winner != null) {\\n                                                winner = null;\\n                        break;\\n                    } else {\\n                        winner = player;\\n                    }\\n                }\\n            }\\n            if (winner != null) {\\n                return winner;\\n            }\\n        }\\n        if (go.getBoolean(GameOptions.VICTORY_DEFEAT_HUMANS)) {\\n            Player winner = null;\\n            for (Player player : players) {\\n                if (!player.isDead() && !player.isAI()) {\\n                    if (winner != null) {\\n                                                winner = null;\\n                        break;\\n                    } else {\\n                        winner = player;\\n                    }\\n                }\\n            }\\n            if (winner != null) {\\n                return winner;\\n            }\\n        }\\n        return null;\\n    }\\n    private boolean checkForDeath(Player player) {\\n        if (player.isREF()) {\\n            return false;\\n        }\\n                if (!player.getSettlements().isEmpty()) {\\n            return false;\\n        }\\n                boolean hasCarrier = false;\\n        List<Unit> unitList = player.getUnits();\\n        for(Unit unit : unitList){\\n            boolean isValidUnit = false;\\n            if(unit.isCarrier()){\\n                hasCarrier = true;\\n                logger.info(\\\"Still has carrier\\\");\\n                continue;\\n            }\\n                        if(unit.isColonist()){\\n                isValidUnit = true;\\n            }\\n                        if(unit.isOffensiveUnit()){\\n                isValidUnit = true;\\n            }\\n            if(!isValidUnit){\\n                continue;\\n            }\\n                        Location unitLocation = unit.getLocation();\\n                        if(unitLocation instanceof Tile){\\n                logger.info(\\\"Found colonist in new world\\\");\\n                return false;\\n            }\\n                        if(unit.isOnCarrier()){\\n                Unit carrier = (Unit) unitLocation;\\n                                if(carrier.getLocation() instanceof Tile){\\n                    logger.info(\\\"Found colonist aboard carrier in new world\\\");\\n                    return false;\\n                }   \\n            }\\n        }\\n        if (!player.isEuropean() || player.getEurope() == null) {\\n            return true;\\n        }\\n                if (getGame().getTurn().getYear() >= 1600) {\\n            logger.info(\\\"No presence in new world after 1600\\\");\\n            return true;\\n        }\\n        int goldNeeded = 0;\\n        if(!hasCarrier){\\n            Iterator<UnitType> navalUnits = FreeCol.getSpecification().getUnitTypesWithAbility(\\\"model.ability.navalUnit\\\").iterator();\\n            int lowerPrice = Integer.MAX_VALUE;\\n            while(navalUnits.hasNext()){\\n                UnitType unit = navalUnits.next();\\n                int unitPrice = player.getEurope().getUnitPrice(unit);\\n                                if(unitPrice == UnitType.UNDEFINED){\\n                    continue;\\n                }\\n                if(unitPrice < lowerPrice){\\n                    lowerPrice = unitPrice;\\n                }\\n            }\\n                        if(lowerPrice == Integer.MAX_VALUE){\\n                logger.warning(\\\"Couldnt find naval unit to buy\\\");\\n                return true;\\n            }\\n            goldNeeded += lowerPrice;\\n                        if(goldNeeded > player.getGold()){\\n                logger.info(\\\"Does not have enough money to buy carrier\\\");\\n                return true;\\n            }\\n            logger.info(\\\"Has enough money to buy carrier, has=\\\" + player.getGold() + \\\", needs=\\\" + lowerPrice);\\n        }\\n        Iterator<Unit> unitIterator = player.getEurope().getUnitIterator();\\n        while (unitIterator.hasNext()) {\\n            Unit unit = unitIterator.next();\\n            if (unit.isCarrier()) {\\n                if(unit.getGoodsCount() > 0){\\n                    logger.info(\\\"Has goods to sell\\\");\\n                    return false;\\n                }\\n                continue;\\n            }\\n            if (unit.isColonist()){\\n                logger.info(\\\"Has colonist unit waiting in port\\\");\\n                return false;\\n            }\\n        }\\n        int goldToRecruit =  player.getEurope().getRecruitPrice();\\n        Iterator<UnitType> trainedUnits = FreeCol.getSpecification().getUnitTypesTrainedInEurope().iterator();\\n        int goldToTrain = Integer.MAX_VALUE;\\n        while(trainedUnits.hasNext()){\\n            UnitType unit = trainedUnits.next();\\n            if(!unit.hasAbility(\\\"model.ability.foundColony\\\")){\\n                continue;\\n            }\\n            int unitPrice = player.getEurope().getUnitPrice(unit);\\n                        if(unitPrice == UnitType.UNDEFINED){\\n                continue;\\n            }\\n            if(unitPrice < goldToTrain){\\n                goldToTrain = unitPrice;\\n            }\\n        }\\n        goldNeeded += Math.min(goldToTrain, goldToRecruit);\\n                if(goldNeeded > player.getGold()){\\n            logger.info(\\\"Does not have enough money for recruiting or training\\\");\\n            return true;\\n        }\\n        return false;\\n    }\\n    private void monarchAction(ServerPlayer player) {\\n        final ServerPlayer nextPlayer = player;\\n        Thread t = new Thread(\\\"monarchAction\\\") {\\n                public void run() {\\n                    try {\\n                        Monarch monarch = nextPlayer.getMonarch();\\n                        MonarchAction action = monarch.getAction();\\n                        Element monarchActionElement = Message.createNewRootElement(\\\"monarchAction\\\");\\n                        monarchActionElement.setAttribute(\\\"action\\\", String.valueOf(action));\\n                        switch (action) {\\n                        case RAISE_TAX:\\n                            int oldTax = nextPlayer.getTax();\\n                            int newTax = monarch.getNewTax(MonarchAction.RAISE_TAX);\\n                            if (newTax > 100) {\\n                                logger.warning(\\\"Tax rate exceeds 100 percent.\\\");\\n                                return;\\n                            }\\n                            Goods goods = nextPlayer.getMostValuableGoods();\\n                            if (goods == null) {\\n                                return;\\n                            }\\n                            monarchActionElement.setAttribute(\\\"amount\\\", String.valueOf(newTax));\\n                            monarchActionElement.setAttribute(\\\"goods\\\", goods.getName());\\n                            monarchActionElement.setAttribute(\\\"force\\\", String.valueOf(false));\\n                            try {\\n                                nextPlayer.setTax(newTax);                                 Element reply = nextPlayer.getConnection().ask(monarchActionElement);\\n                                boolean accepted = Boolean.valueOf(reply.getAttribute(\\\"accepted\\\")).booleanValue();\\n                                if (!accepted) {\\n                                    Colony colony = (Colony) goods.getLocation();\\n                                    if (colony.getGoodsCount(goods.getType()) >= goods.getAmount()) {\\n                                        nextPlayer.setTax(oldTax);                                         Element removeGoodsElement = Message.createNewRootElement(\\\"removeGoods\\\");\\n                                        colony.removeGoods(goods);\\n                                        nextPlayer.setArrears(goods);\\n                                        colony.getFeatureContainer().addModifier(Modifier\\n                                            .createTeaPartyModifier(getGame().getTurn()));\\n                                        removeGoodsElement.appendChild(goods.toXMLElement(nextPlayer, removeGoodsElement\\n                                                                                          .getOwnerDocument()));\\n                                        nextPlayer.getConnection().send(removeGoodsElement);\\n                                    } else {\\n                                                                                monarchActionElement.setAttribute(\\\"force\\\", String.valueOf(true));\\n                                        nextPlayer.getConnection().send(monarchActionElement);\\n                                    }\\n                                }\\n                            } catch (IOException e) {\\n                                logger.warning(\\\"Could not send message to: \\\" + nextPlayer.getName());\\n                            }\\n                            break;\\n                        case LOWER_TAX:\\n                            int taxLowered = monarch.getNewTax(MonarchAction.LOWER_TAX);\\n                            if (taxLowered < 0) {\\n                                logger.warning(\\\"Tax rate less than 0 percent.\\\");\\n                                return;\\n                            }\\n                            monarchActionElement.setAttribute(\\\"amount\\\", String.valueOf(taxLowered));\\n                            try {\\n                                nextPlayer.setTax(taxLowered);                                 nextPlayer.getConnection().send(monarchActionElement); \\n                            } catch (IOException e) {\\n                                logger.warning(\\\"Could not send message to: \\\" + nextPlayer.getName());\\n                            }\\n                            break;\\n                        case ADD_TO_REF:\\n                            List<AbstractUnit> unitsToAdd = monarch.addToREF();\\n                            monarch.addToREF(unitsToAdd);\\n                            Element additionElement = monarchActionElement.getOwnerDocument().createElement(\\\"addition\\\");\\n                            for (AbstractUnit unit : unitsToAdd) {\\n                                additionElement.appendChild(unit.toXMLElement(nextPlayer,additionElement.getOwnerDocument()));\\n                            }\\n                            monarchActionElement.appendChild(additionElement);\\n                            try {\\n                                nextPlayer.getConnection().send(monarchActionElement);\\n                            } catch (IOException e) {\\n                                logger.warning(\\\"Could not send message to: \\\" + nextPlayer.getName());\\n                            }\\n                            break;\\n                        case DECLARE_WAR:\\n                            Player enemy = monarch.declareWar();\\n                            if (enemy == null) {\\n                                                                logger.warning(\\\"Declared war on nobody.\\\");\\n                                return;\\n                            }\\n                                                        if(nextPlayer.isAI()){\\n                                nextPlayer.modifyTension(enemy, Tension.TENSION_ADD_DECLARE_WAR_FROM_PEACE);\\n                            }\\n                            nextPlayer.changeRelationWithPlayer(enemy, Stance.WAR);\\n                            monarchActionElement.setAttribute(\\\"enemy\\\", enemy.getId());\\n                            try {\\n                                nextPlayer.getConnection().send(monarchActionElement);\\n                            } catch (IOException e) {\\n                                logger.warning(\\\"Could not send message to: \\\" + nextPlayer.getName());\\n                            }\\n                            break;\\n                        case OFFER_MERCENARIES:\\n                            Element mercenaryElement = monarchActionElement.getOwnerDocument().createElement(\\\"mercenaries\\\");\\n                            List<AbstractUnit> units = monarch.getMercenaries();\\n                            int price = monarch.getPrice(units, true);\\n                            monarchActionElement.setAttribute(\\\"price\\\", String.valueOf(price));\\n                            for (AbstractUnit unit : units) {\\n                                mercenaryElement.appendChild(unit.toXMLElement(monarchActionElement.getOwnerDocument()));\\n                            }\\n                            monarchActionElement.appendChild(mercenaryElement);\\n                            try {\\n                                Element reply = nextPlayer.getConnection().ask(monarchActionElement);\\n                                boolean accepted = Boolean.valueOf(reply.getAttribute(\\\"accepted\\\")).booleanValue();\\n                                if (accepted) {\\n                                    Element updateElement = Message.createNewRootElement(\\\"monarchAction\\\");\\n                                    updateElement.setAttribute(\\\"action\\\", String.valueOf(MonarchAction.ADD_UNITS));\\n                                    nextPlayer.modifyGold(-price);\\n                                    createUnits(units, updateElement, nextPlayer);\\n                                    nextPlayer.getConnection().send(updateElement);\\n                                }\\n                            } catch (IOException e) {\\n                                logger.warning(\\\"Could not send message to: \\\" + nextPlayer.getName());\\n                            }\\n                            break;\\n                        case NO_ACTION:\\n                                                        break;\\n                        }\\n                    } catch (Exception e) {\\n                        logger.log(Level.WARNING, \\\"Monarch action failed!\\\", e);\\n                    }\\n                }\\n            };\\n        t.start();\\n    }\\n    public ServerPlayer createREFPlayer(ServerPlayer player){\\n        Nation refNation = Specification.getSpecification().getNation(player.getNation().getRefId());\\n        ServerPlayer refPlayer = getFreeColServer().addAIPlayer(refNation);\\n        refPlayer.setEntryLocation(player.getEntryLocation());\\n                player.setStance(refPlayer, Stance.PEACE);\\n        refPlayer.setTension(player, new Tension(Tension.Level.CONTENT.getLimit()));\\n        player.setTension(refPlayer, new Tension(Tension.Level.CONTENT.getLimit()));\\n        return refPlayer;\\n    }\\n    private void createUnits(List<AbstractUnit> units, Element element, ServerPlayer nextPlayer) {\\n        String musketsTypeStr = null;\\n        String horsesTypeStr = null;\\n        if(nextPlayer.isIndian()){\\n                musketsTypeStr = \\\"model.equipment.indian.muskets\\\";\\n            horsesTypeStr = \\\"model.equipment.indian.horses\\\";\\n        } else {\\n                musketsTypeStr = \\\"model.equipment.muskets\\\";\\n            horsesTypeStr = \\\"model.equipment.horses\\\";\\n        }\\n        final EquipmentType muskets = FreeCol.getSpecification().getEquipmentType(musketsTypeStr);\\n        final EquipmentType horses = FreeCol.getSpecification().getEquipmentType(horsesTypeStr);\\n        EquipmentType[] soldier = new EquipmentType[] { muskets };\\n        EquipmentType[] dragoon = new EquipmentType[] { horses, muskets };\\n        for (AbstractUnit unit : units) {\\n            EquipmentType[] equipment = EquipmentType.NO_EQUIPMENT;\\n            for (int count = 0; count < unit.getNumber(); count++) {\\n                switch(unit.getRole()) {\\n                case SOLDIER:\\n                    equipment = soldier;\\n                    break;\\n                case DRAGOON:\\n                    equipment = dragoon;\\n                    break;\\n                default:\\n                }\\n                Unit newUnit = new Unit(getGame(), nextPlayer.getEurope(), nextPlayer,\\n                                        unit.getUnitType(), UnitState.ACTIVE, equipment);\\n                                if (element != null) {\\n                    element.appendChild(newUnit.toXMLElement(nextPlayer, element.getOwnerDocument()));\\n                }\\n            }\\n        }\\n    }\\n    public List<Unit> createREFUnits(ServerPlayer player, ServerPlayer refPlayer){\\n        EquipmentType muskets = Specification.getSpecification().getEquipmentType(\\\"model.equipment.muskets\\\");\\n        EquipmentType horses = Specification.getSpecification().getEquipmentType(\\\"model.equipment.horses\\\");\\n        List<Unit> unitsList = new ArrayList<Unit>();\\n        List<Unit> navalUnits = new ArrayList<Unit>();\\n        List<Unit> landUnits = new ArrayList<Unit>();\\n                for (AbstractUnit unit : player.getMonarch().getNavalUnits()) {\\n            for (int index = 0; index < unit.getNumber(); index++) {\\n                Unit newUnit = new Unit(getGame(), refPlayer.getEurope(), refPlayer,\\n                                        unit.getUnitType(), UnitState.TO_AMERICA);\\n                navalUnits.add(newUnit);\\n            }\\n        }\\n        unitsList.addAll(navalUnits);\\n                for (AbstractUnit unit : player.getMonarch().getLandUnits()) {\\n            EquipmentType[] equipment = EquipmentType.NO_EQUIPMENT;\\n            switch(unit.getRole()) {\\n            case SOLDIER:\\n                equipment = new EquipmentType[] { muskets };\\n                break;\\n            case DRAGOON:\\n                equipment = new EquipmentType[] { horses, muskets };\\n                break;\\n            default:\\n            }\\n            for (int index = 0; index < unit.getNumber(); index++) {\\n                landUnits.add(new Unit(getGame(), refPlayer.getEurope(), refPlayer,\\n                                        unit.getUnitType(), UnitState.ACTIVE, equipment));\\n            }\\n        }\\n        unitsList.addAll(landUnits);\\n                Iterator<Unit> carriers = navalUnits.iterator();\\n        for(Unit unit : landUnits){\\n                        boolean noSpaceForUnit=true;\\n            for(Unit carrier : navalUnits){\\n                if (unit.getSpaceTaken() <= carrier.getSpaceLeft()) {\\n                    noSpaceForUnit=false;\\n                    break;\\n                }\\n            }\\n                        if(noSpaceForUnit){\\n                continue;\\n            }\\n                        Unit carrier = null;\\n            while (carrier == null){\\n                                if (!carriers.hasNext()) {\\n                    carriers = navalUnits.iterator();\\n                }\\n                carrier = carriers.next();\\n                                if (unit.getSpaceTaken() > carrier.getSpaceLeft()) {\\n                    carrier = null;\\n                }\\n            }\\n                        unit.setLocation(carrier);\\n                                }\\n        return unitsList;\\n    }\\n    public boolean createMission(IndianSettlement settlement,Unit missionary){\\n        settlement.setMissionary(missionary);\\n                return true;\\n    }\\n    private void bombardEnemyShips(ServerPlayer currentPlayer) {\\n        logger.finest(\\\"Entering method bombardEnemyShips.\\\");\\n        Map map = getFreeColServer().getGame().getMap();\\n        CombatModel combatModel = getFreeColServer().getGame().getCombatModel();\\n        for (Settlement settlement : currentPlayer.getSettlements()) {\\n            Colony colony = (Colony) settlement;\\n            if (colony.canBombardEnemyShip()){\\n                logger.fine(\\\"Colony \\\" + colony.getName() + \\\" can bombard enemy ships.\\\");\\n                Position colonyPosition = colony.getTile().getPosition();\\n                for (Direction direction : Direction.values()) {\\n                    Tile tile = map.getTile(Map.getAdjacent(colonyPosition, direction));\\n                                        if(tile == null || tile.isLand()){\\n                        continue;\\n                    }\\n                                                            List<Unit> unitList = new ArrayList<Unit>(tile.getUnitList());\\n                    Iterator<Unit> unitIterator = unitList.iterator();\\n                    while (unitIterator.hasNext()) {\\n                        Unit unit = unitIterator.next();\\n                        Player player = unit.getOwner();\\n                                                if(player == currentPlayer){\\n                                continue;\\n                        }\\n                                                if(currentPlayer.getStance(player) != Stance.WAR &&\\n                                                !unit.hasAbility(\\\"model.ability.piracy\\\")){\\n                                continue;\\n                        }\\n                        logger.info(colony.getName() + \\\" found enemy unit to bombard: \\\" + unit.getName() + \\\"(\\\" + unit.getOwner().getNationAsString() + \\\")\\\");\\n                                                CombatModel.CombatResult result = combatModel.generateAttackResult(colony, unit);\\n                                                Location repairLocation = null;\\n                        if(result.type == CombatModel.CombatResultType.WIN){\\n                                        repairLocation = player.getRepairLocation(unit);\\n                        }\\n                                                getGame().getCombatModel().bombard(colony, unit, result, repairLocation);\\n                                                                        int plunderGold = -1;\\n                        Iterator<Player> enemyPlayerIterator = getFreeColServer().getGame().getPlayerIterator();\\n                        while (enemyPlayerIterator.hasNext()) {\\n                                ServerPlayer enemyPlayer = (ServerPlayer) enemyPlayerIterator.next();\\n                                if (                                                enemyPlayer.getConnection() == null) {\\n                                        continue;\\n                                }\\n                                                                if(!unit.isVisibleTo(enemyPlayer)){\\n                                        continue;\\n                                }\\n                                Element opponentAttackElement = Message.createNewRootElement(\\\"opponentAttack\\\");                                 \\n                                opponentAttackElement.setAttribute(\\\"direction\\\", direction.toString());\\n                                opponentAttackElement.setAttribute(\\\"result\\\", result.type.toString());\\n                                opponentAttackElement.setAttribute(\\\"plunderGold\\\", Integer.toString(plunderGold));\\n                            opponentAttackElement.setAttribute(\\\"colony\\\", colony.getId());\\n                                opponentAttackElement.setAttribute(\\\"defender\\\", unit.getId());\\n                                opponentAttackElement.setAttribute(\\\"damage\\\", String.valueOf(result.damage));\\n                                                                if(enemyPlayer == player && repairLocation != null){\\n                                        opponentAttackElement.setAttribute(\\\"repairIn\\\", repairLocation.getId());\\n                                }\\n                                                                if (!enemyPlayer.canSee(colony.getTile())) {\\n                                        opponentAttackElement.setAttribute(\\\"update\\\", \\\"tile\\\");\\n                                        enemyPlayer.setExplored(colony.getTile());\\n                                        opponentAttackElement.appendChild(colony.getTile().toXMLElement(\\n                                                        enemyPlayer, opponentAttackElement.getOwnerDocument()));\\n                                }\\n                                                                if (enemyPlayer.canSee(unit.getTile())) { \\n                            opponentAttackElement.setAttribute(\\\"update\\\", \\\"unit\\\");\\n                            opponentAttackElement.appendChild(unit.toXMLElement(enemyPlayer, opponentAttackElement.getOwnerDocument()));\\n                                }\\n                                                                try {\\n                                        enemyPlayer.getConnection().send(opponentAttackElement);\\n                                } catch (IOException e) {\\n                                        logger.warning(\\\"Could not send message to: \\\" + enemyPlayer.getName()\\n                                                        + \\\" with connection \\\" + enemyPlayer.getConnection());\\n                                }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    public java.util.Map<String,Object> getTransactionSession(Unit unit, Settlement settlement){\\n        java.util.Map<String, java.util.Map<String,Object>> unitTransactions = null;\\n        if(transactionSessions.containsKey(unit.getId())){\\n            unitTransactions = transactionSessions.get(unit.getId());\\n            if(unitTransactions.containsKey(settlement.getId())){\\n                return unitTransactions.get(settlement.getId());\\n            }\\n        }\\n                java.util.Map<String,Object> session = new HashMap<String,Object>();\\n                session.put(\\\"canGift\\\", true);\\n        session.put(\\\"canSell\\\", true);\\n        session.put(\\\"canBuy\\\", true);\\n        session.put(\\\"actionTaken\\\", false);\\n        session.put(\\\"hasSpaceLeft\\\", unit.getSpaceLeft() != 0);\\n        session.put(\\\"unitMoves\\\", unit.getMovesLeft());\\n        if(settlement.getOwner().getStance(unit.getOwner()) == Stance.WAR){\\n            session.put(\\\"canSell\\\", false);\\n            session.put(\\\"canBuy\\\", false);\\n        }\\n        else{\\n        \\t            if(unit.getSpaceTaken() == 0){\\n                session.put(\\\"canSell\\\", false);\\n            }\\n        }\\n                if(unit.getOwner().isAI()){\\n            return session;\\n        }\\n                if(unitTransactions == null){\\n            unitTransactions = new HashMap<String,java.util.Map<String, Object>>();\\n            transactionSessions.put(unit.getId(), unitTransactions);\\n        }\\n        unitTransactions.put(settlement.getId(), session);\\n        return session;\\n    }\\n    public void closeTransactionSession(Unit unit, Settlement settlement){\\n        java.util.Map<String, java.util.Map<String,Object>> unitTransactions;\\n                if(unit.getOwner().isAI()){\\n          return;  \\n        }\\n        if(!transactionSessions.containsKey(unit.getId())){\\n            throw new IllegalStateException(\\\"Trying to close a non-existing session\\\");\\n        }\\n        unitTransactions = transactionSessions.get(unit.getId());   \\n        if(!unitTransactions.containsKey(settlement.getId())){\\n            throw new IllegalStateException(\\\"Trying to close a non-existing session\\\");\\n        }\\n        unitTransactions.remove(settlement.getId());\\n        if(unitTransactions.isEmpty()){\\n            transactionSessions.remove(unit.getId());\\n        }\\n    }\\n    public boolean isTransactionSessionOpen(Unit unit, Settlement settlement){\\n                if(unit.getOwner().isAI()){\\n            return true;\\n        }\\n        if(!transactionSessions.containsKey(unit.getId())){\\n            return false;\\n        }\\n        if(settlement != null &&\\n           !transactionSessions.get(unit.getId()).containsKey(settlement.getId())){\\n                return false;\\n        }\\n        return true;\\n    }\\n}\""
        },
        {
            "content": "The code for **InGameController.java** reveals that it is a core component of the game logic in FreeCol, specifically responsible for handling actions and transitions during gameplay. It coordinates complex operations such as:\n\n- Ending turns and advancing to the next player.\n- Managing AI behavior and interactions with human players.\n- Handling events like taxation changes, declaring war, recruiting units, and managing founding fathers.\n- Controlling combat mechanics (e.g., bombardment of enemy ships).\n- Managing transactions and sessions related to unit and settlement interactions.\n\n### Relationship to `GUI.java`\nSince `GUI.java` likely serves as the main interface or controller for rendering and interacting with the user interface, any change in game state or control logic managed by `InGameController` would require corresponding updates or synchronization in the GUI layer. For example:\n- When a turn ends or a new player begins their turn, the GUI must update accordingly.\n- Events like declaring war, changing tax rates, or combat results likely trigger visual updates or notifications in the UI.\n- Transaction sessions and unit interactions may need to be reflected in UI components.\n\nGiven this tight coupling between `InGameController` and the UI, it's reasonable that these two files are often co-changed.\n\n---\n\n### Next Steps:\nTo continue our CIA, we can explore one of two directions:\n1. **Explore another top co-change entity**, such as **UnitMoveAnimation.java** or **ActionManager.java**, to understand how they relate to both `GUI.java` and `InGameController.java`.\n2. **Analyze dependencies/coupling** between `GUI.java` and `InGameController.java` using functions like `get_coupling_dependencies` or `get_conceptual_coupling`.\n\nLet\u2019s proceed by checking the conceptual coupling (semantic similarity) between `GUI.java` and `InGameController.java` to see if there's a strong semantic relationship.\n\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_94b092c9b96347a5909e70",
                    "function": {
                        "arguments": "{\"entity1\": \"GUI.java\", \"entity2\": \"InGameController.java\"}",
                        "name": "get_conceptual_coupling"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_conceptual_coupling",
            "content": "\"0.7902087\""
        },
        {
            "content": "The **conceptual coupling** (semantic similarity) between `GUI.java` and `InGameController.java` is approximately **0.79**, which indicates a **strong semantic relationship** between the two files.\n\nThis aligns with our earlier analysis: changes in game control logic within `InGameController.java` likely necessitate updates to the user interface managed by `GUI.java`. This could include:\n- Updating UI elements when a player's turn ends.\n- Reflecting combat results or diplomatic changes in the GUI.\n- Triggering visual animations or notifications based on game events.\n\n### Next Steps:\nTo further understand how these two components interact, we can:\n1. Retrieve the code of **GUI.java** to examine its structure and look for direct references or dependencies on `InGameController`.\n2. Use `get_call_graph` or `get_coupling_dependencies` to identify direct method calls or type dependencies between these two entities.\n\nLet\u2019s start by retrieving the origin code of **GUI.java**.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_968ef098cdf34c84978f9f",
                    "function": {
                        "arguments": "{\"entity\": \"GUI.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package net.sf.freecol.client.gui;\\nimport java.awt.AlphaComposite;\\nimport java.awt.Color;\\nimport java.awt.Composite;\\nimport java.awt.Dimension;\\nimport java.awt.Font;\\nimport java.awt.FontMetrics;\\nimport java.awt.Graphics;\\nimport java.awt.Graphics2D;\\nimport java.awt.Image;\\nimport java.awt.Point;\\nimport java.awt.Polygon;\\nimport java.awt.Rectangle;\\nimport java.awt.event.ActionEvent;\\nimport java.awt.event.ActionListener;\\nimport java.awt.font.TextLayout;\\nimport java.awt.geom.GeneralPath;\\nimport java.awt.geom.Rectangle2D;\\nimport java.awt.image.BufferedImage;\\nimport java.util.ArrayList;\\nimport java.util.Date;\\nimport java.util.Iterator;\\nimport java.util.List;\\nimport java.util.Random;\\nimport java.util.Vector;\\nimport java.util.logging.Logger;\\nimport javax.swing.ImageIcon;\\nimport javax.swing.JComponent;\\nimport javax.swing.JLabel;\\nimport javax.swing.JLayeredPane;\\nimport javax.swing.UIManager;\\nimport net.sf.freecol.FreeCol;\\nimport net.sf.freecol.client.ClientOptions;\\nimport net.sf.freecol.client.FreeColClient;\\nimport net.sf.freecol.client.gui.i18n.Messages;\\nimport net.sf.freecol.client.gui.panel.MapControls;\\nimport net.sf.freecol.common.model.Colony;\\nimport net.sf.freecol.common.model.Europe;\\nimport net.sf.freecol.common.model.Game;\\nimport net.sf.freecol.common.model.IndianSettlement;\\nimport net.sf.freecol.common.model.Map;\\nimport net.sf.freecol.common.model.PathNode;\\nimport net.sf.freecol.common.model.Player;\\nimport net.sf.freecol.common.model.Settlement;\\nimport net.sf.freecol.common.model.Tension;\\nimport net.sf.freecol.common.model.Tile;\\nimport net.sf.freecol.common.model.TileImprovement;\\nimport net.sf.freecol.common.model.TileItemContainer;\\nimport net.sf.freecol.common.model.TileType;\\nimport net.sf.freecol.common.model.Unit;\\nimport net.sf.freecol.common.model.Map.Direction;\\nimport net.sf.freecol.common.model.Map.Position;\\nimport net.sf.freecol.common.model.Unit.UnitState;\\nimport net.sf.freecol.common.resources.ResourceManager;\\npublic final class GUI {\\n    private static final Logger logger = Logger.getLogger(GUI.class.getName());\\n    private final FreeColClient freeColClient;\\n    private Dimension size;\\n    private ImageLibrary lib;\\n    private TerrainCursor cursor;\\n    private ViewMode viewMode;\\n    private boolean inGame;\\n    private final Vector<GUIMessage> messages;\\n    private Map.Position selectedTile;\\n    private Map.Position focus = null;\\n    private Unit activeUnit;\\n    private PathNode currentPath;\\n    private PathNode gotoPath = null;\\n    private boolean gotoStarted = false;\\n        private int tileHeight,\\n    tileWidth,\\n    topSpace,\\n    topRows,\\n        bottomRows,\\n    leftSpace,\\n    rightSpace;\\n        private int bottomRow = -1;\\n        private int topRow;\\n            private int bottomRowY;\\n            private int topRowY;\\n        private int leftColumn;\\n        private int rightColumn;\\n            private int leftColumnX;\\n        public static final int UNIT_OFFSET = 20,\\n    TEXT_OFFSET_X = 2,     TEXT_OFFSET_Y = 13,     STATE_OFFSET_X = 25,\\n    STATE_OFFSET_Y = 10,\\n    ALARM_OFFSET_X = 37,\\n    ALARM_OFFSET_Y = 10,\\n    RUMOUR_OFFSET_X = 40,\\n    RUMOUR_OFFSET_Y = 5,\\n    MISSION_OFFSET_X = 49,\\n    MISSION_OFFSET_Y = 10,\\n    OTHER_UNITS_OFFSET_X = -5,     OTHER_UNITS_OFFSET_Y = 1,\\n    OTHER_UNITS_WIDTH = 3,\\n    MAX_OTHER_UNITS = 10,\\n    MESSAGE_COUNT = 3,\\n    MESSAGE_AGE = 30000; \\n    private boolean displayGrid = false;\\n    private int displayTileText = 0;\\n    private GeneralPath gridPath = null;\\n        public boolean displayCoordinates = false;\\n    public boolean displayColonyValue = false;\\n    public Player displayColonyValuePlayer = null;\\n    public boolean debugShowMission = false;\\n    public boolean debugShowMissionInfo = false;\\n    private volatile boolean blinkingMarqueeEnabled;\\n    private Image cursorImage;\\n    private JLabel coatOfArms;\\n    private JLabel greyLayer;\\n    private JLabel waitingForMsg;\\n    public GUI(FreeColClient freeColClient, Dimension size, ImageLibrary lib) {\\n        this.freeColClient = freeColClient;\\n        this.size = size;\\n        setImageLibrary(lib);\\n        inGame = false;\\n        logger.info(\\\"GUI created.\\\");\\n        messages = new Vector<GUIMessage>(MESSAGE_COUNT);\\n        viewMode = new ViewMode(this);\\n        logger.info(\\\"Starting in Move Units View Mode\\\");\\n        displayGrid = freeColClient.getClientOptions().getBoolean(ClientOptions.DISPLAY_GRID);\\n        displayTileText = freeColClient.getClientOptions().getDisplayTileText();\\n        blinkingMarqueeEnabled = true;\\n        cursor = new net.sf.freecol.client.gui.TerrainCursor();\\n    }\\n    public void setImageLibrary(ImageLibrary lib) {\\n        this.lib = lib;\\n        cursorImage = lib.getMiscImage(ImageLibrary.UNIT_SELECT);\\n        TileType tileType = FreeCol.getSpecification().getTileTypeList().get(0);\\n        tileHeight = lib.getTerrainImageHeight(tileType);\\n        tileWidth = lib.getTerrainImageWidth(tileType);\\n        updateMapDisplayVariables();\\n    }\\n    private void updateMapDisplayVariables() {\\n                topSpace = (size.height - tileHeight) / 2;\\n        if ((topSpace % (tileHeight / 2)) != 0) {\\n            topRows = topSpace / (tileHeight / 2) + 2;\\n        } else {\\n            topRows = topSpace / (tileHeight / 2) + 1;\\n        }\\n        bottomRows = topRows;\\n        leftSpace = (size.width - tileWidth) / 2;\\n        rightSpace = leftSpace;\\n    }\\n    public ViewMode getViewMode(){\\n        return viewMode;\\n    }\\n    public void startCursorBlinking() {\\n        final FreeColClient theFreeColClient = freeColClient; \\n        ActionListener taskPerformer = new ActionListener() {\\n            public void actionPerformed(ActionEvent event) {\\n                if (!blinkingMarqueeEnabled) return;\\n                if (getActiveUnit() != null && getActiveUnit().getTile() != null) {\\n                                        theFreeColClient.getCanvas().refreshTile(getActiveUnit().getTile());            \\n                }               \\n            }\\n        };\\n        cursor.addActionListener(taskPerformer);\\n        cursor.startBlinking();\\n    }\\n    public TerrainCursor getCursor(){\\n        return cursor;\\n    }\\n    public void setSize(Dimension size) {\\n        this.size = size;\\n        updateMapDisplayVariables();\\n    }\\n    public void moveTileCursor(Direction direction){\\n        Tile selectedTile = freeColClient.getGame().getMap().getTile(getSelectedTile());\\n        if(selectedTile != null){   \\n            Tile newTile = freeColClient.getGame().getMap().getNeighbourOrNull(direction, selectedTile);\\n            if(newTile != null)\\n                setSelectedTile(newTile.getPosition());\\n        }\\n        else{\\n            logger.warning(\\\"selectedTile is null\\\");\\n        }\\n    }\\n    public void setSelectedTile(Position selectedTile) {\\n        setSelectedTile(selectedTile, false);\\n    }\\n    public void setSelectedTile(Position selectedTile, boolean clearGoToOrders) {\\n        Game gameData = freeColClient.getGame();\\n        if (selectedTile != null && !gameData.getMap().isValid(selectedTile)) {\\n            return;\\n        }\\n        Position oldPosition = this.selectedTile;\\n        this.selectedTile = selectedTile;\\n        if (viewMode.getView() == ViewMode.MOVE_UNITS_MODE) {\\n            if (activeUnit == null ||\\n                (activeUnit.getTile() != null &&\\n                 !activeUnit.getTile().getPosition().equals(selectedTile))) {\\n                Tile t = gameData.getMap().getTile(selectedTile);\\n                if (t != null && t.getSettlement() != null) {\\n                    Settlement s = t.getSettlement();\\n                    if (s instanceof Colony && s.getOwner().equals(freeColClient.getMyPlayer())) {\\n                                                setFocus(selectedTile);\\n                        freeColClient.getCanvas().showColonyPanel((Colony) s);\\n                        return;\\n                    } else if (s instanceof IndianSettlement) {\\n                                                setFocus(selectedTile);\\n                        freeColClient.getCanvas().showIndianSettlementPanel((IndianSettlement)s);\\n                        return;\\n                    }\\n                }\\n                                Unit unitInFront = getUnitInFront(gameData.getMap().getTile(selectedTile));\\n                if (unitInFront != null) {\\n                    setActiveUnit(unitInFront);\\n                    updateGotoPathForActiveUnit();\\n                } else {\\n                    setFocus(selectedTile);\\n                }\\n            } else if (activeUnit.getTile() != null &&\\n                    activeUnit.getTile().getPosition().equals(selectedTile)) {\\n                                if (clearGoToOrders && activeUnit.getDestination() != null) {\\n                    freeColClient.getInGameController().clearGotoOrders(activeUnit);\\n                    updateGotoPathForActiveUnit();\\n                }\\n            }\\n        }\\n        freeColClient.getActionManager().update();\\n        freeColClient.getCanvas().updateJMenuBar();\\n        int x = 0, y = 0;\\n        MapControls mapControls = freeColClient.getCanvas().getMapControls();\\n        if (mapControls != null) {\\n            x = getWidth() - mapControls.getInfoPanelWidth();\\n            y = getHeight() - mapControls.getInfoPanelHeight();\\n        }\\n        freeColClient.getCanvas().repaint(x, y, getWidth(), getHeight());\\n                if ((!onScreen(selectedTile) &&\\n             freeColClient.getClientOptions().getBoolean(ClientOptions.JUMP_TO_ACTIVE_UNIT)) ||\\n            freeColClient.getClientOptions().getBoolean(ClientOptions.ALWAYS_CENTER)) {\\n                setFocus(selectedTile);\\n        } else {\\n            if (oldPosition != null) {\\n                freeColClient.getCanvas().refreshTile(oldPosition);\\n            }\\n            if (selectedTile != null) {\\n                freeColClient.getCanvas().refreshTile(selectedTile);\\n            }\\n        }\\n    }\\n    public void showColonyPanel(Position selectedTile) {\\n        Game gameData = freeColClient.getGame();\\n        if (selectedTile != null && !gameData.getMap().isValid(selectedTile)) {\\n            return;\\n        }\\n        if (viewMode.getView() == ViewMode.MOVE_UNITS_MODE) {\\n            Tile t = gameData.getMap().getTile(selectedTile);\\n            if (t != null && t.getSettlement() != null && t.getSettlement() instanceof Colony\\n                && t.getSettlement().getOwner().equals(freeColClient.getMyPlayer())) {\\n                setFocus(selectedTile);\\n                stopBlinking();\\n                freeColClient.getCanvas().showColonyPanel((Colony) t.getSettlement());\\n                return;\\n            }\\n        }\\n    }\\n    public void restartBlinking() {\\n        blinkingMarqueeEnabled = true;\\n    }\\n    public void stopBlinking() {\\n        blinkingMarqueeEnabled = false;\\n    }\\n    public Unit getUnitInFront(Tile unitTile) {\\n        if (unitTile == null || unitTile.getUnitCount() <= 0) {\\n            return null;\\n        }\\n        if (activeUnit != null && activeUnit.getTile() == unitTile) {\\n            return activeUnit;\\n        } else {\\n            if (unitTile.getSettlement() == null) {\\n                Unit bestDefendingUnit = null;\\n                if (activeUnit != null) {\\n                    bestDefendingUnit = unitTile.getDefendingUnit(activeUnit);\\n                    if (bestDefendingUnit != null) {\\n                        return bestDefendingUnit;\\n                    }\\n                }\\n                Unit movableUnit = unitTile.getMovableUnit();\\n                if (movableUnit != null && movableUnit.getLocation() == movableUnit.getTile()) {\\n                    return movableUnit;\\n                } else {\\n                    Unit bestPick = null;\\n                    Iterator<Unit> unitIterator = unitTile.getUnitIterator();\\n                    while (unitIterator.hasNext()) {\\n                        Unit u = unitIterator.next();\\n                        if (bestPick == null || bestPick.getMovesLeft() < u.getMovesLeft()) {\\n                            bestPick = u;\\n                        }\\n                    }\\n                    return bestPick;\\n                }\\n            } else {\\n                return null;\\n            }\\n        }\\n    }\\n    public Position getSelectedTile() {\\n        return selectedTile;\\n    }\\n    public Unit getActiveUnit() {\\n        return activeUnit;\\n    }\\n    public void setActiveUnit(Unit activeUnit) {\\n        if (activeUnit != null && activeUnit.getOwner() != freeColClient.getMyPlayer()) {\\n            freeColClient.getCanvas().repaint(0, 0, getWidth(), getHeight());\\n            return;\\n        }\\n        if (activeUnit != null && activeUnit.getTile() == null) {\\n            activeUnit = null;\\n        }\\n        this.activeUnit = activeUnit;\\n        if (activeUnit != null) {\\n            if (freeColClient.getGame().getCurrentPlayer() == freeColClient.getMyPlayer()) {\\n                if (activeUnit.getState() != UnitState.ACTIVE) {\\n                    freeColClient.getInGameController().clearOrders(activeUnit);\\n                }\\n            } else {\\n                freeColClient.getInGameController().clearGotoOrders(activeUnit);\\n            }\\n        }\\n        updateGotoPathForActiveUnit();\\n                if(viewMode.getView() == ViewMode.VIEW_TERRAIN_MODE && activeUnit != null)\\n            viewMode.changeViewMode(ViewMode.MOVE_UNITS_MODE);\\n                if (activeUnit != null) {\\n            setSelectedTile(activeUnit.getTile().getPosition());\\n        } else {\\n            freeColClient.getActionManager().update();\\n            freeColClient.getCanvas().updateJMenuBar();\\n            int x = 0, y = 0;\\n            MapControls mapControls = freeColClient.getCanvas().getMapControls();\\n            if (mapControls != null) {\\n                x = getWidth() - mapControls.getInfoPanelWidth();\\n                y = getHeight() - mapControls.getInfoPanelHeight();\\n            }\\n            freeColClient.getCanvas().repaint(x, y, getWidth(), getHeight());\\n        }\\n    }\\n    public Position getFocus() {\\n        return focus;\\n    }\\n    public void setFocus(Position focus) {\\n        this.focus = focus;\\n        forceReposition();\\n        freeColClient.getCanvas().repaint(0, 0, getWidth(), getHeight());\\n    }\\n    public void setFocusImmediately(Position focus) {\\n        this.focus = focus;\\n        forceReposition();\\n        freeColClient.getCanvas().paintImmediately(0, 0, getWidth(), getHeight());\\n    }\\n    public void setFocus(int x, int y) {\\n        setFocus(new Map.Position(x,y));\\n    }\\n    public int getMessageCount() {\\n        return messages.size();\\n    }\\n    public GUIMessage getMessage(int index) {\\n        return messages.get(index);\\n    }\\n    public synchronized void addMessage(GUIMessage message) {\\n        if (getMessageCount() == MESSAGE_COUNT) {\\n            messages.remove(0);\\n        }\\n        messages.add(message);\\n        freeColClient.getCanvas().repaint(0, 0, getWidth(), getHeight());\\n    }\\n    public synchronized boolean removeOldMessages() {\\n        long currentTime = new Date().getTime();\\n        boolean result = false;\\n        int i = 0;\\n        while (i < getMessageCount()) {\\n            long messageCreationTime = getMessage(i).getCreationTime().getTime();\\n            if ((currentTime - messageCreationTime) >= MESSAGE_AGE) {\\n                result = true;\\n                messages.remove(i);\\n            } else {\\n                i++;\\n            }\\n        }\\n        return result;\\n    }\\n    public int getWidth() {\\n        return size.width;\\n    }\\n    public int getHeight() {\\n        return size.height;\\n    }\\n    public void display(Graphics2D g) {\\n        if ((freeColClient.getGame() != null)\\n                && (freeColClient.getGame().getMap() != null)\\n                && (focus != null)\\n                && inGame) {\\n            removeOldMessages();\\n            displayMap(g);\\n        } else {\\n            if (freeColClient.isMapEditor()) {\\n                g.setColor(Color.black);\\n                g.fillRect(0, 0, size.width, size.height);                \\n            } else {\\n                Image bgImage = ResourceManager.getImage(\\\"CanvasBackgroundImage\\\", size);\\n                if (bgImage != null) {\\n                    g.drawImage(bgImage, 0, 0, freeColClient.getCanvas());\\n                                        String versionStr = \\\"v. \\\" + FreeCol.getVersion();\\n                    Font oldFont = g.getFont();\\n                    Color oldColor = g.getColor();\\n                    Font newFont = oldFont.deriveFont(Font.BOLD);\\n                    TextLayout layout = new TextLayout(versionStr, newFont, g.getFontRenderContext());\\n                    Rectangle2D bounds = layout.getBounds();\\n                    float x = getWidth() - (float) bounds.getWidth() - 5;\\n                    float y = getHeight() - (float) bounds.getHeight();\\n                    g.setColor(Color.white);\\n                    layout.draw(g, x, y);\\n                                        g.setFont(oldFont);\\n                    g.setColor(oldColor);\\n                } else {\\n                    g.setColor(Color.black);\\n                    g.fillRect(0, 0, size.width, size.height);\\n                }\\n            }\\n        }\\n    }\\n    private int getLeftColumns() {\\n        return getLeftColumns(focus.getY());\\n    }\\n    private int getLeftColumns(int y) {\\n        int leftColumns;\\n        if ((y % 2) == 0) {\\n            leftColumns = leftSpace / tileWidth + 1;\\n            if ((leftSpace % tileWidth) > 32) {\\n                leftColumns++;\\n            }\\n        } else {\\n            leftColumns = leftSpace / tileWidth + 1;\\n            if ((leftSpace % tileWidth) == 0) {\\n                leftColumns--;\\n            }\\n        }\\n        return leftColumns;\\n    }\\n    private int getRightColumns() {\\n        return getRightColumns(focus.getY());\\n    }\\n    private int getRightColumns(int y) {\\n        int rightColumns;\\n        if ((y % 2) == 0) {\\n            rightColumns = rightSpace / tileWidth + 1;\\n            if ((rightSpace % tileWidth) == 0) {\\n                rightColumns--;\\n            }\\n        } else {\\n            rightColumns = rightSpace / tileWidth + 1;\\n            if ((rightSpace % tileWidth) > 32) {\\n                rightColumns++;\\n            }\\n        }\\n        return rightColumns;\\n    }\\n    private void positionMap() {\\n        Game gameData = freeColClient.getGame();\\n        if (focus == null) {\\n            return;\\n        }\\n        int x = focus.getX(),\\n            y = focus.getY();\\n        int leftColumns = getLeftColumns(),\\n            rightColumns = getRightColumns();\\n        if (y < topRows) {\\n                        bottomRow = (size.height / (tileHeight / 2)) - 1;\\n            if ((size.height % (tileHeight / 2)) != 0) {\\n                bottomRow++;\\n            }\\n            topRow = 0;\\n            bottomRowY = bottomRow * (tileHeight / 2);\\n            topRowY = 0;\\n        } else if (y >= (gameData.getMap().getHeight() - bottomRows)) {\\n                        bottomRow = gameData.getMap().getHeight() - 1;\\n            topRow = size.height / (tileHeight / 2);\\n            if ((size.height % (tileHeight / 2)) > 0) {\\n                topRow++;\\n            }\\n            topRow = gameData.getMap().getHeight() - topRow;\\n            bottomRowY = size.height - tileHeight;\\n            topRowY = bottomRowY - (bottomRow - topRow) * (tileHeight / 2);\\n        } else {\\n                        bottomRow = y + bottomRows;\\n            topRow = y - topRows;\\n            bottomRowY = topSpace + (tileHeight / 2) * bottomRows;\\n            topRowY = topSpace - topRows * (tileHeight / 2);\\n        }\\n        if (x < leftColumns) {\\n                        leftColumn = 0;\\n            rightColumn = size.width / tileWidth - 1;\\n            if ((size.width % tileWidth) > 0) {\\n                rightColumn++;\\n            }\\n            leftColumnX = 0;\\n        } else if (x >= (gameData.getMap().getWidth() - rightColumns)) {\\n                        rightColumn = gameData.getMap().getWidth() - 1;\\n            leftColumn = size.width / tileWidth;\\n            if ((size.width % tileWidth) > 0) {\\n                leftColumn++;\\n            }\\n            leftColumnX = size.width - tileWidth - tileWidth / 2 -\\n                leftColumn * tileWidth;\\n            leftColumn = rightColumn - leftColumn;\\n        } else {\\n                        leftColumn = x - leftColumns;\\n            rightColumn = x + rightColumns;\\n            leftColumnX = (size.width - tileWidth) / 2 - leftColumns * tileWidth;\\n        }\\n    }\\n    private void displayGotoPath(Graphics2D g, PathNode gotoPath) {\\n        if (gotoPath != null) {\\n            PathNode temp = gotoPath;\\n            while (temp != null) {\\n                Point p = getTilePosition(temp.getTile());\\n                if (p != null) {\\n                    Tile tile = temp.getTile();\\n                    Image image;\\n                    final Color textColor; \\n                    if (temp.getTurns() == 0) {\\n                        g.setColor(Color.GREEN);                        \\n                        image = getPathImage(activeUnit);\\n                        if (activeUnit != null \\n                                && tile.isExplored()\\n                                && activeUnit.isNaval()\\n                                && tile.isLand() \\n                                && (tile.getColony() == null || tile.getColony().getOwner() != activeUnit.getOwner())) {\\n                            image = getPathImage(activeUnit.getFirstUnit());\\n                        }\\n                        textColor = Color.BLACK;\\n                    } else {\\n                        g.setColor(Color.RED);\\n                        image = getPathNextTurnImage(activeUnit);\\n                        if (activeUnit != null\\n                                && tile.isExplored()\\n                                && activeUnit.isNaval()\\n                                && tile.isLand() \\n                                && (tile.getColony() == null || tile.getColony().getOwner() != activeUnit.getOwner())) {\\n                            image = getPathNextTurnImage(activeUnit.getFirstUnit());\\n                        }\\n                        textColor = Color.WHITE;\\n                    }                \\n                    if (image != null) {\\n                        g.drawImage(image, p.x + (tileWidth - image.getWidth(null))/2, p.y + (tileHeight - image.getHeight(null))/2, null);\\n                    } else {\\n                        g.fillOval(p.x + tileWidth/2, p.y + tileHeight/2, 10, 10);\\n                        g.setColor(Color.BLACK);\\n                        g.drawOval(p.x + tileWidth/2, p.y + tileHeight/2, 10, 10);\\n                    }                \\n                    if (temp.getTurns() > 0) {\\n                        BufferedImage stringImage = createStringImage(g, Integer.toString(temp.getTurns()), textColor, tileWidth, 12);\\n                        g.drawImage(stringImage, p.x + (tileWidth - stringImage.getWidth(null))/2, p.y + (tileHeight - stringImage.getHeight()) / 2, null);\\n                    }\\n                }                    \\n                temp = temp.next;\\n            }\\n        }\\n    }\\n    private int getXOffset(int clipLeftX, int tileY) {\\n        int xx = clipLeftX;\\n        if ((tileY % 2) != 0) {\\n            xx += tileWidth / 2;\\n        }\\n        return xx;\\n    }\\n    private void displayMap(Graphics2D g) {\\n        Rectangle clipBounds = g.getClipBounds();\\n        Map map = freeColClient.getGame().getMap();\\n        if (bottomRow < 0) {\\n            positionMap();\\n        }\\n        int clipTopRow = (clipBounds.y - topRowY) / (tileHeight / 2) - 1;\\n        int clipTopY = topRowY + clipTopRow * (tileHeight / 2);\\n        clipTopRow = topRow + clipTopRow;\\n        int clipLeftCol = (clipBounds.x - leftColumnX) / tileWidth - 1;\\n        int clipLeftX = leftColumnX + clipLeftCol * tileWidth;\\n        clipLeftCol = leftColumn + clipLeftCol;\\n        int clipBottomRow = (clipBounds.y + clipBounds.height - topRowY) / (tileHeight / 2);\\n        clipBottomRow = topRow + clipBottomRow;\\n        int clipRightCol = (clipBounds.x + clipBounds.width - leftColumnX) / tileWidth;\\n        clipRightCol = leftColumn + clipRightCol;\\n        if (displayGrid) {\\n            gridPath = new GeneralPath();\\n            gridPath.moveTo(0, 0);\\n            int nextX = tileWidth / 2;\\n            int nextY = - (tileHeight / 2);\\n            for (int i = 0; i <= ((clipRightCol - clipLeftCol) * 2 + 1); i++) {\\n                gridPath.lineTo(nextX, nextY);\\n                nextX += tileWidth / 2;\\n                if (nextY == - (tileHeight / 2)) {\\n                    nextY = 0;\\n                }\\n                else {\\n                    nextY = - (tileHeight / 2);\\n                }\\n            }\\n        }\\n        g.setColor(Color.black);\\n        g.fillRect(clipBounds.x, clipBounds.y, clipBounds.width, clipBounds.height);\\n        int xx;\\n        int yy = clipTopY;\\n                for (int tileY = clipTopRow; tileY <= clipBottomRow; tileY++) {\\n            xx = getXOffset(clipLeftX, tileY);\\n                        for (int tileX = clipLeftCol; tileX <= clipRightCol; tileX++) {\\n                displayBaseTile(g, map, map.getTile(tileX, tileY), xx, yy, true);\\n                xx += tileWidth;\\n            }\\n            yy += tileHeight / 2;\\n        }\\n        List<Unit> darkUnits = new ArrayList<Unit>();\\n        List<Integer> darkUnitsX = new ArrayList<Integer>();\\n        List<Integer> darkUnitsY = new ArrayList<Integer>();\\n        yy = clipTopY;\\n                for (int tileY = clipTopRow; tileY <= clipBottomRow; tileY++) {\\n            xx = getXOffset(clipLeftX, tileY);\\n            if (displayGrid) {\\n                                g.translate(xx, yy + (tileHeight / 2));\\n                g.setColor(Color.BLACK);\\n                g.draw(gridPath);\\n                g.translate(- xx, - (yy + (tileHeight / 2)));\\n            }\\n                        for (int tileX = clipLeftCol; tileX <= clipRightCol; tileX++) {\\n                Tile tile = map.getTile(tileX, tileY);\\n                                displayTileOverlays(g, map, tile, xx, yy, true, true);\\n                if (viewMode.displayTileCursor(tile,xx,yy)) {\\n                    drawCursor(g, xx, yy);\\n                }\\n                xx += tileWidth;\\n            }\\n            xx = getXOffset(clipLeftX, tileY);\\n                        for (int tileX = clipLeftCol; tileX <= clipRightCol; tileX++) {\\n                Unit unitInFront = getUnitInFront(map.getTile(tileX, tileY));\\n                if (unitInFront != null) {\\n                    displayUnit(g, unitInFront, xx, yy);\\n                    if (unitInFront.isUndead()) {\\n                        darkUnits.add(unitInFront);\\n                        darkUnitsX.add(xx);\\n                        darkUnitsY.add(yy);\\n                    }\\n                }\\n                xx += tileWidth;\\n            }\\n            yy += tileHeight / 2;\\n        }\\n        if (darkUnits.size() > 0) {\\n            g.setColor(Color.BLACK);\\n            final Image im = getImageLibrary().getMiscImage(ImageLibrary.DARKNESS);\\n            for (int index=0; index<darkUnits.size(); index++) {\\n                final Unit u = darkUnits.get(index);\\n                final int x = darkUnitsX.get(index);\\n                final int y = darkUnitsY.get(index);            \\n                g.drawImage(im, x  + tileWidth/2 - im.getWidth(null)/2, y + tileHeight/2 - im.getHeight(null)/2, null);\\n                displayUnit(g, u, x, y);\\n            }\\n        }\\n                yy = clipTopY;\\n                for (int tileY = clipTopRow; tileY <= clipBottomRow; tileY++) {\\n            xx = getXOffset(clipLeftX, tileY);\\n                        for (int tileX = clipLeftCol; tileX <= clipRightCol; tileX++) {\\n                Tile tile = map.getTile(tileX, tileY);\\n                if (tile != null && tile.getSettlement() instanceof Colony) {\\n                    Colony colony = (Colony) tile.getSettlement();\\n                    BufferedImage stringImage =\\n                        createColonyNameImage(g, colony,\\n                                              lib.getTerrainImageWidth(tile.getType()) * 4/3, 16);\\n                    g.drawImage(stringImage, \\n                                xx + (lib.getTerrainImageWidth(tile.getType()) - \\n                                      stringImage.getWidth())/2 + 1,\\n                                yy + (lib.getSettlementImage(colony).getHeight(null) + 1), null);\\n                }\\n                xx += tileWidth;\\n            }\\n            yy += tileHeight / 2;\\n        }\\n        displayGotoPath(g, currentPath);\\n        displayGotoPath(g, gotoPath);\\n        Canvas canvas = freeColClient.getCanvas();\\n                if (coatOfArms != null) {\\n            canvas.remove(coatOfArms, false);\\n            coatOfArms = null;\\n        }\\n        if (waitingForMsg != null) {\\n            canvas.remove(waitingForMsg, false);\\n            waitingForMsg = null;\\n        }\\n        if (!freeColClient.isMapEditor()\\n                && freeColClient.getGame() != null\\n                && freeColClient.getMyPlayer() != freeColClient.getGame().getCurrentPlayer()) {\\n            if (greyLayer == null) {\\n                greyLayer = buildGreyLayer();\\n            } else if (!greyLayer.getSize().equals(size)) {\\n                canvas.remove(greyLayer, false);\\n                greyLayer = buildGreyLayer();\\n            }\\n            if (greyLayer.getParent() == null) {                 canvas.add(greyLayer, JLayeredPane.DEFAULT_LAYER, false);\\n                canvas.moveToFront(greyLayer);\\n            }\\n            final Color currentPlayerColor = freeColClient.getGame().getCurrentPlayer().getColor();\\n            final String nation = freeColClient.getGame().getCurrentPlayer().getNationAsString();\\n            Image im = createStringImage(g, \\n                    Messages.message(\\\"waitingFor\\\", \\\"%nation%\\\", nation),\\n                    currentPlayerColor,\\n                    640,\\n                    18);\\n            final ImageIcon coatOfArmsIcon = lib.getCoatOfArmsImageIcon(freeColClient.getGame().getCurrentPlayer().getNation());\\n            final int cHeight = (coatOfArmsIcon != null) ? coatOfArmsIcon.getIconHeight() : 0;\\n            final int cWidth = (coatOfArmsIcon != null) ? coatOfArmsIcon.getIconWidth() : 0;\\n            waitingForMsg = new JLabel(new ImageIcon(im));\\n            waitingForMsg.setBounds((size.width - im.getWidth(null)) / 2, (size.height - im.getHeight(null) - cHeight) / 2, im.getWidth(null), im.getHeight(null));\\n            canvas.add(waitingForMsg, JLayeredPane.DEFAULT_LAYER, false);\\n            canvas.moveToFront(waitingForMsg);\\n            if (coatOfArmsIcon != null) {\\n                coatOfArms = new JLabel(coatOfArmsIcon);\\n                coatOfArms.setBounds((size.width - cWidth) / 2, (size.height - cHeight) / 2 + im.getHeight(null), cWidth, cHeight);\\n                canvas.add(coatOfArms, JLayeredPane.DEFAULT_LAYER, false);\\n                canvas.moveToFront(coatOfArms);\\n            }\\n        }\\n        else {\\n            if (greyLayer != null && greyLayer.getParent() != null) {\\n                canvas.remove(greyLayer, false);\\n            }\\n        }\\n                synchronized (this) {\\n            BufferedImage si = createStringImage(g, \\\"getSizes\\\", Color.WHITE, size.width, 12);\\n            yy = size.height - 300 - getMessageCount() * si.getHeight();            xx = 40;\\n            for (int i = 0; i < getMessageCount(); i++) {\\n                GUIMessage message = getMessage(i);\\n                g.drawImage(createStringImage(g, message.getMessage(), message.getColor(), size.width, 12), xx, yy, null);\\n                yy += si.getHeight();\\n            }\\n        }\\n    }\\n    private JLabel buildGreyLayer() {\\n        BufferedImage greyLayerImg = new BufferedImage(size.width, size.height, BufferedImage.TYPE_INT_ARGB);\\n        Graphics2D greyG = greyLayerImg.createGraphics();\\n        greyG.setColor(Color.BLACK);\\n        Composite oldComposite = greyG.getComposite();\\n        greyG.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.6f));\\n        greyG.fill(new Rectangle(0, 0, size.width, size.height));\\n        greyG.setComposite(oldComposite);\\n        JLabel toReturn = new JLabel(new ImageIcon(greyLayerImg));\\n        toReturn.setBounds(0, 0, size.width, size.height);\\n        return toReturn;\\n    }\\n    private Image getPathImage(Unit u) {\\n        if (u == null) {\\n            return null;\\n        } else {\\n            return ResourceManager.getImage(\\\"path.\\\" + u.getPathTypeImage() + \\\".image\\\");\\n        }\\n    }\\n    private Image getPathNextTurnImage(Unit u) {\\n        if (u == null) {\\n            return null;\\n        } else {\\n            return ResourceManager.getImage(\\\"path.\\\" + u.getPathTypeImage() + \\\".nextTurn.image\\\");\\n        }\\n    }\\n    public BufferedImage createStringImage(Graphics2D g, String nameString, Color color, int maxWidth, int preferredFontSize) {\\n        return createStringImage(null, g, nameString, color, maxWidth, preferredFontSize);\\n    }\\n    public BufferedImage createStringImage(JComponent c, String nameString, Color color, int maxWidth, int preferredFontSize) {\\n        return createStringImage(c, null, nameString, color, maxWidth, preferredFontSize);\\n    }    \\n    private BufferedImage createStringImage(JComponent c, Graphics g, String nameString, Color color, int maxWidth, int preferredFontSize) {        \\n        if (color == null) {\\n            logger.warning(\\\"createStringImage called with color null\\\");\\n            color = Color.WHITE;\\n        }\\n        Font nameFont = (c != null) ? c.getFont() : g.getFont();\\n        FontMetrics nameFontMetrics = (c != null) ? c.getFontMetrics(nameFont) : g.getFontMetrics(nameFont);\\n        BufferedImage bi = null;\\n        int fontSize = preferredFontSize;\\n        do {\\n            nameFont = nameFont.deriveFont(Font.BOLD, fontSize);            \\n            nameFontMetrics = (c != null) ? c.getFontMetrics(nameFont) : g.getFontMetrics(nameFont);\\n            bi = new BufferedImage(nameFontMetrics.stringWidth(nameString) + 4, nameFontMetrics.getMaxAscent() + nameFontMetrics.getMaxDescent(), BufferedImage.TYPE_INT_ARGB);\\n            fontSize -= 2;\\n        } while (bi.getWidth() > maxWidth);\\n        Graphics2D big = bi.createGraphics();\\n        big.setColor(color);\\n        big.setFont(nameFont);\\n        big.drawString(nameString, 2, nameFontMetrics.getMaxAscent());\\n        int playerColor = color.getRGB();\\n        for (int biX=0; biX<bi.getWidth(); biX++) {\\n            for (int biY=0; biY<bi.getHeight(); biY++) {\\n                int r = bi.getRGB(biX, biY);\\n                if (r == playerColor) {\\n                    continue;\\n                }\\n                for (int cX=-1; cX <=1; cX++) {\\n                    for (int cY=-1; cY <=1; cY++) {\\n                        if (biX+cX >= 0 && biY+cY >= 0 && biX+cX < bi.getWidth() && biY+cY < bi.getHeight() && bi.getRGB(biX + cX, biY + cY) == playerColor) {\\n                            bi.setRGB(biX, biY, getStringBorderColor(color).getRGB());\\n                            continue;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return bi;\\n    }\\n    private BufferedImage createColonyNameImage(Graphics g, Colony colony,\\n                                                int maxWidth, int preferredFontSize) {        \\n        return createStringImage((Graphics2D) g,\\n                colony.getName(),\\n                colony.getOwner().getColor(),\\n                maxWidth,\\n                preferredFontSize);\\n    }\\n    public void drawRoad(Graphics2D g, long seed, int x1, int y1, int x2, int y2) {\\n        final int MAX_CORR = 4;\\n        Color oldColor = g.getColor();\\n        Random roadRandom = new Random(seed);\\n        int i = Math.max(Math.abs(x2-x1), Math.abs(y2-y1));\\n        int baseX = x1;\\n        int baseY = y1;\\n        double addX = (x2-x1)/((double) i);\\n        double addY = (y2-y1)/((double) i);\\n        int corr = 0;\\n        int xCorr = 0;\\n        int yCorr = 0;\\n        int lastDiff = 1;\\n        g.setColor(new Color(128, 64, 0));\\n        g.drawLine(baseX, baseY, baseX, baseY);\\n        for (int j=1; j<=i; j++) {\\n            int oldCorr = corr;\\n                            corr = corr + roadRandom.nextInt(3)-1;\\n                if (oldCorr != corr) {\\n                    lastDiff = oldCorr - corr;\\n                }\\n            if (Math.abs(corr) > MAX_CORR || Math.abs(corr) >= i-j) {\\n                if (corr > 0) {\\n                    corr--;\\n                } else {\\n                    corr++;\\n                }\\n            }\\n            if (corr != oldCorr) {\\n                g.setColor(new Color(128, 128, 0));\\n                g.drawLine(baseX+(int) (j*addX)+xCorr, baseY+(int) (j*addY)+yCorr, baseX+(int) (j*addX)+xCorr, baseY+(int) (j*addY)+yCorr);\\n            } else {\\n                int oldXCorr = 0;\\n                int oldYCorr = 0;\\n                if (x2-x1 == 0) {\\n                    oldXCorr = corr+lastDiff;\\n                    oldYCorr = 0;\\n                } else if (y2-y1 == 0) {\\n                    oldXCorr = 0;\\n                    oldYCorr = corr+lastDiff;\\n                } else {\\n                    if (corr > 0) {\\n                        oldXCorr = corr+lastDiff;\\n                    } else {\\n                        oldYCorr = corr+lastDiff;\\n                    }\\n                }\\n                g.setColor(new Color(128, 128, 0));\\n                g.drawLine(baseX+(int) (j*addX)+oldXCorr, baseY+(int) (j*addY)+oldYCorr, baseX+(int) (j*addX)+oldXCorr, baseY+(int) (j*addY)+oldYCorr);\\n            }\\n            if (x2-x1 == 0) {\\n                xCorr = corr;\\n                yCorr = 0;\\n            } else if (y2-y1 == 0) {\\n                xCorr = 0;\\n                yCorr = corr;\\n            } else {\\n                if (corr > 0) {\\n                    xCorr = corr;\\n                } else {\\n                    yCorr = corr;\\n                }\\n            }\\n            g.setColor(new Color(128, 64, 0));\\n            g.drawLine(baseX+(int) (j*addX)+xCorr, baseY+(int) (j*addY)+yCorr, baseX+(int) (j*addX)+xCorr, baseY+(int) (j*addY)+yCorr);\\n        }\\n        g.setColor(oldColor);\\n    }\\n    public void displayColonyTile(Graphics2D g, Map map, Tile tile, int x, int y, Colony colony) {\\n        displayBaseTile(g, map, tile, x, y, false);        \\n        Unit occupyingUnit = colony.getColonyTile(tile).getOccupyingUnit();\\n        Settlement settlement = tile.getOwningSettlement();\\n        int price = colony.getOwner().getLandPrice(tile);\\n        if ((settlement != null &&\\n             (settlement instanceof Colony && settlement != colony) ||\\n             (settlement instanceof IndianSettlement && price > 0)) ||\\n            occupyingUnit != null) {\\n                        g.drawImage(lib.getMiscImage(ImageLibrary.TILE_TAKEN), x, y, null);\\n        }\\n        displayTileOverlays(g, map, tile, x, y, false, false);\\n        if (price > 0 && tile.getSettlement() == null) {\\n                        Image image = lib.getMiscImage(ImageLibrary.TILE_OWNED_BY_INDIANS);\\n            g.drawImage(image, x+tileWidth/2-image.getWidth(null)/2, y+tileHeight/2-image.getHeight(null)/2, null);\\n        }\\n        if (occupyingUnit != null) {\\n            ImageIcon image = lib.getScaledImageIcon(lib.getUnitImageIcon(occupyingUnit), 0.5f);\\n            g.drawImage(image.getImage(), (x + tileWidth / 4) - image.getIconWidth() / 2,\\n                    (y + tileHeight / 2) - image.getIconHeight() / 2, null);\\n                        displayOccupationIndicator(g, occupyingUnit, x + (int) (STATE_OFFSET_X * lib.getScalingFactor()), y);\\n        }\\n    }\\n    public void displayTerrain(Graphics2D g, Map map, Tile tile, int x, int y) {\\n        displayBaseTile(g, map, tile, x, y, true);\\n        displayAdditionsAndImprovements(g, map, tile, x, y);\\n            }\\n    public void displayTile(Graphics2D g, Map map, Tile tile, int x, int y) {\\n        displayTile(g, map, tile, x, y, true);\\n    }\\n    public void displayTile(Graphics2D g, Map map, Tile tile, int x, int y, boolean drawUnexploredBorders) {\\n        displayBaseTile(g, map, tile, x, y, drawUnexploredBorders);\\n        displayTileOverlays(g, map, tile, x, y, drawUnexploredBorders, true);\\n    }\\n    private void displayBaseTile(Graphics2D g, Map map, Tile tile, int x, int y, boolean drawUnexploredBorders) {\\n        if (tile == null) {\\n            return;\\n        }\\n        g.drawImage(lib.getTerrainImage(tile.getType(), tile.getX(), tile.getY()), x, y, null);\\n        Map.Position pos = new Map.Position(tile.getX(), tile.getY());\\n        for (Direction direction : Direction.values()) {\\n            Map.Position p = Map.getAdjacent(pos, direction);\\n            if (map.isValid(p)) {\\n                Tile borderingTile = map.getTile(p.x, p.y);\\n                if (borderingTile == null) {\\n                                        logger.warning(\\\"Bordering Tile was null.\\\");\\n                    continue;\\n                }\\n                if (!drawUnexploredBorders && !borderingTile.isExplored() &&\\n                    (direction == Direction.SE || direction == Direction.S ||\\n                     direction == Direction.SW)) {\\n                    continue;\\n                }\\n                if (tile.getType() == borderingTile.getType()) {\\n                                        continue;\\n                }\\n                else if (tile.isLand() && !borderingTile.isLand()) {\\n                                        continue;\\n                }\\n                else if (!tile.isLand() && borderingTile.isLand() && borderingTile.isExplored()) {\\n                                        if (borderingTile.getType().getArtCoast() != null) {\\n                        g.drawImage(lib.getCoastImage(borderingTile.getType(), direction,\\n                                                        tile.getX(), tile.getY()),\\n                                                        x, y, null);\\n                    }\\n                                        g.drawImage(lib.getBorderImage(borderingTile.getType(), direction,\\n                                                    tile.getX(), tile.getY()),\\n                                                    x, y, null);\\n                } else if (tile.isExplored() && borderingTile.isExplored()) {\\n                    if (tile.getType().getArtBasic().equals(borderingTile.getType().getArtBasic())) {\\n                                                continue;\\n                    }\\n                    else if (borderingTile.getType().getIndex() < tile.getType().getIndex()) {\\n                                                g.drawImage(lib.getBorderImage(borderingTile.getType(), direction,\\n                                                        tile.getX(), tile.getY()),\\n                                                        x, y, null);\\n                    }\\n                }\\n            }\\n        }\\n    }    \\n    private void displayTileOverlays(Graphics2D g, Map map, Tile tile, int x, int y,\\n                                     boolean drawUnexploredBorders, boolean withNumber) {\\n        if (tile != null) {\\n            if (drawUnexploredBorders) {\\n                displayUnexploredBorders(g, map, tile, x, y);\\n            }\\n            displayAdditionsAndImprovements(g, map, tile, x, y);\\n            displaySettlement(g, map, tile, x, y, withNumber);\\n            displayFogOfWar(g, map, tile, x, y);\\n            displayOptionalValues(g, map, tile, x, y);\\n        }\\n    }\\n    private void displayAdditionsAndImprovements(Graphics2D g, Map map, Tile tile, int x, int y) {  \\n        Map.Position pos = new Map.Position(tile.getX(), tile.getY());\\n        if (!tile.isExplored()) {\\n            g.drawImage(lib.getTerrainImage(null, tile.getX(), tile.getY()), x, y, null);\\n        } else {\\n                        if (tile.getType().getArtOverlay() != null) {\\n                g.drawImage(lib.getOverlayImage(tile.getType(), tile.getX(), tile.getY()), x, y - (int) (32 * lib.getScalingFactor()), null);\\n            }\\n            TileItemContainer tic = tile.getTileItemContainer();\\n            if (tic == null) {\\n                if(tile.isForested()) {\\n                    g.drawImage(lib.getForestImage(tile.getType()), x, y, null);\\n                }\\n            } else {\\n                List<TileImprovement> tiList = tile.getCompletedTileImprovements();\\n                List<TileImprovement> tiList2 = new ArrayList<TileImprovement>();\\n                                                for (TileImprovement ti : tiList) {\\n                    if (ti == tic.getRiver() || ti == tic.getRoad())\\n                        continue;\\n                    if (!ti.getType().isArtOverTrees()) {\\n                        tiList2.add(ti);\\n                    } else if (ti.getType().getArtOverlay() != null) {\\n                                                g.drawImage(ResourceManager.getImage(ti.getType().getArtOverlay()), x, y, null);\\n                    }\\n                }\\n                                if (tic.hasRiver() && tic.getRiver().getMagnitude() < TileImprovement.FJORD_RIVER) {\\n                    g.drawImage(lib.getRiverImage(tic.getRiverStyle()), x, y, null);\\n                }\\n                if (tile.isForested()) {\\n                    g.drawImage(lib.getForestImage(tile.getType()), x, y, null);\\n                }\\n                for (TileImprovement ti : tiList2) {\\n                    if (ti == tic.getRiver() || ti == tic.getRoad())\\n                        continue;\\n                    if (ti.getType().getArtOverlay() != null) {\\n                                                g.drawImage(ResourceManager.getImage(ti.getType().getArtOverlay()), x, y, null);\\n                    }\\n                }\\n                if (tile.hasResource()) {\\n                    Image bonusImage = lib.getBonusImage(tic.getResource().getType());\\n                    if (bonusImage != null) {\\n                        g.drawImage(bonusImage, x + tileWidth/2 - bonusImage.getWidth(null)/2,\\n                                    y + tileHeight/2 - bonusImage.getHeight(null)/2, null);\\n                    }\\n                }\\n                                if (tile.hasRoad()) {\\n                    long seed = Long.parseLong(Integer.toString(tile.getX()) + Integer.toString(tile.getY()));\\n                    boolean connectedRoad = false;\\n                    for (Direction direction : Direction.values()) {\\n                        Map.Position p = Map.getAdjacent(pos, direction);\\n                        if (map.isValid(p)) {\\n                            Tile borderingTile = map.getTile(p);\\n                            if (borderingTile.hasRoad()) {\\n                                connectedRoad =  true;\\n                                int nx = x + tileWidth/2;\\n                                int ny = y + tileHeight/2;\\n                                switch (direction) {\\n                                case N : nx = x + tileWidth/2; ny = y; break;\\n                                case NE: nx = x + (tileWidth*3)/4; ny = y + tileHeight/4; break;\\n                                case E : nx = x + tileWidth; ny = y + tileHeight/2; break;\\n                                case SE: nx = x + (tileWidth*3)/4; ny = y + (tileHeight*3)/4; break;\\n                                case S : nx = x + tileWidth/2; ny = y + tileHeight; break;\\n                                case SW: nx = x + tileWidth/4; ny = y + (tileHeight*3)/4; break;\\n                                case W : nx = x; ny = y + tileHeight/2; break;\\n                                case NW: nx = x + tileWidth/4; ny = y + tileHeight/4; break;\\n                                }\\n                                drawRoad(g, seed, x + tileWidth/2, y + tileHeight/2, nx, ny);\\n                            }\\n                        }\\n                    }\\n                    if (!connectedRoad) {\\n                        drawRoad(g, seed, x + tileWidth/2 - 10, y + tileHeight/2, x + tileWidth/2 + 10, y + tileHeight/2);\\n                        drawRoad(g, seed, x + tileWidth/2, y + tileHeight/2 - 10, x + tileWidth/2, y + tileHeight/2 + 10);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    private void displaySettlement(Graphics2D g, Map map, Tile tile, int x, int y, boolean withNumber) {  \\n        if (tile.isExplored()) {\\n            Settlement settlement = tile.getSettlement();\\n            if (settlement != null) {\\n                if (settlement instanceof Colony) {\\n                    Image colonyImage = lib.getSettlementImage(settlement);\\n                                        g.drawImage(colonyImage,\\n                                x + (lib.getTerrainImageWidth(tile.getType()) -\\n                                     colonyImage.getWidth(null)) / 2,\\n                                y + (lib.getTerrainImageHeight(tile.getType()) -\\n                                     colonyImage.getHeight(null)) / 2, null);\\n                    if (withNumber) {\\n                        String populationString = Integer.toString(((Colony)settlement).getUnitCount());\\n                        Color theColor = null;\\n                        int bonus = ((Colony)settlement).getProductionBonus();\\n                        switch (bonus) {\\n                        case 2:\\n                            theColor = Color.BLUE;\\n                            break;\\n                        case 1:\\n                            theColor = Color.GREEN;\\n                            break;\\n                        case -1:\\n                            theColor = Color.ORANGE;\\n                            break;\\n                        case -2:\\n                            theColor = Color.RED;\\n                            break;\\n                        default:\\n                            theColor = Color.WHITE;\\n                        break;\\n                        }\\n                        BufferedImage stringImage = createStringImage(g, populationString, theColor, lib.getTerrainImageWidth(tile.getType()), 12);\\n                        g.drawImage(stringImage, x + (lib.getTerrainImageWidth(tile.getType()) - stringImage.getWidth())/2 + 1, y + ((lib.getTerrainImageHeight(tile.getType()) - stringImage.getHeight()) / 2) + 1, null);\\n                    }\\n                    g.setColor(Color.BLACK);\\n                } else if (settlement instanceof IndianSettlement) {\\n                    IndianSettlement indianSettlement = (IndianSettlement) settlement;\\n                    Image settlementImage = lib.getSettlementImage(settlement);\\n                                        g.drawImage(settlementImage,\\n                                x + (lib.getTerrainImageWidth(tile.getType()) -\\n                                     settlementImage.getWidth(null)) / 2,\\n                                y + (lib.getTerrainImageHeight(tile.getType()) - \\n                                     settlementImage.getHeight(null)) / 2, null);\\n                                        g.drawImage(lib.getColorChip(indianSettlement.getOwner().getColor()),\\n                                x + (int) (STATE_OFFSET_X * lib.getScalingFactor()),\\n                                y + (int) (STATE_OFFSET_Y * lib.getScalingFactor()), null);\\n                                        Unit missionary = indianSettlement.getMissionary();\\n                    if (missionary != null) {\\n                        boolean expert = missionary.hasAbility(\\\"model.ability.expertMissionary\\\");\\n                        g.drawImage(lib.getMissionChip(missionary.getOwner().getColor(), expert),\\n                                    x + (int) (STATE_OFFSET_X * lib.getScalingFactor()) +\\n                                    (MISSION_OFFSET_X - STATE_OFFSET_X),\\n                                    y + (int) (MISSION_OFFSET_Y * lib.getScalingFactor()), null);\\n                    }\\n                                        if (freeColClient.getMyPlayer() != null) {\\n                        Tension alarm = indianSettlement.getAlarm(freeColClient.getMyPlayer());\\n                        if (alarm != null) {\\n                                                        final boolean visited = indianSettlement.hasBeenVisited(freeColClient.getMyPlayer());\\n                            g.drawImage(lib.getAlarmChip(alarm.getLevel(), visited),\\n                                        x + (int) (STATE_OFFSET_X * lib.getScalingFactor()) +\\n                                        (ALARM_OFFSET_X - STATE_OFFSET_X),\\n                                        y + (int) (ALARM_OFFSET_Y  * lib.getScalingFactor()), null);\\n                        }\\n                    }\\n                    g.setColor(Color.BLACK);\\n                    if (indianSettlement.isCapital()) {\\n                                                g.drawString(\\\"*\\\",\\n                                     x + (STATE_OFFSET_X * lib.getScalingFactor()) + TEXT_OFFSET_X + 1,\\n                                     y + (int) (STATE_OFFSET_Y * lib.getScalingFactor()) + TEXT_OFFSET_Y + 2);\\n                    } else {\\n                        g.drawString(\\\"-\\\", \\n                                     x + (int) (STATE_OFFSET_X * lib.getScalingFactor()) + TEXT_OFFSET_X,\\n                                     y + (int) (STATE_OFFSET_Y * lib.getScalingFactor()) + TEXT_OFFSET_Y);\\n                    }\\n                } else {\\n                    logger.warning(\\\"Requested to draw unknown settlement type.\\\");\\n                }\\n            } else if (tile.hasLostCityRumour()) {\\n                g.drawImage(lib.getMiscImage(ImageLibrary.LOST_CITY_RUMOUR),\\n                            x + (int) (RUMOUR_OFFSET_X * lib.getScalingFactor()),\\n                            y + (int) (RUMOUR_OFFSET_Y * lib.getScalingFactor()), null);\\n            }\\n        }\\n    }\\n    private void displayFogOfWar(Graphics2D g, Map map, Tile tile, int x, int y) {  \\n        if (tile.isExplored()) {\\n            final boolean displayFogOfWar = freeColClient.getClientOptions().getBoolean(ClientOptions.DISPLAY_FOG_OF_WAR);\\n            if (displayFogOfWar\\n                    && freeColClient.getMyPlayer() != null\\n                    && !freeColClient.getMyPlayer().canSee(tile)) {\\n                g.setColor(Color.BLACK);\\n                Composite oldComposite = g.getComposite();\\n                g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.2f));\\n                Polygon pol = new Polygon(new int[] {x + tileWidth/2, x + tileWidth, x + tileWidth/2, x},\\n                                          new int[] {y, y + tileHeight/2, y + tileHeight, y + tileHeight/2},\\n                                          4);\\n                g.fill(pol);\\n                g.setComposite(oldComposite);\\n            }\\n        }\\n    }\\n    private void displayUnexploredBorders(Graphics2D g, Map map, Tile tile, int x, int y) {  \\n        if (tile.isExplored()) {\\n            Map.Position pos = new Map.Position(tile.getX(), tile.getY());\\n            for (Direction direction : Direction.values()) {\\n                Map.Position p = Map.getAdjacent(pos, direction);\\n                if (map.isValid(p)) {\\n                    Tile borderingTile = map.getTile(p);\\n                    if (borderingTile == null || borderingTile.isExplored()){\\n                        continue;\\n                    }\\n                    g.drawImage(lib.getBorderImage(null, direction, tile.getX(), tile.getY()), x, y, null);\\n                }\\n            }\\n        }\\n    }\\n    private void displayOptionalValues(Graphics2D g, Map map, Tile tile, int x, int y) {\\n        switch (displayTileText) {\\n        case ClientOptions.DISPLAY_TILE_TEXT_EMPTY:\\n            break;\\n        case ClientOptions.DISPLAY_TILE_TEXT_NAMES:\\n            if (tile.getName() != null) {\\n                String tileName = tile.getName();\\n                g.setColor(Color.BLACK);\\n                int b = getBreakingPoint(tileName);\\n                if (b == -1) {\\n                    g.drawString(tileName, x + (lib.getTerrainImageWidth(tile.getType()) - g.getFontMetrics().stringWidth(tileName))/2, y + (lib.getTerrainImageHeight(tile.getType())/2));\\n                } else {\\n                    g.drawString(tileName.substring(0, b), x + (lib.getTerrainImageWidth(tile.getType()) - g.getFontMetrics().stringWidth(tileName.substring(0, b)))/2, y + lib.getTerrainImageHeight(tile.getType())/2 - (g.getFontMetrics().getAscent()*2)/3);\\n                    g.drawString(tileName.substring(b+1), x + (lib.getTerrainImageWidth(tile.getType()) - g.getFontMetrics().stringWidth(tileName.substring(b+1)))/2, y + lib.getTerrainImageHeight(tile.getType())/2 + (g.getFontMetrics().getAscent()*2)/3);\\n                }\\n            }\\n            break;\\n        case ClientOptions.DISPLAY_TILE_TEXT_OWNERS:\\n            if (tile.getOwner() != null) {\\n                String tileOwner = tile.getOwner().getNationAsString();\\n                g.setColor(Color.BLACK);\\n                int b = getBreakingPoint(tileOwner);\\n                if (b == -1) {\\n                    g.drawString(tileOwner, x + (lib.getTerrainImageWidth(tile.getType()) - g.getFontMetrics().stringWidth(tileOwner))/2, y + (lib.getTerrainImageHeight(tile.getType())/2));\\n                } else {\\n                    g.drawString(tileOwner.substring(0, b), x + (lib.getTerrainImageWidth(tile.getType()) - g.getFontMetrics().stringWidth(tileOwner.substring(0, b)))/2, y + lib.getTerrainImageHeight(tile.getType())/2 - (g.getFontMetrics().getAscent()*2)/3);\\n                    g.drawString(tileOwner.substring(b+1), x + (lib.getTerrainImageWidth(tile.getType()) - g.getFontMetrics().stringWidth(tileOwner.substring(b+1)))/2, y + lib.getTerrainImageHeight(tile.getType())/2 + (g.getFontMetrics().getAscent()*2)/3);\\n                }\\n            }\\n            break;\\n        case ClientOptions.DISPLAY_TILE_TEXT_REGIONS:\\n            if (tile.getRegion() != null) {\\n                String regionString = tile.getRegion().getDisplayName();\\n                g.setColor(Color.BLACK);\\n                int b = getBreakingPoint(regionString);\\n                if (b == -1) {\\n                    g.drawString(regionString, x + (lib.getTerrainImageWidth(tile.getType()) - g.getFontMetrics().stringWidth(regionString))/2, y + (lib.getTerrainImageHeight(tile.getType())/2));\\n                } else {\\n                    g.drawString(regionString.substring(0, b), x + (lib.getTerrainImageWidth(tile.getType()) - g.getFontMetrics().stringWidth(regionString.substring(0, b)))/2, y + lib.getTerrainImageHeight(tile.getType())/2 - (g.getFontMetrics().getAscent()*2)/3);\\n                    g.drawString(regionString.substring(b+1), x + (lib.getTerrainImageWidth(tile.getType()) - g.getFontMetrics().stringWidth(regionString.substring(b+1)))/2, y + lib.getTerrainImageHeight(tile.getType())/2 + (g.getFontMetrics().getAscent()*2)/3);\\n                }\\n            }\\n            break;\\n        default:\\n            logger.warning(\\\"displayTileText out of range\\\");\\n            break;\\n        }\\n        g.setColor(Color.BLACK);\\n        if (displayCoordinates) {\\n            String posString = tile.getX() + \\\", \\\" + tile.getY();\\n            g.drawString(posString, x + (lib.getTerrainImageWidth(tile.getType()) - g.getFontMetrics().stringWidth(posString))/2, y + (lib.getTerrainImageHeight(tile.getType()) - g.getFontMetrics().getAscent())/2);\\n        }\\n        if (displayColonyValue && tile.isExplored() && tile.isLand()) {\\n            String valueString;\\n            if (displayColonyValuePlayer == null) {\\n                valueString = Integer.toString(tile.getColonyValue());\\n            } else {\\n                valueString = Integer.toString(displayColonyValuePlayer.getColonyValue(tile));\\n            }\\n            g.drawString(valueString, x + (lib.getTerrainImageWidth(tile.getType()) - g.getFontMetrics().stringWidth(valueString))/2, y + (lib.getTerrainImageHeight(tile.getType()) - g.getFontMetrics().getAscent())/2);\\n        }\\n    }\\n    public void stopGoto() {\\n        freeColClient.getCanvas().setCursor(null);\\n        setGotoPath(null);\\n        updateGotoPathForActiveUnit();\\n        gotoStarted = false;\\n    }\\n    public void startGoto() {\\n        gotoStarted = true;\\n        freeColClient.getCanvas().setCursor((java.awt.Cursor) UIManager.get(\\\"cursor.go\\\"));\\n        setGotoPath(null);\\n    }\\n    public boolean isGotoStarted() {\\n        return gotoStarted;\\n    }\\n    public void updateGotoPathForActiveUnit() {\\n        if (activeUnit == null || activeUnit.getDestination() == null) {\\n            currentPath = null;\\n        } else {\\n            if (activeUnit.getDestination() instanceof Europe) {\\n                currentPath = freeColClient.getGame().getMap().findPathToEurope(activeUnit, activeUnit.getTile());\\n            } else if (activeUnit.getDestination().getTile() == activeUnit.getTile()) {\\n                                currentPath = null;\\n            } else {\\n                currentPath = activeUnit.findPath(activeUnit.getDestination().getTile());\\n            }\\n        }\\n    }\\n    public void setGotoPath(PathNode gotoPath) {\\n        this.gotoPath = gotoPath;\\n        freeColClient.getCanvas().refresh();\\n    }\\n    public PathNode getGotoPath() {\\n        return gotoPath;\\n    }\\n    public void setDisplayGrid(boolean displayGrid) {\\n        this.displayGrid = displayGrid;\\n    }\\n    public void setDisplayTileText(int tileTextType) {\\n        this.displayTileText = tileTextType;\\n    }\\n    public int getBreakingPoint(String string) {\\n        int center = string.length() / 2;\\n        int bestIndex = string.indexOf(' ');\\n        int index = 0;\\n        while (index != -1 && index != bestIndex) {\\n            if (Math.abs(center-index) < Math.abs(center-bestIndex)) {\\n                bestIndex = index;\\n            }\\n            index = string.indexOf(' ', bestIndex);\\n        }\\n        if (bestIndex == 0 || bestIndex == string.length()) {\\n            return -1;\\n        } else {\\n            return bestIndex;\\n        }\\n    }\\n    private Image getOccupationIndicatorImage(Unit unit) {\\n        Image chip = lib.getColorChip(unit.getOwner().getColor());\\n        BufferedImage img = new BufferedImage(chip.getWidth(null), chip.getHeight(null), BufferedImage.TYPE_INT_ARGB);\\n        Graphics g = img.getGraphics();\\n        g.drawImage(chip, 0, 0, null);\\n        g.setColor(getForegroundColor(unit.getOwner().getColor()));\\n        String occupationString;\\n        if (unit.getOwner() != freeColClient.getMyPlayer()\\n                && unit.isNaval()) {\\n            occupationString = Integer.toString(unit.getVisibleGoodsCount());\\n        } else {\\n            occupationString = unit.getOccupationIndicator();\\n            if (unit.getState() == UnitState.FORTIFIED)\\n                g.setColor(Color.GRAY);\\n        }\\n        g.drawString(occupationString, TEXT_OFFSET_X, TEXT_OFFSET_Y);\\n        return img;\\n    }\\n    private Color getForegroundColor(Color background) {\\n        if (background.getRed() * 0.3\\n                + background.getGreen() * 0.59\\n                + background.getBlue() * 0.11 < 126) {\\n            return Color.WHITE;\\n        } else {\\n            return Color.BLACK;\\n        }\\n    }\\n    private Color getStringBorderColor(Color color) {\\n        if (color.getRed() * 0.3\\n                + color.getGreen() * 0.59\\n                + color.getBlue() * 0.11 < 10) {\\n            return Color.WHITE;\\n        } else {\\n            return Color.BLACK;\\n        }\\n    }\\n    public void displayOccupationIndicator(Graphics g, Unit unit, int x, int y) {\\n        g.drawImage(getOccupationIndicatorImage(unit), x, y, null);\\n    }\\n    private void displayUnit(Graphics2D g, Unit unit, int x, int y) {\\n        try {\\n                                    if (viewMode.displayUnitCursor(unit,x,y)) {\\n                drawCursor(g,x,y);\\n            }\\n                                    Image image = lib.getUnitImageIcon(unit, unit.getState() == UnitState.SENTRY).getImage();\\n            Point p = getUnitImagePositionInTile(image, x, y);\\n            g.drawImage(image, p.x, p.y, null);\\n                        displayOccupationIndicator(g, unit, x + (int) (STATE_OFFSET_X * lib.getScalingFactor()), y);\\n                        int unitsOnTile = 0;\\n            if (unit.getTile() != null) {\\n                                                                unitsOnTile = unit.getTile().getTotalUnitCount();\\n            }\\n            if (unitsOnTile > 1) {\\n                g.setColor(Color.WHITE);\\n                int unitLinesY = y + OTHER_UNITS_OFFSET_Y;\\n                for (int i = 0; (i < unitsOnTile) && (i < MAX_OTHER_UNITS); i++) {\\n                    g.drawLine(x + (int) ((STATE_OFFSET_X + OTHER_UNITS_OFFSET_X) * lib.getScalingFactor()), unitLinesY, x + (int) ((STATE_OFFSET_X + OTHER_UNITS_OFFSET_X + OTHER_UNITS_WIDTH) * lib.getScalingFactor()), unitLinesY);\\n                    unitLinesY += 2;\\n                }\\n            }\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n                if (debugShowMission && freeColClient.getFreeColServer() != null) {\\n            net.sf.freecol.server.ai.AIUnit au = (net.sf.freecol.server.ai.AIUnit) freeColClient.getFreeColServer().getAIMain().getAIObject(unit);\\n            if (au != null) {\\n                g.setColor(Color.WHITE);\\n                String text = (unit.getOwner().isAI()) ? \\\"\\\" : \\\"(\\\";\\n                String debuggingInfo = \\\"\\\";\\n                if (au.getMission() != null) {\\n                    String missionName = au.getMission().getClass().toString();\\n                    missionName = missionName.substring(missionName.lastIndexOf('.') + 1);\\n                    text += missionName;\\n                    if (debugShowMissionInfo) {\\n                        debuggingInfo = au.getMission().getDebuggingInfo();\\n                    }\\n                } else {\\n                    text += \\\"No mission\\\";\\n                }                \\n                text += (unit.getOwner().isAI()) ? \\\"\\\" : \\\")\\\";\\n                g.drawString(text, x , y);\\n                g.drawString(debuggingInfo, x , y+25);\\n            }\\n        }\\n    }\\n    private Point getUnitImagePositionInTile(Image unitImage, int tileX, int tileY) {\\n        return getUnitImagePositionInTile(unitImage.getWidth(null), unitImage.getHeight(null), tileX, tileY);\\n    }\\n    private Point getUnitImagePositionInTile(int unitImageWidth, int unitImageHeight, int tileX, int tileY) {\\n        int unitX = ((tileX + getTileWidth() / 2) - unitImageWidth / 2);\\n        int unitY = (tileY + getTileHeight() / 2) - unitImageHeight / 2 -\\n                    (int) (UNIT_OFFSET * lib.getScalingFactor());\\n        return new Point(unitX, unitY);\\n    }\\n    public Point getUnitLabelPositionInTile(JLabel unitLabel, Tile tile) {\\n        return getUnitLabelPositionInTile(unitLabel, getTilePosition(tile));\\n    }\\n    public Point getUnitLabelPositionInTile(JLabel unitLabel, Point tileP) {\\n        if (tileP != null) {\\n            int labelX = tileP.x;\\n            int labelY = (tileP.y + getTileHeight() / 2) - unitLabel.getHeight() / 2 -\\n                        (int) (UNIT_OFFSET * lib.getScalingFactor());\\n            return new Point(labelX, labelY);\\n        } else {\\n            return null;\\n        }\\n    }\\n    public JLabel getUnitLabel(Unit unit) {\\n        Image unitImg = lib.getUnitImageIcon(unit).getImage();\\n        Image chipImg = getOccupationIndicatorImage(unit);\\n        final int width = tileWidth/2 + unitImg.getWidth(null)/2;\\n        final int height = unitImg.getHeight(null);\\n        BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\\n        Graphics g = img.getGraphics();\\n        final int unitX = width - unitImg.getWidth(null);\\n        g.drawImage(unitImg, unitX, 0, null);\\n        final int chipX = ((int)(STATE_OFFSET_X * lib.getScalingFactor()));\\n        final int chipY = (int) (((height / 2 + UNIT_OFFSET*lib.getScalingFactor())) - tileHeight / 2);\\n        g.drawImage(chipImg, chipX, chipY, null);\\n        JLabel label = new JLabel(new ImageIcon(img));\\n        label.setBounds(0, 0, width, height);\\n        return label;\\n    }\\n    private void drawCursor(Graphics2D g, int x, int y) {\\n        g.drawImage(cursorImage, x, y, null);\\n    }\\n    public void setInGame(boolean inGame) {\\n        this.inGame = inGame;\\n    }\\n    public boolean isInGame() {\\n        return inGame;\\n    }\\n    public boolean onScreen(int x, int y) {\\n        if (bottomRow < 0) {\\n            positionMap();\\n            return y - 2 > topRow && y + 4 < bottomRow && x - 1 > leftColumn && x + 2 < rightColumn;\\n        } else {\\n            return y - 2 > topRow && y + 4 < bottomRow && x - 1 > leftColumn && x + 2 < rightColumn;\\n        }\\n    }\\n    public boolean onScreen(Position position) {\\n        return onScreen(position.getX(), position.getY());\\n    }\\n    public Map.Position convertToMapCoordinates(int x, int y) {\\n        Game gameData = freeColClient.getGame();\\n        if ((gameData == null) || (gameData.getMap() == null)) {\\n            return null;\\n        }\\n        int leftOffset;\\n        if (focus.getX() < getLeftColumns()) {\\n                        if ((focus.getY() % 2) == 0) {\\n                leftOffset = tileWidth * focus.getX() + tileWidth / 2;\\n            } else {\\n                leftOffset = tileWidth * (focus.getX() + 1);\\n            }\\n        } else if (focus.getX() >= (gameData.getMap().getWidth() - getRightColumns())) {\\n                        if ((focus.getY() % 2) == 0) {\\n                leftOffset = size.width - (gameData.getMap().getWidth() - focus.getX()) * tileWidth;\\n            } else {\\n                leftOffset = size.width - (gameData.getMap().getWidth() - focus.getX() - 1) * tileWidth - tileWidth / 2;\\n            }\\n        } else {\\n            if ((focus.getY() % 2) == 0) {\\n                leftOffset = (size.width / 2);\\n            } else {\\n                leftOffset = (size.width / 2) + tileWidth / 2;\\n            }\\n        }\\n        int topOffset;\\n        if (focus.getY() < topRows) {\\n                        topOffset = (focus.getY() + 1) * (tileHeight / 2);\\n        } else if (focus.getY() >= (gameData.getMap().getHeight() - bottomRows)) {\\n                        topOffset = size.height - (gameData.getMap().getHeight() - focus.getY()) * (tileHeight / 2);\\n        } else {\\n            topOffset = (size.height / 2);\\n        }\\n                                        int diffUp = (topOffset - y) / (tileHeight / 4),\\n            diffLeft = (leftOffset - x) / (tileWidth / 4);\\n                        int orDiffUp = diffUp,\\n            orDiffLeft = diffLeft,\\n            remainderUp = (topOffset - y) % (tileHeight / 4),\\n            remainderLeft = (leftOffset - x) % (tileWidth / 4);\\n        if ((diffUp % 2) == 0) {\\n            diffUp = diffUp / 2;\\n        } else {\\n            if (diffUp < 0) {\\n                diffUp = (diffUp / 2) - 1;\\n            } else {\\n                diffUp = (diffUp / 2) + 1;\\n            }\\n        }\\n        if ((diffLeft % 2) == 0) {\\n            diffLeft = diffLeft / 2;\\n        } else {\\n            if (diffLeft < 0) {\\n                diffLeft = (diffLeft / 2) - 1;\\n            } else {\\n                diffLeft = (diffLeft / 2) + 1;\\n            }\\n        }\\n        boolean done = false;\\n        while (!done) {\\n            if ((diffUp % 2) == 0) {\\n                if ((diffLeft % 2) == 0) {\\n                    diffLeft = diffLeft / 2;\\n                    done = true;\\n                } else {\\n                                        if (((orDiffLeft % 2) == 0) && ((orDiffUp % 2) == 0)) {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2) > remainderLeft) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2) > -remainderLeft) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        } else if ((orDiffLeft > 0) && (orDiffUp == 0)) {\\n                            if (remainderUp > 0) {\\n                                                                if ((remainderUp * 2) > remainderLeft) {\\n                                    diffUp++;\\n                                } else {\\n                                    diffLeft++;\\n                                }\\n                            } else {\\n                                                                if ((-remainderUp * 2) > remainderLeft) {\\n                                    diffUp--;\\n                                } else {\\n                                    diffLeft++;\\n                                }\\n                            }\\n                        } else if (orDiffUp == 0) {\\n                            if (remainderUp > 0) {\\n                                                                if ((remainderUp * 2) > -remainderLeft) {\\n                                    diffUp++;\\n                                } else {\\n                                    diffLeft--;\\n                                }\\n                            } else {\\n                                                                if ((-remainderUp * 2) > -remainderLeft) {\\n                                    diffUp--;\\n                                } else {\\n                                    diffLeft--;\\n                                }\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2) > remainderLeft) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2) > -remainderLeft) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        }\\n                    } else if ((orDiffLeft % 2) == 0) {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        }\\n                    } else if ((orDiffUp % 2) == 0) {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        } else if ((orDiffLeft > 0) && (orDiffUp == 0)) {\\n                            if (remainderUp > 0) {\\n                                                                if ((remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                    diffUp++;\\n                                } else {\\n                                    diffLeft--;\\n                                }\\n                            } else {\\n                                                                if ((-remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                    diffUp--;\\n                                } else {\\n                                    diffLeft--;\\n                                }\\n                            }\\n                        } else if (orDiffUp == 0) {\\n                            if (remainderUp > 0) {\\n                                                                if ((remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                    diffUp++;\\n                                } else {\\n                                    diffLeft++;\\n                                }\\n                            } else {\\n                                                                if ((-remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                    diffUp--;\\n                                } else {\\n                                    diffLeft++;\\n                                }\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        }\\n                    } else {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2) > remainderLeft) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2) > -remainderLeft) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2) > remainderLeft) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2) > -remainderLeft) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        }\\n                    }\\n                }\\n            } else {\\n                if ((diffLeft % 2) == 0) {\\n                                        if (((orDiffLeft % 2) == 0) && ((orDiffUp % 2) == 0)) {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2) > remainderLeft) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2) > remainderLeft) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        } else if ((orDiffUp > 0) && (orDiffLeft == 0)) {\\n                            if (remainderLeft > 0) {\\n                                                                if ((remainderUp * 2) > remainderLeft) {\\n                                    diffUp++;\\n                                } else {\\n                                    diffLeft++;\\n                                }\\n                            } else {\\n                                                                if ((remainderUp * 2) > -remainderLeft) {\\n                                    diffUp++;\\n                                } else {\\n                                    diffLeft--;\\n                                }\\n                            }\\n                        } else if (orDiffLeft == 0) {\\n                            if (remainderLeft > 0) {\\n                                                                if ((-remainderUp * 2) > remainderLeft) {\\n                                    diffUp--;\\n                                } else {\\n                                    diffLeft++;\\n                                }\\n                            } else {\\n                                                                if ((-remainderUp * 2) > -remainderLeft) {\\n                                    diffUp--;\\n                                } else {\\n                                    diffLeft--;\\n                                }\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2) > -remainderLeft) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2) > -remainderLeft) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        }\\n                    } else if ((orDiffLeft % 2) == 0) {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        } else if ((orDiffUp > 0) && (orDiffLeft == 0)) {\\n                            if (remainderLeft > 0) {\\n                                                                if ((remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                    diffLeft++;\\n                                } else {\\n                                    diffUp--;\\n                                }\\n                            } else {\\n                                                                if ((remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                    diffLeft--;\\n                                } else {\\n                                    diffUp--;\\n                                }\\n                            }\\n                        } else if (orDiffLeft == 0) {\\n                            if (remainderLeft > 0) {\\n                                                                if ((-remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                    diffLeft++;\\n                                } else {\\n                                    diffUp++;\\n                                }\\n                            } else {\\n                                                                if ((-remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                    diffLeft--;\\n                                } else {\\n                                    diffUp++;\\n                                }\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        }\\n                    } else if ((orDiffUp % 2) == 0) {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        }\\n                    } else {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2) > remainderLeft) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2) > -remainderLeft) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2) > remainderLeft) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2) > -remainderLeft) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        }\\n                    }\\n                } else {\\n                    if ((focus.getY() % 2) == 0) {\\n                        if (diffLeft < 0) {\\n                            diffLeft = diffLeft / 2;\\n                        } else {\\n                            diffLeft = (diffLeft / 2) + 1;\\n                        }\\n                    } else {\\n                        if (diffLeft < 0) {\\n                            diffLeft = (diffLeft / 2) - 1;\\n                        } else {\\n                            diffLeft = diffLeft / 2;\\n                        }\\n                    }\\n                    done = true;\\n                }\\n            }\\n        }\\n        return new Map.Position(focus.getX() - diffLeft, focus.getY() - diffUp);\\n    }\\n    public boolean isMapNearTop(int y) {\\n        if (y < topRows) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    public boolean isMapNearBottom(int y) {\\n        if (y >= (freeColClient.getGame().getMap().getHeight() - bottomRows)) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    public boolean isMapNearLeft(int x, int y) {\\n        if (x < getLeftColumns(y)) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    public boolean isMapNearRight(int x, int y) {\\n        if (x >= (freeColClient.getGame().getMap().getWidth() - getRightColumns(y))) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    public ImageLibrary getImageLibrary() {\\n        return lib;\\n    }\\n    public Point getTilePosition(Tile t) {\\n        if (t.getY() >= topRow \\n                && t.getY() <= bottomRow \\n                && t.getX() >= leftColumn \\n                && t.getX() <= rightColumn) {\\n            int x = ((t.getX() - leftColumn) * tileWidth) + leftColumnX;\\n            int y = ((t.getY() - topRow) * tileHeight / 2) + topRowY;\\n            if ((t.getY() % 2) != 0) {     \\n                x += tileWidth / 2;\\n            }\\n            return new Point(x, y);\\n        } else {\\n            return null;\\n        }\\n    }\\n    public Rectangle getTileBounds(Tile tile) {\\n        return getTileBounds(tile.getX(), tile.getY());\\n    }\\n    public Rectangle getTileBounds(int x, int y) {\\n        Rectangle result = new Rectangle(0, 0, size.width, size.height);\\n        if (y >= topRow && y <= bottomRow && x >= leftColumn && x <= rightColumn) {\\n            result.y = ((y - topRow) * tileHeight / 2) + topRowY - tileHeight;\\n            result.x = ((x - leftColumn) * tileWidth) + leftColumnX;\\n            if ((y % 2) != 0) {\\n                result.x += tileWidth / 2;\\n            }\\n            result.width = tileWidth;\\n            result.height = tileHeight * 2;\\n        }\\n        return result;\\n    }\\n    public void forceReposition() {\\n        bottomRow = -1;\\n    }\\n    public int getTileHeight() {\\n        return tileHeight;\\n    }\\n    public int getTileWidth() {\\n        return tileWidth;\\n    }\\n}\""
        },
        {
            "content": "### Analysis of `GUI.java`\n\nThe `GUI.java` class serves as the **core graphical user interface controller** for the FreeCol game client. It handles:\n- Rendering the map and game elements (tiles, units, settlements).\n- Managing UI overlays (e.g., unit paths, colony names, fog of war).\n- Handling user interactions like selecting tiles, managing active units, and navigating the map.\n- Displaying messages, tooltips, and visual indicators (e.g., alarms, mission status).\n\nIt heavily interacts with:\n- Game state objects such as `Tile`, `Unit`, `Colony`, and `Player`.\n- Other GUI components like `ImageLibrary`, `ViewMode`, and `Canvas`.\n\n---\n\n### Relationship Between `GUI.java` and `InGameController.java`\n\nFrom our analysis:\n- **High conceptual coupling (0.79)** confirms that these two files are semantically related.\n- The **co-change data** indicates they are frequently modified together.\n- From code inspection:\n  - `GUI.java` calls methods from `InGameController.java` to manage game logic, such as:\n    ```java\n    freeColClient.getInGameController().clearGotoOrders(activeUnit);\n    ```\n    This suggests that the GUI triggers or responds to actions managed by the game controller.\n\n---\n\n### Next Steps in CIA\n\nWe now understand that changes in `InGameController.java` likely necessitate updates in `GUI.java`. To complete the impact analysis, we should consider:\n\n1. **Call Graph Analysis**: Identify which other entities call or are called by `GUI.java`.\n2. **Coupling Dependencies**: Analyze direct dependencies between `GUI.java` and top co-changed entities like `ActionManager.java`, `UnitMoveAnimation.java`, etc.\n3. **Further Semantic Coupling**: Compare `GUI.java` with other co-changed files to determine if they also have strong conceptual links.\n\nLet\u2019s start by retrieving the **call graph** for `GUI.java` to identify its direct dependencies.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_40c3dd2c54f94f989323d1",
                    "function": {
                        "arguments": "{\"entity\": \"GUI.java\"}",
                        "name": "get_call_graph"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_call_graph",
            "content": "[\"Tension\", \"TileImprovement\", \"TileItemContainer\", \"Messages\", \"Map\", \"Unit\", \"FreeCol\", \"FreeColClient\", \"Europe\", \"MapControls\", \"IndianSettlement\", \"PathNode\", \"ClientOptions\", \"Player\", \"Settlement\", \"Game\", \"ResourceManager\", \"Tile\", \"TileType\", \"Colony\"]"
        },
        {
            "content": "The **call graph** for `GUI.java` reveals that it directly interacts with a wide range of entities, most of which are central to the game model and UI rendering. These include:\n\n### Key Entities Used by `GUI.java`\n| Entity | Role in GUI |\n|--------|-------------|\n| `FreeColClient` | Main client interface; provides access to game state and controllers. |\n| `Game`, `Map`, `Tile`, `Unit`, `Player`, `Colony`, `Settlement`, `IndianSettlement` | Game state objects displayed or manipulated via the GUI. |\n| `TileImprovement`, `TileType`, `TileItemContainer` | Represent terrain features and improvements shown on tiles. |\n| `PathNode` | Used for pathfinding visualization (e.g., unit movement paths). |\n| `ResourceManager`, `Messages` | Support for loading images, strings, and localized messages. |\n| `MapControls` | UI component for map navigation and controls. |\n| `ClientOptions` | User preferences affecting display behavior (e.g., fog of war, grid display). |\n| `Tension` | Used in displaying diplomatic status (e.g., alarms from indigenous settlements). |\n\nThis confirms that `GUI.java` is **deeply integrated with the game model**, meaning changes to these types or their interactions may ripple into the GUI.\n\n---\n\n### Impact Analysis Summary So Far\n\n- **Starting Entity**: `GUI.java`\n- **High Co-Change Entities**:\n  - `InGameController.java` \u2013 High conceptual coupling confirmed.\n  - Others like `ActionManager.java`, `UnitMoveAnimation.java`, etc., still need validation.\n- **Call Graph** shows direct dependencies on core game model classes.\n- **Conceptual Coupling** with `InGameController.java` suggests strong semantic relationship.\n\n---\n\n### Next Steps\n\nWe now have enough data to begin identifying **which co-changed entities actually impact `GUI.java`** and should be synchronized.\n\nLet\u2019s proceed by analyzing **coupling dependencies** between `GUI.java` and some of the top co-change candidates:\n1. `ActionManager.java`\n2. `UnitMoveAnimation.java`\n3. `MapEditorController.java`\n\nWe'll use the `get_coupling_dependencies` function to determine if there are direct code-level dependencies.\n\nLet's start with `ActionManager.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_8ab1e61ed8ad47468a4fa9",
                    "function": {
                        "arguments": "{\"entity1\": \"GUI.java\", \"entity2\": \"ActionManager.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"There are no coupling dependencies between these two entities\"]"
        },
        {
            "content": "There are **no direct coupling dependencies** between `GUI.java` and `ActionManager.java`. This suggests that while these two files may be co-changed due to broader functional relationships (e.g., both involved in handling user actions), there is **no explicit code-level dependency** such as method calls, type references, or shared variables.\n\n---\n\n### Next Steps\n\nSince `ActionManager.java` does not have a direct coupling with `GUI.java`, we should:\n1. Check coupling for another high-co-change entity like **UnitMoveAnimation.java**, which might have a more direct visual or control relationship.\n2. Reassess whether some co-change relationships are architectural or behavioral rather than structural.\n\nLet\u2019s now check the coupling between `GUI.java` and `UnitMoveAnimation.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_f68417c46d2546169aaddc",
                    "function": {
                        "arguments": "{\"entity1\": \"GUI.java\", \"entity2\": \"UnitMoveAnimation.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"There are no coupling dependencies between these two entities\"]"
        },
        {
            "role": "user",
            "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
        },
        {
            "content": "Title: Diagnosis of starting entity `GUI.java`  \nChange set: [InGameController, UnitMoveAnimation, ActionManager, Canvas, MapEditorController, MiniMap, MapControls, FreeColLookAndFeel, ChatAction, EndTurnAction, ClientOptions, FreeColMenuBar, InGameMenuBar, ProductionLabel, UnitLabel, TileInfoPanel, ReportContinentalCongressPanel, ImageLibrary, InfoPanel, CombatOdds, Animations, FreeColClient, InGameInputHandler, PreGameController, ViewMode, DisplayTileOwnersAction, ProductionPanel, TilePanel, DebugMenu, ColonyPanel, MoveAction, MapboardAction, WorkProductionPanel, SelectableAction, FreeColAction, ColopediaAction, FindSettlementDialog, ServerPlayer, AIColony, ResourceManager, TilePopup]  \n\nDetails:  \n- **InGameController**: High co-change confidence (0.1578), strong conceptual coupling (0.79), and semantic analysis show it coordinates game logic that directly affects the GUI state.  \n- **UnitMoveAnimation**: Frequently co-changed (confidence 0.1447); likely involved in visual updates managed by GUI for unit movements.  \n- **ActionManager**: Co-changed with high support (confidence 0.1184); although no direct coupling found, it mediates user actions reflected in GUI.  \n- **Canvas**: Core UI rendering component; tightly linked to GUI for redrawing and repainting operations.  \n- **MapEditorController**: High co-change score (confidence 0.1184); likely shares similar UI/game-state synchronization needs.  \n- **MiniMap**, **MapControls**, **FreeColMenuBar**, **ViewMode**, **TileInfoPanel**, **InfoPanel**, **DebugMenu**, **ColonyPanel**, **FindSettlementDialog**, **TilePopup**: These are all UI components or controllers used within the main GUI for rendering and interaction.  \n- **FreeColLookAndFeel**, **DisplayTileOwnersAction**, **SelectableAction**, **FreeColAction**, **ColopediaAction**, **MapboardAction**, **MoveAction**: Actions/UI customizations that are likely triggered or displayed via GUI.  \n- **CombatOdds**, **Animations**, **WorkProductionPanel**, **ProductionPanel**, **ProductionLabel**, **UnitLabel**, **TilePanel**: Visual elements related to gameplay features managed through GUI.  \n- **ClientOptions**: Affects display settings (e.g., fog of war, grid) that `GUI.java` must reflect.  \n- **ResourceManager**, **ImageLibrary**: Provide resources used in GUI rendering.  \n- **InGameInputHandler**, **PreGameController**: Coordinate input and pre-game setup that influence GUI behavior.  \n- **ServerPlayer**, **AIColony**: Game model entities whose state changes may trigger UI updates.  \n- **FreeColClient**: Central client interface, frequently used by GUI to access game state and controllers.  \n\nAll these entities are either:\n- Directly involved in UI rendering/modification,\n- Frequently co-changed with `GUI.java`, or\n- Semantically tied to GUI behavior based on functional dependencies.\n\nThus, they should be considered as part of the change impact set when modifying `GUI.java`.",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        }
    ],
    "interaction_records": {
        "step_histories": [
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4"
                ],
                "response_message": "m5"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6"
                ],
                "response_message": "m7"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8"
                ],
                "response_message": "m9"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10"
                ],
                "response_message": "m11"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12"
                ],
                "response_message": "m13"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14"
                ],
                "response_message": "m15"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14",
                    "m15",
                    "m14",
                    "m16"
                ],
                "response_message": "m17"
            }
        ],
        "mid_to_message": {
            "m1": {
                "role": "system",
                "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
            },
            "m2": {
                "role": "user",
                "content": "The project you need to analyze is `freecol`, a well-known Java open source project. The starting entity you need to deal with is GUI.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
            },
            "m3": {
                "content": "",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_f38bbaaea9634182adaede",
                        "function": {
                            "arguments": "{\"entity\": \"GUI.java\"}",
                            "name": "get_co_change_relationship"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m4": {
                "name": "get_co_change_relationship",
                "role": "tool",
                "content": "[[\"ImageLibrary\", \"4\", \"0.05263157894736842\"], [\"MiniMap\", \"7\", \"0.09210526315789473\"], [\"MapControls\", \"5\", \"0.06578947368421052\"], [\"FreeColLookAndFeel\", \"2\", \"0.02631578947368421\"], [\"ActionManager\", \"9\", \"0.11842105263157894\"], [\"ChatAction\", \"1\", \"0.013157894736842105\"], [\"EndTurnAction\", \"1\", \"0.013157894736842105\"], [\"CanvasKeyListener\", \"2\", \"0.02631578947368421\"], [\"FreeColMenuBar\", \"5\", \"0.06578947368421052\"], [\"InGameController\", \"12\", \"0.15789473684210525\"], [\"ClientOptions\", \"4\", \"0.05263157894736842\"], [\"ReportContinentalCongressPanel\", \"1\", \"0.013157894736842105\"], [\"FreeColClient\", \"4\", \"0.05263157894736842\"], [\"InGameInputHandler\", \"3\", \"0.039473684210526314\"], [\"PreGameController\", \"4\", \"0.05263157894736842\"], [\"ViewMode\", \"3\", \"0.039473684210526314\"], [\"InfoPanel\", \"3\", \"0.039473684210526314\"], [\"TileInfoPanel\", \"4\", \"0.05263157894736842\"], [\"DisplayTileOwnersAction\", \"3\", \"0.039473684210526314\"], [\"ImageProvider\", \"2\", \"0.02631578947368421\"], [\"UnitLabel\", \"10\", \"0.13157894736842105\"], [\"CanvasMapEditorMouseListener\", \"6\", \"0.07894736842105263\"], [\"CanvasMouseListener\", \"4\", \"0.05263157894736842\"], [\"ProductionLabel\", \"8\", \"0.10526315789473684\"], [\"ProductionPanel\", \"2\", \"0.02631578947368421\"], [\"TileImprovement\", \"1\", \"0.013157894736842105\"], [\"TileType\", \"1\", \"0.013157894736842105\"], [\"TerrainGenerator\", \"1\", \"0.013157894736842105\"], [\"TilePanel\", \"5\", \"0.06578947368421052\"], [\"InGameMenuBar\", \"7\", \"0.09210526315789473\"], [\"MapEditorMenuBar\", \"4\", \"0.05263157894736842\"], [\"Animation\", \"1\", \"0.013157894736842105\"], [\"UnitMoveAnimation\", \"11\", \"0.14473684210526316\"], [\"Canvas\", \"9\", \"0.11842105263157894\"], [\"MapControlsAction\", \"2\", \"0.02631578947368421\"], [\"DisplayTileNamesAction\", \"2\", \"0.02631578947368421\"], [\"DisplayRegionAction\", \"1\", \"0.013157894736842105\"], [\"GotoAction\", \"1\", \"0.013157894736842105\"], [\"CanvasMouseMotionListener\", \"1\", \"0.013157894736842105\"], [\"DisplayTileEmptyAction\", \"1\", \"0.013157894736842105\"], [\"DisplayTileRegionsAction\", \"1\", \"0.013157894736842105\"], [\"DisplayBordersAction\", \"2\", \"0.02631578947368421\"], [\"ProductionMultiplesLabel\", \"6\", \"0.07894736842105263\"], [\"OutForAnimationCallback\", \"1\", \"0.013157894736842105\"], [\"UnitImageAnimation\", \"5\", \"0.06578947368421052\"], [\"CombatOdds\", \"1\", \"0.013157894736842105\"], [\"CombatModel\", \"1\", \"0.013157894736842105\"], [\"Animations\", \"4\", \"0.05263157894736842\"], [\"CombatResult\", \"1\", \"0.013157894736842105\"], [\"IndianSettlementPanel\", \"2\", \"0.02631578947368421\"], [\"TilePopup\", \"2\", \"0.02631578947368421\"], [\"UnitMoveAnimationCanvasSwingTask\", \"3\", \"0.039473684210526314\"], [\"DisplayGridAction\", \"1\", \"0.013157894736842105\"], [\"ZoomOutAction\", \"2\", \"0.02631578947368421\"], [\"ZoomInAction\", \"2\", \"0.02631578947368421\"], [\"MapEditorController\", \"9\", \"0.11842105263157894\"], [\"GoodsLabel\", \"2\", \"0.02631578947368421\"], [\"MarketLabel\", \"1\", \"0.013157894736842105\"], [\"FreeColPanel\", \"3\", \"0.039473684210526314\"], [\"FreeColProgressBar\", \"1\", \"0.013157894736842105\"], [\"DebugMenu\", \"5\", \"0.06578947368421052\"], [\"PlayersTable\", \"2\", \"0.02631578947368421\"], [\"MapGenerator\", \"1\", \"0.013157894736842105\"], [\"BuildQueuePanel\", \"2\", \"0.02631578947368421\"], [\"Market\", \"1\", \"0.013157894736842105\"], [\"FreeColDialog\", \"3\", \"0.039473684210526314\"], [\"EuropePanel\", \"1\", \"0.013157894736842105\"], [\"PlayersTableModel\", \"1\", \"0.013157894736842105\"], [\"EmigrationPanel\", \"1\", \"0.013157894736842105\"], [\"PlayerCellEditor\", \"1\", \"0.013157894736842105\"], [\"ReportTurnPanel\", \"2\", \"0.02631578947368421\"], [\"InformationDialog\", \"1\", \"0.013157894736842105\"], [\"FindSettlementDialog\", \"4\", \"0.05263157894736842\"], [\"ColonyPanel\", \"5\", \"0.06578947368421052\"], [\"ReportColonyPanel\", \"1\", \"0.013157894736842105\"], [\"ChipResource\", \"2\", \"0.02631578947368421\"], [\"ResourceManager\", \"3\", \"0.039473684210526314\"], [\"ImageResource\", \"1\", \"0.013157894736842105\"], [\"DisplayTileTextAction\", \"2\", \"0.02631578947368421\"], [\"MoveAction\", \"3\", \"0.039473684210526314\"], [\"MapboardAction\", \"2\", \"0.02631578947368421\"], [\"FreeColAction\", \"2\", \"0.02631578947368421\"], [\"SelectableAction\", \"2\", \"0.02631578947368421\"], [\"ColopediaAction\", \"3\", \"0.039473684210526314\"], [\"WorkProductionPanel\", \"2\", \"0.02631578947368421\"], [\"ColonyPlan\", \"1\", \"0.013157894736842105\"], [\"AIColony\", \"1\", \"0.013157894736842105\"], [\"ServerPlayer\", \"1\", \"0.013157894736842105\"], [\"DifficultyDialog\", \"1\", \"0.013157894736842105\"], [\"ClientOptionsDialog\", \"2\", \"0.02631578947368421\"], [\"FreeColListUI\", \"1\", \"0.013157894736842105\"], [\"FreeColTextFieldUI\", \"1\", \"0.013157894736842105\"], [\"FreeColTextAreaUI\", \"1\", \"0.013157894736842105\"], [\"MainPanel\", \"1\", \"0.013157894736842105\"], [\"FreeColPopupMenuUI\", \"1\", \"0.013157894736842105\"], [\"FreeColMenuBarUI\", \"1\", \"0.013157894736842105\"], [\"FreeColPanelUI\", \"1\", \"0.013157894736842105\"], [\"VictoryPanel\", \"1\", \"0.013157894736842105\"], [\"ConnectController\", \"4\", \"0.05263157894736842\"], [\"ScaleMapAction\", \"1\", \"0.013157894736842105\"], [\"ScrollThread\", \"2\", \"0.02631578947368421\"], [\"NewEmptyMapAction\", \"3\", \"0.039473684210526314\"], [\"TilePopupAction\", \"2\", \"0.02631578947368421\"], [\"ReportPanel\", \"4\", \"0.05263157894736842\"], [\"UnitAttackAnimationCanvasSwingTask\", \"2\", \"0.02631578947368421\"], [\"ServerPlayerTest\", \"1\", \"0.013157894736842105\"], [\"ServerIndianSettlementTest\", \"1\", \"0.013157894736842105\"], [\"StartGamePanel\", \"1\", \"0.013157894736842105\"], [\"ShowGameOptionsAction\", \"1\", \"0.013157894736842105\"], [\"EndTurnDialog\", \"2\", \"0.02631578947368421\"], [\"ChangeAction\", \"2\", \"0.02631578947368421\"], [\"UnitAttackAnimation\", \"1\", \"0.013157894736842105\"], [\"LoadAction\", \"1\", \"0.013157894736842105\"], [\"AssignTradeRouteAction\", \"1\", \"0.013157894736842105\"], [\"UnloadAction\", \"1\", \"0.013157894736842105\"], [\"PreCombatDialog\", \"1\", \"0.013157894736842105\"], [\"ShowInformationMessageSwingTask\", \"1\", \"0.013157894736842105\"], [\"DestinationPanel\", \"1\", \"0.013157894736842105\"], [\"ShowConfirmDialogSwingTask\", \"1\", \"0.013157894736842105\"], [\"EditSettlementDialog\", \"1\", \"0.013157894736842105\"], [\"NewLandNameSwingTask\", \"1\", \"0.013157894736842105\"], [\"ShowMainAction\", \"1\", \"0.013157894736842105\"], [\"OptionsDialog\", \"1\", \"0.013157894736842105\"], [\"NewPanel\", \"1\", \"0.013157894736842105\"], [\"CompactLabourReport\", \"1\", \"0.013157894736842105\"], [\"SpyColonySwingTask\", \"1\", \"0.013157894736842105\"], [\"RefreshCanvasSwingTask\", \"1\", \"0.013157894736842105\"], [\"DragListener\", \"1\", \"0.013157894736842105\"], [\"BuildQueueMouseAdapter\", \"1\", \"0.013157894736842105\"], [\"MonarchPanel\", \"1\", \"0.013157894736842105\"], [\"ConstructionPanel\", \"1\", \"0.013157894736842105\"], [\"BuildingsPanel\", \"1\", \"0.013157894736842105\"]]"
            },
            "m5": {
                "content": "The `get_co_change_relationship` function has provided a list of entities that are frequently co-changed with **GUI.java** along with their support count and confidence score. The confidence score indicates the probability that a particular entity was modified alongside GUI.java in previous commits.\n\n### Interpretation:\n- **Support Count**: Number of times an entity was modified together with GUI.java.\n- **Confidence Score**: Calculated as (support count) / (total number of GUI.java modifications). A higher value means stronger correlation.\n\n### Next Steps:\nTo determine which entities should be synchronized or investigated further, we can focus on those with high confidence scores and support counts. These represent strong correlations to changes in `GUI.java`.\n\n#### Top 5 Entities with Highest Confidence Scores:\n1. **InGameController** - Support: 12, Confidence: **0.1578**\n2. **UnitMoveAnimation** - Support: 11, Confidence: **0.1447**\n3. **ActionManager** - Support: 9, Confidence: **0.1184**\n4. **Canvas** - Support: 9, Confidence: **0.1184**\n5. **MapEditorController** - Support: 9, Confidence: **0.1184**\n\nThese five seem most likely to be impacted by or related to changes in `GUI.java`. To understand why these relationships exist, I'll examine one of these files to see how it relates semantically or structurally to `GUI.java`.\n\nLet\u2019s start by analyzing the code of **InGameController.java**, as it has the highest confidence score.\n\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_3509e01f30a046bbb9f815",
                        "function": {
                            "arguments": "{\"entity\": \"InGameController.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m6": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package net.sf.freecol.server.control;\\nimport java.io.IOException;\\nimport java.util.ArrayList;\\nimport java.util.EnumMap;\\nimport java.util.HashMap;\\nimport java.util.Iterator;\\nimport java.util.List;\\nimport java.util.Timer;\\nimport java.util.TimerTask;\\nimport java.util.logging.Level;\\nimport java.util.logging.Logger;\\nimport net.sf.freecol.FreeCol;\\nimport net.sf.freecol.common.Specification;\\nimport net.sf.freecol.common.model.AbstractUnit;\\nimport net.sf.freecol.common.model.Colony;\\nimport net.sf.freecol.common.model.CombatModel;\\nimport net.sf.freecol.common.model.EquipmentType;\\nimport net.sf.freecol.common.model.FoundingFather;\\nimport net.sf.freecol.common.model.GameOptions;\\nimport net.sf.freecol.common.model.Goods;\\nimport net.sf.freecol.common.model.GoodsType;\\nimport net.sf.freecol.common.model.IndianSettlement;\\nimport net.sf.freecol.common.model.Location;\\nimport net.sf.freecol.common.model.Map;\\nimport net.sf.freecol.common.model.Market;\\nimport net.sf.freecol.common.model.ModelController;\\nimport net.sf.freecol.common.model.Modifier;\\nimport net.sf.freecol.common.model.Monarch;\\nimport net.sf.freecol.common.model.Nation;\\nimport net.sf.freecol.common.model.Player;\\nimport net.sf.freecol.common.model.Settlement;\\nimport net.sf.freecol.common.model.Tension;\\nimport net.sf.freecol.common.model.Tile;\\nimport net.sf.freecol.common.model.Unit;\\nimport net.sf.freecol.common.model.UnitType;\\nimport net.sf.freecol.common.model.FoundingFather.FoundingFatherType;\\nimport net.sf.freecol.common.model.Map.Direction;\\nimport net.sf.freecol.common.model.Map.Position;\\nimport net.sf.freecol.common.model.Monarch.MonarchAction;\\nimport net.sf.freecol.common.model.Player.PlayerType;\\nimport net.sf.freecol.common.model.Player.Stance;\\nimport net.sf.freecol.common.model.Unit.UnitState;\\nimport net.sf.freecol.common.networking.Message;\\nimport net.sf.freecol.server.FreeColServer;\\nimport net.sf.freecol.server.model.ServerPlayer;\\nimport org.w3c.dom.Element;\\npublic final class InGameController extends Controller {\\n    private static Logger logger = Logger.getLogger(InGameController.class.getName());\\n    public int debugOnlyAITurns = 0;\\n    private java.util.Map<String,java.util.Map<String, java.util.Map<String,Object>>> transactionSessions;\\n    public InGameController(FreeColServer freeColServer) {\\n        super(freeColServer);\\n        transactionSessions = new HashMap<String,java.util.Map<String, java.util.Map<String,Object>>>();\\n    }\\n    public void endTurn(ServerPlayer player) {\\n        try {\\n            Thread.sleep(100);\\n        } catch (InterruptedException e) {}\\n        FreeColServer freeColServer = getFreeColServer();\\n        ServerPlayer oldPlayer = (ServerPlayer) getGame().getCurrentPlayer();\\n        if (oldPlayer != player) {\\n            logger.warning(\\\"It is not \\\" + player.getName() + \\\"'s turn!\\\");\\n            throw new IllegalArgumentException(\\\"It is not \\\" + player.getName() + \\\"'s turn!\\\");\\n        }\\n        player.clearModelMessages();\\n        freeColServer.getModelController().clearTaskRegister();\\n        Player winner = checkForWinner();\\n        if (winner != null && (!freeColServer.isSingleplayer() || !winner.isAI())) {\\n            Element gameEndedElement = Message.createNewRootElement(\\\"gameEnded\\\");\\n            gameEndedElement.setAttribute(\\\"winner\\\", winner.getId());\\n            freeColServer.getServer().sendToAll(gameEndedElement, null);\\n                        if (FreeCol.getFreeColClient() == null) {\\n                new Timer(true).schedule(new TimerTask() {\\n                    @Override\\n                    public void run() {\\n                        System.exit(0);\\n                    }\\n                }, 20000);\\n            }\\n            return;\\n        }\\n        ServerPlayer newPlayer = (ServerPlayer) nextPlayer();\\n        if (newPlayer != null \\n            && !newPlayer.isAI()\\n            && (!newPlayer.isConnected() || debugOnlyAITurns > 0)) {\\n            endTurn(newPlayer);\\n            return;\\n        }\\n    }\\n    private Player nextPlayer() {\\n        final FreeColServer freeColServer = getFreeColServer();\\n        if (!isHumanPlayersLeft()) {\\n            getGame().setCurrentPlayer(null);\\n            return null;\\n        }\\n        if (getGame().isNextPlayerInNewTurn()) {\\n            getGame().newTurn();\\n            if (debugOnlyAITurns > 0) {\\n                debugOnlyAITurns--;\\n            }\\n            Element newTurnElement = Message.createNewRootElement(\\\"newTurn\\\");\\n            freeColServer.getServer().sendToAll(newTurnElement, null);\\n        }\\n        ServerPlayer newPlayer = (ServerPlayer) getGame().getNextPlayer();\\n        getGame().setCurrentPlayer(newPlayer);\\n        if (newPlayer == null) {\\n            getGame().setCurrentPlayer(null);\\n            return null;\\n        }\\n        synchronized (newPlayer) {\\n            if (checkForDeath(newPlayer)) {\\n                newPlayer.setDead(true);\\n                Element setDeadElement = Message.createNewRootElement(\\\"setDead\\\");\\n                setDeadElement.setAttribute(\\\"player\\\", newPlayer.getId());\\n                freeColServer.getServer().sendToAll(setDeadElement, null);\\n                return nextPlayer();\\n            }\\n        }\\n        if (newPlayer.isEuropean()) {\\n            try {        \\n                Market market = newPlayer.getMarket();\\n                                List<GoodsType> goodsTypes = FreeCol.getSpecification().getGoodsTypeList();\\n                GoodsType typeToRemove = goodsTypes.get(getPseudoRandom().nextInt(goodsTypes.size()));\\n                if (typeToRemove.isStorable()) {\\n                    int amountToRemove = getPseudoRandom().nextInt(21);\\n                    market.remove(typeToRemove, amountToRemove);\\n                    Element updateElement = Message.createNewRootElement(\\\"marketElement\\\");\\n                    updateElement.setAttribute(\\\"type\\\", typeToRemove.getId());\\n                    updateElement.setAttribute(\\\"amount\\\", String.valueOf(-amountToRemove));\\n                    newPlayer.getConnection().send(updateElement);\\n                }\\n            } catch (IOException e) {\\n                logger.warning(\\\"Could not send message to: \\\" + newPlayer.getName() +\\n                               \\\" with connection \\\" + newPlayer.getConnection());\\n            }\\n            if (newPlayer.getCurrentFather() == null && newPlayer.getSettlements().size() > 0) {\\n                chooseFoundingFather(newPlayer);\\n            }\\n            if (newPlayer.getMonarch() != null) {\\n                monarchAction(newPlayer);\\n            }\\n            bombardEnemyShips(newPlayer);\\n        }\\n        else if (newPlayer.isIndian()) {\\n            for (IndianSettlement indianSettlement: newPlayer.getIndianSettlements()) {\\n                if (indianSettlement.checkForNewMissionaryConvert()) {\\n                                        Unit missionary = indianSettlement.getMissionary();\\n                    ServerPlayer european = (ServerPlayer) missionary.getOwner();\\n                                        Tile settlementTile = indianSettlement.getTile();\\n                    Tile targetTile = null;\\n                    Iterator<Position> ffi = getGame().getMap().getFloodFillIterator(settlementTile.getPosition());\\n                    while (ffi.hasNext()) {\\n                        Tile t = getGame().getMap().getTile(ffi.next());\\n                        if (settlementTile.getDistanceTo(t) > IndianSettlement.MAX_CONVERT_DISTANCE) {\\n                            break;\\n                        }\\n                        if (t.getSettlement() != null && t.getSettlement().getOwner() == european) {\\n                            targetTile = t;\\n                            break;\\n                        }\\n                    }\\n                    if (targetTile != null) {\\n                        List<UnitType> converts = FreeCol.getSpecification().getUnitTypesWithAbility(\\\"model.ability.convert\\\");\\n                        if (converts.size() > 0) {\\n                                                        Unit brave = indianSettlement.getUnitIterator().next();\\n                            String nationId = brave.getOwner().getNationID();\\n                            brave.dispose();\\n                            ModelController modelController = getGame().getModelController();\\n                            int random = modelController.getRandom(indianSettlement.getId() + \\\"getNewConvertType\\\", converts.size());\\n                            UnitType unitType = converts.get(random);\\n                            Unit unit = modelController.createUnit(indianSettlement.getId() + \\\"newTurn100missionary\\\", targetTile,\\n                                    european, unitType);\\n                                                        try {\\n                                Element updateElement = Message.createNewRootElement(\\\"newConvert\\\");\\n                                updateElement.setAttribute(\\\"nation\\\", nationId);\\n                                updateElement.setAttribute(\\\"colonyTile\\\", targetTile.getId());\\n                                updateElement.appendChild(unit.toXMLElement(european,updateElement.getOwnerDocument()));\\n                                european.getConnection().send(updateElement);\\n                                logger.info(\\\"New convert created for \\\" + european.getName() + \\\" with ID=\\\" + unit.getId());\\n                            } catch (IOException e) {\\n                                logger.warning(\\\"Could not send message to: \\\" + european.getName());\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        Element setCurrentPlayerElement = Message.createNewRootElement(\\\"setCurrentPlayer\\\");\\n        setCurrentPlayerElement.setAttribute(\\\"player\\\", newPlayer.getId());\\n        freeColServer.getServer().sendToAll(setCurrentPlayerElement, null);\\n        return newPlayer;\\n    }\\n    private boolean isHumanPlayersLeft() {\\n        for (Player player : getFreeColServer().getGame().getPlayers()) {\\n            if (!player.isDead() && !player.isAI() && ((ServerPlayer) player).isConnected()) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    private void chooseFoundingFather(ServerPlayer player) {\\n        final ServerPlayer nextPlayer = player;\\n        Thread t = new Thread(FreeCol.SERVER_THREAD+\\\"FoundingFather-thread\\\") {\\n                public void run() {\\n                    List<FoundingFather> randomFoundingFathers = getRandomFoundingFathers(nextPlayer);\\n                    boolean atLeastOneChoice = false;\\n                    Element chooseFoundingFatherElement = Message.createNewRootElement(\\\"chooseFoundingFather\\\");\\n                    for (FoundingFather father : randomFoundingFathers) {\\n                        chooseFoundingFatherElement.setAttribute(father.getType().toString(),\\n                                                                 father.getId());\\n                        atLeastOneChoice = true;\\n                    }\\n                    if (!atLeastOneChoice) {\\n                        nextPlayer.setCurrentFather(null);\\n                    } else {\\n                        try {\\n                            Element reply = nextPlayer.getConnection().ask(chooseFoundingFatherElement);\\n                            FoundingFather father = FreeCol.getSpecification().\\n                                getFoundingFather(reply.getAttribute(\\\"foundingFather\\\"));\\n                            if (!randomFoundingFathers.contains(father)) {\\n                                throw new IllegalArgumentException();\\n                            }\\n                            nextPlayer.setCurrentFather(father);\\n                        } catch (IOException e) {\\n                            logger.warning(\\\"Could not send message to: \\\" + nextPlayer.getName());\\n                        }\\n                    }\\n                }\\n            };\\n        t.start();\\n    }\\n    private List<FoundingFather> getRandomFoundingFathers(Player player) {\\n        int age = getGame().getTurn().getAge();\\n        List<FoundingFather> randomFoundingFathers = new ArrayList<FoundingFather>();\\n        EnumMap<FoundingFatherType, Integer> weightSums = new\\n            EnumMap<FoundingFatherType, Integer>(FoundingFatherType.class);\\n        for (FoundingFather father : FreeCol.getSpecification().getFoundingFathers()) {\\n            if (!player.hasFather(father) && father.isAvailableTo(player)) {\\n                Integer weightSum = weightSums.get(father.getType());\\n                if (weightSum == null) {\\n                    weightSum = new Integer(0);\\n                }\\n                weightSums.put(father.getType(), weightSum + father.getWeight(age));\\n            }\\n        }\\n        for (java.util.Map.Entry<FoundingFatherType, Integer> entry : weightSums.entrySet()) {\\n            if (entry.getValue() != 0) {\\n                int r = getPseudoRandom().nextInt(entry.getValue()) + 1;\\n                int weightSum = 0;\\n                for (FoundingFather father : FreeCol.getSpecification().getFoundingFathers()) {\\n                    if (!player.hasFather(father) && father.getType() == entry.getKey()) {\\n                        weightSum += father.getWeight(age);\\n                        if (weightSum >= r) {\\n                            randomFoundingFathers.add(father);\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return randomFoundingFathers;\\n    }\\n    public Player checkForWinner() {\\n        List<Player> players = getGame().getPlayers();\\n        GameOptions go = getGame().getGameOptions();\\n        if (go.getBoolean(GameOptions.VICTORY_DEFEAT_REF)) {\\n            for (Player player : players) {\\n                if (!player.isAI() && player.getPlayerType() == PlayerType.INDEPENDENT) {\\n                    return player;\\n                }\\n            }\\n        }\\n        if (go.getBoolean(GameOptions.VICTORY_DEFEAT_EUROPEANS)) {\\n            Player winner = null;\\n            for (Player player : players) {\\n                if (!player.isDead() && player.isEuropean() && !player.isREF()) {\\n                    if (winner != null) {\\n                                                winner = null;\\n                        break;\\n                    } else {\\n                        winner = player;\\n                    }\\n                }\\n            }\\n            if (winner != null) {\\n                return winner;\\n            }\\n        }\\n        if (go.getBoolean(GameOptions.VICTORY_DEFEAT_HUMANS)) {\\n            Player winner = null;\\n            for (Player player : players) {\\n                if (!player.isDead() && !player.isAI()) {\\n                    if (winner != null) {\\n                                                winner = null;\\n                        break;\\n                    } else {\\n                        winner = player;\\n                    }\\n                }\\n            }\\n            if (winner != null) {\\n                return winner;\\n            }\\n        }\\n        return null;\\n    }\\n    private boolean checkForDeath(Player player) {\\n        if (player.isREF()) {\\n            return false;\\n        }\\n                if (!player.getSettlements().isEmpty()) {\\n            return false;\\n        }\\n                boolean hasCarrier = false;\\n        List<Unit> unitList = player.getUnits();\\n        for(Unit unit : unitList){\\n            boolean isValidUnit = false;\\n            if(unit.isCarrier()){\\n                hasCarrier = true;\\n                logger.info(\\\"Still has carrier\\\");\\n                continue;\\n            }\\n                        if(unit.isColonist()){\\n                isValidUnit = true;\\n            }\\n                        if(unit.isOffensiveUnit()){\\n                isValidUnit = true;\\n            }\\n            if(!isValidUnit){\\n                continue;\\n            }\\n                        Location unitLocation = unit.getLocation();\\n                        if(unitLocation instanceof Tile){\\n                logger.info(\\\"Found colonist in new world\\\");\\n                return false;\\n            }\\n                        if(unit.isOnCarrier()){\\n                Unit carrier = (Unit) unitLocation;\\n                                if(carrier.getLocation() instanceof Tile){\\n                    logger.info(\\\"Found colonist aboard carrier in new world\\\");\\n                    return false;\\n                }   \\n            }\\n        }\\n        if (!player.isEuropean() || player.getEurope() == null) {\\n            return true;\\n        }\\n                if (getGame().getTurn().getYear() >= 1600) {\\n            logger.info(\\\"No presence in new world after 1600\\\");\\n            return true;\\n        }\\n        int goldNeeded = 0;\\n        if(!hasCarrier){\\n            Iterator<UnitType> navalUnits = FreeCol.getSpecification().getUnitTypesWithAbility(\\\"model.ability.navalUnit\\\").iterator();\\n            int lowerPrice = Integer.MAX_VALUE;\\n            while(navalUnits.hasNext()){\\n                UnitType unit = navalUnits.next();\\n                int unitPrice = player.getEurope().getUnitPrice(unit);\\n                                if(unitPrice == UnitType.UNDEFINED){\\n                    continue;\\n                }\\n                if(unitPrice < lowerPrice){\\n                    lowerPrice = unitPrice;\\n                }\\n            }\\n                        if(lowerPrice == Integer.MAX_VALUE){\\n                logger.warning(\\\"Couldnt find naval unit to buy\\\");\\n                return true;\\n            }\\n            goldNeeded += lowerPrice;\\n                        if(goldNeeded > player.getGold()){\\n                logger.info(\\\"Does not have enough money to buy carrier\\\");\\n                return true;\\n            }\\n            logger.info(\\\"Has enough money to buy carrier, has=\\\" + player.getGold() + \\\", needs=\\\" + lowerPrice);\\n        }\\n        Iterator<Unit> unitIterator = player.getEurope().getUnitIterator();\\n        while (unitIterator.hasNext()) {\\n            Unit unit = unitIterator.next();\\n            if (unit.isCarrier()) {\\n                if(unit.getGoodsCount() > 0){\\n                    logger.info(\\\"Has goods to sell\\\");\\n                    return false;\\n                }\\n                continue;\\n            }\\n            if (unit.isColonist()){\\n                logger.info(\\\"Has colonist unit waiting in port\\\");\\n                return false;\\n            }\\n        }\\n        int goldToRecruit =  player.getEurope().getRecruitPrice();\\n        Iterator<UnitType> trainedUnits = FreeCol.getSpecification().getUnitTypesTrainedInEurope().iterator();\\n        int goldToTrain = Integer.MAX_VALUE;\\n        while(trainedUnits.hasNext()){\\n            UnitType unit = trainedUnits.next();\\n            if(!unit.hasAbility(\\\"model.ability.foundColony\\\")){\\n                continue;\\n            }\\n            int unitPrice = player.getEurope().getUnitPrice(unit);\\n                        if(unitPrice == UnitType.UNDEFINED){\\n                continue;\\n            }\\n            if(unitPrice < goldToTrain){\\n                goldToTrain = unitPrice;\\n            }\\n        }\\n        goldNeeded += Math.min(goldToTrain, goldToRecruit);\\n                if(goldNeeded > player.getGold()){\\n            logger.info(\\\"Does not have enough money for recruiting or training\\\");\\n            return true;\\n        }\\n        return false;\\n    }\\n    private void monarchAction(ServerPlayer player) {\\n        final ServerPlayer nextPlayer = player;\\n        Thread t = new Thread(\\\"monarchAction\\\") {\\n                public void run() {\\n                    try {\\n                        Monarch monarch = nextPlayer.getMonarch();\\n                        MonarchAction action = monarch.getAction();\\n                        Element monarchActionElement = Message.createNewRootElement(\\\"monarchAction\\\");\\n                        monarchActionElement.setAttribute(\\\"action\\\", String.valueOf(action));\\n                        switch (action) {\\n                        case RAISE_TAX:\\n                            int oldTax = nextPlayer.getTax();\\n                            int newTax = monarch.getNewTax(MonarchAction.RAISE_TAX);\\n                            if (newTax > 100) {\\n                                logger.warning(\\\"Tax rate exceeds 100 percent.\\\");\\n                                return;\\n                            }\\n                            Goods goods = nextPlayer.getMostValuableGoods();\\n                            if (goods == null) {\\n                                return;\\n                            }\\n                            monarchActionElement.setAttribute(\\\"amount\\\", String.valueOf(newTax));\\n                            monarchActionElement.setAttribute(\\\"goods\\\", goods.getName());\\n                            monarchActionElement.setAttribute(\\\"force\\\", String.valueOf(false));\\n                            try {\\n                                nextPlayer.setTax(newTax);                                 Element reply = nextPlayer.getConnection().ask(monarchActionElement);\\n                                boolean accepted = Boolean.valueOf(reply.getAttribute(\\\"accepted\\\")).booleanValue();\\n                                if (!accepted) {\\n                                    Colony colony = (Colony) goods.getLocation();\\n                                    if (colony.getGoodsCount(goods.getType()) >= goods.getAmount()) {\\n                                        nextPlayer.setTax(oldTax);                                         Element removeGoodsElement = Message.createNewRootElement(\\\"removeGoods\\\");\\n                                        colony.removeGoods(goods);\\n                                        nextPlayer.setArrears(goods);\\n                                        colony.getFeatureContainer().addModifier(Modifier\\n                                            .createTeaPartyModifier(getGame().getTurn()));\\n                                        removeGoodsElement.appendChild(goods.toXMLElement(nextPlayer, removeGoodsElement\\n                                                                                          .getOwnerDocument()));\\n                                        nextPlayer.getConnection().send(removeGoodsElement);\\n                                    } else {\\n                                                                                monarchActionElement.setAttribute(\\\"force\\\", String.valueOf(true));\\n                                        nextPlayer.getConnection().send(monarchActionElement);\\n                                    }\\n                                }\\n                            } catch (IOException e) {\\n                                logger.warning(\\\"Could not send message to: \\\" + nextPlayer.getName());\\n                            }\\n                            break;\\n                        case LOWER_TAX:\\n                            int taxLowered = monarch.getNewTax(MonarchAction.LOWER_TAX);\\n                            if (taxLowered < 0) {\\n                                logger.warning(\\\"Tax rate less than 0 percent.\\\");\\n                                return;\\n                            }\\n                            monarchActionElement.setAttribute(\\\"amount\\\", String.valueOf(taxLowered));\\n                            try {\\n                                nextPlayer.setTax(taxLowered);                                 nextPlayer.getConnection().send(monarchActionElement); \\n                            } catch (IOException e) {\\n                                logger.warning(\\\"Could not send message to: \\\" + nextPlayer.getName());\\n                            }\\n                            break;\\n                        case ADD_TO_REF:\\n                            List<AbstractUnit> unitsToAdd = monarch.addToREF();\\n                            monarch.addToREF(unitsToAdd);\\n                            Element additionElement = monarchActionElement.getOwnerDocument().createElement(\\\"addition\\\");\\n                            for (AbstractUnit unit : unitsToAdd) {\\n                                additionElement.appendChild(unit.toXMLElement(nextPlayer,additionElement.getOwnerDocument()));\\n                            }\\n                            monarchActionElement.appendChild(additionElement);\\n                            try {\\n                                nextPlayer.getConnection().send(monarchActionElement);\\n                            } catch (IOException e) {\\n                                logger.warning(\\\"Could not send message to: \\\" + nextPlayer.getName());\\n                            }\\n                            break;\\n                        case DECLARE_WAR:\\n                            Player enemy = monarch.declareWar();\\n                            if (enemy == null) {\\n                                                                logger.warning(\\\"Declared war on nobody.\\\");\\n                                return;\\n                            }\\n                                                        if(nextPlayer.isAI()){\\n                                nextPlayer.modifyTension(enemy, Tension.TENSION_ADD_DECLARE_WAR_FROM_PEACE);\\n                            }\\n                            nextPlayer.changeRelationWithPlayer(enemy, Stance.WAR);\\n                            monarchActionElement.setAttribute(\\\"enemy\\\", enemy.getId());\\n                            try {\\n                                nextPlayer.getConnection().send(monarchActionElement);\\n                            } catch (IOException e) {\\n                                logger.warning(\\\"Could not send message to: \\\" + nextPlayer.getName());\\n                            }\\n                            break;\\n                        case OFFER_MERCENARIES:\\n                            Element mercenaryElement = monarchActionElement.getOwnerDocument().createElement(\\\"mercenaries\\\");\\n                            List<AbstractUnit> units = monarch.getMercenaries();\\n                            int price = monarch.getPrice(units, true);\\n                            monarchActionElement.setAttribute(\\\"price\\\", String.valueOf(price));\\n                            for (AbstractUnit unit : units) {\\n                                mercenaryElement.appendChild(unit.toXMLElement(monarchActionElement.getOwnerDocument()));\\n                            }\\n                            monarchActionElement.appendChild(mercenaryElement);\\n                            try {\\n                                Element reply = nextPlayer.getConnection().ask(monarchActionElement);\\n                                boolean accepted = Boolean.valueOf(reply.getAttribute(\\\"accepted\\\")).booleanValue();\\n                                if (accepted) {\\n                                    Element updateElement = Message.createNewRootElement(\\\"monarchAction\\\");\\n                                    updateElement.setAttribute(\\\"action\\\", String.valueOf(MonarchAction.ADD_UNITS));\\n                                    nextPlayer.modifyGold(-price);\\n                                    createUnits(units, updateElement, nextPlayer);\\n                                    nextPlayer.getConnection().send(updateElement);\\n                                }\\n                            } catch (IOException e) {\\n                                logger.warning(\\\"Could not send message to: \\\" + nextPlayer.getName());\\n                            }\\n                            break;\\n                        case NO_ACTION:\\n                                                        break;\\n                        }\\n                    } catch (Exception e) {\\n                        logger.log(Level.WARNING, \\\"Monarch action failed!\\\", e);\\n                    }\\n                }\\n            };\\n        t.start();\\n    }\\n    public ServerPlayer createREFPlayer(ServerPlayer player){\\n        Nation refNation = Specification.getSpecification().getNation(player.getNation().getRefId());\\n        ServerPlayer refPlayer = getFreeColServer().addAIPlayer(refNation);\\n        refPlayer.setEntryLocation(player.getEntryLocation());\\n                player.setStance(refPlayer, Stance.PEACE);\\n        refPlayer.setTension(player, new Tension(Tension.Level.CONTENT.getLimit()));\\n        player.setTension(refPlayer, new Tension(Tension.Level.CONTENT.getLimit()));\\n        return refPlayer;\\n    }\\n    private void createUnits(List<AbstractUnit> units, Element element, ServerPlayer nextPlayer) {\\n        String musketsTypeStr = null;\\n        String horsesTypeStr = null;\\n        if(nextPlayer.isIndian()){\\n                musketsTypeStr = \\\"model.equipment.indian.muskets\\\";\\n            horsesTypeStr = \\\"model.equipment.indian.horses\\\";\\n        } else {\\n                musketsTypeStr = \\\"model.equipment.muskets\\\";\\n            horsesTypeStr = \\\"model.equipment.horses\\\";\\n        }\\n        final EquipmentType muskets = FreeCol.getSpecification().getEquipmentType(musketsTypeStr);\\n        final EquipmentType horses = FreeCol.getSpecification().getEquipmentType(horsesTypeStr);\\n        EquipmentType[] soldier = new EquipmentType[] { muskets };\\n        EquipmentType[] dragoon = new EquipmentType[] { horses, muskets };\\n        for (AbstractUnit unit : units) {\\n            EquipmentType[] equipment = EquipmentType.NO_EQUIPMENT;\\n            for (int count = 0; count < unit.getNumber(); count++) {\\n                switch(unit.getRole()) {\\n                case SOLDIER:\\n                    equipment = soldier;\\n                    break;\\n                case DRAGOON:\\n                    equipment = dragoon;\\n                    break;\\n                default:\\n                }\\n                Unit newUnit = new Unit(getGame(), nextPlayer.getEurope(), nextPlayer,\\n                                        unit.getUnitType(), UnitState.ACTIVE, equipment);\\n                                if (element != null) {\\n                    element.appendChild(newUnit.toXMLElement(nextPlayer, element.getOwnerDocument()));\\n                }\\n            }\\n        }\\n    }\\n    public List<Unit> createREFUnits(ServerPlayer player, ServerPlayer refPlayer){\\n        EquipmentType muskets = Specification.getSpecification().getEquipmentType(\\\"model.equipment.muskets\\\");\\n        EquipmentType horses = Specification.getSpecification().getEquipmentType(\\\"model.equipment.horses\\\");\\n        List<Unit> unitsList = new ArrayList<Unit>();\\n        List<Unit> navalUnits = new ArrayList<Unit>();\\n        List<Unit> landUnits = new ArrayList<Unit>();\\n                for (AbstractUnit unit : player.getMonarch().getNavalUnits()) {\\n            for (int index = 0; index < unit.getNumber(); index++) {\\n                Unit newUnit = new Unit(getGame(), refPlayer.getEurope(), refPlayer,\\n                                        unit.getUnitType(), UnitState.TO_AMERICA);\\n                navalUnits.add(newUnit);\\n            }\\n        }\\n        unitsList.addAll(navalUnits);\\n                for (AbstractUnit unit : player.getMonarch().getLandUnits()) {\\n            EquipmentType[] equipment = EquipmentType.NO_EQUIPMENT;\\n            switch(unit.getRole()) {\\n            case SOLDIER:\\n                equipment = new EquipmentType[] { muskets };\\n                break;\\n            case DRAGOON:\\n                equipment = new EquipmentType[] { horses, muskets };\\n                break;\\n            default:\\n            }\\n            for (int index = 0; index < unit.getNumber(); index++) {\\n                landUnits.add(new Unit(getGame(), refPlayer.getEurope(), refPlayer,\\n                                        unit.getUnitType(), UnitState.ACTIVE, equipment));\\n            }\\n        }\\n        unitsList.addAll(landUnits);\\n                Iterator<Unit> carriers = navalUnits.iterator();\\n        for(Unit unit : landUnits){\\n                        boolean noSpaceForUnit=true;\\n            for(Unit carrier : navalUnits){\\n                if (unit.getSpaceTaken() <= carrier.getSpaceLeft()) {\\n                    noSpaceForUnit=false;\\n                    break;\\n                }\\n            }\\n                        if(noSpaceForUnit){\\n                continue;\\n            }\\n                        Unit carrier = null;\\n            while (carrier == null){\\n                                if (!carriers.hasNext()) {\\n                    carriers = navalUnits.iterator();\\n                }\\n                carrier = carriers.next();\\n                                if (unit.getSpaceTaken() > carrier.getSpaceLeft()) {\\n                    carrier = null;\\n                }\\n            }\\n                        unit.setLocation(carrier);\\n                                }\\n        return unitsList;\\n    }\\n    public boolean createMission(IndianSettlement settlement,Unit missionary){\\n        settlement.setMissionary(missionary);\\n                return true;\\n    }\\n    private void bombardEnemyShips(ServerPlayer currentPlayer) {\\n        logger.finest(\\\"Entering method bombardEnemyShips.\\\");\\n        Map map = getFreeColServer().getGame().getMap();\\n        CombatModel combatModel = getFreeColServer().getGame().getCombatModel();\\n        for (Settlement settlement : currentPlayer.getSettlements()) {\\n            Colony colony = (Colony) settlement;\\n            if (colony.canBombardEnemyShip()){\\n                logger.fine(\\\"Colony \\\" + colony.getName() + \\\" can bombard enemy ships.\\\");\\n                Position colonyPosition = colony.getTile().getPosition();\\n                for (Direction direction : Direction.values()) {\\n                    Tile tile = map.getTile(Map.getAdjacent(colonyPosition, direction));\\n                                        if(tile == null || tile.isLand()){\\n                        continue;\\n                    }\\n                                                            List<Unit> unitList = new ArrayList<Unit>(tile.getUnitList());\\n                    Iterator<Unit> unitIterator = unitList.iterator();\\n                    while (unitIterator.hasNext()) {\\n                        Unit unit = unitIterator.next();\\n                        Player player = unit.getOwner();\\n                                                if(player == currentPlayer){\\n                                continue;\\n                        }\\n                                                if(currentPlayer.getStance(player) != Stance.WAR &&\\n                                                !unit.hasAbility(\\\"model.ability.piracy\\\")){\\n                                continue;\\n                        }\\n                        logger.info(colony.getName() + \\\" found enemy unit to bombard: \\\" + unit.getName() + \\\"(\\\" + unit.getOwner().getNationAsString() + \\\")\\\");\\n                                                CombatModel.CombatResult result = combatModel.generateAttackResult(colony, unit);\\n                                                Location repairLocation = null;\\n                        if(result.type == CombatModel.CombatResultType.WIN){\\n                                        repairLocation = player.getRepairLocation(unit);\\n                        }\\n                                                getGame().getCombatModel().bombard(colony, unit, result, repairLocation);\\n                                                                        int plunderGold = -1;\\n                        Iterator<Player> enemyPlayerIterator = getFreeColServer().getGame().getPlayerIterator();\\n                        while (enemyPlayerIterator.hasNext()) {\\n                                ServerPlayer enemyPlayer = (ServerPlayer) enemyPlayerIterator.next();\\n                                if (                                                enemyPlayer.getConnection() == null) {\\n                                        continue;\\n                                }\\n                                                                if(!unit.isVisibleTo(enemyPlayer)){\\n                                        continue;\\n                                }\\n                                Element opponentAttackElement = Message.createNewRootElement(\\\"opponentAttack\\\");                                 \\n                                opponentAttackElement.setAttribute(\\\"direction\\\", direction.toString());\\n                                opponentAttackElement.setAttribute(\\\"result\\\", result.type.toString());\\n                                opponentAttackElement.setAttribute(\\\"plunderGold\\\", Integer.toString(plunderGold));\\n                            opponentAttackElement.setAttribute(\\\"colony\\\", colony.getId());\\n                                opponentAttackElement.setAttribute(\\\"defender\\\", unit.getId());\\n                                opponentAttackElement.setAttribute(\\\"damage\\\", String.valueOf(result.damage));\\n                                                                if(enemyPlayer == player && repairLocation != null){\\n                                        opponentAttackElement.setAttribute(\\\"repairIn\\\", repairLocation.getId());\\n                                }\\n                                                                if (!enemyPlayer.canSee(colony.getTile())) {\\n                                        opponentAttackElement.setAttribute(\\\"update\\\", \\\"tile\\\");\\n                                        enemyPlayer.setExplored(colony.getTile());\\n                                        opponentAttackElement.appendChild(colony.getTile().toXMLElement(\\n                                                        enemyPlayer, opponentAttackElement.getOwnerDocument()));\\n                                }\\n                                                                if (enemyPlayer.canSee(unit.getTile())) { \\n                            opponentAttackElement.setAttribute(\\\"update\\\", \\\"unit\\\");\\n                            opponentAttackElement.appendChild(unit.toXMLElement(enemyPlayer, opponentAttackElement.getOwnerDocument()));\\n                                }\\n                                                                try {\\n                                        enemyPlayer.getConnection().send(opponentAttackElement);\\n                                } catch (IOException e) {\\n                                        logger.warning(\\\"Could not send message to: \\\" + enemyPlayer.getName()\\n                                                        + \\\" with connection \\\" + enemyPlayer.getConnection());\\n                                }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    public java.util.Map<String,Object> getTransactionSession(Unit unit, Settlement settlement){\\n        java.util.Map<String, java.util.Map<String,Object>> unitTransactions = null;\\n        if(transactionSessions.containsKey(unit.getId())){\\n            unitTransactions = transactionSessions.get(unit.getId());\\n            if(unitTransactions.containsKey(settlement.getId())){\\n                return unitTransactions.get(settlement.getId());\\n            }\\n        }\\n                java.util.Map<String,Object> session = new HashMap<String,Object>();\\n                session.put(\\\"canGift\\\", true);\\n        session.put(\\\"canSell\\\", true);\\n        session.put(\\\"canBuy\\\", true);\\n        session.put(\\\"actionTaken\\\", false);\\n        session.put(\\\"hasSpaceLeft\\\", unit.getSpaceLeft() != 0);\\n        session.put(\\\"unitMoves\\\", unit.getMovesLeft());\\n        if(settlement.getOwner().getStance(unit.getOwner()) == Stance.WAR){\\n            session.put(\\\"canSell\\\", false);\\n            session.put(\\\"canBuy\\\", false);\\n        }\\n        else{\\n        \\t            if(unit.getSpaceTaken() == 0){\\n                session.put(\\\"canSell\\\", false);\\n            }\\n        }\\n                if(unit.getOwner().isAI()){\\n            return session;\\n        }\\n                if(unitTransactions == null){\\n            unitTransactions = new HashMap<String,java.util.Map<String, Object>>();\\n            transactionSessions.put(unit.getId(), unitTransactions);\\n        }\\n        unitTransactions.put(settlement.getId(), session);\\n        return session;\\n    }\\n    public void closeTransactionSession(Unit unit, Settlement settlement){\\n        java.util.Map<String, java.util.Map<String,Object>> unitTransactions;\\n                if(unit.getOwner().isAI()){\\n          return;  \\n        }\\n        if(!transactionSessions.containsKey(unit.getId())){\\n            throw new IllegalStateException(\\\"Trying to close a non-existing session\\\");\\n        }\\n        unitTransactions = transactionSessions.get(unit.getId());   \\n        if(!unitTransactions.containsKey(settlement.getId())){\\n            throw new IllegalStateException(\\\"Trying to close a non-existing session\\\");\\n        }\\n        unitTransactions.remove(settlement.getId());\\n        if(unitTransactions.isEmpty()){\\n            transactionSessions.remove(unit.getId());\\n        }\\n    }\\n    public boolean isTransactionSessionOpen(Unit unit, Settlement settlement){\\n                if(unit.getOwner().isAI()){\\n            return true;\\n        }\\n        if(!transactionSessions.containsKey(unit.getId())){\\n            return false;\\n        }\\n        if(settlement != null &&\\n           !transactionSessions.get(unit.getId()).containsKey(settlement.getId())){\\n                return false;\\n        }\\n        return true;\\n    }\\n}\""
            },
            "m7": {
                "content": "The code for **InGameController.java** reveals that it is a core component of the game logic in FreeCol, specifically responsible for handling actions and transitions during gameplay. It coordinates complex operations such as:\n\n- Ending turns and advancing to the next player.\n- Managing AI behavior and interactions with human players.\n- Handling events like taxation changes, declaring war, recruiting units, and managing founding fathers.\n- Controlling combat mechanics (e.g., bombardment of enemy ships).\n- Managing transactions and sessions related to unit and settlement interactions.\n\n### Relationship to `GUI.java`\nSince `GUI.java` likely serves as the main interface or controller for rendering and interacting with the user interface, any change in game state or control logic managed by `InGameController` would require corresponding updates or synchronization in the GUI layer. For example:\n- When a turn ends or a new player begins their turn, the GUI must update accordingly.\n- Events like declaring war, changing tax rates, or combat results likely trigger visual updates or notifications in the UI.\n- Transaction sessions and unit interactions may need to be reflected in UI components.\n\nGiven this tight coupling between `InGameController` and the UI, it's reasonable that these two files are often co-changed.\n\n---\n\n### Next Steps:\nTo continue our CIA, we can explore one of two directions:\n1. **Explore another top co-change entity**, such as **UnitMoveAnimation.java** or **ActionManager.java**, to understand how they relate to both `GUI.java` and `InGameController.java`.\n2. **Analyze dependencies/coupling** between `GUI.java` and `InGameController.java` using functions like `get_coupling_dependencies` or `get_conceptual_coupling`.\n\nLet\u2019s proceed by checking the conceptual coupling (semantic similarity) between `GUI.java` and `InGameController.java` to see if there's a strong semantic relationship.\n\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_94b092c9b96347a5909e70",
                        "function": {
                            "arguments": "{\"entity1\": \"GUI.java\", \"entity2\": \"InGameController.java\"}",
                            "name": "get_conceptual_coupling"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m8": {
                "role": "tool",
                "name": "get_conceptual_coupling",
                "content": "\"0.7902087\""
            },
            "m9": {
                "content": "The **conceptual coupling** (semantic similarity) between `GUI.java` and `InGameController.java` is approximately **0.79**, which indicates a **strong semantic relationship** between the two files.\n\nThis aligns with our earlier analysis: changes in game control logic within `InGameController.java` likely necessitate updates to the user interface managed by `GUI.java`. This could include:\n- Updating UI elements when a player's turn ends.\n- Reflecting combat results or diplomatic changes in the GUI.\n- Triggering visual animations or notifications based on game events.\n\n### Next Steps:\nTo further understand how these two components interact, we can:\n1. Retrieve the code of **GUI.java** to examine its structure and look for direct references or dependencies on `InGameController`.\n2. Use `get_call_graph` or `get_coupling_dependencies` to identify direct method calls or type dependencies between these two entities.\n\nLet\u2019s start by retrieving the origin code of **GUI.java**.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_968ef098cdf34c84978f9f",
                        "function": {
                            "arguments": "{\"entity\": \"GUI.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m10": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package net.sf.freecol.client.gui;\\nimport java.awt.AlphaComposite;\\nimport java.awt.Color;\\nimport java.awt.Composite;\\nimport java.awt.Dimension;\\nimport java.awt.Font;\\nimport java.awt.FontMetrics;\\nimport java.awt.Graphics;\\nimport java.awt.Graphics2D;\\nimport java.awt.Image;\\nimport java.awt.Point;\\nimport java.awt.Polygon;\\nimport java.awt.Rectangle;\\nimport java.awt.event.ActionEvent;\\nimport java.awt.event.ActionListener;\\nimport java.awt.font.TextLayout;\\nimport java.awt.geom.GeneralPath;\\nimport java.awt.geom.Rectangle2D;\\nimport java.awt.image.BufferedImage;\\nimport java.util.ArrayList;\\nimport java.util.Date;\\nimport java.util.Iterator;\\nimport java.util.List;\\nimport java.util.Random;\\nimport java.util.Vector;\\nimport java.util.logging.Logger;\\nimport javax.swing.ImageIcon;\\nimport javax.swing.JComponent;\\nimport javax.swing.JLabel;\\nimport javax.swing.JLayeredPane;\\nimport javax.swing.UIManager;\\nimport net.sf.freecol.FreeCol;\\nimport net.sf.freecol.client.ClientOptions;\\nimport net.sf.freecol.client.FreeColClient;\\nimport net.sf.freecol.client.gui.i18n.Messages;\\nimport net.sf.freecol.client.gui.panel.MapControls;\\nimport net.sf.freecol.common.model.Colony;\\nimport net.sf.freecol.common.model.Europe;\\nimport net.sf.freecol.common.model.Game;\\nimport net.sf.freecol.common.model.IndianSettlement;\\nimport net.sf.freecol.common.model.Map;\\nimport net.sf.freecol.common.model.PathNode;\\nimport net.sf.freecol.common.model.Player;\\nimport net.sf.freecol.common.model.Settlement;\\nimport net.sf.freecol.common.model.Tension;\\nimport net.sf.freecol.common.model.Tile;\\nimport net.sf.freecol.common.model.TileImprovement;\\nimport net.sf.freecol.common.model.TileItemContainer;\\nimport net.sf.freecol.common.model.TileType;\\nimport net.sf.freecol.common.model.Unit;\\nimport net.sf.freecol.common.model.Map.Direction;\\nimport net.sf.freecol.common.model.Map.Position;\\nimport net.sf.freecol.common.model.Unit.UnitState;\\nimport net.sf.freecol.common.resources.ResourceManager;\\npublic final class GUI {\\n    private static final Logger logger = Logger.getLogger(GUI.class.getName());\\n    private final FreeColClient freeColClient;\\n    private Dimension size;\\n    private ImageLibrary lib;\\n    private TerrainCursor cursor;\\n    private ViewMode viewMode;\\n    private boolean inGame;\\n    private final Vector<GUIMessage> messages;\\n    private Map.Position selectedTile;\\n    private Map.Position focus = null;\\n    private Unit activeUnit;\\n    private PathNode currentPath;\\n    private PathNode gotoPath = null;\\n    private boolean gotoStarted = false;\\n        private int tileHeight,\\n    tileWidth,\\n    topSpace,\\n    topRows,\\n        bottomRows,\\n    leftSpace,\\n    rightSpace;\\n        private int bottomRow = -1;\\n        private int topRow;\\n            private int bottomRowY;\\n            private int topRowY;\\n        private int leftColumn;\\n        private int rightColumn;\\n            private int leftColumnX;\\n        public static final int UNIT_OFFSET = 20,\\n    TEXT_OFFSET_X = 2,     TEXT_OFFSET_Y = 13,     STATE_OFFSET_X = 25,\\n    STATE_OFFSET_Y = 10,\\n    ALARM_OFFSET_X = 37,\\n    ALARM_OFFSET_Y = 10,\\n    RUMOUR_OFFSET_X = 40,\\n    RUMOUR_OFFSET_Y = 5,\\n    MISSION_OFFSET_X = 49,\\n    MISSION_OFFSET_Y = 10,\\n    OTHER_UNITS_OFFSET_X = -5,     OTHER_UNITS_OFFSET_Y = 1,\\n    OTHER_UNITS_WIDTH = 3,\\n    MAX_OTHER_UNITS = 10,\\n    MESSAGE_COUNT = 3,\\n    MESSAGE_AGE = 30000; \\n    private boolean displayGrid = false;\\n    private int displayTileText = 0;\\n    private GeneralPath gridPath = null;\\n        public boolean displayCoordinates = false;\\n    public boolean displayColonyValue = false;\\n    public Player displayColonyValuePlayer = null;\\n    public boolean debugShowMission = false;\\n    public boolean debugShowMissionInfo = false;\\n    private volatile boolean blinkingMarqueeEnabled;\\n    private Image cursorImage;\\n    private JLabel coatOfArms;\\n    private JLabel greyLayer;\\n    private JLabel waitingForMsg;\\n    public GUI(FreeColClient freeColClient, Dimension size, ImageLibrary lib) {\\n        this.freeColClient = freeColClient;\\n        this.size = size;\\n        setImageLibrary(lib);\\n        inGame = false;\\n        logger.info(\\\"GUI created.\\\");\\n        messages = new Vector<GUIMessage>(MESSAGE_COUNT);\\n        viewMode = new ViewMode(this);\\n        logger.info(\\\"Starting in Move Units View Mode\\\");\\n        displayGrid = freeColClient.getClientOptions().getBoolean(ClientOptions.DISPLAY_GRID);\\n        displayTileText = freeColClient.getClientOptions().getDisplayTileText();\\n        blinkingMarqueeEnabled = true;\\n        cursor = new net.sf.freecol.client.gui.TerrainCursor();\\n    }\\n    public void setImageLibrary(ImageLibrary lib) {\\n        this.lib = lib;\\n        cursorImage = lib.getMiscImage(ImageLibrary.UNIT_SELECT);\\n        TileType tileType = FreeCol.getSpecification().getTileTypeList().get(0);\\n        tileHeight = lib.getTerrainImageHeight(tileType);\\n        tileWidth = lib.getTerrainImageWidth(tileType);\\n        updateMapDisplayVariables();\\n    }\\n    private void updateMapDisplayVariables() {\\n                topSpace = (size.height - tileHeight) / 2;\\n        if ((topSpace % (tileHeight / 2)) != 0) {\\n            topRows = topSpace / (tileHeight / 2) + 2;\\n        } else {\\n            topRows = topSpace / (tileHeight / 2) + 1;\\n        }\\n        bottomRows = topRows;\\n        leftSpace = (size.width - tileWidth) / 2;\\n        rightSpace = leftSpace;\\n    }\\n    public ViewMode getViewMode(){\\n        return viewMode;\\n    }\\n    public void startCursorBlinking() {\\n        final FreeColClient theFreeColClient = freeColClient; \\n        ActionListener taskPerformer = new ActionListener() {\\n            public void actionPerformed(ActionEvent event) {\\n                if (!blinkingMarqueeEnabled) return;\\n                if (getActiveUnit() != null && getActiveUnit().getTile() != null) {\\n                                        theFreeColClient.getCanvas().refreshTile(getActiveUnit().getTile());            \\n                }               \\n            }\\n        };\\n        cursor.addActionListener(taskPerformer);\\n        cursor.startBlinking();\\n    }\\n    public TerrainCursor getCursor(){\\n        return cursor;\\n    }\\n    public void setSize(Dimension size) {\\n        this.size = size;\\n        updateMapDisplayVariables();\\n    }\\n    public void moveTileCursor(Direction direction){\\n        Tile selectedTile = freeColClient.getGame().getMap().getTile(getSelectedTile());\\n        if(selectedTile != null){   \\n            Tile newTile = freeColClient.getGame().getMap().getNeighbourOrNull(direction, selectedTile);\\n            if(newTile != null)\\n                setSelectedTile(newTile.getPosition());\\n        }\\n        else{\\n            logger.warning(\\\"selectedTile is null\\\");\\n        }\\n    }\\n    public void setSelectedTile(Position selectedTile) {\\n        setSelectedTile(selectedTile, false);\\n    }\\n    public void setSelectedTile(Position selectedTile, boolean clearGoToOrders) {\\n        Game gameData = freeColClient.getGame();\\n        if (selectedTile != null && !gameData.getMap().isValid(selectedTile)) {\\n            return;\\n        }\\n        Position oldPosition = this.selectedTile;\\n        this.selectedTile = selectedTile;\\n        if (viewMode.getView() == ViewMode.MOVE_UNITS_MODE) {\\n            if (activeUnit == null ||\\n                (activeUnit.getTile() != null &&\\n                 !activeUnit.getTile().getPosition().equals(selectedTile))) {\\n                Tile t = gameData.getMap().getTile(selectedTile);\\n                if (t != null && t.getSettlement() != null) {\\n                    Settlement s = t.getSettlement();\\n                    if (s instanceof Colony && s.getOwner().equals(freeColClient.getMyPlayer())) {\\n                                                setFocus(selectedTile);\\n                        freeColClient.getCanvas().showColonyPanel((Colony) s);\\n                        return;\\n                    } else if (s instanceof IndianSettlement) {\\n                                                setFocus(selectedTile);\\n                        freeColClient.getCanvas().showIndianSettlementPanel((IndianSettlement)s);\\n                        return;\\n                    }\\n                }\\n                                Unit unitInFront = getUnitInFront(gameData.getMap().getTile(selectedTile));\\n                if (unitInFront != null) {\\n                    setActiveUnit(unitInFront);\\n                    updateGotoPathForActiveUnit();\\n                } else {\\n                    setFocus(selectedTile);\\n                }\\n            } else if (activeUnit.getTile() != null &&\\n                    activeUnit.getTile().getPosition().equals(selectedTile)) {\\n                                if (clearGoToOrders && activeUnit.getDestination() != null) {\\n                    freeColClient.getInGameController().clearGotoOrders(activeUnit);\\n                    updateGotoPathForActiveUnit();\\n                }\\n            }\\n        }\\n        freeColClient.getActionManager().update();\\n        freeColClient.getCanvas().updateJMenuBar();\\n        int x = 0, y = 0;\\n        MapControls mapControls = freeColClient.getCanvas().getMapControls();\\n        if (mapControls != null) {\\n            x = getWidth() - mapControls.getInfoPanelWidth();\\n            y = getHeight() - mapControls.getInfoPanelHeight();\\n        }\\n        freeColClient.getCanvas().repaint(x, y, getWidth(), getHeight());\\n                if ((!onScreen(selectedTile) &&\\n             freeColClient.getClientOptions().getBoolean(ClientOptions.JUMP_TO_ACTIVE_UNIT)) ||\\n            freeColClient.getClientOptions().getBoolean(ClientOptions.ALWAYS_CENTER)) {\\n                setFocus(selectedTile);\\n        } else {\\n            if (oldPosition != null) {\\n                freeColClient.getCanvas().refreshTile(oldPosition);\\n            }\\n            if (selectedTile != null) {\\n                freeColClient.getCanvas().refreshTile(selectedTile);\\n            }\\n        }\\n    }\\n    public void showColonyPanel(Position selectedTile) {\\n        Game gameData = freeColClient.getGame();\\n        if (selectedTile != null && !gameData.getMap().isValid(selectedTile)) {\\n            return;\\n        }\\n        if (viewMode.getView() == ViewMode.MOVE_UNITS_MODE) {\\n            Tile t = gameData.getMap().getTile(selectedTile);\\n            if (t != null && t.getSettlement() != null && t.getSettlement() instanceof Colony\\n                && t.getSettlement().getOwner().equals(freeColClient.getMyPlayer())) {\\n                setFocus(selectedTile);\\n                stopBlinking();\\n                freeColClient.getCanvas().showColonyPanel((Colony) t.getSettlement());\\n                return;\\n            }\\n        }\\n    }\\n    public void restartBlinking() {\\n        blinkingMarqueeEnabled = true;\\n    }\\n    public void stopBlinking() {\\n        blinkingMarqueeEnabled = false;\\n    }\\n    public Unit getUnitInFront(Tile unitTile) {\\n        if (unitTile == null || unitTile.getUnitCount() <= 0) {\\n            return null;\\n        }\\n        if (activeUnit != null && activeUnit.getTile() == unitTile) {\\n            return activeUnit;\\n        } else {\\n            if (unitTile.getSettlement() == null) {\\n                Unit bestDefendingUnit = null;\\n                if (activeUnit != null) {\\n                    bestDefendingUnit = unitTile.getDefendingUnit(activeUnit);\\n                    if (bestDefendingUnit != null) {\\n                        return bestDefendingUnit;\\n                    }\\n                }\\n                Unit movableUnit = unitTile.getMovableUnit();\\n                if (movableUnit != null && movableUnit.getLocation() == movableUnit.getTile()) {\\n                    return movableUnit;\\n                } else {\\n                    Unit bestPick = null;\\n                    Iterator<Unit> unitIterator = unitTile.getUnitIterator();\\n                    while (unitIterator.hasNext()) {\\n                        Unit u = unitIterator.next();\\n                        if (bestPick == null || bestPick.getMovesLeft() < u.getMovesLeft()) {\\n                            bestPick = u;\\n                        }\\n                    }\\n                    return bestPick;\\n                }\\n            } else {\\n                return null;\\n            }\\n        }\\n    }\\n    public Position getSelectedTile() {\\n        return selectedTile;\\n    }\\n    public Unit getActiveUnit() {\\n        return activeUnit;\\n    }\\n    public void setActiveUnit(Unit activeUnit) {\\n        if (activeUnit != null && activeUnit.getOwner() != freeColClient.getMyPlayer()) {\\n            freeColClient.getCanvas().repaint(0, 0, getWidth(), getHeight());\\n            return;\\n        }\\n        if (activeUnit != null && activeUnit.getTile() == null) {\\n            activeUnit = null;\\n        }\\n        this.activeUnit = activeUnit;\\n        if (activeUnit != null) {\\n            if (freeColClient.getGame().getCurrentPlayer() == freeColClient.getMyPlayer()) {\\n                if (activeUnit.getState() != UnitState.ACTIVE) {\\n                    freeColClient.getInGameController().clearOrders(activeUnit);\\n                }\\n            } else {\\n                freeColClient.getInGameController().clearGotoOrders(activeUnit);\\n            }\\n        }\\n        updateGotoPathForActiveUnit();\\n                if(viewMode.getView() == ViewMode.VIEW_TERRAIN_MODE && activeUnit != null)\\n            viewMode.changeViewMode(ViewMode.MOVE_UNITS_MODE);\\n                if (activeUnit != null) {\\n            setSelectedTile(activeUnit.getTile().getPosition());\\n        } else {\\n            freeColClient.getActionManager().update();\\n            freeColClient.getCanvas().updateJMenuBar();\\n            int x = 0, y = 0;\\n            MapControls mapControls = freeColClient.getCanvas().getMapControls();\\n            if (mapControls != null) {\\n                x = getWidth() - mapControls.getInfoPanelWidth();\\n                y = getHeight() - mapControls.getInfoPanelHeight();\\n            }\\n            freeColClient.getCanvas().repaint(x, y, getWidth(), getHeight());\\n        }\\n    }\\n    public Position getFocus() {\\n        return focus;\\n    }\\n    public void setFocus(Position focus) {\\n        this.focus = focus;\\n        forceReposition();\\n        freeColClient.getCanvas().repaint(0, 0, getWidth(), getHeight());\\n    }\\n    public void setFocusImmediately(Position focus) {\\n        this.focus = focus;\\n        forceReposition();\\n        freeColClient.getCanvas().paintImmediately(0, 0, getWidth(), getHeight());\\n    }\\n    public void setFocus(int x, int y) {\\n        setFocus(new Map.Position(x,y));\\n    }\\n    public int getMessageCount() {\\n        return messages.size();\\n    }\\n    public GUIMessage getMessage(int index) {\\n        return messages.get(index);\\n    }\\n    public synchronized void addMessage(GUIMessage message) {\\n        if (getMessageCount() == MESSAGE_COUNT) {\\n            messages.remove(0);\\n        }\\n        messages.add(message);\\n        freeColClient.getCanvas().repaint(0, 0, getWidth(), getHeight());\\n    }\\n    public synchronized boolean removeOldMessages() {\\n        long currentTime = new Date().getTime();\\n        boolean result = false;\\n        int i = 0;\\n        while (i < getMessageCount()) {\\n            long messageCreationTime = getMessage(i).getCreationTime().getTime();\\n            if ((currentTime - messageCreationTime) >= MESSAGE_AGE) {\\n                result = true;\\n                messages.remove(i);\\n            } else {\\n                i++;\\n            }\\n        }\\n        return result;\\n    }\\n    public int getWidth() {\\n        return size.width;\\n    }\\n    public int getHeight() {\\n        return size.height;\\n    }\\n    public void display(Graphics2D g) {\\n        if ((freeColClient.getGame() != null)\\n                && (freeColClient.getGame().getMap() != null)\\n                && (focus != null)\\n                && inGame) {\\n            removeOldMessages();\\n            displayMap(g);\\n        } else {\\n            if (freeColClient.isMapEditor()) {\\n                g.setColor(Color.black);\\n                g.fillRect(0, 0, size.width, size.height);                \\n            } else {\\n                Image bgImage = ResourceManager.getImage(\\\"CanvasBackgroundImage\\\", size);\\n                if (bgImage != null) {\\n                    g.drawImage(bgImage, 0, 0, freeColClient.getCanvas());\\n                                        String versionStr = \\\"v. \\\" + FreeCol.getVersion();\\n                    Font oldFont = g.getFont();\\n                    Color oldColor = g.getColor();\\n                    Font newFont = oldFont.deriveFont(Font.BOLD);\\n                    TextLayout layout = new TextLayout(versionStr, newFont, g.getFontRenderContext());\\n                    Rectangle2D bounds = layout.getBounds();\\n                    float x = getWidth() - (float) bounds.getWidth() - 5;\\n                    float y = getHeight() - (float) bounds.getHeight();\\n                    g.setColor(Color.white);\\n                    layout.draw(g, x, y);\\n                                        g.setFont(oldFont);\\n                    g.setColor(oldColor);\\n                } else {\\n                    g.setColor(Color.black);\\n                    g.fillRect(0, 0, size.width, size.height);\\n                }\\n            }\\n        }\\n    }\\n    private int getLeftColumns() {\\n        return getLeftColumns(focus.getY());\\n    }\\n    private int getLeftColumns(int y) {\\n        int leftColumns;\\n        if ((y % 2) == 0) {\\n            leftColumns = leftSpace / tileWidth + 1;\\n            if ((leftSpace % tileWidth) > 32) {\\n                leftColumns++;\\n            }\\n        } else {\\n            leftColumns = leftSpace / tileWidth + 1;\\n            if ((leftSpace % tileWidth) == 0) {\\n                leftColumns--;\\n            }\\n        }\\n        return leftColumns;\\n    }\\n    private int getRightColumns() {\\n        return getRightColumns(focus.getY());\\n    }\\n    private int getRightColumns(int y) {\\n        int rightColumns;\\n        if ((y % 2) == 0) {\\n            rightColumns = rightSpace / tileWidth + 1;\\n            if ((rightSpace % tileWidth) == 0) {\\n                rightColumns--;\\n            }\\n        } else {\\n            rightColumns = rightSpace / tileWidth + 1;\\n            if ((rightSpace % tileWidth) > 32) {\\n                rightColumns++;\\n            }\\n        }\\n        return rightColumns;\\n    }\\n    private void positionMap() {\\n        Game gameData = freeColClient.getGame();\\n        if (focus == null) {\\n            return;\\n        }\\n        int x = focus.getX(),\\n            y = focus.getY();\\n        int leftColumns = getLeftColumns(),\\n            rightColumns = getRightColumns();\\n        if (y < topRows) {\\n                        bottomRow = (size.height / (tileHeight / 2)) - 1;\\n            if ((size.height % (tileHeight / 2)) != 0) {\\n                bottomRow++;\\n            }\\n            topRow = 0;\\n            bottomRowY = bottomRow * (tileHeight / 2);\\n            topRowY = 0;\\n        } else if (y >= (gameData.getMap().getHeight() - bottomRows)) {\\n                        bottomRow = gameData.getMap().getHeight() - 1;\\n            topRow = size.height / (tileHeight / 2);\\n            if ((size.height % (tileHeight / 2)) > 0) {\\n                topRow++;\\n            }\\n            topRow = gameData.getMap().getHeight() - topRow;\\n            bottomRowY = size.height - tileHeight;\\n            topRowY = bottomRowY - (bottomRow - topRow) * (tileHeight / 2);\\n        } else {\\n                        bottomRow = y + bottomRows;\\n            topRow = y - topRows;\\n            bottomRowY = topSpace + (tileHeight / 2) * bottomRows;\\n            topRowY = topSpace - topRows * (tileHeight / 2);\\n        }\\n        if (x < leftColumns) {\\n                        leftColumn = 0;\\n            rightColumn = size.width / tileWidth - 1;\\n            if ((size.width % tileWidth) > 0) {\\n                rightColumn++;\\n            }\\n            leftColumnX = 0;\\n        } else if (x >= (gameData.getMap().getWidth() - rightColumns)) {\\n                        rightColumn = gameData.getMap().getWidth() - 1;\\n            leftColumn = size.width / tileWidth;\\n            if ((size.width % tileWidth) > 0) {\\n                leftColumn++;\\n            }\\n            leftColumnX = size.width - tileWidth - tileWidth / 2 -\\n                leftColumn * tileWidth;\\n            leftColumn = rightColumn - leftColumn;\\n        } else {\\n                        leftColumn = x - leftColumns;\\n            rightColumn = x + rightColumns;\\n            leftColumnX = (size.width - tileWidth) / 2 - leftColumns * tileWidth;\\n        }\\n    }\\n    private void displayGotoPath(Graphics2D g, PathNode gotoPath) {\\n        if (gotoPath != null) {\\n            PathNode temp = gotoPath;\\n            while (temp != null) {\\n                Point p = getTilePosition(temp.getTile());\\n                if (p != null) {\\n                    Tile tile = temp.getTile();\\n                    Image image;\\n                    final Color textColor; \\n                    if (temp.getTurns() == 0) {\\n                        g.setColor(Color.GREEN);                        \\n                        image = getPathImage(activeUnit);\\n                        if (activeUnit != null \\n                                && tile.isExplored()\\n                                && activeUnit.isNaval()\\n                                && tile.isLand() \\n                                && (tile.getColony() == null || tile.getColony().getOwner() != activeUnit.getOwner())) {\\n                            image = getPathImage(activeUnit.getFirstUnit());\\n                        }\\n                        textColor = Color.BLACK;\\n                    } else {\\n                        g.setColor(Color.RED);\\n                        image = getPathNextTurnImage(activeUnit);\\n                        if (activeUnit != null\\n                                && tile.isExplored()\\n                                && activeUnit.isNaval()\\n                                && tile.isLand() \\n                                && (tile.getColony() == null || tile.getColony().getOwner() != activeUnit.getOwner())) {\\n                            image = getPathNextTurnImage(activeUnit.getFirstUnit());\\n                        }\\n                        textColor = Color.WHITE;\\n                    }                \\n                    if (image != null) {\\n                        g.drawImage(image, p.x + (tileWidth - image.getWidth(null))/2, p.y + (tileHeight - image.getHeight(null))/2, null);\\n                    } else {\\n                        g.fillOval(p.x + tileWidth/2, p.y + tileHeight/2, 10, 10);\\n                        g.setColor(Color.BLACK);\\n                        g.drawOval(p.x + tileWidth/2, p.y + tileHeight/2, 10, 10);\\n                    }                \\n                    if (temp.getTurns() > 0) {\\n                        BufferedImage stringImage = createStringImage(g, Integer.toString(temp.getTurns()), textColor, tileWidth, 12);\\n                        g.drawImage(stringImage, p.x + (tileWidth - stringImage.getWidth(null))/2, p.y + (tileHeight - stringImage.getHeight()) / 2, null);\\n                    }\\n                }                    \\n                temp = temp.next;\\n            }\\n        }\\n    }\\n    private int getXOffset(int clipLeftX, int tileY) {\\n        int xx = clipLeftX;\\n        if ((tileY % 2) != 0) {\\n            xx += tileWidth / 2;\\n        }\\n        return xx;\\n    }\\n    private void displayMap(Graphics2D g) {\\n        Rectangle clipBounds = g.getClipBounds();\\n        Map map = freeColClient.getGame().getMap();\\n        if (bottomRow < 0) {\\n            positionMap();\\n        }\\n        int clipTopRow = (clipBounds.y - topRowY) / (tileHeight / 2) - 1;\\n        int clipTopY = topRowY + clipTopRow * (tileHeight / 2);\\n        clipTopRow = topRow + clipTopRow;\\n        int clipLeftCol = (clipBounds.x - leftColumnX) / tileWidth - 1;\\n        int clipLeftX = leftColumnX + clipLeftCol * tileWidth;\\n        clipLeftCol = leftColumn + clipLeftCol;\\n        int clipBottomRow = (clipBounds.y + clipBounds.height - topRowY) / (tileHeight / 2);\\n        clipBottomRow = topRow + clipBottomRow;\\n        int clipRightCol = (clipBounds.x + clipBounds.width - leftColumnX) / tileWidth;\\n        clipRightCol = leftColumn + clipRightCol;\\n        if (displayGrid) {\\n            gridPath = new GeneralPath();\\n            gridPath.moveTo(0, 0);\\n            int nextX = tileWidth / 2;\\n            int nextY = - (tileHeight / 2);\\n            for (int i = 0; i <= ((clipRightCol - clipLeftCol) * 2 + 1); i++) {\\n                gridPath.lineTo(nextX, nextY);\\n                nextX += tileWidth / 2;\\n                if (nextY == - (tileHeight / 2)) {\\n                    nextY = 0;\\n                }\\n                else {\\n                    nextY = - (tileHeight / 2);\\n                }\\n            }\\n        }\\n        g.setColor(Color.black);\\n        g.fillRect(clipBounds.x, clipBounds.y, clipBounds.width, clipBounds.height);\\n        int xx;\\n        int yy = clipTopY;\\n                for (int tileY = clipTopRow; tileY <= clipBottomRow; tileY++) {\\n            xx = getXOffset(clipLeftX, tileY);\\n                        for (int tileX = clipLeftCol; tileX <= clipRightCol; tileX++) {\\n                displayBaseTile(g, map, map.getTile(tileX, tileY), xx, yy, true);\\n                xx += tileWidth;\\n            }\\n            yy += tileHeight / 2;\\n        }\\n        List<Unit> darkUnits = new ArrayList<Unit>();\\n        List<Integer> darkUnitsX = new ArrayList<Integer>();\\n        List<Integer> darkUnitsY = new ArrayList<Integer>();\\n        yy = clipTopY;\\n                for (int tileY = clipTopRow; tileY <= clipBottomRow; tileY++) {\\n            xx = getXOffset(clipLeftX, tileY);\\n            if (displayGrid) {\\n                                g.translate(xx, yy + (tileHeight / 2));\\n                g.setColor(Color.BLACK);\\n                g.draw(gridPath);\\n                g.translate(- xx, - (yy + (tileHeight / 2)));\\n            }\\n                        for (int tileX = clipLeftCol; tileX <= clipRightCol; tileX++) {\\n                Tile tile = map.getTile(tileX, tileY);\\n                                displayTileOverlays(g, map, tile, xx, yy, true, true);\\n                if (viewMode.displayTileCursor(tile,xx,yy)) {\\n                    drawCursor(g, xx, yy);\\n                }\\n                xx += tileWidth;\\n            }\\n            xx = getXOffset(clipLeftX, tileY);\\n                        for (int tileX = clipLeftCol; tileX <= clipRightCol; tileX++) {\\n                Unit unitInFront = getUnitInFront(map.getTile(tileX, tileY));\\n                if (unitInFront != null) {\\n                    displayUnit(g, unitInFront, xx, yy);\\n                    if (unitInFront.isUndead()) {\\n                        darkUnits.add(unitInFront);\\n                        darkUnitsX.add(xx);\\n                        darkUnitsY.add(yy);\\n                    }\\n                }\\n                xx += tileWidth;\\n            }\\n            yy += tileHeight / 2;\\n        }\\n        if (darkUnits.size() > 0) {\\n            g.setColor(Color.BLACK);\\n            final Image im = getImageLibrary().getMiscImage(ImageLibrary.DARKNESS);\\n            for (int index=0; index<darkUnits.size(); index++) {\\n                final Unit u = darkUnits.get(index);\\n                final int x = darkUnitsX.get(index);\\n                final int y = darkUnitsY.get(index);            \\n                g.drawImage(im, x  + tileWidth/2 - im.getWidth(null)/2, y + tileHeight/2 - im.getHeight(null)/2, null);\\n                displayUnit(g, u, x, y);\\n            }\\n        }\\n                yy = clipTopY;\\n                for (int tileY = clipTopRow; tileY <= clipBottomRow; tileY++) {\\n            xx = getXOffset(clipLeftX, tileY);\\n                        for (int tileX = clipLeftCol; tileX <= clipRightCol; tileX++) {\\n                Tile tile = map.getTile(tileX, tileY);\\n                if (tile != null && tile.getSettlement() instanceof Colony) {\\n                    Colony colony = (Colony) tile.getSettlement();\\n                    BufferedImage stringImage =\\n                        createColonyNameImage(g, colony,\\n                                              lib.getTerrainImageWidth(tile.getType()) * 4/3, 16);\\n                    g.drawImage(stringImage, \\n                                xx + (lib.getTerrainImageWidth(tile.getType()) - \\n                                      stringImage.getWidth())/2 + 1,\\n                                yy + (lib.getSettlementImage(colony).getHeight(null) + 1), null);\\n                }\\n                xx += tileWidth;\\n            }\\n            yy += tileHeight / 2;\\n        }\\n        displayGotoPath(g, currentPath);\\n        displayGotoPath(g, gotoPath);\\n        Canvas canvas = freeColClient.getCanvas();\\n                if (coatOfArms != null) {\\n            canvas.remove(coatOfArms, false);\\n            coatOfArms = null;\\n        }\\n        if (waitingForMsg != null) {\\n            canvas.remove(waitingForMsg, false);\\n            waitingForMsg = null;\\n        }\\n        if (!freeColClient.isMapEditor()\\n                && freeColClient.getGame() != null\\n                && freeColClient.getMyPlayer() != freeColClient.getGame().getCurrentPlayer()) {\\n            if (greyLayer == null) {\\n                greyLayer = buildGreyLayer();\\n            } else if (!greyLayer.getSize().equals(size)) {\\n                canvas.remove(greyLayer, false);\\n                greyLayer = buildGreyLayer();\\n            }\\n            if (greyLayer.getParent() == null) {                 canvas.add(greyLayer, JLayeredPane.DEFAULT_LAYER, false);\\n                canvas.moveToFront(greyLayer);\\n            }\\n            final Color currentPlayerColor = freeColClient.getGame().getCurrentPlayer().getColor();\\n            final String nation = freeColClient.getGame().getCurrentPlayer().getNationAsString();\\n            Image im = createStringImage(g, \\n                    Messages.message(\\\"waitingFor\\\", \\\"%nation%\\\", nation),\\n                    currentPlayerColor,\\n                    640,\\n                    18);\\n            final ImageIcon coatOfArmsIcon = lib.getCoatOfArmsImageIcon(freeColClient.getGame().getCurrentPlayer().getNation());\\n            final int cHeight = (coatOfArmsIcon != null) ? coatOfArmsIcon.getIconHeight() : 0;\\n            final int cWidth = (coatOfArmsIcon != null) ? coatOfArmsIcon.getIconWidth() : 0;\\n            waitingForMsg = new JLabel(new ImageIcon(im));\\n            waitingForMsg.setBounds((size.width - im.getWidth(null)) / 2, (size.height - im.getHeight(null) - cHeight) / 2, im.getWidth(null), im.getHeight(null));\\n            canvas.add(waitingForMsg, JLayeredPane.DEFAULT_LAYER, false);\\n            canvas.moveToFront(waitingForMsg);\\n            if (coatOfArmsIcon != null) {\\n                coatOfArms = new JLabel(coatOfArmsIcon);\\n                coatOfArms.setBounds((size.width - cWidth) / 2, (size.height - cHeight) / 2 + im.getHeight(null), cWidth, cHeight);\\n                canvas.add(coatOfArms, JLayeredPane.DEFAULT_LAYER, false);\\n                canvas.moveToFront(coatOfArms);\\n            }\\n        }\\n        else {\\n            if (greyLayer != null && greyLayer.getParent() != null) {\\n                canvas.remove(greyLayer, false);\\n            }\\n        }\\n                synchronized (this) {\\n            BufferedImage si = createStringImage(g, \\\"getSizes\\\", Color.WHITE, size.width, 12);\\n            yy = size.height - 300 - getMessageCount() * si.getHeight();            xx = 40;\\n            for (int i = 0; i < getMessageCount(); i++) {\\n                GUIMessage message = getMessage(i);\\n                g.drawImage(createStringImage(g, message.getMessage(), message.getColor(), size.width, 12), xx, yy, null);\\n                yy += si.getHeight();\\n            }\\n        }\\n    }\\n    private JLabel buildGreyLayer() {\\n        BufferedImage greyLayerImg = new BufferedImage(size.width, size.height, BufferedImage.TYPE_INT_ARGB);\\n        Graphics2D greyG = greyLayerImg.createGraphics();\\n        greyG.setColor(Color.BLACK);\\n        Composite oldComposite = greyG.getComposite();\\n        greyG.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.6f));\\n        greyG.fill(new Rectangle(0, 0, size.width, size.height));\\n        greyG.setComposite(oldComposite);\\n        JLabel toReturn = new JLabel(new ImageIcon(greyLayerImg));\\n        toReturn.setBounds(0, 0, size.width, size.height);\\n        return toReturn;\\n    }\\n    private Image getPathImage(Unit u) {\\n        if (u == null) {\\n            return null;\\n        } else {\\n            return ResourceManager.getImage(\\\"path.\\\" + u.getPathTypeImage() + \\\".image\\\");\\n        }\\n    }\\n    private Image getPathNextTurnImage(Unit u) {\\n        if (u == null) {\\n            return null;\\n        } else {\\n            return ResourceManager.getImage(\\\"path.\\\" + u.getPathTypeImage() + \\\".nextTurn.image\\\");\\n        }\\n    }\\n    public BufferedImage createStringImage(Graphics2D g, String nameString, Color color, int maxWidth, int preferredFontSize) {\\n        return createStringImage(null, g, nameString, color, maxWidth, preferredFontSize);\\n    }\\n    public BufferedImage createStringImage(JComponent c, String nameString, Color color, int maxWidth, int preferredFontSize) {\\n        return createStringImage(c, null, nameString, color, maxWidth, preferredFontSize);\\n    }    \\n    private BufferedImage createStringImage(JComponent c, Graphics g, String nameString, Color color, int maxWidth, int preferredFontSize) {        \\n        if (color == null) {\\n            logger.warning(\\\"createStringImage called with color null\\\");\\n            color = Color.WHITE;\\n        }\\n        Font nameFont = (c != null) ? c.getFont() : g.getFont();\\n        FontMetrics nameFontMetrics = (c != null) ? c.getFontMetrics(nameFont) : g.getFontMetrics(nameFont);\\n        BufferedImage bi = null;\\n        int fontSize = preferredFontSize;\\n        do {\\n            nameFont = nameFont.deriveFont(Font.BOLD, fontSize);            \\n            nameFontMetrics = (c != null) ? c.getFontMetrics(nameFont) : g.getFontMetrics(nameFont);\\n            bi = new BufferedImage(nameFontMetrics.stringWidth(nameString) + 4, nameFontMetrics.getMaxAscent() + nameFontMetrics.getMaxDescent(), BufferedImage.TYPE_INT_ARGB);\\n            fontSize -= 2;\\n        } while (bi.getWidth() > maxWidth);\\n        Graphics2D big = bi.createGraphics();\\n        big.setColor(color);\\n        big.setFont(nameFont);\\n        big.drawString(nameString, 2, nameFontMetrics.getMaxAscent());\\n        int playerColor = color.getRGB();\\n        for (int biX=0; biX<bi.getWidth(); biX++) {\\n            for (int biY=0; biY<bi.getHeight(); biY++) {\\n                int r = bi.getRGB(biX, biY);\\n                if (r == playerColor) {\\n                    continue;\\n                }\\n                for (int cX=-1; cX <=1; cX++) {\\n                    for (int cY=-1; cY <=1; cY++) {\\n                        if (biX+cX >= 0 && biY+cY >= 0 && biX+cX < bi.getWidth() && biY+cY < bi.getHeight() && bi.getRGB(biX + cX, biY + cY) == playerColor) {\\n                            bi.setRGB(biX, biY, getStringBorderColor(color).getRGB());\\n                            continue;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return bi;\\n    }\\n    private BufferedImage createColonyNameImage(Graphics g, Colony colony,\\n                                                int maxWidth, int preferredFontSize) {        \\n        return createStringImage((Graphics2D) g,\\n                colony.getName(),\\n                colony.getOwner().getColor(),\\n                maxWidth,\\n                preferredFontSize);\\n    }\\n    public void drawRoad(Graphics2D g, long seed, int x1, int y1, int x2, int y2) {\\n        final int MAX_CORR = 4;\\n        Color oldColor = g.getColor();\\n        Random roadRandom = new Random(seed);\\n        int i = Math.max(Math.abs(x2-x1), Math.abs(y2-y1));\\n        int baseX = x1;\\n        int baseY = y1;\\n        double addX = (x2-x1)/((double) i);\\n        double addY = (y2-y1)/((double) i);\\n        int corr = 0;\\n        int xCorr = 0;\\n        int yCorr = 0;\\n        int lastDiff = 1;\\n        g.setColor(new Color(128, 64, 0));\\n        g.drawLine(baseX, baseY, baseX, baseY);\\n        for (int j=1; j<=i; j++) {\\n            int oldCorr = corr;\\n                            corr = corr + roadRandom.nextInt(3)-1;\\n                if (oldCorr != corr) {\\n                    lastDiff = oldCorr - corr;\\n                }\\n            if (Math.abs(corr) > MAX_CORR || Math.abs(corr) >= i-j) {\\n                if (corr > 0) {\\n                    corr--;\\n                } else {\\n                    corr++;\\n                }\\n            }\\n            if (corr != oldCorr) {\\n                g.setColor(new Color(128, 128, 0));\\n                g.drawLine(baseX+(int) (j*addX)+xCorr, baseY+(int) (j*addY)+yCorr, baseX+(int) (j*addX)+xCorr, baseY+(int) (j*addY)+yCorr);\\n            } else {\\n                int oldXCorr = 0;\\n                int oldYCorr = 0;\\n                if (x2-x1 == 0) {\\n                    oldXCorr = corr+lastDiff;\\n                    oldYCorr = 0;\\n                } else if (y2-y1 == 0) {\\n                    oldXCorr = 0;\\n                    oldYCorr = corr+lastDiff;\\n                } else {\\n                    if (corr > 0) {\\n                        oldXCorr = corr+lastDiff;\\n                    } else {\\n                        oldYCorr = corr+lastDiff;\\n                    }\\n                }\\n                g.setColor(new Color(128, 128, 0));\\n                g.drawLine(baseX+(int) (j*addX)+oldXCorr, baseY+(int) (j*addY)+oldYCorr, baseX+(int) (j*addX)+oldXCorr, baseY+(int) (j*addY)+oldYCorr);\\n            }\\n            if (x2-x1 == 0) {\\n                xCorr = corr;\\n                yCorr = 0;\\n            } else if (y2-y1 == 0) {\\n                xCorr = 0;\\n                yCorr = corr;\\n            } else {\\n                if (corr > 0) {\\n                    xCorr = corr;\\n                } else {\\n                    yCorr = corr;\\n                }\\n            }\\n            g.setColor(new Color(128, 64, 0));\\n            g.drawLine(baseX+(int) (j*addX)+xCorr, baseY+(int) (j*addY)+yCorr, baseX+(int) (j*addX)+xCorr, baseY+(int) (j*addY)+yCorr);\\n        }\\n        g.setColor(oldColor);\\n    }\\n    public void displayColonyTile(Graphics2D g, Map map, Tile tile, int x, int y, Colony colony) {\\n        displayBaseTile(g, map, tile, x, y, false);        \\n        Unit occupyingUnit = colony.getColonyTile(tile).getOccupyingUnit();\\n        Settlement settlement = tile.getOwningSettlement();\\n        int price = colony.getOwner().getLandPrice(tile);\\n        if ((settlement != null &&\\n             (settlement instanceof Colony && settlement != colony) ||\\n             (settlement instanceof IndianSettlement && price > 0)) ||\\n            occupyingUnit != null) {\\n                        g.drawImage(lib.getMiscImage(ImageLibrary.TILE_TAKEN), x, y, null);\\n        }\\n        displayTileOverlays(g, map, tile, x, y, false, false);\\n        if (price > 0 && tile.getSettlement() == null) {\\n                        Image image = lib.getMiscImage(ImageLibrary.TILE_OWNED_BY_INDIANS);\\n            g.drawImage(image, x+tileWidth/2-image.getWidth(null)/2, y+tileHeight/2-image.getHeight(null)/2, null);\\n        }\\n        if (occupyingUnit != null) {\\n            ImageIcon image = lib.getScaledImageIcon(lib.getUnitImageIcon(occupyingUnit), 0.5f);\\n            g.drawImage(image.getImage(), (x + tileWidth / 4) - image.getIconWidth() / 2,\\n                    (y + tileHeight / 2) - image.getIconHeight() / 2, null);\\n                        displayOccupationIndicator(g, occupyingUnit, x + (int) (STATE_OFFSET_X * lib.getScalingFactor()), y);\\n        }\\n    }\\n    public void displayTerrain(Graphics2D g, Map map, Tile tile, int x, int y) {\\n        displayBaseTile(g, map, tile, x, y, true);\\n        displayAdditionsAndImprovements(g, map, tile, x, y);\\n            }\\n    public void displayTile(Graphics2D g, Map map, Tile tile, int x, int y) {\\n        displayTile(g, map, tile, x, y, true);\\n    }\\n    public void displayTile(Graphics2D g, Map map, Tile tile, int x, int y, boolean drawUnexploredBorders) {\\n        displayBaseTile(g, map, tile, x, y, drawUnexploredBorders);\\n        displayTileOverlays(g, map, tile, x, y, drawUnexploredBorders, true);\\n    }\\n    private void displayBaseTile(Graphics2D g, Map map, Tile tile, int x, int y, boolean drawUnexploredBorders) {\\n        if (tile == null) {\\n            return;\\n        }\\n        g.drawImage(lib.getTerrainImage(tile.getType(), tile.getX(), tile.getY()), x, y, null);\\n        Map.Position pos = new Map.Position(tile.getX(), tile.getY());\\n        for (Direction direction : Direction.values()) {\\n            Map.Position p = Map.getAdjacent(pos, direction);\\n            if (map.isValid(p)) {\\n                Tile borderingTile = map.getTile(p.x, p.y);\\n                if (borderingTile == null) {\\n                                        logger.warning(\\\"Bordering Tile was null.\\\");\\n                    continue;\\n                }\\n                if (!drawUnexploredBorders && !borderingTile.isExplored() &&\\n                    (direction == Direction.SE || direction == Direction.S ||\\n                     direction == Direction.SW)) {\\n                    continue;\\n                }\\n                if (tile.getType() == borderingTile.getType()) {\\n                                        continue;\\n                }\\n                else if (tile.isLand() && !borderingTile.isLand()) {\\n                                        continue;\\n                }\\n                else if (!tile.isLand() && borderingTile.isLand() && borderingTile.isExplored()) {\\n                                        if (borderingTile.getType().getArtCoast() != null) {\\n                        g.drawImage(lib.getCoastImage(borderingTile.getType(), direction,\\n                                                        tile.getX(), tile.getY()),\\n                                                        x, y, null);\\n                    }\\n                                        g.drawImage(lib.getBorderImage(borderingTile.getType(), direction,\\n                                                    tile.getX(), tile.getY()),\\n                                                    x, y, null);\\n                } else if (tile.isExplored() && borderingTile.isExplored()) {\\n                    if (tile.getType().getArtBasic().equals(borderingTile.getType().getArtBasic())) {\\n                                                continue;\\n                    }\\n                    else if (borderingTile.getType().getIndex() < tile.getType().getIndex()) {\\n                                                g.drawImage(lib.getBorderImage(borderingTile.getType(), direction,\\n                                                        tile.getX(), tile.getY()),\\n                                                        x, y, null);\\n                    }\\n                }\\n            }\\n        }\\n    }    \\n    private void displayTileOverlays(Graphics2D g, Map map, Tile tile, int x, int y,\\n                                     boolean drawUnexploredBorders, boolean withNumber) {\\n        if (tile != null) {\\n            if (drawUnexploredBorders) {\\n                displayUnexploredBorders(g, map, tile, x, y);\\n            }\\n            displayAdditionsAndImprovements(g, map, tile, x, y);\\n            displaySettlement(g, map, tile, x, y, withNumber);\\n            displayFogOfWar(g, map, tile, x, y);\\n            displayOptionalValues(g, map, tile, x, y);\\n        }\\n    }\\n    private void displayAdditionsAndImprovements(Graphics2D g, Map map, Tile tile, int x, int y) {  \\n        Map.Position pos = new Map.Position(tile.getX(), tile.getY());\\n        if (!tile.isExplored()) {\\n            g.drawImage(lib.getTerrainImage(null, tile.getX(), tile.getY()), x, y, null);\\n        } else {\\n                        if (tile.getType().getArtOverlay() != null) {\\n                g.drawImage(lib.getOverlayImage(tile.getType(), tile.getX(), tile.getY()), x, y - (int) (32 * lib.getScalingFactor()), null);\\n            }\\n            TileItemContainer tic = tile.getTileItemContainer();\\n            if (tic == null) {\\n                if(tile.isForested()) {\\n                    g.drawImage(lib.getForestImage(tile.getType()), x, y, null);\\n                }\\n            } else {\\n                List<TileImprovement> tiList = tile.getCompletedTileImprovements();\\n                List<TileImprovement> tiList2 = new ArrayList<TileImprovement>();\\n                                                for (TileImprovement ti : tiList) {\\n                    if (ti == tic.getRiver() || ti == tic.getRoad())\\n                        continue;\\n                    if (!ti.getType().isArtOverTrees()) {\\n                        tiList2.add(ti);\\n                    } else if (ti.getType().getArtOverlay() != null) {\\n                                                g.drawImage(ResourceManager.getImage(ti.getType().getArtOverlay()), x, y, null);\\n                    }\\n                }\\n                                if (tic.hasRiver() && tic.getRiver().getMagnitude() < TileImprovement.FJORD_RIVER) {\\n                    g.drawImage(lib.getRiverImage(tic.getRiverStyle()), x, y, null);\\n                }\\n                if (tile.isForested()) {\\n                    g.drawImage(lib.getForestImage(tile.getType()), x, y, null);\\n                }\\n                for (TileImprovement ti : tiList2) {\\n                    if (ti == tic.getRiver() || ti == tic.getRoad())\\n                        continue;\\n                    if (ti.getType().getArtOverlay() != null) {\\n                                                g.drawImage(ResourceManager.getImage(ti.getType().getArtOverlay()), x, y, null);\\n                    }\\n                }\\n                if (tile.hasResource()) {\\n                    Image bonusImage = lib.getBonusImage(tic.getResource().getType());\\n                    if (bonusImage != null) {\\n                        g.drawImage(bonusImage, x + tileWidth/2 - bonusImage.getWidth(null)/2,\\n                                    y + tileHeight/2 - bonusImage.getHeight(null)/2, null);\\n                    }\\n                }\\n                                if (tile.hasRoad()) {\\n                    long seed = Long.parseLong(Integer.toString(tile.getX()) + Integer.toString(tile.getY()));\\n                    boolean connectedRoad = false;\\n                    for (Direction direction : Direction.values()) {\\n                        Map.Position p = Map.getAdjacent(pos, direction);\\n                        if (map.isValid(p)) {\\n                            Tile borderingTile = map.getTile(p);\\n                            if (borderingTile.hasRoad()) {\\n                                connectedRoad =  true;\\n                                int nx = x + tileWidth/2;\\n                                int ny = y + tileHeight/2;\\n                                switch (direction) {\\n                                case N : nx = x + tileWidth/2; ny = y; break;\\n                                case NE: nx = x + (tileWidth*3)/4; ny = y + tileHeight/4; break;\\n                                case E : nx = x + tileWidth; ny = y + tileHeight/2; break;\\n                                case SE: nx = x + (tileWidth*3)/4; ny = y + (tileHeight*3)/4; break;\\n                                case S : nx = x + tileWidth/2; ny = y + tileHeight; break;\\n                                case SW: nx = x + tileWidth/4; ny = y + (tileHeight*3)/4; break;\\n                                case W : nx = x; ny = y + tileHeight/2; break;\\n                                case NW: nx = x + tileWidth/4; ny = y + tileHeight/4; break;\\n                                }\\n                                drawRoad(g, seed, x + tileWidth/2, y + tileHeight/2, nx, ny);\\n                            }\\n                        }\\n                    }\\n                    if (!connectedRoad) {\\n                        drawRoad(g, seed, x + tileWidth/2 - 10, y + tileHeight/2, x + tileWidth/2 + 10, y + tileHeight/2);\\n                        drawRoad(g, seed, x + tileWidth/2, y + tileHeight/2 - 10, x + tileWidth/2, y + tileHeight/2 + 10);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    private void displaySettlement(Graphics2D g, Map map, Tile tile, int x, int y, boolean withNumber) {  \\n        if (tile.isExplored()) {\\n            Settlement settlement = tile.getSettlement();\\n            if (settlement != null) {\\n                if (settlement instanceof Colony) {\\n                    Image colonyImage = lib.getSettlementImage(settlement);\\n                                        g.drawImage(colonyImage,\\n                                x + (lib.getTerrainImageWidth(tile.getType()) -\\n                                     colonyImage.getWidth(null)) / 2,\\n                                y + (lib.getTerrainImageHeight(tile.getType()) -\\n                                     colonyImage.getHeight(null)) / 2, null);\\n                    if (withNumber) {\\n                        String populationString = Integer.toString(((Colony)settlement).getUnitCount());\\n                        Color theColor = null;\\n                        int bonus = ((Colony)settlement).getProductionBonus();\\n                        switch (bonus) {\\n                        case 2:\\n                            theColor = Color.BLUE;\\n                            break;\\n                        case 1:\\n                            theColor = Color.GREEN;\\n                            break;\\n                        case -1:\\n                            theColor = Color.ORANGE;\\n                            break;\\n                        case -2:\\n                            theColor = Color.RED;\\n                            break;\\n                        default:\\n                            theColor = Color.WHITE;\\n                        break;\\n                        }\\n                        BufferedImage stringImage = createStringImage(g, populationString, theColor, lib.getTerrainImageWidth(tile.getType()), 12);\\n                        g.drawImage(stringImage, x + (lib.getTerrainImageWidth(tile.getType()) - stringImage.getWidth())/2 + 1, y + ((lib.getTerrainImageHeight(tile.getType()) - stringImage.getHeight()) / 2) + 1, null);\\n                    }\\n                    g.setColor(Color.BLACK);\\n                } else if (settlement instanceof IndianSettlement) {\\n                    IndianSettlement indianSettlement = (IndianSettlement) settlement;\\n                    Image settlementImage = lib.getSettlementImage(settlement);\\n                                        g.drawImage(settlementImage,\\n                                x + (lib.getTerrainImageWidth(tile.getType()) -\\n                                     settlementImage.getWidth(null)) / 2,\\n                                y + (lib.getTerrainImageHeight(tile.getType()) - \\n                                     settlementImage.getHeight(null)) / 2, null);\\n                                        g.drawImage(lib.getColorChip(indianSettlement.getOwner().getColor()),\\n                                x + (int) (STATE_OFFSET_X * lib.getScalingFactor()),\\n                                y + (int) (STATE_OFFSET_Y * lib.getScalingFactor()), null);\\n                                        Unit missionary = indianSettlement.getMissionary();\\n                    if (missionary != null) {\\n                        boolean expert = missionary.hasAbility(\\\"model.ability.expertMissionary\\\");\\n                        g.drawImage(lib.getMissionChip(missionary.getOwner().getColor(), expert),\\n                                    x + (int) (STATE_OFFSET_X * lib.getScalingFactor()) +\\n                                    (MISSION_OFFSET_X - STATE_OFFSET_X),\\n                                    y + (int) (MISSION_OFFSET_Y * lib.getScalingFactor()), null);\\n                    }\\n                                        if (freeColClient.getMyPlayer() != null) {\\n                        Tension alarm = indianSettlement.getAlarm(freeColClient.getMyPlayer());\\n                        if (alarm != null) {\\n                                                        final boolean visited = indianSettlement.hasBeenVisited(freeColClient.getMyPlayer());\\n                            g.drawImage(lib.getAlarmChip(alarm.getLevel(), visited),\\n                                        x + (int) (STATE_OFFSET_X * lib.getScalingFactor()) +\\n                                        (ALARM_OFFSET_X - STATE_OFFSET_X),\\n                                        y + (int) (ALARM_OFFSET_Y  * lib.getScalingFactor()), null);\\n                        }\\n                    }\\n                    g.setColor(Color.BLACK);\\n                    if (indianSettlement.isCapital()) {\\n                                                g.drawString(\\\"*\\\",\\n                                     x + (STATE_OFFSET_X * lib.getScalingFactor()) + TEXT_OFFSET_X + 1,\\n                                     y + (int) (STATE_OFFSET_Y * lib.getScalingFactor()) + TEXT_OFFSET_Y + 2);\\n                    } else {\\n                        g.drawString(\\\"-\\\", \\n                                     x + (int) (STATE_OFFSET_X * lib.getScalingFactor()) + TEXT_OFFSET_X,\\n                                     y + (int) (STATE_OFFSET_Y * lib.getScalingFactor()) + TEXT_OFFSET_Y);\\n                    }\\n                } else {\\n                    logger.warning(\\\"Requested to draw unknown settlement type.\\\");\\n                }\\n            } else if (tile.hasLostCityRumour()) {\\n                g.drawImage(lib.getMiscImage(ImageLibrary.LOST_CITY_RUMOUR),\\n                            x + (int) (RUMOUR_OFFSET_X * lib.getScalingFactor()),\\n                            y + (int) (RUMOUR_OFFSET_Y * lib.getScalingFactor()), null);\\n            }\\n        }\\n    }\\n    private void displayFogOfWar(Graphics2D g, Map map, Tile tile, int x, int y) {  \\n        if (tile.isExplored()) {\\n            final boolean displayFogOfWar = freeColClient.getClientOptions().getBoolean(ClientOptions.DISPLAY_FOG_OF_WAR);\\n            if (displayFogOfWar\\n                    && freeColClient.getMyPlayer() != null\\n                    && !freeColClient.getMyPlayer().canSee(tile)) {\\n                g.setColor(Color.BLACK);\\n                Composite oldComposite = g.getComposite();\\n                g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.2f));\\n                Polygon pol = new Polygon(new int[] {x + tileWidth/2, x + tileWidth, x + tileWidth/2, x},\\n                                          new int[] {y, y + tileHeight/2, y + tileHeight, y + tileHeight/2},\\n                                          4);\\n                g.fill(pol);\\n                g.setComposite(oldComposite);\\n            }\\n        }\\n    }\\n    private void displayUnexploredBorders(Graphics2D g, Map map, Tile tile, int x, int y) {  \\n        if (tile.isExplored()) {\\n            Map.Position pos = new Map.Position(tile.getX(), tile.getY());\\n            for (Direction direction : Direction.values()) {\\n                Map.Position p = Map.getAdjacent(pos, direction);\\n                if (map.isValid(p)) {\\n                    Tile borderingTile = map.getTile(p);\\n                    if (borderingTile == null || borderingTile.isExplored()){\\n                        continue;\\n                    }\\n                    g.drawImage(lib.getBorderImage(null, direction, tile.getX(), tile.getY()), x, y, null);\\n                }\\n            }\\n        }\\n    }\\n    private void displayOptionalValues(Graphics2D g, Map map, Tile tile, int x, int y) {\\n        switch (displayTileText) {\\n        case ClientOptions.DISPLAY_TILE_TEXT_EMPTY:\\n            break;\\n        case ClientOptions.DISPLAY_TILE_TEXT_NAMES:\\n            if (tile.getName() != null) {\\n                String tileName = tile.getName();\\n                g.setColor(Color.BLACK);\\n                int b = getBreakingPoint(tileName);\\n                if (b == -1) {\\n                    g.drawString(tileName, x + (lib.getTerrainImageWidth(tile.getType()) - g.getFontMetrics().stringWidth(tileName))/2, y + (lib.getTerrainImageHeight(tile.getType())/2));\\n                } else {\\n                    g.drawString(tileName.substring(0, b), x + (lib.getTerrainImageWidth(tile.getType()) - g.getFontMetrics().stringWidth(tileName.substring(0, b)))/2, y + lib.getTerrainImageHeight(tile.getType())/2 - (g.getFontMetrics().getAscent()*2)/3);\\n                    g.drawString(tileName.substring(b+1), x + (lib.getTerrainImageWidth(tile.getType()) - g.getFontMetrics().stringWidth(tileName.substring(b+1)))/2, y + lib.getTerrainImageHeight(tile.getType())/2 + (g.getFontMetrics().getAscent()*2)/3);\\n                }\\n            }\\n            break;\\n        case ClientOptions.DISPLAY_TILE_TEXT_OWNERS:\\n            if (tile.getOwner() != null) {\\n                String tileOwner = tile.getOwner().getNationAsString();\\n                g.setColor(Color.BLACK);\\n                int b = getBreakingPoint(tileOwner);\\n                if (b == -1) {\\n                    g.drawString(tileOwner, x + (lib.getTerrainImageWidth(tile.getType()) - g.getFontMetrics().stringWidth(tileOwner))/2, y + (lib.getTerrainImageHeight(tile.getType())/2));\\n                } else {\\n                    g.drawString(tileOwner.substring(0, b), x + (lib.getTerrainImageWidth(tile.getType()) - g.getFontMetrics().stringWidth(tileOwner.substring(0, b)))/2, y + lib.getTerrainImageHeight(tile.getType())/2 - (g.getFontMetrics().getAscent()*2)/3);\\n                    g.drawString(tileOwner.substring(b+1), x + (lib.getTerrainImageWidth(tile.getType()) - g.getFontMetrics().stringWidth(tileOwner.substring(b+1)))/2, y + lib.getTerrainImageHeight(tile.getType())/2 + (g.getFontMetrics().getAscent()*2)/3);\\n                }\\n            }\\n            break;\\n        case ClientOptions.DISPLAY_TILE_TEXT_REGIONS:\\n            if (tile.getRegion() != null) {\\n                String regionString = tile.getRegion().getDisplayName();\\n                g.setColor(Color.BLACK);\\n                int b = getBreakingPoint(regionString);\\n                if (b == -1) {\\n                    g.drawString(regionString, x + (lib.getTerrainImageWidth(tile.getType()) - g.getFontMetrics().stringWidth(regionString))/2, y + (lib.getTerrainImageHeight(tile.getType())/2));\\n                } else {\\n                    g.drawString(regionString.substring(0, b), x + (lib.getTerrainImageWidth(tile.getType()) - g.getFontMetrics().stringWidth(regionString.substring(0, b)))/2, y + lib.getTerrainImageHeight(tile.getType())/2 - (g.getFontMetrics().getAscent()*2)/3);\\n                    g.drawString(regionString.substring(b+1), x + (lib.getTerrainImageWidth(tile.getType()) - g.getFontMetrics().stringWidth(regionString.substring(b+1)))/2, y + lib.getTerrainImageHeight(tile.getType())/2 + (g.getFontMetrics().getAscent()*2)/3);\\n                }\\n            }\\n            break;\\n        default:\\n            logger.warning(\\\"displayTileText out of range\\\");\\n            break;\\n        }\\n        g.setColor(Color.BLACK);\\n        if (displayCoordinates) {\\n            String posString = tile.getX() + \\\", \\\" + tile.getY();\\n            g.drawString(posString, x + (lib.getTerrainImageWidth(tile.getType()) - g.getFontMetrics().stringWidth(posString))/2, y + (lib.getTerrainImageHeight(tile.getType()) - g.getFontMetrics().getAscent())/2);\\n        }\\n        if (displayColonyValue && tile.isExplored() && tile.isLand()) {\\n            String valueString;\\n            if (displayColonyValuePlayer == null) {\\n                valueString = Integer.toString(tile.getColonyValue());\\n            } else {\\n                valueString = Integer.toString(displayColonyValuePlayer.getColonyValue(tile));\\n            }\\n            g.drawString(valueString, x + (lib.getTerrainImageWidth(tile.getType()) - g.getFontMetrics().stringWidth(valueString))/2, y + (lib.getTerrainImageHeight(tile.getType()) - g.getFontMetrics().getAscent())/2);\\n        }\\n    }\\n    public void stopGoto() {\\n        freeColClient.getCanvas().setCursor(null);\\n        setGotoPath(null);\\n        updateGotoPathForActiveUnit();\\n        gotoStarted = false;\\n    }\\n    public void startGoto() {\\n        gotoStarted = true;\\n        freeColClient.getCanvas().setCursor((java.awt.Cursor) UIManager.get(\\\"cursor.go\\\"));\\n        setGotoPath(null);\\n    }\\n    public boolean isGotoStarted() {\\n        return gotoStarted;\\n    }\\n    public void updateGotoPathForActiveUnit() {\\n        if (activeUnit == null || activeUnit.getDestination() == null) {\\n            currentPath = null;\\n        } else {\\n            if (activeUnit.getDestination() instanceof Europe) {\\n                currentPath = freeColClient.getGame().getMap().findPathToEurope(activeUnit, activeUnit.getTile());\\n            } else if (activeUnit.getDestination().getTile() == activeUnit.getTile()) {\\n                                currentPath = null;\\n            } else {\\n                currentPath = activeUnit.findPath(activeUnit.getDestination().getTile());\\n            }\\n        }\\n    }\\n    public void setGotoPath(PathNode gotoPath) {\\n        this.gotoPath = gotoPath;\\n        freeColClient.getCanvas().refresh();\\n    }\\n    public PathNode getGotoPath() {\\n        return gotoPath;\\n    }\\n    public void setDisplayGrid(boolean displayGrid) {\\n        this.displayGrid = displayGrid;\\n    }\\n    public void setDisplayTileText(int tileTextType) {\\n        this.displayTileText = tileTextType;\\n    }\\n    public int getBreakingPoint(String string) {\\n        int center = string.length() / 2;\\n        int bestIndex = string.indexOf(' ');\\n        int index = 0;\\n        while (index != -1 && index != bestIndex) {\\n            if (Math.abs(center-index) < Math.abs(center-bestIndex)) {\\n                bestIndex = index;\\n            }\\n            index = string.indexOf(' ', bestIndex);\\n        }\\n        if (bestIndex == 0 || bestIndex == string.length()) {\\n            return -1;\\n        } else {\\n            return bestIndex;\\n        }\\n    }\\n    private Image getOccupationIndicatorImage(Unit unit) {\\n        Image chip = lib.getColorChip(unit.getOwner().getColor());\\n        BufferedImage img = new BufferedImage(chip.getWidth(null), chip.getHeight(null), BufferedImage.TYPE_INT_ARGB);\\n        Graphics g = img.getGraphics();\\n        g.drawImage(chip, 0, 0, null);\\n        g.setColor(getForegroundColor(unit.getOwner().getColor()));\\n        String occupationString;\\n        if (unit.getOwner() != freeColClient.getMyPlayer()\\n                && unit.isNaval()) {\\n            occupationString = Integer.toString(unit.getVisibleGoodsCount());\\n        } else {\\n            occupationString = unit.getOccupationIndicator();\\n            if (unit.getState() == UnitState.FORTIFIED)\\n                g.setColor(Color.GRAY);\\n        }\\n        g.drawString(occupationString, TEXT_OFFSET_X, TEXT_OFFSET_Y);\\n        return img;\\n    }\\n    private Color getForegroundColor(Color background) {\\n        if (background.getRed() * 0.3\\n                + background.getGreen() * 0.59\\n                + background.getBlue() * 0.11 < 126) {\\n            return Color.WHITE;\\n        } else {\\n            return Color.BLACK;\\n        }\\n    }\\n    private Color getStringBorderColor(Color color) {\\n        if (color.getRed() * 0.3\\n                + color.getGreen() * 0.59\\n                + color.getBlue() * 0.11 < 10) {\\n            return Color.WHITE;\\n        } else {\\n            return Color.BLACK;\\n        }\\n    }\\n    public void displayOccupationIndicator(Graphics g, Unit unit, int x, int y) {\\n        g.drawImage(getOccupationIndicatorImage(unit), x, y, null);\\n    }\\n    private void displayUnit(Graphics2D g, Unit unit, int x, int y) {\\n        try {\\n                                    if (viewMode.displayUnitCursor(unit,x,y)) {\\n                drawCursor(g,x,y);\\n            }\\n                                    Image image = lib.getUnitImageIcon(unit, unit.getState() == UnitState.SENTRY).getImage();\\n            Point p = getUnitImagePositionInTile(image, x, y);\\n            g.drawImage(image, p.x, p.y, null);\\n                        displayOccupationIndicator(g, unit, x + (int) (STATE_OFFSET_X * lib.getScalingFactor()), y);\\n                        int unitsOnTile = 0;\\n            if (unit.getTile() != null) {\\n                                                                unitsOnTile = unit.getTile().getTotalUnitCount();\\n            }\\n            if (unitsOnTile > 1) {\\n                g.setColor(Color.WHITE);\\n                int unitLinesY = y + OTHER_UNITS_OFFSET_Y;\\n                for (int i = 0; (i < unitsOnTile) && (i < MAX_OTHER_UNITS); i++) {\\n                    g.drawLine(x + (int) ((STATE_OFFSET_X + OTHER_UNITS_OFFSET_X) * lib.getScalingFactor()), unitLinesY, x + (int) ((STATE_OFFSET_X + OTHER_UNITS_OFFSET_X + OTHER_UNITS_WIDTH) * lib.getScalingFactor()), unitLinesY);\\n                    unitLinesY += 2;\\n                }\\n            }\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n                if (debugShowMission && freeColClient.getFreeColServer() != null) {\\n            net.sf.freecol.server.ai.AIUnit au = (net.sf.freecol.server.ai.AIUnit) freeColClient.getFreeColServer().getAIMain().getAIObject(unit);\\n            if (au != null) {\\n                g.setColor(Color.WHITE);\\n                String text = (unit.getOwner().isAI()) ? \\\"\\\" : \\\"(\\\";\\n                String debuggingInfo = \\\"\\\";\\n                if (au.getMission() != null) {\\n                    String missionName = au.getMission().getClass().toString();\\n                    missionName = missionName.substring(missionName.lastIndexOf('.') + 1);\\n                    text += missionName;\\n                    if (debugShowMissionInfo) {\\n                        debuggingInfo = au.getMission().getDebuggingInfo();\\n                    }\\n                } else {\\n                    text += \\\"No mission\\\";\\n                }                \\n                text += (unit.getOwner().isAI()) ? \\\"\\\" : \\\")\\\";\\n                g.drawString(text, x , y);\\n                g.drawString(debuggingInfo, x , y+25);\\n            }\\n        }\\n    }\\n    private Point getUnitImagePositionInTile(Image unitImage, int tileX, int tileY) {\\n        return getUnitImagePositionInTile(unitImage.getWidth(null), unitImage.getHeight(null), tileX, tileY);\\n    }\\n    private Point getUnitImagePositionInTile(int unitImageWidth, int unitImageHeight, int tileX, int tileY) {\\n        int unitX = ((tileX + getTileWidth() / 2) - unitImageWidth / 2);\\n        int unitY = (tileY + getTileHeight() / 2) - unitImageHeight / 2 -\\n                    (int) (UNIT_OFFSET * lib.getScalingFactor());\\n        return new Point(unitX, unitY);\\n    }\\n    public Point getUnitLabelPositionInTile(JLabel unitLabel, Tile tile) {\\n        return getUnitLabelPositionInTile(unitLabel, getTilePosition(tile));\\n    }\\n    public Point getUnitLabelPositionInTile(JLabel unitLabel, Point tileP) {\\n        if (tileP != null) {\\n            int labelX = tileP.x;\\n            int labelY = (tileP.y + getTileHeight() / 2) - unitLabel.getHeight() / 2 -\\n                        (int) (UNIT_OFFSET * lib.getScalingFactor());\\n            return new Point(labelX, labelY);\\n        } else {\\n            return null;\\n        }\\n    }\\n    public JLabel getUnitLabel(Unit unit) {\\n        Image unitImg = lib.getUnitImageIcon(unit).getImage();\\n        Image chipImg = getOccupationIndicatorImage(unit);\\n        final int width = tileWidth/2 + unitImg.getWidth(null)/2;\\n        final int height = unitImg.getHeight(null);\\n        BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\\n        Graphics g = img.getGraphics();\\n        final int unitX = width - unitImg.getWidth(null);\\n        g.drawImage(unitImg, unitX, 0, null);\\n        final int chipX = ((int)(STATE_OFFSET_X * lib.getScalingFactor()));\\n        final int chipY = (int) (((height / 2 + UNIT_OFFSET*lib.getScalingFactor())) - tileHeight / 2);\\n        g.drawImage(chipImg, chipX, chipY, null);\\n        JLabel label = new JLabel(new ImageIcon(img));\\n        label.setBounds(0, 0, width, height);\\n        return label;\\n    }\\n    private void drawCursor(Graphics2D g, int x, int y) {\\n        g.drawImage(cursorImage, x, y, null);\\n    }\\n    public void setInGame(boolean inGame) {\\n        this.inGame = inGame;\\n    }\\n    public boolean isInGame() {\\n        return inGame;\\n    }\\n    public boolean onScreen(int x, int y) {\\n        if (bottomRow < 0) {\\n            positionMap();\\n            return y - 2 > topRow && y + 4 < bottomRow && x - 1 > leftColumn && x + 2 < rightColumn;\\n        } else {\\n            return y - 2 > topRow && y + 4 < bottomRow && x - 1 > leftColumn && x + 2 < rightColumn;\\n        }\\n    }\\n    public boolean onScreen(Position position) {\\n        return onScreen(position.getX(), position.getY());\\n    }\\n    public Map.Position convertToMapCoordinates(int x, int y) {\\n        Game gameData = freeColClient.getGame();\\n        if ((gameData == null) || (gameData.getMap() == null)) {\\n            return null;\\n        }\\n        int leftOffset;\\n        if (focus.getX() < getLeftColumns()) {\\n                        if ((focus.getY() % 2) == 0) {\\n                leftOffset = tileWidth * focus.getX() + tileWidth / 2;\\n            } else {\\n                leftOffset = tileWidth * (focus.getX() + 1);\\n            }\\n        } else if (focus.getX() >= (gameData.getMap().getWidth() - getRightColumns())) {\\n                        if ((focus.getY() % 2) == 0) {\\n                leftOffset = size.width - (gameData.getMap().getWidth() - focus.getX()) * tileWidth;\\n            } else {\\n                leftOffset = size.width - (gameData.getMap().getWidth() - focus.getX() - 1) * tileWidth - tileWidth / 2;\\n            }\\n        } else {\\n            if ((focus.getY() % 2) == 0) {\\n                leftOffset = (size.width / 2);\\n            } else {\\n                leftOffset = (size.width / 2) + tileWidth / 2;\\n            }\\n        }\\n        int topOffset;\\n        if (focus.getY() < topRows) {\\n                        topOffset = (focus.getY() + 1) * (tileHeight / 2);\\n        } else if (focus.getY() >= (gameData.getMap().getHeight() - bottomRows)) {\\n                        topOffset = size.height - (gameData.getMap().getHeight() - focus.getY()) * (tileHeight / 2);\\n        } else {\\n            topOffset = (size.height / 2);\\n        }\\n                                        int diffUp = (topOffset - y) / (tileHeight / 4),\\n            diffLeft = (leftOffset - x) / (tileWidth / 4);\\n                        int orDiffUp = diffUp,\\n            orDiffLeft = diffLeft,\\n            remainderUp = (topOffset - y) % (tileHeight / 4),\\n            remainderLeft = (leftOffset - x) % (tileWidth / 4);\\n        if ((diffUp % 2) == 0) {\\n            diffUp = diffUp / 2;\\n        } else {\\n            if (diffUp < 0) {\\n                diffUp = (diffUp / 2) - 1;\\n            } else {\\n                diffUp = (diffUp / 2) + 1;\\n            }\\n        }\\n        if ((diffLeft % 2) == 0) {\\n            diffLeft = diffLeft / 2;\\n        } else {\\n            if (diffLeft < 0) {\\n                diffLeft = (diffLeft / 2) - 1;\\n            } else {\\n                diffLeft = (diffLeft / 2) + 1;\\n            }\\n        }\\n        boolean done = false;\\n        while (!done) {\\n            if ((diffUp % 2) == 0) {\\n                if ((diffLeft % 2) == 0) {\\n                    diffLeft = diffLeft / 2;\\n                    done = true;\\n                } else {\\n                                        if (((orDiffLeft % 2) == 0) && ((orDiffUp % 2) == 0)) {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2) > remainderLeft) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2) > -remainderLeft) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        } else if ((orDiffLeft > 0) && (orDiffUp == 0)) {\\n                            if (remainderUp > 0) {\\n                                                                if ((remainderUp * 2) > remainderLeft) {\\n                                    diffUp++;\\n                                } else {\\n                                    diffLeft++;\\n                                }\\n                            } else {\\n                                                                if ((-remainderUp * 2) > remainderLeft) {\\n                                    diffUp--;\\n                                } else {\\n                                    diffLeft++;\\n                                }\\n                            }\\n                        } else if (orDiffUp == 0) {\\n                            if (remainderUp > 0) {\\n                                                                if ((remainderUp * 2) > -remainderLeft) {\\n                                    diffUp++;\\n                                } else {\\n                                    diffLeft--;\\n                                }\\n                            } else {\\n                                                                if ((-remainderUp * 2) > -remainderLeft) {\\n                                    diffUp--;\\n                                } else {\\n                                    diffLeft--;\\n                                }\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2) > remainderLeft) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2) > -remainderLeft) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        }\\n                    } else if ((orDiffLeft % 2) == 0) {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        }\\n                    } else if ((orDiffUp % 2) == 0) {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        } else if ((orDiffLeft > 0) && (orDiffUp == 0)) {\\n                            if (remainderUp > 0) {\\n                                                                if ((remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                    diffUp++;\\n                                } else {\\n                                    diffLeft--;\\n                                }\\n                            } else {\\n                                                                if ((-remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                    diffUp--;\\n                                } else {\\n                                    diffLeft--;\\n                                }\\n                            }\\n                        } else if (orDiffUp == 0) {\\n                            if (remainderUp > 0) {\\n                                                                if ((remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                    diffUp++;\\n                                } else {\\n                                    diffLeft++;\\n                                }\\n                            } else {\\n                                                                if ((-remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                    diffUp--;\\n                                } else {\\n                                    diffLeft++;\\n                                }\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        }\\n                    } else {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2) > remainderLeft) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2) > -remainderLeft) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2) > remainderLeft) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2) > -remainderLeft) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        }\\n                    }\\n                }\\n            } else {\\n                if ((diffLeft % 2) == 0) {\\n                                        if (((orDiffLeft % 2) == 0) && ((orDiffUp % 2) == 0)) {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2) > remainderLeft) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2) > remainderLeft) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        } else if ((orDiffUp > 0) && (orDiffLeft == 0)) {\\n                            if (remainderLeft > 0) {\\n                                                                if ((remainderUp * 2) > remainderLeft) {\\n                                    diffUp++;\\n                                } else {\\n                                    diffLeft++;\\n                                }\\n                            } else {\\n                                                                if ((remainderUp * 2) > -remainderLeft) {\\n                                    diffUp++;\\n                                } else {\\n                                    diffLeft--;\\n                                }\\n                            }\\n                        } else if (orDiffLeft == 0) {\\n                            if (remainderLeft > 0) {\\n                                                                if ((-remainderUp * 2) > remainderLeft) {\\n                                    diffUp--;\\n                                } else {\\n                                    diffLeft++;\\n                                }\\n                            } else {\\n                                                                if ((-remainderUp * 2) > -remainderLeft) {\\n                                    diffUp--;\\n                                } else {\\n                                    diffLeft--;\\n                                }\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2) > -remainderLeft) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2) > -remainderLeft) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        }\\n                    } else if ((orDiffLeft % 2) == 0) {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        } else if ((orDiffUp > 0) && (orDiffLeft == 0)) {\\n                            if (remainderLeft > 0) {\\n                                                                if ((remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                    diffLeft++;\\n                                } else {\\n                                    diffUp--;\\n                                }\\n                            } else {\\n                                                                if ((remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                    diffLeft--;\\n                                } else {\\n                                    diffUp--;\\n                                }\\n                            }\\n                        } else if (orDiffLeft == 0) {\\n                            if (remainderLeft > 0) {\\n                                                                if ((-remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                    diffLeft++;\\n                                } else {\\n                                    diffUp++;\\n                                }\\n                            } else {\\n                                                                if ((-remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                    diffLeft--;\\n                                } else {\\n                                    diffUp++;\\n                                }\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        }\\n                    } else if ((orDiffUp % 2) == 0) {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        }\\n                    } else {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2) > remainderLeft) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2) > -remainderLeft) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2) > remainderLeft) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2) > -remainderLeft) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        }\\n                    }\\n                } else {\\n                    if ((focus.getY() % 2) == 0) {\\n                        if (diffLeft < 0) {\\n                            diffLeft = diffLeft / 2;\\n                        } else {\\n                            diffLeft = (diffLeft / 2) + 1;\\n                        }\\n                    } else {\\n                        if (diffLeft < 0) {\\n                            diffLeft = (diffLeft / 2) - 1;\\n                        } else {\\n                            diffLeft = diffLeft / 2;\\n                        }\\n                    }\\n                    done = true;\\n                }\\n            }\\n        }\\n        return new Map.Position(focus.getX() - diffLeft, focus.getY() - diffUp);\\n    }\\n    public boolean isMapNearTop(int y) {\\n        if (y < topRows) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    public boolean isMapNearBottom(int y) {\\n        if (y >= (freeColClient.getGame().getMap().getHeight() - bottomRows)) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    public boolean isMapNearLeft(int x, int y) {\\n        if (x < getLeftColumns(y)) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    public boolean isMapNearRight(int x, int y) {\\n        if (x >= (freeColClient.getGame().getMap().getWidth() - getRightColumns(y))) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    public ImageLibrary getImageLibrary() {\\n        return lib;\\n    }\\n    public Point getTilePosition(Tile t) {\\n        if (t.getY() >= topRow \\n                && t.getY() <= bottomRow \\n                && t.getX() >= leftColumn \\n                && t.getX() <= rightColumn) {\\n            int x = ((t.getX() - leftColumn) * tileWidth) + leftColumnX;\\n            int y = ((t.getY() - topRow) * tileHeight / 2) + topRowY;\\n            if ((t.getY() % 2) != 0) {     \\n                x += tileWidth / 2;\\n            }\\n            return new Point(x, y);\\n        } else {\\n            return null;\\n        }\\n    }\\n    public Rectangle getTileBounds(Tile tile) {\\n        return getTileBounds(tile.getX(), tile.getY());\\n    }\\n    public Rectangle getTileBounds(int x, int y) {\\n        Rectangle result = new Rectangle(0, 0, size.width, size.height);\\n        if (y >= topRow && y <= bottomRow && x >= leftColumn && x <= rightColumn) {\\n            result.y = ((y - topRow) * tileHeight / 2) + topRowY - tileHeight;\\n            result.x = ((x - leftColumn) * tileWidth) + leftColumnX;\\n            if ((y % 2) != 0) {\\n                result.x += tileWidth / 2;\\n            }\\n            result.width = tileWidth;\\n            result.height = tileHeight * 2;\\n        }\\n        return result;\\n    }\\n    public void forceReposition() {\\n        bottomRow = -1;\\n    }\\n    public int getTileHeight() {\\n        return tileHeight;\\n    }\\n    public int getTileWidth() {\\n        return tileWidth;\\n    }\\n}\""
            },
            "m11": {
                "content": "### Analysis of `GUI.java`\n\nThe `GUI.java` class serves as the **core graphical user interface controller** for the FreeCol game client. It handles:\n- Rendering the map and game elements (tiles, units, settlements).\n- Managing UI overlays (e.g., unit paths, colony names, fog of war).\n- Handling user interactions like selecting tiles, managing active units, and navigating the map.\n- Displaying messages, tooltips, and visual indicators (e.g., alarms, mission status).\n\nIt heavily interacts with:\n- Game state objects such as `Tile`, `Unit`, `Colony`, and `Player`.\n- Other GUI components like `ImageLibrary`, `ViewMode`, and `Canvas`.\n\n---\n\n### Relationship Between `GUI.java` and `InGameController.java`\n\nFrom our analysis:\n- **High conceptual coupling (0.79)** confirms that these two files are semantically related.\n- The **co-change data** indicates they are frequently modified together.\n- From code inspection:\n  - `GUI.java` calls methods from `InGameController.java` to manage game logic, such as:\n    ```java\n    freeColClient.getInGameController().clearGotoOrders(activeUnit);\n    ```\n    This suggests that the GUI triggers or responds to actions managed by the game controller.\n\n---\n\n### Next Steps in CIA\n\nWe now understand that changes in `InGameController.java` likely necessitate updates in `GUI.java`. To complete the impact analysis, we should consider:\n\n1. **Call Graph Analysis**: Identify which other entities call or are called by `GUI.java`.\n2. **Coupling Dependencies**: Analyze direct dependencies between `GUI.java` and top co-changed entities like `ActionManager.java`, `UnitMoveAnimation.java`, etc.\n3. **Further Semantic Coupling**: Compare `GUI.java` with other co-changed files to determine if they also have strong conceptual links.\n\nLet\u2019s start by retrieving the **call graph** for `GUI.java` to identify its direct dependencies.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_40c3dd2c54f94f989323d1",
                        "function": {
                            "arguments": "{\"entity\": \"GUI.java\"}",
                            "name": "get_call_graph"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m12": {
                "role": "tool",
                "name": "get_call_graph",
                "content": "[\"Tension\", \"TileImprovement\", \"TileItemContainer\", \"Messages\", \"Map\", \"Unit\", \"FreeCol\", \"FreeColClient\", \"Europe\", \"MapControls\", \"IndianSettlement\", \"PathNode\", \"ClientOptions\", \"Player\", \"Settlement\", \"Game\", \"ResourceManager\", \"Tile\", \"TileType\", \"Colony\"]"
            },
            "m13": {
                "content": "The **call graph** for `GUI.java` reveals that it directly interacts with a wide range of entities, most of which are central to the game model and UI rendering. These include:\n\n### Key Entities Used by `GUI.java`\n| Entity | Role in GUI |\n|--------|-------------|\n| `FreeColClient` | Main client interface; provides access to game state and controllers. |\n| `Game`, `Map`, `Tile`, `Unit`, `Player`, `Colony`, `Settlement`, `IndianSettlement` | Game state objects displayed or manipulated via the GUI. |\n| `TileImprovement`, `TileType`, `TileItemContainer` | Represent terrain features and improvements shown on tiles. |\n| `PathNode` | Used for pathfinding visualization (e.g., unit movement paths). |\n| `ResourceManager`, `Messages` | Support for loading images, strings, and localized messages. |\n| `MapControls` | UI component for map navigation and controls. |\n| `ClientOptions` | User preferences affecting display behavior (e.g., fog of war, grid display). |\n| `Tension` | Used in displaying diplomatic status (e.g., alarms from indigenous settlements). |\n\nThis confirms that `GUI.java` is **deeply integrated with the game model**, meaning changes to these types or their interactions may ripple into the GUI.\n\n---\n\n### Impact Analysis Summary So Far\n\n- **Starting Entity**: `GUI.java`\n- **High Co-Change Entities**:\n  - `InGameController.java` \u2013 High conceptual coupling confirmed.\n  - Others like `ActionManager.java`, `UnitMoveAnimation.java`, etc., still need validation.\n- **Call Graph** shows direct dependencies on core game model classes.\n- **Conceptual Coupling** with `InGameController.java` suggests strong semantic relationship.\n\n---\n\n### Next Steps\n\nWe now have enough data to begin identifying **which co-changed entities actually impact `GUI.java`** and should be synchronized.\n\nLet\u2019s proceed by analyzing **coupling dependencies** between `GUI.java` and some of the top co-change candidates:\n1. `ActionManager.java`\n2. `UnitMoveAnimation.java`\n3. `MapEditorController.java`\n\nWe'll use the `get_coupling_dependencies` function to determine if there are direct code-level dependencies.\n\nLet's start with `ActionManager.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_8ab1e61ed8ad47468a4fa9",
                        "function": {
                            "arguments": "{\"entity1\": \"GUI.java\", \"entity2\": \"ActionManager.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m14": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"There are no coupling dependencies between these two entities\"]"
            },
            "m15": {
                "content": "There are **no direct coupling dependencies** between `GUI.java` and `ActionManager.java`. This suggests that while these two files may be co-changed due to broader functional relationships (e.g., both involved in handling user actions), there is **no explicit code-level dependency** such as method calls, type references, or shared variables.\n\n---\n\n### Next Steps\n\nSince `ActionManager.java` does not have a direct coupling with `GUI.java`, we should:\n1. Check coupling for another high-co-change entity like **UnitMoveAnimation.java**, which might have a more direct visual or control relationship.\n2. Reassess whether some co-change relationships are architectural or behavioral rather than structural.\n\nLet\u2019s now check the coupling between `GUI.java` and `UnitMoveAnimation.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_f68417c46d2546169aaddc",
                        "function": {
                            "arguments": "{\"entity1\": \"GUI.java\", \"entity2\": \"UnitMoveAnimation.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m16": {
                "role": "user",
                "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
            },
            "m17": {
                "content": "Title: Diagnosis of starting entity `GUI.java`  \nChange set: [InGameController, UnitMoveAnimation, ActionManager, Canvas, MapEditorController, MiniMap, MapControls, FreeColLookAndFeel, ChatAction, EndTurnAction, ClientOptions, FreeColMenuBar, InGameMenuBar, ProductionLabel, UnitLabel, TileInfoPanel, ReportContinentalCongressPanel, ImageLibrary, InfoPanel, CombatOdds, Animations, FreeColClient, InGameInputHandler, PreGameController, ViewMode, DisplayTileOwnersAction, ProductionPanel, TilePanel, DebugMenu, ColonyPanel, MoveAction, MapboardAction, WorkProductionPanel, SelectableAction, FreeColAction, ColopediaAction, FindSettlementDialog, ServerPlayer, AIColony, ResourceManager, TilePopup]  \n\nDetails:  \n- **InGameController**: High co-change confidence (0.1578), strong conceptual coupling (0.79), and semantic analysis show it coordinates game logic that directly affects the GUI state.  \n- **UnitMoveAnimation**: Frequently co-changed (confidence 0.1447); likely involved in visual updates managed by GUI for unit movements.  \n- **ActionManager**: Co-changed with high support (confidence 0.1184); although no direct coupling found, it mediates user actions reflected in GUI.  \n- **Canvas**: Core UI rendering component; tightly linked to GUI for redrawing and repainting operations.  \n- **MapEditorController**: High co-change score (confidence 0.1184); likely shares similar UI/game-state synchronization needs.  \n- **MiniMap**, **MapControls**, **FreeColMenuBar**, **ViewMode**, **TileInfoPanel**, **InfoPanel**, **DebugMenu**, **ColonyPanel**, **FindSettlementDialog**, **TilePopup**: These are all UI components or controllers used within the main GUI for rendering and interaction.  \n- **FreeColLookAndFeel**, **DisplayTileOwnersAction**, **SelectableAction**, **FreeColAction**, **ColopediaAction**, **MapboardAction**, **MoveAction**: Actions/UI customizations that are likely triggered or displayed via GUI.  \n- **CombatOdds**, **Animations**, **WorkProductionPanel**, **ProductionPanel**, **ProductionLabel**, **UnitLabel**, **TilePanel**: Visual elements related to gameplay features managed through GUI.  \n- **ClientOptions**: Affects display settings (e.g., fog of war, grid) that `GUI.java` must reflect.  \n- **ResourceManager**, **ImageLibrary**: Provide resources used in GUI rendering.  \n- **InGameInputHandler**, **PreGameController**: Coordinate input and pre-game setup that influence GUI behavior.  \n- **ServerPlayer**, **AIColony**: Game model entities whose state changes may trigger UI updates.  \n- **FreeColClient**: Central client interface, frequently used by GUI to access game state and controllers.  \n\nAll these entities are either:\n- Directly involved in UI rendering/modification,\n- Frequently co-changed with `GUI.java`, or\n- Semantically tied to GUI behavior based on functional dependencies.\n\nThus, they should be considered as part of the change impact set when modifying `GUI.java`.",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            }
        }
    }
}