{
    "time": 1749447528.0002263,
    "messages": [
        {
            "role": "system",
            "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
        },
        {
            "role": "user",
            "content": "The project you need to analyze is `freecol`, a well-known Java open source project. The starting entity you need to deal with is MapViewer.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
        },
        {
            "content": "",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_4932233957bf4114a7c729",
                    "function": {
                        "arguments": "{\"entity\": \"MapViewer.java\"}",
                        "name": "get_co_change_relationship"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "name": "get_co_change_relationship",
            "role": "tool",
            "content": "[[\"InGameInputHandler\", \"1\", \"0.25\"], [\"FreeColClient\", \"2\", \"0.5\"], [\"PreGameController\", \"1\", \"0.25\"], [\"Canvas\", \"2\", \"0.5\"], [\"MiniMap\", \"1\", \"0.25\"], [\"AudioMixerOptionUI\", \"1\", \"0.25\"], [\"WorkProductionPanel\", \"1\", \"0.25\"], [\"GUI\", \"2\", \"0.5\"], [\"MapEditorController\", \"1\", \"0.25\"], [\"ZoomOutAction\", \"1\", \"0.25\"], [\"ZoomInAction\", \"1\", \"0.25\"], [\"RefreshTilesSwingTask\", \"1\", \"0.25\"]]"
        },
        {
            "content": "The `get_co_change_relationship` function has returned a list of entities that are frequently co-changed with `MapViewer.java`, along with their support count and confidence level. Based on the confidence score, we can identify which entities are most likely to be impacted by changes in `MapViewer.java`.\n\n### Observations:\n1. **High Confidence Relationships (>= 0.5):**\n   - `FreeColClient` (confidence: 0.5)\n   - `Canvas` (confidence: 0.5)\n   - `GUI` (confidence: 0.5)\n\n   These entities have relatively high confidence scores and significant historical co-change relationships with `MapViewer.java`. They should be prioritized for further analysis and potential synchronization.\n\n2. **Lower Confidence Relationships (< 0.5):**\n   - Entities like `InGameInputHandler`, `MiniMap`, `AudioMixerOptionUI`, etc., have lower confidence scores, indicating weaker historical ties. However, they might still warrant attention depending on specific change scenarios.\n\n### Next Steps:\nTo better understand how these entities relate to `MapViewer.java`, I will analyze their coupling dependencies. Starting with the highest-confidence entity, `FreeColClient`, let's examine its coupling dependencies with `MapViewer.java`.\n\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_59823cebd2384336b945b1",
                    "function": {
                        "arguments": "{\"entity1\": \"MapViewer.java\", \"entity2\": \"FreeColClient\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"ConstructorInvoking(CMAIM): Coupling found in method convertToMapTile, at line: 392. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method convertToMapTile, at line: 871. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method convertToMapTile, at line: 874. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method display, at line: 950. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method display, at line: 951. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method display, at line: 953. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method isInGame.  Coupling found in method display, at line: 957. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method isMapEditor.  Coupling found in method getOccupationIndicatorImage, at line: 1158. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getMyPlayer.  Coupling found in method isMapNearBottom, at line: 1320. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method isMapNearRight, at line: 1341. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method setActiveUnit, at line: 1411. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getMyPlayer.  Coupling found in method setActiveUnit, at line: 1423. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method currentPlayerIsMyPlayer.  Coupling found in method setActiveUnit, at line: 1425. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getInGameController.  Coupling found in method setActiveUnit, at line: 1428. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getInGameController.  Coupling found in method setActiveUnit, at line: 1442. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getClientOptions.  Coupling found in method setActiveUnit, at line: 1448. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getActionManager.  Coupling found in method setOffsetFocus, at line: 1512. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method setSelectedTile, at line: 1579. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getInGameController.  Coupling found in method setSelectedTile, at line: 1585. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getActionManager.  Coupling found in method setSelectedTile, at line: 1591. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getClientOptions.  Coupling found in method displayFogOfWar, at line: 1984. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method displayFogOfWar, at line: 1985. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getMyPlayer.  Coupling found in method displayFogOfWar, at line: 1986. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getMyPlayer.  Coupling found in method displayMap, at line: 2062. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method displayMap, at line: 2099. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getClientOptions.  Coupling found in method displayMap, at line: 2159. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getClientOptions.  Coupling found in method displayMap, at line: 2168. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getClientOptions.  Coupling found in method displayMap, at line: 2243. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getMyPlayer.  Coupling found in method displayMap, at line: 2346. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method isMapEditor.  Coupling found in method displayMap, at line: 2347. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method displayMap, at line: 2348. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method currentPlayerIsMyPlayer.  Coupling found in method displayMap, at line: 2359. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method displayOptionalValues, at line: 2414. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getClientOptions.  Coupling found in method displayOptionalValues, at line: 2466. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method displaySettlement, at line: 2512. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getClientOptions.  Coupling found in method displaySettlement, at line: 2533. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getMyPlayer.  Coupling found in method displayUnit, at line: 2650. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getMyPlayer.  Coupling found in method displayUnit, at line: 2683. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getFreeColServer.  Coupling found in method displayUnit, at line: 2686. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getFreeColServer.  Coupling found in method paintBorders, at line: 3096. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getClientOptions.  Coupling found in method positionMap, at line: 3189. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.\"]"
        },
        {
            "content": "The coupling dependency analysis between `MapViewer.java` and `FreeColClient` reveals a **strong relationship**. The `MapViewer` class heavily relies on the `FreeColClient` class by invoking its methods across multiple functionalities, such as retrieving game state (`getGame`), checking player status (`getMyPlayer`, `currentPlayerIsMyPlayer`), and accessing controllers or options (`getClientOptions`, `getInGameController`, `getActionManager`). These dependencies are spread throughout key methods in `MapViewer.java`.\n\n### Key Findings:\n1. **High Coupling Intensity:**\n   - Multiple method calls to `FreeColClient` appear across many functions in `MapViewer.java`.\n   - This indicates that changes in `FreeColClient` could significantly affect `MapViewer.java`, and vice versa.\n\n2. **Critical Interactions:**\n   - `MapViewer` uses `FreeColClient` to access core game data (`getGame`, `getMyPlayer`) and control logic (`getActionManager`, `getInGameController`).\n   - These interactions suggest that any change affecting these methods in `FreeColClient` will likely require updates in `MapViewer.java`.\n\n3. **Implication for Synchronization:**\n   - Due to the strong coupling and high co-change confidence score, **`FreeColClient` should definitely be synchronized with `MapViewer.java`** during changes.\n\n### Next Steps:\nLet's analyze another high-confidence co-changed entity, `Canvas`, and examine its coupling dependencies with `MapViewer.java`. This will help us determine if it also has significant interdependencies.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_ad16d406f4a04060b4d96d",
                    "function": {
                        "arguments": "{\"entity1\": \"MapViewer.java\", \"entity2\": \"Canvas\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"There are no coupling dependencies between these two entities\"]"
        },
        {
            "content": "The coupling dependency analysis between `MapViewer.java` and `Canvas` reveals **no direct dependencies**. This means that although they have a relatively high co-change confidence (0.5), their interaction is likely **indirect**, or the changes may be driven by shared contextual logic rather than direct method or variable usage.\n\n### Implications:\n- Since there are no direct coupling dependencies, it suggests that changes in `Canvas` may not directly impact `MapViewer.java` through code-level interactions.\n- However, the historical co-change relationship might indicate that both files are affected by broader UI or rendering-related changes.\n\n### Next Steps:\nLet's analyze the third high-confidence co-changed entity, `GUI`, to determine whether it has any significant coupling with `MapViewer.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_bc6a438fc63e4bb0ad0fc1",
                    "function": {
                        "arguments": "{\"entity1\": \"MapViewer.java\", \"entity2\": \"GUI\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"ConstructorInvoking(CMAIM): Coupling found in method display, at line: 963. Instance of GUI member variable gui is used to call GUI's method getCanvas.  Coupling found in method setActiveUnit, at line: 1412. Instance of GUI member variable gui is used to call GUI's method getCanvas.  Coupling found in method setActiveUnit, at line: 1449. Instance of GUI member variable gui is used to call GUI's method updateMenuBar.  Coupling found in method setFocus, at line: 1466. Instance of GUI member variable gui is used to call GUI's method refresh.  Coupling found in method setFocusImmediately, at line: 1481. Instance of GUI member variable gui is used to call GUI's method getCanvas.  Coupling found in method setGotoPath, at line: 1493. Instance of GUI member variable gui is used to call GUI's method refresh.  Coupling found in method setSelectedTile, at line: 1563. Instance of GUI member variable gui is used to call GUI's method getCanvas.  Coupling found in method setSelectedTile, at line: 1586. Instance of GUI member variable gui is used to call GUI's method updateMenuBar.  Coupling found in method setSelectedTile, at line: 1597. Instance of GUI member variable gui is used to call GUI's method refreshTile.  Coupling found in method setSelectedTile, at line: 1601. Instance of GUI member variable gui is used to call GUI's method refreshTile.  Coupling found in method actionPerformed, at line: 1630. Instance of GUI member variable gui is used to call GUI's method refreshTile.  Coupling found in method startCursorBlinking, at line: 1630. Instance of GUI member variable gui is used to call GUI's method refreshTile.  Coupling found in method startGoto, at line: 1648. Instance of GUI member variable gui is used to call GUI's method getCanvas.  Coupling found in method stopGoto, at line: 1665. Instance of GUI member variable gui is used to call GUI's method getCanvas.  Coupling found in method scaleMap, at line: 1696. Instance of GUI member variable gui is used to call GUI's method getImageLibrary.  Coupling found in method scaleMap, at line: 1698. Instance of GUI member variable gui is used to call GUI's method getImageLibrary.  Coupling found in method displayMap, at line: 2344. Instance of GUI member variable gui is used to call GUI's method getCanvas.  Coupling found in method enterUnitOutForAnimation, at line: 2840. Instance of GUI member variable gui is used to call GUI's method getCanvas.  Coupling found in method redrawMapControls, at line: 3278. Instance of GUI member variable gui is used to call GUI's method getCanvas.  Coupling found in method redrawMapControls, at line: 3283. Instance of GUI member variable gui is used to call GUI's method getCanvas.  Coupling found in method releaseUnitOutForAnimation, at line: 3300. Instance of GUI member variable gui is used to call GUI's method getCanvas.\"]"
        },
        {
            "content": "The coupling dependency analysis between `MapViewer.java` and `GUI` reveals a **significant relationship**, with multiple method invocations from `MapViewer` to the `GUI` class. These interactions are spread across several key functionalities in `MapViewer.java`.\n\n### Key Findings:\n1. **Frequent Use of GUI Components:**\n   - `MapViewer` frequently uses the `GUI` object to access UI components such as the canvas (`getCanvas`) and image library (`getImageLibrary`).\n   - It also calls methods like `refresh`, `updateMenuBar`, and `refreshTile`, which are essential for updating the user interface based on map-related actions.\n\n2. **Impact on UI Behavior:**\n   - Many of these interactions occur during operations like setting focus, selecting tiles, and redrawing map elements.\n   - Changes in the `GUI` class\u2014especially those affecting UI rendering or interaction\u2014could directly impact how `MapViewer` behaves.\n\n3. **Implication for Synchronization:**\n   - Given the high co-change confidence (0.5) and the presence of real code-level dependencies, **`GUI` should be synchronized with `MapViewer.java`** when changes are made.\n\n### Summary of Entities to Synchronize:\nSo far, we have confirmed that the following entities should be synchronized with `MapViewer.java` due to either strong coupling or significant historical co-change relationships:\n\n- \u2705 `FreeColClient` \u2013 Strong coupling and high co-change confidence\n- \u2705 `GUI` \u2013 Moderate-to-strong coupling and high co-change confidence\n- \u274c `Canvas` \u2013 No direct coupling found despite co-change history\n\n### Next Steps:\nLet\u2019s now take a broader look at `MapViewer.java` itself by analyzing its internal structure and call graph to identify other potentially important dependencies.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_a5b2d15f9bee4908bc09e0",
                    "function": {
                        "arguments": "{\"entity\": \"MapViewer.java\"}",
                        "name": "get_call_graph"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_call_graph",
            "content": "[\"BuildableType\", \"Ability\", \"TileImprovement\", \"PathNode\", \"StringTemplate\", \"FreeColClient\", \"ColonyTile\", \"Resource\", \"Settlement\", \"Europe\", \"GameOptions\", \"Region\", \"ImageResource\", \"ResourceManager\", \"Unit\", \"FreeCol\", \"Player\", \"Map\", \"InfoPanel\", \"TileItem\", \"ClientOptions\", \"Colony\", \"Messages\", \"IndianSettlement\", \"Game\", \"Tile\", \"LostCityRumour\", \"MapControls\"]"
        },
        {
            "content": "The call graph of `MapViewer.java` provides a list of classes that it directly interacts with through method calls or references. These entities represent **internal dependencies** that are crucial for the functionality of the `MapViewer`.\n\n### Key Observations:\n1. **Core Game Entities:**\n   - `Game`, `Player`, `Unit`, `Tile`, `Settlement`, `Colony`, `IndianSettlement`, `Europe`, and `Resource` are all central to FreeCol\u2019s gameplay.\n   - These indicate that changes in `MapViewer.java` may affect how map-related game state is visualized or manipulated.\n\n2. **UI and Control Components:**\n   - `FreeColClient`, `GUI`, `InfoPanel`, `MapControls`, and `ClientOptions` show continued interaction with UI and control logic, reinforcing earlier coupling findings.\n\n3. **Supporting Classes:**\n   - `ResourceManager`, `ImageResource`, `StringTemplate`, and `Messages` suggest that `MapViewer` also depends on resource management and internationalization components.\n\n4. **Interesting Absence:**\n   - Although `Canvas` was found to co-change frequently, it does not appear in the call graph\u2014further supporting the idea that their relationship might be indirect or mediated through other classes like `GUI`.\n\n### Synchronization Implications:\n- Any change in `MapViewer.java` should consider the impact on tightly coupled classes such as:\n  - \u2705 `FreeColClient`\n  - \u2705 `GUI`\n  - \u2705 `Game`, `Tile`, `Unit`, `Settlement`, etc.\n\nThese classes should be evaluated for synchronization when modifying `MapViewer.java`.\n\n### Final Step:\nTo ensure completeness, let's briefly examine the source code of `MapViewer.java` to understand its general structure and identify any additional insights about its responsibilities and interactions.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_b6bb3066648f49cb99bc7b",
                    "function": {
                        "arguments": "{\"entity\": \"MapViewer.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package net.sf.freecol.client.gui;\\nimport java.awt.AlphaComposite;\\nimport java.awt.BasicStroke;\\nimport java.awt.Color;\\nimport java.awt.Component;\\nimport java.awt.Composite;\\nimport java.awt.Dimension;\\nimport java.awt.Font;\\nimport java.awt.FontMetrics;\\nimport java.awt.Graphics;\\nimport java.awt.Graphics2D;\\nimport java.awt.Image;\\nimport java.awt.Point;\\nimport java.awt.Rectangle;\\nimport java.awt.RenderingHints;\\nimport java.awt.Stroke;\\nimport java.awt.event.ActionEvent;\\nimport java.awt.event.ActionListener;\\nimport java.awt.font.TextLayout;\\nimport java.awt.geom.AffineTransform;\\nimport java.awt.geom.Ellipse2D;\\nimport java.awt.geom.GeneralPath;\\nimport java.awt.geom.Point2D;\\nimport java.awt.geom.Rectangle2D;\\nimport java.awt.geom.RoundRectangle2D;\\nimport java.awt.image.BufferedImage;\\nimport java.util.Arrays;\\nimport java.util.ArrayList;\\nimport java.util.Date;\\nimport java.util.EnumMap;\\nimport java.util.HashMap;\\nimport java.util.Iterator;\\nimport java.util.List;\\nimport java.util.Vector;\\nimport java.util.logging.Logger;\\nimport javax.swing.ImageIcon;\\nimport javax.swing.JLabel;\\nimport javax.swing.JLayeredPane;\\nimport javax.swing.UIManager;\\nimport net.sf.freecol.FreeCol;\\nimport net.sf.freecol.client.ClientOptions;\\nimport net.sf.freecol.client.FreeColClient;\\nimport net.sf.freecol.client.gui.i18n.Messages;\\nimport net.sf.freecol.client.gui.panel.InfoPanel;\\nimport net.sf.freecol.client.gui.panel.MapControls;\\nimport net.sf.freecol.common.model.Ability;\\nimport net.sf.freecol.common.model.BuildableType;\\nimport net.sf.freecol.common.model.Colony;\\nimport net.sf.freecol.common.model.ColonyTile;\\nimport net.sf.freecol.common.model.Europe;\\nimport net.sf.freecol.common.model.Game;\\nimport net.sf.freecol.common.model.GameOptions;\\nimport net.sf.freecol.common.model.IndianSettlement;\\nimport net.sf.freecol.common.model.LostCityRumour;\\nimport net.sf.freecol.common.model.Map;\\nimport net.sf.freecol.common.model.Map.Direction;\\nimport net.sf.freecol.common.model.Map.Position;\\nimport net.sf.freecol.common.model.PathNode;\\nimport net.sf.freecol.common.model.Player;\\nimport net.sf.freecol.common.model.Region;\\nimport net.sf.freecol.common.model.Resource;\\nimport net.sf.freecol.common.model.Settlement;\\nimport net.sf.freecol.common.model.StringTemplate;\\nimport net.sf.freecol.common.model.Tile;\\nimport net.sf.freecol.common.model.TileImprovement;\\nimport net.sf.freecol.common.model.TileItem;\\nimport net.sf.freecol.common.model.Unit;\\nimport net.sf.freecol.common.resources.ImageResource;\\nimport net.sf.freecol.common.resources.ResourceManager;\\npublic final class MapViewer {\\n    public static enum BorderType { COUNTRY, REGION }\\n    @SuppressWarnings(\\\"serial\\\")\\n    static class GrayLayer extends Component {\\n        private static final Color MASK_COLOR = new Color(0f, 0f, 0f, .6f);\\n        private static final int DEFAULT_FONT_SIZE = 18;\\n        private static final int FONT_SIZE_DECREMENT = 2;\\n        private static final int MAX_TEXT_WIDTH = 640;\\n        private ImageLibrary imageLibrary;\\n        private Player player;\\n        public GrayLayer(ImageLibrary imageLibrary) {\\n            this.imageLibrary = imageLibrary;\\n        }\\n        @Override\\n        public void paint(Graphics g) {\\n            Rectangle clipArea = g.getClipBounds();\\n            if (clipArea == null) {\\n                clipArea = getBounds();\\n                clipArea.x = clipArea.y = 0;\\n            }\\n            if (clipArea.isEmpty()) {\\n                                return;\\n            }\\n            g.setColor(MASK_COLOR);\\n            g.fillRect(clipArea.x, clipArea.y, clipArea.width, clipArea.height);\\n            if (player == null) {\\n                                return;\\n            }\\n            ImageIcon coatOfArmsIcon = imageLibrary\\n                    .getCoatOfArmsImageIcon(player.getNation());\\n            Rectangle iconBounds = new Rectangle();\\n            if (coatOfArmsIcon != null) {\\n                iconBounds.width = coatOfArmsIcon.getIconWidth();\\n                iconBounds.height = coatOfArmsIcon.getIconHeight();\\n            }\\n            Font nameFont = getFont();\\n            FontMetrics nameFontMetrics = getFontMetrics(nameFont);\\n            StringTemplate t = StringTemplate.template(\\\"waitingFor\\\")\\n                .addStringTemplate(\\\"%nation%\\\", player.getNationName());\\n            String message = Messages.message(t);\\n            Rectangle textBounds;\\n            int fontSize = DEFAULT_FONT_SIZE;\\n            int maxWidth = Math.min(MAX_TEXT_WIDTH, getSize().width);\\n            do {\\n                nameFont = nameFont.deriveFont(Font.BOLD, fontSize);\\n                nameFontMetrics = getFontMetrics(nameFont);\\n                textBounds = nameFontMetrics.getStringBounds(message, g)\\n                        .getBounds();\\n                fontSize -= FONT_SIZE_DECREMENT;\\n            } while (textBounds.width > maxWidth);\\n            Dimension size = getSize();\\n            textBounds.x = (size.width - textBounds.width) / 2;\\n            textBounds.y = size.height - InfoPanel.PANEL_HEIGHT - 2 * textBounds.height;\\n            iconBounds.x = (size.width - iconBounds.width) / 2;\\n            iconBounds.y = textBounds.y + 3 * textBounds.height / 2;\\n            if (textBounds.intersects(clipArea)) {\\n                                g.setFont(nameFont);\\n                g.setColor(imageLibrary.getColor(player));\\n                g.drawString(message, textBounds.x, textBounds.y\\n                        + textBounds.height);\\n            }\\n            if (coatOfArmsIcon != null && iconBounds.intersects(clipArea)) {\\n                                coatOfArmsIcon.paintIcon(this, g, iconBounds.x, iconBounds.y);\\n            }\\n        }\\n        public void setPlayer(Player player) {\\n            if (this.player == player) {\\n                return;\\n            }\\n            this.player = player;\\n            repaint();\\n        }\\n    }\\n    class TextSpecification {\\n        public String text;\\n        public Font font;\\n        public TextSpecification(String newText, Font newFont) {\\n            text = newText;\\n            font = newFont;\\n        }\\n    }\\n    private static final Logger logger = Logger.getLogger(MapViewer.class.getName());\\n    private final FreeColClient freeColClient;\\n    private Dimension size;\\n    private ImageLibrary lib;\\n    private TerrainCursor cursor;\\n    private ViewMode viewMode;\\n    private final Vector<GUIMessage> messages;\\n    private Tile selectedTile;\\n    private Tile focus = null;\\n    private Unit activeUnit;\\n    private PathNode currentPath;\\n    private PathNode gotoPath = null;\\n    private boolean gotoStarted = false;\\n        private int tileHeight, tileWidth, halfHeight, halfWidth,\\n    topSpace,\\n    topRows,\\n        bottomRows,\\n    leftSpace,\\n    rightSpace;\\n        private int bottomRow = -1;\\n        private int topRow;\\n            private int bottomRowY;\\n            private int topRowY;\\n        private int leftColumn;\\n        private int rightColumn;\\n            private int leftColumnX;\\n        private static final int UNIT_OFFSET = 20,\\n        STATE_OFFSET_X = 25,\\n        STATE_OFFSET_Y = 10,\\n        OTHER_UNITS_OFFSET_X = -5,         OTHER_UNITS_OFFSET_Y = 1,\\n        OTHER_UNITS_WIDTH = 3,\\n        MAX_OTHER_UNITS = 10,\\n        MESSAGE_COUNT = 3,\\n        MESSAGE_AGE = 30000; \\n    public static final int OVERLAY_INDEX = 100;\\n    public static final int FOREST_INDEX = 200;\\n    private GeneralPath gridPath = null;\\n    private GeneralPath fog = new GeneralPath();\\n        public boolean displayCoordinates = false;\\n    public boolean displayColonyValue = false;\\n    public Player displayColonyValuePlayer = null;\\n    public boolean debugShowMission = false;\\n    public boolean debugShowMissionInfo = false;\\n    private volatile boolean blinkingMarqueeEnabled;\\n    private Image cursorImage;\\n    private GrayLayer greyLayer;\\n    private java.util.Map<Unit, Integer> unitsOutForAnimation;\\n    private java.util.Map<Unit, JLabel> unitsOutForAnimationLabels;\\n        private EnumMap<Direction, Point2D.Float> corners =\\n        new EnumMap<Direction, Point2D.Float>(Direction.class);\\n    private EnumMap<Direction, List<Direction>> prohibitedRoads =\\n        new EnumMap<Direction, List<Direction>>(Direction.class);\\n    private Stroke roadStroke = new BasicStroke(2);\\n        private EnumMap<Direction, Point2D.Float> borderPoints =\\n        new EnumMap<Direction, Point2D.Float>(Direction.class);\\n    private EnumMap<Direction, Point2D.Float> controlPoints =\\n        new EnumMap<Direction, Point2D.Float>(Direction.class);\\n    private Stroke borderStroke = new BasicStroke(4);\\n    private Stroke gridStroke = new BasicStroke(1);\\n    private GUI gui;\\n    public MapViewer(FreeColClient freeColClient, GUI gui, Dimension size, ImageLibrary lib) {\\n        this.freeColClient = freeColClient;\\n        this.gui = gui;\\n        this.size = size;\\n        setImageLibrary(lib);\\n        unitsOutForAnimation = new HashMap<Unit, Integer>();\\n        unitsOutForAnimationLabels = new HashMap<Unit, JLabel>();\\n        logger.info(\\\"GUI created.\\\");\\n        messages = new Vector<GUIMessage>(MESSAGE_COUNT);\\n        viewMode = new ViewMode(this);\\n        logger.info(\\\"Starting in Move Units View Mode\\\");\\n        blinkingMarqueeEnabled = true;\\n        cursor = new net.sf.freecol.client.gui.TerrainCursor();\\n    }\\n    public synchronized void addMessage(GUIMessage message) {\\n        if (getMessageCount() == MESSAGE_COUNT) {\\n            messages.remove(0);\\n        }\\n        messages.add(message);\\n    }\\n    public void centerActiveUnit() {\\n        if (activeUnit != null && activeUnit.getTile() != null) {\\n            setFocus(activeUnit.getTile());\\n        }\\n    }\\n    public Tile convertToMapTile(int x, int y) {\\n        Game gameData = freeColClient.getGame();\\n        if ((gameData == null) || (gameData.getMap() == null)) {\\n            return null;\\n        }\\n        int leftOffset;\\n        if (focus.getX() < getLeftColumns()) {\\n                        if ((focus.getY() % 2) == 0) {\\n                leftOffset = tileWidth * focus.getX() + halfWidth;\\n            } else {\\n                leftOffset = tileWidth * (focus.getX() + 1);\\n            }\\n        } else if (focus.getX() >= (gameData.getMap().getWidth() - getRightColumns())) {\\n                        if ((focus.getY() % 2) == 0) {\\n                leftOffset = size.width - (gameData.getMap().getWidth() - focus.getX()) * tileWidth;\\n            } else {\\n                leftOffset = size.width - (gameData.getMap().getWidth() - focus.getX() - 1) * tileWidth - halfWidth;\\n            }\\n        } else {\\n            if ((focus.getY() % 2) == 0) {\\n                leftOffset = (size.width / 2);\\n            } else {\\n                leftOffset = (size.width / 2) + halfWidth;\\n            }\\n        }\\n        int topOffset;\\n        if (focus.getY() < topRows) {\\n                        topOffset = (focus.getY() + 1) * (halfHeight);\\n        } else if (focus.getY() >= (gameData.getMap().getHeight() - bottomRows)) {\\n                        topOffset = size.height - (gameData.getMap().getHeight() - focus.getY()) * (halfHeight);\\n        } else {\\n            topOffset = (size.height / 2);\\n        }\\n                                        int diffUp = (topOffset - y) / (tileHeight / 4),\\n            diffLeft = (leftOffset - x) / (tileWidth / 4);\\n                        int orDiffUp = diffUp,\\n            orDiffLeft = diffLeft,\\n            remainderUp = (topOffset - y) % (tileHeight / 4),\\n            remainderLeft = (leftOffset - x) % (tileWidth / 4);\\n        if ((diffUp % 2) == 0) {\\n            diffUp = diffUp / 2;\\n        } else {\\n            if (diffUp < 0) {\\n                diffUp = (diffUp / 2) - 1;\\n            } else {\\n                diffUp = (diffUp / 2) + 1;\\n            }\\n        }\\n        if ((diffLeft % 2) == 0) {\\n            diffLeft = diffLeft / 2;\\n        } else {\\n            if (diffLeft < 0) {\\n                diffLeft = (diffLeft / 2) - 1;\\n            } else {\\n                diffLeft = (diffLeft / 2) + 1;\\n            }\\n        }\\n        boolean done = false;\\n        while (!done) {\\n            if ((diffUp % 2) == 0) {\\n                if ((diffLeft % 2) == 0) {\\n                    diffLeft = diffLeft / 2;\\n                    done = true;\\n                } else {\\n                                        if (((orDiffLeft % 2) == 0) && ((orDiffUp % 2) == 0)) {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2) > remainderLeft) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2) > -remainderLeft) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        } else if ((orDiffLeft > 0) && (orDiffUp == 0)) {\\n                            if (remainderUp > 0) {\\n                                                                if ((remainderUp * 2) > remainderLeft) {\\n                                    diffUp++;\\n                                } else {\\n                                    diffLeft++;\\n                                }\\n                            } else {\\n                                                                if ((-remainderUp * 2) > remainderLeft) {\\n                                    diffUp--;\\n                                } else {\\n                                    diffLeft++;\\n                                }\\n                            }\\n                        } else if (orDiffUp == 0) {\\n                            if (remainderUp > 0) {\\n                                                                if ((remainderUp * 2) > -remainderLeft) {\\n                                    diffUp++;\\n                                } else {\\n                                    diffLeft--;\\n                                }\\n                            } else {\\n                                                                if ((-remainderUp * 2) > -remainderLeft) {\\n                                    diffUp--;\\n                                } else {\\n                                    diffLeft--;\\n                                }\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2) > remainderLeft) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2) > -remainderLeft) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        }\\n                    } else if ((orDiffLeft % 2) == 0) {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        }\\n                    } else if ((orDiffUp % 2) == 0) {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        } else if ((orDiffLeft > 0) && (orDiffUp == 0)) {\\n                            if (remainderUp > 0) {\\n                                                                if ((remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                    diffUp++;\\n                                } else {\\n                                    diffLeft--;\\n                                }\\n                            } else {\\n                                                                if ((-remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                    diffUp--;\\n                                } else {\\n                                    diffLeft--;\\n                                }\\n                            }\\n                        } else if (orDiffUp == 0) {\\n                            if (remainderUp > 0) {\\n                                                                if ((remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                    diffUp++;\\n                                } else {\\n                                    diffLeft++;\\n                                }\\n                            } else {\\n                                                                if ((-remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                    diffUp--;\\n                                } else {\\n                                    diffLeft++;\\n                                }\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        }\\n                    } else {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2) > remainderLeft) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2) > -remainderLeft) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2) > remainderLeft) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2) > -remainderLeft) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        }\\n                    }\\n                }\\n            } else {\\n                if ((diffLeft % 2) == 0) {\\n                                        if (((orDiffLeft % 2) == 0) && ((orDiffUp % 2) == 0)) {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2) > remainderLeft) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2) > remainderLeft) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        } else if ((orDiffUp > 0) && (orDiffLeft == 0)) {\\n                            if (remainderLeft > 0) {\\n                                                                if ((remainderUp * 2) > remainderLeft) {\\n                                    diffUp++;\\n                                } else {\\n                                    diffLeft++;\\n                                }\\n                            } else {\\n                                                                if ((remainderUp * 2) > -remainderLeft) {\\n                                    diffUp++;\\n                                } else {\\n                                    diffLeft--;\\n                                }\\n                            }\\n                        } else if (orDiffLeft == 0) {\\n                            if (remainderLeft > 0) {\\n                                                                if ((-remainderUp * 2) > remainderLeft) {\\n                                    diffUp--;\\n                                } else {\\n                                    diffLeft++;\\n                                }\\n                            } else {\\n                                                                if ((-remainderUp * 2) > -remainderLeft) {\\n                                    diffUp--;\\n                                } else {\\n                                    diffLeft--;\\n                                }\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2) > -remainderLeft) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2) > -remainderLeft) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        }\\n                    } else if ((orDiffLeft % 2) == 0) {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        } else if ((orDiffUp > 0) && (orDiffLeft == 0)) {\\n                            if (remainderLeft > 0) {\\n                                                                if ((remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                    diffLeft++;\\n                                } else {\\n                                    diffUp--;\\n                                }\\n                            } else {\\n                                                                if ((remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                    diffLeft--;\\n                                } else {\\n                                    diffUp--;\\n                                }\\n                            }\\n                        } else if (orDiffLeft == 0) {\\n                            if (remainderLeft > 0) {\\n                                                                if ((-remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                    diffLeft++;\\n                                } else {\\n                                    diffUp++;\\n                                }\\n                            } else {\\n                                                                if ((-remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                    diffLeft--;\\n                                } else {\\n                                    diffUp++;\\n                                }\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        }\\n                    } else if ((orDiffUp % 2) == 0) {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        }\\n                    } else {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2) > remainderLeft) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2) > -remainderLeft) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2) > remainderLeft) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2) > -remainderLeft) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        }\\n                    }\\n                } else {\\n                    if ((focus.getY() % 2) == 0) {\\n                        if (diffLeft < 0) {\\n                            diffLeft = diffLeft / 2;\\n                        } else {\\n                            diffLeft = (diffLeft / 2) + 1;\\n                        }\\n                    } else {\\n                        if (diffLeft < 0) {\\n                            diffLeft = (diffLeft / 2) - 1;\\n                        } else {\\n                            diffLeft = diffLeft / 2;\\n                        }\\n                    }\\n                    done = true;\\n                }\\n            }\\n        }\\n        Position position = new Map.Position(focus.getX() - diffLeft, focus.getY() - diffUp);\\n        if (!freeColClient.getGame().getMap().isValid(position))\\n            return null;\\n        return freeColClient.getGame().getMap().getTile(position);\\n    }\\n    public Image createStringImage(Graphics g, String nameString, Color color, Font font) {\\n        if (color == null) {\\n            logger.warning(\\\"createStringImage called with color null\\\");\\n            color = Color.WHITE;\\n        }\\n                String key = \\\"dynamic.stringImage.\\\" + nameString\\n            + \\\".\\\" + font.getFontName().replace(' ', '-')\\n            + \\\".\\\" + Integer.toString(font.getSize())\\n            + \\\".\\\" + Integer.toHexString(color.getRGB());\\n        Image image = (Image) ResourceManager.getImage(key);        if (image != null) {\\n            return image;\\n        }\\n                FontMetrics fontMetrics = g.getFontMetrics(font);\\n        BufferedImage bi = new BufferedImage(fontMetrics.stringWidth(nameString) + 4,\\n                                             fontMetrics.getMaxAscent() + fontMetrics.getMaxDescent(),\\n                                             BufferedImage.TYPE_INT_ARGB);\\n                Graphics2D big = bi.createGraphics();\\n        big.setColor(color);\\n        big.setFont(font);\\n        big.drawString(nameString, 2, fontMetrics.getMaxAscent());\\n                int textColor = color.getRGB();\\n        int borderColor = getStringBorderColor(color).getRGB();\\n        for (int biX = 0; biX < bi.getWidth(); biX++) {\\n            for (int biY = 0; biY < bi.getHeight(); biY++) {\\n                int r = bi.getRGB(biX, biY);\\n                if (r == textColor) {\\n                    continue;\\n                }\\n                for (int cX = -1; cX <= 1; cX++) {\\n                    for (int cY = -1; cY <= 1; cY++) {\\n                        if (biX+cX >= 0 && biY+cY >= 0\\n                            && biX+cX < bi.getWidth() && biY+cY < bi.getHeight()\\n                            && bi.getRGB(biX + cX, biY + cY) == textColor) {\\n                            bi.setRGB(biX, biY, borderColor);\\n                            continue;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        ResourceManager.addGameMapping(key, new ImageResource(bi));\\n        return (Image) ResourceManager.getImage(key);    }\\n    public void display(Graphics2D g) {\\n        if ((freeColClient.getGame() != null)\\n                && (freeColClient.getGame().getMap() != null)\\n                && (focus != null)\\n                && freeColClient.isInGame()) {\\n            removeOldMessages();\\n            displayMap(g);\\n        } else {\\n            if (freeColClient.isMapEditor()) {\\n                g.setColor(Color.black);\\n                g.fillRect(0, 0, size.width, size.height);\\n            } else {\\n                Image bgImage = ResourceManager.getImage(\\\"CanvasBackgroundImage\\\", size);\\n                if (bgImage != null) {\\n                    g.drawImage(bgImage, 0, 0, gui.getCanvas());\\n                                        String versionStr = \\\"v. \\\" + FreeCol.getVersion();\\n                    Font oldFont = g.getFont();\\n                    Color oldColor = g.getColor();\\n                    Font newFont = oldFont.deriveFont(Font.BOLD);\\n                    TextLayout layout = new TextLayout(versionStr, newFont, g.getFontRenderContext());\\n                    Rectangle2D bounds = layout.getBounds();\\n                    float x = getWidth() - (float) bounds.getWidth() - 5;\\n                    float y = getHeight() - (float) bounds.getHeight();\\n                    g.setColor(Color.white);\\n                    layout.draw(g, x, y);\\n                                        g.setFont(oldFont);\\n                    g.setColor(oldColor);\\n                } else {\\n                    g.setColor(Color.black);\\n                    g.fillRect(0, 0, size.width, size.height);\\n                }\\n            }\\n        }\\n    }\\n    public void displayColonyTile(Graphics2D g, Tile tile, Colony colony) {\\n        boolean tileCannotBeWorked = false;\\n        Unit occupyingUnit = null;\\n        int price = 0;\\n        if (colony != null) {\\n            ColonyTile colonyTile = colony.getColonyTile(tile);\\n            occupyingUnit = colonyTile.getOccupyingUnit();\\n            price = colony.getOwner().getLandPrice(tile);\\n            switch (colonyTile.getNoWorkReason()) {\\n            case NONE: case COLONY_CENTER: case CLAIM_REQUIRED:\\n                break;\\n            default:\\n                tileCannotBeWorked = true;\\n            }\\n        }\\n        displayBaseTile(g, tile, false);\\n        displayTileOverlays(g, tile, false, false);\\n        if (tileCannotBeWorked) {\\n            g.drawImage(lib.getMiscImage(ImageLibrary.TILE_TAKEN), 0, 0, null);\\n        }\\n        if (price > 0 && tile.getSettlement() == null) {\\n                        Image image = lib.getMiscImage(ImageLibrary.TILE_OWNED_BY_INDIANS);\\n            centerImage(g, image);\\n        }\\n        if (occupyingUnit != null) {\\n            ImageIcon image = lib.getUnitImageIcon(occupyingUnit, 0.5);\\n            g.drawImage(image.getImage(), tileWidth/4 - image.getIconWidth() / 2,\\n                        halfHeight - image.getIconHeight() / 2, null);\\n                        g.drawImage(getOccupationIndicatorImage(g, occupyingUnit),\\n                        (int) (STATE_OFFSET_X * lib.getScalingFactor()), 0, null);\\n        }\\n    }\\n    public void displayTerrain(Graphics2D g, Tile tile) {\\n        displayBaseTile(g, tile, true);\\n        displayTileItems(g, tile);\\n    }\\n    public void executeWithUnitOutForAnimation(final Unit unit,\\n                                               final Tile sourceTile,\\n                                               final OutForAnimationCallback r) {\\n        final JLabel unitLabel = enterUnitOutForAnimation(unit, sourceTile);\\n        try {\\n            r.executeWithUnitOutForAnimation(unitLabel);\\n        } finally {\\n            releaseUnitOutForAnimation(unit);\\n        }\\n    }\\n    public void forceReposition() {\\n        bottomRow = -1;\\n    }\\n    public Unit getActiveUnit() {\\n        return activeUnit;\\n    }\\n    public TerrainCursor getCursor(){\\n        return cursor;\\n    }\\n    public Tile getFocus() {\\n        if (focus == null)\\n            return null;\\n        return focus;\\n    }\\n    public PathNode getGotoPath() {\\n        return gotoPath;\\n    }\\n    public int getHeight() {\\n        return size.height;\\n    }\\n    public float getMapScale() {\\n        return lib.getScalingFactor();\\n    }\\n    public Image getOccupationIndicatorImage(Graphics g, Unit unit) {\\n        Color backgroundColor = lib.getColor(unit.getOwner());\\n        Color foregroundColor = getForegroundColor(backgroundColor);\\n        String occupationString;\\n        if (!freeColClient.getMyPlayer().owns(unit)\\n                && unit.isNaval()) {\\n            occupationString = Integer.toString(unit.getVisibleGoodsCount());\\n        } else {\\n            if (unit.getDestination() != null) {\\n                if(unit.getTradeRoute() != null)\\n                    occupationString = \\\"model.unit.occupation.inTradeRoute\\\";\\n                else\\n                    occupationString = \\\"model.unit.occupation.goingSomewhere\\\";\\n            } else if (unit.getState() == Unit.UnitState.IMPROVING\\n                       && unit.getWorkImprovement() != null) {\\n                occupationString = unit.getWorkImprovement().getType().getId() + \\\".occupationString\\\";\\n            } else if (unit.getState() == Unit.UnitState.ACTIVE\\n                && unit.getMovesLeft() == 0) {\\n                if(unit.isUnderRepair())\\n                    occupationString = \\\"model.unit.occupation.underRepair\\\";\\n                else\\n                    occupationString = \\\"model.unit.occupation.activeNoMovesLeft\\\";\\n            } else {\\n                occupationString = \\\"model.unit.occupation.\\\" + unit.getState().toString().toLowerCase();\\n            }\\n            occupationString = Messages.message(occupationString);\\n            if (unit.getState() == Unit.UnitState.FORTIFIED)\\n                foregroundColor = Color.GRAY;\\n        }\\n                String key = \\\"dynamic.occupationIndicator.\\\" + occupationString\\n            + \\\".\\\" + Integer.toHexString(backgroundColor.getRGB());\\n        Image img = (Image) ResourceManager.getImage(key, lib.getScalingFactor());\\n        if (img == null) {\\n            img = lib.createChip(occupationString, Color.BLACK, backgroundColor, foregroundColor);\\n            ResourceManager.addGameMapping(key, new ImageResource(img));\\n        }\\n        return img;\\n    }\\n    public Tile getSelectedTile() {\\n        return selectedTile;\\n    }\\n    public Rectangle getTileBounds(Tile tile) {\\n        Rectangle result = new Rectangle(0, 0, size.width, size.height);\\n        if (isTileVisible(tile)) {\\n            result.x = ((tile.getX() - leftColumn) * tileWidth) + leftColumnX;\\n            result.y = ((tile.getY() - topRow) * halfHeight) + topRowY - tileHeight;\\n            if ((tile.getY() % 2) != 0) {\\n                result.x += halfWidth;\\n            }\\n            result.width = tileWidth;\\n            result.height = tileHeight * 2;\\n        }\\n        return result;\\n    }\\n    public int getTileHeight() {\\n        return tileHeight;\\n    }\\n    public Point getTilePosition(Tile t) {\\n        repositionMapIfNeeded();\\n        if (isTileVisible(t)) {\\n            int x = ((t.getX() - leftColumn) * tileWidth) + leftColumnX;\\n            int y = ((t.getY() - topRow) * halfHeight) + topRowY;\\n            if ((t.getY() % 2) != 0) {\\n                x += halfWidth;\\n            }\\n            return new Point(x, y);\\n        } else {\\n            return null;\\n        }\\n    }\\n    public int getTileWidth() {\\n        return tileWidth;\\n    }\\n    public Point getUnitLabelPositionInTile(JLabel unitLabel, Point tileP) {\\n        if (tileP != null) {\\n            int labelX = tileP.x + getTileWidth() / 2 - unitLabel.getWidth() / 2;\\n            int labelY = tileP.y + getTileHeight() / 2 - unitLabel.getHeight() / 2 -\\n                        (int) (UNIT_OFFSET * lib.getScalingFactor());\\n            return new Point(labelX, labelY);\\n        } else {\\n            return null;\\n        }\\n    }\\n    public ViewMode getViewMode(){\\n        return viewMode;\\n    }\\n    public int getWidth() {\\n        return size.width;\\n    }\\n    public boolean isGotoStarted() {\\n        return gotoStarted;\\n    }\\n    public boolean isMapNearBottom(int y) {\\n        return (y >= (freeColClient.getGame().getMap().getHeight() - bottomRows));\\n    }\\n    public boolean isMapNearLeft(int x, int y) {\\n        return (x < getLeftColumns(y));\\n    }\\n    public boolean isMapNearRight(int x, int y) {\\n        return (x >= (freeColClient.getGame().getMap().getWidth() - getRightColumns(y)));\\n    }\\n    public boolean isMapNearTop(int y) {\\n        return (y < topRows);\\n    }\\n    public void moveTileCursor(Direction direction) {\\n        if (selectedTile != null) {\\n            Tile newTile = selectedTile.getNeighbourOrNull(direction);\\n            if (newTile != null) setSelectedTile(newTile, false);\\n        } else {\\n            logger.warning(\\\"selectedTile is null\\\");\\n        }\\n    }\\n    public boolean onScreen(Tile tileToCheck) {\\n        repositionMapIfNeeded();\\n        return tileToCheck.getY() - 2 > topRow\\n            && tileToCheck.getY() + 4 < bottomRow\\n            && tileToCheck.getX() - 1 > leftColumn\\n            && tileToCheck.getX() + 2 < rightColumn;\\n    }\\n    public void restartBlinking() {\\n        blinkingMarqueeEnabled = true;\\n    }\\n    public boolean setActiveUnit(Unit activeUnit) {\\n                        boolean ret = false;\\n        if (activeUnit != null && !freeColClient.getMyPlayer().owns(activeUnit)) {\\n            gui.getCanvas().repaint(0, 0, getWidth(), getHeight());\\n            return ret;\\n        }\\n        if (activeUnit != null && activeUnit.getTile() == null) {\\n            activeUnit = null;\\n        }\\n        this.activeUnit = activeUnit;\\n        if (activeUnit != null) {\\n            if (freeColClient.currentPlayerIsMyPlayer()) {\\n                if (activeUnit.getState() != Unit.UnitState.ACTIVE) {\\n                    freeColClient.getInGameController().clearOrders(activeUnit);\\n                }\\n            } else {\\n                freeColClient.getInGameController().clearGotoOrders(activeUnit);\\n            }\\n        }\\n        updateGotoPathForActiveUnit();\\n                if (viewMode.getView() == ViewMode.VIEW_TERRAIN_MODE\\n            && activeUnit != null) {\\n            viewMode.changeViewMode(ViewMode.MOVE_UNITS_MODE);\\n        }\\n        if (activeUnit != null) {\\n            Tile tile = activeUnit.getTile();\\n            if (!setSelectedTile(tile, false)\\n                || freeColClient.getClientOptions()\\n                .getBoolean(ClientOptions.JUMP_TO_ACTIVE_UNIT)) {\\n                setFocus(tile);\\n                ret = true;\\n            }\\n        } else {\\n            freeColClient.getActionManager().update();\\n            gui.updateMenuBar();\\n            redrawMapControls();\\n        }\\n        return ret;\\n    }\\n    public void setFocus(Tile focus) {\\n        this.focus = focus;\\n        gui.refresh();\\n    }\\n    public void setFocusImmediately(Tile focus) {\\n        this.focus = focus;\\n        forceReposition();\\n        gui.getCanvas().paintImmediately(0, 0, getWidth(), getHeight());\\n    }\\n    public void setGotoPath(PathNode gotoPath) {\\n        this.gotoPath = gotoPath;\\n        gui.refresh();\\n    }\\n    public int setOffsetFocus(Tile tile) {\\n        int where = 0;\\n        if (tile != null) {\\n            positionMap(tile);\\n            Map map = freeColClient.getGame().getMap();\\n            if (leftColumn == 0) {\\n                where = -1;             } else if (rightColumn == map.getWidth() - 1) {\\n                where = 1;             } else {                 int x = tile.getX() - (tile.getX() - leftColumn) / 2;\\n                tile = map.getTile(x, tile.getY());\\n                where = 1;\\n            }\\n            setFocus(tile);\\n        }\\n        return where;\\n    }\\n    public boolean setSelectedTile(Tile newTileToSelect, boolean clearGoToOrders) {\\n        Tile oldTile = this.selectedTile;\\n        boolean ret = false;\\n        selectedTile = newTileToSelect;\\n        if (viewMode.getView() == ViewMode.MOVE_UNITS_MODE) {\\n            if (noActiveUnitIsAt(selectedTile)) {\\n                if (selectedTile != null && selectedTile.getSettlement() != null) {\\n                    Settlement s = selectedTile.getSettlement();\\n                    gui.getCanvas().showSettlement(s);\\n                    return ret;\\n                }\\n                                Unit unitInFront = getUnitInFront(selectedTile);\\n                if (unitInFront != null) {\\n                    ret = setActiveUnit(unitInFront);\\n                    updateGotoPathForActiveUnit();\\n                } else {\\n                    setFocus(selectedTile);\\n                    ret = true;\\n                }\\n            } else {\\n                                if (clearGoToOrders) {\\n                    freeColClient.getInGameController().clearGotoOrders(activeUnit);\\n                    updateGotoPathForActiveUnit();\\n                }\\n            }\\n        }\\n        freeColClient.getActionManager().update();\\n        gui.updateMenuBar();\\n        redrawMapControls();\\n                if (!onScreen(selectedTile) || freeColClient.getClientOptions()\\n            .getBoolean(ClientOptions.ALWAYS_CENTER)) {\\n            setFocus(selectedTile);\\n            ret = true;\\n        } else {\\n            if (oldTile != null) {\\n                gui.refreshTile(oldTile);\\n            }\\n            if (selectedTile != null) {\\n                gui.refreshTile(selectedTile);\\n            }\\n        }\\n        return ret;\\n    }\\n    public void setSize(Dimension size) {\\n        this.size = size;\\n        updateMapDisplayVariables();\\n    }\\n    public void startCursorBlinking() {\\n        ActionListener taskPerformer = new ActionListener() {\\n            public void actionPerformed(ActionEvent event) {\\n                if (!blinkingMarqueeEnabled)\\n                    return;\\n                if (getActiveUnit() != null && getActiveUnit().getTile() != null) {\\n                    Tile tile = getActiveUnit().getTile();\\n                    if (isTileVisible(tile)) {\\n                        gui.refreshTile(tile);\\n                    }\\n                }\\n            }\\n        };\\n        cursor.addActionListener(taskPerformer);\\n        cursor.startBlinking();\\n    }\\n    public void startGoto() {\\n        gotoStarted = true;\\n        gui.getCanvas().setCursor((java.awt.Cursor) UIManager.get(\\\"cursor.go\\\"));\\n        setGotoPath(null);\\n    }\\n    public void stopBlinking() {\\n        blinkingMarqueeEnabled = false;\\n    }\\n    public void stopGoto() {\\n        gui.getCanvas().setCursor(null);\\n        setGotoPath(null);\\n        updateGotoPathForActiveUnit();\\n        gotoStarted = false;\\n    }\\n    public void updateGotoPathForActiveUnit() {\\n        currentPath = (activeUnit == null\\n                       || activeUnit.getDestination() == null)\\n            ? null\\n            : (activeUnit.getDestination() instanceof Europe)\\n            ? activeUnit.findPathToEurope()\\n            : (activeUnit.getDestination().getTile() == activeUnit.getTile())\\n            ? null             : activeUnit.findPath(activeUnit.getDestination().getTile());\\n    }\\n    void scaleMap(float delta) {\\n        float newScale = lib.getScalingFactor() + delta;\\n        try {\\n            if (newScale >= 1f) {\\n                setImageLibrary(gui.getImageLibrary());\\n            } else {\\n                setImageLibrary(gui.getImageLibrary().getScaledImageLibrary(newScale));\\n            }\\n        } catch (Exception ex) {\\n            logger.warning(\\\"Failed to retrieve scaled image library.\\\");\\n        }\\n    }\\n    private void centerImage(Graphics2D g, Image image) {\\n        g.drawImage(image,\\n                    (tileWidth - image.getWidth(null))/2,\\n                    (tileHeight - image.getHeight(null))/2,\\n                    null);\\n    }\\n    private void centerString(Graphics2D g, String text) {\\n        g.setColor(Color.BLACK);\\n        g.setFont(ResourceManager.getFont(\\\"NormalFont\\\", 12f));\\n        g.drawString(text,\\n                     (tileWidth - g.getFontMetrics().stringWidth(text))/2,\\n                     (tileHeight - g.getFontMetrics().getAscent())/2);\\n    }\\n    private Image createCapitalLabel(int extent, int padding, Color backgroundColor) {\\n        String key = \\\"dynamic.label.nativeCapital\\\"\\n            + \\\".\\\" + Integer.toHexString(backgroundColor.getRGB());\\n        Image image = (Image) ResourceManager.getImage(key, lib.getScalingFactor());\\n        if (image != null) {\\n            return image;\\n        }\\n                double deg2rad = Math.PI/180.0;\\n        double angle = -90.0 * deg2rad;\\n        double offset = extent * 0.5;\\n        double size = (extent - padding - padding) * 0.5;\\n        GeneralPath path = new GeneralPath();\\n        path.moveTo(Math.cos(angle) * size + offset, Math.sin(angle) * size + offset);\\n        for (int i = 0; i < 4; i++) {\\n            angle += 144 * deg2rad;\\n            path.lineTo(Math.cos(angle) * size + offset, Math.sin(angle) * size + offset);\\n        }\\n        path.closePath();\\n                BufferedImage bi = new BufferedImage(extent, extent, BufferedImage.TYPE_INT_ARGB);\\n        Graphics2D g = bi.createGraphics();\\n        g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\\n        g.setColor(backgroundColor);\\n        g.fill(new RoundRectangle2D.Float(0, 0, extent, extent, padding, padding));\\n        g.setColor(Color.BLACK);\\n        g.setStroke(new BasicStroke(2.4f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));\\n        g.draw(path);\\n        g.setColor(Color.WHITE);\\n        g.fill(path);\\n        ResourceManager.addGameMapping(key, new ImageResource(bi));\\n        return (Image) ResourceManager.getImage(key, lib.getScalingFactor());\\n    }\\n    private Image createLabel(Graphics2D g, String text, Font font, Color backgroundColor) {\\n        TextSpecification[] specs = new TextSpecification[1];\\n        specs[0] = new TextSpecification(text, font);\\n        return createLabel(g, specs, backgroundColor);\\n    }\\n    private Image createLabel(Graphics2D g, TextSpecification[] textSpecs, Color backgroundColor) {\\n        int hPadding = 15;\\n        int vPadding = 10;\\n        int linePadding = 2;\\n        int width = 0;\\n        int height = vPadding;\\n        int i;\\n        TextSpecification spec;\\n        TextLayout[] labels = new TextLayout[textSpecs.length];\\n        TextLayout label;\\n        for (i = 0; i < textSpecs.length; i++) {\\n            spec = textSpecs[i];\\n            label = new TextLayout(spec.text, spec.font, g.getFontRenderContext());\\n            labels[i] = label;\\n            width = Math.max(width, (int) label.getBounds().getWidth() + hPadding);\\n            height += (int) (label.getAscent() + label.getDescent());\\n            if (i > 0) height += linePadding;\\n        }\\n        int radius = Math.min(hPadding, vPadding);\\n        BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\\n        Graphics2D g2 = bi.createGraphics();\\n        g2.scale(lib.getScalingFactor(), lib.getScalingFactor());\\n        g2.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\\n        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\\n        g2.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);\\n        g2.setColor(backgroundColor);\\n        g2.fill(new RoundRectangle2D.Float(0, 0, width, height, radius, radius));\\n        g2.setColor(getForegroundColor(backgroundColor));\\n        int offset = 0;\\n        for (i = 0; i < labels.length; i++) {\\n            if (i > 0) offset += labels[i - 1].getAscent() + linePadding + vPadding/2;\\n            labels[i].draw(g2, (float) (width - labels[i].getBounds().getWidth())/2,\\n                           offset + labels[i].getAscent() + vPadding/2);\\n        }\\n        return bi;\\n    }\\n    private Image createReligiousMissionLabel(int extent, int padding, Color backgroundColor, boolean expertMissionary) {\\n        String key = \\\"dynamic.label.religiousMission\\\"\\n            + (expertMissionary ? \\\".expert\\\" : \\\"\\\")\\n            + \\\".\\\" + Integer.toHexString(backgroundColor.getRGB());\\n        Image image = (Image) ResourceManager.getImage(key, lib.getScalingFactor());\\n        if (image != null) {\\n            return image;\\n        }\\n                double offset = extent * 0.5;\\n        double size = extent - padding - padding;\\n        double bar = size / 3.0;\\n        double inset = 0.0;\\n        double kludge = 0.0;\\n        GeneralPath circle = new GeneralPath();\\n        GeneralPath cross = new GeneralPath();\\n        if (expertMissionary) {\\n                        circle.append(new Ellipse2D.Double(padding-1, padding-1, size+1, size+1), false);\\n            inset = 4.0;\\n            bar = (size - inset - inset) / 3.0;\\n                        kludge = 1.0;\\n        }\\n        offset -= 1.0;\\n        cross.moveTo(offset, padding + inset - kludge);\\n        cross.lineTo(offset, extent - padding - inset);\\n        cross.moveTo(offset - bar, padding + bar + inset);\\n        cross.lineTo(offset + bar + 1, padding + bar + inset);\\n                BufferedImage bi = new BufferedImage(extent, extent, BufferedImage.TYPE_INT_ARGB);\\n        Graphics2D g = bi.createGraphics();\\n        g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\\n        g.setColor(backgroundColor);\\n        g.fill(new RoundRectangle2D.Float(0, 0, extent, extent, padding, padding));\\n        g.setColor(getForegroundColor(backgroundColor));\\n        if (expertMissionary) {\\n            g.setStroke(new BasicStroke(2.0f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));\\n            g.draw(circle);\\n            g.setStroke(new BasicStroke(1.6f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));\\n        } else {\\n            g.setStroke(new BasicStroke(2.4f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));\\n        }\\n        g.draw(cross);\\n        ResourceManager.addGameMapping(key, new ImageResource(bi));\\n        return (Image) ResourceManager.getImage(key, lib.getScalingFactor());\\n    }\\n    private void displayBaseTile(Graphics2D g, Tile tile, boolean drawUnexploredBorders) {\\n        if (tile != null) {\\n            int x = tile.getX();\\n            int y = tile.getY();\\n                        g.drawImage(lib.getTerrainImage(tile.getType(), x, y), 0, 0, null);\\n            if (tile.isExplored()) {\\n                if (!tile.isLand() && tile.getStyle() > 0) {\\n                    int edgeStyle = tile.getStyle() >> 4;\\n                    if (edgeStyle > 0) {\\n                        g.drawImage(lib.getBeachEdgeImage(edgeStyle, x, y), 0, 0, null);\\n                    }\\n                    int cornerStyle = tile.getStyle() & 15;\\n                    if (cornerStyle > 0) {\\n                        g.drawImage(lib.getBeachCornerImage(cornerStyle, x, y), 0, 0, null);\\n                    }\\n                }\\n                for (Direction direction : Direction.values()) {\\n                    Tile borderingTile = tile.getAdjacentTile(direction);\\n                    if (borderingTile != null) {\\n                        if (!drawUnexploredBorders && !borderingTile.isExplored() &&\\n                            (direction == Direction.SE || direction == Direction.S ||\\n                             direction == Direction.SW)) {\\n                            continue;\\n                        }\\n                        if (tile.getType() == borderingTile.getType()) {\\n                                                        continue;\\n                        } else if (tile.isLand() && !borderingTile.isLand()) {\\n                                                        continue;\\n                        } else if (!tile.isLand() && borderingTile.isLand() && borderingTile.isExplored()) {\\n                                                                                    g.drawImage(lib.getBorderImage(borderingTile.getType(), direction,\\n                                                           x, y), 0, 0, null);\\n                            TileImprovement river = borderingTile.getRiver();\\n                            if (river != null && (direction == Direction.SE || direction == Direction.SW ||\\n                                                  direction == Direction.NE || direction == Direction.NW)) {\\n                                int[] branches = river.getStyleBreakdown(Direction.longSides, 3);\\n                                if (branches[direction.getReverseDirection().ordinal()] > 0) {\\n                                    g.drawImage(lib.getRiverMouthImage(direction, borderingTile.getRiver()\\n                                                                       .getMagnitude(), x,\\n                                                                       y), 0, 0, null);\\n                                }\\n                            }\\n                        } else if (borderingTile.isExplored()) {\\n                            if (lib.getTerrainImage(tile.getType(), 0, 0)\\n                                .equals(lib.getTerrainImage(borderingTile.getType(), 0, 0))) {\\n                                                                continue;\\n                            } else if (borderingTile.getType().getIndex() < tile.getType().getIndex()) {\\n                                                                g.drawImage(lib.getBorderImage(borderingTile.getType(), direction,\\n                                                               x, y), 0, 0, null);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    private void displayFogOfWar(Graphics2D g, Tile tile) {\\n        if (freeColClient.getGame().getSpecification().getBoolean(GameOptions.FOG_OF_WAR)\\n            && freeColClient.getMyPlayer() != null\\n            && !freeColClient.getMyPlayer().canSee(tile)) {\\n            g.setColor(Color.BLACK);\\n            Composite oldComposite = g.getComposite();\\n            g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.2f));\\n            g.fill(fog);\\n            g.setComposite(oldComposite);\\n        }\\n    }\\n    private void displayGotoPath(Graphics2D g, PathNode gotoPath) {\\n        if (gotoPath != null) {\\n            PathNode temp = gotoPath;\\n            Font font = ResourceManager.getFont(\\\"NormalFont\\\", 12f);\\n            while (temp != null) {\\n                Point p = getTilePosition(temp.getTile());\\n                if (p != null) {\\n                    Tile tile = temp.getTile();\\n                    Image image;\\n                    final Color textColor;\\n                    if (temp.getTurns() == 0) {\\n                        g.setColor(Color.GREEN);\\n                        image = lib.getPathImage(activeUnit);\\n                        if (activeUnit != null\\n                                && tile.isExplored()\\n                                && activeUnit.isNaval()\\n                                && tile.isLand()\\n                                && (tile.getColony() == null || tile.getColony().getOwner() != activeUnit.getOwner())) {\\n                            image = lib.getPathImage(activeUnit.getFirstUnit());\\n                        }\\n                        textColor = Color.BLACK;\\n                    } else {\\n                        g.setColor(Color.RED);\\n                        image = lib.getPathNextTurnImage(activeUnit);\\n                        if (activeUnit != null\\n                                && tile.isExplored()\\n                                && activeUnit.isNaval()\\n                                && tile.isLand()\\n                                && (tile.getColony() == null || tile.getColony().getOwner() != activeUnit.getOwner())) {\\n                            image = lib.getPathNextTurnImage(activeUnit.getFirstUnit());\\n                        }\\n                        textColor = Color.WHITE;\\n                    }\\n                    g.translate(p.x, p.y);\\n                    if (image != null) {\\n                        centerImage(g, image);\\n                    } else {\\n                        g.fillOval(halfWidth, halfHeight, 10, 10);\\n                        g.setColor(Color.BLACK);\\n                        g.drawOval(halfWidth, halfHeight, 10, 10);\\n                    }\\n                    if (temp.getTurns() > 0) {\\n                        Image stringImage = createStringImage(g, Integer.toString(temp.getTurns()),\\n                                                              textColor, font);\\n                        centerImage(g, stringImage);\\n                    }\\n                    g.translate(-p.x, -p.y);\\n                }\\n                temp = temp.next;\\n            }\\n        }\\n    }\\n    private void displayMap(Graphics2D g) {\\n        AffineTransform originTransform = g.getTransform();\\n        Rectangle clipBounds = g.getClipBounds();\\n        Map map = freeColClient.getGame().getMap();\\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\\n                           RenderingHints.VALUE_ANTIALIAS_ON);\\n        repositionMapIfNeeded();\\n        int firstRow = (clipBounds.y - topRowY) / (halfHeight) - 1;\\n        int clipTopY = topRowY + firstRow * (halfHeight);\\n        firstRow = topRow + firstRow;\\n        int firstColumn = (clipBounds.x - leftColumnX) / tileWidth - 1;\\n        int clipLeftX = leftColumnX + firstColumn * tileWidth;\\n        firstColumn = leftColumn + firstColumn;\\n        int lastRow = (clipBounds.y + clipBounds.height - topRowY) / (halfHeight);\\n        lastRow = topRow + lastRow;\\n        int lastColumn = (clipBounds.x + clipBounds.width - leftColumnX) / tileWidth;\\n        lastColumn = leftColumn + lastColumn;\\n        if (freeColClient.getClientOptions().getBoolean(ClientOptions.DISPLAY_GRID)) {\\n            gridPath = new GeneralPath();\\n            gridPath.moveTo(0, 0);\\n            int nextX = halfWidth;\\n            int nextY = -halfHeight;\\n            for (int i = 0; i <= ((lastColumn - firstColumn) * 2 + 1); i++) {\\n                gridPath.lineTo(nextX, nextY);\\n                nextX += halfWidth;\\n                nextY = (nextY == 0 ? -halfHeight : 0);\\n            }\\n        }\\n        g.setColor(Color.black);\\n        g.fillRect(clipBounds.x, clipBounds.y, clipBounds.width, clipBounds.height);\\n        g.translate(clipLeftX, clipTopY);\\n        AffineTransform baseTransform = g.getTransform();\\n        AffineTransform rowTransform = null;\\n                for (int row = firstRow; row <= lastRow; row++) {\\n            rowTransform = g.getTransform();\\n            if (row % 2 == 1) {\\n                g.translate(halfWidth, 0);\\n            }\\n                        for (int column = firstColumn; column <= lastColumn; column++) {\\n                Tile tile = map.getTile(column, row);\\n                displayBaseTile(g, tile, true);\\n                g.translate(tileWidth, 0);\\n            }\\n            g.setTransform(rowTransform);\\n            g.translate(0, halfHeight);\\n        }\\n        g.setTransform(baseTransform);\\n        List<Unit> units = new ArrayList<Unit>();\\n        List<AffineTransform> unitTransforms = new ArrayList<AffineTransform>();\\n        List<Settlement> settlements = new ArrayList<Settlement>();\\n        List<AffineTransform> settlementTransforms = new ArrayList<AffineTransform>();\\n        int colonyLabels = freeColClient.getClientOptions().getInteger(ClientOptions.COLONY_LABELS);\\n        boolean withNumbers = (colonyLabels == ClientOptions.COLONY_LABELS_CLASSIC);\\n                for (int row = firstRow; row <= lastRow; row++) {\\n            rowTransform = g.getTransform();\\n            if (row % 2 == 1) {\\n                g.translate(halfWidth, 0);\\n            }\\n            if (freeColClient.getClientOptions().getBoolean(ClientOptions.DISPLAY_GRID)) {\\n                                g.translate(0, halfHeight);\\n                g.setStroke(gridStroke);\\n                g.setColor(Color.BLACK);\\n                g.draw(gridPath);\\n                g.translate(0, -halfHeight);\\n            }\\n                        for (int column = firstColumn; column <= lastColumn; column++) {\\n                Tile tile = map.getTile(column, row);\\n                                paintBorders(g, tile, BorderType.COUNTRY, true);\\n                                g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\\n                                   RenderingHints.VALUE_ANTIALIAS_OFF);\\n                displayTileOverlays(g, tile, true, withNumbers);\\n                g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\\n                                   RenderingHints.VALUE_ANTIALIAS_ON);\\n                                paintBorders(g, tile, BorderType.COUNTRY, false);\\n                if (viewMode.displayTileCursor(tile)) {\\n                    drawCursor(g);\\n                }\\n                                if (tile != null) {\\n                    Unit unitInFront = getUnitInFront(tile);\\n                    if (unitInFront != null && !isOutForAnimation(unitInFront)) {\\n                        units.add(unitInFront);\\n                        unitTransforms.add(g.getTransform());\\n                    }\\n                                        Settlement settlement = tile.getSettlement();\\n                    if (settlement != null) {\\n                        settlements.add(settlement);\\n                        settlementTransforms.add(g.getTransform());\\n                    }\\n                }\\n                g.translate(tileWidth, 0);\\n            }\\n            g.setTransform(rowTransform);\\n            g.translate(0, halfHeight);\\n        }\\n        g.setTransform(baseTransform);\\n        if (units.size() > 0) {\\n            g.setColor(Color.BLACK);\\n            final Image im = lib.getMiscImage(ImageLibrary.DARKNESS);\\n            for (int index = 0; index < units.size(); index++) {\\n                final Unit unit = units.get(index);\\n                g.setTransform(unitTransforms.get(index));\\n                if (unit.isUndead()) {\\n                                        centerImage(g, im);\\n                }\\n                displayUnit(g, unit);\\n            }\\n            g.setTransform(baseTransform);\\n        }\\n        if (settlements.size() > 0 && colonyLabels != ClientOptions.COLONY_LABELS_NONE) {\\n            Player clientPlayer = freeColClient.getMyPlayer();\\n            for (int index = 0; index < settlements.size(); index++) {\\n                final Settlement settlement = settlements.get(index);\\n                String name = Messages.message(settlement.getNameFor(clientPlayer));\\n                if (name != null) {\\n                    Color backgroundColor = lib.getColor(settlement.getOwner());\\n                    Font font = ResourceManager.getFont(\\\"NormalFont\\\", 18f);\\n                    Font productionFont = ResourceManager.getFont(\\\"NormalFont\\\", 12f);\\n                    int yOffset = tileHeight;\\n                    g.setTransform(settlementTransforms.get(index));\\n                    switch(colonyLabels) {\\n                    case ClientOptions.COLONY_LABELS_CLASSIC:\\n                        Image stringImage = createStringImage(g, name, backgroundColor, font);\\n                        g.drawImage(stringImage, (tileWidth - stringImage.getWidth(null))/2 + 1, yOffset, null);\\n                        break;\\n                    case ClientOptions.COLONY_LABELS_MODERN:\\n                    default:\\n                        backgroundColor = new Color(backgroundColor.getRed(), backgroundColor.getGreen(), backgroundColor.getBlue(), 128);\\n                        TextSpecification[] specs = new TextSpecification[1];\\n                        if (settlement instanceof Colony && settlement.getOwner() == clientPlayer) {\\n                            Colony colony = (Colony) settlement;\\n                            BuildableType buildable = colony.getCurrentlyBuilding();\\n                            if (buildable != null) {\\n                                specs = new TextSpecification[2];\\n                                String turnsStr = Messages.getTurnsText(colony.getTurnsToComplete(buildable));\\n                                String nowBuilding = Messages.message(buildable.getNameKey()) + \\\" \\\" + turnsStr;\\n                                specs[1] = new TextSpecification(nowBuilding, productionFont);\\n                            }\\n                        }\\n                        specs[0] = new TextSpecification(name, font);\\n                        Image nameImage = createLabel(g, specs, backgroundColor);\\n                        if (nameImage != null) {\\n                            int spacing = 3;\\n                            Image leftImage = null;\\n                            Image rightImage = null;\\n                            if (settlement instanceof Colony) {\\n                                String size = Integer.toString(((Colony) settlement).getDisplayUnitCount());\\n                                leftImage = createLabel(g, size, font, backgroundColor);\\n                                if (clientPlayer.owns(settlement)) {\\n                                    int bonusProduction = ((Colony) settlement).getProductionBonus();\\n                                    if (bonusProduction != 0) {\\n                                        String bonus = bonusProduction > 0 ? \\\"+\\\" + bonusProduction : Integer.toString(bonusProduction);\\n                                        rightImage = createLabel(g, bonus, font, backgroundColor);\\n                                    }\\n                                }\\n                            } else if (settlement instanceof IndianSettlement) {\\n                                IndianSettlement nativeSettlement = (IndianSettlement) settlement;\\n                                if (nativeSettlement.getType().isCapital()) {\\n                                    leftImage = createCapitalLabel(nameImage.getHeight(null), 5, backgroundColor);\\n                                }\\n                                Unit missionary = nativeSettlement.getMissionary();\\n                                if (missionary != null) {\\n                                    boolean expert = missionary.hasAbility(Ability.EXPERT_MISSIONARY);\\n                                    backgroundColor = lib.getColor(missionary.getOwner());\\n                                    backgroundColor = new Color(backgroundColor.getRed(), backgroundColor.getGreen(), backgroundColor.getBlue(), 128);\\n                                    rightImage = createReligiousMissionLabel(nameImage.getHeight(null), 5, backgroundColor, expert);\\n                                }\\n                            }\\n                            int width = (int) ((nameImage.getWidth(null)*lib.getScalingFactor())\\n                                + (leftImage != null ? (leftImage.getWidth(null)*lib.getScalingFactor()) + spacing : 0)\\n                                + (rightImage != null ? (rightImage.getWidth(null)*lib.getScalingFactor()) + spacing : 0));\\n                            int labelOffset = (tileWidth - width)/2;\\n                            yOffset -= (nameImage.getHeight(null)*lib.getScalingFactor())/2;\\n                            if (leftImage != null) {\\n                                g.drawImage(leftImage, labelOffset, yOffset, null);\\n                                labelOffset += (leftImage.getWidth(null)*lib.getScalingFactor()) + spacing;\\n                            }\\n                            g.drawImage(nameImage, labelOffset, yOffset, null);\\n                            if (rightImage != null) {\\n                                labelOffset += (nameImage.getWidth(null)*lib.getScalingFactor()) + spacing;\\n                                g.drawImage(rightImage, labelOffset, yOffset, null);\\n                            }\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        g.setTransform(originTransform);\\n        displayGotoPath(g, currentPath);\\n        displayGotoPath(g, gotoPath);\\n        Canvas canvas = gui.getCanvas();\\n        if (!freeColClient.isMapEditor()\\n            && freeColClient.getGame() != null\\n            && !freeColClient.currentPlayerIsMyPlayer()) {\\n            if (greyLayer == null) {\\n                greyLayer = new GrayLayer(lib);\\n            }\\n            if (greyLayer.getParent() == null) {                 canvas.add(greyLayer, JLayeredPane.DEFAULT_LAYER, false);\\n                canvas.moveToFront(greyLayer);\\n            }\\n            greyLayer.setBounds(0,0,canvas.getSize().width, canvas.getSize().height);\\n            greyLayer.setPlayer(freeColClient.getGame().getCurrentPlayer());\\n        }\\n        else {\\n            if (greyLayer != null && greyLayer.getParent() != null) {\\n                canvas.remove(greyLayer, false);\\n            }\\n        }\\n        if (getMessageCount() > 0) {\\n                        synchronized (this) {\\n                Font font = ResourceManager.getFont(\\\"NormalFont\\\", 12f);\\n                GUIMessage message = getMessage(0);\\n                Image si = createStringImage(g, message.getMessage(), message.getColor(), font);\\n                int yy = size.height - 300 - getMessageCount() * si.getHeight(null);\\n                int xx = 40;\\n                for (int i = 0; i < getMessageCount(); i++) {\\n                    message = getMessage(i);\\n                    g.drawImage(createStringImage(g, message.getMessage(), message.getColor(), font),\\n                                xx, yy, null);\\n                    yy += si.getHeight(null);\\n                }\\n            }\\n        }\\n        Image decoration = ResourceManager.getImage(\\\"menuborder.shadow.s.image\\\");\\n        int width = decoration.getWidth(null);\\n        for (int index = 0; index < size.width; index += width) {\\n            g.drawImage(decoration, index, 0, null);\\n        }\\n        decoration = ResourceManager.getImage(\\\"menuborder.shadow.sw.image\\\");\\n        g.drawImage(decoration, 0, 0, null);\\n        decoration = ResourceManager.getImage(\\\"menuborder.shadow.se.image\\\");\\n        g.drawImage(decoration, size.width - decoration.getWidth(null), 0, null);\\n    }\\n    private void displayOptionalValues(Graphics2D g, Tile tile) {\\n        String text = null;\\n        switch (freeColClient.getClientOptions().getInteger(ClientOptions.DISPLAY_TILE_TEXT)) {\\n        case ClientOptions.DISPLAY_TILE_TEXT_NAMES:\\n            if (tile.getNameKey() != null) {\\n                text = Messages.message(tile.getNameKey());\\n            }\\n            break;\\n        case ClientOptions.DISPLAY_TILE_TEXT_OWNERS:\\n            if (tile.getOwner() != null) {\\n                text = Messages.message(tile.getOwner().getNationName());\\n            }\\n            break;\\n        case ClientOptions.DISPLAY_TILE_TEXT_REGIONS:\\n            if (tile.getRegion() != null) {\\n                text = Messages.message(tile.getRegion().getLabel());\\n            }\\n            paintBorders(g, tile, BorderType.REGION, true);\\n            break;\\n        case ClientOptions.DISPLAY_TILE_TEXT_EMPTY:\\n            break;\\n        default:\\n            logger.warning(\\\"displayTileText out of range\\\");\\n            break;\\n        }\\n        if (text != null) {\\n            int b = Messages.getBreakingPoint(text);\\n            if (b == -1) {\\n                centerString(g, text);\\n            } else {\\n                g.setColor(Color.BLACK);\\n                g.setFont(ResourceManager.getFont(\\\"NormalFont\\\", 12f));\\n                g.drawString(text.substring(0, b),\\n                             (tileWidth -\\n                              g.getFontMetrics().stringWidth(text.substring(0, b)))/2,\\n                             halfHeight - (g.getFontMetrics().getAscent()*2)/3);\\n                g.drawString(text.substring(b+1),\\n                             (tileWidth -\\n                              g.getFontMetrics().stringWidth(text.substring(b+1)))/2,\\n                             halfHeight + (g.getFontMetrics().getAscent()*2)/3);\\n            }\\n        }\\n        if (displayCoordinates) {\\n            String posString = tile.getX() + \\\", \\\" + tile.getY();\\n            if (tile.isConnected()) {\\n                posString += \\\"C\\\";\\n            }\\n            centerString(g, posString);\\n        }\\n        if (displayColonyValue && tile.isExplored() && tile.isLand()) {\\n            String valueString;\\n            if (displayColonyValuePlayer == null) {\\n                valueString = Integer.toString(freeColClient.getGame().getCurrentPlayer().getOutpostValue(tile));\\n            } else {\\n                valueString = Integer.toString(displayColonyValuePlayer.getColonyValue(tile));\\n            }\\n            centerString(g, valueString);\\n        }\\n    }\\n    private void displaySettlement(Graphics2D g, Tile tile, boolean withNumber) {\\n        Settlement settlement = tile.getSettlement();\\n        if (settlement != null) {\\n            if (settlement instanceof Colony) {\\n                Image colonyImage = lib.getSettlementImage(settlement);\\n                                centerImage(g, colonyImage);\\n                if (withNumber) {\\n                    String populationString = Integer.toString(((Colony)settlement).getDisplayUnitCount());\\n                    int bonus = ((Colony)settlement).getProductionBonus();\\n                    Color theColor = ResourceManager.getProductionColor(bonus);\\n                    Font font = ResourceManager.getFont(\\\"SimpleFont\\\", Font.BOLD, 12f);\\n                    Image stringImage = createStringImage(g, populationString, theColor, font);\\n                    centerImage(g, stringImage);\\n                }\\n                            } else if (settlement instanceof IndianSettlement) {\\n                IndianSettlement indianSettlement = (IndianSettlement) settlement;\\n                Image settlementImage = lib.getSettlementImage(settlement);\\n                                centerImage(g, settlementImage);\\n                String text = null;\\n                Image chip = null;\\n                Color background = lib.getColor(indianSettlement.getOwner());\\n                Color foreground = getForegroundColor(background);\\n                float xOffset = STATE_OFFSET_X * lib.getScalingFactor();\\n                float yOffset = STATE_OFFSET_Y * lib.getScalingFactor();\\n                int colonyLabels = freeColClient.getClientOptions().getInteger(ClientOptions.COLONY_LABELS);\\n                if (colonyLabels != ClientOptions.COLONY_LABELS_MODERN) {\\n                                        text = indianSettlement.getType().isCapital() ? \\\"*\\\" : \\\"-\\\";\\n                    chip = lib.createChip(text, Color.BLACK, background, foreground);\\n                    g.drawImage(chip, (int) xOffset, (int) yOffset, null);\\n                    xOffset += chip.getWidth(null) + 2;\\n                                        Unit missionary = indianSettlement.getMissionary();\\n                    if (missionary != null) {\\n                        boolean expert = missionary.hasAbility(Ability.EXPERT_MISSIONARY);\\n                        Color mission = (expert ? Color.BLACK : Color.GRAY);\\n                        Color cross = lib.getColor(missionary.getOwner());\\n                        chip = lib.createChip(\\\"\\\\u271D\\\", Color.BLACK, mission, cross);\\n                        g.drawImage(chip, (int) xOffset, (int) yOffset, null);\\n                        xOffset += chip.getWidth(null) + 2;\\n                    }\\n                }\\n                                Player player = freeColClient.getMyPlayer();\\n                if (player != null && indianSettlement.hasContactedSettlement(player)) {\\n                    final boolean visited = indianSettlement.hasSpokenToChief(player);\\n                    chip = lib.createChip((visited ? \\\"!\\\" : \\\"?\\\"), Color.BLACK, background, foreground);\\n                    g.drawImage(chip, (int) xOffset, (int) yOffset, null);\\n                }\\n            } else {\\n                logger.warning(\\\"Requested to draw unknown settlement type.\\\");\\n            }\\n        }\\n    }\\n    private void displayTileItems(Graphics2D g, Tile tile) {\\n                        if (!tile.isExplored()) {\\n            g.drawImage(lib.getTerrainImage(null, tile.getX(), tile.getY()), 0, 0, null);\\n        } else {\\n                        List<TileItem> tileItems = new ArrayList<TileItem>();\\n            if (tile.getTileItemContainer() != null) {\\n                tileItems = tile.getTileItemContainer().getTileItems();\\n            }\\n            int startIndex = 0;\\n            for (int index = startIndex; index < tileItems.size(); index++) {\\n                if (tileItems.get(index).getZIndex() < OVERLAY_INDEX) {\\n                    drawItem(g, tile, tileItems.get(index));\\n                    startIndex = index + 1;\\n                } else {\\n                    startIndex = index;\\n                    break;\\n                }\\n            }\\n                        Image overlayImage = lib.getOverlayImage(tile.getType(), tile.getX(), tile.getY());\\n            if (overlayImage != null) {\\n                g.drawImage(overlayImage, 0, (tileHeight - overlayImage.getHeight(null)), null);\\n            }\\n            for (int index = startIndex; index < tileItems.size(); index++) {\\n                if (tileItems.get(index).getZIndex() < FOREST_INDEX) {\\n                    drawItem(g, tile, tileItems.get(index));\\n                    startIndex = index + 1;\\n                } else {\\n                    startIndex = index;\\n                    break;\\n                }\\n            }\\n                        if (tile.isForested()) {\\n                Image forestImage = lib.getForestImage(tile.getType());\\n                g.drawImage(forestImage, 0, (tileHeight - forestImage.getHeight(null)), null);\\n            }\\n                        for (int index = startIndex; index < tileItems.size(); index++) {\\n                drawItem(g, tile, tileItems.get(index));\\n            }\\n        }\\n    }\\n    private void displayTileOverlays(Graphics2D g, Tile tile,\\n                                     boolean drawUnexploredBorders, boolean withNumber) {\\n        if (tile != null && tile.isExplored()) {\\n            if (drawUnexploredBorders) {\\n                for (Direction direction : Direction.values()) {\\n                    Tile borderingTile = tile.getAdjacentTile(direction);\\n                    if (borderingTile != null && !borderingTile.isExplored()){\\n                        g.drawImage(lib.getBorderImage(null, direction, tile.getX(), tile.getY()), 0, 0, null);\\n                    }\\n                }\\n            }\\n            displayTileItems(g, tile);\\n            displaySettlement(g, tile, withNumber);\\n            displayFogOfWar(g, tile);\\n            displayOptionalValues(g, tile);\\n        }\\n    }\\n    private void displayUnit(Graphics2D g, Unit unit) {\\n        try {\\n                                    if (viewMode.displayUnitCursor(unit)) {\\n                drawCursor(g);\\n            }\\n                                    boolean fade = (unit.getState() == Unit.UnitState.SENTRY)\\n                || (unit.getTile() != null\\n                    && !freeColClient.getMyPlayer().canSee(unit.getTile()));\\n            Image image = lib.getUnitImageIcon(unit, fade).getImage();\\n            Point p = getUnitImagePositionInTile(image);\\n            g.drawImage(image, p.x, p.y, null);\\n                        g.drawImage(getOccupationIndicatorImage(g, unit),\\n                        (int) (STATE_OFFSET_X * lib.getScalingFactor()), 0, null);\\n                        int unitsOnTile = 0;\\n            if (unit.getTile() != null) {\\n                                                                unitsOnTile = unit.getTile().getTotalUnitCount();\\n            }\\n            if (unitsOnTile > 1) {\\n                g.setColor(Color.WHITE);\\n                int unitLinesY = OTHER_UNITS_OFFSET_Y;\\n                int x1 = (int) ((STATE_OFFSET_X + OTHER_UNITS_OFFSET_X) * lib.getScalingFactor());\\n                int x2 = (int) ((STATE_OFFSET_X + OTHER_UNITS_OFFSET_X + OTHER_UNITS_WIDTH) * lib.getScalingFactor());\\n                for (int i = 0; (i < unitsOnTile) && (i < MAX_OTHER_UNITS); i++) {\\n                    g.drawLine(x1, unitLinesY, x2, unitLinesY);\\n                    unitLinesY += 2;\\n                }\\n            }\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n                if (debugShowMission\\n            && freeColClient.getFreeColServer() != null\\n            && (unit.getOwner().isAI()\\n                || unit.hasAbility(Ability.PIRACY))) {\\n            net.sf.freecol.server.ai.AIUnit au = freeColClient\\n                .getFreeColServer().getAIMain().getAIUnit(unit);\\n            if (au != null) {\\n                g.setColor(Color.WHITE);\\n                String text = (unit.getOwner().isAI()) ? \\\"\\\" : \\\"(\\\";\\n                String debuggingInfo = \\\"\\\";\\n                if (au.getMission() != null) {\\n                    String missionName = au.getMission().getClass().toString();\\n                    missionName = missionName.substring(missionName.lastIndexOf('.') + 1);\\n                    text += missionName;\\n                    if (debugShowMissionInfo) {\\n                        debuggingInfo = au.getMission().getDebuggingInfo();\\n                    }\\n                } else {\\n                    text += \\\"No mission\\\";\\n                }\\n                text += (unit.getOwner().isAI()) ? \\\"\\\" : \\\")\\\";\\n                g.drawString(text, 0 , 0);\\n                g.drawString(debuggingInfo, 0 , 25);\\n            }\\n        }\\n    }\\n    private void drawCursor(Graphics2D g) {\\n        g.drawImage(cursorImage, 0, 0, null);\\n    }\\n    private void drawItem(Graphics2D g, Tile tile, TileItem item) {\\n        if (item instanceof Resource) {\\n            Image bonusImage = lib.getBonusImage(((Resource) item).getType());\\n            if (bonusImage != null) {\\n                centerImage(g, bonusImage);\\n            }\\n        } else if (item instanceof LostCityRumour) {\\n            centerImage(g, lib.getMiscImage(ImageLibrary.LOST_CITY_RUMOUR));\\n        } else {\\n            TileImprovement improvement = (TileImprovement) item;\\n            if (improvement.isComplete()) {\\n                String key = improvement.getType().getId() + \\\".image\\\";\\n                if (ResourceManager.hasResource(key)) {\\n                                        Image overlay = ResourceManager.getImage(key, lib.getScalingFactor());\\n                    g.drawImage(overlay, 0, 0, null);\\n                } else if (improvement.isRiver() && improvement.getMagnitude() < TileImprovement.FJORD_RIVER) {\\n                    g.drawImage(lib.getRiverImage(improvement.getStyle()), 0, 0, null);\\n                } else if (improvement.isRoad()) {\\n                    drawRoad(g, tile);\\n                }\\n            }\\n        }\\n    }\\n    private void drawRoad(Graphics2D g, Tile tile) {\\n        Color oldColor = g.getColor();\\n        g.setColor(ResourceManager.getColor(\\\"road.color\\\"));\\n        g.setStroke(roadStroke);\\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\\n        GeneralPath path = new GeneralPath();\\n        List<Point2D.Float> points = new ArrayList<Point2D.Float>(8);\\n        List<Direction> directions = new ArrayList<Direction>(8);\\n        for (Direction direction : Direction.values()) {\\n            Tile borderingTile = tile.getAdjacentTile(direction);\\n            TileImprovement r;\\n            if (borderingTile != null\\n                && (r = borderingTile.getRoad()) != null\\n                && r.isComplete()) {\\n                points.add(corners.get(direction));\\n                directions.add(direction);\\n            }\\n        }\\n        switch(points.size()) {\\n        case 0:\\n            path.moveTo(0.35f * tileWidth, 0.35f * tileHeight);\\n            path.lineTo(0.65f * tileWidth, 0.65f * tileHeight);\\n            path.moveTo(0.35f * tileWidth, 0.65f * tileHeight);\\n            path.lineTo(0.65f * tileWidth, 0.35f * tileHeight);\\n            break;\\n        case 1:\\n            path.moveTo(halfWidth, halfHeight);\\n            path.lineTo(points.get(0).getX(), points.get(0).getY());\\n            break;\\n        case 2:\\n            path.moveTo(points.get(0).getX(), points.get(0).getY());\\n            path.quadTo(halfWidth, halfHeight, points.get(1).getX(), points.get(1).getY());\\n            break;\\n        case 3:\\n        case 4: {\\n            Direction pen = directions.get(directions.size() - 1);\\n            Point2D p = corners.get(pen);\\n            path.moveTo(p.getX(), p.getY());\\n            for (Direction d : directions) {\\n                p = corners.get(d);\\n                if(prohibitedRoads.get(pen).contains(d)) {\\n                    path.moveTo(p.getX(), p.getY());\\n                } else {\\n                    path.quadTo(halfWidth, halfHeight, p.getX(), p.getY());\\n                }\\n                pen = d;\\n            }\\n            break;\\n        }\\n        default:\\n            for (Point2D p : points) {\\n                path.moveTo(halfWidth, halfHeight);\\n                path.lineTo(p.getX(), p.getY());\\n            }\\n        }\\n        g.draw(path);\\n        g.setColor(oldColor);\\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);\\n    }\\n    private JLabel enterUnitOutForAnimation(final Unit unit, final Tile sourceTile) {\\n        Integer i = unitsOutForAnimation.get(unit);\\n        if (i == null) {\\n            final JLabel unitLabel = getUnitLabel(unit);\\n            final Integer UNIT_LABEL_LAYER = JLayeredPane.DEFAULT_LAYER;\\n            i = 1;\\n            unitLabel.setLocation(getUnitLabelPositionInTile(unitLabel,\\n                    getTilePosition(sourceTile)));\\n            unitsOutForAnimationLabels.put(unit, unitLabel);\\n            gui.getCanvas().add(unitLabel, UNIT_LABEL_LAYER, false);\\n        } else {\\n            i++;\\n        }\\n        unitsOutForAnimation.put(unit, i);\\n        return unitsOutForAnimationLabels.get(unit);\\n    }\\n    private Color getForegroundColor(Color background) {\\n        if (background.getRed() * 0.3\\n                + background.getGreen() * 0.59\\n                + background.getBlue() * 0.11 < 126) {\\n            return Color.WHITE;\\n        } else {\\n            return Color.BLACK;\\n        }\\n    }\\n    private int getLeftColumns() {\\n        return getLeftColumns(focus.getY());\\n    }\\n    private int getLeftColumns(int y) {\\n        int leftColumns = leftSpace / tileWidth + 1;\\n        if ((y % 2) == 0) {\\n            if ((leftSpace % tileWidth) > 32) {\\n                leftColumns++;\\n            }\\n        } else {\\n            if ((leftSpace % tileWidth) == 0) {\\n                leftColumns--;\\n            }\\n        }\\n        return leftColumns;\\n    }\\n    private GUIMessage getMessage(int index) {\\n        return messages.get(index);\\n    }\\n    private int getMessageCount() {\\n        return messages.size();\\n    }\\n    private int getRightColumns() {\\n        return getRightColumns(focus.getY());\\n    }\\n    private int getRightColumns(int y) {\\n        int rightColumns = rightSpace / tileWidth + 1;\\n        if ((y % 2) == 0) {\\n            if ((rightSpace % tileWidth) == 0) {\\n                rightColumns--;\\n            }\\n        } else {\\n            if ((rightSpace % tileWidth) > 32) {\\n                rightColumns++;\\n            }\\n        }\\n        return rightColumns;\\n    }\\n    private Color getStringBorderColor(Color color) {\\n        if (color.getRed() * 0.3\\n                + color.getGreen() * 0.59\\n                + color.getBlue() * 0.11 < 10) {\\n            return Color.WHITE;\\n        } else {\\n            return Color.BLACK;\\n        }\\n    }\\n    private Point getUnitImagePositionInTile(Image unitImage) {\\n        int unitX = (tileWidth - unitImage.getWidth(null)) / 2;\\n        int unitY = (tileHeight - unitImage.getHeight(null)) / 2 -\\n                    (int) (UNIT_OFFSET * lib.getScalingFactor());\\n        return new Point(unitX, unitY);\\n    }\\n    private Unit getUnitInFront(Tile unitTile) {\\n        if (unitTile == null || unitTile.getUnitCount() <= 0) {\\n            return null;\\n        }\\n        if (activeUnit != null && activeUnit.getTile() == unitTile) {\\n            return activeUnit;\\n        } else {\\n            if (unitTile.getSettlement() == null) {\\n                Unit bestDefendingUnit = null;\\n                if (activeUnit != null) {\\n                    bestDefendingUnit = unitTile.getDefendingUnit(activeUnit);\\n                    if (bestDefendingUnit != null) {\\n                        return bestDefendingUnit;\\n                    }\\n                }\\n                Unit movableUnit = unitTile.getMovableUnit();\\n                if (movableUnit != null && movableUnit.getLocation() == movableUnit.getTile()) {\\n                    return movableUnit;\\n                } else {\\n                    Unit bestPick = null;\\n                    Iterator<Unit> unitIterator = unitTile.getUnitIterator();\\n                    while (unitIterator.hasNext()) {\\n                        Unit u = unitIterator.next();\\n                        if (bestPick == null || bestPick.getMovesLeft() < u.getMovesLeft()) {\\n                            bestPick = u;\\n                        }\\n                    }\\n                    return bestPick;\\n                }\\n            } else {\\n                return null;\\n            }\\n        }\\n    }\\n    private JLabel getUnitLabel(Unit unit) {\\n        final Image unitImg = lib.getUnitImageIcon(unit).getImage();\\n        final int width = halfWidth + unitImg.getWidth(null)/2;\\n        final int height = unitImg.getHeight(null);\\n        BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\\n        Graphics g = img.getGraphics();\\n        final int unitX = (width - unitImg.getWidth(null)) / 2;\\n        g.drawImage(unitImg, unitX, 0, null);\\n        final JLabel label = new JLabel(new ImageIcon(img));\\n        label.setSize(width, height);\\n        return label;\\n    }\\n    private boolean isOutForAnimation(final Unit unit) {\\n        return unitsOutForAnimation.containsKey(unit);\\n    }\\n    private boolean isTileVisible(Tile tile) {\\n        return tile.getY() >= topRow && tile.getY() <= bottomRow\\n            && tile.getX() >= leftColumn && tile.getX() <= rightColumn;\\n    }\\n    private boolean noActiveUnitIsAt(Tile selectedTile) {\\n        return activeUnit == null ||\\n            (activeUnit.getTile() != null &&\\n             !activeUnit.getTile().equals(selectedTile));\\n    }\\n    private void paintBorders(Graphics2D g, Tile tile, BorderType type, boolean opaque) {\\n        if (tile == null ||\\n            (type == BorderType.COUNTRY\\n             && !freeColClient.getClientOptions().getBoolean(ClientOptions.DISPLAY_BORDERS))) {\\n            return;\\n        }\\n        Player owner = tile.getOwner();\\n        Region region = tile.getRegion();\\n        if ((type == BorderType.COUNTRY && owner != null)\\n            || (type == BorderType.REGION && region != null)) {\\n            Stroke oldStroke = g.getStroke();\\n            g.setStroke(borderStroke);\\n            Color oldColor = g.getColor();\\n            Color newColor = Color.WHITE;\\n            if (type == BorderType.COUNTRY) {\\n                newColor = new Color(lib.getColor(owner).getRed(),\\n                                     lib.getColor(owner).getGreen(),\\n                                     lib.getColor(owner).getBlue(),\\n                                     opaque ? 255 : 100);\\n            }\\n            g.setColor(newColor);\\n            GeneralPath path = new GeneralPath(GeneralPath.WIND_EVEN_ODD);\\n            path.moveTo(borderPoints.get(Direction.longSides[0]).x,\\n                        borderPoints.get(Direction.longSides[0]).y);\\n            for (Direction d : Direction.longSides) {\\n                Tile otherTile = tile.getNeighbourOrNull(d);\\n                Direction next = d.getNextDirection();\\n                Direction next2 = next.getNextDirection();\\n                if (otherTile == null\\n                    || (type == BorderType.COUNTRY && !owner.owns(otherTile))\\n                    || (type == BorderType.REGION && otherTile.getRegion() != region)) {\\n                    Tile tile1 = tile.getNeighbourOrNull(next);\\n                    Tile tile2 = tile.getNeighbourOrNull(next2);\\n                    if (tile2 == null\\n                        || (type == BorderType.COUNTRY && !owner.owns(tile2))\\n                        || (type == BorderType.REGION && tile2.getRegion() != region)) {\\n                                                path.lineTo(borderPoints.get(next).x,\\n                                    borderPoints.get(next).y);\\n                        path.quadTo(controlPoints.get(next).x,\\n                                    controlPoints.get(next).y,\\n                                    borderPoints.get(next2).x,\\n                                    borderPoints.get(next2).y);\\n                    } else {\\n                        int dx = 0, dy = 0;\\n                        switch(d) {\\n                        case NW: dx = halfWidth; dy = -halfHeight; break;\\n                        case NE: dx = halfWidth; dy = halfHeight; break;\\n                        case SE: dx = -halfWidth; dy = halfHeight; break;\\n                        case SW: dx = -halfWidth; dy = -halfHeight; break;\\n                        }\\n                        if (tile1 != null\\n                            && ((type == BorderType.COUNTRY && owner.owns(tile1))\\n                                || (type == BorderType.REGION && tile1.getRegion() == region))) {\\n                                                        path.lineTo(borderPoints.get(next).x,\\n                                        borderPoints.get(next).y);\\n                                                        Direction previous = d.getPreviousDirection();\\n                            Direction previous2 = previous.getPreviousDirection();\\n                            int ddx = 0, ddy = 0;\\n                            switch(d) {\\n                            case NW: ddy = -tileHeight; break;\\n                            case NE: ddx = tileWidth; break;\\n                            case SE: ddy = tileHeight; break;\\n                            case SW: ddx = -tileWidth; break;\\n                            }\\n                            path.quadTo(controlPoints.get(previous).x + dx,\\n                                        controlPoints.get(previous).y + dy,\\n                                        borderPoints.get(previous2).x + ddx,\\n                                        borderPoints.get(previous2).y + ddy);\\n                        } else {\\n                                                        path.lineTo(borderPoints.get(d).x + dx,\\n                                        borderPoints.get(d).y + dy);\\n                        }\\n                    }\\n                } else {\\n                    path.moveTo(borderPoints.get(next2).x,\\n                                borderPoints.get(next2).y);\\n                }\\n            }\\n            g.draw(path);\\n            g.setColor(oldColor);\\n            g.setStroke(oldStroke);\\n        }\\n    }\\n    private void positionMap(Tile pos) {\\n        Game gameData = freeColClient.getGame();\\n        int x = pos.getX(),\\n            y = pos.getY();\\n        int leftColumns = getLeftColumns(),\\n            rightColumns = getRightColumns();\\n        if (y < topRows) {\\n                        bottomRow = (size.height / (halfHeight)) - 1;\\n            if ((size.height % (halfHeight)) != 0) {\\n                bottomRow++;\\n            }\\n            topRow = 0;\\n            bottomRowY = bottomRow * (halfHeight);\\n            topRowY = 0;\\n        } else if (y >= (gameData.getMap().getHeight() - bottomRows)) {\\n                        bottomRow = gameData.getMap().getHeight() - 1;\\n            topRow = size.height / (halfHeight);\\n            if ((size.height % (halfHeight)) > 0) {\\n                topRow++;\\n            }\\n            topRow = gameData.getMap().getHeight() - topRow;\\n            bottomRowY = size.height - tileHeight;\\n            topRowY = bottomRowY - (bottomRow - topRow) * (halfHeight);\\n        } else {\\n                        bottomRow = y + bottomRows;\\n            topRow = y - topRows;\\n            bottomRowY = topSpace + (halfHeight) * bottomRows;\\n            topRowY = topSpace - topRows * (halfHeight);\\n        }\\n        if (x < leftColumns) {\\n                        leftColumn = 0;\\n            rightColumn = size.width / tileWidth - 1;\\n            if ((size.width % tileWidth) > 0) {\\n                rightColumn++;\\n            }\\n            leftColumnX = 0;\\n        } else if (x >= (gameData.getMap().getWidth() - rightColumns)) {\\n                        rightColumn = gameData.getMap().getWidth() - 1;\\n            leftColumn = size.width / tileWidth;\\n            if ((size.width % tileWidth) > 0) {\\n                leftColumn++;\\n            }\\n            leftColumnX = size.width - tileWidth - halfWidth -\\n                leftColumn * tileWidth;\\n            leftColumn = rightColumn - leftColumn;\\n        } else {\\n                        leftColumn = x - leftColumns;\\n            rightColumn = x + rightColumns;\\n            leftColumnX = (size.width - tileWidth) / 2 - leftColumns * tileWidth;\\n        }\\n    }\\n    private void redrawMapControls() {\\n        int x = 0, y = 0;\\n        MapControls mapControls = gui.getCanvas().getMapControls();\\n        if (mapControls != null) {\\n            x = getWidth() - mapControls.getInfoPanelWidth();\\n            y = getHeight() - mapControls.getInfoPanelHeight();\\n        }\\n        gui.getCanvas().repaint(x, y, getWidth(), getHeight());\\n    }\\n    private void releaseUnitOutForAnimation(final Unit unit) {\\n        Integer i = unitsOutForAnimation.get(unit);\\n        if (i == null) {\\n            throw new IllegalStateException(\\\"Tried to release unit that was not out for animation\\\");\\n        }\\n        if (i == 1) {\\n            unitsOutForAnimation.remove(unit);\\n            gui.getCanvas().remove(unitsOutForAnimationLabels.remove(unit), false);\\n        } else {\\n            i--;\\n            unitsOutForAnimation.put(unit, i);\\n        }\\n    }\\n    private synchronized boolean removeOldMessages() {\\n        long currentTime = new Date().getTime();\\n        boolean result = false;\\n        int i = 0;\\n        while (i < getMessageCount()) {\\n            long messageCreationTime = getMessage(i).getCreationTime().getTime();\\n            if ((currentTime - messageCreationTime) >= MESSAGE_AGE) {\\n                result = true;\\n                messages.remove(i);\\n            } else {\\n                i++;\\n            }\\n        }\\n        return result;\\n    }\\n    private void repositionMapIfNeeded() {\\n        if (bottomRow < 0 && focus != null)\\n            positionMap(focus);\\n    }\\n    private void setImageLibrary(ImageLibrary lib) {\\n        this.lib = lib;\\n        cursorImage = lib.getMiscImage(ImageLibrary.UNIT_SELECT);\\n                tileHeight = lib.getTerrainImageHeight(null);\\n        halfHeight = tileHeight/2;\\n        tileWidth = lib.getTerrainImageWidth(null);\\n        halfWidth = tileWidth/2;\\n        int dx = tileWidth/16;\\n        int dy = tileHeight/16;\\n        int ddx = dx + dx/2;\\n        int ddy = dy + dy/2;\\n                corners.put(Direction.N,  new Point2D.Float(halfWidth, 0));\\n        corners.put(Direction.NE, new Point2D.Float(0.75f * tileWidth, 0.25f * tileHeight));\\n        corners.put(Direction.E,  new Point2D.Float(tileWidth, halfHeight));\\n        corners.put(Direction.SE, new Point2D.Float(0.75f * tileWidth, 0.75f * tileHeight));\\n        corners.put(Direction.S,  new Point2D.Float(halfWidth, tileHeight));\\n        corners.put(Direction.SW, new Point2D.Float(0.25f * tileWidth, 0.75f * tileHeight));\\n        corners.put(Direction.W,  new Point2D.Float(0, halfHeight));\\n        corners.put(Direction.NW, new Point2D.Float(0.25f * tileWidth, 0.25f * tileHeight));\\n                controlPoints.put(Direction.N, new Point2D.Float(halfWidth, dy));\\n        controlPoints.put(Direction.E, new Point2D.Float(tileWidth - dx, halfHeight));\\n        controlPoints.put(Direction.S, new Point2D.Float(halfWidth, tileHeight - dy));\\n        controlPoints.put(Direction.W, new Point2D.Float(dx, halfHeight));\\n                controlPoints.put(Direction.SE, new Point2D.Float(halfWidth, tileHeight));\\n        controlPoints.put(Direction.NE, new Point2D.Float(tileWidth, halfHeight));\\n        controlPoints.put(Direction.SW, new Point2D.Float(0, halfHeight));\\n        controlPoints.put(Direction.NW, new Point2D.Float(halfWidth, 0));\\n                borderPoints.put(Direction.NW, new Point2D.Float(dx + ddx, halfHeight - ddy));\\n        borderPoints.put(Direction.N,  new Point2D.Float(halfWidth - ddx, dy + ddy));\\n        borderPoints.put(Direction.NE, new Point2D.Float(halfWidth + ddx, dy + ddy));\\n        borderPoints.put(Direction.E,  new Point2D.Float(tileWidth - dx - ddx, halfHeight - ddy));\\n        borderPoints.put(Direction.SE, new Point2D.Float(tileWidth - dx - ddx, halfHeight + ddy));\\n        borderPoints.put(Direction.S,  new Point2D.Float(halfWidth + ddx, tileHeight - dy - ddy));\\n        borderPoints.put(Direction.SW, new Point2D.Float(halfWidth - ddx, tileHeight - dy - ddy));\\n        borderPoints.put(Direction.W,  new Point2D.Float(dx + ddx, halfHeight + ddy));\\n                                prohibitedRoads.put(Direction.N,  Arrays.asList(Direction.NW, Direction.NE));\\n        prohibitedRoads.put(Direction.NE, Arrays.asList(Direction.N, Direction.E));\\n        prohibitedRoads.put(Direction.E,  Arrays.asList(Direction.NE, Direction.SE));\\n        prohibitedRoads.put(Direction.SE, Arrays.asList(Direction.E, Direction.S));\\n        prohibitedRoads.put(Direction.S,  Arrays.asList(Direction.SE, Direction.SW));\\n        prohibitedRoads.put(Direction.SW, Arrays.asList(Direction.S, Direction.W));\\n        prohibitedRoads.put(Direction.W,  Arrays.asList(Direction.SW, Direction.NW));\\n        prohibitedRoads.put(Direction.NW, Arrays.asList(Direction.W, Direction.N));\\n        borderStroke = new BasicStroke(dy);\\n        roadStroke = new BasicStroke(dy/2);\\n        gridStroke = new BasicStroke(lib.getScalingFactor());\\n        fog.reset();\\n        fog.moveTo(halfWidth, 0);\\n        fog.lineTo(tileWidth, halfHeight);\\n        fog.lineTo(halfWidth, tileHeight);\\n        fog.lineTo(0, halfHeight);\\n        fog.closePath();\\n        updateMapDisplayVariables();\\n    }\\n    private void updateMapDisplayVariables() {\\n                topSpace = (size.height - tileHeight) / 2;\\n        if ((topSpace % (halfHeight)) != 0) {\\n            topRows = topSpace / (halfHeight) + 2;\\n        } else {\\n            topRows = topSpace / (halfHeight) + 1;\\n        }\\n        bottomRows = topRows;\\n        leftSpace = (size.width - tileWidth) / 2;\\n        rightSpace = leftSpace;\\n    }\\n}\""
        },
        {
            "content": "The source code of `MapViewer.java` reveals that it is a **central component** of the FreeCol GUI system, responsible for rendering and interacting with the game map. It handles:\n\n- **Tile rendering**, including terrain, borders, units, settlements, and overlays.\n- **User interactions**, such as tile selection, unit control, and camera movement.\n- **Integration with core game logic**, via `FreeColClient`, to reflect game state changes in real-time.\n- **Visual feedback**, such as fog of war, goto paths, and UI labels.\n\n### Final CIA Summary: Entities to Synchronize with `MapViewer.java`\n\nBased on all the analyses performed, here are the entities that should be synchronized when changes are made to `MapViewer.java`:\n\n---\n\n\u2705 **Strongly Coupled & Co-Changed Entities**\n1. **`FreeColClient`**\n   - **Why**: Strong method-level coupling; used extensively for accessing game data and control logic.\n   - **Impact**: Changes in `FreeColClient` will almost certainly affect how `MapViewer` behaves.\n\n2. **`GUI`**\n   - **Why**: Frequently called to access UI components like `Canvas`, update menus, refresh tiles, etc.\n   - **Impact**: UI-related changes in `GUI` can directly influence map display and interaction logic.\n\n---\n\n\ud83d\udfe1 **High Co-Change Confidence but No Direct Coupling**\n3. **`Canvas`**\n   - **Why**: High historical co-change confidence (0.5), likely due to shared UI responsibilities.\n   - **Impact**: Indirect impact; may require synchronization if broader UI refactorings occur.\n\n---\n\n\ud83d\udfe0 **Core Game Entities (Used via Call Graph)**\n4. **Game Logic Classes**\n   - Examples: `Game`, `Player`, `Unit`, `Tile`, `Settlement`, `Colony`, `IndianSettlement`, `Europe`, `Resource`, `Map`\n   - **Why**: Heavily referenced in rendering and interaction logic.\n   - **Impact**: Structural or API changes in these classes could break `MapViewer` functionality.\n\n5. **UI Support Classes**\n   - Examples: `ImageLibrary`, `ResourceManager`, `InfoPanel`, `MapControls`, `ClientOptions`\n   - **Why**: Used for rendering images, strings, and managing UI states.\n   - **Impact**: Changes in resource handling or UI configuration may affect visuals or behavior.\n\n---\n\n### \u2705 Final Recommendation\n\nWhen modifying `MapViewer.java`, the following files should be considered for **synchronized changes**:\n\n| Entity | Type | Reason |\n|-------|------|--------|\n| `FreeColClient` | Core Controller | Strong coupling, frequent use |\n| `GUI` | UI Controller | Frequent calls, UI updates |\n| `Canvas` | UI Component | High co-change history |\n| `Game`, `Player`, `Unit`, `Tile`, etc. | Core Models | Heavy usage in display logic |\n| `ImageLibrary`, `ResourceManager`, `InfoPanel`, etc. | UI Helpers | Visual/UI integration |\n\nThis comprehensive analysis ensures that future modifications to `MapViewer.java` consider ripple effects across the system, minimizing regression risks and improving change accuracy.",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        },
        {
            "role": "user",
            "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
        },
        {
            "content": "Title: Diagnosis of starting entity `MapViewer.java`\n\nChange set: [FreeColClient, GUI, Canvas, Game, Player, Unit, Tile, Settlement, Colony, IndianSettlement, Europe, Resource, Map, InfoPanel, MapControls, ClientOptions, GameOptions, ImageLibrary, ResourceManager, Messages, Ability, BuildableType, PathNode, StringTemplate, ColonyTile, Region, FreeCol, TileImprovement, LostCityRumour, TileItem, InGameInputHandler, MiniMap, AudioMixerOptionUI, WorkProductionPanel, MapEditorController, ZoomOutAction, ZoomInAction, RefreshTilesSwingTask, PreGameController]\n\nDetails:\n1. **FreeColClient**: Strong coupling found in multiple methods like getGame, getMyPlayer, getInGameController, etc., indicating heavy reliance on game state and control logic.\n2. **GUI**: Direct method calls for UI updates (getCanvas, refresh, updateMenuBar), showing tight integration with UI behavior.\n3. **Canvas**: High co-change confidence (0.5), though no direct coupling; likely due to shared rendering responsibilities.\n4. **Game**: Frequently accessed via FreeColClient to retrieve map and player data for rendering.\n5. **Player**: Used to determine ownership, visibility, and color schemes for visual differentiation.\n6. **Unit**: Core to rendering unit graphics, occupation indicators, and unit-related actions.\n7. **Tile**: Central to map rendering logic, including terrain, borders, items, and overlays.\n8. **Settlement**: Rendered directly, with special handling for colony and native settlements.\n9. **Colony**: Derived from Settlement; includes extra rendering logic for population, production, and colony state.\n10. **IndianSettlement**: Native settlement type with unique religious mission and capital indicators.\n11. **Europe**: Related to unit pathfinding and destination logic.\n12. **Resource**: Visualized as tile improvements or bonuses in the map.\n13. **Map**: Accessed frequently to determine tile positions, map bounds, and navigation.\n14. **InfoPanel**: Part of the GUI system used to display contextual map information.\n15. **MapControls**: Integrated into the map viewer UI for zooming, panning, and other controls.\n16. **ClientOptions**: Used to determine user preferences affecting map display (e.g., fog of war, labels).\n17. **GameOptions**: Affects game-wide behaviors that influence how map elements are displayed.\n18. **ImageLibrary**: Critical for rendering map tiles, unit images, icons, and overlay graphics.\n19. **ResourceManager**: Supplies fonts, colors, and dynamic images used in map rendering.\n20. **Messages**: Localizes text shown on the map (e.g., settlement names, tooltips).\n21. **Ability**: Used to determine unit capabilities and visual indicators (e.g., expert missionary).\n22. **BuildableType**: Determines what can be built in colonies and affects rendering logic.\n23. **PathNode**: Used in goto path visualization and unit movement planning.\n24. **StringTemplate**: Supports localized message formatting for map tooltips and labels.\n25. **ColonyTile**: Provides context for colony-related tile rendering and overlays.\n26. **Region**: Influences map border drawing when region display mode is active.\n27. **FreeCol**: Likely a top-level class involved in global application configuration.\n28. **TileImprovement**: Represents roads, rivers, and other enhancements rendered on tiles.\n29. **LostCityRumour**: Special tile item with dedicated rendering logic.\n30. **TileItem**: Base class for all objects placed on tiles (e.g., resources, improvements).\n31. **InGameInputHandler**: Co-changed with MapViewer (confidence 0.25); may share input routing logic.\n32. **MiniMap**: Co-changed (confidence 0.25); likely shares map state or viewport synchronization.\n33. **AudioMixerOptionUI**: Co-changed (confidence 0.25); possibly part of a broader UI refactoring pattern.\n34. **WorkProductionPanel**: Co-changed (confidence 0.25); could relate to colony work/production visuals.\n35. **MapEditorController**: Co-changed (confidence 0.25); may share map rendering or editing logic.\n36. **ZoomOutAction**: Co-changed (confidence 0.25); tied to map scaling and display logic.\n37. **ZoomInAction**: Similar to ZoomOutAction, affects map scale and rendering.\n38. **RefreshTilesSwingTask**: Co-changed (confidence 0.25); may involve tile redrawing or animation.\n39. **PreGameController**: Co-changed (confidence 0.25); possibly related to initial map setup or UI flow.\n40. **RefreshTilesSwingTask**: Co-changed (confidence 0.25); potentially involved in tile state updates.\n\nThese entities should be synchronized during changes to `MapViewer.java` due to strong coupling, frequent co-change history, or functional interdependence in rendering and interaction logic.",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        }
    ],
    "interaction_records": {
        "step_histories": [
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4"
                ],
                "response_message": "m5"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6"
                ],
                "response_message": "m7"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8"
                ],
                "response_message": "m9"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10"
                ],
                "response_message": "m11"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12"
                ],
                "response_message": "m13"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14"
                ],
                "response_message": "m15"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14",
                    "m15",
                    "m16"
                ],
                "response_message": "m17"
            }
        ],
        "mid_to_message": {
            "m1": {
                "role": "system",
                "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
            },
            "m2": {
                "role": "user",
                "content": "The project you need to analyze is `freecol`, a well-known Java open source project. The starting entity you need to deal with is MapViewer.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
            },
            "m3": {
                "content": "",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_4932233957bf4114a7c729",
                        "function": {
                            "arguments": "{\"entity\": \"MapViewer.java\"}",
                            "name": "get_co_change_relationship"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m4": {
                "name": "get_co_change_relationship",
                "role": "tool",
                "content": "[[\"InGameInputHandler\", \"1\", \"0.25\"], [\"FreeColClient\", \"2\", \"0.5\"], [\"PreGameController\", \"1\", \"0.25\"], [\"Canvas\", \"2\", \"0.5\"], [\"MiniMap\", \"1\", \"0.25\"], [\"AudioMixerOptionUI\", \"1\", \"0.25\"], [\"WorkProductionPanel\", \"1\", \"0.25\"], [\"GUI\", \"2\", \"0.5\"], [\"MapEditorController\", \"1\", \"0.25\"], [\"ZoomOutAction\", \"1\", \"0.25\"], [\"ZoomInAction\", \"1\", \"0.25\"], [\"RefreshTilesSwingTask\", \"1\", \"0.25\"]]"
            },
            "m5": {
                "content": "The `get_co_change_relationship` function has returned a list of entities that are frequently co-changed with `MapViewer.java`, along with their support count and confidence level. Based on the confidence score, we can identify which entities are most likely to be impacted by changes in `MapViewer.java`.\n\n### Observations:\n1. **High Confidence Relationships (>= 0.5):**\n   - `FreeColClient` (confidence: 0.5)\n   - `Canvas` (confidence: 0.5)\n   - `GUI` (confidence: 0.5)\n\n   These entities have relatively high confidence scores and significant historical co-change relationships with `MapViewer.java`. They should be prioritized for further analysis and potential synchronization.\n\n2. **Lower Confidence Relationships (< 0.5):**\n   - Entities like `InGameInputHandler`, `MiniMap`, `AudioMixerOptionUI`, etc., have lower confidence scores, indicating weaker historical ties. However, they might still warrant attention depending on specific change scenarios.\n\n### Next Steps:\nTo better understand how these entities relate to `MapViewer.java`, I will analyze their coupling dependencies. Starting with the highest-confidence entity, `FreeColClient`, let's examine its coupling dependencies with `MapViewer.java`.\n\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_59823cebd2384336b945b1",
                        "function": {
                            "arguments": "{\"entity1\": \"MapViewer.java\", \"entity2\": \"FreeColClient\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m6": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"ConstructorInvoking(CMAIM): Coupling found in method convertToMapTile, at line: 392. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method convertToMapTile, at line: 871. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method convertToMapTile, at line: 874. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method display, at line: 950. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method display, at line: 951. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method display, at line: 953. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method isInGame.  Coupling found in method display, at line: 957. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method isMapEditor.  Coupling found in method getOccupationIndicatorImage, at line: 1158. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getMyPlayer.  Coupling found in method isMapNearBottom, at line: 1320. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method isMapNearRight, at line: 1341. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method setActiveUnit, at line: 1411. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getMyPlayer.  Coupling found in method setActiveUnit, at line: 1423. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method currentPlayerIsMyPlayer.  Coupling found in method setActiveUnit, at line: 1425. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getInGameController.  Coupling found in method setActiveUnit, at line: 1428. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getInGameController.  Coupling found in method setActiveUnit, at line: 1442. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getClientOptions.  Coupling found in method setActiveUnit, at line: 1448. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getActionManager.  Coupling found in method setOffsetFocus, at line: 1512. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method setSelectedTile, at line: 1579. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getInGameController.  Coupling found in method setSelectedTile, at line: 1585. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getActionManager.  Coupling found in method setSelectedTile, at line: 1591. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getClientOptions.  Coupling found in method displayFogOfWar, at line: 1984. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method displayFogOfWar, at line: 1985. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getMyPlayer.  Coupling found in method displayFogOfWar, at line: 1986. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getMyPlayer.  Coupling found in method displayMap, at line: 2062. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method displayMap, at line: 2099. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getClientOptions.  Coupling found in method displayMap, at line: 2159. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getClientOptions.  Coupling found in method displayMap, at line: 2168. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getClientOptions.  Coupling found in method displayMap, at line: 2243. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getMyPlayer.  Coupling found in method displayMap, at line: 2346. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method isMapEditor.  Coupling found in method displayMap, at line: 2347. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method displayMap, at line: 2348. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method currentPlayerIsMyPlayer.  Coupling found in method displayMap, at line: 2359. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method displayOptionalValues, at line: 2414. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getClientOptions.  Coupling found in method displayOptionalValues, at line: 2466. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.  Coupling found in method displaySettlement, at line: 2512. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getClientOptions.  Coupling found in method displaySettlement, at line: 2533. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getMyPlayer.  Coupling found in method displayUnit, at line: 2650. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getMyPlayer.  Coupling found in method displayUnit, at line: 2683. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getFreeColServer.  Coupling found in method displayUnit, at line: 2686. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getFreeColServer.  Coupling found in method paintBorders, at line: 3096. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getClientOptions.  Coupling found in method positionMap, at line: 3189. Instance of FreeColClient member variable freeColClient is used to call FreeColClient's method getGame.\"]"
            },
            "m7": {
                "content": "The coupling dependency analysis between `MapViewer.java` and `FreeColClient` reveals a **strong relationship**. The `MapViewer` class heavily relies on the `FreeColClient` class by invoking its methods across multiple functionalities, such as retrieving game state (`getGame`), checking player status (`getMyPlayer`, `currentPlayerIsMyPlayer`), and accessing controllers or options (`getClientOptions`, `getInGameController`, `getActionManager`). These dependencies are spread throughout key methods in `MapViewer.java`.\n\n### Key Findings:\n1. **High Coupling Intensity:**\n   - Multiple method calls to `FreeColClient` appear across many functions in `MapViewer.java`.\n   - This indicates that changes in `FreeColClient` could significantly affect `MapViewer.java`, and vice versa.\n\n2. **Critical Interactions:**\n   - `MapViewer` uses `FreeColClient` to access core game data (`getGame`, `getMyPlayer`) and control logic (`getActionManager`, `getInGameController`).\n   - These interactions suggest that any change affecting these methods in `FreeColClient` will likely require updates in `MapViewer.java`.\n\n3. **Implication for Synchronization:**\n   - Due to the strong coupling and high co-change confidence score, **`FreeColClient` should definitely be synchronized with `MapViewer.java`** during changes.\n\n### Next Steps:\nLet's analyze another high-confidence co-changed entity, `Canvas`, and examine its coupling dependencies with `MapViewer.java`. This will help us determine if it also has significant interdependencies.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_ad16d406f4a04060b4d96d",
                        "function": {
                            "arguments": "{\"entity1\": \"MapViewer.java\", \"entity2\": \"Canvas\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m8": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"There are no coupling dependencies between these two entities\"]"
            },
            "m9": {
                "content": "The coupling dependency analysis between `MapViewer.java` and `Canvas` reveals **no direct dependencies**. This means that although they have a relatively high co-change confidence (0.5), their interaction is likely **indirect**, or the changes may be driven by shared contextual logic rather than direct method or variable usage.\n\n### Implications:\n- Since there are no direct coupling dependencies, it suggests that changes in `Canvas` may not directly impact `MapViewer.java` through code-level interactions.\n- However, the historical co-change relationship might indicate that both files are affected by broader UI or rendering-related changes.\n\n### Next Steps:\nLet's analyze the third high-confidence co-changed entity, `GUI`, to determine whether it has any significant coupling with `MapViewer.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_bc6a438fc63e4bb0ad0fc1",
                        "function": {
                            "arguments": "{\"entity1\": \"MapViewer.java\", \"entity2\": \"GUI\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m10": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"ConstructorInvoking(CMAIM): Coupling found in method display, at line: 963. Instance of GUI member variable gui is used to call GUI's method getCanvas.  Coupling found in method setActiveUnit, at line: 1412. Instance of GUI member variable gui is used to call GUI's method getCanvas.  Coupling found in method setActiveUnit, at line: 1449. Instance of GUI member variable gui is used to call GUI's method updateMenuBar.  Coupling found in method setFocus, at line: 1466. Instance of GUI member variable gui is used to call GUI's method refresh.  Coupling found in method setFocusImmediately, at line: 1481. Instance of GUI member variable gui is used to call GUI's method getCanvas.  Coupling found in method setGotoPath, at line: 1493. Instance of GUI member variable gui is used to call GUI's method refresh.  Coupling found in method setSelectedTile, at line: 1563. Instance of GUI member variable gui is used to call GUI's method getCanvas.  Coupling found in method setSelectedTile, at line: 1586. Instance of GUI member variable gui is used to call GUI's method updateMenuBar.  Coupling found in method setSelectedTile, at line: 1597. Instance of GUI member variable gui is used to call GUI's method refreshTile.  Coupling found in method setSelectedTile, at line: 1601. Instance of GUI member variable gui is used to call GUI's method refreshTile.  Coupling found in method actionPerformed, at line: 1630. Instance of GUI member variable gui is used to call GUI's method refreshTile.  Coupling found in method startCursorBlinking, at line: 1630. Instance of GUI member variable gui is used to call GUI's method refreshTile.  Coupling found in method startGoto, at line: 1648. Instance of GUI member variable gui is used to call GUI's method getCanvas.  Coupling found in method stopGoto, at line: 1665. Instance of GUI member variable gui is used to call GUI's method getCanvas.  Coupling found in method scaleMap, at line: 1696. Instance of GUI member variable gui is used to call GUI's method getImageLibrary.  Coupling found in method scaleMap, at line: 1698. Instance of GUI member variable gui is used to call GUI's method getImageLibrary.  Coupling found in method displayMap, at line: 2344. Instance of GUI member variable gui is used to call GUI's method getCanvas.  Coupling found in method enterUnitOutForAnimation, at line: 2840. Instance of GUI member variable gui is used to call GUI's method getCanvas.  Coupling found in method redrawMapControls, at line: 3278. Instance of GUI member variable gui is used to call GUI's method getCanvas.  Coupling found in method redrawMapControls, at line: 3283. Instance of GUI member variable gui is used to call GUI's method getCanvas.  Coupling found in method releaseUnitOutForAnimation, at line: 3300. Instance of GUI member variable gui is used to call GUI's method getCanvas.\"]"
            },
            "m11": {
                "content": "The coupling dependency analysis between `MapViewer.java` and `GUI` reveals a **significant relationship**, with multiple method invocations from `MapViewer` to the `GUI` class. These interactions are spread across several key functionalities in `MapViewer.java`.\n\n### Key Findings:\n1. **Frequent Use of GUI Components:**\n   - `MapViewer` frequently uses the `GUI` object to access UI components such as the canvas (`getCanvas`) and image library (`getImageLibrary`).\n   - It also calls methods like `refresh`, `updateMenuBar`, and `refreshTile`, which are essential for updating the user interface based on map-related actions.\n\n2. **Impact on UI Behavior:**\n   - Many of these interactions occur during operations like setting focus, selecting tiles, and redrawing map elements.\n   - Changes in the `GUI` class\u2014especially those affecting UI rendering or interaction\u2014could directly impact how `MapViewer` behaves.\n\n3. **Implication for Synchronization:**\n   - Given the high co-change confidence (0.5) and the presence of real code-level dependencies, **`GUI` should be synchronized with `MapViewer.java`** when changes are made.\n\n### Summary of Entities to Synchronize:\nSo far, we have confirmed that the following entities should be synchronized with `MapViewer.java` due to either strong coupling or significant historical co-change relationships:\n\n- \u2705 `FreeColClient` \u2013 Strong coupling and high co-change confidence\n- \u2705 `GUI` \u2013 Moderate-to-strong coupling and high co-change confidence\n- \u274c `Canvas` \u2013 No direct coupling found despite co-change history\n\n### Next Steps:\nLet\u2019s now take a broader look at `MapViewer.java` itself by analyzing its internal structure and call graph to identify other potentially important dependencies.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_a5b2d15f9bee4908bc09e0",
                        "function": {
                            "arguments": "{\"entity\": \"MapViewer.java\"}",
                            "name": "get_call_graph"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m12": {
                "role": "tool",
                "name": "get_call_graph",
                "content": "[\"BuildableType\", \"Ability\", \"TileImprovement\", \"PathNode\", \"StringTemplate\", \"FreeColClient\", \"ColonyTile\", \"Resource\", \"Settlement\", \"Europe\", \"GameOptions\", \"Region\", \"ImageResource\", \"ResourceManager\", \"Unit\", \"FreeCol\", \"Player\", \"Map\", \"InfoPanel\", \"TileItem\", \"ClientOptions\", \"Colony\", \"Messages\", \"IndianSettlement\", \"Game\", \"Tile\", \"LostCityRumour\", \"MapControls\"]"
            },
            "m13": {
                "content": "The call graph of `MapViewer.java` provides a list of classes that it directly interacts with through method calls or references. These entities represent **internal dependencies** that are crucial for the functionality of the `MapViewer`.\n\n### Key Observations:\n1. **Core Game Entities:**\n   - `Game`, `Player`, `Unit`, `Tile`, `Settlement`, `Colony`, `IndianSettlement`, `Europe`, and `Resource` are all central to FreeCol\u2019s gameplay.\n   - These indicate that changes in `MapViewer.java` may affect how map-related game state is visualized or manipulated.\n\n2. **UI and Control Components:**\n   - `FreeColClient`, `GUI`, `InfoPanel`, `MapControls`, and `ClientOptions` show continued interaction with UI and control logic, reinforcing earlier coupling findings.\n\n3. **Supporting Classes:**\n   - `ResourceManager`, `ImageResource`, `StringTemplate`, and `Messages` suggest that `MapViewer` also depends on resource management and internationalization components.\n\n4. **Interesting Absence:**\n   - Although `Canvas` was found to co-change frequently, it does not appear in the call graph\u2014further supporting the idea that their relationship might be indirect or mediated through other classes like `GUI`.\n\n### Synchronization Implications:\n- Any change in `MapViewer.java` should consider the impact on tightly coupled classes such as:\n  - \u2705 `FreeColClient`\n  - \u2705 `GUI`\n  - \u2705 `Game`, `Tile`, `Unit`, `Settlement`, etc.\n\nThese classes should be evaluated for synchronization when modifying `MapViewer.java`.\n\n### Final Step:\nTo ensure completeness, let's briefly examine the source code of `MapViewer.java` to understand its general structure and identify any additional insights about its responsibilities and interactions.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_b6bb3066648f49cb99bc7b",
                        "function": {
                            "arguments": "{\"entity\": \"MapViewer.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m14": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package net.sf.freecol.client.gui;\\nimport java.awt.AlphaComposite;\\nimport java.awt.BasicStroke;\\nimport java.awt.Color;\\nimport java.awt.Component;\\nimport java.awt.Composite;\\nimport java.awt.Dimension;\\nimport java.awt.Font;\\nimport java.awt.FontMetrics;\\nimport java.awt.Graphics;\\nimport java.awt.Graphics2D;\\nimport java.awt.Image;\\nimport java.awt.Point;\\nimport java.awt.Rectangle;\\nimport java.awt.RenderingHints;\\nimport java.awt.Stroke;\\nimport java.awt.event.ActionEvent;\\nimport java.awt.event.ActionListener;\\nimport java.awt.font.TextLayout;\\nimport java.awt.geom.AffineTransform;\\nimport java.awt.geom.Ellipse2D;\\nimport java.awt.geom.GeneralPath;\\nimport java.awt.geom.Point2D;\\nimport java.awt.geom.Rectangle2D;\\nimport java.awt.geom.RoundRectangle2D;\\nimport java.awt.image.BufferedImage;\\nimport java.util.Arrays;\\nimport java.util.ArrayList;\\nimport java.util.Date;\\nimport java.util.EnumMap;\\nimport java.util.HashMap;\\nimport java.util.Iterator;\\nimport java.util.List;\\nimport java.util.Vector;\\nimport java.util.logging.Logger;\\nimport javax.swing.ImageIcon;\\nimport javax.swing.JLabel;\\nimport javax.swing.JLayeredPane;\\nimport javax.swing.UIManager;\\nimport net.sf.freecol.FreeCol;\\nimport net.sf.freecol.client.ClientOptions;\\nimport net.sf.freecol.client.FreeColClient;\\nimport net.sf.freecol.client.gui.i18n.Messages;\\nimport net.sf.freecol.client.gui.panel.InfoPanel;\\nimport net.sf.freecol.client.gui.panel.MapControls;\\nimport net.sf.freecol.common.model.Ability;\\nimport net.sf.freecol.common.model.BuildableType;\\nimport net.sf.freecol.common.model.Colony;\\nimport net.sf.freecol.common.model.ColonyTile;\\nimport net.sf.freecol.common.model.Europe;\\nimport net.sf.freecol.common.model.Game;\\nimport net.sf.freecol.common.model.GameOptions;\\nimport net.sf.freecol.common.model.IndianSettlement;\\nimport net.sf.freecol.common.model.LostCityRumour;\\nimport net.sf.freecol.common.model.Map;\\nimport net.sf.freecol.common.model.Map.Direction;\\nimport net.sf.freecol.common.model.Map.Position;\\nimport net.sf.freecol.common.model.PathNode;\\nimport net.sf.freecol.common.model.Player;\\nimport net.sf.freecol.common.model.Region;\\nimport net.sf.freecol.common.model.Resource;\\nimport net.sf.freecol.common.model.Settlement;\\nimport net.sf.freecol.common.model.StringTemplate;\\nimport net.sf.freecol.common.model.Tile;\\nimport net.sf.freecol.common.model.TileImprovement;\\nimport net.sf.freecol.common.model.TileItem;\\nimport net.sf.freecol.common.model.Unit;\\nimport net.sf.freecol.common.resources.ImageResource;\\nimport net.sf.freecol.common.resources.ResourceManager;\\npublic final class MapViewer {\\n    public static enum BorderType { COUNTRY, REGION }\\n    @SuppressWarnings(\\\"serial\\\")\\n    static class GrayLayer extends Component {\\n        private static final Color MASK_COLOR = new Color(0f, 0f, 0f, .6f);\\n        private static final int DEFAULT_FONT_SIZE = 18;\\n        private static final int FONT_SIZE_DECREMENT = 2;\\n        private static final int MAX_TEXT_WIDTH = 640;\\n        private ImageLibrary imageLibrary;\\n        private Player player;\\n        public GrayLayer(ImageLibrary imageLibrary) {\\n            this.imageLibrary = imageLibrary;\\n        }\\n        @Override\\n        public void paint(Graphics g) {\\n            Rectangle clipArea = g.getClipBounds();\\n            if (clipArea == null) {\\n                clipArea = getBounds();\\n                clipArea.x = clipArea.y = 0;\\n            }\\n            if (clipArea.isEmpty()) {\\n                                return;\\n            }\\n            g.setColor(MASK_COLOR);\\n            g.fillRect(clipArea.x, clipArea.y, clipArea.width, clipArea.height);\\n            if (player == null) {\\n                                return;\\n            }\\n            ImageIcon coatOfArmsIcon = imageLibrary\\n                    .getCoatOfArmsImageIcon(player.getNation());\\n            Rectangle iconBounds = new Rectangle();\\n            if (coatOfArmsIcon != null) {\\n                iconBounds.width = coatOfArmsIcon.getIconWidth();\\n                iconBounds.height = coatOfArmsIcon.getIconHeight();\\n            }\\n            Font nameFont = getFont();\\n            FontMetrics nameFontMetrics = getFontMetrics(nameFont);\\n            StringTemplate t = StringTemplate.template(\\\"waitingFor\\\")\\n                .addStringTemplate(\\\"%nation%\\\", player.getNationName());\\n            String message = Messages.message(t);\\n            Rectangle textBounds;\\n            int fontSize = DEFAULT_FONT_SIZE;\\n            int maxWidth = Math.min(MAX_TEXT_WIDTH, getSize().width);\\n            do {\\n                nameFont = nameFont.deriveFont(Font.BOLD, fontSize);\\n                nameFontMetrics = getFontMetrics(nameFont);\\n                textBounds = nameFontMetrics.getStringBounds(message, g)\\n                        .getBounds();\\n                fontSize -= FONT_SIZE_DECREMENT;\\n            } while (textBounds.width > maxWidth);\\n            Dimension size = getSize();\\n            textBounds.x = (size.width - textBounds.width) / 2;\\n            textBounds.y = size.height - InfoPanel.PANEL_HEIGHT - 2 * textBounds.height;\\n            iconBounds.x = (size.width - iconBounds.width) / 2;\\n            iconBounds.y = textBounds.y + 3 * textBounds.height / 2;\\n            if (textBounds.intersects(clipArea)) {\\n                                g.setFont(nameFont);\\n                g.setColor(imageLibrary.getColor(player));\\n                g.drawString(message, textBounds.x, textBounds.y\\n                        + textBounds.height);\\n            }\\n            if (coatOfArmsIcon != null && iconBounds.intersects(clipArea)) {\\n                                coatOfArmsIcon.paintIcon(this, g, iconBounds.x, iconBounds.y);\\n            }\\n        }\\n        public void setPlayer(Player player) {\\n            if (this.player == player) {\\n                return;\\n            }\\n            this.player = player;\\n            repaint();\\n        }\\n    }\\n    class TextSpecification {\\n        public String text;\\n        public Font font;\\n        public TextSpecification(String newText, Font newFont) {\\n            text = newText;\\n            font = newFont;\\n        }\\n    }\\n    private static final Logger logger = Logger.getLogger(MapViewer.class.getName());\\n    private final FreeColClient freeColClient;\\n    private Dimension size;\\n    private ImageLibrary lib;\\n    private TerrainCursor cursor;\\n    private ViewMode viewMode;\\n    private final Vector<GUIMessage> messages;\\n    private Tile selectedTile;\\n    private Tile focus = null;\\n    private Unit activeUnit;\\n    private PathNode currentPath;\\n    private PathNode gotoPath = null;\\n    private boolean gotoStarted = false;\\n        private int tileHeight, tileWidth, halfHeight, halfWidth,\\n    topSpace,\\n    topRows,\\n        bottomRows,\\n    leftSpace,\\n    rightSpace;\\n        private int bottomRow = -1;\\n        private int topRow;\\n            private int bottomRowY;\\n            private int topRowY;\\n        private int leftColumn;\\n        private int rightColumn;\\n            private int leftColumnX;\\n        private static final int UNIT_OFFSET = 20,\\n        STATE_OFFSET_X = 25,\\n        STATE_OFFSET_Y = 10,\\n        OTHER_UNITS_OFFSET_X = -5,         OTHER_UNITS_OFFSET_Y = 1,\\n        OTHER_UNITS_WIDTH = 3,\\n        MAX_OTHER_UNITS = 10,\\n        MESSAGE_COUNT = 3,\\n        MESSAGE_AGE = 30000; \\n    public static final int OVERLAY_INDEX = 100;\\n    public static final int FOREST_INDEX = 200;\\n    private GeneralPath gridPath = null;\\n    private GeneralPath fog = new GeneralPath();\\n        public boolean displayCoordinates = false;\\n    public boolean displayColonyValue = false;\\n    public Player displayColonyValuePlayer = null;\\n    public boolean debugShowMission = false;\\n    public boolean debugShowMissionInfo = false;\\n    private volatile boolean blinkingMarqueeEnabled;\\n    private Image cursorImage;\\n    private GrayLayer greyLayer;\\n    private java.util.Map<Unit, Integer> unitsOutForAnimation;\\n    private java.util.Map<Unit, JLabel> unitsOutForAnimationLabels;\\n        private EnumMap<Direction, Point2D.Float> corners =\\n        new EnumMap<Direction, Point2D.Float>(Direction.class);\\n    private EnumMap<Direction, List<Direction>> prohibitedRoads =\\n        new EnumMap<Direction, List<Direction>>(Direction.class);\\n    private Stroke roadStroke = new BasicStroke(2);\\n        private EnumMap<Direction, Point2D.Float> borderPoints =\\n        new EnumMap<Direction, Point2D.Float>(Direction.class);\\n    private EnumMap<Direction, Point2D.Float> controlPoints =\\n        new EnumMap<Direction, Point2D.Float>(Direction.class);\\n    private Stroke borderStroke = new BasicStroke(4);\\n    private Stroke gridStroke = new BasicStroke(1);\\n    private GUI gui;\\n    public MapViewer(FreeColClient freeColClient, GUI gui, Dimension size, ImageLibrary lib) {\\n        this.freeColClient = freeColClient;\\n        this.gui = gui;\\n        this.size = size;\\n        setImageLibrary(lib);\\n        unitsOutForAnimation = new HashMap<Unit, Integer>();\\n        unitsOutForAnimationLabels = new HashMap<Unit, JLabel>();\\n        logger.info(\\\"GUI created.\\\");\\n        messages = new Vector<GUIMessage>(MESSAGE_COUNT);\\n        viewMode = new ViewMode(this);\\n        logger.info(\\\"Starting in Move Units View Mode\\\");\\n        blinkingMarqueeEnabled = true;\\n        cursor = new net.sf.freecol.client.gui.TerrainCursor();\\n    }\\n    public synchronized void addMessage(GUIMessage message) {\\n        if (getMessageCount() == MESSAGE_COUNT) {\\n            messages.remove(0);\\n        }\\n        messages.add(message);\\n    }\\n    public void centerActiveUnit() {\\n        if (activeUnit != null && activeUnit.getTile() != null) {\\n            setFocus(activeUnit.getTile());\\n        }\\n    }\\n    public Tile convertToMapTile(int x, int y) {\\n        Game gameData = freeColClient.getGame();\\n        if ((gameData == null) || (gameData.getMap() == null)) {\\n            return null;\\n        }\\n        int leftOffset;\\n        if (focus.getX() < getLeftColumns()) {\\n                        if ((focus.getY() % 2) == 0) {\\n                leftOffset = tileWidth * focus.getX() + halfWidth;\\n            } else {\\n                leftOffset = tileWidth * (focus.getX() + 1);\\n            }\\n        } else if (focus.getX() >= (gameData.getMap().getWidth() - getRightColumns())) {\\n                        if ((focus.getY() % 2) == 0) {\\n                leftOffset = size.width - (gameData.getMap().getWidth() - focus.getX()) * tileWidth;\\n            } else {\\n                leftOffset = size.width - (gameData.getMap().getWidth() - focus.getX() - 1) * tileWidth - halfWidth;\\n            }\\n        } else {\\n            if ((focus.getY() % 2) == 0) {\\n                leftOffset = (size.width / 2);\\n            } else {\\n                leftOffset = (size.width / 2) + halfWidth;\\n            }\\n        }\\n        int topOffset;\\n        if (focus.getY() < topRows) {\\n                        topOffset = (focus.getY() + 1) * (halfHeight);\\n        } else if (focus.getY() >= (gameData.getMap().getHeight() - bottomRows)) {\\n                        topOffset = size.height - (gameData.getMap().getHeight() - focus.getY()) * (halfHeight);\\n        } else {\\n            topOffset = (size.height / 2);\\n        }\\n                                        int diffUp = (topOffset - y) / (tileHeight / 4),\\n            diffLeft = (leftOffset - x) / (tileWidth / 4);\\n                        int orDiffUp = diffUp,\\n            orDiffLeft = diffLeft,\\n            remainderUp = (topOffset - y) % (tileHeight / 4),\\n            remainderLeft = (leftOffset - x) % (tileWidth / 4);\\n        if ((diffUp % 2) == 0) {\\n            diffUp = diffUp / 2;\\n        } else {\\n            if (diffUp < 0) {\\n                diffUp = (diffUp / 2) - 1;\\n            } else {\\n                diffUp = (diffUp / 2) + 1;\\n            }\\n        }\\n        if ((diffLeft % 2) == 0) {\\n            diffLeft = diffLeft / 2;\\n        } else {\\n            if (diffLeft < 0) {\\n                diffLeft = (diffLeft / 2) - 1;\\n            } else {\\n                diffLeft = (diffLeft / 2) + 1;\\n            }\\n        }\\n        boolean done = false;\\n        while (!done) {\\n            if ((diffUp % 2) == 0) {\\n                if ((diffLeft % 2) == 0) {\\n                    diffLeft = diffLeft / 2;\\n                    done = true;\\n                } else {\\n                                        if (((orDiffLeft % 2) == 0) && ((orDiffUp % 2) == 0)) {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2) > remainderLeft) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2) > -remainderLeft) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        } else if ((orDiffLeft > 0) && (orDiffUp == 0)) {\\n                            if (remainderUp > 0) {\\n                                                                if ((remainderUp * 2) > remainderLeft) {\\n                                    diffUp++;\\n                                } else {\\n                                    diffLeft++;\\n                                }\\n                            } else {\\n                                                                if ((-remainderUp * 2) > remainderLeft) {\\n                                    diffUp--;\\n                                } else {\\n                                    diffLeft++;\\n                                }\\n                            }\\n                        } else if (orDiffUp == 0) {\\n                            if (remainderUp > 0) {\\n                                                                if ((remainderUp * 2) > -remainderLeft) {\\n                                    diffUp++;\\n                                } else {\\n                                    diffLeft--;\\n                                }\\n                            } else {\\n                                                                if ((-remainderUp * 2) > -remainderLeft) {\\n                                    diffUp--;\\n                                } else {\\n                                    diffLeft--;\\n                                }\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2) > remainderLeft) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2) > -remainderLeft) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        }\\n                    } else if ((orDiffLeft % 2) == 0) {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        }\\n                    } else if ((orDiffUp % 2) == 0) {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        } else if ((orDiffLeft > 0) && (orDiffUp == 0)) {\\n                            if (remainderUp > 0) {\\n                                                                if ((remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                    diffUp++;\\n                                } else {\\n                                    diffLeft--;\\n                                }\\n                            } else {\\n                                                                if ((-remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                    diffUp--;\\n                                } else {\\n                                    diffLeft--;\\n                                }\\n                            }\\n                        } else if (orDiffUp == 0) {\\n                            if (remainderUp > 0) {\\n                                                                if ((remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                    diffUp++;\\n                                } else {\\n                                    diffLeft++;\\n                                }\\n                            } else {\\n                                                                if ((-remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                    diffUp--;\\n                                } else {\\n                                    diffLeft++;\\n                                }\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        }\\n                    } else {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2) > remainderLeft) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2) > -remainderLeft) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2) > remainderLeft) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2) > -remainderLeft) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        }\\n                    }\\n                }\\n            } else {\\n                if ((diffLeft % 2) == 0) {\\n                                        if (((orDiffLeft % 2) == 0) && ((orDiffUp % 2) == 0)) {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2) > remainderLeft) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2) > remainderLeft) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        } else if ((orDiffUp > 0) && (orDiffLeft == 0)) {\\n                            if (remainderLeft > 0) {\\n                                                                if ((remainderUp * 2) > remainderLeft) {\\n                                    diffUp++;\\n                                } else {\\n                                    diffLeft++;\\n                                }\\n                            } else {\\n                                                                if ((remainderUp * 2) > -remainderLeft) {\\n                                    diffUp++;\\n                                } else {\\n                                    diffLeft--;\\n                                }\\n                            }\\n                        } else if (orDiffLeft == 0) {\\n                            if (remainderLeft > 0) {\\n                                                                if ((-remainderUp * 2) > remainderLeft) {\\n                                    diffUp--;\\n                                } else {\\n                                    diffLeft++;\\n                                }\\n                            } else {\\n                                                                if ((-remainderUp * 2) > -remainderLeft) {\\n                                    diffUp--;\\n                                } else {\\n                                    diffLeft--;\\n                                }\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2) > -remainderLeft) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2) > -remainderLeft) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        }\\n                    } else if ((orDiffLeft % 2) == 0) {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        } else if ((orDiffUp > 0) && (orDiffLeft == 0)) {\\n                            if (remainderLeft > 0) {\\n                                                                if ((remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                    diffLeft++;\\n                                } else {\\n                                    diffUp--;\\n                                }\\n                            } else {\\n                                                                if ((remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                    diffLeft--;\\n                                } else {\\n                                    diffUp--;\\n                                }\\n                            }\\n                        } else if (orDiffLeft == 0) {\\n                            if (remainderLeft > 0) {\\n                                                                if ((-remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                    diffLeft++;\\n                                } else {\\n                                    diffUp++;\\n                                }\\n                            } else {\\n                                                                if ((-remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                    diffLeft--;\\n                                } else {\\n                                    diffUp++;\\n                                }\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        }\\n                    } else if ((orDiffUp % 2) == 0) {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffUp++;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2 + remainderLeft) > (tileWidth / 4)) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft--;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2 - remainderLeft) > (tileWidth / 4)) {\\n                                diffUp--;\\n                            } else {\\n                                diffLeft++;\\n                            }\\n                        }\\n                    } else {\\n                        if ((orDiffLeft > 0) && (orDiffUp > 0)) {\\n                                                        if ((remainderUp * 2) > remainderLeft) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffUp > 0) {\\n                                                        if ((remainderUp * 2) > -remainderLeft) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp--;\\n                            }\\n                        } else if (orDiffLeft > 0) {\\n                                                        if ((-remainderUp * 2) > remainderLeft) {\\n                                diffLeft--;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        } else {\\n                                                        if ((-remainderUp * 2) > -remainderLeft) {\\n                                diffLeft++;\\n                            } else {\\n                                diffUp++;\\n                            }\\n                        }\\n                    }\\n                } else {\\n                    if ((focus.getY() % 2) == 0) {\\n                        if (diffLeft < 0) {\\n                            diffLeft = diffLeft / 2;\\n                        } else {\\n                            diffLeft = (diffLeft / 2) + 1;\\n                        }\\n                    } else {\\n                        if (diffLeft < 0) {\\n                            diffLeft = (diffLeft / 2) - 1;\\n                        } else {\\n                            diffLeft = diffLeft / 2;\\n                        }\\n                    }\\n                    done = true;\\n                }\\n            }\\n        }\\n        Position position = new Map.Position(focus.getX() - diffLeft, focus.getY() - diffUp);\\n        if (!freeColClient.getGame().getMap().isValid(position))\\n            return null;\\n        return freeColClient.getGame().getMap().getTile(position);\\n    }\\n    public Image createStringImage(Graphics g, String nameString, Color color, Font font) {\\n        if (color == null) {\\n            logger.warning(\\\"createStringImage called with color null\\\");\\n            color = Color.WHITE;\\n        }\\n                String key = \\\"dynamic.stringImage.\\\" + nameString\\n            + \\\".\\\" + font.getFontName().replace(' ', '-')\\n            + \\\".\\\" + Integer.toString(font.getSize())\\n            + \\\".\\\" + Integer.toHexString(color.getRGB());\\n        Image image = (Image) ResourceManager.getImage(key);        if (image != null) {\\n            return image;\\n        }\\n                FontMetrics fontMetrics = g.getFontMetrics(font);\\n        BufferedImage bi = new BufferedImage(fontMetrics.stringWidth(nameString) + 4,\\n                                             fontMetrics.getMaxAscent() + fontMetrics.getMaxDescent(),\\n                                             BufferedImage.TYPE_INT_ARGB);\\n                Graphics2D big = bi.createGraphics();\\n        big.setColor(color);\\n        big.setFont(font);\\n        big.drawString(nameString, 2, fontMetrics.getMaxAscent());\\n                int textColor = color.getRGB();\\n        int borderColor = getStringBorderColor(color).getRGB();\\n        for (int biX = 0; biX < bi.getWidth(); biX++) {\\n            for (int biY = 0; biY < bi.getHeight(); biY++) {\\n                int r = bi.getRGB(biX, biY);\\n                if (r == textColor) {\\n                    continue;\\n                }\\n                for (int cX = -1; cX <= 1; cX++) {\\n                    for (int cY = -1; cY <= 1; cY++) {\\n                        if (biX+cX >= 0 && biY+cY >= 0\\n                            && biX+cX < bi.getWidth() && biY+cY < bi.getHeight()\\n                            && bi.getRGB(biX + cX, biY + cY) == textColor) {\\n                            bi.setRGB(biX, biY, borderColor);\\n                            continue;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        ResourceManager.addGameMapping(key, new ImageResource(bi));\\n        return (Image) ResourceManager.getImage(key);    }\\n    public void display(Graphics2D g) {\\n        if ((freeColClient.getGame() != null)\\n                && (freeColClient.getGame().getMap() != null)\\n                && (focus != null)\\n                && freeColClient.isInGame()) {\\n            removeOldMessages();\\n            displayMap(g);\\n        } else {\\n            if (freeColClient.isMapEditor()) {\\n                g.setColor(Color.black);\\n                g.fillRect(0, 0, size.width, size.height);\\n            } else {\\n                Image bgImage = ResourceManager.getImage(\\\"CanvasBackgroundImage\\\", size);\\n                if (bgImage != null) {\\n                    g.drawImage(bgImage, 0, 0, gui.getCanvas());\\n                                        String versionStr = \\\"v. \\\" + FreeCol.getVersion();\\n                    Font oldFont = g.getFont();\\n                    Color oldColor = g.getColor();\\n                    Font newFont = oldFont.deriveFont(Font.BOLD);\\n                    TextLayout layout = new TextLayout(versionStr, newFont, g.getFontRenderContext());\\n                    Rectangle2D bounds = layout.getBounds();\\n                    float x = getWidth() - (float) bounds.getWidth() - 5;\\n                    float y = getHeight() - (float) bounds.getHeight();\\n                    g.setColor(Color.white);\\n                    layout.draw(g, x, y);\\n                                        g.setFont(oldFont);\\n                    g.setColor(oldColor);\\n                } else {\\n                    g.setColor(Color.black);\\n                    g.fillRect(0, 0, size.width, size.height);\\n                }\\n            }\\n        }\\n    }\\n    public void displayColonyTile(Graphics2D g, Tile tile, Colony colony) {\\n        boolean tileCannotBeWorked = false;\\n        Unit occupyingUnit = null;\\n        int price = 0;\\n        if (colony != null) {\\n            ColonyTile colonyTile = colony.getColonyTile(tile);\\n            occupyingUnit = colonyTile.getOccupyingUnit();\\n            price = colony.getOwner().getLandPrice(tile);\\n            switch (colonyTile.getNoWorkReason()) {\\n            case NONE: case COLONY_CENTER: case CLAIM_REQUIRED:\\n                break;\\n            default:\\n                tileCannotBeWorked = true;\\n            }\\n        }\\n        displayBaseTile(g, tile, false);\\n        displayTileOverlays(g, tile, false, false);\\n        if (tileCannotBeWorked) {\\n            g.drawImage(lib.getMiscImage(ImageLibrary.TILE_TAKEN), 0, 0, null);\\n        }\\n        if (price > 0 && tile.getSettlement() == null) {\\n                        Image image = lib.getMiscImage(ImageLibrary.TILE_OWNED_BY_INDIANS);\\n            centerImage(g, image);\\n        }\\n        if (occupyingUnit != null) {\\n            ImageIcon image = lib.getUnitImageIcon(occupyingUnit, 0.5);\\n            g.drawImage(image.getImage(), tileWidth/4 - image.getIconWidth() / 2,\\n                        halfHeight - image.getIconHeight() / 2, null);\\n                        g.drawImage(getOccupationIndicatorImage(g, occupyingUnit),\\n                        (int) (STATE_OFFSET_X * lib.getScalingFactor()), 0, null);\\n        }\\n    }\\n    public void displayTerrain(Graphics2D g, Tile tile) {\\n        displayBaseTile(g, tile, true);\\n        displayTileItems(g, tile);\\n    }\\n    public void executeWithUnitOutForAnimation(final Unit unit,\\n                                               final Tile sourceTile,\\n                                               final OutForAnimationCallback r) {\\n        final JLabel unitLabel = enterUnitOutForAnimation(unit, sourceTile);\\n        try {\\n            r.executeWithUnitOutForAnimation(unitLabel);\\n        } finally {\\n            releaseUnitOutForAnimation(unit);\\n        }\\n    }\\n    public void forceReposition() {\\n        bottomRow = -1;\\n    }\\n    public Unit getActiveUnit() {\\n        return activeUnit;\\n    }\\n    public TerrainCursor getCursor(){\\n        return cursor;\\n    }\\n    public Tile getFocus() {\\n        if (focus == null)\\n            return null;\\n        return focus;\\n    }\\n    public PathNode getGotoPath() {\\n        return gotoPath;\\n    }\\n    public int getHeight() {\\n        return size.height;\\n    }\\n    public float getMapScale() {\\n        return lib.getScalingFactor();\\n    }\\n    public Image getOccupationIndicatorImage(Graphics g, Unit unit) {\\n        Color backgroundColor = lib.getColor(unit.getOwner());\\n        Color foregroundColor = getForegroundColor(backgroundColor);\\n        String occupationString;\\n        if (!freeColClient.getMyPlayer().owns(unit)\\n                && unit.isNaval()) {\\n            occupationString = Integer.toString(unit.getVisibleGoodsCount());\\n        } else {\\n            if (unit.getDestination() != null) {\\n                if(unit.getTradeRoute() != null)\\n                    occupationString = \\\"model.unit.occupation.inTradeRoute\\\";\\n                else\\n                    occupationString = \\\"model.unit.occupation.goingSomewhere\\\";\\n            } else if (unit.getState() == Unit.UnitState.IMPROVING\\n                       && unit.getWorkImprovement() != null) {\\n                occupationString = unit.getWorkImprovement().getType().getId() + \\\".occupationString\\\";\\n            } else if (unit.getState() == Unit.UnitState.ACTIVE\\n                && unit.getMovesLeft() == 0) {\\n                if(unit.isUnderRepair())\\n                    occupationString = \\\"model.unit.occupation.underRepair\\\";\\n                else\\n                    occupationString = \\\"model.unit.occupation.activeNoMovesLeft\\\";\\n            } else {\\n                occupationString = \\\"model.unit.occupation.\\\" + unit.getState().toString().toLowerCase();\\n            }\\n            occupationString = Messages.message(occupationString);\\n            if (unit.getState() == Unit.UnitState.FORTIFIED)\\n                foregroundColor = Color.GRAY;\\n        }\\n                String key = \\\"dynamic.occupationIndicator.\\\" + occupationString\\n            + \\\".\\\" + Integer.toHexString(backgroundColor.getRGB());\\n        Image img = (Image) ResourceManager.getImage(key, lib.getScalingFactor());\\n        if (img == null) {\\n            img = lib.createChip(occupationString, Color.BLACK, backgroundColor, foregroundColor);\\n            ResourceManager.addGameMapping(key, new ImageResource(img));\\n        }\\n        return img;\\n    }\\n    public Tile getSelectedTile() {\\n        return selectedTile;\\n    }\\n    public Rectangle getTileBounds(Tile tile) {\\n        Rectangle result = new Rectangle(0, 0, size.width, size.height);\\n        if (isTileVisible(tile)) {\\n            result.x = ((tile.getX() - leftColumn) * tileWidth) + leftColumnX;\\n            result.y = ((tile.getY() - topRow) * halfHeight) + topRowY - tileHeight;\\n            if ((tile.getY() % 2) != 0) {\\n                result.x += halfWidth;\\n            }\\n            result.width = tileWidth;\\n            result.height = tileHeight * 2;\\n        }\\n        return result;\\n    }\\n    public int getTileHeight() {\\n        return tileHeight;\\n    }\\n    public Point getTilePosition(Tile t) {\\n        repositionMapIfNeeded();\\n        if (isTileVisible(t)) {\\n            int x = ((t.getX() - leftColumn) * tileWidth) + leftColumnX;\\n            int y = ((t.getY() - topRow) * halfHeight) + topRowY;\\n            if ((t.getY() % 2) != 0) {\\n                x += halfWidth;\\n            }\\n            return new Point(x, y);\\n        } else {\\n            return null;\\n        }\\n    }\\n    public int getTileWidth() {\\n        return tileWidth;\\n    }\\n    public Point getUnitLabelPositionInTile(JLabel unitLabel, Point tileP) {\\n        if (tileP != null) {\\n            int labelX = tileP.x + getTileWidth() / 2 - unitLabel.getWidth() / 2;\\n            int labelY = tileP.y + getTileHeight() / 2 - unitLabel.getHeight() / 2 -\\n                        (int) (UNIT_OFFSET * lib.getScalingFactor());\\n            return new Point(labelX, labelY);\\n        } else {\\n            return null;\\n        }\\n    }\\n    public ViewMode getViewMode(){\\n        return viewMode;\\n    }\\n    public int getWidth() {\\n        return size.width;\\n    }\\n    public boolean isGotoStarted() {\\n        return gotoStarted;\\n    }\\n    public boolean isMapNearBottom(int y) {\\n        return (y >= (freeColClient.getGame().getMap().getHeight() - bottomRows));\\n    }\\n    public boolean isMapNearLeft(int x, int y) {\\n        return (x < getLeftColumns(y));\\n    }\\n    public boolean isMapNearRight(int x, int y) {\\n        return (x >= (freeColClient.getGame().getMap().getWidth() - getRightColumns(y)));\\n    }\\n    public boolean isMapNearTop(int y) {\\n        return (y < topRows);\\n    }\\n    public void moveTileCursor(Direction direction) {\\n        if (selectedTile != null) {\\n            Tile newTile = selectedTile.getNeighbourOrNull(direction);\\n            if (newTile != null) setSelectedTile(newTile, false);\\n        } else {\\n            logger.warning(\\\"selectedTile is null\\\");\\n        }\\n    }\\n    public boolean onScreen(Tile tileToCheck) {\\n        repositionMapIfNeeded();\\n        return tileToCheck.getY() - 2 > topRow\\n            && tileToCheck.getY() + 4 < bottomRow\\n            && tileToCheck.getX() - 1 > leftColumn\\n            && tileToCheck.getX() + 2 < rightColumn;\\n    }\\n    public void restartBlinking() {\\n        blinkingMarqueeEnabled = true;\\n    }\\n    public boolean setActiveUnit(Unit activeUnit) {\\n                        boolean ret = false;\\n        if (activeUnit != null && !freeColClient.getMyPlayer().owns(activeUnit)) {\\n            gui.getCanvas().repaint(0, 0, getWidth(), getHeight());\\n            return ret;\\n        }\\n        if (activeUnit != null && activeUnit.getTile() == null) {\\n            activeUnit = null;\\n        }\\n        this.activeUnit = activeUnit;\\n        if (activeUnit != null) {\\n            if (freeColClient.currentPlayerIsMyPlayer()) {\\n                if (activeUnit.getState() != Unit.UnitState.ACTIVE) {\\n                    freeColClient.getInGameController().clearOrders(activeUnit);\\n                }\\n            } else {\\n                freeColClient.getInGameController().clearGotoOrders(activeUnit);\\n            }\\n        }\\n        updateGotoPathForActiveUnit();\\n                if (viewMode.getView() == ViewMode.VIEW_TERRAIN_MODE\\n            && activeUnit != null) {\\n            viewMode.changeViewMode(ViewMode.MOVE_UNITS_MODE);\\n        }\\n        if (activeUnit != null) {\\n            Tile tile = activeUnit.getTile();\\n            if (!setSelectedTile(tile, false)\\n                || freeColClient.getClientOptions()\\n                .getBoolean(ClientOptions.JUMP_TO_ACTIVE_UNIT)) {\\n                setFocus(tile);\\n                ret = true;\\n            }\\n        } else {\\n            freeColClient.getActionManager().update();\\n            gui.updateMenuBar();\\n            redrawMapControls();\\n        }\\n        return ret;\\n    }\\n    public void setFocus(Tile focus) {\\n        this.focus = focus;\\n        gui.refresh();\\n    }\\n    public void setFocusImmediately(Tile focus) {\\n        this.focus = focus;\\n        forceReposition();\\n        gui.getCanvas().paintImmediately(0, 0, getWidth(), getHeight());\\n    }\\n    public void setGotoPath(PathNode gotoPath) {\\n        this.gotoPath = gotoPath;\\n        gui.refresh();\\n    }\\n    public int setOffsetFocus(Tile tile) {\\n        int where = 0;\\n        if (tile != null) {\\n            positionMap(tile);\\n            Map map = freeColClient.getGame().getMap();\\n            if (leftColumn == 0) {\\n                where = -1;             } else if (rightColumn == map.getWidth() - 1) {\\n                where = 1;             } else {                 int x = tile.getX() - (tile.getX() - leftColumn) / 2;\\n                tile = map.getTile(x, tile.getY());\\n                where = 1;\\n            }\\n            setFocus(tile);\\n        }\\n        return where;\\n    }\\n    public boolean setSelectedTile(Tile newTileToSelect, boolean clearGoToOrders) {\\n        Tile oldTile = this.selectedTile;\\n        boolean ret = false;\\n        selectedTile = newTileToSelect;\\n        if (viewMode.getView() == ViewMode.MOVE_UNITS_MODE) {\\n            if (noActiveUnitIsAt(selectedTile)) {\\n                if (selectedTile != null && selectedTile.getSettlement() != null) {\\n                    Settlement s = selectedTile.getSettlement();\\n                    gui.getCanvas().showSettlement(s);\\n                    return ret;\\n                }\\n                                Unit unitInFront = getUnitInFront(selectedTile);\\n                if (unitInFront != null) {\\n                    ret = setActiveUnit(unitInFront);\\n                    updateGotoPathForActiveUnit();\\n                } else {\\n                    setFocus(selectedTile);\\n                    ret = true;\\n                }\\n            } else {\\n                                if (clearGoToOrders) {\\n                    freeColClient.getInGameController().clearGotoOrders(activeUnit);\\n                    updateGotoPathForActiveUnit();\\n                }\\n            }\\n        }\\n        freeColClient.getActionManager().update();\\n        gui.updateMenuBar();\\n        redrawMapControls();\\n                if (!onScreen(selectedTile) || freeColClient.getClientOptions()\\n            .getBoolean(ClientOptions.ALWAYS_CENTER)) {\\n            setFocus(selectedTile);\\n            ret = true;\\n        } else {\\n            if (oldTile != null) {\\n                gui.refreshTile(oldTile);\\n            }\\n            if (selectedTile != null) {\\n                gui.refreshTile(selectedTile);\\n            }\\n        }\\n        return ret;\\n    }\\n    public void setSize(Dimension size) {\\n        this.size = size;\\n        updateMapDisplayVariables();\\n    }\\n    public void startCursorBlinking() {\\n        ActionListener taskPerformer = new ActionListener() {\\n            public void actionPerformed(ActionEvent event) {\\n                if (!blinkingMarqueeEnabled)\\n                    return;\\n                if (getActiveUnit() != null && getActiveUnit().getTile() != null) {\\n                    Tile tile = getActiveUnit().getTile();\\n                    if (isTileVisible(tile)) {\\n                        gui.refreshTile(tile);\\n                    }\\n                }\\n            }\\n        };\\n        cursor.addActionListener(taskPerformer);\\n        cursor.startBlinking();\\n    }\\n    public void startGoto() {\\n        gotoStarted = true;\\n        gui.getCanvas().setCursor((java.awt.Cursor) UIManager.get(\\\"cursor.go\\\"));\\n        setGotoPath(null);\\n    }\\n    public void stopBlinking() {\\n        blinkingMarqueeEnabled = false;\\n    }\\n    public void stopGoto() {\\n        gui.getCanvas().setCursor(null);\\n        setGotoPath(null);\\n        updateGotoPathForActiveUnit();\\n        gotoStarted = false;\\n    }\\n    public void updateGotoPathForActiveUnit() {\\n        currentPath = (activeUnit == null\\n                       || activeUnit.getDestination() == null)\\n            ? null\\n            : (activeUnit.getDestination() instanceof Europe)\\n            ? activeUnit.findPathToEurope()\\n            : (activeUnit.getDestination().getTile() == activeUnit.getTile())\\n            ? null             : activeUnit.findPath(activeUnit.getDestination().getTile());\\n    }\\n    void scaleMap(float delta) {\\n        float newScale = lib.getScalingFactor() + delta;\\n        try {\\n            if (newScale >= 1f) {\\n                setImageLibrary(gui.getImageLibrary());\\n            } else {\\n                setImageLibrary(gui.getImageLibrary().getScaledImageLibrary(newScale));\\n            }\\n        } catch (Exception ex) {\\n            logger.warning(\\\"Failed to retrieve scaled image library.\\\");\\n        }\\n    }\\n    private void centerImage(Graphics2D g, Image image) {\\n        g.drawImage(image,\\n                    (tileWidth - image.getWidth(null))/2,\\n                    (tileHeight - image.getHeight(null))/2,\\n                    null);\\n    }\\n    private void centerString(Graphics2D g, String text) {\\n        g.setColor(Color.BLACK);\\n        g.setFont(ResourceManager.getFont(\\\"NormalFont\\\", 12f));\\n        g.drawString(text,\\n                     (tileWidth - g.getFontMetrics().stringWidth(text))/2,\\n                     (tileHeight - g.getFontMetrics().getAscent())/2);\\n    }\\n    private Image createCapitalLabel(int extent, int padding, Color backgroundColor) {\\n        String key = \\\"dynamic.label.nativeCapital\\\"\\n            + \\\".\\\" + Integer.toHexString(backgroundColor.getRGB());\\n        Image image = (Image) ResourceManager.getImage(key, lib.getScalingFactor());\\n        if (image != null) {\\n            return image;\\n        }\\n                double deg2rad = Math.PI/180.0;\\n        double angle = -90.0 * deg2rad;\\n        double offset = extent * 0.5;\\n        double size = (extent - padding - padding) * 0.5;\\n        GeneralPath path = new GeneralPath();\\n        path.moveTo(Math.cos(angle) * size + offset, Math.sin(angle) * size + offset);\\n        for (int i = 0; i < 4; i++) {\\n            angle += 144 * deg2rad;\\n            path.lineTo(Math.cos(angle) * size + offset, Math.sin(angle) * size + offset);\\n        }\\n        path.closePath();\\n                BufferedImage bi = new BufferedImage(extent, extent, BufferedImage.TYPE_INT_ARGB);\\n        Graphics2D g = bi.createGraphics();\\n        g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\\n        g.setColor(backgroundColor);\\n        g.fill(new RoundRectangle2D.Float(0, 0, extent, extent, padding, padding));\\n        g.setColor(Color.BLACK);\\n        g.setStroke(new BasicStroke(2.4f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));\\n        g.draw(path);\\n        g.setColor(Color.WHITE);\\n        g.fill(path);\\n        ResourceManager.addGameMapping(key, new ImageResource(bi));\\n        return (Image) ResourceManager.getImage(key, lib.getScalingFactor());\\n    }\\n    private Image createLabel(Graphics2D g, String text, Font font, Color backgroundColor) {\\n        TextSpecification[] specs = new TextSpecification[1];\\n        specs[0] = new TextSpecification(text, font);\\n        return createLabel(g, specs, backgroundColor);\\n    }\\n    private Image createLabel(Graphics2D g, TextSpecification[] textSpecs, Color backgroundColor) {\\n        int hPadding = 15;\\n        int vPadding = 10;\\n        int linePadding = 2;\\n        int width = 0;\\n        int height = vPadding;\\n        int i;\\n        TextSpecification spec;\\n        TextLayout[] labels = new TextLayout[textSpecs.length];\\n        TextLayout label;\\n        for (i = 0; i < textSpecs.length; i++) {\\n            spec = textSpecs[i];\\n            label = new TextLayout(spec.text, spec.font, g.getFontRenderContext());\\n            labels[i] = label;\\n            width = Math.max(width, (int) label.getBounds().getWidth() + hPadding);\\n            height += (int) (label.getAscent() + label.getDescent());\\n            if (i > 0) height += linePadding;\\n        }\\n        int radius = Math.min(hPadding, vPadding);\\n        BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\\n        Graphics2D g2 = bi.createGraphics();\\n        g2.scale(lib.getScalingFactor(), lib.getScalingFactor());\\n        g2.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\\n        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\\n        g2.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);\\n        g2.setColor(backgroundColor);\\n        g2.fill(new RoundRectangle2D.Float(0, 0, width, height, radius, radius));\\n        g2.setColor(getForegroundColor(backgroundColor));\\n        int offset = 0;\\n        for (i = 0; i < labels.length; i++) {\\n            if (i > 0) offset += labels[i - 1].getAscent() + linePadding + vPadding/2;\\n            labels[i].draw(g2, (float) (width - labels[i].getBounds().getWidth())/2,\\n                           offset + labels[i].getAscent() + vPadding/2);\\n        }\\n        return bi;\\n    }\\n    private Image createReligiousMissionLabel(int extent, int padding, Color backgroundColor, boolean expertMissionary) {\\n        String key = \\\"dynamic.label.religiousMission\\\"\\n            + (expertMissionary ? \\\".expert\\\" : \\\"\\\")\\n            + \\\".\\\" + Integer.toHexString(backgroundColor.getRGB());\\n        Image image = (Image) ResourceManager.getImage(key, lib.getScalingFactor());\\n        if (image != null) {\\n            return image;\\n        }\\n                double offset = extent * 0.5;\\n        double size = extent - padding - padding;\\n        double bar = size / 3.0;\\n        double inset = 0.0;\\n        double kludge = 0.0;\\n        GeneralPath circle = new GeneralPath();\\n        GeneralPath cross = new GeneralPath();\\n        if (expertMissionary) {\\n                        circle.append(new Ellipse2D.Double(padding-1, padding-1, size+1, size+1), false);\\n            inset = 4.0;\\n            bar = (size - inset - inset) / 3.0;\\n                        kludge = 1.0;\\n        }\\n        offset -= 1.0;\\n        cross.moveTo(offset, padding + inset - kludge);\\n        cross.lineTo(offset, extent - padding - inset);\\n        cross.moveTo(offset - bar, padding + bar + inset);\\n        cross.lineTo(offset + bar + 1, padding + bar + inset);\\n                BufferedImage bi = new BufferedImage(extent, extent, BufferedImage.TYPE_INT_ARGB);\\n        Graphics2D g = bi.createGraphics();\\n        g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\\n        g.setColor(backgroundColor);\\n        g.fill(new RoundRectangle2D.Float(0, 0, extent, extent, padding, padding));\\n        g.setColor(getForegroundColor(backgroundColor));\\n        if (expertMissionary) {\\n            g.setStroke(new BasicStroke(2.0f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));\\n            g.draw(circle);\\n            g.setStroke(new BasicStroke(1.6f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));\\n        } else {\\n            g.setStroke(new BasicStroke(2.4f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));\\n        }\\n        g.draw(cross);\\n        ResourceManager.addGameMapping(key, new ImageResource(bi));\\n        return (Image) ResourceManager.getImage(key, lib.getScalingFactor());\\n    }\\n    private void displayBaseTile(Graphics2D g, Tile tile, boolean drawUnexploredBorders) {\\n        if (tile != null) {\\n            int x = tile.getX();\\n            int y = tile.getY();\\n                        g.drawImage(lib.getTerrainImage(tile.getType(), x, y), 0, 0, null);\\n            if (tile.isExplored()) {\\n                if (!tile.isLand() && tile.getStyle() > 0) {\\n                    int edgeStyle = tile.getStyle() >> 4;\\n                    if (edgeStyle > 0) {\\n                        g.drawImage(lib.getBeachEdgeImage(edgeStyle, x, y), 0, 0, null);\\n                    }\\n                    int cornerStyle = tile.getStyle() & 15;\\n                    if (cornerStyle > 0) {\\n                        g.drawImage(lib.getBeachCornerImage(cornerStyle, x, y), 0, 0, null);\\n                    }\\n                }\\n                for (Direction direction : Direction.values()) {\\n                    Tile borderingTile = tile.getAdjacentTile(direction);\\n                    if (borderingTile != null) {\\n                        if (!drawUnexploredBorders && !borderingTile.isExplored() &&\\n                            (direction == Direction.SE || direction == Direction.S ||\\n                             direction == Direction.SW)) {\\n                            continue;\\n                        }\\n                        if (tile.getType() == borderingTile.getType()) {\\n                                                        continue;\\n                        } else if (tile.isLand() && !borderingTile.isLand()) {\\n                                                        continue;\\n                        } else if (!tile.isLand() && borderingTile.isLand() && borderingTile.isExplored()) {\\n                                                                                    g.drawImage(lib.getBorderImage(borderingTile.getType(), direction,\\n                                                           x, y), 0, 0, null);\\n                            TileImprovement river = borderingTile.getRiver();\\n                            if (river != null && (direction == Direction.SE || direction == Direction.SW ||\\n                                                  direction == Direction.NE || direction == Direction.NW)) {\\n                                int[] branches = river.getStyleBreakdown(Direction.longSides, 3);\\n                                if (branches[direction.getReverseDirection().ordinal()] > 0) {\\n                                    g.drawImage(lib.getRiverMouthImage(direction, borderingTile.getRiver()\\n                                                                       .getMagnitude(), x,\\n                                                                       y), 0, 0, null);\\n                                }\\n                            }\\n                        } else if (borderingTile.isExplored()) {\\n                            if (lib.getTerrainImage(tile.getType(), 0, 0)\\n                                .equals(lib.getTerrainImage(borderingTile.getType(), 0, 0))) {\\n                                                                continue;\\n                            } else if (borderingTile.getType().getIndex() < tile.getType().getIndex()) {\\n                                                                g.drawImage(lib.getBorderImage(borderingTile.getType(), direction,\\n                                                               x, y), 0, 0, null);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    private void displayFogOfWar(Graphics2D g, Tile tile) {\\n        if (freeColClient.getGame().getSpecification().getBoolean(GameOptions.FOG_OF_WAR)\\n            && freeColClient.getMyPlayer() != null\\n            && !freeColClient.getMyPlayer().canSee(tile)) {\\n            g.setColor(Color.BLACK);\\n            Composite oldComposite = g.getComposite();\\n            g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.2f));\\n            g.fill(fog);\\n            g.setComposite(oldComposite);\\n        }\\n    }\\n    private void displayGotoPath(Graphics2D g, PathNode gotoPath) {\\n        if (gotoPath != null) {\\n            PathNode temp = gotoPath;\\n            Font font = ResourceManager.getFont(\\\"NormalFont\\\", 12f);\\n            while (temp != null) {\\n                Point p = getTilePosition(temp.getTile());\\n                if (p != null) {\\n                    Tile tile = temp.getTile();\\n                    Image image;\\n                    final Color textColor;\\n                    if (temp.getTurns() == 0) {\\n                        g.setColor(Color.GREEN);\\n                        image = lib.getPathImage(activeUnit);\\n                        if (activeUnit != null\\n                                && tile.isExplored()\\n                                && activeUnit.isNaval()\\n                                && tile.isLand()\\n                                && (tile.getColony() == null || tile.getColony().getOwner() != activeUnit.getOwner())) {\\n                            image = lib.getPathImage(activeUnit.getFirstUnit());\\n                        }\\n                        textColor = Color.BLACK;\\n                    } else {\\n                        g.setColor(Color.RED);\\n                        image = lib.getPathNextTurnImage(activeUnit);\\n                        if (activeUnit != null\\n                                && tile.isExplored()\\n                                && activeUnit.isNaval()\\n                                && tile.isLand()\\n                                && (tile.getColony() == null || tile.getColony().getOwner() != activeUnit.getOwner())) {\\n                            image = lib.getPathNextTurnImage(activeUnit.getFirstUnit());\\n                        }\\n                        textColor = Color.WHITE;\\n                    }\\n                    g.translate(p.x, p.y);\\n                    if (image != null) {\\n                        centerImage(g, image);\\n                    } else {\\n                        g.fillOval(halfWidth, halfHeight, 10, 10);\\n                        g.setColor(Color.BLACK);\\n                        g.drawOval(halfWidth, halfHeight, 10, 10);\\n                    }\\n                    if (temp.getTurns() > 0) {\\n                        Image stringImage = createStringImage(g, Integer.toString(temp.getTurns()),\\n                                                              textColor, font);\\n                        centerImage(g, stringImage);\\n                    }\\n                    g.translate(-p.x, -p.y);\\n                }\\n                temp = temp.next;\\n            }\\n        }\\n    }\\n    private void displayMap(Graphics2D g) {\\n        AffineTransform originTransform = g.getTransform();\\n        Rectangle clipBounds = g.getClipBounds();\\n        Map map = freeColClient.getGame().getMap();\\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\\n                           RenderingHints.VALUE_ANTIALIAS_ON);\\n        repositionMapIfNeeded();\\n        int firstRow = (clipBounds.y - topRowY) / (halfHeight) - 1;\\n        int clipTopY = topRowY + firstRow * (halfHeight);\\n        firstRow = topRow + firstRow;\\n        int firstColumn = (clipBounds.x - leftColumnX) / tileWidth - 1;\\n        int clipLeftX = leftColumnX + firstColumn * tileWidth;\\n        firstColumn = leftColumn + firstColumn;\\n        int lastRow = (clipBounds.y + clipBounds.height - topRowY) / (halfHeight);\\n        lastRow = topRow + lastRow;\\n        int lastColumn = (clipBounds.x + clipBounds.width - leftColumnX) / tileWidth;\\n        lastColumn = leftColumn + lastColumn;\\n        if (freeColClient.getClientOptions().getBoolean(ClientOptions.DISPLAY_GRID)) {\\n            gridPath = new GeneralPath();\\n            gridPath.moveTo(0, 0);\\n            int nextX = halfWidth;\\n            int nextY = -halfHeight;\\n            for (int i = 0; i <= ((lastColumn - firstColumn) * 2 + 1); i++) {\\n                gridPath.lineTo(nextX, nextY);\\n                nextX += halfWidth;\\n                nextY = (nextY == 0 ? -halfHeight : 0);\\n            }\\n        }\\n        g.setColor(Color.black);\\n        g.fillRect(clipBounds.x, clipBounds.y, clipBounds.width, clipBounds.height);\\n        g.translate(clipLeftX, clipTopY);\\n        AffineTransform baseTransform = g.getTransform();\\n        AffineTransform rowTransform = null;\\n                for (int row = firstRow; row <= lastRow; row++) {\\n            rowTransform = g.getTransform();\\n            if (row % 2 == 1) {\\n                g.translate(halfWidth, 0);\\n            }\\n                        for (int column = firstColumn; column <= lastColumn; column++) {\\n                Tile tile = map.getTile(column, row);\\n                displayBaseTile(g, tile, true);\\n                g.translate(tileWidth, 0);\\n            }\\n            g.setTransform(rowTransform);\\n            g.translate(0, halfHeight);\\n        }\\n        g.setTransform(baseTransform);\\n        List<Unit> units = new ArrayList<Unit>();\\n        List<AffineTransform> unitTransforms = new ArrayList<AffineTransform>();\\n        List<Settlement> settlements = new ArrayList<Settlement>();\\n        List<AffineTransform> settlementTransforms = new ArrayList<AffineTransform>();\\n        int colonyLabels = freeColClient.getClientOptions().getInteger(ClientOptions.COLONY_LABELS);\\n        boolean withNumbers = (colonyLabels == ClientOptions.COLONY_LABELS_CLASSIC);\\n                for (int row = firstRow; row <= lastRow; row++) {\\n            rowTransform = g.getTransform();\\n            if (row % 2 == 1) {\\n                g.translate(halfWidth, 0);\\n            }\\n            if (freeColClient.getClientOptions().getBoolean(ClientOptions.DISPLAY_GRID)) {\\n                                g.translate(0, halfHeight);\\n                g.setStroke(gridStroke);\\n                g.setColor(Color.BLACK);\\n                g.draw(gridPath);\\n                g.translate(0, -halfHeight);\\n            }\\n                        for (int column = firstColumn; column <= lastColumn; column++) {\\n                Tile tile = map.getTile(column, row);\\n                                paintBorders(g, tile, BorderType.COUNTRY, true);\\n                                g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\\n                                   RenderingHints.VALUE_ANTIALIAS_OFF);\\n                displayTileOverlays(g, tile, true, withNumbers);\\n                g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\\n                                   RenderingHints.VALUE_ANTIALIAS_ON);\\n                                paintBorders(g, tile, BorderType.COUNTRY, false);\\n                if (viewMode.displayTileCursor(tile)) {\\n                    drawCursor(g);\\n                }\\n                                if (tile != null) {\\n                    Unit unitInFront = getUnitInFront(tile);\\n                    if (unitInFront != null && !isOutForAnimation(unitInFront)) {\\n                        units.add(unitInFront);\\n                        unitTransforms.add(g.getTransform());\\n                    }\\n                                        Settlement settlement = tile.getSettlement();\\n                    if (settlement != null) {\\n                        settlements.add(settlement);\\n                        settlementTransforms.add(g.getTransform());\\n                    }\\n                }\\n                g.translate(tileWidth, 0);\\n            }\\n            g.setTransform(rowTransform);\\n            g.translate(0, halfHeight);\\n        }\\n        g.setTransform(baseTransform);\\n        if (units.size() > 0) {\\n            g.setColor(Color.BLACK);\\n            final Image im = lib.getMiscImage(ImageLibrary.DARKNESS);\\n            for (int index = 0; index < units.size(); index++) {\\n                final Unit unit = units.get(index);\\n                g.setTransform(unitTransforms.get(index));\\n                if (unit.isUndead()) {\\n                                        centerImage(g, im);\\n                }\\n                displayUnit(g, unit);\\n            }\\n            g.setTransform(baseTransform);\\n        }\\n        if (settlements.size() > 0 && colonyLabels != ClientOptions.COLONY_LABELS_NONE) {\\n            Player clientPlayer = freeColClient.getMyPlayer();\\n            for (int index = 0; index < settlements.size(); index++) {\\n                final Settlement settlement = settlements.get(index);\\n                String name = Messages.message(settlement.getNameFor(clientPlayer));\\n                if (name != null) {\\n                    Color backgroundColor = lib.getColor(settlement.getOwner());\\n                    Font font = ResourceManager.getFont(\\\"NormalFont\\\", 18f);\\n                    Font productionFont = ResourceManager.getFont(\\\"NormalFont\\\", 12f);\\n                    int yOffset = tileHeight;\\n                    g.setTransform(settlementTransforms.get(index));\\n                    switch(colonyLabels) {\\n                    case ClientOptions.COLONY_LABELS_CLASSIC:\\n                        Image stringImage = createStringImage(g, name, backgroundColor, font);\\n                        g.drawImage(stringImage, (tileWidth - stringImage.getWidth(null))/2 + 1, yOffset, null);\\n                        break;\\n                    case ClientOptions.COLONY_LABELS_MODERN:\\n                    default:\\n                        backgroundColor = new Color(backgroundColor.getRed(), backgroundColor.getGreen(), backgroundColor.getBlue(), 128);\\n                        TextSpecification[] specs = new TextSpecification[1];\\n                        if (settlement instanceof Colony && settlement.getOwner() == clientPlayer) {\\n                            Colony colony = (Colony) settlement;\\n                            BuildableType buildable = colony.getCurrentlyBuilding();\\n                            if (buildable != null) {\\n                                specs = new TextSpecification[2];\\n                                String turnsStr = Messages.getTurnsText(colony.getTurnsToComplete(buildable));\\n                                String nowBuilding = Messages.message(buildable.getNameKey()) + \\\" \\\" + turnsStr;\\n                                specs[1] = new TextSpecification(nowBuilding, productionFont);\\n                            }\\n                        }\\n                        specs[0] = new TextSpecification(name, font);\\n                        Image nameImage = createLabel(g, specs, backgroundColor);\\n                        if (nameImage != null) {\\n                            int spacing = 3;\\n                            Image leftImage = null;\\n                            Image rightImage = null;\\n                            if (settlement instanceof Colony) {\\n                                String size = Integer.toString(((Colony) settlement).getDisplayUnitCount());\\n                                leftImage = createLabel(g, size, font, backgroundColor);\\n                                if (clientPlayer.owns(settlement)) {\\n                                    int bonusProduction = ((Colony) settlement).getProductionBonus();\\n                                    if (bonusProduction != 0) {\\n                                        String bonus = bonusProduction > 0 ? \\\"+\\\" + bonusProduction : Integer.toString(bonusProduction);\\n                                        rightImage = createLabel(g, bonus, font, backgroundColor);\\n                                    }\\n                                }\\n                            } else if (settlement instanceof IndianSettlement) {\\n                                IndianSettlement nativeSettlement = (IndianSettlement) settlement;\\n                                if (nativeSettlement.getType().isCapital()) {\\n                                    leftImage = createCapitalLabel(nameImage.getHeight(null), 5, backgroundColor);\\n                                }\\n                                Unit missionary = nativeSettlement.getMissionary();\\n                                if (missionary != null) {\\n                                    boolean expert = missionary.hasAbility(Ability.EXPERT_MISSIONARY);\\n                                    backgroundColor = lib.getColor(missionary.getOwner());\\n                                    backgroundColor = new Color(backgroundColor.getRed(), backgroundColor.getGreen(), backgroundColor.getBlue(), 128);\\n                                    rightImage = createReligiousMissionLabel(nameImage.getHeight(null), 5, backgroundColor, expert);\\n                                }\\n                            }\\n                            int width = (int) ((nameImage.getWidth(null)*lib.getScalingFactor())\\n                                + (leftImage != null ? (leftImage.getWidth(null)*lib.getScalingFactor()) + spacing : 0)\\n                                + (rightImage != null ? (rightImage.getWidth(null)*lib.getScalingFactor()) + spacing : 0));\\n                            int labelOffset = (tileWidth - width)/2;\\n                            yOffset -= (nameImage.getHeight(null)*lib.getScalingFactor())/2;\\n                            if (leftImage != null) {\\n                                g.drawImage(leftImage, labelOffset, yOffset, null);\\n                                labelOffset += (leftImage.getWidth(null)*lib.getScalingFactor()) + spacing;\\n                            }\\n                            g.drawImage(nameImage, labelOffset, yOffset, null);\\n                            if (rightImage != null) {\\n                                labelOffset += (nameImage.getWidth(null)*lib.getScalingFactor()) + spacing;\\n                                g.drawImage(rightImage, labelOffset, yOffset, null);\\n                            }\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        g.setTransform(originTransform);\\n        displayGotoPath(g, currentPath);\\n        displayGotoPath(g, gotoPath);\\n        Canvas canvas = gui.getCanvas();\\n        if (!freeColClient.isMapEditor()\\n            && freeColClient.getGame() != null\\n            && !freeColClient.currentPlayerIsMyPlayer()) {\\n            if (greyLayer == null) {\\n                greyLayer = new GrayLayer(lib);\\n            }\\n            if (greyLayer.getParent() == null) {                 canvas.add(greyLayer, JLayeredPane.DEFAULT_LAYER, false);\\n                canvas.moveToFront(greyLayer);\\n            }\\n            greyLayer.setBounds(0,0,canvas.getSize().width, canvas.getSize().height);\\n            greyLayer.setPlayer(freeColClient.getGame().getCurrentPlayer());\\n        }\\n        else {\\n            if (greyLayer != null && greyLayer.getParent() != null) {\\n                canvas.remove(greyLayer, false);\\n            }\\n        }\\n        if (getMessageCount() > 0) {\\n                        synchronized (this) {\\n                Font font = ResourceManager.getFont(\\\"NormalFont\\\", 12f);\\n                GUIMessage message = getMessage(0);\\n                Image si = createStringImage(g, message.getMessage(), message.getColor(), font);\\n                int yy = size.height - 300 - getMessageCount() * si.getHeight(null);\\n                int xx = 40;\\n                for (int i = 0; i < getMessageCount(); i++) {\\n                    message = getMessage(i);\\n                    g.drawImage(createStringImage(g, message.getMessage(), message.getColor(), font),\\n                                xx, yy, null);\\n                    yy += si.getHeight(null);\\n                }\\n            }\\n        }\\n        Image decoration = ResourceManager.getImage(\\\"menuborder.shadow.s.image\\\");\\n        int width = decoration.getWidth(null);\\n        for (int index = 0; index < size.width; index += width) {\\n            g.drawImage(decoration, index, 0, null);\\n        }\\n        decoration = ResourceManager.getImage(\\\"menuborder.shadow.sw.image\\\");\\n        g.drawImage(decoration, 0, 0, null);\\n        decoration = ResourceManager.getImage(\\\"menuborder.shadow.se.image\\\");\\n        g.drawImage(decoration, size.width - decoration.getWidth(null), 0, null);\\n    }\\n    private void displayOptionalValues(Graphics2D g, Tile tile) {\\n        String text = null;\\n        switch (freeColClient.getClientOptions().getInteger(ClientOptions.DISPLAY_TILE_TEXT)) {\\n        case ClientOptions.DISPLAY_TILE_TEXT_NAMES:\\n            if (tile.getNameKey() != null) {\\n                text = Messages.message(tile.getNameKey());\\n            }\\n            break;\\n        case ClientOptions.DISPLAY_TILE_TEXT_OWNERS:\\n            if (tile.getOwner() != null) {\\n                text = Messages.message(tile.getOwner().getNationName());\\n            }\\n            break;\\n        case ClientOptions.DISPLAY_TILE_TEXT_REGIONS:\\n            if (tile.getRegion() != null) {\\n                text = Messages.message(tile.getRegion().getLabel());\\n            }\\n            paintBorders(g, tile, BorderType.REGION, true);\\n            break;\\n        case ClientOptions.DISPLAY_TILE_TEXT_EMPTY:\\n            break;\\n        default:\\n            logger.warning(\\\"displayTileText out of range\\\");\\n            break;\\n        }\\n        if (text != null) {\\n            int b = Messages.getBreakingPoint(text);\\n            if (b == -1) {\\n                centerString(g, text);\\n            } else {\\n                g.setColor(Color.BLACK);\\n                g.setFont(ResourceManager.getFont(\\\"NormalFont\\\", 12f));\\n                g.drawString(text.substring(0, b),\\n                             (tileWidth -\\n                              g.getFontMetrics().stringWidth(text.substring(0, b)))/2,\\n                             halfHeight - (g.getFontMetrics().getAscent()*2)/3);\\n                g.drawString(text.substring(b+1),\\n                             (tileWidth -\\n                              g.getFontMetrics().stringWidth(text.substring(b+1)))/2,\\n                             halfHeight + (g.getFontMetrics().getAscent()*2)/3);\\n            }\\n        }\\n        if (displayCoordinates) {\\n            String posString = tile.getX() + \\\", \\\" + tile.getY();\\n            if (tile.isConnected()) {\\n                posString += \\\"C\\\";\\n            }\\n            centerString(g, posString);\\n        }\\n        if (displayColonyValue && tile.isExplored() && tile.isLand()) {\\n            String valueString;\\n            if (displayColonyValuePlayer == null) {\\n                valueString = Integer.toString(freeColClient.getGame().getCurrentPlayer().getOutpostValue(tile));\\n            } else {\\n                valueString = Integer.toString(displayColonyValuePlayer.getColonyValue(tile));\\n            }\\n            centerString(g, valueString);\\n        }\\n    }\\n    private void displaySettlement(Graphics2D g, Tile tile, boolean withNumber) {\\n        Settlement settlement = tile.getSettlement();\\n        if (settlement != null) {\\n            if (settlement instanceof Colony) {\\n                Image colonyImage = lib.getSettlementImage(settlement);\\n                                centerImage(g, colonyImage);\\n                if (withNumber) {\\n                    String populationString = Integer.toString(((Colony)settlement).getDisplayUnitCount());\\n                    int bonus = ((Colony)settlement).getProductionBonus();\\n                    Color theColor = ResourceManager.getProductionColor(bonus);\\n                    Font font = ResourceManager.getFont(\\\"SimpleFont\\\", Font.BOLD, 12f);\\n                    Image stringImage = createStringImage(g, populationString, theColor, font);\\n                    centerImage(g, stringImage);\\n                }\\n                            } else if (settlement instanceof IndianSettlement) {\\n                IndianSettlement indianSettlement = (IndianSettlement) settlement;\\n                Image settlementImage = lib.getSettlementImage(settlement);\\n                                centerImage(g, settlementImage);\\n                String text = null;\\n                Image chip = null;\\n                Color background = lib.getColor(indianSettlement.getOwner());\\n                Color foreground = getForegroundColor(background);\\n                float xOffset = STATE_OFFSET_X * lib.getScalingFactor();\\n                float yOffset = STATE_OFFSET_Y * lib.getScalingFactor();\\n                int colonyLabels = freeColClient.getClientOptions().getInteger(ClientOptions.COLONY_LABELS);\\n                if (colonyLabels != ClientOptions.COLONY_LABELS_MODERN) {\\n                                        text = indianSettlement.getType().isCapital() ? \\\"*\\\" : \\\"-\\\";\\n                    chip = lib.createChip(text, Color.BLACK, background, foreground);\\n                    g.drawImage(chip, (int) xOffset, (int) yOffset, null);\\n                    xOffset += chip.getWidth(null) + 2;\\n                                        Unit missionary = indianSettlement.getMissionary();\\n                    if (missionary != null) {\\n                        boolean expert = missionary.hasAbility(Ability.EXPERT_MISSIONARY);\\n                        Color mission = (expert ? Color.BLACK : Color.GRAY);\\n                        Color cross = lib.getColor(missionary.getOwner());\\n                        chip = lib.createChip(\\\"\\\\u271D\\\", Color.BLACK, mission, cross);\\n                        g.drawImage(chip, (int) xOffset, (int) yOffset, null);\\n                        xOffset += chip.getWidth(null) + 2;\\n                    }\\n                }\\n                                Player player = freeColClient.getMyPlayer();\\n                if (player != null && indianSettlement.hasContactedSettlement(player)) {\\n                    final boolean visited = indianSettlement.hasSpokenToChief(player);\\n                    chip = lib.createChip((visited ? \\\"!\\\" : \\\"?\\\"), Color.BLACK, background, foreground);\\n                    g.drawImage(chip, (int) xOffset, (int) yOffset, null);\\n                }\\n            } else {\\n                logger.warning(\\\"Requested to draw unknown settlement type.\\\");\\n            }\\n        }\\n    }\\n    private void displayTileItems(Graphics2D g, Tile tile) {\\n                        if (!tile.isExplored()) {\\n            g.drawImage(lib.getTerrainImage(null, tile.getX(), tile.getY()), 0, 0, null);\\n        } else {\\n                        List<TileItem> tileItems = new ArrayList<TileItem>();\\n            if (tile.getTileItemContainer() != null) {\\n                tileItems = tile.getTileItemContainer().getTileItems();\\n            }\\n            int startIndex = 0;\\n            for (int index = startIndex; index < tileItems.size(); index++) {\\n                if (tileItems.get(index).getZIndex() < OVERLAY_INDEX) {\\n                    drawItem(g, tile, tileItems.get(index));\\n                    startIndex = index + 1;\\n                } else {\\n                    startIndex = index;\\n                    break;\\n                }\\n            }\\n                        Image overlayImage = lib.getOverlayImage(tile.getType(), tile.getX(), tile.getY());\\n            if (overlayImage != null) {\\n                g.drawImage(overlayImage, 0, (tileHeight - overlayImage.getHeight(null)), null);\\n            }\\n            for (int index = startIndex; index < tileItems.size(); index++) {\\n                if (tileItems.get(index).getZIndex() < FOREST_INDEX) {\\n                    drawItem(g, tile, tileItems.get(index));\\n                    startIndex = index + 1;\\n                } else {\\n                    startIndex = index;\\n                    break;\\n                }\\n            }\\n                        if (tile.isForested()) {\\n                Image forestImage = lib.getForestImage(tile.getType());\\n                g.drawImage(forestImage, 0, (tileHeight - forestImage.getHeight(null)), null);\\n            }\\n                        for (int index = startIndex; index < tileItems.size(); index++) {\\n                drawItem(g, tile, tileItems.get(index));\\n            }\\n        }\\n    }\\n    private void displayTileOverlays(Graphics2D g, Tile tile,\\n                                     boolean drawUnexploredBorders, boolean withNumber) {\\n        if (tile != null && tile.isExplored()) {\\n            if (drawUnexploredBorders) {\\n                for (Direction direction : Direction.values()) {\\n                    Tile borderingTile = tile.getAdjacentTile(direction);\\n                    if (borderingTile != null && !borderingTile.isExplored()){\\n                        g.drawImage(lib.getBorderImage(null, direction, tile.getX(), tile.getY()), 0, 0, null);\\n                    }\\n                }\\n            }\\n            displayTileItems(g, tile);\\n            displaySettlement(g, tile, withNumber);\\n            displayFogOfWar(g, tile);\\n            displayOptionalValues(g, tile);\\n        }\\n    }\\n    private void displayUnit(Graphics2D g, Unit unit) {\\n        try {\\n                                    if (viewMode.displayUnitCursor(unit)) {\\n                drawCursor(g);\\n            }\\n                                    boolean fade = (unit.getState() == Unit.UnitState.SENTRY)\\n                || (unit.getTile() != null\\n                    && !freeColClient.getMyPlayer().canSee(unit.getTile()));\\n            Image image = lib.getUnitImageIcon(unit, fade).getImage();\\n            Point p = getUnitImagePositionInTile(image);\\n            g.drawImage(image, p.x, p.y, null);\\n                        g.drawImage(getOccupationIndicatorImage(g, unit),\\n                        (int) (STATE_OFFSET_X * lib.getScalingFactor()), 0, null);\\n                        int unitsOnTile = 0;\\n            if (unit.getTile() != null) {\\n                                                                unitsOnTile = unit.getTile().getTotalUnitCount();\\n            }\\n            if (unitsOnTile > 1) {\\n                g.setColor(Color.WHITE);\\n                int unitLinesY = OTHER_UNITS_OFFSET_Y;\\n                int x1 = (int) ((STATE_OFFSET_X + OTHER_UNITS_OFFSET_X) * lib.getScalingFactor());\\n                int x2 = (int) ((STATE_OFFSET_X + OTHER_UNITS_OFFSET_X + OTHER_UNITS_WIDTH) * lib.getScalingFactor());\\n                for (int i = 0; (i < unitsOnTile) && (i < MAX_OTHER_UNITS); i++) {\\n                    g.drawLine(x1, unitLinesY, x2, unitLinesY);\\n                    unitLinesY += 2;\\n                }\\n            }\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n                if (debugShowMission\\n            && freeColClient.getFreeColServer() != null\\n            && (unit.getOwner().isAI()\\n                || unit.hasAbility(Ability.PIRACY))) {\\n            net.sf.freecol.server.ai.AIUnit au = freeColClient\\n                .getFreeColServer().getAIMain().getAIUnit(unit);\\n            if (au != null) {\\n                g.setColor(Color.WHITE);\\n                String text = (unit.getOwner().isAI()) ? \\\"\\\" : \\\"(\\\";\\n                String debuggingInfo = \\\"\\\";\\n                if (au.getMission() != null) {\\n                    String missionName = au.getMission().getClass().toString();\\n                    missionName = missionName.substring(missionName.lastIndexOf('.') + 1);\\n                    text += missionName;\\n                    if (debugShowMissionInfo) {\\n                        debuggingInfo = au.getMission().getDebuggingInfo();\\n                    }\\n                } else {\\n                    text += \\\"No mission\\\";\\n                }\\n                text += (unit.getOwner().isAI()) ? \\\"\\\" : \\\")\\\";\\n                g.drawString(text, 0 , 0);\\n                g.drawString(debuggingInfo, 0 , 25);\\n            }\\n        }\\n    }\\n    private void drawCursor(Graphics2D g) {\\n        g.drawImage(cursorImage, 0, 0, null);\\n    }\\n    private void drawItem(Graphics2D g, Tile tile, TileItem item) {\\n        if (item instanceof Resource) {\\n            Image bonusImage = lib.getBonusImage(((Resource) item).getType());\\n            if (bonusImage != null) {\\n                centerImage(g, bonusImage);\\n            }\\n        } else if (item instanceof LostCityRumour) {\\n            centerImage(g, lib.getMiscImage(ImageLibrary.LOST_CITY_RUMOUR));\\n        } else {\\n            TileImprovement improvement = (TileImprovement) item;\\n            if (improvement.isComplete()) {\\n                String key = improvement.getType().getId() + \\\".image\\\";\\n                if (ResourceManager.hasResource(key)) {\\n                                        Image overlay = ResourceManager.getImage(key, lib.getScalingFactor());\\n                    g.drawImage(overlay, 0, 0, null);\\n                } else if (improvement.isRiver() && improvement.getMagnitude() < TileImprovement.FJORD_RIVER) {\\n                    g.drawImage(lib.getRiverImage(improvement.getStyle()), 0, 0, null);\\n                } else if (improvement.isRoad()) {\\n                    drawRoad(g, tile);\\n                }\\n            }\\n        }\\n    }\\n    private void drawRoad(Graphics2D g, Tile tile) {\\n        Color oldColor = g.getColor();\\n        g.setColor(ResourceManager.getColor(\\\"road.color\\\"));\\n        g.setStroke(roadStroke);\\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\\n        GeneralPath path = new GeneralPath();\\n        List<Point2D.Float> points = new ArrayList<Point2D.Float>(8);\\n        List<Direction> directions = new ArrayList<Direction>(8);\\n        for (Direction direction : Direction.values()) {\\n            Tile borderingTile = tile.getAdjacentTile(direction);\\n            TileImprovement r;\\n            if (borderingTile != null\\n                && (r = borderingTile.getRoad()) != null\\n                && r.isComplete()) {\\n                points.add(corners.get(direction));\\n                directions.add(direction);\\n            }\\n        }\\n        switch(points.size()) {\\n        case 0:\\n            path.moveTo(0.35f * tileWidth, 0.35f * tileHeight);\\n            path.lineTo(0.65f * tileWidth, 0.65f * tileHeight);\\n            path.moveTo(0.35f * tileWidth, 0.65f * tileHeight);\\n            path.lineTo(0.65f * tileWidth, 0.35f * tileHeight);\\n            break;\\n        case 1:\\n            path.moveTo(halfWidth, halfHeight);\\n            path.lineTo(points.get(0).getX(), points.get(0).getY());\\n            break;\\n        case 2:\\n            path.moveTo(points.get(0).getX(), points.get(0).getY());\\n            path.quadTo(halfWidth, halfHeight, points.get(1).getX(), points.get(1).getY());\\n            break;\\n        case 3:\\n        case 4: {\\n            Direction pen = directions.get(directions.size() - 1);\\n            Point2D p = corners.get(pen);\\n            path.moveTo(p.getX(), p.getY());\\n            for (Direction d : directions) {\\n                p = corners.get(d);\\n                if(prohibitedRoads.get(pen).contains(d)) {\\n                    path.moveTo(p.getX(), p.getY());\\n                } else {\\n                    path.quadTo(halfWidth, halfHeight, p.getX(), p.getY());\\n                }\\n                pen = d;\\n            }\\n            break;\\n        }\\n        default:\\n            for (Point2D p : points) {\\n                path.moveTo(halfWidth, halfHeight);\\n                path.lineTo(p.getX(), p.getY());\\n            }\\n        }\\n        g.draw(path);\\n        g.setColor(oldColor);\\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);\\n    }\\n    private JLabel enterUnitOutForAnimation(final Unit unit, final Tile sourceTile) {\\n        Integer i = unitsOutForAnimation.get(unit);\\n        if (i == null) {\\n            final JLabel unitLabel = getUnitLabel(unit);\\n            final Integer UNIT_LABEL_LAYER = JLayeredPane.DEFAULT_LAYER;\\n            i = 1;\\n            unitLabel.setLocation(getUnitLabelPositionInTile(unitLabel,\\n                    getTilePosition(sourceTile)));\\n            unitsOutForAnimationLabels.put(unit, unitLabel);\\n            gui.getCanvas().add(unitLabel, UNIT_LABEL_LAYER, false);\\n        } else {\\n            i++;\\n        }\\n        unitsOutForAnimation.put(unit, i);\\n        return unitsOutForAnimationLabels.get(unit);\\n    }\\n    private Color getForegroundColor(Color background) {\\n        if (background.getRed() * 0.3\\n                + background.getGreen() * 0.59\\n                + background.getBlue() * 0.11 < 126) {\\n            return Color.WHITE;\\n        } else {\\n            return Color.BLACK;\\n        }\\n    }\\n    private int getLeftColumns() {\\n        return getLeftColumns(focus.getY());\\n    }\\n    private int getLeftColumns(int y) {\\n        int leftColumns = leftSpace / tileWidth + 1;\\n        if ((y % 2) == 0) {\\n            if ((leftSpace % tileWidth) > 32) {\\n                leftColumns++;\\n            }\\n        } else {\\n            if ((leftSpace % tileWidth) == 0) {\\n                leftColumns--;\\n            }\\n        }\\n        return leftColumns;\\n    }\\n    private GUIMessage getMessage(int index) {\\n        return messages.get(index);\\n    }\\n    private int getMessageCount() {\\n        return messages.size();\\n    }\\n    private int getRightColumns() {\\n        return getRightColumns(focus.getY());\\n    }\\n    private int getRightColumns(int y) {\\n        int rightColumns = rightSpace / tileWidth + 1;\\n        if ((y % 2) == 0) {\\n            if ((rightSpace % tileWidth) == 0) {\\n                rightColumns--;\\n            }\\n        } else {\\n            if ((rightSpace % tileWidth) > 32) {\\n                rightColumns++;\\n            }\\n        }\\n        return rightColumns;\\n    }\\n    private Color getStringBorderColor(Color color) {\\n        if (color.getRed() * 0.3\\n                + color.getGreen() * 0.59\\n                + color.getBlue() * 0.11 < 10) {\\n            return Color.WHITE;\\n        } else {\\n            return Color.BLACK;\\n        }\\n    }\\n    private Point getUnitImagePositionInTile(Image unitImage) {\\n        int unitX = (tileWidth - unitImage.getWidth(null)) / 2;\\n        int unitY = (tileHeight - unitImage.getHeight(null)) / 2 -\\n                    (int) (UNIT_OFFSET * lib.getScalingFactor());\\n        return new Point(unitX, unitY);\\n    }\\n    private Unit getUnitInFront(Tile unitTile) {\\n        if (unitTile == null || unitTile.getUnitCount() <= 0) {\\n            return null;\\n        }\\n        if (activeUnit != null && activeUnit.getTile() == unitTile) {\\n            return activeUnit;\\n        } else {\\n            if (unitTile.getSettlement() == null) {\\n                Unit bestDefendingUnit = null;\\n                if (activeUnit != null) {\\n                    bestDefendingUnit = unitTile.getDefendingUnit(activeUnit);\\n                    if (bestDefendingUnit != null) {\\n                        return bestDefendingUnit;\\n                    }\\n                }\\n                Unit movableUnit = unitTile.getMovableUnit();\\n                if (movableUnit != null && movableUnit.getLocation() == movableUnit.getTile()) {\\n                    return movableUnit;\\n                } else {\\n                    Unit bestPick = null;\\n                    Iterator<Unit> unitIterator = unitTile.getUnitIterator();\\n                    while (unitIterator.hasNext()) {\\n                        Unit u = unitIterator.next();\\n                        if (bestPick == null || bestPick.getMovesLeft() < u.getMovesLeft()) {\\n                            bestPick = u;\\n                        }\\n                    }\\n                    return bestPick;\\n                }\\n            } else {\\n                return null;\\n            }\\n        }\\n    }\\n    private JLabel getUnitLabel(Unit unit) {\\n        final Image unitImg = lib.getUnitImageIcon(unit).getImage();\\n        final int width = halfWidth + unitImg.getWidth(null)/2;\\n        final int height = unitImg.getHeight(null);\\n        BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\\n        Graphics g = img.getGraphics();\\n        final int unitX = (width - unitImg.getWidth(null)) / 2;\\n        g.drawImage(unitImg, unitX, 0, null);\\n        final JLabel label = new JLabel(new ImageIcon(img));\\n        label.setSize(width, height);\\n        return label;\\n    }\\n    private boolean isOutForAnimation(final Unit unit) {\\n        return unitsOutForAnimation.containsKey(unit);\\n    }\\n    private boolean isTileVisible(Tile tile) {\\n        return tile.getY() >= topRow && tile.getY() <= bottomRow\\n            && tile.getX() >= leftColumn && tile.getX() <= rightColumn;\\n    }\\n    private boolean noActiveUnitIsAt(Tile selectedTile) {\\n        return activeUnit == null ||\\n            (activeUnit.getTile() != null &&\\n             !activeUnit.getTile().equals(selectedTile));\\n    }\\n    private void paintBorders(Graphics2D g, Tile tile, BorderType type, boolean opaque) {\\n        if (tile == null ||\\n            (type == BorderType.COUNTRY\\n             && !freeColClient.getClientOptions().getBoolean(ClientOptions.DISPLAY_BORDERS))) {\\n            return;\\n        }\\n        Player owner = tile.getOwner();\\n        Region region = tile.getRegion();\\n        if ((type == BorderType.COUNTRY && owner != null)\\n            || (type == BorderType.REGION && region != null)) {\\n            Stroke oldStroke = g.getStroke();\\n            g.setStroke(borderStroke);\\n            Color oldColor = g.getColor();\\n            Color newColor = Color.WHITE;\\n            if (type == BorderType.COUNTRY) {\\n                newColor = new Color(lib.getColor(owner).getRed(),\\n                                     lib.getColor(owner).getGreen(),\\n                                     lib.getColor(owner).getBlue(),\\n                                     opaque ? 255 : 100);\\n            }\\n            g.setColor(newColor);\\n            GeneralPath path = new GeneralPath(GeneralPath.WIND_EVEN_ODD);\\n            path.moveTo(borderPoints.get(Direction.longSides[0]).x,\\n                        borderPoints.get(Direction.longSides[0]).y);\\n            for (Direction d : Direction.longSides) {\\n                Tile otherTile = tile.getNeighbourOrNull(d);\\n                Direction next = d.getNextDirection();\\n                Direction next2 = next.getNextDirection();\\n                if (otherTile == null\\n                    || (type == BorderType.COUNTRY && !owner.owns(otherTile))\\n                    || (type == BorderType.REGION && otherTile.getRegion() != region)) {\\n                    Tile tile1 = tile.getNeighbourOrNull(next);\\n                    Tile tile2 = tile.getNeighbourOrNull(next2);\\n                    if (tile2 == null\\n                        || (type == BorderType.COUNTRY && !owner.owns(tile2))\\n                        || (type == BorderType.REGION && tile2.getRegion() != region)) {\\n                                                path.lineTo(borderPoints.get(next).x,\\n                                    borderPoints.get(next).y);\\n                        path.quadTo(controlPoints.get(next).x,\\n                                    controlPoints.get(next).y,\\n                                    borderPoints.get(next2).x,\\n                                    borderPoints.get(next2).y);\\n                    } else {\\n                        int dx = 0, dy = 0;\\n                        switch(d) {\\n                        case NW: dx = halfWidth; dy = -halfHeight; break;\\n                        case NE: dx = halfWidth; dy = halfHeight; break;\\n                        case SE: dx = -halfWidth; dy = halfHeight; break;\\n                        case SW: dx = -halfWidth; dy = -halfHeight; break;\\n                        }\\n                        if (tile1 != null\\n                            && ((type == BorderType.COUNTRY && owner.owns(tile1))\\n                                || (type == BorderType.REGION && tile1.getRegion() == region))) {\\n                                                        path.lineTo(borderPoints.get(next).x,\\n                                        borderPoints.get(next).y);\\n                                                        Direction previous = d.getPreviousDirection();\\n                            Direction previous2 = previous.getPreviousDirection();\\n                            int ddx = 0, ddy = 0;\\n                            switch(d) {\\n                            case NW: ddy = -tileHeight; break;\\n                            case NE: ddx = tileWidth; break;\\n                            case SE: ddy = tileHeight; break;\\n                            case SW: ddx = -tileWidth; break;\\n                            }\\n                            path.quadTo(controlPoints.get(previous).x + dx,\\n                                        controlPoints.get(previous).y + dy,\\n                                        borderPoints.get(previous2).x + ddx,\\n                                        borderPoints.get(previous2).y + ddy);\\n                        } else {\\n                                                        path.lineTo(borderPoints.get(d).x + dx,\\n                                        borderPoints.get(d).y + dy);\\n                        }\\n                    }\\n                } else {\\n                    path.moveTo(borderPoints.get(next2).x,\\n                                borderPoints.get(next2).y);\\n                }\\n            }\\n            g.draw(path);\\n            g.setColor(oldColor);\\n            g.setStroke(oldStroke);\\n        }\\n    }\\n    private void positionMap(Tile pos) {\\n        Game gameData = freeColClient.getGame();\\n        int x = pos.getX(),\\n            y = pos.getY();\\n        int leftColumns = getLeftColumns(),\\n            rightColumns = getRightColumns();\\n        if (y < topRows) {\\n                        bottomRow = (size.height / (halfHeight)) - 1;\\n            if ((size.height % (halfHeight)) != 0) {\\n                bottomRow++;\\n            }\\n            topRow = 0;\\n            bottomRowY = bottomRow * (halfHeight);\\n            topRowY = 0;\\n        } else if (y >= (gameData.getMap().getHeight() - bottomRows)) {\\n                        bottomRow = gameData.getMap().getHeight() - 1;\\n            topRow = size.height / (halfHeight);\\n            if ((size.height % (halfHeight)) > 0) {\\n                topRow++;\\n            }\\n            topRow = gameData.getMap().getHeight() - topRow;\\n            bottomRowY = size.height - tileHeight;\\n            topRowY = bottomRowY - (bottomRow - topRow) * (halfHeight);\\n        } else {\\n                        bottomRow = y + bottomRows;\\n            topRow = y - topRows;\\n            bottomRowY = topSpace + (halfHeight) * bottomRows;\\n            topRowY = topSpace - topRows * (halfHeight);\\n        }\\n        if (x < leftColumns) {\\n                        leftColumn = 0;\\n            rightColumn = size.width / tileWidth - 1;\\n            if ((size.width % tileWidth) > 0) {\\n                rightColumn++;\\n            }\\n            leftColumnX = 0;\\n        } else if (x >= (gameData.getMap().getWidth() - rightColumns)) {\\n                        rightColumn = gameData.getMap().getWidth() - 1;\\n            leftColumn = size.width / tileWidth;\\n            if ((size.width % tileWidth) > 0) {\\n                leftColumn++;\\n            }\\n            leftColumnX = size.width - tileWidth - halfWidth -\\n                leftColumn * tileWidth;\\n            leftColumn = rightColumn - leftColumn;\\n        } else {\\n                        leftColumn = x - leftColumns;\\n            rightColumn = x + rightColumns;\\n            leftColumnX = (size.width - tileWidth) / 2 - leftColumns * tileWidth;\\n        }\\n    }\\n    private void redrawMapControls() {\\n        int x = 0, y = 0;\\n        MapControls mapControls = gui.getCanvas().getMapControls();\\n        if (mapControls != null) {\\n            x = getWidth() - mapControls.getInfoPanelWidth();\\n            y = getHeight() - mapControls.getInfoPanelHeight();\\n        }\\n        gui.getCanvas().repaint(x, y, getWidth(), getHeight());\\n    }\\n    private void releaseUnitOutForAnimation(final Unit unit) {\\n        Integer i = unitsOutForAnimation.get(unit);\\n        if (i == null) {\\n            throw new IllegalStateException(\\\"Tried to release unit that was not out for animation\\\");\\n        }\\n        if (i == 1) {\\n            unitsOutForAnimation.remove(unit);\\n            gui.getCanvas().remove(unitsOutForAnimationLabels.remove(unit), false);\\n        } else {\\n            i--;\\n            unitsOutForAnimation.put(unit, i);\\n        }\\n    }\\n    private synchronized boolean removeOldMessages() {\\n        long currentTime = new Date().getTime();\\n        boolean result = false;\\n        int i = 0;\\n        while (i < getMessageCount()) {\\n            long messageCreationTime = getMessage(i).getCreationTime().getTime();\\n            if ((currentTime - messageCreationTime) >= MESSAGE_AGE) {\\n                result = true;\\n                messages.remove(i);\\n            } else {\\n                i++;\\n            }\\n        }\\n        return result;\\n    }\\n    private void repositionMapIfNeeded() {\\n        if (bottomRow < 0 && focus != null)\\n            positionMap(focus);\\n    }\\n    private void setImageLibrary(ImageLibrary lib) {\\n        this.lib = lib;\\n        cursorImage = lib.getMiscImage(ImageLibrary.UNIT_SELECT);\\n                tileHeight = lib.getTerrainImageHeight(null);\\n        halfHeight = tileHeight/2;\\n        tileWidth = lib.getTerrainImageWidth(null);\\n        halfWidth = tileWidth/2;\\n        int dx = tileWidth/16;\\n        int dy = tileHeight/16;\\n        int ddx = dx + dx/2;\\n        int ddy = dy + dy/2;\\n                corners.put(Direction.N,  new Point2D.Float(halfWidth, 0));\\n        corners.put(Direction.NE, new Point2D.Float(0.75f * tileWidth, 0.25f * tileHeight));\\n        corners.put(Direction.E,  new Point2D.Float(tileWidth, halfHeight));\\n        corners.put(Direction.SE, new Point2D.Float(0.75f * tileWidth, 0.75f * tileHeight));\\n        corners.put(Direction.S,  new Point2D.Float(halfWidth, tileHeight));\\n        corners.put(Direction.SW, new Point2D.Float(0.25f * tileWidth, 0.75f * tileHeight));\\n        corners.put(Direction.W,  new Point2D.Float(0, halfHeight));\\n        corners.put(Direction.NW, new Point2D.Float(0.25f * tileWidth, 0.25f * tileHeight));\\n                controlPoints.put(Direction.N, new Point2D.Float(halfWidth, dy));\\n        controlPoints.put(Direction.E, new Point2D.Float(tileWidth - dx, halfHeight));\\n        controlPoints.put(Direction.S, new Point2D.Float(halfWidth, tileHeight - dy));\\n        controlPoints.put(Direction.W, new Point2D.Float(dx, halfHeight));\\n                controlPoints.put(Direction.SE, new Point2D.Float(halfWidth, tileHeight));\\n        controlPoints.put(Direction.NE, new Point2D.Float(tileWidth, halfHeight));\\n        controlPoints.put(Direction.SW, new Point2D.Float(0, halfHeight));\\n        controlPoints.put(Direction.NW, new Point2D.Float(halfWidth, 0));\\n                borderPoints.put(Direction.NW, new Point2D.Float(dx + ddx, halfHeight - ddy));\\n        borderPoints.put(Direction.N,  new Point2D.Float(halfWidth - ddx, dy + ddy));\\n        borderPoints.put(Direction.NE, new Point2D.Float(halfWidth + ddx, dy + ddy));\\n        borderPoints.put(Direction.E,  new Point2D.Float(tileWidth - dx - ddx, halfHeight - ddy));\\n        borderPoints.put(Direction.SE, new Point2D.Float(tileWidth - dx - ddx, halfHeight + ddy));\\n        borderPoints.put(Direction.S,  new Point2D.Float(halfWidth + ddx, tileHeight - dy - ddy));\\n        borderPoints.put(Direction.SW, new Point2D.Float(halfWidth - ddx, tileHeight - dy - ddy));\\n        borderPoints.put(Direction.W,  new Point2D.Float(dx + ddx, halfHeight + ddy));\\n                                prohibitedRoads.put(Direction.N,  Arrays.asList(Direction.NW, Direction.NE));\\n        prohibitedRoads.put(Direction.NE, Arrays.asList(Direction.N, Direction.E));\\n        prohibitedRoads.put(Direction.E,  Arrays.asList(Direction.NE, Direction.SE));\\n        prohibitedRoads.put(Direction.SE, Arrays.asList(Direction.E, Direction.S));\\n        prohibitedRoads.put(Direction.S,  Arrays.asList(Direction.SE, Direction.SW));\\n        prohibitedRoads.put(Direction.SW, Arrays.asList(Direction.S, Direction.W));\\n        prohibitedRoads.put(Direction.W,  Arrays.asList(Direction.SW, Direction.NW));\\n        prohibitedRoads.put(Direction.NW, Arrays.asList(Direction.W, Direction.N));\\n        borderStroke = new BasicStroke(dy);\\n        roadStroke = new BasicStroke(dy/2);\\n        gridStroke = new BasicStroke(lib.getScalingFactor());\\n        fog.reset();\\n        fog.moveTo(halfWidth, 0);\\n        fog.lineTo(tileWidth, halfHeight);\\n        fog.lineTo(halfWidth, tileHeight);\\n        fog.lineTo(0, halfHeight);\\n        fog.closePath();\\n        updateMapDisplayVariables();\\n    }\\n    private void updateMapDisplayVariables() {\\n                topSpace = (size.height - tileHeight) / 2;\\n        if ((topSpace % (halfHeight)) != 0) {\\n            topRows = topSpace / (halfHeight) + 2;\\n        } else {\\n            topRows = topSpace / (halfHeight) + 1;\\n        }\\n        bottomRows = topRows;\\n        leftSpace = (size.width - tileWidth) / 2;\\n        rightSpace = leftSpace;\\n    }\\n}\""
            },
            "m15": {
                "content": "The source code of `MapViewer.java` reveals that it is a **central component** of the FreeCol GUI system, responsible for rendering and interacting with the game map. It handles:\n\n- **Tile rendering**, including terrain, borders, units, settlements, and overlays.\n- **User interactions**, such as tile selection, unit control, and camera movement.\n- **Integration with core game logic**, via `FreeColClient`, to reflect game state changes in real-time.\n- **Visual feedback**, such as fog of war, goto paths, and UI labels.\n\n### Final CIA Summary: Entities to Synchronize with `MapViewer.java`\n\nBased on all the analyses performed, here are the entities that should be synchronized when changes are made to `MapViewer.java`:\n\n---\n\n\u2705 **Strongly Coupled & Co-Changed Entities**\n1. **`FreeColClient`**\n   - **Why**: Strong method-level coupling; used extensively for accessing game data and control logic.\n   - **Impact**: Changes in `FreeColClient` will almost certainly affect how `MapViewer` behaves.\n\n2. **`GUI`**\n   - **Why**: Frequently called to access UI components like `Canvas`, update menus, refresh tiles, etc.\n   - **Impact**: UI-related changes in `GUI` can directly influence map display and interaction logic.\n\n---\n\n\ud83d\udfe1 **High Co-Change Confidence but No Direct Coupling**\n3. **`Canvas`**\n   - **Why**: High historical co-change confidence (0.5), likely due to shared UI responsibilities.\n   - **Impact**: Indirect impact; may require synchronization if broader UI refactorings occur.\n\n---\n\n\ud83d\udfe0 **Core Game Entities (Used via Call Graph)**\n4. **Game Logic Classes**\n   - Examples: `Game`, `Player`, `Unit`, `Tile`, `Settlement`, `Colony`, `IndianSettlement`, `Europe`, `Resource`, `Map`\n   - **Why**: Heavily referenced in rendering and interaction logic.\n   - **Impact**: Structural or API changes in these classes could break `MapViewer` functionality.\n\n5. **UI Support Classes**\n   - Examples: `ImageLibrary`, `ResourceManager`, `InfoPanel`, `MapControls`, `ClientOptions`\n   - **Why**: Used for rendering images, strings, and managing UI states.\n   - **Impact**: Changes in resource handling or UI configuration may affect visuals or behavior.\n\n---\n\n### \u2705 Final Recommendation\n\nWhen modifying `MapViewer.java`, the following files should be considered for **synchronized changes**:\n\n| Entity | Type | Reason |\n|-------|------|--------|\n| `FreeColClient` | Core Controller | Strong coupling, frequent use |\n| `GUI` | UI Controller | Frequent calls, UI updates |\n| `Canvas` | UI Component | High co-change history |\n| `Game`, `Player`, `Unit`, `Tile`, etc. | Core Models | Heavy usage in display logic |\n| `ImageLibrary`, `ResourceManager`, `InfoPanel`, etc. | UI Helpers | Visual/UI integration |\n\nThis comprehensive analysis ensures that future modifications to `MapViewer.java` consider ripple effects across the system, minimizing regression risks and improving change accuracy.",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            },
            "m16": {
                "role": "user",
                "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
            },
            "m17": {
                "content": "Title: Diagnosis of starting entity `MapViewer.java`\n\nChange set: [FreeColClient, GUI, Canvas, Game, Player, Unit, Tile, Settlement, Colony, IndianSettlement, Europe, Resource, Map, InfoPanel, MapControls, ClientOptions, GameOptions, ImageLibrary, ResourceManager, Messages, Ability, BuildableType, PathNode, StringTemplate, ColonyTile, Region, FreeCol, TileImprovement, LostCityRumour, TileItem, InGameInputHandler, MiniMap, AudioMixerOptionUI, WorkProductionPanel, MapEditorController, ZoomOutAction, ZoomInAction, RefreshTilesSwingTask, PreGameController]\n\nDetails:\n1. **FreeColClient**: Strong coupling found in multiple methods like getGame, getMyPlayer, getInGameController, etc., indicating heavy reliance on game state and control logic.\n2. **GUI**: Direct method calls for UI updates (getCanvas, refresh, updateMenuBar), showing tight integration with UI behavior.\n3. **Canvas**: High co-change confidence (0.5), though no direct coupling; likely due to shared rendering responsibilities.\n4. **Game**: Frequently accessed via FreeColClient to retrieve map and player data for rendering.\n5. **Player**: Used to determine ownership, visibility, and color schemes for visual differentiation.\n6. **Unit**: Core to rendering unit graphics, occupation indicators, and unit-related actions.\n7. **Tile**: Central to map rendering logic, including terrain, borders, items, and overlays.\n8. **Settlement**: Rendered directly, with special handling for colony and native settlements.\n9. **Colony**: Derived from Settlement; includes extra rendering logic for population, production, and colony state.\n10. **IndianSettlement**: Native settlement type with unique religious mission and capital indicators.\n11. **Europe**: Related to unit pathfinding and destination logic.\n12. **Resource**: Visualized as tile improvements or bonuses in the map.\n13. **Map**: Accessed frequently to determine tile positions, map bounds, and navigation.\n14. **InfoPanel**: Part of the GUI system used to display contextual map information.\n15. **MapControls**: Integrated into the map viewer UI for zooming, panning, and other controls.\n16. **ClientOptions**: Used to determine user preferences affecting map display (e.g., fog of war, labels).\n17. **GameOptions**: Affects game-wide behaviors that influence how map elements are displayed.\n18. **ImageLibrary**: Critical for rendering map tiles, unit images, icons, and overlay graphics.\n19. **ResourceManager**: Supplies fonts, colors, and dynamic images used in map rendering.\n20. **Messages**: Localizes text shown on the map (e.g., settlement names, tooltips).\n21. **Ability**: Used to determine unit capabilities and visual indicators (e.g., expert missionary).\n22. **BuildableType**: Determines what can be built in colonies and affects rendering logic.\n23. **PathNode**: Used in goto path visualization and unit movement planning.\n24. **StringTemplate**: Supports localized message formatting for map tooltips and labels.\n25. **ColonyTile**: Provides context for colony-related tile rendering and overlays.\n26. **Region**: Influences map border drawing when region display mode is active.\n27. **FreeCol**: Likely a top-level class involved in global application configuration.\n28. **TileImprovement**: Represents roads, rivers, and other enhancements rendered on tiles.\n29. **LostCityRumour**: Special tile item with dedicated rendering logic.\n30. **TileItem**: Base class for all objects placed on tiles (e.g., resources, improvements).\n31. **InGameInputHandler**: Co-changed with MapViewer (confidence 0.25); may share input routing logic.\n32. **MiniMap**: Co-changed (confidence 0.25); likely shares map state or viewport synchronization.\n33. **AudioMixerOptionUI**: Co-changed (confidence 0.25); possibly part of a broader UI refactoring pattern.\n34. **WorkProductionPanel**: Co-changed (confidence 0.25); could relate to colony work/production visuals.\n35. **MapEditorController**: Co-changed (confidence 0.25); may share map rendering or editing logic.\n36. **ZoomOutAction**: Co-changed (confidence 0.25); tied to map scaling and display logic.\n37. **ZoomInAction**: Similar to ZoomOutAction, affects map scale and rendering.\n38. **RefreshTilesSwingTask**: Co-changed (confidence 0.25); may involve tile redrawing or animation.\n39. **PreGameController**: Co-changed (confidence 0.25); possibly related to initial map setup or UI flow.\n40. **RefreshTilesSwingTask**: Co-changed (confidence 0.25); potentially involved in tile state updates.\n\nThese entities should be synchronized during changes to `MapViewer.java` due to strong coupling, frequent co-change history, or functional interdependence in rendering and interaction logic.",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            }
        }
    }
}