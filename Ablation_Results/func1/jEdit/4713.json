{
    "time": 1749543860.3090467,
    "messages": [
        {
            "role": "system",
            "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
        },
        {
            "role": "user",
            "content": "The project you need to analyze is `jEdit`, a well-known Java open source project. The starting entity you need to deal with is DisplayManager.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
        },
        {
            "content": "",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_9b91e2ea870f42309ce652",
                    "function": {
                        "arguments": "{\"entity\": \"DisplayManager.java\"}",
                        "name": "get_co_change_relationship"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "name": "get_co_change_relationship",
            "role": "tool",
            "content": "[[\"FirstLine\", \"6\", \"0.375\"], [\"ScrollLineCount\", \"6\", \"0.375\"], [\"ChunkCache\", \"6\", \"0.375\"], [\"HelpIndex\", \"2\", \"0.125\"], [\"HelpTOCPanel\", \"2\", \"0.125\"], [\"View\", \"2\", \"0.125\"], [\"BufferChangeHandler\", \"9\", \"0.5625\"], [\"BufferIORequest\", \"4\", \"0.25\"], [\"RingListModel\", \"2\", \"0.125\"], [\"OffsetManager\", \"2\", \"0.125\"], [\"PosBottomHalf\", \"2\", \"0.125\"], [\"PositionManager\", \"2\", \"0.125\"], [\"PasteFromListDialog\", \"2\", \"0.125\"], [\"ListHandler\", \"2\", \"0.125\"], [\"KeyHandler\", \"2\", \"0.125\"], [\"FontSelector\", \"2\", \"0.125\"], [\"FontSelectorDialog\", \"2\", \"0.125\"], [\"TextAreaOptionPane\", \"2\", \"0.125\"], [\"ActionHandler\", \"2\", \"0.125\"], [\"JEditTextArea\", \"3\", \"0.1875\"], [\"TextAreaPainter\", \"2\", \"0.125\"], [\"EditPane\", \"2\", \"0.125\"], [\"BeanShell\", \"2\", \"0.125\"], [\"MouseHandler\", \"1\", \"0.0625\"], [\"Anchor\", \"1\", \"0.0625\"], [\"RangeMap\", \"1\", \"0.0625\"]]"
        },
        {
            "content": "The `get_co_change_relationship` function has returned a list of entities along with the number of supports and confidence values. These represent files that were historically modified together with `DisplayManager.java`. To prioritize the most relevant files for synchronization, we should focus on those with higher confidence values (e.g., >0.3).\n\nHere are the notable co-changed entities with their confidence values:\n1. **BufferChangeHandler.java** - Confidence: 0.5625\n2. **FirstLine.java**, **ScrollLineCount.java**, **ChunkCache.java** - Confidence: 0.375\n\nThese files show significant historical co-change relationships with `DisplayManager.java`. We can proceed by analyzing the semantic coupling between `DisplayManager.java` and these top candidates to validate if they are conceptually related.\n\nI suggest starting with `BufferChangeHandler.java`, as it has the highest confidence value. Let's calculate the conceptual coupling between `DisplayManager.java` and `BufferChangeHandler.java`.\n\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_012fbbda9cf9413ea7670d",
                    "function": {
                        "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"BufferChangeHandler.java\"}",
                        "name": "get_conceptual_coupling"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_conceptual_coupling",
            "content": "[\"BufferChangeHandler has been removed from the project due to project version iteration\"]"
        },
        {
            "content": "It appears that `BufferChangeHandler.java` has been removed from the project in a previous version iteration, which explains why it no longer exists for further analysis.\n\nGiven this, we should shift our focus to the next set of files with high confidence values from the co-change relationship:  \n- **FirstLine.java**, **ScrollLineCount.java**, and **ChunkCache.java** (all with 0.375 confidence).\n\nLet\u2019s examine the conceptual coupling between `DisplayManager.java` and one of these\u2014say, `FirstLine.java`\u2014to determine if there is still a strong semantic relationship:\n\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_7ce2bee7a98e4e2ab07477",
                    "function": {
                        "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"FirstLine.java\"}",
                        "name": "get_conceptual_coupling"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_conceptual_coupling",
            "content": "[\"FirstLine has been removed from the project due to project version iteration\"]"
        },
        {
            "content": "Similar to `BufferChangeHandler.java`, it seems that `FirstLine.java` has also been removed from the project due to version iteration.\n\nThis suggests that several historically co-changed files related to `DisplayManager.java` are no longer present in the current codebase. This could indicate significant refactoring or architectural changes over time.\n\nLet\u2019s try analyzing the conceptual coupling with another high-confidence file, such as **ScrollLineCount.java**, to see if it still exists and is semantically related:\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_fdbb2f8524be404da0f48b",
                    "function": {
                        "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"ScrollLineCount.java\"}",
                        "name": "get_conceptual_coupling"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_conceptual_coupling",
            "content": "[\"ScrollLineCount has been removed from the project due to project version iteration\"]"
        },
        {
            "content": "It appears that `ScrollLineCount.java` has also been removed from the project, following the same pattern as the previous files.\n\nGiven this recurring trend of removals among files with high co-change confidence, it's possible that `DisplayManager.java` has undergone significant architectural changes or refactoring in recent versions, leading to the obsolescence of several related entities.\n\nLet\u2019s now check a file with slightly lower confidence but potentially still relevant: **ChunkCache.java**. We'll assess its conceptual coupling with `DisplayManager.java`:\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_68dd5bfa146045b7a10a20",
                    "function": {
                        "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"ChunkCache.java\"}",
                        "name": "get_conceptual_coupling"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_conceptual_coupling",
            "content": "\"0.868545\""
        },
        {
            "content": "The conceptual coupling between `DisplayManager.java` and `ChunkCache.java` is quite high at **0.868545**, indicating a strong semantic relationship.\n\nDespite the removal of several historically co-changed files, `ChunkCache.java` still exists in the project and is semantically related to `DisplayManager.java`. Therefore, it should be considered a key entity that may need synchronization when changes are made to `DisplayManager.java`.\n\n### Summary of Findings:\n- Several historically co-changed files (e.g., `BufferChangeHandler.java`, `FirstLine.java`, `ScrollLineCount.java`) have been removed due to project evolution.\n- `ChunkCache.java` remains in the codebase and has a strong semantic relationship with `DisplayManager.java`.\n\n### Recommendation:\n**Synchronize changes to `ChunkCache.java` whenever modifications are made to `DisplayManager.java`.**\n\nIf you'd like, we can now examine the actual source code of these two files to further validate their relationship or understand potential impact areas.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_f24215cbfb4d4c6c8790fe",
                    "function": {
                        "arguments": "{\"entity\": \"DisplayManager.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package org.gjt.sp.jedit.textarea;\\nimport javax.swing.SwingUtilities;\\nimport java.awt.Toolkit;\\nimport java.util.*;\\nimport org.gjt.sp.jedit.buffer.*;\\nimport org.gjt.sp.jedit.textarea.JEditTextArea;\\nimport org.gjt.sp.jedit.*;\\nimport org.gjt.sp.util.Log;\\npublic class DisplayManager\\n{\\n\\tpublic static long scanCount, scannedLines;\\n\\t\\tstatic DisplayManager getDisplayManager(Buffer buffer,\\n\\t\\tJEditTextArea textArea)\\n\\t{\\n\\t\\tList l = (List)bufferMap.get(buffer);\\n\\t\\tDisplayManager dmgr;\\n\\t\\tif(l == null)\\n\\t\\t{\\n\\t\\t\\tl = new LinkedList();\\n\\t\\t\\tbufferMap.put(buffer,l);\\n\\t\\t}\\n\\t\\tIterator liter = l.iterator();\\n\\t\\twhile(liter.hasNext())\\n\\t\\t{\\n\\t\\t\\tdmgr = (DisplayManager)liter.next();\\n\\t\\t\\tif(!dmgr.inUse && dmgr.textArea == textArea)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdmgr.inUse = true;\\n\\t\\t\\t\\treturn dmgr;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tdmgr = new DisplayManager(buffer,textArea);\\n\\t\\tdmgr.inUse = true;\\n\\t\\tl.add(dmgr);\\n\\t\\treturn dmgr;\\n\\t} \\n\\t\\tstatic void releaseDisplayManager(DisplayManager dmgr)\\n\\t{\\n\\t\\tdmgr.inUse = false;\\n\\t} \\n\\t\\tpublic static void bufferClosed(Buffer buffer)\\n\\t{\\n\\t\\tbufferMap.remove(buffer);\\n\\t} \\n\\t\\tstatic void textAreaDisposed(JEditTextArea textArea)\\n\\t{\\n\\t\\tIterator biter = bufferMap.values().iterator();\\n\\t\\twhile(biter.hasNext())\\n\\t\\t{\\n\\t\\t\\tList l = (List)biter.next();\\n\\t\\t\\tIterator liter = l.iterator();\\n\\t\\t\\twhile(liter.hasNext())\\n\\t\\t\\t{\\n\\t\\t\\t\\tDisplayManager dmgr = (DisplayManager)\\n\\t\\t\\t\\t\\tliter.next();\\n\\t\\t\\t\\tif(dmgr.textArea == textArea)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdmgr.dispose();\\n\\t\\t\\t\\t\\tliter.remove();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate static void _setScreenLineCount(Buffer buffer, int line,\\n\\t\\tint oldCount, int count)\\n\\t{\\n\\t\\tIterator iter = ((List)bufferMap.get(buffer)).iterator();\\n\\t\\twhile(iter.hasNext())\\n\\t\\t{\\n\\t\\t\\t((DisplayManager)iter.next())._setScreenLineCount(line,oldCount,count);\\n\\t\\t}\\n\\t} \\n\\t\\tstatic void _notifyScreenLineChanges(Buffer buffer)\\n\\t{\\n\\t\\tIterator iter = ((List)bufferMap.get(buffer)).iterator();\\n\\t\\twhile(iter.hasNext())\\n\\t\\t{\\n\\t\\t\\t((DisplayManager)iter.next())._notifyScreenLineChanges();\\n\\t\\t}\\n\\t} \\n\\tprivate static Map bufferMap = new HashMap();\\n\\tpublic final boolean isLineVisible(int line)\\n\\t{\\n\\t\\treturn fvmget(line) % 2 == 0;\\n\\t} \\n\\tpublic int getFirstVisibleLine()\\n\\t{\\n\\t\\treturn fvm[0];\\n\\t} \\n\\tpublic int getLastVisibleLine()\\n\\t{\\n\\t\\treturn fvm[fvmcount - 1] - 1;\\n\\t} \\n\\tpublic int getNextVisibleLine(int line)\\n\\t{\\n\\t\\tint index = fvmget(line);\\n\\t\\tif(index % 2 != 0)\\n\\t\\t{\\n\\t\\t\\tif(fvmcount == index + 1)\\n\\t\\t\\t\\treturn - 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn fvm[index + 1];\\n\\t\\t}\\n\\t\\telse if(line == fvm[index + 1] - 1)\\n\\t\\t{\\n\\t\\t\\tif(fvmcount == index + 2)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn fvm[index + 2];\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn line + 1;\\n\\t} \\n\\tpublic int getPrevVisibleLine(int line)\\n\\t{\\n\\t\\tint index = fvmget(line);\\n\\t\\tif(index == -1)\\n\\t\\t\\treturn -1;\\n\\t\\telse if(index % 2 == 1)\\n\\t\\t{\\n\\t\\t\\treturn fvm[index] - 1;\\n\\t\\t}\\n\\t\\telse if(line == fvm[index])\\n\\t\\t{\\n\\t\\t\\tif(index == 0)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn fvm[index - 1] - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn line - 1;\\n\\t} \\n\\t\\tpublic final int getScreenLineCount(int line)\\n\\t{\\n\\t\\tif(offsetMgr.isScreenLineCountValid(line))\\n\\t\\t\\treturn offsetMgr.getScreenLineCount(line);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint newCount = textArea.chunkCache\\n\\t\\t\\t\\t.getLineSubregionCount(line);\\n\\t\\t\\tsetScreenLineCount(line,newCount);\\n\\t\\t\\treturn newCount;\\n\\t\\t}\\n\\t} \\n\\t\\tpublic final int getScrollLineCount()\\n\\t{\\n\\t\\treturn scrollLineCount.scrollLine;\\n\\t} \\n\\tpublic void collapseFold(int line)\\n\\t{\\n\\t\\tint lineCount = buffer.getLineCount();\\n\\t\\tint start = 0;\\n\\t\\tint end = lineCount - 1;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.writeLock();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(line != 0\\n\\t\\t\\t\\t&& line != buffer.getLineCount() - 1\\n\\t\\t\\t\\t&& buffer.isFoldStart(line)\\n\\t\\t\\t\\t&& !isLineVisible(line + 1))\\n\\t\\t\\t{\\n\\t\\t\\t\\tline--;\\n\\t\\t\\t}\\n\\t\\t\\tint initialFoldLevel = buffer.getFoldLevel(line);\\n\\t\\t\\t\\t\\t\\tif(line != lineCount - 1\\n\\t\\t\\t\\t&& buffer.getFoldLevel(line + 1) > initialFoldLevel)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tstart = line + 1;\\n\\t\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(buffer.getFoldLevel(i) <= initialFoldLevel)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tboolean ok = false;\\n\\t\\t\\t\\t\\t\\t\\t\\tfor(int i = line - 1; i >= 0; i--)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(buffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tstart = i + 1;\\n\\t\\t\\t\\t\\t\\tok = true;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!ok)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(buffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\t\\t\\t\\thideLineRange(start,end);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.writeUnlock();\\n\\t\\t}\\n\\t\\t_notifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic int expandFold(int line, boolean fully)\\n\\t{\\n\\t\\t\\t\\tint returnValue = -1;\\n\\t\\tint lineCount = buffer.getLineCount();\\n\\t\\tint start = 0;\\n\\t\\tint end = lineCount - 1;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.writeLock();\\n\\t\\t\\tint initialFoldLevel = buffer.getFoldLevel(line);\\n\\t\\t\\t\\t\\t\\tif(line != lineCount - 1\\n\\t\\t\\t\\t&& isLineVisible(line)\\n\\t\\t\\t\\t&& !isLineVisible(line + 1)\\n\\t\\t\\t\\t&& buffer.getFoldLevel(line + 1) > initialFoldLevel)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tstart = line + 1;\\n\\t\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(\\n\\t\\t\\t\\t\\t\\tbuffer.getFoldLevel(i) <= initialFoldLevel)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tboolean ok = false;\\n\\t\\t\\t\\t\\t\\t\\t\\tfor(int i = line - 1; i >= 0; i--)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(isLineVisible(i) && buffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tstart = i + 1;\\n\\t\\t\\t\\t\\t\\tok = true;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!ok)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif((isLineVisible(i) &&\\n\\t\\t\\t\\t\\t\\tbuffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t\\t\\t|| i == getLastVisibleLine())\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\t\\t\\t\\tif(fully)\\n\\t\\t\\t{\\n\\t\\t\\t\\tshowLineRange(start,end);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tinitialFoldLevel = buffer.getFoldLevel(start);\\n\\t\\t\\t\\tint firstVisible = start;\\n\\t\\t\\t\\tfor(int i = start; i <= end; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(buffer.getFoldLevel(i) > initialFoldLevel)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(returnValue == -1\\n\\t\\t\\t\\t\\t\\t\\t&& i != 0\\n\\t\\t\\t\\t\\t\\t\\t&& buffer.isFoldStart(i - 1))\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\treturnValue = i - 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(firstVisible != i)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tshowLineRange(firstVisible,i - 1);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tfirstVisible = i + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(firstVisible != end + 1)\\n\\t\\t\\t\\t\\tshowLineRange(firstVisible,end);\\n\\t\\t\\t\\tif(!isLineVisible(line))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\texpandFold(line,false);\\n\\t\\t\\t\\t\\treturn returnValue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.writeUnlock();\\n\\t\\t}\\n\\t\\t_notifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t\\treturn returnValue;\\n\\t} \\n\\tpublic void expandAllFolds()\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.writeLock();\\n\\t\\t\\tshowLineRange(0,buffer.getLineCount() - 1);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.writeUnlock();\\n\\t\\t}\\n\\t\\t_notifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic void expandFolds(char digit)\\n\\t{\\n\\t\\tif(digit < '1' || digit > '9')\\n\\t\\t{\\n\\t\\t\\tToolkit.getDefaultToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\texpandFolds((int)(digit - '1') + 1);\\n\\t} \\n\\tpublic void expandFolds(int foldLevel)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.writeLock();\\n\\t\\t\\tif(buffer.getFoldHandler() instanceof IndentFoldHandler)\\n\\t\\t\\t\\tfoldLevel = (foldLevel - 1) * buffer.getIndentSize() + 1;\\n\\t\\t\\tshowLineRange(0,buffer.getLineCount() - 1);\\n\\t\\t\\tboolean seenVisibleLine = false;\\n\\t\\t\\tint firstInvisible = 0;\\n\\t\\t\\tfor(int i = 0; i < buffer.getLineCount(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(!seenVisibleLine || buffer.getFoldLevel(i) < foldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(firstInvisible != i)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\thideLineRange(firstInvisible,\\n\\t\\t\\t\\t\\t\\t\\ti - 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfirstInvisible = i + 1;\\n\\t\\t\\t\\t\\tseenVisibleLine = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(firstInvisible != buffer.getLineCount())\\n\\t\\t\\t\\thideLineRange(firstInvisible,buffer.getLineCount() - 1);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.writeUnlock();\\n\\t\\t}\\n\\t\\t_notifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic void narrow(int start, int end)\\n\\t{\\n\\t\\tif(start > end || start < 0 || end >= buffer.getLineCount())\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(start + \\\", \\\" + end);\\n\\t\\tif(start < getFirstVisibleLine() || end > getLastVisibleLine())\\n\\t\\t\\texpandAllFolds();\\n\\t\\thideLineRange(0,start - 1);\\n\\t\\thideLineRange(end + 1,buffer.getLineCount() - 1);\\n\\t\\t\\t\\tif(getNextVisibleLine(start) == -1)\\n\\t\\t\\texpandFold(start,false);\\n\\t\\t\\t\\t\\t\\tGUIUtilities.getView(textArea).getStatus().setMessageAndClear(\\n\\t\\t\\tjEdit.getProperty(\\\"view.status.narrow\\\"));\\n\\t\\t_notifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\t\\tboolean softWrap;\\n\\tint wrapMargin;\\n\\tFirstLine firstLine;\\n\\tScrollLineCount scrollLineCount;\\n\\t\\tvoid init()\\n\\t{\\n\\t\\tif(!initialized)\\n\\t\\t{\\n\\t\\t\\tinitialized = true;\\n\\t\\t\\tfvm = new int[2];\\n\\t\\t\\tif(buffer.isLoaded())\\n\\t\\t\\t\\tbufferChangeHandler.foldHandlerChanged(buffer);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t}\\n\\t} \\n\\tvoid setScreenLineCount(int line, int count)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.writeLock();\\n\\t\\t\\tint oldCount = offsetMgr.getScreenLineCount(line);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(count != oldCount)\\n\\t\\t\\t{\\n\\t\\t\\t\\toffsetMgr.setScreenLineCount(line,count);\\n\\t\\t\\t\\t_setScreenLineCount(buffer,line,oldCount,count);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.writeUnlock();\\n\\t\\t}\\n\\t} \\n\\t\\tvoid updateWrapSettings()\\n\\t{\\n\\t\\tString wrap = buffer.getStringProperty(\\\"wrap\\\");\\n\\t\\tsoftWrap = wrap.equals(\\\"soft\\\");\\n\\t\\tif(textArea.maxLineLen <= 0)\\n\\t\\t{\\n\\t\\t\\tsoftWrap = false;\\n\\t\\t\\twrapMargin = 0;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tchar[] foo = new char[textArea.maxLineLen];\\n\\t\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfoo[i] = ' ';\\n\\t\\t\\t}\\n\\t\\t\\tTextAreaPainter painter = textArea.getPainter();\\n\\t\\t\\twrapMargin = (int)painter.getFont().getStringBounds(\\n\\t\\t\\t\\tfoo,0,foo.length,\\n\\t\\t\\t\\tpainter.getFontRenderContext())\\n\\t\\t\\t\\t.getWidth();\\n\\t\\t}\\n\\t} \\n\\t\\tprivate boolean initialized;\\n\\tprivate boolean inUse;\\n\\tprivate Buffer buffer;\\n\\tprivate OffsetManager offsetMgr;\\n\\tprivate JEditTextArea textArea;\\n\\tprivate BufferChangeHandler bufferChangeHandler;\\n\\tprivate int[] fvm;\\n\\tprivate int fvmcount;\\n\\tprivate int lastfvmget = -1;\\n\\t\\tprivate DisplayManager(Buffer buffer, JEditTextArea textArea)\\n\\t{\\n\\t\\tthis.buffer = buffer;\\n\\t\\tthis.offsetMgr = buffer._getOffsetManager();\\n\\t\\tthis.textArea = textArea;\\n\\t\\tscrollLineCount = new ScrollLineCount();\\n\\t\\tfirstLine = new FirstLine();\\n\\t\\tbufferChangeHandler = new BufferChangeHandler();\\n\\t\\t\\t\\tbuffer.addBufferChangeListener(bufferChangeHandler,\\n\\t\\t\\tBuffer.HIGH_PRIORITY);\\n\\t} \\n\\t\\tprivate void dispose()\\n\\t{\\n\\t\\tbuffer.removeBufferChangeListener(bufferChangeHandler);\\n\\t} \\n\\tprivate void fvmtest()\\n\\t{\\n\\t\\tboolean[] map = new boolean[buffer.getLineCount()];\\n\\t\\tjava.util.Random random = new java.util.Random();\\n\\t\\t\\t\\t\\t\\tfor(int i = 0; i < 1000; i++)\\n\\t\\t{\\n\\t\\t\\tint random1 = Math.abs(random.nextInt() % map.length);\\n\\t\\t\\tint random2 = Math.abs(random.nextInt() % map.length);\\n\\t\\t\\tif(random2 < random1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint tmp = random1;\\n\\t\\t\\t\\trandom1 = random2;\\n\\t\\t\\t\\trandom2 = tmp;\\n\\t\\t\\t}\\n\\t\\t\\tboolean vis = (random1 + random2 % 2 == 0);\\n\\t\\t\\tif(vis)\\n\\t\\t\\t\\tshowLineRange(random1,random2);\\n\\t\\t\\telse\\n\\t\\t\\t\\thideLineRange(random1,random2);\\n\\t\\t\\tfor(int j = random1; j <= random2; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmap[j] = vis;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tfor(int i = 0; i < map.length; i++)\\n\\t\\t{\\n\\t\\t\\tif(isLineVisible(i) != map[i])\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Mismatch: \\\" + i);\\n\\t\\t}\\n\\t} \\n\\tprivate int fvmget(int line)\\n\\t{\\n\\t\\tscanCount++;\\n\\t\\tif(line < fvm[0])\\n\\t\\t\\treturn -1;\\n\\t\\tif(line >= fvm[fvmcount - 1])\\n\\t\\t\\treturn fvmcount - 1;\\n\\t\\tif(lastfvmget != -1)\\n\\t\\t{\\n\\t\\t\\tif(line >= fvm[lastfvmget])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(lastfvmget == fvmcount - 1\\n\\t\\t\\t\\t\\t|| line < fvm[lastfvmget + 1])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn lastfvmget;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint start = 0;\\n\\t\\tint end = fvmcount - 1;\\nloop:\\t\\tfor(;;)\\n\\t\\t{\\n\\t\\t\\tscannedLines++;\\n\\t\\t\\tswitch(end - start)\\n\\t\\t\\t{\\n\\t\\t\\tcase 0:\\n\\t\\t\\t\\tlastfvmget = start;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\tint value = fvm[end];\\n\\t\\t\\t\\tif(value <= line)\\n\\t\\t\\t\\t\\tlastfvmget = end;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tlastfvmget = start;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tint pivot = (end + start) / 2;\\n\\t\\t\\t\\tvalue = fvm[pivot];\\n\\t\\t\\t\\tif(value == line)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastfvmget = pivot;\\n\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(value < line)\\n\\t\\t\\t\\t\\tstart = pivot;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tend = pivot - 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn lastfvmget;\\n\\t} \\n\\tprivate void fvmput(int start, int end, int[] put)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tStringBuffer buf = new StringBuffer(\\\"{\\\");\\n\\t\\t\\tif(put != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i = 0; i < put.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(i != 0)\\n\\t\\t\\t\\t\\t\\tbuf.append(',');\\n\\t\\t\\t\\t\\tbuf.append(put[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tbuf.append(\\\"}\\\");\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"fvmput(\\\" + start + \\\",\\\"\\n\\t\\t\\t\\t+ end + \\\",\\\" + buf + \\\")\\\");\\n\\t\\t}\\n\\t\\tint putl = (put == null ? 0 : put.length);\\n\\t\\tint delta = putl - (end - start);\\n\\t\\tif(fvmcount + delta > fvm.length)\\n\\t\\t{\\n\\t\\t\\tint[] newfvm = new int[fvm.length * 2 + 1];\\n\\t\\t\\tSystem.arraycopy(fvm,0,newfvm,0,fvmcount);\\n\\t\\t\\tfvm = newfvm;\\n\\t\\t}\\n\\t\\tif(delta != 0)\\n\\t\\t{\\n\\t\\t\\tSystem.arraycopy(fvm,end,fvm,start + putl,\\n\\t\\t\\t\\tfvmcount - end);\\n\\t\\t}\\n\\t\\tif(putl != 0)\\n\\t\\t{\\n\\t\\t\\tSystem.arraycopy(put,0,fvm,start,put.length);\\n\\t\\t}\\n\\t\\tfvmcount += delta;\\n\\t\\tif(fvmcount == 0)\\n\\t\\t\\tthrow new InternalError();\\n\\t} \\n\\tprivate void fvmput2(int starti, int endi, int start, int end)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"*fvmput2(\\\" + starti + \\\",\\\"\\n\\t\\t\\t\\t+ endi + \\\",\\\" + start + \\\",\\\" + end + \\\")\\\");\\n\\t\\t}\\n\\t\\tif(starti != -1 && fvm[starti] == start)\\n\\t\\t{\\n\\t\\t\\tif(endi <= fvmcount - 2 && fvm[endi + 1]\\n\\t\\t\\t\\t== end + 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti,endi + 2,null);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti,endi + 1,\\n\\t\\t\\t\\t\\tnew int[] { end + 1 });\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(endi != fvmcount - 1 && fvm[endi + 1]\\n\\t\\t\\t\\t== end + 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 2,\\n\\t\\t\\t\\t\\tnew int[] { start });\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 1,\\n\\t\\t\\t\\t\\tnew int[] { start,\\n\\t\\t\\t\\t\\tend + 1 });\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void showLineRange(int start, int end)\\n\\t{\\n\\t\\tfor(int i = start; i <= end; i++)\\n\\t\\t{\\n\\t\\t\\tif(!isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint screenLines = offsetMgr\\n\\t\\t\\t\\t\\t.getScreenLineCount(i);\\n\\t\\t\\t\\tif(firstLine.physicalLine >= i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfirstLine.scrollLine += screenLines;\\n\\t\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tscrollLineCount.scrollLine += screenLines;\\n\\t\\t\\t\\tscrollLineCount.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tlastfvmget = -1;\\n\\t\\tint starti = fvmget(start);\\n\\t\\tint endi = fvmget(end);\\n\\t\\tif(starti % 2 == 0)\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 1,null);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\tfvm[starti + 1] = end + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\tfvm[starti + 1] = start;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tfvmput2(starti,endi,start,end);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void hideLineRange(int start, int end)\\n\\t{\\n\\t\\tfor(int i = start; i <= end; i++)\\n\\t\\t{\\n\\t\\t\\tif(isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint screenLines = offsetMgr\\n\\t\\t\\t\\t\\t.getScreenLineCount(i);\\n\\t\\t\\t\\tif(firstLine.physicalLine >= i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfirstLine.scrollLine -= screenLines;\\n\\t\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tscrollLineCount.scrollLine -= screenLines;\\n\\t\\t\\t\\tscrollLineCount.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tlastfvmget = -1;\\n\\t\\tint starti = fvmget(start);\\n\\t\\tint endi = fvmget(end);\\n\\t\\tif(starti % 2 == 0)\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t\\tfvmput2(starti,endi,start,end);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\tfvm[starti + 1] = start;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\tfvm[starti + 1] = end + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 1,null);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void _setScreenLineCount(int line, int oldCount, int count)\\n\\t{\\n\\t\\tif(!isLineVisible(line))\\n\\t\\t\\treturn;\\n\\t\\tif(firstLine.physicalLine >= line)\\n\\t\\t{\\n\\t\\t\\tif(firstLine.physicalLine == line)\\n\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.scrollLine += (count - oldCount);\\n\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tscrollLineCount.scrollLine += (count - oldCount);\\n\\t\\tscrollLineCount.callChanged = true;\\n\\t} \\n\\t\\tprivate void _notifyScreenLineChanges()\\n\\t{\\n\\t\\tif(firstLine.callReset)\\n\\t\\t\\tfirstLine.reset();\\n\\t\\telse if(firstLine.callChanged)\\n\\t\\t\\tfirstLine.changed();\\n\\t\\tfirstLine.callReset = firstLine.callChanged = false;\\n\\t\\tif(scrollLineCount.callReset)\\n\\t\\t\\tscrollLineCount.reset();\\n\\t\\telse if(scrollLineCount.callChanged)\\n\\t\\t\\tscrollLineCount.changed();\\n\\t\\tscrollLineCount.callReset = scrollLineCount.callChanged = false;\\n\\t} \\n\\t\\tstatic abstract class Anchor\\n\\t{\\n\\t\\tint physicalLine;\\n\\t\\tint scrollLine;\\n\\t\\tboolean callChanged;\\n\\t\\tboolean callReset;\\n\\t\\tabstract void reset();\\n\\t\\tabstract void changed();\\n\\t} \\n\\t\\tclass ScrollLineCount extends Anchor\\n\\t{\\n\\t\\t\\t\\tpublic void changed()\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"changed()\\\");\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t} \\n\\t\\t\\t\\tpublic void reset()\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"reset()\\\");\\n\\t\\t\\tupdateWrapSettings();\\n\\t\\t\\tphysicalLine = 0;\\n\\t\\t\\tscrollLine = 0;\\n\\t\\t\\t\\t\\t\\tfor(int i = 0; i < buffer.getLineCount(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(isLineVisible(i))\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(i);\\n\\t\\t\\t}\\n\\t\\t\\tphysicalLine = buffer.getLineCount();\\n\\t\\t\\tfirstLine.ensurePhysicalLineIsVisible();\\n\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t} \\t} \\n\\t\\tclass FirstLine extends Anchor\\n\\t{\\n\\t\\tint skew;\\n\\t\\t\\t\\tpublic void changed()\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"changed() before: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t} \\n\\t\\t\\tensurePhysicalLineIsVisible();\\n\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\tif(skew >= screenLines)\\n\\t\\t\\t\\tskew = screenLines - 1;\\n\\t\\t\\t\\t\\t\\tif(Debug.VERIFY_FIRST_LINE)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint verifyScrollLine = 0;\\n\\t\\t\\t\\tfor(int i = 0; i < buffer.getLineCount(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!isLineVisible(i))\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\tif(i >= physicalLine)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tverifyScrollLine += getScreenLineCount(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(verifyScrollLine != scrollLine)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tException ex = new Exception(scrollLine + \\\":\\\" + verifyScrollLine);\\n\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,ex);\\n\\t\\t\\t\\t\\tnew org.gjt.sp.jedit.gui.BeanShellErrorDialog(null,ex);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"changed() after: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t} \\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t} \\n\\t\\t\\t\\tpublic void reset()\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"reset()\\\");\\n\\t\\t\\tString wrap = buffer.getStringProperty(\\\"wrap\\\");\\n\\t\\t\\tsoftWrap = wrap.equals(\\\"soft\\\");\\n\\t\\t\\tif(textArea.maxLineLen <= 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsoftWrap = false;\\n\\t\\t\\t\\twrapMargin = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tchar[] foo = new char[textArea.maxLineLen];\\n\\t\\t\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfoo[i] = ' ';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tTextAreaPainter painter = textArea.getPainter();\\n\\t\\t\\t\\twrapMargin = (int)painter.getFont().getStringBounds(\\n\\t\\t\\t\\t\\tfoo,0,foo.length,\\n\\t\\t\\t\\t\\tpainter.getFontRenderContext())\\n\\t\\t\\t\\t\\t.getWidth();\\n\\t\\t\\t}\\n\\t\\t\\tscrollLine = 0;\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tfor(; i < buffer.getLineCount(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(!isLineVisible(i))\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif(i >= physicalLine)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tscrollLine += getScreenLineCount(i);\\n\\t\\t\\t}\\n\\t\\t\\tphysicalLine = i;\\n\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\tif(skew >= screenLines)\\n\\t\\t\\t\\tskew = screenLines - 1;\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid physDown(int amount, int screenAmount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physDown() start: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tskew = 0;\\n\\t\\t\\tif(!isLineVisible(physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint lastVisibleLine = getLastVisibleLine();\\n\\t\\t\\t\\tif(physicalLine > lastVisibleLine)\\n\\t\\t\\t\\t\\tphysicalLine = lastVisibleLine;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint nextPhysicalLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tamount -= (nextPhysicalLine - physicalLine);\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = nextPhysicalLine;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(;;)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint nextPhysicalLine = getNextVisibleLine(\\n\\t\\t\\t\\t\\tphysicalLine);\\n\\t\\t\\t\\tif(nextPhysicalLine == -1)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse if(nextPhysicalLine > physicalLine + amount)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t\\tamount -= (nextPhysicalLine - physicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = nextPhysicalLine;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physDown() end: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(screenAmount != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(screenAmount < 0)\\n\\t\\t\\t\\t\\tscrollUp(-screenAmount);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tscrollDown(screenAmount);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid physUp(int amount, int screenAmount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physUp() start: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tskew = 0;\\n\\t\\t\\tif(!isLineVisible(physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint firstVisibleLine = getFirstVisibleLine();\\n\\t\\t\\t\\tif(physicalLine < firstVisibleLine)\\n\\t\\t\\t\\t\\tphysicalLine = firstVisibleLine;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint prevPhysicalLine = getPrevVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tamount -= (physicalLine - prevPhysicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(;;)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint prevPhysicalLine = getPrevVisibleLine(\\n\\t\\t\\t\\t\\tphysicalLine);\\n\\t\\t\\t\\tif(prevPhysicalLine == -1)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse if(prevPhysicalLine < physicalLine - amount)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tamount -= (physicalLine - prevPhysicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = prevPhysicalLine;\\n\\t\\t\\t\\t\\tscrollLine -= getScreenLineCount(\\n\\t\\t\\t\\t\\t\\tprevPhysicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physUp() end: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(screenAmount != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(screenAmount < 0)\\n\\t\\t\\t\\t\\tscrollUp(-screenAmount);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tscrollDown(screenAmount);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid scrollDown(int amount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"scrollDown()\\\");\\n\\t\\t\\tensurePhysicalLineIsVisible();\\n\\t\\t\\tamount += skew;\\n\\t\\t\\tskew = 0;\\n\\t\\t\\twhile(amount > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\t\\tif(amount < screenLines)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tskew = amount;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint nextLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tboolean visible = isLineVisible(physicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = nextLine;\\n\\t\\t\\t\\t\\tif(visible)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tamount -= screenLines;\\n\\t\\t\\t\\t\\t\\tscrollLine += screenLines;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid scrollUp(int amount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"scrollUp()\\\");\\n\\t\\t\\tensurePhysicalLineIsVisible();\\n\\t\\t\\tif(amount <= skew)\\n\\t\\t\\t{\\n\\t\\t\\t\\tskew -= amount;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tamount -= skew;\\n\\t\\t\\t\\tskew = 0;\\n\\t\\t\\t\\twhile(amount > 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint prevLine = getPrevVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tif(prevLine == -1)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tphysicalLine = prevLine;\\n\\t\\t\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t\\tscrollLine -= screenLines;\\n\\t\\t\\t\\t\\tif(amount < screenLines)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tskew = screenLines - amount;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tamount -= screenLines;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void ensurePhysicalLineIsVisible()\\n\\t\\t{\\n\\t\\t\\tif(!isLineVisible(physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(physicalLine > getLastVisibleLine())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysicalLine = getPrevVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tscrollLine -= getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysicalLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\t} \\n\\t\\tclass BufferChangeHandler extends BufferChangeAdapter\\n\\t{\\n\\t\\tboolean delayedUpdate;\\n\\t\\tint delayedUpdateStart;\\n\\t\\tint delayedUpdateEnd;\\n\\t\\t\\t\\tpublic void foldHandlerChanged(Buffer buffer)\\n\\t\\t{\\n\\t\\t\\tlastfvmget = -1;\\n\\t\\t\\tfvmcount = 2;\\n\\t\\t\\tfvm[0] = 0;\\n\\t\\t\\tfvm[1] = buffer.getLineCount();\\n\\t\\t\\tfirstLine.reset();\\n\\t\\t\\tscrollLineCount.reset();\\n\\t\\t\\tint collapseFolds = buffer.getIntegerProperty(\\n\\t\\t\\t\\t\\\"collapseFolds\\\",0);\\n\\t\\t\\tif(collapseFolds != 0)\\n\\t\\t\\t\\texpandFolds(collapseFolds);\\n\\t\\t} \\n\\t\\t\\t\\tpublic void wrapModeChanged(Buffer buffer)\\n\\t\\t{\\n\\t\\t\\tfirstLine.reset();\\n\\t\\t\\tscrollLineCount.reset();\\n\\t\\t} \\n\\t\\t\\t\\tpublic void contentInserted(Buffer buffer, int startLine,\\n\\t\\t\\tint offset, int numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tdelayedUpdate(startLine,startLine + numLines);\\n\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontentInserted(firstLine,startLine,numLines);\\n\\t\\t\\t\\tcontentInserted(scrollLineCount,startLine,numLines);\\n\\t\\t\\t\\tint index = fvmget(startLine);\\n\\t\\t\\t\\tfor(int i = index + 1; i < fvmcount; i++)\\n\\t\\t\\t\\t\\tfvm[i] += numLines;\\n\\t\\t\\t}\\n\\t\\t\\tif(!buffer.isTransactionInProgress())\\n\\t\\t\\t\\ttransactionComplete(buffer);\\n\\t\\t} \\n\\t\\t\\t\\tpublic void preContentRemoved(Buffer buffer, int startLine,\\n\\t\\t\\tint offset, int numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tdelayedUpdate(startLine,startLine);\\n\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tpreContentRemoved(firstLine,startLine,numLines);\\n\\t\\t\\t\\tpreContentRemoved(scrollLineCount,startLine,numLines);\\n\\t\\t\\t\\tint starti = fvmget(startLine);\\n\\t\\t\\t\\tint endi = fvmget(startLine + numLines);\\n\\t\\t\\t\\tif(Math.abs(starti % 2) == Math.abs(endi % 2))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(endi - starti == fvmcount)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfvmcount = 2;\\n\\t\\t\\t\\t\\t\\tfvm[0] = 0;\\n\\t\\t\\t\\t\\t\\tfvm[1] = buffer.getLineCount();\\n\\t\\t\\t\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\t\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tfvmput(starti,endi,null);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\t\\tfvm[starti + 1] = startLine;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int i = starti + 1; i < fvmcount; i++)\\n\\t\\t\\t\\t\\tfvm[i] -= numLines;\\n\\t\\t\\t}\\n\\t\\t\\tif(!buffer.isTransactionInProgress())\\n\\t\\t\\t\\ttransactionComplete(buffer);\\n\\t\\t} \\n\\t\\t\\t\\tpublic void transactionComplete(Buffer buffer)\\n\\t\\t{\\n\\t\\t\\tif(delayedUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i = delayedUpdateStart;\\n\\t\\t\\t\\t\\ti <= delayedUpdateEnd;\\n\\t\\t\\t\\t\\ti++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(isLineVisible(i))\\n\\t\\t\\t\\t\\t\\tgetScreenLineCount(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t_notifyScreenLineChanges();\\n\\t\\t\\t\\tdelayedUpdate = false;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void contentInserted(Anchor anchor, int startLine,\\n\\t\\t\\tint numLines)\\n\\t\\t{\\n\\t\\t\\tif(anchor.physicalLine >= startLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(anchor.physicalLine != startLine)\\n\\t\\t\\t\\t\\tanchor.physicalLine += numLines;\\n\\t\\t\\t\\tanchor.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void preContentRemoved(Anchor anchor, int startLine,\\n\\t\\t\\tint numLines)\\n\\t\\t{\\n\\t\\t\\tif(anchor.physicalLine >= startLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(anchor.physicalLine == startLine)\\n\\t\\t\\t\\t\\tanchor.callChanged = true;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint end = Math.min(startLine + numLines,\\n\\t\\t\\t\\t\\t\\tanchor.physicalLine);\\n\\t\\t\\t\\t\\tfor(int i = startLine; i < end; i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(isLineVisible(i))\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tanchor.scrollLine -=\\n\\t\\t\\t\\t\\t\\t\\t\\toffsetMgr\\n\\t\\t\\t\\t\\t\\t\\t\\t.getScreenLineCount(i);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tanchor.physicalLine -= (end - startLine);\\n\\t\\t\\t\\t\\tanchor.callChanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void delayedUpdate(int startLine, int endLine)\\n\\t\\t{\\n\\t\\t\\ttextArea.chunkCache.invalidateChunksFromPhys(startLine);\\n\\t\\t\\tif(!delayedUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedUpdateStart = startLine;\\n\\t\\t\\t\\tdelayedUpdateEnd = endLine;\\n\\t\\t\\t\\tdelayedUpdate = true;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedUpdateStart = Math.min(\\n\\t\\t\\t\\t\\tdelayedUpdateStart,\\n\\t\\t\\t\\t\\tstartLine);\\n\\t\\t\\t\\tdelayedUpdateEnd = Math.max(\\n\\t\\t\\t\\t\\tdelayedUpdateEnd,\\n\\t\\t\\t\\t\\tendLine);\\n\\t\\t\\t}\\n\\t\\t} \\t} }\""
        },
        {
            "content": "",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_e61d802348c946d0afcaa9",
                    "function": {
                        "arguments": "{\"entity\": \"ChunkCache.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package org.gjt.sp.jedit.textarea;\\nimport java.util.*;\\nimport org.gjt.sp.jedit.Buffer;\\nimport org.gjt.sp.jedit.Debug;\\nimport org.gjt.sp.jedit.syntax.*;\\nimport org.gjt.sp.util.Log;\\nclass ChunkCache\\n{\\n\\t\\tChunkCache(JEditTextArea textArea)\\n\\t{\\n\\t\\tthis.textArea = textArea;\\n\\t\\tout = new ArrayList();\\n\\t\\ttokenHandler = new DisplayTokenHandler();\\n\\t} \\n\\t\\tint getMaxHorizontalScrollWidth()\\n\\t{\\n\\t\\tint max = 0;\\n\\t\\tfor(int i = 0; i < firstInvalidLine; i++)\\n\\t\\t{\\n\\t\\t\\tLineInfo info = lineInfo[i];\\n\\t\\t\\tif(info.width > max)\\n\\t\\t\\t\\tmax = info.width;\\n\\t\\t}\\n\\t\\treturn max;\\n\\t} \\n\\t\\tint getScreenLineOfOffset(int line, int offset)\\n\\t{\\n\\t\\tif(line < textArea.getFirstPhysicalLine())\\n\\t\\t{\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\telse if(line > textArea.getLastPhysicalLine())\\n\\t\\t{\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint screenLine;\\n\\t\\t\\tif(line == lastScreenLineP)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLineInfo last = getLineInfo(lastScreenLine);\\n\\t\\t\\t\\tif(offset >= last.offset\\n\\t\\t\\t\\t\\t&& offset < last.offset + last.length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn lastScreenLine;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tscreenLine = -1;\\n\\t\\t\\t\\t\\t\\tfor(int i = 0; i < textArea.getVisibleLines(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLineInfo info = getLineInfo(i);\\n\\t\\t\\t\\tif(info.physicalLine > line)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tscreenLine = i - 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(info.physicalLine == line)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(offset >= info.offset\\n\\t\\t\\t\\t\\t\\t&& offset < info.offset + info.length)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tscreenLine = i;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(screenLine == -1)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tlastScreenLineP = line;\\n\\t\\t\\t\\tlastScreenLine = screenLine;\\n\\t\\t\\t\\treturn screenLine;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tvoid recalculateVisibleLines()\\n\\t{\\n\\t\\tLineInfo[] newLineInfo = new LineInfo[textArea.getVisibleLines()];\\n\\t\\tint start;\\n\\t\\tif(lineInfo == null)\\n\\t\\t\\tstart = 0;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstart = Math.min(lineInfo.length,newLineInfo.length);\\n\\t\\t\\tSystem.arraycopy(lineInfo,0,newLineInfo,0,start);\\n\\t\\t}\\n\\t\\tfor(int i = start; i < newLineInfo.length; i++)\\n\\t\\t\\tnewLineInfo[i] = new LineInfo();\\n\\t\\tlineInfo = newLineInfo;\\n\\t\\tlastScreenLine = lastScreenLineP = -1;\\n\\t} \\n\\t\\tvoid setBuffer(Buffer buffer)\\n\\t{\\n\\t\\tthis.buffer = buffer;\\n\\t\\tlastScreenLine = lastScreenLineP = -1;\\n\\t} \\n\\t\\tvoid scrollDown(int amount)\\n\\t{\\n\\t\\tint visibleLines = textArea.getVisibleLines();\\n\\t\\tSystem.arraycopy(lineInfo,amount,lineInfo,0,visibleLines - amount);\\n\\t\\tfor(int i = visibleLines - amount; i < visibleLines; i++)\\n\\t\\t{\\n\\t\\t\\tlineInfo[i] = new LineInfo();\\n\\t\\t}\\n\\t\\tfirstInvalidLine -= amount;\\n\\t\\tif(firstInvalidLine < 0)\\n\\t\\t\\tfirstInvalidLine = 0;\\n\\t\\tif(Debug.CHUNK_CACHE_DEBUG)\\n\\t\\t{\\n\\t\\t\\tSystem.err.println(\\\"f > t.f: only \\\" + amount\\n\\t\\t\\t\\t+ \\\" need updates\\\");\\n\\t\\t}\\n\\t\\tlastScreenLine = lastScreenLineP = -1;\\n\\t} \\n\\t\\tvoid scrollUp(int amount)\\n\\t{\\n\\t\\tSystem.arraycopy(lineInfo,0,lineInfo,amount,\\n\\t\\t\\ttextArea.getVisibleLines() - amount);\\n\\t\\tfor(int i = 0; i < amount; i++)\\n\\t\\t{\\n\\t\\t\\tlineInfo[i] = new LineInfo();\\n\\t\\t}\\n\\t\\t\\t\\tint oldFirstInvalidLine = firstInvalidLine;\\n\\t\\tfirstInvalidLine = 0;\\n\\t\\tupdateChunksUpTo(amount);\\n\\t\\tfirstInvalidLine = oldFirstInvalidLine + amount;\\n\\t\\tif(firstInvalidLine > textArea.getVisibleLines())\\n\\t\\t\\tfirstInvalidLine = textArea.getVisibleLines();\\n\\t\\tif(Debug.CHUNK_CACHE_DEBUG)\\n\\t\\t{\\n\\t\\t\\tSystem.err.println(\\\"f > t.f: only \\\" + amount\\n\\t\\t\\t\\t+ \\\" need updates\\\");\\n\\t\\t}\\n\\t\\tlastScreenLine = lastScreenLineP = -1;\\n\\t} \\n\\t\\tvoid invalidateAll()\\n\\t{\\n\\t\\tfirstInvalidLine = 0;\\n\\t\\tlastScreenLine = lastScreenLineP = -1;\\n\\t} \\n\\t\\tvoid invalidateChunksFrom(int screenLine)\\n\\t{\\n\\t\\tfirstInvalidLine = Math.min(screenLine,firstInvalidLine);\\n\\t\\tif(screenLine <= lastScreenLine)\\n\\t\\t\\tlastScreenLine = lastScreenLineP = -1;\\n\\t} \\n\\t\\tvoid invalidateChunksFromPhys(int physicalLine)\\n\\t{\\n\\t\\tfor(int i = 0; i < firstInvalidLine; i++)\\n\\t\\t{\\n\\t\\t\\tLineInfo info = lineInfo[i];\\n\\t\\t\\tif(info.physicalLine == -1 || info.physicalLine >= physicalLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstInvalidLine = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tLineInfo getLineInfo(int screenLine)\\n\\t{\\n\\t\\tupdateChunksUpTo(screenLine);\\n\\t\\treturn lineInfo[screenLine];\\n\\t} \\n\\t\\tint getLineSubregionCount(int physicalLine)\\n\\t{\\n\\t\\tout.clear();\\n\\t\\tlineToChunkList(physicalLine,out);\\n\\t\\tint size = out.size();\\n\\t\\tif(size == 0)\\n\\t\\t\\treturn 1;\\n\\t\\telse\\n\\t\\t\\treturn size;\\n\\t} \\n\\tint getSubregionOfOffset(int offset, LineInfo[] lineInfos)\\n\\t{\\n\\t\\tfor(int i = 0; i < lineInfos.length; i++)\\n\\t\\t{\\n\\t\\t\\tLineInfo info = lineInfos[i];\\n\\t\\t\\tif(offset >= info.offset && offset < info.offset + info.length)\\n\\t\\t\\t\\treturn i;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t} \\n\\tint xToSubregionOffset(int physicalLine, int subregion, int x,\\n\\t\\tboolean round)\\n\\t{\\n\\t\\tLineInfo[] infos = getLineInfosForPhysicalLine(physicalLine);\\n\\t\\tif(subregion == -1)\\n\\t\\t\\tsubregion += infos.length;\\n\\t\\treturn xToSubregionOffset(infos[subregion],x,round);\\n\\t} \\n\\tint xToSubregionOffset(LineInfo info, int x,\\n\\t\\tboolean round)\\n\\t{\\n\\t\\tint offset = Chunk.xToOffset(info.chunks,\\n\\t\\t\\tx - textArea.getHorizontalOffset(),round);\\n\\t\\tif(offset == -1 || offset == info.offset + info.length)\\n\\t\\t\\toffset = info.offset + info.length - 1;\\n\\t\\treturn offset;\\n\\t} \\n\\tint subregionOffsetToX(int physicalLine, int offset)\\n\\t{\\n\\t\\tLineInfo[] infos = getLineInfosForPhysicalLine(physicalLine);\\n\\t\\tLineInfo info = infos[getSubregionOfOffset(offset,infos)];\\n\\t\\treturn subregionOffsetToX(info,offset);\\n\\t} \\n\\tint subregionOffsetToX(LineInfo info, int offset)\\n\\t{\\n\\t\\treturn (int)(textArea.getHorizontalOffset() + Chunk.offsetToX(\\n\\t\\t\\tinfo.chunks,offset));\\n\\t} \\n\\tint getSubregionStartOffset(int line, int offset)\\n\\t{\\n\\t\\tLineInfo[] lineInfos = getLineInfosForPhysicalLine(line);\\n\\t\\tLineInfo info = lineInfos[getSubregionOfOffset(offset,lineInfos)];\\n\\t\\treturn textArea.getLineStartOffset(info.physicalLine)\\n\\t\\t\\t+ info.offset;\\n\\t} \\n\\tint getSubregionEndOffset(int line, int offset)\\n\\t{\\n\\t\\tLineInfo[] lineInfos = getLineInfosForPhysicalLine(line);\\n\\t\\tLineInfo info = lineInfos[getSubregionOfOffset(offset,lineInfos)];\\n\\t\\treturn textArea.getLineStartOffset(info.physicalLine)\\n\\t\\t\\t+ info.offset + info.length;\\n\\t} \\n\\tint getBelowPosition(int physicalLine, int offset, int x,\\n\\t\\tboolean ignoreWrap)\\n\\t{\\n\\t\\tLineInfo[] lineInfos = getLineInfosForPhysicalLine(physicalLine);\\n\\t\\tint subregion = getSubregionOfOffset(offset,lineInfos);\\n\\t\\tif(subregion != lineInfos.length - 1 && !ignoreWrap)\\n\\t\\t{\\n\\t\\t\\treturn textArea.getLineStartOffset(physicalLine)\\n\\t\\t\\t\\t+ xToSubregionOffset(lineInfos[subregion + 1],\\n\\t\\t\\t\\tx,true);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint nextLine = textArea.displayManager\\n\\t\\t\\t\\t.getNextVisibleLine(physicalLine);\\n\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn textArea.getLineStartOffset(nextLine)\\n\\t\\t\\t\\t\\t+ xToSubregionOffset(nextLine,0,\\n\\t\\t\\t\\t\\tx,true);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tint getAbovePosition(int physicalLine, int offset, int x,\\n\\t\\tboolean ignoreWrap)\\n\\t{\\n\\t\\tLineInfo[] lineInfos = getLineInfosForPhysicalLine(physicalLine);\\n\\t\\tint subregion = getSubregionOfOffset(offset,lineInfos);\\n\\t\\tif(subregion != 0 && !ignoreWrap)\\n\\t\\t{\\n\\t\\t\\treturn textArea.getLineStartOffset(physicalLine)\\n\\t\\t\\t\\t+ xToSubregionOffset(lineInfos[subregion - 1],\\n\\t\\t\\t\\tx,true);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint prevLine = textArea.displayManager\\n\\t\\t\\t\\t.getPrevVisibleLine(physicalLine);\\n\\t\\t\\tif(prevLine == -1)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn textArea.getLineStartOffset(prevLine)\\n\\t\\t\\t\\t\\t+ xToSubregionOffset(prevLine,-1,\\n\\t\\t\\t\\t\\tx,true);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tboolean needFullRepaint()\\n\\t{\\n\\t\\tboolean retVal = needFullRepaint;\\n\\t\\tneedFullRepaint = false;\\n\\t\\treturn retVal;\\n\\t} \\n\\t\\tLineInfo[] getLineInfosForPhysicalLine(int physicalLine)\\n\\t{\\n\\t\\tout.clear();\\n\\t\\tlineToChunkList(physicalLine,out);\\n\\t\\tif(out.size() == 0)\\n\\t\\t\\tout.add(null);\\n\\t\\tArrayList returnValue = new ArrayList(out.size());\\n\\t\\tgetLineInfosForPhysicalLine(physicalLine,returnValue);\\n\\t\\treturn (LineInfo[])returnValue.toArray(new LineInfo[out.size()]);\\n\\t} \\n\\t\\tprivate JEditTextArea textArea;\\n\\tprivate Buffer buffer;\\n\\tprivate LineInfo[] lineInfo;\\n\\tprivate ArrayList out;\\n\\tprivate int firstInvalidLine;\\n\\tprivate int lastScreenLineP;\\n\\tprivate int lastScreenLine;\\n\\tprivate boolean needFullRepaint;\\n\\tprivate DisplayTokenHandler tokenHandler;\\n\\t\\tprivate void getLineInfosForPhysicalLine(int physicalLine, List list)\\n\\t{\\n\\t\\tfor(int i = 0; i < out.size(); i++)\\n\\t\\t{\\n\\t\\t\\tChunk chunks = (Chunk)out.get(i);\\n\\t\\t\\tLineInfo info = new LineInfo();\\n\\t\\t\\tinfo.physicalLine = physicalLine;\\n\\t\\t\\tif(i == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tinfo.firstSubregion = true;\\n\\t\\t\\t\\tinfo.offset = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tinfo.offset = chunks.offset;\\n\\t\\t\\tif(i == out.size() - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tinfo.lastSubregion = true;\\n\\t\\t\\t\\tinfo.length = textArea.getLineLength(physicalLine)\\n\\t\\t\\t\\t\\t- info.offset + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tinfo.length = ((Chunk)out.get(i + 1)).offset\\n\\t\\t\\t\\t\\t- info.offset;\\n\\t\\t\\t}\\n\\t\\t\\tinfo.chunks = chunks;\\n\\t\\t\\tlist.add(info);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void updateChunksUpTo(int lastScreenLine)\\n\\t{\\n\\t\\tif(lastScreenLine >= lineInfo.length)\\n\\t\\t{\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(lastScreenLine);\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(lastScreenLine < firstInvalidLine)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\tint firstScreenLine = 0;\\n\\t\\tfor(int i = firstInvalidLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(lineInfo[i].lastSubregion)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstScreenLine = i + 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint physicalLine;\\n\\t\\t\\t\\t\\t\\tif(firstScreenLine == 0)\\n\\t\\t{\\n\\t\\t\\tphysicalLine = textArea.getFirstPhysicalLine();\\n\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint prevPhysLine = lineInfo[\\n\\t\\t\\t\\tfirstScreenLine - 1]\\n\\t\\t\\t\\t.physicalLine;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(prevPhysLine == -1)\\n\\t\\t\\t\\tphysicalLine = -1;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tphysicalLine = textArea\\n\\t\\t\\t\\t\\t.displayManager\\n\\t\\t\\t\\t\\t.getNextVisibleLine(prevPhysLine);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(Debug.CHUNK_CACHE_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"Updating chunks from \\\" + firstScreenLine\\n\\t\\t\\t\\t+ \\\" to \\\" + lastScreenLine);\\n\\t\\t}\\n\\t\\tout.clear();\\n\\t\\tint offset = 0;\\n\\t\\tint length = 0;\\n\\t\\tfor(int i = firstScreenLine; i <= lastScreenLine; i++)\\n\\t\\t{\\n\\t\\t\\tLineInfo info = lineInfo[i];\\n\\t\\t\\tChunk chunks;\\n\\t\\t\\t\\t\\t\\tif(out.size() == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(physicalLine != -1 && i != firstScreenLine)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysicalLine = textArea.displayManager\\n\\t\\t\\t\\t\\t\\t.getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\tif(physicalLine == -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tinfo.chunks = null;\\n\\t\\t\\t\\t\\tinfo.physicalLine = -1;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\tlineToChunkList(physicalLine,out);\\n\\t\\t\\t\\tinfo.firstSubregion = true;\\n\\t\\t\\t\\t\\t\\t\\t\\tif(out.size() == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttextArea.getDisplayManager()\\n\\t\\t\\t\\t\\t\\t.setScreenLineCount(\\n\\t\\t\\t\\t\\t\\tphysicalLine,1);\\n\\t\\t\\t\\t\\tif(i == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(textArea.displayManager.firstLine.skew > 0)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"BUG: skew=\\\" + textArea.displayManager.firstLine.skew + \\\",out.size()=\\\" + out.size());\\n\\t\\t\\t\\t\\t\\t\\ttextArea.displayManager.firstLine.skew = 0;\\n\\t\\t\\t\\t\\t\\t\\tneedFullRepaint = true;\\n\\t\\t\\t\\t\\t\\t\\tlastScreenLine = lineInfo.length - 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tchunks = null;\\n\\t\\t\\t\\t\\toffset = 0;\\n\\t\\t\\t\\t\\tlength = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttextArea.getDisplayManager()\\n\\t\\t\\t\\t\\t\\t.setScreenLineCount(\\n\\t\\t\\t\\t\\t\\tphysicalLine,out.size());\\n\\t\\t\\t\\t\\tif(i == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint skew = textArea.displayManager.firstLine.skew;\\n\\t\\t\\t\\t\\t\\tif(skew >= out.size())\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"BUG: skew=\\\" + skew + \\\",out.size()=\\\" + out.size());\\n\\t\\t\\t\\t\\t\\t\\tskew = 0;\\n\\t\\t\\t\\t\\t\\t\\tneedFullRepaint = true;\\n\\t\\t\\t\\t\\t\\t\\tlastScreenLine = lineInfo.length - 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if(skew > 0)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tinfo.firstSubregion = false;\\n\\t\\t\\t\\t\\t\\t\\tfor(int j = 0; j < skew; j++)\\n\\t\\t\\t\\t\\t\\t\\t\\tout.remove(0);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tchunks = (Chunk)out.get(0);\\n\\t\\t\\t\\t\\tout.remove(0);\\n\\t\\t\\t\\t\\toffset = chunks.offset;\\n\\t\\t\\t\\t\\tif(out.size() != 0)\\n\\t\\t\\t\\t\\t\\tlength = ((Chunk)out.get(0)).offset - offset;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tlength = textArea.getLineLength(physicalLine) - offset + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tinfo.firstSubregion = false;\\n\\t\\t\\t\\tchunks = (Chunk)out.get(0);\\n\\t\\t\\t\\tout.remove(0);\\n\\t\\t\\t\\toffset = chunks.offset;\\n\\t\\t\\t\\tif(out.size() != 0)\\n\\t\\t\\t\\t\\tlength = ((Chunk)out.get(0)).offset - offset;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tlength = textArea.getLineLength(physicalLine) - offset + 1;\\n\\t\\t\\t}\\n\\t\\t\\tboolean lastSubregion = (out.size() == 0);\\n\\t\\t\\tif(i == lastScreenLine\\n\\t\\t\\t\\t&& lastScreenLine != lineInfo.length - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(info.physicalLine != physicalLine\\n\\t\\t\\t\\t\\t|| info.lastSubregion != lastSubregion)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastScreenLine++;\\n\\t\\t\\t\\t\\tneedFullRepaint = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(out.size() != 0)\\n\\t\\t\\t\\t\\tlastScreenLine++;\\n\\t\\t\\t}\\n\\t\\t\\tinfo.physicalLine = physicalLine;\\n\\t\\t\\tinfo.lastSubregion = lastSubregion;\\n\\t\\t\\tinfo.offset = offset;\\n\\t\\t\\tinfo.length = length;\\n\\t\\t\\tinfo.chunks = chunks;\\n\\t\\t}\\n\\t\\tfirstInvalidLine = Math.max(lastScreenLine + 1,firstInvalidLine);\\n\\t} \\n\\t\\tprivate void lineToChunkList(int physicalLine, List out)\\n\\t{\\n\\t\\tTextAreaPainter painter = textArea.getPainter();\\n\\t\\tbuffer.getLineText(physicalLine,textArea.lineSegment);\\n\\t\\ttokenHandler.init(textArea.lineSegment,painter.getStyles(),\\n\\t\\t\\tpainter.getFontRenderContext(),\\n\\t\\t\\tpainter,out,\\n\\t\\t\\t(textArea.getDisplayManager().softWrap\\n\\t\\t\\t? textArea.getDisplayManager().wrapMargin : 0.0f));\\n\\t\\tbuffer.markTokens(physicalLine,tokenHandler);\\n\\t} \\n\\t\\tstatic class LineInfo\\n\\t{\\n\\t\\tint physicalLine;\\n\\t\\tint offset;\\n\\t\\tint length;\\n\\t\\tboolean firstSubregion;\\n\\t\\tboolean lastSubregion;\\n\\t\\tChunk chunks;\\n\\t\\tint width;\\n\\t} }\""
        },
        {
            "role": "user",
            "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
        },
        {
            "content": "Title: Diagnosis of starting entity `DisplayManager`\n\nChange set: [ChunkCache, BufferChangeHandler, ScrollLineCount, FirstLine, HelpIndex, HelpTOCPanel, View, BufferIORequest, RingListModel, OffsetManager, PosBottomHalf, PositionManager, PasteFromListDialog, ListHandler, KeyHandler, FontSelector, FontSelectorDialog, TextAreaOptionPane, ActionHandler, JEditTextArea, TextAreaPainter, EditPane, BeanShell]\n\nDetails:\n- **ChunkCache**: Strong semantic coupling (0.868545) with DisplayManager; responsible for caching line display chunks which are directly used by DisplayManager.\n- **BufferChangeHandler**: High co-change confidence (0.5625); though removed in later versions, historical data shows it was tightly coupled with DisplayManager for handling buffer changes.\n- **ScrollLineCount**: DisplayManager instantiates and manages ScrollLineCount to keep track of scroll line count.\n- **FirstLine**: DisplayManager uses FirstLine to manage the first visible line information.\n- **HelpIndex, HelpTOCPanel, View**: Moderate co-change relationships; historically modified together, possibly due to UI or event propagation logic tied to display settings.\n- **BufferIORequest, RingListModel, OffsetManager, PosBottomHalf, PositionManager**: Lower confidence but still relevant co-change history; potentially involved in managing line visibility, offsets, or scrolling states.\n- **PasteFromListDialog, ListHandler, KeyHandler, FontSelector, FontSelectorDialog, TextAreaOptionPane, ActionHandler**: These entities have moderate historical co-change frequency, likely related to user interface configuration or input actions managed by DisplayManager.\n- **JEditTextArea, TextAreaPainter, EditPane, BeanShell**: Related to the broader text area management system; DisplayManager interacts with these components for rendering and editing behavior.\n- **MouseHandler, Anchor, RangeMap**: Low confidence co-changes; may be included for recall completeness, though their relevance is diminished due to removal or refactoring.\n\nThese entities were selected based on co-change history, conceptual coupling results, and analysis of code dependencies between DisplayManager and other components in the jEdit system.",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        }
    ],
    "interaction_records": {
        "step_histories": [
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4"
                ],
                "response_message": "m5"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6"
                ],
                "response_message": "m7"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8"
                ],
                "response_message": "m9"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10"
                ],
                "response_message": "m11"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12"
                ],
                "response_message": "m13"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14"
                ],
                "response_message": "m15"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14",
                    "m15",
                    "m16",
                    "m17"
                ],
                "response_message": "m18"
            }
        ],
        "mid_to_message": {
            "m1": {
                "role": "system",
                "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
            },
            "m2": {
                "role": "user",
                "content": "The project you need to analyze is `jEdit`, a well-known Java open source project. The starting entity you need to deal with is DisplayManager.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
            },
            "m3": {
                "content": "",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_9b91e2ea870f42309ce652",
                        "function": {
                            "arguments": "{\"entity\": \"DisplayManager.java\"}",
                            "name": "get_co_change_relationship"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m4": {
                "name": "get_co_change_relationship",
                "role": "tool",
                "content": "[[\"FirstLine\", \"6\", \"0.375\"], [\"ScrollLineCount\", \"6\", \"0.375\"], [\"ChunkCache\", \"6\", \"0.375\"], [\"HelpIndex\", \"2\", \"0.125\"], [\"HelpTOCPanel\", \"2\", \"0.125\"], [\"View\", \"2\", \"0.125\"], [\"BufferChangeHandler\", \"9\", \"0.5625\"], [\"BufferIORequest\", \"4\", \"0.25\"], [\"RingListModel\", \"2\", \"0.125\"], [\"OffsetManager\", \"2\", \"0.125\"], [\"PosBottomHalf\", \"2\", \"0.125\"], [\"PositionManager\", \"2\", \"0.125\"], [\"PasteFromListDialog\", \"2\", \"0.125\"], [\"ListHandler\", \"2\", \"0.125\"], [\"KeyHandler\", \"2\", \"0.125\"], [\"FontSelector\", \"2\", \"0.125\"], [\"FontSelectorDialog\", \"2\", \"0.125\"], [\"TextAreaOptionPane\", \"2\", \"0.125\"], [\"ActionHandler\", \"2\", \"0.125\"], [\"JEditTextArea\", \"3\", \"0.1875\"], [\"TextAreaPainter\", \"2\", \"0.125\"], [\"EditPane\", \"2\", \"0.125\"], [\"BeanShell\", \"2\", \"0.125\"], [\"MouseHandler\", \"1\", \"0.0625\"], [\"Anchor\", \"1\", \"0.0625\"], [\"RangeMap\", \"1\", \"0.0625\"]]"
            },
            "m5": {
                "content": "The `get_co_change_relationship` function has returned a list of entities along with the number of supports and confidence values. These represent files that were historically modified together with `DisplayManager.java`. To prioritize the most relevant files for synchronization, we should focus on those with higher confidence values (e.g., >0.3).\n\nHere are the notable co-changed entities with their confidence values:\n1. **BufferChangeHandler.java** - Confidence: 0.5625\n2. **FirstLine.java**, **ScrollLineCount.java**, **ChunkCache.java** - Confidence: 0.375\n\nThese files show significant historical co-change relationships with `DisplayManager.java`. We can proceed by analyzing the semantic coupling between `DisplayManager.java` and these top candidates to validate if they are conceptually related.\n\nI suggest starting with `BufferChangeHandler.java`, as it has the highest confidence value. Let's calculate the conceptual coupling between `DisplayManager.java` and `BufferChangeHandler.java`.\n\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_012fbbda9cf9413ea7670d",
                        "function": {
                            "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"BufferChangeHandler.java\"}",
                            "name": "get_conceptual_coupling"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m6": {
                "role": "tool",
                "name": "get_conceptual_coupling",
                "content": "[\"BufferChangeHandler has been removed from the project due to project version iteration\"]"
            },
            "m7": {
                "content": "It appears that `BufferChangeHandler.java` has been removed from the project in a previous version iteration, which explains why it no longer exists for further analysis.\n\nGiven this, we should shift our focus to the next set of files with high confidence values from the co-change relationship:  \n- **FirstLine.java**, **ScrollLineCount.java**, and **ChunkCache.java** (all with 0.375 confidence).\n\nLet\u2019s examine the conceptual coupling between `DisplayManager.java` and one of these\u2014say, `FirstLine.java`\u2014to determine if there is still a strong semantic relationship:\n\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_7ce2bee7a98e4e2ab07477",
                        "function": {
                            "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"FirstLine.java\"}",
                            "name": "get_conceptual_coupling"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m8": {
                "role": "tool",
                "name": "get_conceptual_coupling",
                "content": "[\"FirstLine has been removed from the project due to project version iteration\"]"
            },
            "m9": {
                "content": "Similar to `BufferChangeHandler.java`, it seems that `FirstLine.java` has also been removed from the project due to version iteration.\n\nThis suggests that several historically co-changed files related to `DisplayManager.java` are no longer present in the current codebase. This could indicate significant refactoring or architectural changes over time.\n\nLet\u2019s try analyzing the conceptual coupling with another high-confidence file, such as **ScrollLineCount.java**, to see if it still exists and is semantically related:\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_fdbb2f8524be404da0f48b",
                        "function": {
                            "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"ScrollLineCount.java\"}",
                            "name": "get_conceptual_coupling"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m10": {
                "role": "tool",
                "name": "get_conceptual_coupling",
                "content": "[\"ScrollLineCount has been removed from the project due to project version iteration\"]"
            },
            "m11": {
                "content": "It appears that `ScrollLineCount.java` has also been removed from the project, following the same pattern as the previous files.\n\nGiven this recurring trend of removals among files with high co-change confidence, it's possible that `DisplayManager.java` has undergone significant architectural changes or refactoring in recent versions, leading to the obsolescence of several related entities.\n\nLet\u2019s now check a file with slightly lower confidence but potentially still relevant: **ChunkCache.java**. We'll assess its conceptual coupling with `DisplayManager.java`:\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_68dd5bfa146045b7a10a20",
                        "function": {
                            "arguments": "{\"entity1\": \"DisplayManager.java\", \"entity2\": \"ChunkCache.java\"}",
                            "name": "get_conceptual_coupling"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m12": {
                "role": "tool",
                "name": "get_conceptual_coupling",
                "content": "\"0.868545\""
            },
            "m13": {
                "content": "The conceptual coupling between `DisplayManager.java` and `ChunkCache.java` is quite high at **0.868545**, indicating a strong semantic relationship.\n\nDespite the removal of several historically co-changed files, `ChunkCache.java` still exists in the project and is semantically related to `DisplayManager.java`. Therefore, it should be considered a key entity that may need synchronization when changes are made to `DisplayManager.java`.\n\n### Summary of Findings:\n- Several historically co-changed files (e.g., `BufferChangeHandler.java`, `FirstLine.java`, `ScrollLineCount.java`) have been removed due to project evolution.\n- `ChunkCache.java` remains in the codebase and has a strong semantic relationship with `DisplayManager.java`.\n\n### Recommendation:\n**Synchronize changes to `ChunkCache.java` whenever modifications are made to `DisplayManager.java`.**\n\nIf you'd like, we can now examine the actual source code of these two files to further validate their relationship or understand potential impact areas.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_f24215cbfb4d4c6c8790fe",
                        "function": {
                            "arguments": "{\"entity\": \"DisplayManager.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m14": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package org.gjt.sp.jedit.textarea;\\nimport javax.swing.SwingUtilities;\\nimport java.awt.Toolkit;\\nimport java.util.*;\\nimport org.gjt.sp.jedit.buffer.*;\\nimport org.gjt.sp.jedit.textarea.JEditTextArea;\\nimport org.gjt.sp.jedit.*;\\nimport org.gjt.sp.util.Log;\\npublic class DisplayManager\\n{\\n\\tpublic static long scanCount, scannedLines;\\n\\t\\tstatic DisplayManager getDisplayManager(Buffer buffer,\\n\\t\\tJEditTextArea textArea)\\n\\t{\\n\\t\\tList l = (List)bufferMap.get(buffer);\\n\\t\\tDisplayManager dmgr;\\n\\t\\tif(l == null)\\n\\t\\t{\\n\\t\\t\\tl = new LinkedList();\\n\\t\\t\\tbufferMap.put(buffer,l);\\n\\t\\t}\\n\\t\\tIterator liter = l.iterator();\\n\\t\\twhile(liter.hasNext())\\n\\t\\t{\\n\\t\\t\\tdmgr = (DisplayManager)liter.next();\\n\\t\\t\\tif(!dmgr.inUse && dmgr.textArea == textArea)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdmgr.inUse = true;\\n\\t\\t\\t\\treturn dmgr;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tdmgr = new DisplayManager(buffer,textArea);\\n\\t\\tdmgr.inUse = true;\\n\\t\\tl.add(dmgr);\\n\\t\\treturn dmgr;\\n\\t} \\n\\t\\tstatic void releaseDisplayManager(DisplayManager dmgr)\\n\\t{\\n\\t\\tdmgr.inUse = false;\\n\\t} \\n\\t\\tpublic static void bufferClosed(Buffer buffer)\\n\\t{\\n\\t\\tbufferMap.remove(buffer);\\n\\t} \\n\\t\\tstatic void textAreaDisposed(JEditTextArea textArea)\\n\\t{\\n\\t\\tIterator biter = bufferMap.values().iterator();\\n\\t\\twhile(biter.hasNext())\\n\\t\\t{\\n\\t\\t\\tList l = (List)biter.next();\\n\\t\\t\\tIterator liter = l.iterator();\\n\\t\\t\\twhile(liter.hasNext())\\n\\t\\t\\t{\\n\\t\\t\\t\\tDisplayManager dmgr = (DisplayManager)\\n\\t\\t\\t\\t\\tliter.next();\\n\\t\\t\\t\\tif(dmgr.textArea == textArea)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdmgr.dispose();\\n\\t\\t\\t\\t\\tliter.remove();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate static void _setScreenLineCount(Buffer buffer, int line,\\n\\t\\tint oldCount, int count)\\n\\t{\\n\\t\\tIterator iter = ((List)bufferMap.get(buffer)).iterator();\\n\\t\\twhile(iter.hasNext())\\n\\t\\t{\\n\\t\\t\\t((DisplayManager)iter.next())._setScreenLineCount(line,oldCount,count);\\n\\t\\t}\\n\\t} \\n\\t\\tstatic void _notifyScreenLineChanges(Buffer buffer)\\n\\t{\\n\\t\\tIterator iter = ((List)bufferMap.get(buffer)).iterator();\\n\\t\\twhile(iter.hasNext())\\n\\t\\t{\\n\\t\\t\\t((DisplayManager)iter.next())._notifyScreenLineChanges();\\n\\t\\t}\\n\\t} \\n\\tprivate static Map bufferMap = new HashMap();\\n\\tpublic final boolean isLineVisible(int line)\\n\\t{\\n\\t\\treturn fvmget(line) % 2 == 0;\\n\\t} \\n\\tpublic int getFirstVisibleLine()\\n\\t{\\n\\t\\treturn fvm[0];\\n\\t} \\n\\tpublic int getLastVisibleLine()\\n\\t{\\n\\t\\treturn fvm[fvmcount - 1] - 1;\\n\\t} \\n\\tpublic int getNextVisibleLine(int line)\\n\\t{\\n\\t\\tint index = fvmget(line);\\n\\t\\tif(index % 2 != 0)\\n\\t\\t{\\n\\t\\t\\tif(fvmcount == index + 1)\\n\\t\\t\\t\\treturn - 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn fvm[index + 1];\\n\\t\\t}\\n\\t\\telse if(line == fvm[index + 1] - 1)\\n\\t\\t{\\n\\t\\t\\tif(fvmcount == index + 2)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn fvm[index + 2];\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn line + 1;\\n\\t} \\n\\tpublic int getPrevVisibleLine(int line)\\n\\t{\\n\\t\\tint index = fvmget(line);\\n\\t\\tif(index == -1)\\n\\t\\t\\treturn -1;\\n\\t\\telse if(index % 2 == 1)\\n\\t\\t{\\n\\t\\t\\treturn fvm[index] - 1;\\n\\t\\t}\\n\\t\\telse if(line == fvm[index])\\n\\t\\t{\\n\\t\\t\\tif(index == 0)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn fvm[index - 1] - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn line - 1;\\n\\t} \\n\\t\\tpublic final int getScreenLineCount(int line)\\n\\t{\\n\\t\\tif(offsetMgr.isScreenLineCountValid(line))\\n\\t\\t\\treturn offsetMgr.getScreenLineCount(line);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint newCount = textArea.chunkCache\\n\\t\\t\\t\\t.getLineSubregionCount(line);\\n\\t\\t\\tsetScreenLineCount(line,newCount);\\n\\t\\t\\treturn newCount;\\n\\t\\t}\\n\\t} \\n\\t\\tpublic final int getScrollLineCount()\\n\\t{\\n\\t\\treturn scrollLineCount.scrollLine;\\n\\t} \\n\\tpublic void collapseFold(int line)\\n\\t{\\n\\t\\tint lineCount = buffer.getLineCount();\\n\\t\\tint start = 0;\\n\\t\\tint end = lineCount - 1;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.writeLock();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(line != 0\\n\\t\\t\\t\\t&& line != buffer.getLineCount() - 1\\n\\t\\t\\t\\t&& buffer.isFoldStart(line)\\n\\t\\t\\t\\t&& !isLineVisible(line + 1))\\n\\t\\t\\t{\\n\\t\\t\\t\\tline--;\\n\\t\\t\\t}\\n\\t\\t\\tint initialFoldLevel = buffer.getFoldLevel(line);\\n\\t\\t\\t\\t\\t\\tif(line != lineCount - 1\\n\\t\\t\\t\\t&& buffer.getFoldLevel(line + 1) > initialFoldLevel)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tstart = line + 1;\\n\\t\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(buffer.getFoldLevel(i) <= initialFoldLevel)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tboolean ok = false;\\n\\t\\t\\t\\t\\t\\t\\t\\tfor(int i = line - 1; i >= 0; i--)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(buffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tstart = i + 1;\\n\\t\\t\\t\\t\\t\\tok = true;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!ok)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(buffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\t\\t\\t\\thideLineRange(start,end);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.writeUnlock();\\n\\t\\t}\\n\\t\\t_notifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic int expandFold(int line, boolean fully)\\n\\t{\\n\\t\\t\\t\\tint returnValue = -1;\\n\\t\\tint lineCount = buffer.getLineCount();\\n\\t\\tint start = 0;\\n\\t\\tint end = lineCount - 1;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.writeLock();\\n\\t\\t\\tint initialFoldLevel = buffer.getFoldLevel(line);\\n\\t\\t\\t\\t\\t\\tif(line != lineCount - 1\\n\\t\\t\\t\\t&& isLineVisible(line)\\n\\t\\t\\t\\t&& !isLineVisible(line + 1)\\n\\t\\t\\t\\t&& buffer.getFoldLevel(line + 1) > initialFoldLevel)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tstart = line + 1;\\n\\t\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(\\n\\t\\t\\t\\t\\t\\tbuffer.getFoldLevel(i) <= initialFoldLevel)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tboolean ok = false;\\n\\t\\t\\t\\t\\t\\t\\t\\tfor(int i = line - 1; i >= 0; i--)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(isLineVisible(i) && buffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tstart = i + 1;\\n\\t\\t\\t\\t\\t\\tok = true;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!ok)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int i = line + 1; i < lineCount; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif((isLineVisible(i) &&\\n\\t\\t\\t\\t\\t\\tbuffer.getFoldLevel(i) < initialFoldLevel)\\n\\t\\t\\t\\t\\t\\t|| i == getLastVisibleLine())\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\t\\t\\t\\tif(fully)\\n\\t\\t\\t{\\n\\t\\t\\t\\tshowLineRange(start,end);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tinitialFoldLevel = buffer.getFoldLevel(start);\\n\\t\\t\\t\\tint firstVisible = start;\\n\\t\\t\\t\\tfor(int i = start; i <= end; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(buffer.getFoldLevel(i) > initialFoldLevel)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(returnValue == -1\\n\\t\\t\\t\\t\\t\\t\\t&& i != 0\\n\\t\\t\\t\\t\\t\\t\\t&& buffer.isFoldStart(i - 1))\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\treturnValue = i - 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(firstVisible != i)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tshowLineRange(firstVisible,i - 1);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tfirstVisible = i + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(firstVisible != end + 1)\\n\\t\\t\\t\\t\\tshowLineRange(firstVisible,end);\\n\\t\\t\\t\\tif(!isLineVisible(line))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\texpandFold(line,false);\\n\\t\\t\\t\\t\\treturn returnValue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.writeUnlock();\\n\\t\\t}\\n\\t\\t_notifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t\\treturn returnValue;\\n\\t} \\n\\tpublic void expandAllFolds()\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.writeLock();\\n\\t\\t\\tshowLineRange(0,buffer.getLineCount() - 1);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.writeUnlock();\\n\\t\\t}\\n\\t\\t_notifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic void expandFolds(char digit)\\n\\t{\\n\\t\\tif(digit < '1' || digit > '9')\\n\\t\\t{\\n\\t\\t\\tToolkit.getDefaultToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\texpandFolds((int)(digit - '1') + 1);\\n\\t} \\n\\tpublic void expandFolds(int foldLevel)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.writeLock();\\n\\t\\t\\tif(buffer.getFoldHandler() instanceof IndentFoldHandler)\\n\\t\\t\\t\\tfoldLevel = (foldLevel - 1) * buffer.getIndentSize() + 1;\\n\\t\\t\\tshowLineRange(0,buffer.getLineCount() - 1);\\n\\t\\t\\tboolean seenVisibleLine = false;\\n\\t\\t\\tint firstInvisible = 0;\\n\\t\\t\\tfor(int i = 0; i < buffer.getLineCount(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(!seenVisibleLine || buffer.getFoldLevel(i) < foldLevel)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(firstInvisible != i)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\thideLineRange(firstInvisible,\\n\\t\\t\\t\\t\\t\\t\\ti - 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfirstInvisible = i + 1;\\n\\t\\t\\t\\t\\tseenVisibleLine = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(firstInvisible != buffer.getLineCount())\\n\\t\\t\\t\\thideLineRange(firstInvisible,buffer.getLineCount() - 1);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.writeUnlock();\\n\\t\\t}\\n\\t\\t_notifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\tpublic void narrow(int start, int end)\\n\\t{\\n\\t\\tif(start > end || start < 0 || end >= buffer.getLineCount())\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(start + \\\", \\\" + end);\\n\\t\\tif(start < getFirstVisibleLine() || end > getLastVisibleLine())\\n\\t\\t\\texpandAllFolds();\\n\\t\\thideLineRange(0,start - 1);\\n\\t\\thideLineRange(end + 1,buffer.getLineCount() - 1);\\n\\t\\t\\t\\tif(getNextVisibleLine(start) == -1)\\n\\t\\t\\texpandFold(start,false);\\n\\t\\t\\t\\t\\t\\tGUIUtilities.getView(textArea).getStatus().setMessageAndClear(\\n\\t\\t\\tjEdit.getProperty(\\\"view.status.narrow\\\"));\\n\\t\\t_notifyScreenLineChanges();\\n\\t\\ttextArea.foldStructureChanged();\\n\\t} \\n\\t\\tboolean softWrap;\\n\\tint wrapMargin;\\n\\tFirstLine firstLine;\\n\\tScrollLineCount scrollLineCount;\\n\\t\\tvoid init()\\n\\t{\\n\\t\\tif(!initialized)\\n\\t\\t{\\n\\t\\t\\tinitialized = true;\\n\\t\\t\\tfvm = new int[2];\\n\\t\\t\\tif(buffer.isLoaded())\\n\\t\\t\\t\\tbufferChangeHandler.foldHandlerChanged(buffer);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t}\\n\\t} \\n\\tvoid setScreenLineCount(int line, int count)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.writeLock();\\n\\t\\t\\tint oldCount = offsetMgr.getScreenLineCount(line);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(count != oldCount)\\n\\t\\t\\t{\\n\\t\\t\\t\\toffsetMgr.setScreenLineCount(line,count);\\n\\t\\t\\t\\t_setScreenLineCount(buffer,line,oldCount,count);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.writeUnlock();\\n\\t\\t}\\n\\t} \\n\\t\\tvoid updateWrapSettings()\\n\\t{\\n\\t\\tString wrap = buffer.getStringProperty(\\\"wrap\\\");\\n\\t\\tsoftWrap = wrap.equals(\\\"soft\\\");\\n\\t\\tif(textArea.maxLineLen <= 0)\\n\\t\\t{\\n\\t\\t\\tsoftWrap = false;\\n\\t\\t\\twrapMargin = 0;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tchar[] foo = new char[textArea.maxLineLen];\\n\\t\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfoo[i] = ' ';\\n\\t\\t\\t}\\n\\t\\t\\tTextAreaPainter painter = textArea.getPainter();\\n\\t\\t\\twrapMargin = (int)painter.getFont().getStringBounds(\\n\\t\\t\\t\\tfoo,0,foo.length,\\n\\t\\t\\t\\tpainter.getFontRenderContext())\\n\\t\\t\\t\\t.getWidth();\\n\\t\\t}\\n\\t} \\n\\t\\tprivate boolean initialized;\\n\\tprivate boolean inUse;\\n\\tprivate Buffer buffer;\\n\\tprivate OffsetManager offsetMgr;\\n\\tprivate JEditTextArea textArea;\\n\\tprivate BufferChangeHandler bufferChangeHandler;\\n\\tprivate int[] fvm;\\n\\tprivate int fvmcount;\\n\\tprivate int lastfvmget = -1;\\n\\t\\tprivate DisplayManager(Buffer buffer, JEditTextArea textArea)\\n\\t{\\n\\t\\tthis.buffer = buffer;\\n\\t\\tthis.offsetMgr = buffer._getOffsetManager();\\n\\t\\tthis.textArea = textArea;\\n\\t\\tscrollLineCount = new ScrollLineCount();\\n\\t\\tfirstLine = new FirstLine();\\n\\t\\tbufferChangeHandler = new BufferChangeHandler();\\n\\t\\t\\t\\tbuffer.addBufferChangeListener(bufferChangeHandler,\\n\\t\\t\\tBuffer.HIGH_PRIORITY);\\n\\t} \\n\\t\\tprivate void dispose()\\n\\t{\\n\\t\\tbuffer.removeBufferChangeListener(bufferChangeHandler);\\n\\t} \\n\\tprivate void fvmtest()\\n\\t{\\n\\t\\tboolean[] map = new boolean[buffer.getLineCount()];\\n\\t\\tjava.util.Random random = new java.util.Random();\\n\\t\\t\\t\\t\\t\\tfor(int i = 0; i < 1000; i++)\\n\\t\\t{\\n\\t\\t\\tint random1 = Math.abs(random.nextInt() % map.length);\\n\\t\\t\\tint random2 = Math.abs(random.nextInt() % map.length);\\n\\t\\t\\tif(random2 < random1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint tmp = random1;\\n\\t\\t\\t\\trandom1 = random2;\\n\\t\\t\\t\\trandom2 = tmp;\\n\\t\\t\\t}\\n\\t\\t\\tboolean vis = (random1 + random2 % 2 == 0);\\n\\t\\t\\tif(vis)\\n\\t\\t\\t\\tshowLineRange(random1,random2);\\n\\t\\t\\telse\\n\\t\\t\\t\\thideLineRange(random1,random2);\\n\\t\\t\\tfor(int j = random1; j <= random2; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmap[j] = vis;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tfor(int i = 0; i < map.length; i++)\\n\\t\\t{\\n\\t\\t\\tif(isLineVisible(i) != map[i])\\n\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"Mismatch: \\\" + i);\\n\\t\\t}\\n\\t} \\n\\tprivate int fvmget(int line)\\n\\t{\\n\\t\\tscanCount++;\\n\\t\\tif(line < fvm[0])\\n\\t\\t\\treturn -1;\\n\\t\\tif(line >= fvm[fvmcount - 1])\\n\\t\\t\\treturn fvmcount - 1;\\n\\t\\tif(lastfvmget != -1)\\n\\t\\t{\\n\\t\\t\\tif(line >= fvm[lastfvmget])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(lastfvmget == fvmcount - 1\\n\\t\\t\\t\\t\\t|| line < fvm[lastfvmget + 1])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn lastfvmget;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint start = 0;\\n\\t\\tint end = fvmcount - 1;\\nloop:\\t\\tfor(;;)\\n\\t\\t{\\n\\t\\t\\tscannedLines++;\\n\\t\\t\\tswitch(end - start)\\n\\t\\t\\t{\\n\\t\\t\\tcase 0:\\n\\t\\t\\t\\tlastfvmget = start;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\tint value = fvm[end];\\n\\t\\t\\t\\tif(value <= line)\\n\\t\\t\\t\\t\\tlastfvmget = end;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tlastfvmget = start;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tint pivot = (end + start) / 2;\\n\\t\\t\\t\\tvalue = fvm[pivot];\\n\\t\\t\\t\\tif(value == line)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastfvmget = pivot;\\n\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(value < line)\\n\\t\\t\\t\\t\\tstart = pivot;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tend = pivot - 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn lastfvmget;\\n\\t} \\n\\tprivate void fvmput(int start, int end, int[] put)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tStringBuffer buf = new StringBuffer(\\\"{\\\");\\n\\t\\t\\tif(put != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i = 0; i < put.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(i != 0)\\n\\t\\t\\t\\t\\t\\tbuf.append(',');\\n\\t\\t\\t\\t\\tbuf.append(put[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tbuf.append(\\\"}\\\");\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"fvmput(\\\" + start + \\\",\\\"\\n\\t\\t\\t\\t+ end + \\\",\\\" + buf + \\\")\\\");\\n\\t\\t}\\n\\t\\tint putl = (put == null ? 0 : put.length);\\n\\t\\tint delta = putl - (end - start);\\n\\t\\tif(fvmcount + delta > fvm.length)\\n\\t\\t{\\n\\t\\t\\tint[] newfvm = new int[fvm.length * 2 + 1];\\n\\t\\t\\tSystem.arraycopy(fvm,0,newfvm,0,fvmcount);\\n\\t\\t\\tfvm = newfvm;\\n\\t\\t}\\n\\t\\tif(delta != 0)\\n\\t\\t{\\n\\t\\t\\tSystem.arraycopy(fvm,end,fvm,start + putl,\\n\\t\\t\\t\\tfvmcount - end);\\n\\t\\t}\\n\\t\\tif(putl != 0)\\n\\t\\t{\\n\\t\\t\\tSystem.arraycopy(put,0,fvm,start,put.length);\\n\\t\\t}\\n\\t\\tfvmcount += delta;\\n\\t\\tif(fvmcount == 0)\\n\\t\\t\\tthrow new InternalError();\\n\\t} \\n\\tprivate void fvmput2(int starti, int endi, int start, int end)\\n\\t{\\n\\t\\tif(Debug.FOLD_VIS_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"*fvmput2(\\\" + starti + \\\",\\\"\\n\\t\\t\\t\\t+ endi + \\\",\\\" + start + \\\",\\\" + end + \\\")\\\");\\n\\t\\t}\\n\\t\\tif(starti != -1 && fvm[starti] == start)\\n\\t\\t{\\n\\t\\t\\tif(endi <= fvmcount - 2 && fvm[endi + 1]\\n\\t\\t\\t\\t== end + 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti,endi + 2,null);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti,endi + 1,\\n\\t\\t\\t\\t\\tnew int[] { end + 1 });\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(endi != fvmcount - 1 && fvm[endi + 1]\\n\\t\\t\\t\\t== end + 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 2,\\n\\t\\t\\t\\t\\tnew int[] { start });\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 1,\\n\\t\\t\\t\\t\\tnew int[] { start,\\n\\t\\t\\t\\t\\tend + 1 });\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void showLineRange(int start, int end)\\n\\t{\\n\\t\\tfor(int i = start; i <= end; i++)\\n\\t\\t{\\n\\t\\t\\tif(!isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint screenLines = offsetMgr\\n\\t\\t\\t\\t\\t.getScreenLineCount(i);\\n\\t\\t\\t\\tif(firstLine.physicalLine >= i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfirstLine.scrollLine += screenLines;\\n\\t\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tscrollLineCount.scrollLine += screenLines;\\n\\t\\t\\t\\tscrollLineCount.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tlastfvmget = -1;\\n\\t\\tint starti = fvmget(start);\\n\\t\\tint endi = fvmget(end);\\n\\t\\tif(starti % 2 == 0)\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 1,null);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\tfvm[starti + 1] = end + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\tfvm[starti + 1] = start;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tfvmput2(starti,endi,start,end);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void hideLineRange(int start, int end)\\n\\t{\\n\\t\\tfor(int i = start; i <= end; i++)\\n\\t\\t{\\n\\t\\t\\tif(isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint screenLines = offsetMgr\\n\\t\\t\\t\\t\\t.getScreenLineCount(i);\\n\\t\\t\\t\\tif(firstLine.physicalLine >= i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfirstLine.scrollLine -= screenLines;\\n\\t\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tscrollLineCount.scrollLine -= screenLines;\\n\\t\\t\\t\\tscrollLineCount.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tlastfvmget = -1;\\n\\t\\tint starti = fvmget(start);\\n\\t\\tint endi = fvmget(end);\\n\\t\\tif(starti % 2 == 0)\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t\\tfvmput2(starti,endi,start,end);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\tfvm[starti + 1] = start;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(endi % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\tfvm[starti + 1] = end + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tfvmput(starti + 1,endi + 1,null);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void _setScreenLineCount(int line, int oldCount, int count)\\n\\t{\\n\\t\\tif(!isLineVisible(line))\\n\\t\\t\\treturn;\\n\\t\\tif(firstLine.physicalLine >= line)\\n\\t\\t{\\n\\t\\t\\tif(firstLine.physicalLine == line)\\n\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstLine.scrollLine += (count - oldCount);\\n\\t\\t\\t\\tfirstLine.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tscrollLineCount.scrollLine += (count - oldCount);\\n\\t\\tscrollLineCount.callChanged = true;\\n\\t} \\n\\t\\tprivate void _notifyScreenLineChanges()\\n\\t{\\n\\t\\tif(firstLine.callReset)\\n\\t\\t\\tfirstLine.reset();\\n\\t\\telse if(firstLine.callChanged)\\n\\t\\t\\tfirstLine.changed();\\n\\t\\tfirstLine.callReset = firstLine.callChanged = false;\\n\\t\\tif(scrollLineCount.callReset)\\n\\t\\t\\tscrollLineCount.reset();\\n\\t\\telse if(scrollLineCount.callChanged)\\n\\t\\t\\tscrollLineCount.changed();\\n\\t\\tscrollLineCount.callReset = scrollLineCount.callChanged = false;\\n\\t} \\n\\t\\tstatic abstract class Anchor\\n\\t{\\n\\t\\tint physicalLine;\\n\\t\\tint scrollLine;\\n\\t\\tboolean callChanged;\\n\\t\\tboolean callReset;\\n\\t\\tabstract void reset();\\n\\t\\tabstract void changed();\\n\\t} \\n\\t\\tclass ScrollLineCount extends Anchor\\n\\t{\\n\\t\\t\\t\\tpublic void changed()\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"changed()\\\");\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t} \\n\\t\\t\\t\\tpublic void reset()\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"reset()\\\");\\n\\t\\t\\tupdateWrapSettings();\\n\\t\\t\\tphysicalLine = 0;\\n\\t\\t\\tscrollLine = 0;\\n\\t\\t\\t\\t\\t\\tfor(int i = 0; i < buffer.getLineCount(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(isLineVisible(i))\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(i);\\n\\t\\t\\t}\\n\\t\\t\\tphysicalLine = buffer.getLineCount();\\n\\t\\t\\tfirstLine.ensurePhysicalLineIsVisible();\\n\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t} \\t} \\n\\t\\tclass FirstLine extends Anchor\\n\\t{\\n\\t\\tint skew;\\n\\t\\t\\t\\tpublic void changed()\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"changed() before: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t} \\n\\t\\t\\tensurePhysicalLineIsVisible();\\n\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\tif(skew >= screenLines)\\n\\t\\t\\t\\tskew = screenLines - 1;\\n\\t\\t\\t\\t\\t\\tif(Debug.VERIFY_FIRST_LINE)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint verifyScrollLine = 0;\\n\\t\\t\\t\\tfor(int i = 0; i < buffer.getLineCount(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!isLineVisible(i))\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\tif(i >= physicalLine)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tverifyScrollLine += getScreenLineCount(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(verifyScrollLine != scrollLine)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tException ex = new Exception(scrollLine + \\\":\\\" + verifyScrollLine);\\n\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,ex);\\n\\t\\t\\t\\t\\tnew org.gjt.sp.jedit.gui.BeanShellErrorDialog(null,ex);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"changed() after: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t} \\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t\\ttextArea.recalculateLastPhysicalLine();\\n\\t\\t} \\n\\t\\t\\t\\tpublic void reset()\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"reset()\\\");\\n\\t\\t\\tString wrap = buffer.getStringProperty(\\\"wrap\\\");\\n\\t\\t\\tsoftWrap = wrap.equals(\\\"soft\\\");\\n\\t\\t\\tif(textArea.maxLineLen <= 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsoftWrap = false;\\n\\t\\t\\t\\twrapMargin = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tchar[] foo = new char[textArea.maxLineLen];\\n\\t\\t\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfoo[i] = ' ';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tTextAreaPainter painter = textArea.getPainter();\\n\\t\\t\\t\\twrapMargin = (int)painter.getFont().getStringBounds(\\n\\t\\t\\t\\t\\tfoo,0,foo.length,\\n\\t\\t\\t\\t\\tpainter.getFontRenderContext())\\n\\t\\t\\t\\t\\t.getWidth();\\n\\t\\t\\t}\\n\\t\\t\\tscrollLine = 0;\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tfor(; i < buffer.getLineCount(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(!isLineVisible(i))\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif(i >= physicalLine)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tscrollLine += getScreenLineCount(i);\\n\\t\\t\\t}\\n\\t\\t\\tphysicalLine = i;\\n\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\tif(skew >= screenLines)\\n\\t\\t\\t\\tskew = screenLines - 1;\\n\\t\\t\\ttextArea.updateScrollBars();\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid physDown(int amount, int screenAmount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physDown() start: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tskew = 0;\\n\\t\\t\\tif(!isLineVisible(physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint lastVisibleLine = getLastVisibleLine();\\n\\t\\t\\t\\tif(physicalLine > lastVisibleLine)\\n\\t\\t\\t\\t\\tphysicalLine = lastVisibleLine;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint nextPhysicalLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tamount -= (nextPhysicalLine - physicalLine);\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = nextPhysicalLine;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(;;)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint nextPhysicalLine = getNextVisibleLine(\\n\\t\\t\\t\\t\\tphysicalLine);\\n\\t\\t\\t\\tif(nextPhysicalLine == -1)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse if(nextPhysicalLine > physicalLine + amount)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t\\tamount -= (nextPhysicalLine - physicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = nextPhysicalLine;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physDown() end: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(screenAmount != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(screenAmount < 0)\\n\\t\\t\\t\\t\\tscrollUp(-screenAmount);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tscrollDown(screenAmount);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid physUp(int amount, int screenAmount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physUp() start: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\tskew = 0;\\n\\t\\t\\tif(!isLineVisible(physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint firstVisibleLine = getFirstVisibleLine();\\n\\t\\t\\t\\tif(physicalLine < firstVisibleLine)\\n\\t\\t\\t\\t\\tphysicalLine = firstVisibleLine;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint prevPhysicalLine = getPrevVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tamount -= (physicalLine - prevPhysicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(;;)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint prevPhysicalLine = getPrevVisibleLine(\\n\\t\\t\\t\\t\\tphysicalLine);\\n\\t\\t\\t\\tif(prevPhysicalLine == -1)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse if(prevPhysicalLine < physicalLine - amount)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tamount -= (physicalLine - prevPhysicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = prevPhysicalLine;\\n\\t\\t\\t\\t\\tscrollLine -= getScreenLineCount(\\n\\t\\t\\t\\t\\t\\tprevPhysicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"physUp() end: \\\"\\n\\t\\t\\t\\t\\t+ physicalLine + \\\":\\\" + scrollLine);\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(screenAmount != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(screenAmount < 0)\\n\\t\\t\\t\\t\\tscrollUp(-screenAmount);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tscrollDown(screenAmount);\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid scrollDown(int amount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"scrollDown()\\\");\\n\\t\\t\\tensurePhysicalLineIsVisible();\\n\\t\\t\\tamount += skew;\\n\\t\\t\\tskew = 0;\\n\\t\\t\\twhile(amount > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\t\\tif(amount < screenLines)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tskew = amount;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint nextLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tboolean visible = isLineVisible(physicalLine);\\n\\t\\t\\t\\t\\tphysicalLine = nextLine;\\n\\t\\t\\t\\t\\tif(visible)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tamount -= screenLines;\\n\\t\\t\\t\\t\\t\\tscrollLine += screenLines;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\tvoid scrollUp(int amount)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"scrollUp()\\\");\\n\\t\\t\\tensurePhysicalLineIsVisible();\\n\\t\\t\\tif(amount <= skew)\\n\\t\\t\\t{\\n\\t\\t\\t\\tskew -= amount;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tamount -= skew;\\n\\t\\t\\t\\tskew = 0;\\n\\t\\t\\t\\twhile(amount > 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint prevLine = getPrevVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tif(prevLine == -1)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tphysicalLine = prevLine;\\n\\t\\t\\t\\t\\tint screenLines = getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t\\tscrollLine -= screenLines;\\n\\t\\t\\t\\t\\tif(amount < screenLines)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tskew = screenLines - amount;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tamount -= screenLines;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void ensurePhysicalLineIsVisible()\\n\\t\\t{\\n\\t\\t\\tif(!isLineVisible(physicalLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(physicalLine > getLastVisibleLine())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysicalLine = getPrevVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tscrollLine -= getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysicalLine = getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t\\tscrollLine += getScreenLineCount(physicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\t} \\n\\t\\tclass BufferChangeHandler extends BufferChangeAdapter\\n\\t{\\n\\t\\tboolean delayedUpdate;\\n\\t\\tint delayedUpdateStart;\\n\\t\\tint delayedUpdateEnd;\\n\\t\\t\\t\\tpublic void foldHandlerChanged(Buffer buffer)\\n\\t\\t{\\n\\t\\t\\tlastfvmget = -1;\\n\\t\\t\\tfvmcount = 2;\\n\\t\\t\\tfvm[0] = 0;\\n\\t\\t\\tfvm[1] = buffer.getLineCount();\\n\\t\\t\\tfirstLine.reset();\\n\\t\\t\\tscrollLineCount.reset();\\n\\t\\t\\tint collapseFolds = buffer.getIntegerProperty(\\n\\t\\t\\t\\t\\\"collapseFolds\\\",0);\\n\\t\\t\\tif(collapseFolds != 0)\\n\\t\\t\\t\\texpandFolds(collapseFolds);\\n\\t\\t} \\n\\t\\t\\t\\tpublic void wrapModeChanged(Buffer buffer)\\n\\t\\t{\\n\\t\\t\\tfirstLine.reset();\\n\\t\\t\\tscrollLineCount.reset();\\n\\t\\t} \\n\\t\\t\\t\\tpublic void contentInserted(Buffer buffer, int startLine,\\n\\t\\t\\tint offset, int numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tdelayedUpdate(startLine,startLine + numLines);\\n\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontentInserted(firstLine,startLine,numLines);\\n\\t\\t\\t\\tcontentInserted(scrollLineCount,startLine,numLines);\\n\\t\\t\\t\\tint index = fvmget(startLine);\\n\\t\\t\\t\\tfor(int i = index + 1; i < fvmcount; i++)\\n\\t\\t\\t\\t\\tfvm[i] += numLines;\\n\\t\\t\\t}\\n\\t\\t\\tif(!buffer.isTransactionInProgress())\\n\\t\\t\\t\\ttransactionComplete(buffer);\\n\\t\\t} \\n\\t\\t\\t\\tpublic void preContentRemoved(Buffer buffer, int startLine,\\n\\t\\t\\tint offset, int numLines, int length)\\n\\t\\t{\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tdelayedUpdate(startLine,startLine);\\n\\t\\t\\tif(numLines != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tpreContentRemoved(firstLine,startLine,numLines);\\n\\t\\t\\t\\tpreContentRemoved(scrollLineCount,startLine,numLines);\\n\\t\\t\\t\\tint starti = fvmget(startLine);\\n\\t\\t\\t\\tint endi = fvmget(startLine + numLines);\\n\\t\\t\\t\\tif(Math.abs(starti % 2) == Math.abs(endi % 2))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(endi - starti == fvmcount)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfvmcount = 2;\\n\\t\\t\\t\\t\\t\\tfvm[0] = 0;\\n\\t\\t\\t\\t\\t\\tfvm[1] = buffer.getLineCount();\\n\\t\\t\\t\\t\\t\\tfirstLine.callReset = true;\\n\\t\\t\\t\\t\\t\\tscrollLineCount.callReset = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tfvmput(starti,endi,null);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfvmput(starti + 1,endi,null);\\n\\t\\t\\t\\t\\tfvm[starti + 1] = startLine;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int i = starti + 1; i < fvmcount; i++)\\n\\t\\t\\t\\t\\tfvm[i] -= numLines;\\n\\t\\t\\t}\\n\\t\\t\\tif(!buffer.isTransactionInProgress())\\n\\t\\t\\t\\ttransactionComplete(buffer);\\n\\t\\t} \\n\\t\\t\\t\\tpublic void transactionComplete(Buffer buffer)\\n\\t\\t{\\n\\t\\t\\tif(delayedUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i = delayedUpdateStart;\\n\\t\\t\\t\\t\\ti <= delayedUpdateEnd;\\n\\t\\t\\t\\t\\ti++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(isLineVisible(i))\\n\\t\\t\\t\\t\\t\\tgetScreenLineCount(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t_notifyScreenLineChanges();\\n\\t\\t\\t\\tdelayedUpdate = false;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void contentInserted(Anchor anchor, int startLine,\\n\\t\\t\\tint numLines)\\n\\t\\t{\\n\\t\\t\\tif(anchor.physicalLine >= startLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(anchor.physicalLine != startLine)\\n\\t\\t\\t\\t\\tanchor.physicalLine += numLines;\\n\\t\\t\\t\\tanchor.callChanged = true;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void preContentRemoved(Anchor anchor, int startLine,\\n\\t\\t\\tint numLines)\\n\\t\\t{\\n\\t\\t\\tif(anchor.physicalLine >= startLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(anchor.physicalLine == startLine)\\n\\t\\t\\t\\t\\tanchor.callChanged = true;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint end = Math.min(startLine + numLines,\\n\\t\\t\\t\\t\\t\\tanchor.physicalLine);\\n\\t\\t\\t\\t\\tfor(int i = startLine; i < end; i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(isLineVisible(i))\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tanchor.scrollLine -=\\n\\t\\t\\t\\t\\t\\t\\t\\toffsetMgr\\n\\t\\t\\t\\t\\t\\t\\t\\t.getScreenLineCount(i);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tanchor.physicalLine -= (end - startLine);\\n\\t\\t\\t\\t\\tanchor.callChanged = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} \\n\\t\\t\\t\\tprivate void delayedUpdate(int startLine, int endLine)\\n\\t\\t{\\n\\t\\t\\ttextArea.chunkCache.invalidateChunksFromPhys(startLine);\\n\\t\\t\\tif(!delayedUpdate)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedUpdateStart = startLine;\\n\\t\\t\\t\\tdelayedUpdateEnd = endLine;\\n\\t\\t\\t\\tdelayedUpdate = true;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelayedUpdateStart = Math.min(\\n\\t\\t\\t\\t\\tdelayedUpdateStart,\\n\\t\\t\\t\\t\\tstartLine);\\n\\t\\t\\t\\tdelayedUpdateEnd = Math.max(\\n\\t\\t\\t\\t\\tdelayedUpdateEnd,\\n\\t\\t\\t\\t\\tendLine);\\n\\t\\t\\t}\\n\\t\\t} \\t} }\""
            },
            "m15": {
                "content": "",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_e61d802348c946d0afcaa9",
                        "function": {
                            "arguments": "{\"entity\": \"ChunkCache.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m16": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package org.gjt.sp.jedit.textarea;\\nimport java.util.*;\\nimport org.gjt.sp.jedit.Buffer;\\nimport org.gjt.sp.jedit.Debug;\\nimport org.gjt.sp.jedit.syntax.*;\\nimport org.gjt.sp.util.Log;\\nclass ChunkCache\\n{\\n\\t\\tChunkCache(JEditTextArea textArea)\\n\\t{\\n\\t\\tthis.textArea = textArea;\\n\\t\\tout = new ArrayList();\\n\\t\\ttokenHandler = new DisplayTokenHandler();\\n\\t} \\n\\t\\tint getMaxHorizontalScrollWidth()\\n\\t{\\n\\t\\tint max = 0;\\n\\t\\tfor(int i = 0; i < firstInvalidLine; i++)\\n\\t\\t{\\n\\t\\t\\tLineInfo info = lineInfo[i];\\n\\t\\t\\tif(info.width > max)\\n\\t\\t\\t\\tmax = info.width;\\n\\t\\t}\\n\\t\\treturn max;\\n\\t} \\n\\t\\tint getScreenLineOfOffset(int line, int offset)\\n\\t{\\n\\t\\tif(line < textArea.getFirstPhysicalLine())\\n\\t\\t{\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\telse if(line > textArea.getLastPhysicalLine())\\n\\t\\t{\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint screenLine;\\n\\t\\t\\tif(line == lastScreenLineP)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLineInfo last = getLineInfo(lastScreenLine);\\n\\t\\t\\t\\tif(offset >= last.offset\\n\\t\\t\\t\\t\\t&& offset < last.offset + last.length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn lastScreenLine;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tscreenLine = -1;\\n\\t\\t\\t\\t\\t\\tfor(int i = 0; i < textArea.getVisibleLines(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tLineInfo info = getLineInfo(i);\\n\\t\\t\\t\\tif(info.physicalLine > line)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tscreenLine = i - 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(info.physicalLine == line)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(offset >= info.offset\\n\\t\\t\\t\\t\\t\\t&& offset < info.offset + info.length)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tscreenLine = i;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(screenLine == -1)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tlastScreenLineP = line;\\n\\t\\t\\t\\tlastScreenLine = screenLine;\\n\\t\\t\\t\\treturn screenLine;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tvoid recalculateVisibleLines()\\n\\t{\\n\\t\\tLineInfo[] newLineInfo = new LineInfo[textArea.getVisibleLines()];\\n\\t\\tint start;\\n\\t\\tif(lineInfo == null)\\n\\t\\t\\tstart = 0;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstart = Math.min(lineInfo.length,newLineInfo.length);\\n\\t\\t\\tSystem.arraycopy(lineInfo,0,newLineInfo,0,start);\\n\\t\\t}\\n\\t\\tfor(int i = start; i < newLineInfo.length; i++)\\n\\t\\t\\tnewLineInfo[i] = new LineInfo();\\n\\t\\tlineInfo = newLineInfo;\\n\\t\\tlastScreenLine = lastScreenLineP = -1;\\n\\t} \\n\\t\\tvoid setBuffer(Buffer buffer)\\n\\t{\\n\\t\\tthis.buffer = buffer;\\n\\t\\tlastScreenLine = lastScreenLineP = -1;\\n\\t} \\n\\t\\tvoid scrollDown(int amount)\\n\\t{\\n\\t\\tint visibleLines = textArea.getVisibleLines();\\n\\t\\tSystem.arraycopy(lineInfo,amount,lineInfo,0,visibleLines - amount);\\n\\t\\tfor(int i = visibleLines - amount; i < visibleLines; i++)\\n\\t\\t{\\n\\t\\t\\tlineInfo[i] = new LineInfo();\\n\\t\\t}\\n\\t\\tfirstInvalidLine -= amount;\\n\\t\\tif(firstInvalidLine < 0)\\n\\t\\t\\tfirstInvalidLine = 0;\\n\\t\\tif(Debug.CHUNK_CACHE_DEBUG)\\n\\t\\t{\\n\\t\\t\\tSystem.err.println(\\\"f > t.f: only \\\" + amount\\n\\t\\t\\t\\t+ \\\" need updates\\\");\\n\\t\\t}\\n\\t\\tlastScreenLine = lastScreenLineP = -1;\\n\\t} \\n\\t\\tvoid scrollUp(int amount)\\n\\t{\\n\\t\\tSystem.arraycopy(lineInfo,0,lineInfo,amount,\\n\\t\\t\\ttextArea.getVisibleLines() - amount);\\n\\t\\tfor(int i = 0; i < amount; i++)\\n\\t\\t{\\n\\t\\t\\tlineInfo[i] = new LineInfo();\\n\\t\\t}\\n\\t\\t\\t\\tint oldFirstInvalidLine = firstInvalidLine;\\n\\t\\tfirstInvalidLine = 0;\\n\\t\\tupdateChunksUpTo(amount);\\n\\t\\tfirstInvalidLine = oldFirstInvalidLine + amount;\\n\\t\\tif(firstInvalidLine > textArea.getVisibleLines())\\n\\t\\t\\tfirstInvalidLine = textArea.getVisibleLines();\\n\\t\\tif(Debug.CHUNK_CACHE_DEBUG)\\n\\t\\t{\\n\\t\\t\\tSystem.err.println(\\\"f > t.f: only \\\" + amount\\n\\t\\t\\t\\t+ \\\" need updates\\\");\\n\\t\\t}\\n\\t\\tlastScreenLine = lastScreenLineP = -1;\\n\\t} \\n\\t\\tvoid invalidateAll()\\n\\t{\\n\\t\\tfirstInvalidLine = 0;\\n\\t\\tlastScreenLine = lastScreenLineP = -1;\\n\\t} \\n\\t\\tvoid invalidateChunksFrom(int screenLine)\\n\\t{\\n\\t\\tfirstInvalidLine = Math.min(screenLine,firstInvalidLine);\\n\\t\\tif(screenLine <= lastScreenLine)\\n\\t\\t\\tlastScreenLine = lastScreenLineP = -1;\\n\\t} \\n\\t\\tvoid invalidateChunksFromPhys(int physicalLine)\\n\\t{\\n\\t\\tfor(int i = 0; i < firstInvalidLine; i++)\\n\\t\\t{\\n\\t\\t\\tLineInfo info = lineInfo[i];\\n\\t\\t\\tif(info.physicalLine == -1 || info.physicalLine >= physicalLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstInvalidLine = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tLineInfo getLineInfo(int screenLine)\\n\\t{\\n\\t\\tupdateChunksUpTo(screenLine);\\n\\t\\treturn lineInfo[screenLine];\\n\\t} \\n\\t\\tint getLineSubregionCount(int physicalLine)\\n\\t{\\n\\t\\tout.clear();\\n\\t\\tlineToChunkList(physicalLine,out);\\n\\t\\tint size = out.size();\\n\\t\\tif(size == 0)\\n\\t\\t\\treturn 1;\\n\\t\\telse\\n\\t\\t\\treturn size;\\n\\t} \\n\\tint getSubregionOfOffset(int offset, LineInfo[] lineInfos)\\n\\t{\\n\\t\\tfor(int i = 0; i < lineInfos.length; i++)\\n\\t\\t{\\n\\t\\t\\tLineInfo info = lineInfos[i];\\n\\t\\t\\tif(offset >= info.offset && offset < info.offset + info.length)\\n\\t\\t\\t\\treturn i;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t} \\n\\tint xToSubregionOffset(int physicalLine, int subregion, int x,\\n\\t\\tboolean round)\\n\\t{\\n\\t\\tLineInfo[] infos = getLineInfosForPhysicalLine(physicalLine);\\n\\t\\tif(subregion == -1)\\n\\t\\t\\tsubregion += infos.length;\\n\\t\\treturn xToSubregionOffset(infos[subregion],x,round);\\n\\t} \\n\\tint xToSubregionOffset(LineInfo info, int x,\\n\\t\\tboolean round)\\n\\t{\\n\\t\\tint offset = Chunk.xToOffset(info.chunks,\\n\\t\\t\\tx - textArea.getHorizontalOffset(),round);\\n\\t\\tif(offset == -1 || offset == info.offset + info.length)\\n\\t\\t\\toffset = info.offset + info.length - 1;\\n\\t\\treturn offset;\\n\\t} \\n\\tint subregionOffsetToX(int physicalLine, int offset)\\n\\t{\\n\\t\\tLineInfo[] infos = getLineInfosForPhysicalLine(physicalLine);\\n\\t\\tLineInfo info = infos[getSubregionOfOffset(offset,infos)];\\n\\t\\treturn subregionOffsetToX(info,offset);\\n\\t} \\n\\tint subregionOffsetToX(LineInfo info, int offset)\\n\\t{\\n\\t\\treturn (int)(textArea.getHorizontalOffset() + Chunk.offsetToX(\\n\\t\\t\\tinfo.chunks,offset));\\n\\t} \\n\\tint getSubregionStartOffset(int line, int offset)\\n\\t{\\n\\t\\tLineInfo[] lineInfos = getLineInfosForPhysicalLine(line);\\n\\t\\tLineInfo info = lineInfos[getSubregionOfOffset(offset,lineInfos)];\\n\\t\\treturn textArea.getLineStartOffset(info.physicalLine)\\n\\t\\t\\t+ info.offset;\\n\\t} \\n\\tint getSubregionEndOffset(int line, int offset)\\n\\t{\\n\\t\\tLineInfo[] lineInfos = getLineInfosForPhysicalLine(line);\\n\\t\\tLineInfo info = lineInfos[getSubregionOfOffset(offset,lineInfos)];\\n\\t\\treturn textArea.getLineStartOffset(info.physicalLine)\\n\\t\\t\\t+ info.offset + info.length;\\n\\t} \\n\\tint getBelowPosition(int physicalLine, int offset, int x,\\n\\t\\tboolean ignoreWrap)\\n\\t{\\n\\t\\tLineInfo[] lineInfos = getLineInfosForPhysicalLine(physicalLine);\\n\\t\\tint subregion = getSubregionOfOffset(offset,lineInfos);\\n\\t\\tif(subregion != lineInfos.length - 1 && !ignoreWrap)\\n\\t\\t{\\n\\t\\t\\treturn textArea.getLineStartOffset(physicalLine)\\n\\t\\t\\t\\t+ xToSubregionOffset(lineInfos[subregion + 1],\\n\\t\\t\\t\\tx,true);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint nextLine = textArea.displayManager\\n\\t\\t\\t\\t.getNextVisibleLine(physicalLine);\\n\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn textArea.getLineStartOffset(nextLine)\\n\\t\\t\\t\\t\\t+ xToSubregionOffset(nextLine,0,\\n\\t\\t\\t\\t\\tx,true);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tint getAbovePosition(int physicalLine, int offset, int x,\\n\\t\\tboolean ignoreWrap)\\n\\t{\\n\\t\\tLineInfo[] lineInfos = getLineInfosForPhysicalLine(physicalLine);\\n\\t\\tint subregion = getSubregionOfOffset(offset,lineInfos);\\n\\t\\tif(subregion != 0 && !ignoreWrap)\\n\\t\\t{\\n\\t\\t\\treturn textArea.getLineStartOffset(physicalLine)\\n\\t\\t\\t\\t+ xToSubregionOffset(lineInfos[subregion - 1],\\n\\t\\t\\t\\tx,true);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint prevLine = textArea.displayManager\\n\\t\\t\\t\\t.getPrevVisibleLine(physicalLine);\\n\\t\\t\\tif(prevLine == -1)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn textArea.getLineStartOffset(prevLine)\\n\\t\\t\\t\\t\\t+ xToSubregionOffset(prevLine,-1,\\n\\t\\t\\t\\t\\tx,true);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tboolean needFullRepaint()\\n\\t{\\n\\t\\tboolean retVal = needFullRepaint;\\n\\t\\tneedFullRepaint = false;\\n\\t\\treturn retVal;\\n\\t} \\n\\t\\tLineInfo[] getLineInfosForPhysicalLine(int physicalLine)\\n\\t{\\n\\t\\tout.clear();\\n\\t\\tlineToChunkList(physicalLine,out);\\n\\t\\tif(out.size() == 0)\\n\\t\\t\\tout.add(null);\\n\\t\\tArrayList returnValue = new ArrayList(out.size());\\n\\t\\tgetLineInfosForPhysicalLine(physicalLine,returnValue);\\n\\t\\treturn (LineInfo[])returnValue.toArray(new LineInfo[out.size()]);\\n\\t} \\n\\t\\tprivate JEditTextArea textArea;\\n\\tprivate Buffer buffer;\\n\\tprivate LineInfo[] lineInfo;\\n\\tprivate ArrayList out;\\n\\tprivate int firstInvalidLine;\\n\\tprivate int lastScreenLineP;\\n\\tprivate int lastScreenLine;\\n\\tprivate boolean needFullRepaint;\\n\\tprivate DisplayTokenHandler tokenHandler;\\n\\t\\tprivate void getLineInfosForPhysicalLine(int physicalLine, List list)\\n\\t{\\n\\t\\tfor(int i = 0; i < out.size(); i++)\\n\\t\\t{\\n\\t\\t\\tChunk chunks = (Chunk)out.get(i);\\n\\t\\t\\tLineInfo info = new LineInfo();\\n\\t\\t\\tinfo.physicalLine = physicalLine;\\n\\t\\t\\tif(i == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tinfo.firstSubregion = true;\\n\\t\\t\\t\\tinfo.offset = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tinfo.offset = chunks.offset;\\n\\t\\t\\tif(i == out.size() - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tinfo.lastSubregion = true;\\n\\t\\t\\t\\tinfo.length = textArea.getLineLength(physicalLine)\\n\\t\\t\\t\\t\\t- info.offset + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tinfo.length = ((Chunk)out.get(i + 1)).offset\\n\\t\\t\\t\\t\\t- info.offset;\\n\\t\\t\\t}\\n\\t\\t\\tinfo.chunks = chunks;\\n\\t\\t\\tlist.add(info);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void updateChunksUpTo(int lastScreenLine)\\n\\t{\\n\\t\\tif(lastScreenLine >= lineInfo.length)\\n\\t\\t{\\n\\t\\t\\tthrow new ArrayIndexOutOfBoundsException(lastScreenLine);\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(lastScreenLine < firstInvalidLine)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\tint firstScreenLine = 0;\\n\\t\\tfor(int i = firstInvalidLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(lineInfo[i].lastSubregion)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstScreenLine = i + 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint physicalLine;\\n\\t\\t\\t\\t\\t\\tif(firstScreenLine == 0)\\n\\t\\t{\\n\\t\\t\\tphysicalLine = textArea.getFirstPhysicalLine();\\n\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint prevPhysLine = lineInfo[\\n\\t\\t\\t\\tfirstScreenLine - 1]\\n\\t\\t\\t\\t.physicalLine;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(prevPhysLine == -1)\\n\\t\\t\\t\\tphysicalLine = -1;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tphysicalLine = textArea\\n\\t\\t\\t\\t\\t.displayManager\\n\\t\\t\\t\\t\\t.getNextVisibleLine(prevPhysLine);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(Debug.CHUNK_CACHE_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"Updating chunks from \\\" + firstScreenLine\\n\\t\\t\\t\\t+ \\\" to \\\" + lastScreenLine);\\n\\t\\t}\\n\\t\\tout.clear();\\n\\t\\tint offset = 0;\\n\\t\\tint length = 0;\\n\\t\\tfor(int i = firstScreenLine; i <= lastScreenLine; i++)\\n\\t\\t{\\n\\t\\t\\tLineInfo info = lineInfo[i];\\n\\t\\t\\tChunk chunks;\\n\\t\\t\\t\\t\\t\\tif(out.size() == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(physicalLine != -1 && i != firstScreenLine)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tphysicalLine = textArea.displayManager\\n\\t\\t\\t\\t\\t\\t.getNextVisibleLine(physicalLine);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\tif(physicalLine == -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tinfo.chunks = null;\\n\\t\\t\\t\\t\\tinfo.physicalLine = -1;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\tlineToChunkList(physicalLine,out);\\n\\t\\t\\t\\tinfo.firstSubregion = true;\\n\\t\\t\\t\\t\\t\\t\\t\\tif(out.size() == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttextArea.getDisplayManager()\\n\\t\\t\\t\\t\\t\\t.setScreenLineCount(\\n\\t\\t\\t\\t\\t\\tphysicalLine,1);\\n\\t\\t\\t\\t\\tif(i == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(textArea.displayManager.firstLine.skew > 0)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"BUG: skew=\\\" + textArea.displayManager.firstLine.skew + \\\",out.size()=\\\" + out.size());\\n\\t\\t\\t\\t\\t\\t\\ttextArea.displayManager.firstLine.skew = 0;\\n\\t\\t\\t\\t\\t\\t\\tneedFullRepaint = true;\\n\\t\\t\\t\\t\\t\\t\\tlastScreenLine = lineInfo.length - 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tchunks = null;\\n\\t\\t\\t\\t\\toffset = 0;\\n\\t\\t\\t\\t\\tlength = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttextArea.getDisplayManager()\\n\\t\\t\\t\\t\\t\\t.setScreenLineCount(\\n\\t\\t\\t\\t\\t\\tphysicalLine,out.size());\\n\\t\\t\\t\\t\\tif(i == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint skew = textArea.displayManager.firstLine.skew;\\n\\t\\t\\t\\t\\t\\tif(skew >= out.size())\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,\\\"BUG: skew=\\\" + skew + \\\",out.size()=\\\" + out.size());\\n\\t\\t\\t\\t\\t\\t\\tskew = 0;\\n\\t\\t\\t\\t\\t\\t\\tneedFullRepaint = true;\\n\\t\\t\\t\\t\\t\\t\\tlastScreenLine = lineInfo.length - 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if(skew > 0)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tinfo.firstSubregion = false;\\n\\t\\t\\t\\t\\t\\t\\tfor(int j = 0; j < skew; j++)\\n\\t\\t\\t\\t\\t\\t\\t\\tout.remove(0);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tchunks = (Chunk)out.get(0);\\n\\t\\t\\t\\t\\tout.remove(0);\\n\\t\\t\\t\\t\\toffset = chunks.offset;\\n\\t\\t\\t\\t\\tif(out.size() != 0)\\n\\t\\t\\t\\t\\t\\tlength = ((Chunk)out.get(0)).offset - offset;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tlength = textArea.getLineLength(physicalLine) - offset + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tinfo.firstSubregion = false;\\n\\t\\t\\t\\tchunks = (Chunk)out.get(0);\\n\\t\\t\\t\\tout.remove(0);\\n\\t\\t\\t\\toffset = chunks.offset;\\n\\t\\t\\t\\tif(out.size() != 0)\\n\\t\\t\\t\\t\\tlength = ((Chunk)out.get(0)).offset - offset;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tlength = textArea.getLineLength(physicalLine) - offset + 1;\\n\\t\\t\\t}\\n\\t\\t\\tboolean lastSubregion = (out.size() == 0);\\n\\t\\t\\tif(i == lastScreenLine\\n\\t\\t\\t\\t&& lastScreenLine != lineInfo.length - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(info.physicalLine != physicalLine\\n\\t\\t\\t\\t\\t|| info.lastSubregion != lastSubregion)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastScreenLine++;\\n\\t\\t\\t\\t\\tneedFullRepaint = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(out.size() != 0)\\n\\t\\t\\t\\t\\tlastScreenLine++;\\n\\t\\t\\t}\\n\\t\\t\\tinfo.physicalLine = physicalLine;\\n\\t\\t\\tinfo.lastSubregion = lastSubregion;\\n\\t\\t\\tinfo.offset = offset;\\n\\t\\t\\tinfo.length = length;\\n\\t\\t\\tinfo.chunks = chunks;\\n\\t\\t}\\n\\t\\tfirstInvalidLine = Math.max(lastScreenLine + 1,firstInvalidLine);\\n\\t} \\n\\t\\tprivate void lineToChunkList(int physicalLine, List out)\\n\\t{\\n\\t\\tTextAreaPainter painter = textArea.getPainter();\\n\\t\\tbuffer.getLineText(physicalLine,textArea.lineSegment);\\n\\t\\ttokenHandler.init(textArea.lineSegment,painter.getStyles(),\\n\\t\\t\\tpainter.getFontRenderContext(),\\n\\t\\t\\tpainter,out,\\n\\t\\t\\t(textArea.getDisplayManager().softWrap\\n\\t\\t\\t? textArea.getDisplayManager().wrapMargin : 0.0f));\\n\\t\\tbuffer.markTokens(physicalLine,tokenHandler);\\n\\t} \\n\\t\\tstatic class LineInfo\\n\\t{\\n\\t\\tint physicalLine;\\n\\t\\tint offset;\\n\\t\\tint length;\\n\\t\\tboolean firstSubregion;\\n\\t\\tboolean lastSubregion;\\n\\t\\tChunk chunks;\\n\\t\\tint width;\\n\\t} }\""
            },
            "m17": {
                "role": "user",
                "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
            },
            "m18": {
                "content": "Title: Diagnosis of starting entity `DisplayManager`\n\nChange set: [ChunkCache, BufferChangeHandler, ScrollLineCount, FirstLine, HelpIndex, HelpTOCPanel, View, BufferIORequest, RingListModel, OffsetManager, PosBottomHalf, PositionManager, PasteFromListDialog, ListHandler, KeyHandler, FontSelector, FontSelectorDialog, TextAreaOptionPane, ActionHandler, JEditTextArea, TextAreaPainter, EditPane, BeanShell]\n\nDetails:\n- **ChunkCache**: Strong semantic coupling (0.868545) with DisplayManager; responsible for caching line display chunks which are directly used by DisplayManager.\n- **BufferChangeHandler**: High co-change confidence (0.5625); though removed in later versions, historical data shows it was tightly coupled with DisplayManager for handling buffer changes.\n- **ScrollLineCount**: DisplayManager instantiates and manages ScrollLineCount to keep track of scroll line count.\n- **FirstLine**: DisplayManager uses FirstLine to manage the first visible line information.\n- **HelpIndex, HelpTOCPanel, View**: Moderate co-change relationships; historically modified together, possibly due to UI or event propagation logic tied to display settings.\n- **BufferIORequest, RingListModel, OffsetManager, PosBottomHalf, PositionManager**: Lower confidence but still relevant co-change history; potentially involved in managing line visibility, offsets, or scrolling states.\n- **PasteFromListDialog, ListHandler, KeyHandler, FontSelector, FontSelectorDialog, TextAreaOptionPane, ActionHandler**: These entities have moderate historical co-change frequency, likely related to user interface configuration or input actions managed by DisplayManager.\n- **JEditTextArea, TextAreaPainter, EditPane, BeanShell**: Related to the broader text area management system; DisplayManager interacts with these components for rendering and editing behavior.\n- **MouseHandler, Anchor, RangeMap**: Low confidence co-changes; may be included for recall completeness, though their relevance is diminished due to removal or refactoring.\n\nThese entities were selected based on co-change history, conceptual coupling results, and analysis of code dependencies between DisplayManager and other components in the jEdit system.",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            }
        }
    }
}