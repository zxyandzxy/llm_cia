{
    "time": 1749615699.9551363,
    "messages": [
        {
            "role": "system",
            "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
        },
        {
            "role": "user",
            "content": "The project you need to analyze is `Makagiga`, a well-known Java open source project. The starting entity you need to deal with is FeedsFS.java."
        },
        {
            "content": "",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_c08448592c7e470d93274b",
                    "function": {
                        "arguments": "{\"entity\": \"FeedsFS.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package org.makagiga.fs.feeds;\\nimport static org.makagiga.commons.UI.i18n;\\nimport java.awt.Color;\\nimport java.awt.Image;\\nimport java.awt.Window;\\nimport java.io.File;\\nimport java.io.IOException;\\nimport java.net.URL;\\nimport java.nio.file.Files;\\nimport java.nio.file.Path;\\nimport java.nio.file.Paths;\\nimport java.security.AccessControlContext;\\nimport java.security.AccessController;\\nimport java.util.Comparator;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.Objects;\\nimport java.util.StringJoiner;\\nimport java.util.TreeSet;\\nimport java.util.concurrent.TimeUnit;\\nimport java.util.stream.Collectors;\\nimport java.util.stream.Stream;\\nimport javax.swing.Action;\\nimport javax.swing.Icon;\\nimport org.makagiga.MainWindow;\\nimport org.makagiga.Tabs;\\nimport org.makagiga.Vars;\\nimport org.makagiga.commons.Config;\\nimport org.makagiga.commons.FS;\\nimport org.makagiga.commons.Flags;\\nimport org.makagiga.commons.MAction;\\nimport org.makagiga.commons.MActionInfo;\\nimport org.makagiga.commons.MApplication;\\nimport org.makagiga.commons.MColor;\\nimport org.makagiga.commons.MDataAction;\\nimport org.makagiga.commons.MFormat;\\nimport org.makagiga.commons.MIcon;\\nimport org.makagiga.commons.MLogger;\\nimport org.makagiga.commons.TK;\\nimport org.makagiga.commons.Tuple;\\nimport org.makagiga.commons.UI;\\nimport org.makagiga.commons.cache.FileCache;\\nimport org.makagiga.commons.html.HTMLBuilder;\\nimport org.makagiga.commons.mv.MV;\\nimport org.makagiga.commons.swing.MButton;\\nimport org.makagiga.commons.swing.MCheckBox;\\nimport org.makagiga.commons.swing.MCheckBoxTable;\\nimport org.makagiga.commons.swing.MDialog;\\nimport org.makagiga.commons.swing.MFileChooser;\\nimport org.makagiga.commons.swing.MMenu;\\nimport org.makagiga.commons.swing.MMessage;\\nimport org.makagiga.commons.swing.MNotification;\\nimport org.makagiga.commons.swing.MPanel;\\nimport org.makagiga.commons.swing.MRadioButton;\\nimport org.makagiga.commons.swing.MSlider;\\nimport org.makagiga.commons.swing.MSmallButton;\\nimport org.makagiga.commons.swing.MStatusBar;\\nimport org.makagiga.commons.swing.MTabbedPane;\\nimport org.makagiga.commons.swing.MTimer;\\nimport org.makagiga.commons.swing.MToolBar;\\nimport org.makagiga.editors.Editor;\\nimport org.makagiga.feeds.archive.Archive;\\nimport org.makagiga.feeds.archive.ArchiveException;\\nimport org.makagiga.feeds.opml.OPMLReader;\\nimport org.makagiga.feeds.opml.OPMLWriter;\\nimport org.makagiga.fs.AbstractFS;\\nimport org.makagiga.fs.FSDynamic;\\nimport org.makagiga.fs.FSException;\\nimport org.makagiga.fs.FSHelper;\\nimport org.makagiga.fs.FSNewFile;\\nimport org.makagiga.fs.FSNewFolder;\\nimport org.makagiga.fs.FSOpen;\\nimport org.makagiga.fs.FSProperties;\\nimport org.makagiga.fs.FSQuery;\\nimport org.makagiga.fs.MetaInfo;\\nimport org.makagiga.plugins.PluginInfo;\\nimport org.makagiga.plugins.PluginMenu;\\nimport org.makagiga.plugins.PluginSettings;\\nimport org.makagiga.search.Query;\\nimport org.makagiga.tree.ItemRenderer;\\nimport org.makagiga.tree.Tree;\\nimport org.makagiga.web.Favicon;\\npublic final class FeedsFS extends AbstractFS\\nimplements\\n\\tFSDynamic,\\n\\tFSNewFile,\\n\\tFSNewFolder,\\n\\tFSOpen,\\n\\tFSProperties,\\n\\tFSQuery,\\n\\tPluginMenu\\n{\\n\\tpublic static final int USE_EXCLUDE_FROM_FETCH_ALL_FEEDS = 1;\\n\\tpublic static final int USE_EXCLUDE_FROM_INTERVAL_FETCH = 1 << 1;\\n\\tpublic static final int FETCH_OFFLINE = 1 << 2;\\n\\tprivate ArchiveOptions archiveOptions;\\n\\tprivate Color unreadColor = DEFAULT_UNREAD_COLOR;\\n\\tprivate CustomAdvancedPanel customAdvancedPanel;\\n\\tprivate MAction filtersAction;\\n\\tprivate MAction markAllAsReadAction;\\n\\tprivate static final MLogger log = MLogger.get(\\\"feeds\\\");\\n\\tprivate MetaInfo currentImportFolder;\\n\\tprivate final MTimer intervalFetchTimer;\\n\\tfinal AccessControlContext acc;\\n\\tstatic final Color DEFAULT_UNREAD_COLOR = new UnreadColor(0xb1d28f);\\n\\tFetchAllFeedsAction fetchAllFeedsAction = new FetchAllFeedsAction();\\n\\t@Override\\n\\tpublic boolean canImport(final MetaInfo metaInfo) {\\n\\t\\tif (!super.canImport(metaInfo))\\n\\t\\t\\treturn false;\\n\\t\\treturn metaInfo.isAnyFolder();\\n\\t}\\n\\t@Override\\n\\tpublic void deleteNotify(final MetaInfo metaInfo, final boolean move) {\\n\\t\\tif (!move && metaInfo.isDynamicFolder()) {\\n\\t\\t\\tConfig config = metaInfo.getConfig();\\n\\t\\t\\tString url = config.read(\\\"x.url\\\", null);\\n\\t\\t\\tif (url != null) {\\n\\t\\t\\t\\tFeedDownloader.abort(metaInfo);\\n\\t\\t\\t\\tFileCache cache = FileCache.getInstance();\\n\\t\\t\\t\\tcache.getGroup(\\\"feed\\\").remove(url);\\n\\t\\t\\t\\t\\t\\t\\t\\tif (!MNotification.isEmpty()) {\\n\\t\\t\\t\\t\\tfor (MNotification.Message i : MNotification.getInstance()) {\\n\\t\\t\\t\\t\\t\\tAction action = i.getAction();\\n\\t\\t\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\t\\t\\t(action instanceof FeedThread.Action) &&\\n\\t\\t\\t\\t\\t\\t\\t(FeedThread.Action.class.cast(action).getParent() == metaInfo)\\n\\t\\t\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\t\\t\\ti.hide();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tpublic void fetchFeeds(final int flags) {\\n\\t\\tfetchFeeds(getRoot(), flags);\\n\\t}\\n\\tpublic void fetchFeeds(final MetaInfo folder, final int flags) {\\n\\t\\tif (FeedDownloader.isActive())\\n\\t\\t\\treturn;\\n\\t\\tnew Tree.Scanner(folder) {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic void processItem(final MetaInfo item) {\\n\\t\\t\\t\\tdownload(item, false, flags);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\t\\tif (FeedDownloader.isActive()) {\\n\\t\\t\\tboolean fetchOffline = (flags & FETCH_OFFLINE) != 0;\\n\\t\\t\\tFeedDownloader.setFetchMode(this, false, fetchOffline);\\n\\t\\t}\\n\\t}\\n\\tpublic Color getUnreadColor() {\\n\\t\\treturn TK.get(unreadColor, DEFAULT_UNREAD_COLOR);\\n\\t}\\n\\tpublic void setUnreadColor(final Color value) {\\n\\t\\tunreadColor = (value == null) ? null : new UnreadColor(value);\\n\\t}\\n\\t@Override\\n\\tpublic void setupItemRenderer(final ItemRenderer renderer, final MetaInfo item) {\\n\\t\\tif (item instanceof ArticleMetaInfo) {\\n\\t\\t\\tArticleMetaInfo article = (ArticleMetaInfo)item;\\n\\t\\t\\titem.setColor(getColor(article));\\n\\t\\t}\\n\\t\\telse if (item.isDynamicFolder()) {\\n\\t\\t\\tif (Boolean.TRUE.equals(item.getProperty(\\\"feed.no-favicon\\\", false))) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tMIcon icon = Vars.treeSmallIcons.get() ? item.getSmallIcon() : item.getIcon();\\n\\t\\t\\tif (icon == null)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\tif (icon.getOverlay() != null)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tImage favicon = item.getProperty(\\\"feed.favicon\\\", null);\\n\\t\\t\\tif (favicon == null) {\\n\\t\\t\\t\\tString url = item.getConfig().read(\\\"x.faviconURL\\\", \\\"\\\");\\n\\t\\t\\t\\tif (url.isEmpty()) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\titem.setProperty(\\\"feed.no-favicon\\\", true);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfavicon = Favicon.getCachedImage(new URL(url), 16);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch (IOException exception) {\\n\\t\\t\\t\\t\\tMLogger.developerException(exception);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (favicon == null) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\titem.setProperty(\\\"feed.no-favicon\\\", true);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\titem.setProperty(\\\"feed.favicon\\\", favicon);\\n\\t\\t\\t}\\n\\t\\t\\ticon.setOverlay(favicon);\\n\\t\\t}\\n\\t}\\n\\t@Override\\n\\tpublic void applyProperties(final MetaInfo[] selection) {\\n\\t\\tif (selection.length > 1)\\n\\t\\t\\treturn;\\n\\t\\tMetaInfo metaInfo = selection[0];\\n\\t\\tif (!metaInfo.isDynamicFolder() || !(metaInfo.getFS() instanceof FeedsFS))\\n\\t\\t\\treturn;\\n\\t\\t\\t\\tConfig config = metaInfo.getConfig();\\n\\t\\tconfig.write(\\\"x.archivePolicy\\\", archiveOptions.getPolicy().name());\\n\\t\\tconfig.write(\\\"x.blockImages\\\", customAdvancedPanel.blockImagesCheckBox.isSelected());\\n\\t\\tconfig.write(\\\"x.excludeFromFetchAllFeeds\\\", customAdvancedPanel.excludeFromFetchAllFeeds.isSelected());\\n\\t\\tconfig.write(\\\"x.excludeFromIntervalFetch\\\", customAdvancedPanel.excludeFromIntervalFetch.isSelected());\\n\\t\\tconfig.write(\\\"x.removeArticlesAfter\\\", archiveOptions.getDays());\\n\\t\\tconfig.write(\\\"x.showFullPage\\\", customAdvancedPanel.showFullPageCheckBox.isSelected());\\n\\t\\t\\t\\tif (customAdvancedPanel.shouldRefresh())\\n\\t\\t\\trefresh(metaInfo);\\n\\t}\\n\\t@Override\\n\\tpublic void freeProperties() {\\n\\t\\tarchiveOptions = null;\\n\\t\\tcustomAdvancedPanel = null;\\n\\t}\\n\\t@Override\\n\\tpublic Flags getMetaInfoCapabilities(final MetaInfo metaInfo) {\\n\\t\\treturn Flags.valueOf(META_INFO_CATEGORY | META_INFO_COLOR | META_INFO_COMMENT | META_INFO_ICON | META_INFO_RATING | META_INFO_TAGS);\\n\\t}\\n\\t@Override\\n\\tpublic void initProperties(final MTabbedPane<MPanel> tabs, final MetaInfo[] selection) {\\n\\t\\tif (selection.length > 1)\\n\\t\\t\\treturn;\\n\\t\\tfinal MetaInfo metaInfo = selection[0];\\n\\t\\tif (!metaInfo.isDynamicFolder() || !(metaInfo.getFS() instanceof FeedsFS))\\n\\t\\t\\treturn;\\n\\t\\tfinal Config config = metaInfo.getConfig();\\n\\t\\tMPanel advancedTab = tabs.getTabAt(ADVANCED_TAB);\\n\\t\\ttabs.setEnabledAt(ADVANCED_TAB, true);\\n\\t\\ttabs.setIconAt(ADVANCED_TAB, getSmallIcon());\\n\\t\\ttabs.setTitleAt(ADVANCED_TAB, i18n(\\\"RSS Feed\\\"));\\n\\t\\tarchiveOptions = new ArchiveOptions(false);\\n\\t\\tFeedsFSPlugin plugin = getFeedsFSPlugin();\\n\\t\\tFeedsFSPlugin.Settings settings = plugin.readSettings(metaInfo, false);\\n\\t\\tarchiveOptions.setDays(settings.removeArticlesAfter, settings.archivePolicy);\\n\\t\\tadvancedTab.add(archiveOptions);\\n\\t\\tcustomAdvancedPanel = new CustomAdvancedPanel();\\n\\t\\tcustomAdvancedPanel.showExpiredArticlesAgainButton.addActionListener(e -> {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tcustomAdvancedPanel.showExpiredArticlesAgainButton.setEnabled(false);\\n\\t\\t\\t\\tcustomAdvancedPanel.showExpiredArticlesAgainButton.setIcon(MIcon.small(\\\"ui/ok\\\"));\\n\\t\\t\\t\\tString url = config.read(\\\"x.url\\\", null);\\n\\t\\t\\t\\tArchive.getInstance().removeExpiredInfo(url);\\n\\t\\t\\t}\\n\\t\\t\\tcatch (ArchiveException exception) {\\n\\t\\t\\t\\tMLogger.developerException(exception);\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t\\tcustomAdvancedPanel.blockImagesCheckBox.setAndRemember(config.read(\\\"x.blockImages\\\", false));\\n\\t\\tcustomAdvancedPanel.excludeFromFetchAllFeeds.setSelected(config.read(\\\"x.excludeFromFetchAllFeeds\\\", false));\\n\\t\\tcustomAdvancedPanel.excludeFromIntervalFetch.setSelected(config.read(\\\"x.excludeFromIntervalFetch\\\", false));\\n\\t\\tcustomAdvancedPanel.showFullPageCheckBox.setSelected(config.read(\\\"x.showFullPage\\\", false));\\n\\t\\tadvancedTab.add(customAdvancedPanel);\\n\\t}\\n\\t@Override\\n\\tpublic void lockProperties(final boolean locked) {\\n\\t\\tif (archiveOptions != null) {\\n\\t\\t\\tarchiveOptions.days.setEnabled(!locked);\\n\\t\\t\\tarchiveOptions.doNotRemoveArticles.setEnabled(!locked);\\n\\t\\t\\tarchiveOptions.removeArticles.setEnabled(!locked);\\n\\t\\t\\tarchiveOptions.useGlobalSettings.setEnabled(!locked);\\n\\t\\t}\\n\\t\\tif (customAdvancedPanel != null) {\\n\\t\\t\\tcustomAdvancedPanel.blockImagesCheckBox.setEnabled(!locked);\\n\\t\\t\\tcustomAdvancedPanel.excludeFromFetchAllFeeds.setEnabled(!locked);\\n\\t\\t\\tcustomAdvancedPanel.excludeFromIntervalFetch.setEnabled(!locked);\\n\\t\\t\\tcustomAdvancedPanel.showFullPageCheckBox.setEnabled(!locked);\\n\\t\\t}\\n\\t}\\n\\t@Override\\n\\tpublic Icon getNewFileActionIcon(final MIcon.Size size) {\\n\\t\\treturn MIcon.stock(\\\"ui/feed\\\", size);\\n\\t}\\n\\t@Override\\n\\tpublic String getNewFileActionText() {\\n\\t\\treturn i18n(\\\"Add RSS Feed\\\");\\n\\t}\\n\\t@Override\\n\\tpublic String getNewFileDefaultName() {\\n\\t\\treturn i18n(\\\"New RSS Feed\\\");\\n\\t}\\n\\t@Override\\n\\tpublic MetaInfo newFile(final Window owner, final MetaInfo parent) throws FSException {\\n\\t\\treturn newFile(parent, null);\\n\\t}\\n\\t@Override\\n\\tpublic Action getNewFileAction() {\\n\\t\\treturn new MAction(getNewFileActionText(), \\\"ui/feed\\\", action -> {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tnewFile(action.getSourceWindow(), getRoot());\\n\\t\\t\\t}\\n\\t\\t\\tcatch (FSException exception) {\\n\\t\\t\\t\\taction.showErrorMessage(exception);\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t}\\n\\t@Override\\n\\tpublic int getNewFileOptions() {\\n\\t\\treturn NEW_FILE_OPTION_SHOW_IN_MENU;\\n\\t}\\n\\tpublic MetaInfo newFile(final MetaInfo parent, final String link) throws FSException {\\n\\t\\tMainWindow mainWindow = MainWindow.getInstance();\\n\\t\\tAddFeedDialog addFeedDialog = new AddFeedDialog(\\n\\t\\t\\tmainWindow.isActive() ? mainWindow : null,\\n\\t\\t\\tlink,\\n\\t\\t\\tthis\\n\\t\\t);\\n\\t\\tif (!addFeedDialog.exec())\\n\\t\\t\\treturn null;\\n\\t\\tString url = addFeedDialog.getNewURL();\\n\\t\\tif (alreadyExists(null, url))\\n\\t\\t\\treturn null;\\n\\t\\tMetaInfo feedMetaInfo = createUniqueDynamicFolder(parent, addFeedDialog.getNewFileName());\\n\\t\\tif (feedMetaInfo != null) {\\n\\t\\t\\tConfig config = feedMetaInfo.getConfig();\\n\\t\\t\\tconfig.write(\\\"x.blockImages\\\", addFeedDialog.getBlockImages());\\n\\t\\t\\tconfig.write(\\\"x.excludeFromFetchAllFeeds\\\", addFeedDialog.getExcludeFromFetchAllFeeds());\\n\\t\\t\\tconfig.write(\\\"x.url\\\", url);\\n\\t\\t\\tfeedMetaInfo.sync();\\n\\t\\t\\tTree.getInstance().open(feedMetaInfo);\\n\\t\\t}\\n\\t\\treturn feedMetaInfo;\\n\\t}\\n\\t@Override\\n\\tpublic void setMetaInfoProperty(final MetaInfo metaInfo, final int key, final Object value) {\\n\\t\\tif (!(metaInfo instanceof ArticleMetaInfo))\\n\\t\\t\\treturn;\\n\\t\\tArticleMetaInfo article = (ArticleMetaInfo)metaInfo;\\n\\t\\tboolean repaintArticleList = false;\\n\\t\\tString propertyKey;\\n\\t\\tswitch (key) {\\n\\t\\t\\tcase META_INFO_CATEGORY:\\n\\t\\t\\t\\tpropertyKey = Archive.CATEGORY_PROPERTY;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase META_INFO_COLOR:\\n\\t\\t\\t\\tpropertyKey = Archive.COLOR_PROPERTY;\\n\\t\\t\\t\\tarticle.setColor((Color)value);\\n\\t\\t\\t\\trepaintArticleList = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase META_INFO_COMMENT:\\n\\t\\t\\t\\tpropertyKey = Archive.COMMENT_PROPERTY;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase META_INFO_ICON:\\n\\t\\t\\t\\tpropertyKey = Archive.ICON_PROPERTY;\\n\\t\\t\\t\\tif (value == null)\\n\\t\\t\\t\\t\\tmetaInfo.clearIcon();\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmetaInfo.setIconName((String)value);\\n\\t\\t\\t\\trepaintArticleList = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase META_INFO_RATING:\\n\\t\\t\\t\\tpropertyKey = Archive.RATING_PROPERTY;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase META_INFO_TAGS:\\n\\t\\t\\t\\tpropertyKey = Archive.TAGS_PROPERTY;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tthrow new IllegalArgumentException(\\\"Unknown \\\\\\\"key\\\\\\\" value: \\\" + key);\\n\\t\\t}\\n\\t\\tString url = metaInfo.getParentFolder().getConfig().read(\\\"x.url\\\", null);\\n\\t\\tString id = article.getID();\\n\\t\\ttry {\\n\\t\\t\\tArchive.getInstance().setItemProperty(url, id, new Archive.ItemProperty(propertyKey, value));\\n\\t\\t}\\n\\t\\tcatch (ArchiveException exception) {\\n\\t\\t\\tMLogger.exception(exception);\\n\\t\\t}\\n\\t\\tif (repaintArticleList) {\\n\\t\\t\\tEditor<?> tab = Tabs.getInstance().getSelectedTab();\\n\\t\\t\\tif (tab instanceof FeedViewer)\\n\\t\\t\\t\\tFeedViewer.class.cast(tab).getArticleList().repaint();\\n\\t\\t}\\n\\t}\\n\\t@Override\\n\\tpublic void updateInfo(final MetaInfo metaInfo, final HTMLBuilder html) {\\n\\t\\tif (metaInfo.isDynamicFolder()) {\\n\\t\\t\\tConfig config = metaInfo.getConfig();\\n\\t\\t\\tMetaInfo.addSeparator(html);\\n\\t\\t\\tMetaInfo.addInfo(html, i18n(\\\"RSS Feed Address:\\\"), TK.centerSqueeze(config.read(\\\"x.url\\\", null), 128));\\n\\t\\t}\\n\\t}\\n\\t@Override\\n\\tpublic boolean dynamic(final int flags, final MetaInfo parent) throws FSException {\\n\\t\\tif (parent.isDynamicFolder() && checkOffline())\\n\\t\\t\\treturn false;\\n\\t\\t\\t\\treturn download(parent, true, 0);\\n\\t}\\n\\t@Override\\n\\tpublic void open(final int flags, final MetaInfo metaInfo) throws FSException {\\n\\t\\tif (!metaInfo.isVirtualFile())\\n\\t\\t\\treturn;\\n\\t\\tMetaInfo parent = metaInfo.getParentFolder();\\n\\t\\t\\t\\tif (parent == null) \\t\\t\\treturn;\\n\\t\\tFeedViewer viewer = null;\\n\\t\\tTabs tabs = Tabs.getInstance();\\n\\t\\t\\t\\tList<FeedViewer> tabList = Editor.findEditor(FeedViewer.class);\\n\\t\\tfor (FeedViewer editor : tabList) {\\n\\t\\t\\tif (\\n\\t\\t\\t\\t(editor.getMetaInfo() != null) &&\\n\\t\\t\\t\\t(editor.getMetaInfo().getParentFolder() == parent)\\n\\t\\t\\t) {\\n\\t\\t\\t\\tviewer = editor;\\n\\t\\t\\t\\tif (editor.getMetaInfo() == metaInfo)\\n\\t\\t\\t\\t\\tbreak; \\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (viewer == null) {\\n\\t\\t\\tfor (FeedViewer editor : tabList) {\\n\\t\\t\\t\\tviewer = editor;\\n\\t\\t\\t\\tif (editor.getMetaInfo() == metaInfo)\\n\\t\\t\\t\\t\\tbreak; \\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tif (viewer != null) {\\n\\t\\t\\tMetaInfo viewerParent = viewer.getMetaInfo().getParentFolder();\\n\\t\\t\\tif ((viewerParent != null) && (viewerParent != parent)) {\\n\\t\\t\\t\\tTree tree = Tree.getInstance();\\n\\t\\t\\t\\ttree.setExpanded(viewerParent, false);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tboolean openInNewTab = (flags & FSOpen.MIDDLE_BUTTON) != 0;\\n\\t\\tboolean sameMetaInfo = (viewer != null) && (viewer.getMetaInfo() == metaInfo);\\n\\t\\t\\t\\tif ((viewer == null) || (openInNewTab && !sameMetaInfo)) {\\n\\t\\t\\tviewer = new FeedViewer();\\n\\t\\t\\tviewer.setMetaInfo(metaInfo);\\n\\t\\t\\ttabs.addEditor(viewer);\\n\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\tif (!sameMetaInfo) {\\n\\t\\t\\t\\tMetaInfo old = viewer.getMetaInfo();\\n\\t\\t\\t\\ttabs.addRecentlyClosedTab(old);\\n\\t\\t\\t\\told.setOpen(false);\\n\\t\\t\\t\\told.refresh(true);\\n\\t\\t\\t\\tviewer.setMetaInfo(metaInfo);\\n\\t\\t\\t}\\n\\t\\t\\tmetaInfo.setOpen(true);\\n\\t\\t\\ttabs.selectEditor(viewer);\\n\\t\\t\\ttabs.setTabInfo(viewer, metaInfo);\\n\\t\\t\\tMainWindow.getInstance().updateState();\\n\\t\\t}\\n\\t\\tif (metaInfo instanceof ArticleMetaInfo) {\\n\\t\\t\\tArticleMetaInfo article = (ArticleMetaInfo)metaInfo;\\n\\t\\t\\t\\t\\t\\tarticle.setUnread(false);\\n\\t\\t}\\n\\t\\tupdateInfo(parent); \\n\\t\\tif (!sameMetaInfo)\\n\\t\\t\\tviewer.loadFromMetaInfo(parent, metaInfo);\\n\\t\\t\\t\\tmetaInfo.refresh(true);\\n\\t}\\n\\t@Override\\n\\tpublic boolean matches(final Query query, final MetaInfo metaInfo) {\\n\\t\\tif (!metaInfo.isDynamicFolder())\\n\\t\\t\\treturn false;\\n\\t\\t\\t\\tQuery.Criterium criterium = query.getCriteria().get(Query.KEYWORDS);\\n\\t\\tif (criterium != null) {\\n\\t\\t\\tConfig config = metaInfo.getConfig();\\n\\t\\t\\tString url = config.read(\\\"x.url\\\", null);\\n\\t\\t\\tif (url != null) {\\n\\t\\t\\t\\tfor (String i : criterium.getKeywords()) {\\n\\t\\t\\t\\t\\tif (TK.containsIgnoreCase(url, i))\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\t@Override\\n\\tpublic void updateMenu(final String type, final MMenu menu) {\\n\\t\\tif (type.equals(EXPORT_MENU)) {\\n\\t\\t\\tmenu.addSeparator(false);\\n\\t\\t\\tMetaInfo folder = Tree.getInstance().getCurrentFolder(true);\\n\\t\\t\\tString text = folder.isFSRoot() ? i18n(\\\"Export All Feeds\\\") : i18n(\\\"Export \\\\\\\"{0}\\\\\\\" Feeds\\\", folder);\\n\\t\\t\\tmenu.add(new ExportAction(text));\\n\\t\\t}\\n\\t\\telse if (type.equals(IMPORT_MENU)) {\\n\\t\\t\\tmenu.addSeparator(false);\\n\\t\\t\\tmenu.add(new ImportAction());\\n\\t\\t\\tmenu.add(new ImportFromLifereaAction());\\n\\t\\t}\\n\\t\\telse if (type.equals(TREE_MENU)) {\\n\\t\\t\\tMetaInfo feed = Tree.getInstance().getCurrentFolder(true);\\n\\t\\t\\tif (FeedDownloader.isActive())\\n\\t\\t\\t\\tmenu.add(fetchAllFeedsAction);\\n\\t\\t\\telse\\n\\t\\t\\t\\tmenu.add(new FetchFeedsAction(feed));\\n\\t\\t\\tif (filtersAction == null)\\n\\t\\t\\t\\tfiltersAction = new Filters.FiltersAction();\\n\\t\\t\\tif (markAllAsReadAction == null)\\n\\t\\t\\t\\tmarkAllAsReadAction = new MarkAllAsReadAction();\\n\\t\\t\\tif (\\n\\t\\t\\t\\t(feed.getFS() instanceof FeedsFS) &&\\n\\t\\t\\t\\tfeed.isDynamicFolder()\\n\\t\\t\\t) {\\n\\t\\t\\t\\tfiltersAction.setEnabled(feed.isWriteable());\\n\\t\\t\\t\\tfiltersAction.setName(i18n(\\\"RSS Filters: {0}\\\", TK.centerSqueeze(feed.toString(), 15)));\\n\\t\\t\\t\\tmarkAllAsReadAction.setEnabled(true);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tfiltersAction.setEnabled(false);\\n\\t\\t\\t\\tfiltersAction.setName(i18n(\\\"RSS Filters...\\\"));\\n\\t\\t\\t\\tmarkAllAsReadAction.setEnabled(false);\\n\\t\\t\\t}\\n\\t\\t\\tmenu.add(filtersAction);\\n\\t\\t\\tmenu.add(markAllAsReadAction);\\n\\t\\t}\\n\\t}\\n\\t@Override\\n\\tpublic void updateToolBar(final String type, final MToolBar toolBar) { }\\n\\tFeedsFS(final PluginInfo info) throws FSException { \\t\\tsuper(info, \\\"feeds\\\", i18n(\\\"RSS Feeds\\\"));\\n\\t\\tacc = AccessController.getContext();\\n\\t\\tscan();\\n\\t\\t\\t\\tConfig config = Config.getDefault();\\n\\t\\tif (getRoot().isEmpty(MV.MODEL) && config.read(\\\"Feeds.createSamples\\\", true)) {\\n\\t\\t\\tconfig.write(\\\"Feeds.createSamples\\\", false);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\taddSample(\\\"How-To Geek\\\", \\\"ui/console\\\", \\\"http:\\t\\t\\t\\t\\t\\taddSample(\\\"Quotes of the Day\\\", null, \\\"http:\\t\\t\\taddSample(\\\"Today I Learned (TIL)\\\", null, \\\"http:\\t\\t\\taddSample(\\\"Slashdot\\\", \\\"ui/console\\\", \\\"http:\\t\\t\\t\\t\\t}\\n\\t\\tintervalFetchTimer = MTimer.minutes(FeedsFSPlugin.DEFAULT_FETCH_INTERVAL, timer -> {\\n\\t\\t\\tif (!MApplication.offline.booleanValue())\\n\\t\\t\\t\\tfetchFeeds(getRoot(), USE_EXCLUDE_FROM_INTERVAL_FETCH);\\n\\t\\t\\treturn MTimer.CONTINUE;\\n\\t\\t} );\\n\\t}\\n\\t@Override\\n\\tprotected String getDefaultIconName(final MetaInfo metaInfo) {\\n\\t\\treturn metaInfo.isDynamicFolder() ? \\\"ui/feed\\\" : null;\\n\\t}\\n\\t@Override\\n\\tprotected void processFile(final MetaInfo parent, final File file) {\\n\\t\\tprocessDynamicFolder(parent, file);\\n\\t}\\n\\tprivate void addSample(final String name, final String iconName, final String url) {\\n\\t\\tMetaInfo dynamicFolder = addDynamicFolder(getRoot(), name);\\n\\t\\tif (dynamicFolder != null) {\\n\\t\\t\\tif (iconName != null)\\n\\t\\t\\t\\tdynamicFolder.setIconName(iconName);\\n\\t\\t\\tConfig config = dynamicFolder.getConfig();\\n\\t\\t\\tconfig.write(\\\"x.url\\\", url);\\n\\t\\t\\tconfig.sync();\\n\\t\\t}\\n\\t}\\n\\tprivate static boolean checkOffline() {\\n\\t\\tif (MApplication.offline.get()) {\\n\\t\\t\\tMStatusBar.warning(i18n(\\\"Working in Offline Mode\\\"));\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\tprivate static void doRemoveAllChildren(final MetaInfo parent) {\\n\\t\\tfor (FeedViewer i : FeedViewer.findEditor(FeedViewer.class)) {\\n\\t\\t\\tif (i.getMetaInfo().getParentFolder() == parent) {\\n\\t\\t\\t\\ti.waitingForUpdateFrom = parent;\\n\\t\\t\\t\\ti.messageLabel.setWarningMessage(i18n(\\\"Please Wait...\\\"));\\n\\t\\t\\t\\ti.messageLabel.setVisible(true);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (MetaInfo i : parent.list(MV.MODEL))\\n\\t\\t\\ti.setParent(null);\\n\\t\\tTree tree = Tree.getInstance();\\n\\t\\ttree.setCloseTabsOnRemove(false);\\n\\t\\ttry {\\n\\t\\t\\ttree.removeAllChildren(parent);\\n\\t\\t}\\n\\t\\tfinally {\\n\\t\\t\\ttree.setCloseTabsOnRemove(true);\\n\\t\\t}\\n\\t}\\n\\tprivate boolean download(final MetaInfo parent, final boolean expandFolder, final int flags) {\\n\\t\\tif (!parent.isDynamicFolder())\\n\\t\\t\\treturn false;\\n\\t\\t\\t\\tObject feedThread = parent.clearProperty(\\\"feed.thread\\\");\\n\\t\\tif (feedThread instanceof FeedThread) {\\n\\t\\t\\tFeedThread.class.cast(feedThread).abort();\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tConfig config = parent.getConfig();\\n\\t\\tif (\\n\\t\\t\\t((flags & USE_EXCLUDE_FROM_FETCH_ALL_FEEDS) != 0) &&\\n\\t\\t\\tconfig.read(\\\"x.excludeFromFetchAllFeeds\\\", false)\\n\\t\\t)\\n\\t\\t\\treturn true;\\n\\t\\tif (\\n\\t\\t\\t((flags & USE_EXCLUDE_FROM_INTERVAL_FETCH) != 0) &&\\n\\t\\t\\tconfig.read(\\\"x.excludeFromIntervalFetch\\\", false)\\n\\t\\t)\\n\\t\\t\\treturn true;\\n\\t\\t\\t\\tLong lastFetch = parent.getProperty(\\\"feed.lastFetch\\\", null);\\n\\t\\tif (\\n\\t\\t\\t(lastFetch != null) &&\\n\\t\\t\\t((System.currentTimeMillis() - lastFetch) < TimeUnit.MINUTES.toMillis(1))\\n\\t\\t) {\\n\\t\\t\\tlog.debugFormat(\\\"Feed \\\\\\\"%s\\\\\\\" already downloaded\\\", parent);\\n\\t\\t\\tif (expandFolder)\\n\\t\\t\\t\\tTree.getInstance().setExpanded(parent, true);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\t\\t\\tdoRemoveAllChildren(parent);\\n\\t\\tboolean fetchOffline = (flags & FETCH_OFFLINE) != 0;\\n\\t\\tFeedDownloader.download(this, parent, expandFolder, null, fetchOffline);\\n\\t\\treturn true;\\n\\t}\\n\\tprivate void exportTo(final File file) {\\n\\t\\tfinal OPMLWriter writer = new OPMLWriter();\\n\\t\\twriter.beginOPML();\\n\\t\\twriter.emptyHead();\\n\\t\\twriter.beginBody();\\n\\t\\tnew Tree.Scanner(Tree.getInstance().getCurrentFolder(true)) {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic void processItem(final MetaInfo item) {\\n\\t\\t\\t\\tif (item.isDynamicFolder()) {\\n\\t\\t\\t\\t\\tConfig config = item.getConfig();\\n\\t\\t\\t\\t\\twriter.addOutline(\\n\\t\\t\\t\\t\\t\\titem.toString(),\\n\\t\\t\\t\\t\\t\\t\\\"xmlUrl\\\", writer.escape(config.read(\\\"x.url\\\", \\\"\\\"))\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (item.isFolder()) {\\n\\t\\t\\t\\t\\twriter.beginOutline(item.toString());\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic void processParent(final MetaInfo parent) {\\n\\t\\t\\t\\tif (parent.isFolder())\\n\\t\\t\\t\\t\\twriter.endOutline();\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\twriter.endBody();\\n\\t\\twriter.endOPML();\\n\\t\\ttry {\\n\\t\\t\\twriter.write(file);\\n\\t\\t}\\n\\t\\tcatch (IOException exception) {\\n\\t\\t\\tMMessage.error(null, exception, i18n(\\\"Could not export feeds\\\"));\\n\\t\\t}\\n\\t}\\n\\tprivate void importFrom(final File file, final MetaInfo toFolder) {\\n\\t\\tcurrentImportFolder = toFolder;\\n\\t\\ttry {\\n\\t\\t\\tOPMLReader reader = new OPMLReader() {\\n\\t\\t\\t\\tprivate boolean inEmptyFolder;\\n\\t\\t\\t\\tprivate Map<String, MetaInfo> existingURLs = FeedsFS.this.findAllURLs();\\n\\t\\t\\t\\t@Override\\n\\t\\t\\t\\tprotected void onEnd(final String name) {\\n\\t\\t\\t\\t\\tsuper.onEnd(name);\\n\\t\\t\\t\\t\\tif (name.equals(\\\"outline\\\") && (inEmptyFolder || !hasAttributes())) {\\n\\t\\t\\t\\t\\t\\tinEmptyFolder = false;\\n\\t\\t\\t\\t\\t\\tMetaInfo parent = currentImportFolder.getParentFolder();\\n\\t\\t\\t\\t\\t\\tif (parent == null)\\n\\t\\t\\t\\t\\t\\t\\tcurrentImportFolder = toFolder;\\n\\t\\t\\t\\t\\t\\telse if (parent.getFS() instanceof FeedsFS)\\n\\t\\t\\t\\t\\t\\t\\tcurrentImportFolder = parent;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tcurrentImportFolder = toFolder;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t@Override\\n\\t\\t\\t\\tprotected void onOutline() {\\n\\t\\t\\t\\t\\tString url = getStringAttribute(\\\"xmlUrl\\\");\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (url == null) {\\n\\t\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\tcurrentImportFolder = currentImportFolder.getFS().createUniqueFolder(currentImportFolder, getTextAttribute(i18n(\\\"Unnamed\\\")));\\n\\t\\t\\t\\t\\t\\t\\tinEmptyFolder = true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcatch (FSException exception) {\\n\\t\\t\\t\\t\\t\\t\\tcancel();\\n\\t\\t\\t\\t\\t\\t\\tMMessage.error(null, exception);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\telse if (!FeedsFS.this.alreadyExists(existingURLs, url)) {\\n\\t\\t\\t\\t\\t\\tString name = FSHelper.getUniqueName(currentImportFolder.getTargetFile(), getTextAttribute(i18n(\\\"Unnamed\\\")), \\\"properties\\\");\\n\\t\\t\\t\\t\\t\\tConfig config = new Config(FS.makePath(currentImportFolder.getTargetPath(), FSHelper.escapeName(name)));\\n\\t\\t\\t\\t\\t\\tconfig.write(\\\"x.url\\\", url);\\n\\t\\t\\t\\t\\t\\tconfig.sync();\\n\\t\\t\\t\\t\\t\\tMetaInfo dynamicFolder = MetaInfo.createDynamicFolder(FeedsFS.this, config.getPath()); \\n\\t\\t\\t\\t\\t\\tcurrentImportFolder.add(dynamicFolder);\\n\\t\\t\\t\\t\\t\\tdynamicFolder.sync();\\n\\t\\t\\t\\t\\t\\tinEmptyFolder = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\treader.read(file);\\n\\t\\t}\\n\\t\\tcatch (Exception exception) {\\n\\t\\t\\tMMessage.error(null, exception, i18n(\\\"Could not import feeds\\\"));\\n\\t\\t}\\n\\t\\tfinally {\\n\\t\\t\\tcurrentImportFolder = null;\\n\\t\\t\\tgetRoot().reload();\\n\\t\\t\\tTree.getInstance().selectItem(toFolder, true);\\n\\t\\t}\\n\\t}\\n\\tboolean alreadyExists(Map<String, MetaInfo> existingURLs, final String newURL) {\\n\\t\\tif (existingURLs == null)\\n\\t\\t\\texistingURLs = findAllURLs();\\n\\t\\tMetaInfo item = existingURLs.get(newURL);\\n\\t\\tif (item != null) {\\n\\t\\t\\tMNotification.Message message = FeedThread.showNotification(\\n\\t\\t\\t\\titem,\\n\\t\\t\\t\\tnew FeedThread.ErrorAction(item, i18n(\\\"RSS feed already exists: {0}\\\", newURL))\\n\\t\\t\\t);\\n\\t\\t\\tmessage.toFront();\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\tMap<String, MetaInfo> findAllURLs() {\\n\\t\\tfinal Map<String, MetaInfo> result = new HashMap<>();\\n\\t\\tnew Tree.Scanner(this) {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic void processItem(final MetaInfo item) {\\n\\t\\t\\t\\tif (item.isDynamicFolder()) {\\n\\t\\t\\t\\t\\tString url = item.getConfig().read(\\\"x.url\\\", null);\\n\\t\\t\\t\\t\\tif (url == null)\\n\\t\\t\\t\\t\\t\\tlog.debugFormat(\\\"Missing Feed URL: %s\\\", item.getFilePath());\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tresult.put(url, item);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\treturn result;\\n\\t}\\n\\tColor getColor(final ArticleMetaInfo article) {\\n\\t\\tColor articleColor = article.getColor();\\n\\t\\tif ((articleColor == null) || (articleColor instanceof UnreadColor)) {\\n\\t\\t\\tif (article.isUnread())\\n\\t\\t\\t\\tarticleColor = getUnreadColor();\\n\\t\\t\\telse\\n\\t\\t\\t\\tarticleColor = null;\\n\\t\\t}\\n\\t\\treturn articleColor;\\n\\t}\\n\\tstatic FeedsFSPlugin getFeedsFSPlugin() {\\n\\t\\treturn (FeedsFSPlugin)self().getInfo().getPlugin();\\n\\t}\\n\\tstatic void refresh(final MetaInfo parent) {\\n\\t\\tparent.clearProperty(\\\"feed.lastFetch\\\"); \\t\\tdoRemoveAllChildren(parent);\\n\\t\\tself().download(parent, true, FETCH_OFFLINE);\\n\\t\\tparent.reload();\\n\\t}\\n\\tFeedsFSPlugin.Settings reloadSettings(final FeedsFSPlugin plugin) {\\n\\t\\tFeedsFSPlugin.Settings settings = plugin.readGlobalSettings();\\n\\t\\tintervalFetchTimer.setDelay(TimeUnit.MINUTES, settings.minutes);\\n\\t\\t\\t\\tif (settings.useIntervalFetching)\\n\\t\\t\\tintervalFetchTimer.restart();\\n\\t\\telse\\n\\t\\t\\tintervalFetchTimer.stop();\\n\\t\\treturn settings;\\n\\t}\\n\\tstatic FeedsFS self() {\\n\\t\\tFeedsFS fs = FeedsFSPlugin._fsInstance;\\n\\t\\tif (fs == null)\\n\\t\\t\\tlog.error(\\\"\\\\\\\"feeds\\\\\\\" VFS no longer available\\\");\\n\\t\\treturn fs;\\n\\t}\\n\\tvoid updateInfo(final MetaInfo dynamicFolder) {\\n\\t\\tint newCount = 0;\\n\\t\\tint unreadCount = 0;\\n\\t\\tfor (MetaInfo i : dynamicFolder.list(MV.MODEL)) {\\n\\t\\t\\tif (i instanceof ArticleMetaInfo) {\\n\\t\\t\\t\\tArticleMetaInfo article = (ArticleMetaInfo)i;\\n\\t\\t\\t\\tif (article.isNew())\\n\\t\\t\\t\\t\\tnewCount++;\\n\\t\\t\\t\\tif (article.isUnread())\\n\\t\\t\\t\\t\\tunreadCount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tStringJoiner s = new StringJoiner(\\\", \\\");\\n\\t\\tboolean dead = dynamicFolder.getProperty(\\\"feed.dead\\\", false);\\n\\t\\tif (dead)\\n\\t\\t\\ts.add(i18n(\\\"Dead RSS source?\\\"));\\n\\t\\tif (newCount > 0)\\n\\t\\t\\ts.add(i18n(\\\"New: {0}\\\", newCount));\\n\\t\\tif (unreadCount > 0)\\n\\t\\t\\ts.add(i18n(\\\"Unread: {0}\\\", unreadCount));\\n\\t\\tif (s.length() == 0) {\\n\\t\\t\\tdynamicFolder.clearProperty(MetaInfo.EXTRA_COLOR);\\n\\t\\t\\tdynamicFolder.clearProperty(MetaInfo.EXTRA_TEXT);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (dead)\\n\\t\\t\\t\\tdynamicFolder.setProperty(MetaInfo.EXTRA_COLOR, MColor.BRICK_RED);\\n\\t\\t\\telse if ((newCount > 0) || (unreadCount > 0))\\n\\t\\t\\t\\tdynamicFolder.setProperty(MetaInfo.EXTRA_COLOR, getUnreadColor());\\n\\t\\t\\telse\\n\\t\\t\\t\\tdynamicFolder.clearProperty(MetaInfo.EXTRA_COLOR);\\n\\t\\t\\tdynamicFolder.setProperty(MetaInfo.EXTRA_TEXT, s.toString());\\n\\t\\t}\\n\\t\\tdynamicFolder.refresh(true);\\n\\t}\\n\\tpublic static final class ArticleMetaInfo extends MetaInfo.VirtualFileMetaInfo {\\n\\t\\tprivate byte state;\\n\\t\\tprivate static final byte UNREAD_STATE = 1;\\n\\t\\tprivate static final byte NEW_STATE = 1 << 1;\\n\\t\\t\\t\\tprivate static final byte WAS_UNREAD_STATE = 1 << 2;\\n\\t\\tpublic ArticleMetaInfo(final AbstractFS fs, final String name, final String articleID) {\\n\\t\\t\\tsuper(fs, name);\\n\\t\\t\\tsetID(Objects.toString(articleID, \\\"\\\"));\\n\\t\\t}\\n\\t\\tpublic boolean isNew() {\\n\\t\\t\\treturn (state & NEW_STATE) != 0;\\n\\t\\t}\\n\\t\\tpublic void setNew(final boolean value) {\\n\\t\\t\\tif (value)\\n\\t\\t\\t\\tstate |= NEW_STATE;\\n\\t\\t\\telse\\n\\t\\t\\t\\tstate &= ~NEW_STATE;\\n\\t\\t}\\n\\t\\tpublic boolean isUnread() {\\n\\t\\t\\treturn (state & UNREAD_STATE) != 0;\\n\\t\\t}\\n\\t\\tpublic void setUnread(final boolean value) {\\n\\t\\t\\tif (value)\\n\\t\\t\\t\\tstate |= (UNREAD_STATE | WAS_UNREAD_STATE);\\n\\t\\t\\telse\\n\\t\\t\\t\\tstate &= ~UNREAD_STATE;\\n\\t\\t}\\n\\t\\tboolean wasUnread() {\\n\\t\\t\\treturn (state & WAS_UNREAD_STATE) != 0;\\n\\t\\t}\\n\\t}\\n\\tpublic static final class ArchiveOptions extends FeedsFSPlugin.AbstractPanel {\\n\\t\\tprivate final MRadioButton doNotRemoveArticles;\\n\\t\\tprivate final MRadioButton removeArticles;\\n\\t\\tprivate MRadioButton useGlobalSettings;\\n\\t\\tprivate final MSlider days;\\n\\t\\tpublic ArchiveOptions(final boolean globalSettings) {\\n\\t\\t\\tsuper(i18n(\\\"Archive\\\"), !globalSettings);\\n\\t\\t\\tif (!globalSettings) {\\n\\t\\t\\t\\tuseGlobalSettings = new MRadioButton(i18n(\\\"Use global settings\\\"));\\n\\t\\t\\t\\tadd(useGlobalSettings);\\n\\t\\t\\t}\\n\\t\\t\\tremoveArticles = new MRadioButton();\\n\\t\\t\\tMSmallButton cleanUpArchiveButton = new MSmallButton(\\n\\t\\t\\t\\tMIcon.small(\\\"ui/delete\\\"),\\n\\t\\t\\t\\ti18n(\\\"Manually Remove Unused RSS Archives...\\\")\\n\\t\\t\\t);\\n\\t\\t\\tcleanUpArchiveButton.addActionListener(e -> cleanUpArchive(cleanUpArchiveButton));\\n\\t\\t\\tadd(cleanUpArchiveButton);\\n\\t\\t\\tMPanel removeArticlesPanel = MPanel.createHBoxPanel();\\n\\t\\t\\tremoveArticlesPanel.add(removeArticles);\\n\\t\\t\\tremoveArticlesPanel.addGap();\\n\\t\\t\\tremoveArticlesPanel.addStretch();\\n\\t\\t\\tremoveArticlesPanel.add(cleanUpArchiveButton);\\n\\t\\t\\tadd(removeArticlesPanel);\\n\\t\\t\\tdays = new MSlider();\\n\\t\\t\\tdays.setMinimum(FeedsFSPlugin.Settings.MIN_DAYS);\\n\\t\\t\\tdays.setMaximum(FeedsFSPlugin.Settings.MAX_DAYS);\\n\\t\\t\\tdays.showSimpleLabels();\\n\\t\\t\\tdays.addChangeListener(e -> {\\n\\t\\t\\t\\tremoveArticles.setSelected(true);\\n\\t\\t\\t\\tupdateText();\\n\\t\\t\\t} );\\n\\t\\t\\tadd(days);\\n\\t\\t\\tremoveArticles.addActionListener(e -> days.requestFocusInWindow());\\n\\t\\t\\tdoNotRemoveArticles = new MRadioButton(i18n(\\\"Do not remove old articles (slow)\\\"));\\n\\t\\t\\tadd(doNotRemoveArticles);\\n\\t\\t\\tUI.group(\\n\\t\\t\\t\\tuseGlobalSettings,\\n\\t\\t\\t\\tremoveArticles,\\n\\t\\t\\t\\tdoNotRemoveArticles\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\tpublic Archive.Policy getPolicy() {\\n\\t\\t\\tif (doNotRemoveArticles.isSelected())\\n\\t\\t\\t\\treturn Archive.Policy.DO_NOT_REMOVE;\\n\\t\\t\\tif (removeArticles.isSelected())\\n\\t\\t\\t\\treturn Archive.Policy.REMOVE;\\n\\t\\t\\treturn (useGlobalSettings == null) ? Archive.Policy.REMOVE : Archive.Policy.USE_GLOBAL_SETTINGS;\\n\\t\\t}\\n\\t\\tpublic int getDays() {\\n\\t\\t\\treturn days.getValue();\\n\\t\\t}\\n\\t\\tpublic void setDays(final int value, final Archive.Policy policy) {\\n\\t\\t\\tdays.setValue(value);\\n\\t\\t\\tswitch (policy) {\\n\\t\\t\\t\\tcase DO_NOT_REMOVE:\\n\\t\\t\\t\\t\\tdoNotRemoveArticles.setSelected(true);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase REMOVE:\\n\\t\\t\\t\\t\\tremoveArticles.setSelected(true);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase USE_GLOBAL_SETTINGS:\\n\\t\\t\\t\\t\\tif (useGlobalSettings == null)\\n\\t\\t\\t\\t\\t\\tremoveArticles.setSelected(true);\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tuseGlobalSettings.setSelected(true);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tupdateText();\\n\\t\\t}\\n\\t\\tprivate void cleanUpArchive(final MButton button) {\\t\\t\\tArchive archive = Archive.getInstance();\\n\\t\\t\\tFeedsFS fs = FeedsFS.self();\\n\\t\\t\\tMap<String, MetaInfo> urlMap = fs.findAllURLs();\\n\\t\\t\\tWindow owner = getWindowAncestor();\\n\\t\\t\\tTreeSet<Tuple.Two<String, String>> unused = new TreeSet<>(Comparator.comparing(Tuple.Two::get1));\\n\\t\\t\\tfor (Map.Entry<String, Archive.Item> i : archive) {\\n\\t\\t\\t\\tif (!urlMap.containsKey(i.getKey())) {\\n\\t\\t\\t\\t\\tPath path = Paths.get(archive.getDirectory().getPath(), i.getValue().getFileName());\\n\\t\\t\\t\\t\\tString sizeText;\\n\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\tsizeText = MFormat.toAutoSize(Files.size(path));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcatch (IOException exception) {\\n\\t\\t\\t\\t\\t\\tsizeText = MFormat.toAutoSize(-1);\\n\\t\\t\\t\\t\\t\\tMLogger.developerException(exception);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tunused.add(Tuple.of(i.getKey(), sizeText));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (unused.isEmpty()) {\\n\\t\\t\\t\\tbutton.setEnabled(false);\\n\\t\\t\\t\\tbutton.setIcon(MIcon.small(\\\"ui/ok\\\"));\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tMCheckBoxTable<Tuple.Two<String, String>> table = new MCheckBoxTable<>(\\n\\t\\t\\t\\ti18n(\\\"Delete\\\"),\\n\\t\\t\\t\\ti18n(\\\"Address\\\"),\\n\\t\\t\\t\\ttrue,\\n\\t\\t\\t\\tunused\\n\\t\\t\\t);\\n\\t\\t\\tMDialog dialog = table.createDialog(\\n\\t\\t\\t\\towner,\\n\\t\\t\\t\\ti18n(\\\"Remove Unused RSS Archives\\\"),\\n\\t\\t\\t\\ti18n(\\\"Items:\\\"),\\n\\t\\t\\t\\tMActionInfo.DELETE\\n\\t\\t\\t);\\n\\t\\t\\tif (dialog.exec()) {\\n\\t\\t\\t\\tif (owner != null)\\n\\t\\t\\t\\t\\tUI.setWaitCursor(owner, true);\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tfor (MCheckBoxTable.CheckBoxItem<Tuple.Two<String, String>> i : table.getModel()) {\\n\\t\\t\\t\\t\\t\\tif (i.isSelected())\\n\\t\\t\\t\\t\\t\\t\\ti.getValue().accept((address, size) -> archive.removeItem(address));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfinally {\\n\\t\\t\\t\\t\\tif (owner != null)\\n\\t\\t\\t\\t\\t\\tUI.setWaitCursor(owner, false);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprivate void updateText() {\\n\\t\\t\\tremoveArticles.setText(i18n(\\\"Automatically remove articles after {0} day(s)\\\", days.getValue()));\\n\\t\\t}\\n\\t}\\n\\tpublic final class FetchAllFeedsAction extends MAction {\\n\\t\\tprivate boolean idle;\\n\\t\\tMButton button;\\n\\t\\tpublic FetchAllFeedsAction() {\\n\\t\\t\\tsetHTMLHelp(i18n(\\\"Download and update all RSS feeds.\\\"));\\n\\t\\t\\tsetIdle(true);\\n\\t\\t}\\n\\t\\t@Override\\n\\t\\tpublic void onAction() {\\n\\t\\t\\tif (idle) {\\n\\t\\t\\t\\tif (FeedsFS.checkOffline())\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\tMetaInfo root = FeedsFS.this.getRoot();\\n\\t\\t\\t\\tMainWindow.showTree(root);\\n\\t\\t\\t\\tTree.getInstance().setExpanded(root, true);\\n\\t\\t\\t\\t\\t\\t\\t\\tif (FeedsFS.this.intervalFetchTimer.isRunning())\\n\\t\\t\\t\\t\\tFeedsFS.this.intervalFetchTimer.restart();\\n\\t\\t\\t\\tFeedsFS.this.fetchFeeds(USE_EXCLUDE_FROM_FETCH_ALL_FEEDS);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tFeedDownloader.abortAll();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tpublic void setIdle(final boolean idle) {\\n\\t\\t\\tthis.idle = idle;\\n\\t\\t\\tif (idle) {\\n\\t\\t\\t\\tsetName(i18n(\\\"Refresh All RSS Feeds\\\"));\\n\\t\\t\\t\\tsetIconName(\\\"ui/feed\\\");\\n\\t\\t\\t\\tif (button != null)\\n\\t\\t\\t\\t\\tbutton.setRolloverIcon(MIcon.stock(\\\"ui/refresh\\\"));\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tsetName(i18n(\\\"Cancel Refresh\\\"));\\n\\t\\t\\t\\tsetIconName(\\\"ui/stop\\\");\\n\\t\\t\\t\\tif (button != null)\\n\\t\\t\\t\\t\\tbutton.setRolloverIcon(button.getIcon());\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tprivate abstract class AbstractImportAction extends MAction {\\n\\t\\tprivate String newFolderName;\\n\\t\\t@Override\\n\\t\\tpublic void onAction() {\\n\\t\\t\\tMFileChooser fileChooser = createFileChooser();\\n\\t\\t\\tif (fileChooser.openDialog()) {\\n\\t\\t\\t\\tFile file = fileChooser.getSelectedFile();\\n\\t\\t\\t\\tif (newFolderName == null)\\n\\t\\t\\t\\t\\tnewFolderName = file.getName();\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tFeedsFS.this.importFrom(file, getTargetFolder());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch (FSException exception) {\\n\\t\\t\\t\\t\\tMMessage.error(null, exception);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprotected Path getImportDir() { return null; }\\n\\t\\tprotected MetaInfo getTargetFolder() throws FSException {\\n\\t\\t\\tMetaInfo folder = FeedsFS.this.getCurrentFolder(false);\\n\\t\\t\\treturn FeedsFS.this.createUniqueFolder(folder, i18n(\\\"Imported from {0}\\\", newFolderName));\\n\\t\\t}\\n\\t\\tprotected MFileChooser createFileChooser() {\\n\\t\\t\\tMFileChooser fileChooser = MFileChooser.createFileChooser(null, i18n(\\\"Import RSS Feed List\\\"));\\n\\t\\t\\tfileChooser.setFileFilter(\\n\\t\\t\\t\\tfileChooser.addFilter(\\\"OPML\\\", \\\"opml\\\", \\\"xml\\\")\\n\\t\\t\\t);\\n\\t\\t\\tfileChooser.setApproveText(MActionInfo.IMPORT.getText());\\n\\t\\t\\tfileChooser.setConfigKey(\\\"importFeeds\\\");\\n\\t\\t\\tPath dir = getImportDir();\\n\\t\\t\\tif (dir != null)\\n\\t\\t\\t\\tfileChooser.setSelectedFile(dir.toFile());\\n\\t\\t\\treturn fileChooser;\\n\\t\\t}\\n\\t\\tprivate AbstractImportAction(final String text, final String newFolderName) {\\n\\t\\t\\tsuper(text, \\\"ui/feed\\\");\\n\\t\\t\\tthis.newFolderName = newFolderName;\\n\\t\\t}\\n\\t}\\n\\tprivate static final class CustomAdvancedPanel extends FeedsFSPlugin.AbstractPanel {\\n\\t\\tprivate boolean showExpiredArticlesAgainClicked;\\n\\t\\tprivate final MButton showExpiredArticlesAgainButton;\\n\\t\\tprivate final MCheckBox blockImagesCheckBox;\\n\\t\\tprivate final MCheckBox excludeFromFetchAllFeeds;\\n\\t\\tprivate final MCheckBox excludeFromIntervalFetch;\\n\\t\\tprivate final MCheckBox showFullPageCheckBox;\\n\\t\\tpublic CustomAdvancedPanel() {\\n\\t\\t\\tsuper(i18n(\\\"Miscellaneous\\\"), false);\\n\\t\\t\\t\\t\\t\\tsetMargin(0, getContentMargin(), getContentMargin(), getContentMargin());\\n\\t\\t\\tblockImagesCheckBox = new MCheckBox(i18n(\\\"Block Images\\\"));\\n\\t\\t\\tadd(blockImagesCheckBox);\\n\\t\\t\\tshowFullPageCheckBox = new MCheckBox(i18n(\\\"Load and Show Full Page\\\") + \\\" - \\\" + i18n(\\\"Experimental\\\"));\\n\\t\\t\\tadd(showFullPageCheckBox);\\n\\t\\t\\t\\t\\t\\texcludeFromFetchAllFeeds = new MCheckBox(i18n(\\\"Exclude from \\\\\\\"Refresh All Feeds\\\\\\\"\\\"));\\n\\t\\t\\tadd(excludeFromFetchAllFeeds);\\n\\t\\t\\t\\t\\t\\texcludeFromIntervalFetch = new MCheckBox(i18n(\\\"Exclude from \\\\\\\"interval\\\\\\\" fetch\\\"));\\n\\t\\t\\tadd(excludeFromIntervalFetch);\\n\\t\\t\\taddContentGap();\\n\\t\\t\\tshowExpiredArticlesAgainButton = new MButton(i18n(\\\"Show Expired Articles Again\\\"));\\n\\t\\t\\tshowExpiredArticlesAgainButton.addActionListener(e -> showExpiredArticlesAgainClicked = true);\\n\\t\\t\\tadd(showExpiredArticlesAgainButton);\\n\\t\\t\\taddContentGap();\\n\\t\\t\\taddStretch();\\n\\t\\t\\tMButton globalSettingsButton = new MButton(new FeedsFS.GlobalSettingsAction());\\n\\t\\t\\tglobalSettingsButton.setIconNameUI(\\\"ui/feed\\\");\\n\\t\\t\\tadd(globalSettingsButton);\\n\\t\\t}\\n\\t\\t@Override\\n\\t\\tprotected boolean shouldRefresh() {\\n\\t\\t\\treturn\\n\\t\\t\\t\\tshowExpiredArticlesAgainClicked ||\\n\\t\\t\\t\\tblockImagesCheckBox.isModified();\\n\\t\\t}\\n\\t}\\n\\tprivate final class ExportAction extends MAction {\\n\\t\\tpublic ExportAction(final String name) {\\n\\t\\t\\tsuper(name, \\\"ui/feed\\\");\\n\\t\\t}\\n\\t\\t@Override\\n\\t\\tpublic void onAction() {\\n\\t\\t\\tMFileChooser fileChooser = MFileChooser.createFileChooser(this.getSourceWindow(), i18n(\\\"Export Feeds\\\"));\\n\\t\\t\\tfileChooser.setFileFilter(\\n\\t\\t\\t\\tfileChooser.addFilter(\\\"OPML\\\", \\\"opml\\\", \\\"xml\\\")\\n\\t\\t\\t);\\n\\t\\t\\tfileChooser.setApproveText(i18n(\\\"Export\\\"));\\n\\t\\t\\tfileChooser.setConfigKey(\\\"exportFeeds\\\");\\n\\t\\t\\tfileChooser.setSelectedFile(new File(\\\"feeds.opml\\\"));\\n\\t\\t\\tif (fileChooser.saveDialog())\\n\\t\\t\\t\\texportTo(fileChooser.getSelectedFile());\\n\\t\\t}\\n\\t}\\n\\tprivate final class FetchFeedsAction extends MDataAction<MetaInfo> {\\n\\t\\t@Override\\n\\t\\tpublic void onAction() {\\n\\t\\t\\tif (FeedsFS.checkOffline())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tFeedsFS.this.fetchFeeds(this.getData(), 0);\\n\\t\\t}\\n\\t\\tprivate FetchFeedsAction(final MetaInfo feed) {\\n\\t\\t\\tsuper(feed, i18n(\\\"Refresh Feeds: {0}\\\", TK.centerSqueeze(feed.toString(), 15)), \\\"ui/refresh\\\");\\n\\t\\t}\\n\\t}\\n\\tprivate final class ImportAction extends AbstractImportAction {\\n\\t\\tprivate ImportAction() {\\n\\t\\t\\tsuper(i18n(\\\"Import RSS Feed List\\\"), null);\\n\\t\\t}\\n\\t}\\n\\tprivate final class ImportFromLifereaAction extends AbstractImportAction {\\n\\t\\t@Override\\n\\t\\tprotected Path getImportDir() {\\n\\t\\t\\ttry (Stream<Path> stream = Files.list(FS.getUserPath())) {\\n\\t\\t\\t\\tList<Path> result = stream\\n\\t\\t\\t\\t\\t.filter(path -> Files.isDirectory(path) && path.getFileName().toString().startsWith(\\\".liferea\\\"))\\n\\t\\t\\t\\t\\t.sorted(Comparator.reverseOrder())\\n\\t\\t\\t\\t\\t.collect(Collectors.toList());\\n\\t\\t\\t\\tif (!result.isEmpty())\\n\\t\\t\\t\\t\\treturn result.get(0).resolve(\\\"feedlist.opml\\\");\\n\\t\\t\\t}\\n\\t\\t\\tcatch (IOException exception) {\\n\\t\\t\\t\\tMLogger.exception(exception);\\n\\t\\t\\t}\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\tprivate ImportFromLifereaAction() {\\n\\t\\t\\tsuper(i18n(\\\"Import RSS Feed List from {0}\\\", \\\"Liferea\\\"), \\\"Liferea\\\");\\n\\t\\t}\\n\\t}\\n\\tstatic final class MarkAllAsReadAction extends MAction { \\t\\n\\t\\tprivate MetaInfo _feed;\\n\\t\\tpublic MarkAllAsReadAction() {\\n\\t\\t\\tsuper(i18n(\\\"Mark All as Read\\\"), \\\"ui/complete\\\");\\n\\t\\t}\\n\\t\\t@Override\\n\\t\\tpublic void onAction() {\\n\\t\\t\\tMetaInfo feed = _feed;\\n\\t\\t\\tif (feed == null)\\n\\t\\t\\t\\tfeed = Tree.getInstance().getCurrentFolder(true);\\n\\t\\t\\tString url = feed.getConfig().read(\\\"x.url\\\", null);\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tArchive.getInstance().markAs(url, Archive.State.READ);\\n\\t\\t\\t\\tFeedsFS.refresh(feed);\\n\\t\\t\\t}\\n\\t\\t\\tcatch (ArchiveException exception) {\\n\\t\\t\\t\\tshowErrorMessage(exception);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tpublic void setFeed(final MetaInfo value) { _feed = value; }\\n\\t}\\n\\tprivate static final class UnreadColor extends Color {\\n\\t\\tprivate UnreadColor(final Color value) {\\n\\t\\t\\tsuper(value.getRGB());\\n\\t\\t}\\n\\t\\tprivate UnreadColor(final int rgb) {\\n\\t\\t\\tsuper(rgb);\\n\\t\\t}\\n\\t}\\n\\tstatic final class GlobalSettingsAction extends MAction {\\n\\t\\tpublic GlobalSettingsAction() {\\n\\t\\t\\tsuper(i18n(\\\"Global Settings...\\\"));\\n\\t\\t}\\n\\t\\t@Override\\n\\t\\tpublic void onAction() {\\n\\t\\t\\tPluginSettings.showPluginOptionsDialog(\\n\\t\\t\\t\\tgetSourceWindow(),\\n\\t\\t\\t\\tMDialog.APPLY_BUTTON,\\n\\t\\t\\t\\tFeedsFS.self().getInfo()\\n\\t\\t\\t);\\n\\t\\t}\\n\\t}\\n}\""
        },
        {
            "content": "The starting entity `FeedsFS.java` is a core component of the `Makagiga` project, implementing various functionalities related to RSS feed handling. It extends `AbstractFS` and implements several interfaces such as `FSDynamic`, `FSNewFile`, `FSOpen`, etc., indicating it has dependencies on multiple other entities.\n\nTo perform Change Impact Analysis (CIA), we need to identify which entities are coupled with `FeedsFS.java`. The next step is to determine coupling dependencies between `FeedsFS.java` and other entities in the system. \n\nI will now analyze its coupling dependencies with one potential dependent entity based on class inheritance and interface implementation clues observed in the code.\n\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_a16891a9683546979f10bd",
                    "function": {
                        "arguments": "{\"entity1\": \"FeedsFS.java\", \"entity2\": \"AbstractFS.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"There are no coupling dependencies between these two entities\"]"
        },
        {
            "content": "It seems there are no direct coupling dependencies between `FeedsFS.java` and `AbstractFS.java`, despite the fact that `FeedsFS` extends `AbstractFS`. This could mean that the dependency is indirect or not captured by the current coupling analysis method.\n\nTo continue with the Change Impact Analysis (CIA), it's important to identify which entities are directly coupled with `FeedsFS.java`. Since our initial check with `AbstractFS.java` did not reveal any coupling dependencies, I will now explore potential coupling with another entity that has a clear relationship with `FeedsFS.java`.\n\nLooking at the implementation details of `FeedsFS`, it implements several interfaces like `FSDynamic`, `FSNewFile`, `FSOpen`, etc. These interface implementations suggest possible dependencies on the corresponding interface definition files. \n\nI will now analyze the coupling dependencies between `FeedsFS.java` and one of these interface files, starting with `FSDynamic.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_dbf332c1d4b94b88a457fd",
                    "function": {
                        "arguments": "{\"entity1\": \"FeedsFS.java\", \"entity2\": \"FSDynamic.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"There are no coupling dependencies between these two entities\"]"
        },
        {
            "content": "Similar to `AbstractFS.java`, there are no direct coupling dependencies between `FeedsFS.java` and `FSDynamic.java`, despite `FeedsFS` implementing the `FSDynamic` interface. This suggests that the coupling might not be captured through direct method calls or field usages, or it could be an issue with how coupling is being analyzed.\n\nSince `FeedsFS` heavily interacts with `MetaInfo` (e.g., methods like `canImport`, `deleteNotify`, and others use `MetaInfo`), we should analyze its coupling with `MetaInfo.java`. This will help determine if there are any direct dependencies affecting `MetaInfo`.\n\nLet's proceed by analyzing the coupling dependencies between `FeedsFS.java` and `MetaInfo.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_c302557841494e03b299a8",
                    "function": {
                        "arguments": "{\"entity1\": \"FeedsFS.java\", \"entity2\": \"MetaInfo.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"There are no coupling dependencies between these two entities\"]"
        },
        {
            "content": "Despite the extensive use of `MetaInfo` within `FeedsFS.java`, there are no detected coupling dependencies between these two entities. This might indicate that the interactions with `MetaInfo` are either highly abstracted or indirect, possibly through inheritance or other mechanisms not captured by direct coupling analysis.\n\nGiven this pattern, it's possible that `FeedsFS.java` has more significant conceptual (semantic) coupling rather than structural coupling with certain entities. To explore this, I will now analyze the **conceptual coupling** between `FeedsFS.java` and one of its key collaborators based on semantic similarity.\n\nSince `FeedsFS` interacts heavily with `FeedDownloader`, which is likely a core collaborator, I will check the conceptual coupling with `FeedDownloader.java`.\n\nLet's proceed with this step.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_da69c03d053b42fe878dec",
                    "function": {
                        "arguments": "{\"entity1\": \"FeedsFS.java\", \"entity2\": \"FeedDownloader.java\"}",
                        "name": "get_conceptual_coupling"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_conceptual_coupling",
            "content": "\"0.70574313\""
        },
        {
            "content": "The conceptual coupling between `FeedsFS.java` and `FeedDownloader.java` is relatively high, with a semantic similarity score of approximately **0.706** (or 70.6%). This indicates that these two entities likely share related functionality or collaborate closely within the system, even if structural dependencies aren't always explicit.\n\nThis strong conceptual link suggests that changes in `FeedsFS.java` could potentially impact `FeedDownloader.java`, and vice versa. As part of Change Impact Analysis (CIA), it would be prudent to inspect this relationship further, especially since `FeedDownloader` appears to play a key role in the RSS feed downloading logic used by `FeedsFS`.\n\nNext, I will examine the call graph for `FeedsFS.java` to identify other entities it directly invokes or interacts with at runtime. This can help uncover additional dependencies that may need synchronization when changes occur.\n\nLet's proceed with retrieving the call graph for `FeedsFS.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_0651847ea2304250988a3e",
                    "function": {
                        "arguments": "{\"entity\": \"FeedsFS.java\"}",
                        "name": "get_call_graph"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_call_graph",
            "content": "[\"Tabs\", \"MApplication\", \"AbstractFS\", \"MColor\", \"FSNewFile\", \"MMenu\", \"Archive\", \"HTMLBuilder\", \"FS\", \"MTimer\", \"MPanel\", \"MCheckBoxTable\", \"OPMLWriter\", \"PluginSettings\", \"MNotification\", \"Flags\", \"FSDynamic\", \"MetaInfo\", \"MMessage\", \"MRadioButton\", \"MainWindow\", \"PluginManager\", \"MButton\", \"MArrayList\", \"MFileChooser\", \"MLogger\", \"PluginMenu\", \"Tree\", \"MDataAction\", \"FSNewFolder\", \"PluginInfo\", \"FileCache\", \"MSlider\", \"MTabbedPane\", \"MV\", \"MToolBar\", \"MAction\", \"Config\", \"FSHelper\", \"MText\", \"OPMLReader\", \"FSOpen\", \"TK\", \"UI\", \"Editor\", \"FSException\", \"MCheckBox\", \"ArchiveException\", \"MDialog\", \"MActionInfo\", \"ItemRenderer\", \"MIcon\", \"FSProperties\"]"
        },
        {
            "content": "The call graph for `FeedsFS.java` reveals a wide range of dependencies, indicating that this entity interacts with many other components in the system. These include core functionalities such as UI handling (`MainWindow`, `MMenu`, `MDialog`), configuration and file management (`Config`, `FSHelper`, `FileCache`), data structures (`Tree`, `MetaInfo`, `MV`), and RSS feed-specific logic (`OPMLReader`, `OPMLWriter`, `Archive`, `FeedDownloader`).\n\nKey entities that are likely to be impacted by changes in `FeedsFS.java` include:\n\n- **FeedDownloader.java** \u2013 Already shown to have high conceptual coupling.\n- **Archive.java** \u2013 Used heavily for managing RSS feed archives.\n- **OPMLReader.java / OPMLWriter.java** \u2013 Handle import/export of RSS feeds.\n- **MetaInfo.java** \u2013 Central to folder and file metadata management.\n- **Tree.java** \u2013 Manages navigation structure within the application.\n- **PluginInfo.java / PluginMenu.java** \u2013 Related to plugin functionality.\n\nTo ensure synchronization and proper change impact analysis, we should further examine structural or conceptual coupling with these key entities.\n\nLet\u2019s begin by checking coupling dependencies between `FeedsFS.java` and `Archive.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_1bb3c9aba4ea446a84cecb",
                    "function": {
                        "arguments": "{\"entity1\": \"FeedsFS.java\", \"entity2\": \"Archive.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"There are no coupling dependencies between these two entities\"]"
        },
        {
            "role": "user",
            "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
        },
        {
            "content": "Title: Diagnosis of starting entity `FeedsFS.java`  \nChange set: [FeedDownloader, Archive, OPMLReader, OPMLWriter, MetaInfo, Tree, PluginInfo, PluginMenu, MainWindow, MMenu, Config, FSHelper, FileCache, MNotification, MDialog, Editor, MAction, MButton, MPanel, MRadioButton, MCheckBox, MSlider, MToolBar, MTabbedPane, MV, UI, TK, MLogger, MMessage, Flags, FSException, ItemRenderer, MIcon, MColor, AbstractFS, FSDynamic, FSNewFile, FSNewFolder, FSOpen, FSProperties, MArrayList]  \n\nDetails:  \n- **FeedDownloader**: Strong conceptual coupling (0.706 similarity) and heavily used for feed downloading logic.  \n- **Archive**: Central to RSS feed archiving functionality and frequently accessed in methods like `download`, `refresh`, and `applyProperties`.  \n- **OPMLReader / OPMLWriter**: Used for importing/exporting feeds; key part of data interchange functionality in `FeedsFS`.  \n- **MetaInfo**: Widely used throughout the codebase for managing metadata of RSS items and folders.  \n- **Tree**: Manages folder/item hierarchy and expansion/collapsing behavior during feed updates.  \n- **PluginInfo / PluginMenu**: As a plugin-based feature, `FeedsFS` integrates with plugin infrastructure.  \n- **MainWindow**: Involved in UI interactions such as dialog display, tab management, and tree navigation.  \n- **MMenu**: Part of the menu structure that `FeedsFS` dynamically updates based on context.  \n- **Config**: Used extensively to store and retrieve feed settings like URLs, archive policies, etc.  \n- **FSHelper**: Used for file naming, escaping, and path manipulation tasks.  \n- **FileCache**: Used for favicon caching and resource cleanup.  \n- **MNotification**: Alerts users about feed-related events like errors or updates.  \n- **MDialog**: Used when showing user prompts during import/export or settings adjustment.  \n- **Editor**: Manages tabbed interface for viewing individual articles.  \n- **MAction / MButton**: Core UI components tied to actions like refresh, import, export, etc.  \n- **MPanel / MRadioButton / MCheckBox / MSlider**: UI elements used in property panels and dialogs.  \n- **MToolBar / MTabbedPane**: UI layout components affected by feed operations.  \n- **MV**: Used in scanning and listing feed items.  \n- **UI / TK / MLogger / MMessage**: Utility classes used across the implementation for general-purpose functions.  \n- **Flags**: Used for capability checks and state flags in meta info handling.  \n- **FSException**: Thrown during exceptional conditions in feed creation or I/O.  \n- **ItemRenderer**: Responsible for rendering visual properties like colors and icons in the tree view.  \n- **MIcon / MColor**: Used for icon overlays and unread color customization.  \n- **AbstractFS**: Base class providing core filesystem abstraction, though no direct coupling found.  \n- **FSDynamic / FSNewFile / FSNewFolder / FSOpen / FSProperties**: Interfaces implemented by `FeedsFS`; despite no direct coupling found, they are integral to its contract.  \n- **MArrayList**: Used in processing lists of feeds or articles.",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        }
    ],
    "interaction_records": {
        "step_histories": [
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m3",
                    "m9",
                    "m10",
                    "m4",
                    "m11",
                    "m7",
                    "m12",
                    "m4",
                    "m13",
                    "m3",
                    "m3",
                    "m14",
                    "m4",
                    "m10",
                    "m7",
                    "m4",
                    "m15",
                    "m13",
                    "m15",
                    "m16",
                    "m11",
                    "m17",
                    "m3",
                    "m4",
                    "m18",
                    "m19",
                    "m4",
                    "m20",
                    "m21",
                    "m15",
                    "m22",
                    "m15",
                    "m23",
                    "m18",
                    "m23",
                    "m15",
                    "m20",
                    "m24",
                    "m4",
                    "m15",
                    "m4",
                    "m25",
                    "m3",
                    "m16",
                    "m16",
                    "m26",
                    "m22",
                    "m13",
                    "m7",
                    "m25",
                    "m13",
                    "m4",
                    "m27",
                    "m15",
                    "m28",
                    "m15",
                    "m4",
                    "m7",
                    "m5",
                    "m3",
                    "m13",
                    "m4",
                    "m19",
                    "m7",
                    "m12",
                    "m6",
                    "m9",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m3",
                    "m9",
                    "m10",
                    "m29",
                    "m4",
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m19",
                    "m10",
                    "m15",
                    "m6",
                    "m10",
                    "m18",
                    "m13",
                    "m23",
                    "m4",
                    "m3",
                    "m13",
                    "m10",
                    "m18",
                    "m10",
                    "m11",
                    "m4",
                    "m11",
                    "m7",
                    "m12",
                    "m4",
                    "m13",
                    "m3",
                    "m3",
                    "m14",
                    "m4",
                    "m10",
                    "m7",
                    "m4",
                    "m14",
                    "m3",
                    "m15",
                    "m16",
                    "m4",
                    "m25",
                    "m18",
                    "m10",
                    "m2",
                    "m4",
                    "m18",
                    "m19",
                    "m4",
                    "m30",
                    "m3",
                    "m3",
                    "m14",
                    "m19",
                    "m30",
                    "m31",
                    "m29",
                    "m8",
                    "m15",
                    "m28",
                    "m15",
                    "m29"
                ],
                "response_message": "m32"
            },
            {
                "prompt_messages": [
                    "m33",
                    "m34",
                    "m32",
                    "m35"
                ],
                "response_message": "m36"
            },
            {
                "prompt_messages": [
                    "m33",
                    "m34",
                    "m32",
                    "m35",
                    "m36",
                    "m37"
                ],
                "response_message": "m38"
            },
            {
                "prompt_messages": [
                    "m33",
                    "m34",
                    "m32",
                    "m35",
                    "m36",
                    "m37",
                    "m38",
                    "m37"
                ],
                "response_message": "m39"
            },
            {
                "prompt_messages": [
                    "m33",
                    "m34",
                    "m32",
                    "m35",
                    "m36",
                    "m37",
                    "m38",
                    "m37",
                    "m39",
                    "m37"
                ],
                "response_message": "m40"
            },
            {
                "prompt_messages": [
                    "m33",
                    "m34",
                    "m32",
                    "m35",
                    "m36",
                    "m37",
                    "m38",
                    "m37",
                    "m39",
                    "m37",
                    "m40",
                    "m41"
                ],
                "response_message": "m42"
            },
            {
                "prompt_messages": [
                    "m33",
                    "m34",
                    "m32",
                    "m35",
                    "m36",
                    "m37",
                    "m38",
                    "m37",
                    "m39",
                    "m37",
                    "m40",
                    "m41",
                    "m42",
                    "m43"
                ],
                "response_message": "m44"
            },
            {
                "prompt_messages": [
                    "m33",
                    "m34",
                    "m32",
                    "m35",
                    "m36",
                    "m37",
                    "m38",
                    "m37",
                    "m39",
                    "m37",
                    "m40",
                    "m41",
                    "m42",
                    "m43",
                    "m44",
                    "m37",
                    "m45"
                ],
                "response_message": "m46"
            }
        ],
        "mid_to_message": {
            "m1": "T",
            "m2": "h",
            "m3": "e",
            "m4": " ",
            "m5": "p",
            "m6": "r",
            "m7": "o",
            "m8": "j",
            "m9": "c",
            "m10": "t",
            "m11": "y",
            "m12": "u",
            "m13": "n",
            "m14": "d",
            "m15": "a",
            "m16": "l",
            "m17": "z",
            "m18": "i",
            "m19": "s",
            "m20": "`",
            "m21": "M",
            "m22": "k",
            "m23": "g",
            "m24": ",",
            "m25": "w",
            "m26": "-",
            "m27": "J",
            "m28": "v",
            "m29": ".",
            "m30": "F",
            "m31": "S",
            "m32": {
                "content": "",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_c08448592c7e470d93274b",
                        "function": {
                            "arguments": "{\"entity\": \"FeedsFS.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m33": {
                "role": "system",
                "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
            },
            "m34": {
                "role": "user",
                "content": "The project you need to analyze is `Makagiga`, a well-known Java open source project. The starting entity you need to deal with is FeedsFS.java."
            },
            "m35": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package org.makagiga.fs.feeds;\\nimport static org.makagiga.commons.UI.i18n;\\nimport java.awt.Color;\\nimport java.awt.Image;\\nimport java.awt.Window;\\nimport java.io.File;\\nimport java.io.IOException;\\nimport java.net.URL;\\nimport java.nio.file.Files;\\nimport java.nio.file.Path;\\nimport java.nio.file.Paths;\\nimport java.security.AccessControlContext;\\nimport java.security.AccessController;\\nimport java.util.Comparator;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.Objects;\\nimport java.util.StringJoiner;\\nimport java.util.TreeSet;\\nimport java.util.concurrent.TimeUnit;\\nimport java.util.stream.Collectors;\\nimport java.util.stream.Stream;\\nimport javax.swing.Action;\\nimport javax.swing.Icon;\\nimport org.makagiga.MainWindow;\\nimport org.makagiga.Tabs;\\nimport org.makagiga.Vars;\\nimport org.makagiga.commons.Config;\\nimport org.makagiga.commons.FS;\\nimport org.makagiga.commons.Flags;\\nimport org.makagiga.commons.MAction;\\nimport org.makagiga.commons.MActionInfo;\\nimport org.makagiga.commons.MApplication;\\nimport org.makagiga.commons.MColor;\\nimport org.makagiga.commons.MDataAction;\\nimport org.makagiga.commons.MFormat;\\nimport org.makagiga.commons.MIcon;\\nimport org.makagiga.commons.MLogger;\\nimport org.makagiga.commons.TK;\\nimport org.makagiga.commons.Tuple;\\nimport org.makagiga.commons.UI;\\nimport org.makagiga.commons.cache.FileCache;\\nimport org.makagiga.commons.html.HTMLBuilder;\\nimport org.makagiga.commons.mv.MV;\\nimport org.makagiga.commons.swing.MButton;\\nimport org.makagiga.commons.swing.MCheckBox;\\nimport org.makagiga.commons.swing.MCheckBoxTable;\\nimport org.makagiga.commons.swing.MDialog;\\nimport org.makagiga.commons.swing.MFileChooser;\\nimport org.makagiga.commons.swing.MMenu;\\nimport org.makagiga.commons.swing.MMessage;\\nimport org.makagiga.commons.swing.MNotification;\\nimport org.makagiga.commons.swing.MPanel;\\nimport org.makagiga.commons.swing.MRadioButton;\\nimport org.makagiga.commons.swing.MSlider;\\nimport org.makagiga.commons.swing.MSmallButton;\\nimport org.makagiga.commons.swing.MStatusBar;\\nimport org.makagiga.commons.swing.MTabbedPane;\\nimport org.makagiga.commons.swing.MTimer;\\nimport org.makagiga.commons.swing.MToolBar;\\nimport org.makagiga.editors.Editor;\\nimport org.makagiga.feeds.archive.Archive;\\nimport org.makagiga.feeds.archive.ArchiveException;\\nimport org.makagiga.feeds.opml.OPMLReader;\\nimport org.makagiga.feeds.opml.OPMLWriter;\\nimport org.makagiga.fs.AbstractFS;\\nimport org.makagiga.fs.FSDynamic;\\nimport org.makagiga.fs.FSException;\\nimport org.makagiga.fs.FSHelper;\\nimport org.makagiga.fs.FSNewFile;\\nimport org.makagiga.fs.FSNewFolder;\\nimport org.makagiga.fs.FSOpen;\\nimport org.makagiga.fs.FSProperties;\\nimport org.makagiga.fs.FSQuery;\\nimport org.makagiga.fs.MetaInfo;\\nimport org.makagiga.plugins.PluginInfo;\\nimport org.makagiga.plugins.PluginMenu;\\nimport org.makagiga.plugins.PluginSettings;\\nimport org.makagiga.search.Query;\\nimport org.makagiga.tree.ItemRenderer;\\nimport org.makagiga.tree.Tree;\\nimport org.makagiga.web.Favicon;\\npublic final class FeedsFS extends AbstractFS\\nimplements\\n\\tFSDynamic,\\n\\tFSNewFile,\\n\\tFSNewFolder,\\n\\tFSOpen,\\n\\tFSProperties,\\n\\tFSQuery,\\n\\tPluginMenu\\n{\\n\\tpublic static final int USE_EXCLUDE_FROM_FETCH_ALL_FEEDS = 1;\\n\\tpublic static final int USE_EXCLUDE_FROM_INTERVAL_FETCH = 1 << 1;\\n\\tpublic static final int FETCH_OFFLINE = 1 << 2;\\n\\tprivate ArchiveOptions archiveOptions;\\n\\tprivate Color unreadColor = DEFAULT_UNREAD_COLOR;\\n\\tprivate CustomAdvancedPanel customAdvancedPanel;\\n\\tprivate MAction filtersAction;\\n\\tprivate MAction markAllAsReadAction;\\n\\tprivate static final MLogger log = MLogger.get(\\\"feeds\\\");\\n\\tprivate MetaInfo currentImportFolder;\\n\\tprivate final MTimer intervalFetchTimer;\\n\\tfinal AccessControlContext acc;\\n\\tstatic final Color DEFAULT_UNREAD_COLOR = new UnreadColor(0xb1d28f);\\n\\tFetchAllFeedsAction fetchAllFeedsAction = new FetchAllFeedsAction();\\n\\t@Override\\n\\tpublic boolean canImport(final MetaInfo metaInfo) {\\n\\t\\tif (!super.canImport(metaInfo))\\n\\t\\t\\treturn false;\\n\\t\\treturn metaInfo.isAnyFolder();\\n\\t}\\n\\t@Override\\n\\tpublic void deleteNotify(final MetaInfo metaInfo, final boolean move) {\\n\\t\\tif (!move && metaInfo.isDynamicFolder()) {\\n\\t\\t\\tConfig config = metaInfo.getConfig();\\n\\t\\t\\tString url = config.read(\\\"x.url\\\", null);\\n\\t\\t\\tif (url != null) {\\n\\t\\t\\t\\tFeedDownloader.abort(metaInfo);\\n\\t\\t\\t\\tFileCache cache = FileCache.getInstance();\\n\\t\\t\\t\\tcache.getGroup(\\\"feed\\\").remove(url);\\n\\t\\t\\t\\t\\t\\t\\t\\tif (!MNotification.isEmpty()) {\\n\\t\\t\\t\\t\\tfor (MNotification.Message i : MNotification.getInstance()) {\\n\\t\\t\\t\\t\\t\\tAction action = i.getAction();\\n\\t\\t\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\t\\t\\t(action instanceof FeedThread.Action) &&\\n\\t\\t\\t\\t\\t\\t\\t(FeedThread.Action.class.cast(action).getParent() == metaInfo)\\n\\t\\t\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\t\\t\\ti.hide();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tpublic void fetchFeeds(final int flags) {\\n\\t\\tfetchFeeds(getRoot(), flags);\\n\\t}\\n\\tpublic void fetchFeeds(final MetaInfo folder, final int flags) {\\n\\t\\tif (FeedDownloader.isActive())\\n\\t\\t\\treturn;\\n\\t\\tnew Tree.Scanner(folder) {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic void processItem(final MetaInfo item) {\\n\\t\\t\\t\\tdownload(item, false, flags);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\t\\tif (FeedDownloader.isActive()) {\\n\\t\\t\\tboolean fetchOffline = (flags & FETCH_OFFLINE) != 0;\\n\\t\\t\\tFeedDownloader.setFetchMode(this, false, fetchOffline);\\n\\t\\t}\\n\\t}\\n\\tpublic Color getUnreadColor() {\\n\\t\\treturn TK.get(unreadColor, DEFAULT_UNREAD_COLOR);\\n\\t}\\n\\tpublic void setUnreadColor(final Color value) {\\n\\t\\tunreadColor = (value == null) ? null : new UnreadColor(value);\\n\\t}\\n\\t@Override\\n\\tpublic void setupItemRenderer(final ItemRenderer renderer, final MetaInfo item) {\\n\\t\\tif (item instanceof ArticleMetaInfo) {\\n\\t\\t\\tArticleMetaInfo article = (ArticleMetaInfo)item;\\n\\t\\t\\titem.setColor(getColor(article));\\n\\t\\t}\\n\\t\\telse if (item.isDynamicFolder()) {\\n\\t\\t\\tif (Boolean.TRUE.equals(item.getProperty(\\\"feed.no-favicon\\\", false))) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tMIcon icon = Vars.treeSmallIcons.get() ? item.getSmallIcon() : item.getIcon();\\n\\t\\t\\tif (icon == null)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\tif (icon.getOverlay() != null)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tImage favicon = item.getProperty(\\\"feed.favicon\\\", null);\\n\\t\\t\\tif (favicon == null) {\\n\\t\\t\\t\\tString url = item.getConfig().read(\\\"x.faviconURL\\\", \\\"\\\");\\n\\t\\t\\t\\tif (url.isEmpty()) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\titem.setProperty(\\\"feed.no-favicon\\\", true);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfavicon = Favicon.getCachedImage(new URL(url), 16);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch (IOException exception) {\\n\\t\\t\\t\\t\\tMLogger.developerException(exception);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (favicon == null) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\titem.setProperty(\\\"feed.no-favicon\\\", true);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\titem.setProperty(\\\"feed.favicon\\\", favicon);\\n\\t\\t\\t}\\n\\t\\t\\ticon.setOverlay(favicon);\\n\\t\\t}\\n\\t}\\n\\t@Override\\n\\tpublic void applyProperties(final MetaInfo[] selection) {\\n\\t\\tif (selection.length > 1)\\n\\t\\t\\treturn;\\n\\t\\tMetaInfo metaInfo = selection[0];\\n\\t\\tif (!metaInfo.isDynamicFolder() || !(metaInfo.getFS() instanceof FeedsFS))\\n\\t\\t\\treturn;\\n\\t\\t\\t\\tConfig config = metaInfo.getConfig();\\n\\t\\tconfig.write(\\\"x.archivePolicy\\\", archiveOptions.getPolicy().name());\\n\\t\\tconfig.write(\\\"x.blockImages\\\", customAdvancedPanel.blockImagesCheckBox.isSelected());\\n\\t\\tconfig.write(\\\"x.excludeFromFetchAllFeeds\\\", customAdvancedPanel.excludeFromFetchAllFeeds.isSelected());\\n\\t\\tconfig.write(\\\"x.excludeFromIntervalFetch\\\", customAdvancedPanel.excludeFromIntervalFetch.isSelected());\\n\\t\\tconfig.write(\\\"x.removeArticlesAfter\\\", archiveOptions.getDays());\\n\\t\\tconfig.write(\\\"x.showFullPage\\\", customAdvancedPanel.showFullPageCheckBox.isSelected());\\n\\t\\t\\t\\tif (customAdvancedPanel.shouldRefresh())\\n\\t\\t\\trefresh(metaInfo);\\n\\t}\\n\\t@Override\\n\\tpublic void freeProperties() {\\n\\t\\tarchiveOptions = null;\\n\\t\\tcustomAdvancedPanel = null;\\n\\t}\\n\\t@Override\\n\\tpublic Flags getMetaInfoCapabilities(final MetaInfo metaInfo) {\\n\\t\\treturn Flags.valueOf(META_INFO_CATEGORY | META_INFO_COLOR | META_INFO_COMMENT | META_INFO_ICON | META_INFO_RATING | META_INFO_TAGS);\\n\\t}\\n\\t@Override\\n\\tpublic void initProperties(final MTabbedPane<MPanel> tabs, final MetaInfo[] selection) {\\n\\t\\tif (selection.length > 1)\\n\\t\\t\\treturn;\\n\\t\\tfinal MetaInfo metaInfo = selection[0];\\n\\t\\tif (!metaInfo.isDynamicFolder() || !(metaInfo.getFS() instanceof FeedsFS))\\n\\t\\t\\treturn;\\n\\t\\tfinal Config config = metaInfo.getConfig();\\n\\t\\tMPanel advancedTab = tabs.getTabAt(ADVANCED_TAB);\\n\\t\\ttabs.setEnabledAt(ADVANCED_TAB, true);\\n\\t\\ttabs.setIconAt(ADVANCED_TAB, getSmallIcon());\\n\\t\\ttabs.setTitleAt(ADVANCED_TAB, i18n(\\\"RSS Feed\\\"));\\n\\t\\tarchiveOptions = new ArchiveOptions(false);\\n\\t\\tFeedsFSPlugin plugin = getFeedsFSPlugin();\\n\\t\\tFeedsFSPlugin.Settings settings = plugin.readSettings(metaInfo, false);\\n\\t\\tarchiveOptions.setDays(settings.removeArticlesAfter, settings.archivePolicy);\\n\\t\\tadvancedTab.add(archiveOptions);\\n\\t\\tcustomAdvancedPanel = new CustomAdvancedPanel();\\n\\t\\tcustomAdvancedPanel.showExpiredArticlesAgainButton.addActionListener(e -> {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tcustomAdvancedPanel.showExpiredArticlesAgainButton.setEnabled(false);\\n\\t\\t\\t\\tcustomAdvancedPanel.showExpiredArticlesAgainButton.setIcon(MIcon.small(\\\"ui/ok\\\"));\\n\\t\\t\\t\\tString url = config.read(\\\"x.url\\\", null);\\n\\t\\t\\t\\tArchive.getInstance().removeExpiredInfo(url);\\n\\t\\t\\t}\\n\\t\\t\\tcatch (ArchiveException exception) {\\n\\t\\t\\t\\tMLogger.developerException(exception);\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t\\tcustomAdvancedPanel.blockImagesCheckBox.setAndRemember(config.read(\\\"x.blockImages\\\", false));\\n\\t\\tcustomAdvancedPanel.excludeFromFetchAllFeeds.setSelected(config.read(\\\"x.excludeFromFetchAllFeeds\\\", false));\\n\\t\\tcustomAdvancedPanel.excludeFromIntervalFetch.setSelected(config.read(\\\"x.excludeFromIntervalFetch\\\", false));\\n\\t\\tcustomAdvancedPanel.showFullPageCheckBox.setSelected(config.read(\\\"x.showFullPage\\\", false));\\n\\t\\tadvancedTab.add(customAdvancedPanel);\\n\\t}\\n\\t@Override\\n\\tpublic void lockProperties(final boolean locked) {\\n\\t\\tif (archiveOptions != null) {\\n\\t\\t\\tarchiveOptions.days.setEnabled(!locked);\\n\\t\\t\\tarchiveOptions.doNotRemoveArticles.setEnabled(!locked);\\n\\t\\t\\tarchiveOptions.removeArticles.setEnabled(!locked);\\n\\t\\t\\tarchiveOptions.useGlobalSettings.setEnabled(!locked);\\n\\t\\t}\\n\\t\\tif (customAdvancedPanel != null) {\\n\\t\\t\\tcustomAdvancedPanel.blockImagesCheckBox.setEnabled(!locked);\\n\\t\\t\\tcustomAdvancedPanel.excludeFromFetchAllFeeds.setEnabled(!locked);\\n\\t\\t\\tcustomAdvancedPanel.excludeFromIntervalFetch.setEnabled(!locked);\\n\\t\\t\\tcustomAdvancedPanel.showFullPageCheckBox.setEnabled(!locked);\\n\\t\\t}\\n\\t}\\n\\t@Override\\n\\tpublic Icon getNewFileActionIcon(final MIcon.Size size) {\\n\\t\\treturn MIcon.stock(\\\"ui/feed\\\", size);\\n\\t}\\n\\t@Override\\n\\tpublic String getNewFileActionText() {\\n\\t\\treturn i18n(\\\"Add RSS Feed\\\");\\n\\t}\\n\\t@Override\\n\\tpublic String getNewFileDefaultName() {\\n\\t\\treturn i18n(\\\"New RSS Feed\\\");\\n\\t}\\n\\t@Override\\n\\tpublic MetaInfo newFile(final Window owner, final MetaInfo parent) throws FSException {\\n\\t\\treturn newFile(parent, null);\\n\\t}\\n\\t@Override\\n\\tpublic Action getNewFileAction() {\\n\\t\\treturn new MAction(getNewFileActionText(), \\\"ui/feed\\\", action -> {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tnewFile(action.getSourceWindow(), getRoot());\\n\\t\\t\\t}\\n\\t\\t\\tcatch (FSException exception) {\\n\\t\\t\\t\\taction.showErrorMessage(exception);\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t}\\n\\t@Override\\n\\tpublic int getNewFileOptions() {\\n\\t\\treturn NEW_FILE_OPTION_SHOW_IN_MENU;\\n\\t}\\n\\tpublic MetaInfo newFile(final MetaInfo parent, final String link) throws FSException {\\n\\t\\tMainWindow mainWindow = MainWindow.getInstance();\\n\\t\\tAddFeedDialog addFeedDialog = new AddFeedDialog(\\n\\t\\t\\tmainWindow.isActive() ? mainWindow : null,\\n\\t\\t\\tlink,\\n\\t\\t\\tthis\\n\\t\\t);\\n\\t\\tif (!addFeedDialog.exec())\\n\\t\\t\\treturn null;\\n\\t\\tString url = addFeedDialog.getNewURL();\\n\\t\\tif (alreadyExists(null, url))\\n\\t\\t\\treturn null;\\n\\t\\tMetaInfo feedMetaInfo = createUniqueDynamicFolder(parent, addFeedDialog.getNewFileName());\\n\\t\\tif (feedMetaInfo != null) {\\n\\t\\t\\tConfig config = feedMetaInfo.getConfig();\\n\\t\\t\\tconfig.write(\\\"x.blockImages\\\", addFeedDialog.getBlockImages());\\n\\t\\t\\tconfig.write(\\\"x.excludeFromFetchAllFeeds\\\", addFeedDialog.getExcludeFromFetchAllFeeds());\\n\\t\\t\\tconfig.write(\\\"x.url\\\", url);\\n\\t\\t\\tfeedMetaInfo.sync();\\n\\t\\t\\tTree.getInstance().open(feedMetaInfo);\\n\\t\\t}\\n\\t\\treturn feedMetaInfo;\\n\\t}\\n\\t@Override\\n\\tpublic void setMetaInfoProperty(final MetaInfo metaInfo, final int key, final Object value) {\\n\\t\\tif (!(metaInfo instanceof ArticleMetaInfo))\\n\\t\\t\\treturn;\\n\\t\\tArticleMetaInfo article = (ArticleMetaInfo)metaInfo;\\n\\t\\tboolean repaintArticleList = false;\\n\\t\\tString propertyKey;\\n\\t\\tswitch (key) {\\n\\t\\t\\tcase META_INFO_CATEGORY:\\n\\t\\t\\t\\tpropertyKey = Archive.CATEGORY_PROPERTY;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase META_INFO_COLOR:\\n\\t\\t\\t\\tpropertyKey = Archive.COLOR_PROPERTY;\\n\\t\\t\\t\\tarticle.setColor((Color)value);\\n\\t\\t\\t\\trepaintArticleList = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase META_INFO_COMMENT:\\n\\t\\t\\t\\tpropertyKey = Archive.COMMENT_PROPERTY;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase META_INFO_ICON:\\n\\t\\t\\t\\tpropertyKey = Archive.ICON_PROPERTY;\\n\\t\\t\\t\\tif (value == null)\\n\\t\\t\\t\\t\\tmetaInfo.clearIcon();\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmetaInfo.setIconName((String)value);\\n\\t\\t\\t\\trepaintArticleList = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase META_INFO_RATING:\\n\\t\\t\\t\\tpropertyKey = Archive.RATING_PROPERTY;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase META_INFO_TAGS:\\n\\t\\t\\t\\tpropertyKey = Archive.TAGS_PROPERTY;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tthrow new IllegalArgumentException(\\\"Unknown \\\\\\\"key\\\\\\\" value: \\\" + key);\\n\\t\\t}\\n\\t\\tString url = metaInfo.getParentFolder().getConfig().read(\\\"x.url\\\", null);\\n\\t\\tString id = article.getID();\\n\\t\\ttry {\\n\\t\\t\\tArchive.getInstance().setItemProperty(url, id, new Archive.ItemProperty(propertyKey, value));\\n\\t\\t}\\n\\t\\tcatch (ArchiveException exception) {\\n\\t\\t\\tMLogger.exception(exception);\\n\\t\\t}\\n\\t\\tif (repaintArticleList) {\\n\\t\\t\\tEditor<?> tab = Tabs.getInstance().getSelectedTab();\\n\\t\\t\\tif (tab instanceof FeedViewer)\\n\\t\\t\\t\\tFeedViewer.class.cast(tab).getArticleList().repaint();\\n\\t\\t}\\n\\t}\\n\\t@Override\\n\\tpublic void updateInfo(final MetaInfo metaInfo, final HTMLBuilder html) {\\n\\t\\tif (metaInfo.isDynamicFolder()) {\\n\\t\\t\\tConfig config = metaInfo.getConfig();\\n\\t\\t\\tMetaInfo.addSeparator(html);\\n\\t\\t\\tMetaInfo.addInfo(html, i18n(\\\"RSS Feed Address:\\\"), TK.centerSqueeze(config.read(\\\"x.url\\\", null), 128));\\n\\t\\t}\\n\\t}\\n\\t@Override\\n\\tpublic boolean dynamic(final int flags, final MetaInfo parent) throws FSException {\\n\\t\\tif (parent.isDynamicFolder() && checkOffline())\\n\\t\\t\\treturn false;\\n\\t\\t\\t\\treturn download(parent, true, 0);\\n\\t}\\n\\t@Override\\n\\tpublic void open(final int flags, final MetaInfo metaInfo) throws FSException {\\n\\t\\tif (!metaInfo.isVirtualFile())\\n\\t\\t\\treturn;\\n\\t\\tMetaInfo parent = metaInfo.getParentFolder();\\n\\t\\t\\t\\tif (parent == null) \\t\\t\\treturn;\\n\\t\\tFeedViewer viewer = null;\\n\\t\\tTabs tabs = Tabs.getInstance();\\n\\t\\t\\t\\tList<FeedViewer> tabList = Editor.findEditor(FeedViewer.class);\\n\\t\\tfor (FeedViewer editor : tabList) {\\n\\t\\t\\tif (\\n\\t\\t\\t\\t(editor.getMetaInfo() != null) &&\\n\\t\\t\\t\\t(editor.getMetaInfo().getParentFolder() == parent)\\n\\t\\t\\t) {\\n\\t\\t\\t\\tviewer = editor;\\n\\t\\t\\t\\tif (editor.getMetaInfo() == metaInfo)\\n\\t\\t\\t\\t\\tbreak; \\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (viewer == null) {\\n\\t\\t\\tfor (FeedViewer editor : tabList) {\\n\\t\\t\\t\\tviewer = editor;\\n\\t\\t\\t\\tif (editor.getMetaInfo() == metaInfo)\\n\\t\\t\\t\\t\\tbreak; \\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tif (viewer != null) {\\n\\t\\t\\tMetaInfo viewerParent = viewer.getMetaInfo().getParentFolder();\\n\\t\\t\\tif ((viewerParent != null) && (viewerParent != parent)) {\\n\\t\\t\\t\\tTree tree = Tree.getInstance();\\n\\t\\t\\t\\ttree.setExpanded(viewerParent, false);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tboolean openInNewTab = (flags & FSOpen.MIDDLE_BUTTON) != 0;\\n\\t\\tboolean sameMetaInfo = (viewer != null) && (viewer.getMetaInfo() == metaInfo);\\n\\t\\t\\t\\tif ((viewer == null) || (openInNewTab && !sameMetaInfo)) {\\n\\t\\t\\tviewer = new FeedViewer();\\n\\t\\t\\tviewer.setMetaInfo(metaInfo);\\n\\t\\t\\ttabs.addEditor(viewer);\\n\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\tif (!sameMetaInfo) {\\n\\t\\t\\t\\tMetaInfo old = viewer.getMetaInfo();\\n\\t\\t\\t\\ttabs.addRecentlyClosedTab(old);\\n\\t\\t\\t\\told.setOpen(false);\\n\\t\\t\\t\\told.refresh(true);\\n\\t\\t\\t\\tviewer.setMetaInfo(metaInfo);\\n\\t\\t\\t}\\n\\t\\t\\tmetaInfo.setOpen(true);\\n\\t\\t\\ttabs.selectEditor(viewer);\\n\\t\\t\\ttabs.setTabInfo(viewer, metaInfo);\\n\\t\\t\\tMainWindow.getInstance().updateState();\\n\\t\\t}\\n\\t\\tif (metaInfo instanceof ArticleMetaInfo) {\\n\\t\\t\\tArticleMetaInfo article = (ArticleMetaInfo)metaInfo;\\n\\t\\t\\t\\t\\t\\tarticle.setUnread(false);\\n\\t\\t}\\n\\t\\tupdateInfo(parent); \\n\\t\\tif (!sameMetaInfo)\\n\\t\\t\\tviewer.loadFromMetaInfo(parent, metaInfo);\\n\\t\\t\\t\\tmetaInfo.refresh(true);\\n\\t}\\n\\t@Override\\n\\tpublic boolean matches(final Query query, final MetaInfo metaInfo) {\\n\\t\\tif (!metaInfo.isDynamicFolder())\\n\\t\\t\\treturn false;\\n\\t\\t\\t\\tQuery.Criterium criterium = query.getCriteria().get(Query.KEYWORDS);\\n\\t\\tif (criterium != null) {\\n\\t\\t\\tConfig config = metaInfo.getConfig();\\n\\t\\t\\tString url = config.read(\\\"x.url\\\", null);\\n\\t\\t\\tif (url != null) {\\n\\t\\t\\t\\tfor (String i : criterium.getKeywords()) {\\n\\t\\t\\t\\t\\tif (TK.containsIgnoreCase(url, i))\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\t@Override\\n\\tpublic void updateMenu(final String type, final MMenu menu) {\\n\\t\\tif (type.equals(EXPORT_MENU)) {\\n\\t\\t\\tmenu.addSeparator(false);\\n\\t\\t\\tMetaInfo folder = Tree.getInstance().getCurrentFolder(true);\\n\\t\\t\\tString text = folder.isFSRoot() ? i18n(\\\"Export All Feeds\\\") : i18n(\\\"Export \\\\\\\"{0}\\\\\\\" Feeds\\\", folder);\\n\\t\\t\\tmenu.add(new ExportAction(text));\\n\\t\\t}\\n\\t\\telse if (type.equals(IMPORT_MENU)) {\\n\\t\\t\\tmenu.addSeparator(false);\\n\\t\\t\\tmenu.add(new ImportAction());\\n\\t\\t\\tmenu.add(new ImportFromLifereaAction());\\n\\t\\t}\\n\\t\\telse if (type.equals(TREE_MENU)) {\\n\\t\\t\\tMetaInfo feed = Tree.getInstance().getCurrentFolder(true);\\n\\t\\t\\tif (FeedDownloader.isActive())\\n\\t\\t\\t\\tmenu.add(fetchAllFeedsAction);\\n\\t\\t\\telse\\n\\t\\t\\t\\tmenu.add(new FetchFeedsAction(feed));\\n\\t\\t\\tif (filtersAction == null)\\n\\t\\t\\t\\tfiltersAction = new Filters.FiltersAction();\\n\\t\\t\\tif (markAllAsReadAction == null)\\n\\t\\t\\t\\tmarkAllAsReadAction = new MarkAllAsReadAction();\\n\\t\\t\\tif (\\n\\t\\t\\t\\t(feed.getFS() instanceof FeedsFS) &&\\n\\t\\t\\t\\tfeed.isDynamicFolder()\\n\\t\\t\\t) {\\n\\t\\t\\t\\tfiltersAction.setEnabled(feed.isWriteable());\\n\\t\\t\\t\\tfiltersAction.setName(i18n(\\\"RSS Filters: {0}\\\", TK.centerSqueeze(feed.toString(), 15)));\\n\\t\\t\\t\\tmarkAllAsReadAction.setEnabled(true);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tfiltersAction.setEnabled(false);\\n\\t\\t\\t\\tfiltersAction.setName(i18n(\\\"RSS Filters...\\\"));\\n\\t\\t\\t\\tmarkAllAsReadAction.setEnabled(false);\\n\\t\\t\\t}\\n\\t\\t\\tmenu.add(filtersAction);\\n\\t\\t\\tmenu.add(markAllAsReadAction);\\n\\t\\t}\\n\\t}\\n\\t@Override\\n\\tpublic void updateToolBar(final String type, final MToolBar toolBar) { }\\n\\tFeedsFS(final PluginInfo info) throws FSException { \\t\\tsuper(info, \\\"feeds\\\", i18n(\\\"RSS Feeds\\\"));\\n\\t\\tacc = AccessController.getContext();\\n\\t\\tscan();\\n\\t\\t\\t\\tConfig config = Config.getDefault();\\n\\t\\tif (getRoot().isEmpty(MV.MODEL) && config.read(\\\"Feeds.createSamples\\\", true)) {\\n\\t\\t\\tconfig.write(\\\"Feeds.createSamples\\\", false);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\taddSample(\\\"How-To Geek\\\", \\\"ui/console\\\", \\\"http:\\t\\t\\t\\t\\t\\taddSample(\\\"Quotes of the Day\\\", null, \\\"http:\\t\\t\\taddSample(\\\"Today I Learned (TIL)\\\", null, \\\"http:\\t\\t\\taddSample(\\\"Slashdot\\\", \\\"ui/console\\\", \\\"http:\\t\\t\\t\\t\\t}\\n\\t\\tintervalFetchTimer = MTimer.minutes(FeedsFSPlugin.DEFAULT_FETCH_INTERVAL, timer -> {\\n\\t\\t\\tif (!MApplication.offline.booleanValue())\\n\\t\\t\\t\\tfetchFeeds(getRoot(), USE_EXCLUDE_FROM_INTERVAL_FETCH);\\n\\t\\t\\treturn MTimer.CONTINUE;\\n\\t\\t} );\\n\\t}\\n\\t@Override\\n\\tprotected String getDefaultIconName(final MetaInfo metaInfo) {\\n\\t\\treturn metaInfo.isDynamicFolder() ? \\\"ui/feed\\\" : null;\\n\\t}\\n\\t@Override\\n\\tprotected void processFile(final MetaInfo parent, final File file) {\\n\\t\\tprocessDynamicFolder(parent, file);\\n\\t}\\n\\tprivate void addSample(final String name, final String iconName, final String url) {\\n\\t\\tMetaInfo dynamicFolder = addDynamicFolder(getRoot(), name);\\n\\t\\tif (dynamicFolder != null) {\\n\\t\\t\\tif (iconName != null)\\n\\t\\t\\t\\tdynamicFolder.setIconName(iconName);\\n\\t\\t\\tConfig config = dynamicFolder.getConfig();\\n\\t\\t\\tconfig.write(\\\"x.url\\\", url);\\n\\t\\t\\tconfig.sync();\\n\\t\\t}\\n\\t}\\n\\tprivate static boolean checkOffline() {\\n\\t\\tif (MApplication.offline.get()) {\\n\\t\\t\\tMStatusBar.warning(i18n(\\\"Working in Offline Mode\\\"));\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\tprivate static void doRemoveAllChildren(final MetaInfo parent) {\\n\\t\\tfor (FeedViewer i : FeedViewer.findEditor(FeedViewer.class)) {\\n\\t\\t\\tif (i.getMetaInfo().getParentFolder() == parent) {\\n\\t\\t\\t\\ti.waitingForUpdateFrom = parent;\\n\\t\\t\\t\\ti.messageLabel.setWarningMessage(i18n(\\\"Please Wait...\\\"));\\n\\t\\t\\t\\ti.messageLabel.setVisible(true);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (MetaInfo i : parent.list(MV.MODEL))\\n\\t\\t\\ti.setParent(null);\\n\\t\\tTree tree = Tree.getInstance();\\n\\t\\ttree.setCloseTabsOnRemove(false);\\n\\t\\ttry {\\n\\t\\t\\ttree.removeAllChildren(parent);\\n\\t\\t}\\n\\t\\tfinally {\\n\\t\\t\\ttree.setCloseTabsOnRemove(true);\\n\\t\\t}\\n\\t}\\n\\tprivate boolean download(final MetaInfo parent, final boolean expandFolder, final int flags) {\\n\\t\\tif (!parent.isDynamicFolder())\\n\\t\\t\\treturn false;\\n\\t\\t\\t\\tObject feedThread = parent.clearProperty(\\\"feed.thread\\\");\\n\\t\\tif (feedThread instanceof FeedThread) {\\n\\t\\t\\tFeedThread.class.cast(feedThread).abort();\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tConfig config = parent.getConfig();\\n\\t\\tif (\\n\\t\\t\\t((flags & USE_EXCLUDE_FROM_FETCH_ALL_FEEDS) != 0) &&\\n\\t\\t\\tconfig.read(\\\"x.excludeFromFetchAllFeeds\\\", false)\\n\\t\\t)\\n\\t\\t\\treturn true;\\n\\t\\tif (\\n\\t\\t\\t((flags & USE_EXCLUDE_FROM_INTERVAL_FETCH) != 0) &&\\n\\t\\t\\tconfig.read(\\\"x.excludeFromIntervalFetch\\\", false)\\n\\t\\t)\\n\\t\\t\\treturn true;\\n\\t\\t\\t\\tLong lastFetch = parent.getProperty(\\\"feed.lastFetch\\\", null);\\n\\t\\tif (\\n\\t\\t\\t(lastFetch != null) &&\\n\\t\\t\\t((System.currentTimeMillis() - lastFetch) < TimeUnit.MINUTES.toMillis(1))\\n\\t\\t) {\\n\\t\\t\\tlog.debugFormat(\\\"Feed \\\\\\\"%s\\\\\\\" already downloaded\\\", parent);\\n\\t\\t\\tif (expandFolder)\\n\\t\\t\\t\\tTree.getInstance().setExpanded(parent, true);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\t\\t\\tdoRemoveAllChildren(parent);\\n\\t\\tboolean fetchOffline = (flags & FETCH_OFFLINE) != 0;\\n\\t\\tFeedDownloader.download(this, parent, expandFolder, null, fetchOffline);\\n\\t\\treturn true;\\n\\t}\\n\\tprivate void exportTo(final File file) {\\n\\t\\tfinal OPMLWriter writer = new OPMLWriter();\\n\\t\\twriter.beginOPML();\\n\\t\\twriter.emptyHead();\\n\\t\\twriter.beginBody();\\n\\t\\tnew Tree.Scanner(Tree.getInstance().getCurrentFolder(true)) {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic void processItem(final MetaInfo item) {\\n\\t\\t\\t\\tif (item.isDynamicFolder()) {\\n\\t\\t\\t\\t\\tConfig config = item.getConfig();\\n\\t\\t\\t\\t\\twriter.addOutline(\\n\\t\\t\\t\\t\\t\\titem.toString(),\\n\\t\\t\\t\\t\\t\\t\\\"xmlUrl\\\", writer.escape(config.read(\\\"x.url\\\", \\\"\\\"))\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (item.isFolder()) {\\n\\t\\t\\t\\t\\twriter.beginOutline(item.toString());\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic void processParent(final MetaInfo parent) {\\n\\t\\t\\t\\tif (parent.isFolder())\\n\\t\\t\\t\\t\\twriter.endOutline();\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\twriter.endBody();\\n\\t\\twriter.endOPML();\\n\\t\\ttry {\\n\\t\\t\\twriter.write(file);\\n\\t\\t}\\n\\t\\tcatch (IOException exception) {\\n\\t\\t\\tMMessage.error(null, exception, i18n(\\\"Could not export feeds\\\"));\\n\\t\\t}\\n\\t}\\n\\tprivate void importFrom(final File file, final MetaInfo toFolder) {\\n\\t\\tcurrentImportFolder = toFolder;\\n\\t\\ttry {\\n\\t\\t\\tOPMLReader reader = new OPMLReader() {\\n\\t\\t\\t\\tprivate boolean inEmptyFolder;\\n\\t\\t\\t\\tprivate Map<String, MetaInfo> existingURLs = FeedsFS.this.findAllURLs();\\n\\t\\t\\t\\t@Override\\n\\t\\t\\t\\tprotected void onEnd(final String name) {\\n\\t\\t\\t\\t\\tsuper.onEnd(name);\\n\\t\\t\\t\\t\\tif (name.equals(\\\"outline\\\") && (inEmptyFolder || !hasAttributes())) {\\n\\t\\t\\t\\t\\t\\tinEmptyFolder = false;\\n\\t\\t\\t\\t\\t\\tMetaInfo parent = currentImportFolder.getParentFolder();\\n\\t\\t\\t\\t\\t\\tif (parent == null)\\n\\t\\t\\t\\t\\t\\t\\tcurrentImportFolder = toFolder;\\n\\t\\t\\t\\t\\t\\telse if (parent.getFS() instanceof FeedsFS)\\n\\t\\t\\t\\t\\t\\t\\tcurrentImportFolder = parent;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tcurrentImportFolder = toFolder;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t@Override\\n\\t\\t\\t\\tprotected void onOutline() {\\n\\t\\t\\t\\t\\tString url = getStringAttribute(\\\"xmlUrl\\\");\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (url == null) {\\n\\t\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\tcurrentImportFolder = currentImportFolder.getFS().createUniqueFolder(currentImportFolder, getTextAttribute(i18n(\\\"Unnamed\\\")));\\n\\t\\t\\t\\t\\t\\t\\tinEmptyFolder = true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcatch (FSException exception) {\\n\\t\\t\\t\\t\\t\\t\\tcancel();\\n\\t\\t\\t\\t\\t\\t\\tMMessage.error(null, exception);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\telse if (!FeedsFS.this.alreadyExists(existingURLs, url)) {\\n\\t\\t\\t\\t\\t\\tString name = FSHelper.getUniqueName(currentImportFolder.getTargetFile(), getTextAttribute(i18n(\\\"Unnamed\\\")), \\\"properties\\\");\\n\\t\\t\\t\\t\\t\\tConfig config = new Config(FS.makePath(currentImportFolder.getTargetPath(), FSHelper.escapeName(name)));\\n\\t\\t\\t\\t\\t\\tconfig.write(\\\"x.url\\\", url);\\n\\t\\t\\t\\t\\t\\tconfig.sync();\\n\\t\\t\\t\\t\\t\\tMetaInfo dynamicFolder = MetaInfo.createDynamicFolder(FeedsFS.this, config.getPath()); \\n\\t\\t\\t\\t\\t\\tcurrentImportFolder.add(dynamicFolder);\\n\\t\\t\\t\\t\\t\\tdynamicFolder.sync();\\n\\t\\t\\t\\t\\t\\tinEmptyFolder = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\treader.read(file);\\n\\t\\t}\\n\\t\\tcatch (Exception exception) {\\n\\t\\t\\tMMessage.error(null, exception, i18n(\\\"Could not import feeds\\\"));\\n\\t\\t}\\n\\t\\tfinally {\\n\\t\\t\\tcurrentImportFolder = null;\\n\\t\\t\\tgetRoot().reload();\\n\\t\\t\\tTree.getInstance().selectItem(toFolder, true);\\n\\t\\t}\\n\\t}\\n\\tboolean alreadyExists(Map<String, MetaInfo> existingURLs, final String newURL) {\\n\\t\\tif (existingURLs == null)\\n\\t\\t\\texistingURLs = findAllURLs();\\n\\t\\tMetaInfo item = existingURLs.get(newURL);\\n\\t\\tif (item != null) {\\n\\t\\t\\tMNotification.Message message = FeedThread.showNotification(\\n\\t\\t\\t\\titem,\\n\\t\\t\\t\\tnew FeedThread.ErrorAction(item, i18n(\\\"RSS feed already exists: {0}\\\", newURL))\\n\\t\\t\\t);\\n\\t\\t\\tmessage.toFront();\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\tMap<String, MetaInfo> findAllURLs() {\\n\\t\\tfinal Map<String, MetaInfo> result = new HashMap<>();\\n\\t\\tnew Tree.Scanner(this) {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic void processItem(final MetaInfo item) {\\n\\t\\t\\t\\tif (item.isDynamicFolder()) {\\n\\t\\t\\t\\t\\tString url = item.getConfig().read(\\\"x.url\\\", null);\\n\\t\\t\\t\\t\\tif (url == null)\\n\\t\\t\\t\\t\\t\\tlog.debugFormat(\\\"Missing Feed URL: %s\\\", item.getFilePath());\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tresult.put(url, item);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\treturn result;\\n\\t}\\n\\tColor getColor(final ArticleMetaInfo article) {\\n\\t\\tColor articleColor = article.getColor();\\n\\t\\tif ((articleColor == null) || (articleColor instanceof UnreadColor)) {\\n\\t\\t\\tif (article.isUnread())\\n\\t\\t\\t\\tarticleColor = getUnreadColor();\\n\\t\\t\\telse\\n\\t\\t\\t\\tarticleColor = null;\\n\\t\\t}\\n\\t\\treturn articleColor;\\n\\t}\\n\\tstatic FeedsFSPlugin getFeedsFSPlugin() {\\n\\t\\treturn (FeedsFSPlugin)self().getInfo().getPlugin();\\n\\t}\\n\\tstatic void refresh(final MetaInfo parent) {\\n\\t\\tparent.clearProperty(\\\"feed.lastFetch\\\"); \\t\\tdoRemoveAllChildren(parent);\\n\\t\\tself().download(parent, true, FETCH_OFFLINE);\\n\\t\\tparent.reload();\\n\\t}\\n\\tFeedsFSPlugin.Settings reloadSettings(final FeedsFSPlugin plugin) {\\n\\t\\tFeedsFSPlugin.Settings settings = plugin.readGlobalSettings();\\n\\t\\tintervalFetchTimer.setDelay(TimeUnit.MINUTES, settings.minutes);\\n\\t\\t\\t\\tif (settings.useIntervalFetching)\\n\\t\\t\\tintervalFetchTimer.restart();\\n\\t\\telse\\n\\t\\t\\tintervalFetchTimer.stop();\\n\\t\\treturn settings;\\n\\t}\\n\\tstatic FeedsFS self() {\\n\\t\\tFeedsFS fs = FeedsFSPlugin._fsInstance;\\n\\t\\tif (fs == null)\\n\\t\\t\\tlog.error(\\\"\\\\\\\"feeds\\\\\\\" VFS no longer available\\\");\\n\\t\\treturn fs;\\n\\t}\\n\\tvoid updateInfo(final MetaInfo dynamicFolder) {\\n\\t\\tint newCount = 0;\\n\\t\\tint unreadCount = 0;\\n\\t\\tfor (MetaInfo i : dynamicFolder.list(MV.MODEL)) {\\n\\t\\t\\tif (i instanceof ArticleMetaInfo) {\\n\\t\\t\\t\\tArticleMetaInfo article = (ArticleMetaInfo)i;\\n\\t\\t\\t\\tif (article.isNew())\\n\\t\\t\\t\\t\\tnewCount++;\\n\\t\\t\\t\\tif (article.isUnread())\\n\\t\\t\\t\\t\\tunreadCount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tStringJoiner s = new StringJoiner(\\\", \\\");\\n\\t\\tboolean dead = dynamicFolder.getProperty(\\\"feed.dead\\\", false);\\n\\t\\tif (dead)\\n\\t\\t\\ts.add(i18n(\\\"Dead RSS source?\\\"));\\n\\t\\tif (newCount > 0)\\n\\t\\t\\ts.add(i18n(\\\"New: {0}\\\", newCount));\\n\\t\\tif (unreadCount > 0)\\n\\t\\t\\ts.add(i18n(\\\"Unread: {0}\\\", unreadCount));\\n\\t\\tif (s.length() == 0) {\\n\\t\\t\\tdynamicFolder.clearProperty(MetaInfo.EXTRA_COLOR);\\n\\t\\t\\tdynamicFolder.clearProperty(MetaInfo.EXTRA_TEXT);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (dead)\\n\\t\\t\\t\\tdynamicFolder.setProperty(MetaInfo.EXTRA_COLOR, MColor.BRICK_RED);\\n\\t\\t\\telse if ((newCount > 0) || (unreadCount > 0))\\n\\t\\t\\t\\tdynamicFolder.setProperty(MetaInfo.EXTRA_COLOR, getUnreadColor());\\n\\t\\t\\telse\\n\\t\\t\\t\\tdynamicFolder.clearProperty(MetaInfo.EXTRA_COLOR);\\n\\t\\t\\tdynamicFolder.setProperty(MetaInfo.EXTRA_TEXT, s.toString());\\n\\t\\t}\\n\\t\\tdynamicFolder.refresh(true);\\n\\t}\\n\\tpublic static final class ArticleMetaInfo extends MetaInfo.VirtualFileMetaInfo {\\n\\t\\tprivate byte state;\\n\\t\\tprivate static final byte UNREAD_STATE = 1;\\n\\t\\tprivate static final byte NEW_STATE = 1 << 1;\\n\\t\\t\\t\\tprivate static final byte WAS_UNREAD_STATE = 1 << 2;\\n\\t\\tpublic ArticleMetaInfo(final AbstractFS fs, final String name, final String articleID) {\\n\\t\\t\\tsuper(fs, name);\\n\\t\\t\\tsetID(Objects.toString(articleID, \\\"\\\"));\\n\\t\\t}\\n\\t\\tpublic boolean isNew() {\\n\\t\\t\\treturn (state & NEW_STATE) != 0;\\n\\t\\t}\\n\\t\\tpublic void setNew(final boolean value) {\\n\\t\\t\\tif (value)\\n\\t\\t\\t\\tstate |= NEW_STATE;\\n\\t\\t\\telse\\n\\t\\t\\t\\tstate &= ~NEW_STATE;\\n\\t\\t}\\n\\t\\tpublic boolean isUnread() {\\n\\t\\t\\treturn (state & UNREAD_STATE) != 0;\\n\\t\\t}\\n\\t\\tpublic void setUnread(final boolean value) {\\n\\t\\t\\tif (value)\\n\\t\\t\\t\\tstate |= (UNREAD_STATE | WAS_UNREAD_STATE);\\n\\t\\t\\telse\\n\\t\\t\\t\\tstate &= ~UNREAD_STATE;\\n\\t\\t}\\n\\t\\tboolean wasUnread() {\\n\\t\\t\\treturn (state & WAS_UNREAD_STATE) != 0;\\n\\t\\t}\\n\\t}\\n\\tpublic static final class ArchiveOptions extends FeedsFSPlugin.AbstractPanel {\\n\\t\\tprivate final MRadioButton doNotRemoveArticles;\\n\\t\\tprivate final MRadioButton removeArticles;\\n\\t\\tprivate MRadioButton useGlobalSettings;\\n\\t\\tprivate final MSlider days;\\n\\t\\tpublic ArchiveOptions(final boolean globalSettings) {\\n\\t\\t\\tsuper(i18n(\\\"Archive\\\"), !globalSettings);\\n\\t\\t\\tif (!globalSettings) {\\n\\t\\t\\t\\tuseGlobalSettings = new MRadioButton(i18n(\\\"Use global settings\\\"));\\n\\t\\t\\t\\tadd(useGlobalSettings);\\n\\t\\t\\t}\\n\\t\\t\\tremoveArticles = new MRadioButton();\\n\\t\\t\\tMSmallButton cleanUpArchiveButton = new MSmallButton(\\n\\t\\t\\t\\tMIcon.small(\\\"ui/delete\\\"),\\n\\t\\t\\t\\ti18n(\\\"Manually Remove Unused RSS Archives...\\\")\\n\\t\\t\\t);\\n\\t\\t\\tcleanUpArchiveButton.addActionListener(e -> cleanUpArchive(cleanUpArchiveButton));\\n\\t\\t\\tadd(cleanUpArchiveButton);\\n\\t\\t\\tMPanel removeArticlesPanel = MPanel.createHBoxPanel();\\n\\t\\t\\tremoveArticlesPanel.add(removeArticles);\\n\\t\\t\\tremoveArticlesPanel.addGap();\\n\\t\\t\\tremoveArticlesPanel.addStretch();\\n\\t\\t\\tremoveArticlesPanel.add(cleanUpArchiveButton);\\n\\t\\t\\tadd(removeArticlesPanel);\\n\\t\\t\\tdays = new MSlider();\\n\\t\\t\\tdays.setMinimum(FeedsFSPlugin.Settings.MIN_DAYS);\\n\\t\\t\\tdays.setMaximum(FeedsFSPlugin.Settings.MAX_DAYS);\\n\\t\\t\\tdays.showSimpleLabels();\\n\\t\\t\\tdays.addChangeListener(e -> {\\n\\t\\t\\t\\tremoveArticles.setSelected(true);\\n\\t\\t\\t\\tupdateText();\\n\\t\\t\\t} );\\n\\t\\t\\tadd(days);\\n\\t\\t\\tremoveArticles.addActionListener(e -> days.requestFocusInWindow());\\n\\t\\t\\tdoNotRemoveArticles = new MRadioButton(i18n(\\\"Do not remove old articles (slow)\\\"));\\n\\t\\t\\tadd(doNotRemoveArticles);\\n\\t\\t\\tUI.group(\\n\\t\\t\\t\\tuseGlobalSettings,\\n\\t\\t\\t\\tremoveArticles,\\n\\t\\t\\t\\tdoNotRemoveArticles\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\tpublic Archive.Policy getPolicy() {\\n\\t\\t\\tif (doNotRemoveArticles.isSelected())\\n\\t\\t\\t\\treturn Archive.Policy.DO_NOT_REMOVE;\\n\\t\\t\\tif (removeArticles.isSelected())\\n\\t\\t\\t\\treturn Archive.Policy.REMOVE;\\n\\t\\t\\treturn (useGlobalSettings == null) ? Archive.Policy.REMOVE : Archive.Policy.USE_GLOBAL_SETTINGS;\\n\\t\\t}\\n\\t\\tpublic int getDays() {\\n\\t\\t\\treturn days.getValue();\\n\\t\\t}\\n\\t\\tpublic void setDays(final int value, final Archive.Policy policy) {\\n\\t\\t\\tdays.setValue(value);\\n\\t\\t\\tswitch (policy) {\\n\\t\\t\\t\\tcase DO_NOT_REMOVE:\\n\\t\\t\\t\\t\\tdoNotRemoveArticles.setSelected(true);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase REMOVE:\\n\\t\\t\\t\\t\\tremoveArticles.setSelected(true);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase USE_GLOBAL_SETTINGS:\\n\\t\\t\\t\\t\\tif (useGlobalSettings == null)\\n\\t\\t\\t\\t\\t\\tremoveArticles.setSelected(true);\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tuseGlobalSettings.setSelected(true);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tupdateText();\\n\\t\\t}\\n\\t\\tprivate void cleanUpArchive(final MButton button) {\\t\\t\\tArchive archive = Archive.getInstance();\\n\\t\\t\\tFeedsFS fs = FeedsFS.self();\\n\\t\\t\\tMap<String, MetaInfo> urlMap = fs.findAllURLs();\\n\\t\\t\\tWindow owner = getWindowAncestor();\\n\\t\\t\\tTreeSet<Tuple.Two<String, String>> unused = new TreeSet<>(Comparator.comparing(Tuple.Two::get1));\\n\\t\\t\\tfor (Map.Entry<String, Archive.Item> i : archive) {\\n\\t\\t\\t\\tif (!urlMap.containsKey(i.getKey())) {\\n\\t\\t\\t\\t\\tPath path = Paths.get(archive.getDirectory().getPath(), i.getValue().getFileName());\\n\\t\\t\\t\\t\\tString sizeText;\\n\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\tsizeText = MFormat.toAutoSize(Files.size(path));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcatch (IOException exception) {\\n\\t\\t\\t\\t\\t\\tsizeText = MFormat.toAutoSize(-1);\\n\\t\\t\\t\\t\\t\\tMLogger.developerException(exception);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tunused.add(Tuple.of(i.getKey(), sizeText));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (unused.isEmpty()) {\\n\\t\\t\\t\\tbutton.setEnabled(false);\\n\\t\\t\\t\\tbutton.setIcon(MIcon.small(\\\"ui/ok\\\"));\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tMCheckBoxTable<Tuple.Two<String, String>> table = new MCheckBoxTable<>(\\n\\t\\t\\t\\ti18n(\\\"Delete\\\"),\\n\\t\\t\\t\\ti18n(\\\"Address\\\"),\\n\\t\\t\\t\\ttrue,\\n\\t\\t\\t\\tunused\\n\\t\\t\\t);\\n\\t\\t\\tMDialog dialog = table.createDialog(\\n\\t\\t\\t\\towner,\\n\\t\\t\\t\\ti18n(\\\"Remove Unused RSS Archives\\\"),\\n\\t\\t\\t\\ti18n(\\\"Items:\\\"),\\n\\t\\t\\t\\tMActionInfo.DELETE\\n\\t\\t\\t);\\n\\t\\t\\tif (dialog.exec()) {\\n\\t\\t\\t\\tif (owner != null)\\n\\t\\t\\t\\t\\tUI.setWaitCursor(owner, true);\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tfor (MCheckBoxTable.CheckBoxItem<Tuple.Two<String, String>> i : table.getModel()) {\\n\\t\\t\\t\\t\\t\\tif (i.isSelected())\\n\\t\\t\\t\\t\\t\\t\\ti.getValue().accept((address, size) -> archive.removeItem(address));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfinally {\\n\\t\\t\\t\\t\\tif (owner != null)\\n\\t\\t\\t\\t\\t\\tUI.setWaitCursor(owner, false);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprivate void updateText() {\\n\\t\\t\\tremoveArticles.setText(i18n(\\\"Automatically remove articles after {0} day(s)\\\", days.getValue()));\\n\\t\\t}\\n\\t}\\n\\tpublic final class FetchAllFeedsAction extends MAction {\\n\\t\\tprivate boolean idle;\\n\\t\\tMButton button;\\n\\t\\tpublic FetchAllFeedsAction() {\\n\\t\\t\\tsetHTMLHelp(i18n(\\\"Download and update all RSS feeds.\\\"));\\n\\t\\t\\tsetIdle(true);\\n\\t\\t}\\n\\t\\t@Override\\n\\t\\tpublic void onAction() {\\n\\t\\t\\tif (idle) {\\n\\t\\t\\t\\tif (FeedsFS.checkOffline())\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\tMetaInfo root = FeedsFS.this.getRoot();\\n\\t\\t\\t\\tMainWindow.showTree(root);\\n\\t\\t\\t\\tTree.getInstance().setExpanded(root, true);\\n\\t\\t\\t\\t\\t\\t\\t\\tif (FeedsFS.this.intervalFetchTimer.isRunning())\\n\\t\\t\\t\\t\\tFeedsFS.this.intervalFetchTimer.restart();\\n\\t\\t\\t\\tFeedsFS.this.fetchFeeds(USE_EXCLUDE_FROM_FETCH_ALL_FEEDS);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tFeedDownloader.abortAll();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tpublic void setIdle(final boolean idle) {\\n\\t\\t\\tthis.idle = idle;\\n\\t\\t\\tif (idle) {\\n\\t\\t\\t\\tsetName(i18n(\\\"Refresh All RSS Feeds\\\"));\\n\\t\\t\\t\\tsetIconName(\\\"ui/feed\\\");\\n\\t\\t\\t\\tif (button != null)\\n\\t\\t\\t\\t\\tbutton.setRolloverIcon(MIcon.stock(\\\"ui/refresh\\\"));\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tsetName(i18n(\\\"Cancel Refresh\\\"));\\n\\t\\t\\t\\tsetIconName(\\\"ui/stop\\\");\\n\\t\\t\\t\\tif (button != null)\\n\\t\\t\\t\\t\\tbutton.setRolloverIcon(button.getIcon());\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tprivate abstract class AbstractImportAction extends MAction {\\n\\t\\tprivate String newFolderName;\\n\\t\\t@Override\\n\\t\\tpublic void onAction() {\\n\\t\\t\\tMFileChooser fileChooser = createFileChooser();\\n\\t\\t\\tif (fileChooser.openDialog()) {\\n\\t\\t\\t\\tFile file = fileChooser.getSelectedFile();\\n\\t\\t\\t\\tif (newFolderName == null)\\n\\t\\t\\t\\t\\tnewFolderName = file.getName();\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tFeedsFS.this.importFrom(file, getTargetFolder());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch (FSException exception) {\\n\\t\\t\\t\\t\\tMMessage.error(null, exception);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprotected Path getImportDir() { return null; }\\n\\t\\tprotected MetaInfo getTargetFolder() throws FSException {\\n\\t\\t\\tMetaInfo folder = FeedsFS.this.getCurrentFolder(false);\\n\\t\\t\\treturn FeedsFS.this.createUniqueFolder(folder, i18n(\\\"Imported from {0}\\\", newFolderName));\\n\\t\\t}\\n\\t\\tprotected MFileChooser createFileChooser() {\\n\\t\\t\\tMFileChooser fileChooser = MFileChooser.createFileChooser(null, i18n(\\\"Import RSS Feed List\\\"));\\n\\t\\t\\tfileChooser.setFileFilter(\\n\\t\\t\\t\\tfileChooser.addFilter(\\\"OPML\\\", \\\"opml\\\", \\\"xml\\\")\\n\\t\\t\\t);\\n\\t\\t\\tfileChooser.setApproveText(MActionInfo.IMPORT.getText());\\n\\t\\t\\tfileChooser.setConfigKey(\\\"importFeeds\\\");\\n\\t\\t\\tPath dir = getImportDir();\\n\\t\\t\\tif (dir != null)\\n\\t\\t\\t\\tfileChooser.setSelectedFile(dir.toFile());\\n\\t\\t\\treturn fileChooser;\\n\\t\\t}\\n\\t\\tprivate AbstractImportAction(final String text, final String newFolderName) {\\n\\t\\t\\tsuper(text, \\\"ui/feed\\\");\\n\\t\\t\\tthis.newFolderName = newFolderName;\\n\\t\\t}\\n\\t}\\n\\tprivate static final class CustomAdvancedPanel extends FeedsFSPlugin.AbstractPanel {\\n\\t\\tprivate boolean showExpiredArticlesAgainClicked;\\n\\t\\tprivate final MButton showExpiredArticlesAgainButton;\\n\\t\\tprivate final MCheckBox blockImagesCheckBox;\\n\\t\\tprivate final MCheckBox excludeFromFetchAllFeeds;\\n\\t\\tprivate final MCheckBox excludeFromIntervalFetch;\\n\\t\\tprivate final MCheckBox showFullPageCheckBox;\\n\\t\\tpublic CustomAdvancedPanel() {\\n\\t\\t\\tsuper(i18n(\\\"Miscellaneous\\\"), false);\\n\\t\\t\\t\\t\\t\\tsetMargin(0, getContentMargin(), getContentMargin(), getContentMargin());\\n\\t\\t\\tblockImagesCheckBox = new MCheckBox(i18n(\\\"Block Images\\\"));\\n\\t\\t\\tadd(blockImagesCheckBox);\\n\\t\\t\\tshowFullPageCheckBox = new MCheckBox(i18n(\\\"Load and Show Full Page\\\") + \\\" - \\\" + i18n(\\\"Experimental\\\"));\\n\\t\\t\\tadd(showFullPageCheckBox);\\n\\t\\t\\t\\t\\t\\texcludeFromFetchAllFeeds = new MCheckBox(i18n(\\\"Exclude from \\\\\\\"Refresh All Feeds\\\\\\\"\\\"));\\n\\t\\t\\tadd(excludeFromFetchAllFeeds);\\n\\t\\t\\t\\t\\t\\texcludeFromIntervalFetch = new MCheckBox(i18n(\\\"Exclude from \\\\\\\"interval\\\\\\\" fetch\\\"));\\n\\t\\t\\tadd(excludeFromIntervalFetch);\\n\\t\\t\\taddContentGap();\\n\\t\\t\\tshowExpiredArticlesAgainButton = new MButton(i18n(\\\"Show Expired Articles Again\\\"));\\n\\t\\t\\tshowExpiredArticlesAgainButton.addActionListener(e -> showExpiredArticlesAgainClicked = true);\\n\\t\\t\\tadd(showExpiredArticlesAgainButton);\\n\\t\\t\\taddContentGap();\\n\\t\\t\\taddStretch();\\n\\t\\t\\tMButton globalSettingsButton = new MButton(new FeedsFS.GlobalSettingsAction());\\n\\t\\t\\tglobalSettingsButton.setIconNameUI(\\\"ui/feed\\\");\\n\\t\\t\\tadd(globalSettingsButton);\\n\\t\\t}\\n\\t\\t@Override\\n\\t\\tprotected boolean shouldRefresh() {\\n\\t\\t\\treturn\\n\\t\\t\\t\\tshowExpiredArticlesAgainClicked ||\\n\\t\\t\\t\\tblockImagesCheckBox.isModified();\\n\\t\\t}\\n\\t}\\n\\tprivate final class ExportAction extends MAction {\\n\\t\\tpublic ExportAction(final String name) {\\n\\t\\t\\tsuper(name, \\\"ui/feed\\\");\\n\\t\\t}\\n\\t\\t@Override\\n\\t\\tpublic void onAction() {\\n\\t\\t\\tMFileChooser fileChooser = MFileChooser.createFileChooser(this.getSourceWindow(), i18n(\\\"Export Feeds\\\"));\\n\\t\\t\\tfileChooser.setFileFilter(\\n\\t\\t\\t\\tfileChooser.addFilter(\\\"OPML\\\", \\\"opml\\\", \\\"xml\\\")\\n\\t\\t\\t);\\n\\t\\t\\tfileChooser.setApproveText(i18n(\\\"Export\\\"));\\n\\t\\t\\tfileChooser.setConfigKey(\\\"exportFeeds\\\");\\n\\t\\t\\tfileChooser.setSelectedFile(new File(\\\"feeds.opml\\\"));\\n\\t\\t\\tif (fileChooser.saveDialog())\\n\\t\\t\\t\\texportTo(fileChooser.getSelectedFile());\\n\\t\\t}\\n\\t}\\n\\tprivate final class FetchFeedsAction extends MDataAction<MetaInfo> {\\n\\t\\t@Override\\n\\t\\tpublic void onAction() {\\n\\t\\t\\tif (FeedsFS.checkOffline())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tFeedsFS.this.fetchFeeds(this.getData(), 0);\\n\\t\\t}\\n\\t\\tprivate FetchFeedsAction(final MetaInfo feed) {\\n\\t\\t\\tsuper(feed, i18n(\\\"Refresh Feeds: {0}\\\", TK.centerSqueeze(feed.toString(), 15)), \\\"ui/refresh\\\");\\n\\t\\t}\\n\\t}\\n\\tprivate final class ImportAction extends AbstractImportAction {\\n\\t\\tprivate ImportAction() {\\n\\t\\t\\tsuper(i18n(\\\"Import RSS Feed List\\\"), null);\\n\\t\\t}\\n\\t}\\n\\tprivate final class ImportFromLifereaAction extends AbstractImportAction {\\n\\t\\t@Override\\n\\t\\tprotected Path getImportDir() {\\n\\t\\t\\ttry (Stream<Path> stream = Files.list(FS.getUserPath())) {\\n\\t\\t\\t\\tList<Path> result = stream\\n\\t\\t\\t\\t\\t.filter(path -> Files.isDirectory(path) && path.getFileName().toString().startsWith(\\\".liferea\\\"))\\n\\t\\t\\t\\t\\t.sorted(Comparator.reverseOrder())\\n\\t\\t\\t\\t\\t.collect(Collectors.toList());\\n\\t\\t\\t\\tif (!result.isEmpty())\\n\\t\\t\\t\\t\\treturn result.get(0).resolve(\\\"feedlist.opml\\\");\\n\\t\\t\\t}\\n\\t\\t\\tcatch (IOException exception) {\\n\\t\\t\\t\\tMLogger.exception(exception);\\n\\t\\t\\t}\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\tprivate ImportFromLifereaAction() {\\n\\t\\t\\tsuper(i18n(\\\"Import RSS Feed List from {0}\\\", \\\"Liferea\\\"), \\\"Liferea\\\");\\n\\t\\t}\\n\\t}\\n\\tstatic final class MarkAllAsReadAction extends MAction { \\t\\n\\t\\tprivate MetaInfo _feed;\\n\\t\\tpublic MarkAllAsReadAction() {\\n\\t\\t\\tsuper(i18n(\\\"Mark All as Read\\\"), \\\"ui/complete\\\");\\n\\t\\t}\\n\\t\\t@Override\\n\\t\\tpublic void onAction() {\\n\\t\\t\\tMetaInfo feed = _feed;\\n\\t\\t\\tif (feed == null)\\n\\t\\t\\t\\tfeed = Tree.getInstance().getCurrentFolder(true);\\n\\t\\t\\tString url = feed.getConfig().read(\\\"x.url\\\", null);\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tArchive.getInstance().markAs(url, Archive.State.READ);\\n\\t\\t\\t\\tFeedsFS.refresh(feed);\\n\\t\\t\\t}\\n\\t\\t\\tcatch (ArchiveException exception) {\\n\\t\\t\\t\\tshowErrorMessage(exception);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tpublic void setFeed(final MetaInfo value) { _feed = value; }\\n\\t}\\n\\tprivate static final class UnreadColor extends Color {\\n\\t\\tprivate UnreadColor(final Color value) {\\n\\t\\t\\tsuper(value.getRGB());\\n\\t\\t}\\n\\t\\tprivate UnreadColor(final int rgb) {\\n\\t\\t\\tsuper(rgb);\\n\\t\\t}\\n\\t}\\n\\tstatic final class GlobalSettingsAction extends MAction {\\n\\t\\tpublic GlobalSettingsAction() {\\n\\t\\t\\tsuper(i18n(\\\"Global Settings...\\\"));\\n\\t\\t}\\n\\t\\t@Override\\n\\t\\tpublic void onAction() {\\n\\t\\t\\tPluginSettings.showPluginOptionsDialog(\\n\\t\\t\\t\\tgetSourceWindow(),\\n\\t\\t\\t\\tMDialog.APPLY_BUTTON,\\n\\t\\t\\t\\tFeedsFS.self().getInfo()\\n\\t\\t\\t);\\n\\t\\t}\\n\\t}\\n}\""
            },
            "m36": {
                "content": "The starting entity `FeedsFS.java` is a core component of the `Makagiga` project, implementing various functionalities related to RSS feed handling. It extends `AbstractFS` and implements several interfaces such as `FSDynamic`, `FSNewFile`, `FSOpen`, etc., indicating it has dependencies on multiple other entities.\n\nTo perform Change Impact Analysis (CIA), we need to identify which entities are coupled with `FeedsFS.java`. The next step is to determine coupling dependencies between `FeedsFS.java` and other entities in the system. \n\nI will now analyze its coupling dependencies with one potential dependent entity based on class inheritance and interface implementation clues observed in the code.\n\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_a16891a9683546979f10bd",
                        "function": {
                            "arguments": "{\"entity1\": \"FeedsFS.java\", \"entity2\": \"AbstractFS.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m37": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"There are no coupling dependencies between these two entities\"]"
            },
            "m38": {
                "content": "It seems there are no direct coupling dependencies between `FeedsFS.java` and `AbstractFS.java`, despite the fact that `FeedsFS` extends `AbstractFS`. This could mean that the dependency is indirect or not captured by the current coupling analysis method.\n\nTo continue with the Change Impact Analysis (CIA), it's important to identify which entities are directly coupled with `FeedsFS.java`. Since our initial check with `AbstractFS.java` did not reveal any coupling dependencies, I will now explore potential coupling with another entity that has a clear relationship with `FeedsFS.java`.\n\nLooking at the implementation details of `FeedsFS`, it implements several interfaces like `FSDynamic`, `FSNewFile`, `FSOpen`, etc. These interface implementations suggest possible dependencies on the corresponding interface definition files. \n\nI will now analyze the coupling dependencies between `FeedsFS.java` and one of these interface files, starting with `FSDynamic.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_dbf332c1d4b94b88a457fd",
                        "function": {
                            "arguments": "{\"entity1\": \"FeedsFS.java\", \"entity2\": \"FSDynamic.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m39": {
                "content": "Similar to `AbstractFS.java`, there are no direct coupling dependencies between `FeedsFS.java` and `FSDynamic.java`, despite `FeedsFS` implementing the `FSDynamic` interface. This suggests that the coupling might not be captured through direct method calls or field usages, or it could be an issue with how coupling is being analyzed.\n\nSince `FeedsFS` heavily interacts with `MetaInfo` (e.g., methods like `canImport`, `deleteNotify`, and others use `MetaInfo`), we should analyze its coupling with `MetaInfo.java`. This will help determine if there are any direct dependencies affecting `MetaInfo`.\n\nLet's proceed by analyzing the coupling dependencies between `FeedsFS.java` and `MetaInfo.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_c302557841494e03b299a8",
                        "function": {
                            "arguments": "{\"entity1\": \"FeedsFS.java\", \"entity2\": \"MetaInfo.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m40": {
                "content": "Despite the extensive use of `MetaInfo` within `FeedsFS.java`, there are no detected coupling dependencies between these two entities. This might indicate that the interactions with `MetaInfo` are either highly abstracted or indirect, possibly through inheritance or other mechanisms not captured by direct coupling analysis.\n\nGiven this pattern, it's possible that `FeedsFS.java` has more significant conceptual (semantic) coupling rather than structural coupling with certain entities. To explore this, I will now analyze the **conceptual coupling** between `FeedsFS.java` and one of its key collaborators based on semantic similarity.\n\nSince `FeedsFS` interacts heavily with `FeedDownloader`, which is likely a core collaborator, I will check the conceptual coupling with `FeedDownloader.java`.\n\nLet's proceed with this step.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_da69c03d053b42fe878dec",
                        "function": {
                            "arguments": "{\"entity1\": \"FeedsFS.java\", \"entity2\": \"FeedDownloader.java\"}",
                            "name": "get_conceptual_coupling"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m41": {
                "role": "tool",
                "name": "get_conceptual_coupling",
                "content": "\"0.70574313\""
            },
            "m42": {
                "content": "The conceptual coupling between `FeedsFS.java` and `FeedDownloader.java` is relatively high, with a semantic similarity score of approximately **0.706** (or 70.6%). This indicates that these two entities likely share related functionality or collaborate closely within the system, even if structural dependencies aren't always explicit.\n\nThis strong conceptual link suggests that changes in `FeedsFS.java` could potentially impact `FeedDownloader.java`, and vice versa. As part of Change Impact Analysis (CIA), it would be prudent to inspect this relationship further, especially since `FeedDownloader` appears to play a key role in the RSS feed downloading logic used by `FeedsFS`.\n\nNext, I will examine the call graph for `FeedsFS.java` to identify other entities it directly invokes or interacts with at runtime. This can help uncover additional dependencies that may need synchronization when changes occur.\n\nLet's proceed with retrieving the call graph for `FeedsFS.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_0651847ea2304250988a3e",
                        "function": {
                            "arguments": "{\"entity\": \"FeedsFS.java\"}",
                            "name": "get_call_graph"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m43": {
                "role": "tool",
                "name": "get_call_graph",
                "content": "[\"Tabs\", \"MApplication\", \"AbstractFS\", \"MColor\", \"FSNewFile\", \"MMenu\", \"Archive\", \"HTMLBuilder\", \"FS\", \"MTimer\", \"MPanel\", \"MCheckBoxTable\", \"OPMLWriter\", \"PluginSettings\", \"MNotification\", \"Flags\", \"FSDynamic\", \"MetaInfo\", \"MMessage\", \"MRadioButton\", \"MainWindow\", \"PluginManager\", \"MButton\", \"MArrayList\", \"MFileChooser\", \"MLogger\", \"PluginMenu\", \"Tree\", \"MDataAction\", \"FSNewFolder\", \"PluginInfo\", \"FileCache\", \"MSlider\", \"MTabbedPane\", \"MV\", \"MToolBar\", \"MAction\", \"Config\", \"FSHelper\", \"MText\", \"OPMLReader\", \"FSOpen\", \"TK\", \"UI\", \"Editor\", \"FSException\", \"MCheckBox\", \"ArchiveException\", \"MDialog\", \"MActionInfo\", \"ItemRenderer\", \"MIcon\", \"FSProperties\"]"
            },
            "m44": {
                "content": "The call graph for `FeedsFS.java` reveals a wide range of dependencies, indicating that this entity interacts with many other components in the system. These include core functionalities such as UI handling (`MainWindow`, `MMenu`, `MDialog`), configuration and file management (`Config`, `FSHelper`, `FileCache`), data structures (`Tree`, `MetaInfo`, `MV`), and RSS feed-specific logic (`OPMLReader`, `OPMLWriter`, `Archive`, `FeedDownloader`).\n\nKey entities that are likely to be impacted by changes in `FeedsFS.java` include:\n\n- **FeedDownloader.java** \u2013 Already shown to have high conceptual coupling.\n- **Archive.java** \u2013 Used heavily for managing RSS feed archives.\n- **OPMLReader.java / OPMLWriter.java** \u2013 Handle import/export of RSS feeds.\n- **MetaInfo.java** \u2013 Central to folder and file metadata management.\n- **Tree.java** \u2013 Manages navigation structure within the application.\n- **PluginInfo.java / PluginMenu.java** \u2013 Related to plugin functionality.\n\nTo ensure synchronization and proper change impact analysis, we should further examine structural or conceptual coupling with these key entities.\n\nLet\u2019s begin by checking coupling dependencies between `FeedsFS.java` and `Archive.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_1bb3c9aba4ea446a84cecb",
                        "function": {
                            "arguments": "{\"entity1\": \"FeedsFS.java\", \"entity2\": \"Archive.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m45": {
                "role": "user",
                "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
            },
            "m46": {
                "content": "Title: Diagnosis of starting entity `FeedsFS.java`  \nChange set: [FeedDownloader, Archive, OPMLReader, OPMLWriter, MetaInfo, Tree, PluginInfo, PluginMenu, MainWindow, MMenu, Config, FSHelper, FileCache, MNotification, MDialog, Editor, MAction, MButton, MPanel, MRadioButton, MCheckBox, MSlider, MToolBar, MTabbedPane, MV, UI, TK, MLogger, MMessage, Flags, FSException, ItemRenderer, MIcon, MColor, AbstractFS, FSDynamic, FSNewFile, FSNewFolder, FSOpen, FSProperties, MArrayList]  \n\nDetails:  \n- **FeedDownloader**: Strong conceptual coupling (0.706 similarity) and heavily used for feed downloading logic.  \n- **Archive**: Central to RSS feed archiving functionality and frequently accessed in methods like `download`, `refresh`, and `applyProperties`.  \n- **OPMLReader / OPMLWriter**: Used for importing/exporting feeds; key part of data interchange functionality in `FeedsFS`.  \n- **MetaInfo**: Widely used throughout the codebase for managing metadata of RSS items and folders.  \n- **Tree**: Manages folder/item hierarchy and expansion/collapsing behavior during feed updates.  \n- **PluginInfo / PluginMenu**: As a plugin-based feature, `FeedsFS` integrates with plugin infrastructure.  \n- **MainWindow**: Involved in UI interactions such as dialog display, tab management, and tree navigation.  \n- **MMenu**: Part of the menu structure that `FeedsFS` dynamically updates based on context.  \n- **Config**: Used extensively to store and retrieve feed settings like URLs, archive policies, etc.  \n- **FSHelper**: Used for file naming, escaping, and path manipulation tasks.  \n- **FileCache**: Used for favicon caching and resource cleanup.  \n- **MNotification**: Alerts users about feed-related events like errors or updates.  \n- **MDialog**: Used when showing user prompts during import/export or settings adjustment.  \n- **Editor**: Manages tabbed interface for viewing individual articles.  \n- **MAction / MButton**: Core UI components tied to actions like refresh, import, export, etc.  \n- **MPanel / MRadioButton / MCheckBox / MSlider**: UI elements used in property panels and dialogs.  \n- **MToolBar / MTabbedPane**: UI layout components affected by feed operations.  \n- **MV**: Used in scanning and listing feed items.  \n- **UI / TK / MLogger / MMessage**: Utility classes used across the implementation for general-purpose functions.  \n- **Flags**: Used for capability checks and state flags in meta info handling.  \n- **FSException**: Thrown during exceptional conditions in feed creation or I/O.  \n- **ItemRenderer**: Responsible for rendering visual properties like colors and icons in the tree view.  \n- **MIcon / MColor**: Used for icon overlays and unread color customization.  \n- **AbstractFS**: Base class providing core filesystem abstraction, though no direct coupling found.  \n- **FSDynamic / FSNewFile / FSNewFolder / FSOpen / FSProperties**: Interfaces implemented by `FeedsFS`; despite no direct coupling found, they are integral to its contract.  \n- **MArrayList**: Used in processing lists of feeds or articles.",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            }
        }
    }
}