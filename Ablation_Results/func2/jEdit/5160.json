{
    "time": 1749612393.10413,
    "messages": [
        {
            "role": "system",
            "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
        },
        {
            "role": "user",
            "content": "The project you need to analyze is `jEdit`, a well-known Java open source project. The starting entity you need to deal with is JEditTextArea.java."
        },
        {
            "content": "",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_0774b1c039c74eb9966fe4",
                    "function": {
                        "arguments": "{\"entity\": \"JEditTextArea.java\"}",
                        "name": "get_call_graph"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_call_graph",
            "content": "[\"\", \"\", \"\", \"\", \"Log\"]"
        },
        {
            "content": "",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_4f496e91a4c141bb880e77",
                    "function": {
                        "arguments": "{\"entity\": \"JEditTextArea.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package org.gjt.sp.jedit.textarea;\\nimport java.awt.*;\\nimport java.awt.event.*;\\nimport java.lang.reflect.Method;\\nimport java.util.Iterator;\\nimport java.util.LinkedList;\\nimport java.util.List;\\nimport java.util.Set;\\nimport java.util.TooManyListenersException;\\nimport java.util.TreeSet;\\nimport java.util.Vector;\\nimport javax.swing.*;\\nimport javax.swing.border.*;\\nimport javax.swing.event.*;\\nimport javax.swing.plaf.metal.MetalLookAndFeel;\\nimport javax.swing.text.Segment;\\nimport org.gjt.sp.jedit.*;\\nimport org.gjt.sp.jedit.buffer.*;\\nimport org.gjt.sp.jedit.gui.*;\\nimport org.gjt.sp.jedit.syntax.*;\\nimport org.gjt.sp.util.Log;\\npublic class JEditTextArea extends JComponent\\n{\\n\\tpublic JEditTextArea(View view)\\n\\t{\\n\\t\\tenableEvents(AWTEvent.FOCUS_EVENT_MASK | AWTEvent.KEY_EVENT_MASK);\\n\\t\\tthis.view = view;\\n\\t\\t\\t\\tselectionManager = new SelectionManager(this);\\n\\t\\tchunkCache = new ChunkCache(this);\\n\\t\\tpainter = new TextAreaPainter(this);\\n\\t\\tgutter = new Gutter(view,this);\\n\\t\\tlistenerList = new EventListenerList();\\n\\t\\tcaretEvent = new MutableCaretEvent();\\n\\t\\tblink = true;\\n\\t\\tlineSegment = new Segment();\\n\\t\\treturnValue = new Point();\\n\\t\\tstructureMatchers = new LinkedList();\\n\\t\\tstructureMatchers.add(new StructureMatcher.BracketMatcher());\\n\\t\\t\\t\\tsetLayout(new ScrollLayout());\\n\\t\\tadd(ScrollLayout.CENTER,painter);\\n\\t\\tadd(ScrollLayout.LEFT,gutter);\\n\\t\\t\\t\\tverticalBox = new Box(BoxLayout.X_AXIS);\\n\\t\\tverticalBox.add(vertical = new JScrollBar(JScrollBar.VERTICAL));\\n\\t\\tvertical.setRequestFocusEnabled(false);\\n\\t\\tadd(ScrollLayout.RIGHT,verticalBox);\\n\\t\\tadd(ScrollLayout.BOTTOM,\\n\\t\\t\\thorizontal = new JScrollBar(JScrollBar.HORIZONTAL));\\n\\t\\thorizontal.setRequestFocusEnabled(false);\\n\\t\\thorizontal.setValues(0,0,0,0);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(UIManager.getLookAndFeel() instanceof MetalLookAndFeel)\\n\\t\\t{\\n\\t\\t\\tsetBorder(new TextAreaBorder());\\n\\t\\t\\tvertical.putClientProperty(\\\"JScrollBar.isFreeStanding\\\",\\n\\t\\t\\t\\tBoolean.FALSE);\\n\\t\\t\\thorizontal.putClientProperty(\\\"JScrollBar.isFreeStanding\\\",\\n\\t\\t\\t\\tBoolean.FALSE);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\tvertical.addAdjustmentListener(new AdjustHandler());\\n\\t\\thorizontal.addAdjustmentListener(new AdjustHandler());\\n\\t\\tmouseHandler = new MouseHandler(this);\\n\\t\\tpainter.addMouseListener(mouseHandler);\\n\\t\\tpainter.addMouseMotionListener(mouseHandler);\\n\\t\\taddFocusListener(new FocusHandler());\\n\\t\\taddMouseWheelListener(new MouseWheelHandler());\\n\\t\\tsetTransferHandler(new TextAreaTransferHandler());\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tgetDropTarget().addDropTargetListener(\\n\\t\\t\\t\\tnew TextAreaDropHandler(this));\\n\\t\\t}\\n\\t\\tcatch(TooManyListenersException e)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.ERROR,this,e);\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\t\\t\\tfocusedComponent = this;\\n\\t\\tpopupEnabled = true;\\n\\t} \\n\\tpublic void dispose()\\n\\t{\\n\\t\\tDisplayManager.textAreaDisposed(this);\\n\\t} \\n\\tpublic View getView()\\n\\t{\\n\\t\\treturn view;\\n\\t} \\n\\tpublic InputHandler getInputHandler()\\n\\t{\\n\\t\\treturn view.getInputHandler();\\n\\t} \\n\\tpublic final TextAreaPainter getPainter()\\n\\t{\\n\\t\\treturn painter;\\n\\t} \\n\\tpublic final Gutter getGutter()\\n\\t{\\n\\t\\treturn gutter;\\n\\t} \\n\\tpublic DisplayManager getDisplayManager()\\n\\t{\\n\\t\\treturn displayManager;\\n\\t} \\n\\tpublic void setStatusMessage(String msg)\\n\\t{\\n\\t\\tview.getStatus().setMessageAndClear(msg);\\n\\t} \\n\\tpublic final boolean isCaretBlinkEnabled()\\n\\t{\\n\\t\\treturn caretBlinks;\\n\\t} \\n\\tpublic void setCaretBlinkEnabled(boolean caretBlinks)\\n\\t{\\n\\t\\tthis.caretBlinks = caretBlinks;\\n\\t\\tif(!caretBlinks)\\n\\t\\t\\tblink = false;\\n\\t\\tif(buffer != null)\\n\\t\\t\\tinvalidateLine(caretLine);\\n\\t} \\n\\tpublic final int getElectricScroll()\\n\\t{\\n\\t\\treturn electricScroll;\\n\\t} \\n\\tpublic final void setElectricScroll(int electricScroll)\\n\\t{\\n\\t\\tthis.electricScroll = electricScroll;\\n\\t} \\n\\tpublic final boolean isQuickCopyEnabled()\\n\\t{\\n\\t\\treturn quickCopy;\\n\\t} \\n\\tpublic final void setQuickCopyEnabled(boolean quickCopy)\\n\\t{\\n\\t\\tthis.quickCopy = quickCopy;\\n\\t} \\n\\tpublic final Buffer getBuffer()\\n\\t{\\n\\t\\treturn buffer;\\n\\t} \\n\\tpublic void setBuffer(Buffer buffer)\\n\\t{\\n\\t\\tif(this.buffer == buffer)\\n\\t\\t\\treturn;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbufferChanging = true;\\n\\t\\t\\tif(this.buffer != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\t\\tcaretLine = caret = caretScreenLine = 0;\\n\\t\\t\\t\\tmatch = null;\\n\\t\\t\\t}\\n\\t\\t\\tthis.buffer = buffer;\\n\\t\\t\\tchunkCache.setBuffer(buffer);\\n\\t\\t\\tpropertiesChanged();\\n\\t\\t\\tif(displayManager != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tDisplayManager.releaseDisplayManager(\\n\\t\\t\\t\\t\\tdisplayManager);\\n\\t\\t\\t}\\n\\t\\t\\tdisplayManager = DisplayManager.getDisplayManager(\\n\\t\\t\\t\\tbuffer,this);\\n\\t\\t\\tdisplayManager.init();\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\tupdateScrollBars();\\n\\t\\t\\trepaint();\\n\\t\\t\\tfireScrollEvent(true);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbufferChanging = false;\\n\\t\\t}\\n\\t} \\n\\tpublic final boolean isEditable()\\n\\t{\\n\\t\\treturn buffer.isEditable();\\n\\t} \\n\\tpublic boolean isDragInProgress()\\n\\t{\\n\\t\\treturn dndInProgress;\\n\\t} \\n\\tpublic void setDragInProgress(boolean dndInProgress)\\n\\t{\\n\\t\\tthis.dndInProgress = dndInProgress;\\n\\t} \\n\\tpublic boolean isDragEnabled()\\n\\t{\\n\\t\\treturn dndEnabled;\\n\\t} \\n\\tpublic void setDragEnabled(boolean dndEnabled)\\n\\t{\\n\\t\\tthis.dndEnabled = dndEnabled;\\n\\t} \\n\\tpublic final int getFirstLine()\\n\\t{\\n\\t\\treturn displayManager.firstLine.scrollLine\\n\\t\\t\\t+ displayManager.firstLine.skew;\\n\\t} \\n\\tpublic void setFirstLine(int firstLine)\\n\\t{\\n\\t\\t\\t\\tint max = displayManager.getScrollLineCount() - visibleLines\\n\\t\\t\\t+ (lastLinePartial ? 1 : 0);\\n\\t\\tif(firstLine > max)\\n\\t\\t\\tfirstLine = max;\\n\\t\\tif(firstLine < 0)\\n\\t\\t\\tfirstLine = 0;\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"setFirstLine() from \\\"\\n\\t\\t\\t\\t+ getFirstLine() + \\\" to \\\" + firstLine);\\n\\t\\t}\\n\\t\\tint oldFirstLine = getFirstLine();\\n\\t\\tif(firstLine == oldFirstLine)\\n\\t\\t\\treturn;\\n\\t\\tdisplayManager.setFirstLine(oldFirstLine,firstLine);\\n\\t\\trepaint();\\n\\t\\tfireScrollEvent(true);\\n\\t} \\n\\tpublic final int getFirstPhysicalLine()\\n\\t{\\n\\t\\treturn displayManager.firstLine.physicalLine;\\n\\t} \\n\\tpublic void setFirstPhysicalLine(int physFirstLine)\\n\\t{\\n\\t\\tsetFirstPhysicalLine(physFirstLine,0);\\n\\t} \\n\\tpublic void setFirstPhysicalLine(int physFirstLine, int skew)\\n\\t{\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"setFirstPhysicalLine(\\\"\\n\\t\\t\\t\\t+ physFirstLine + \\\",\\\" + skew + \\\")\\\");\\n\\t\\t}\\n\\t\\tint amount = (physFirstLine - displayManager.firstLine.physicalLine);\\n\\t\\tdisplayManager.setFirstPhysicalLine(amount,skew);\\n\\t\\trepaint();\\n\\t\\tfireScrollEvent(true);\\n\\t} \\n\\tpublic final int getLastPhysicalLine()\\n\\t{\\n\\t\\treturn physLastLine;\\n\\t} \\n\\tpublic int getLastScreenLine()\\n\\t{\\n\\t\\treturn screenLastLine;\\n\\t} \\n\\tpublic final int getVisibleLines()\\n\\t{\\n\\t\\treturn visibleLines;\\n\\t} \\n\\tpublic final int getHorizontalOffset()\\n\\t{\\n\\t\\treturn horizontalOffset;\\n\\t} \\n\\tpublic void setHorizontalOffset(int horizontalOffset)\\n\\t{\\n\\t\\tif(horizontalOffset > 0)\\n\\t\\t\\thorizontalOffset = 0;\\n\\t\\tif(horizontalOffset == this.horizontalOffset)\\n\\t\\t\\treturn;\\n\\t\\tthis.horizontalOffset = horizontalOffset;\\n\\t\\tif(horizontalOffset != horizontal.getValue())\\n\\t\\t\\tupdateScrollBars();\\n\\t\\tpainter.repaint();\\n\\t\\tfireScrollEvent(false);\\n\\t} \\n\\tpublic void scrollUpLine()\\n\\t{\\n\\t\\tsetFirstLine(getFirstLine() - 1);\\n\\t} \\n\\tpublic void scrollUpPage()\\n\\t{\\n\\t\\tsetFirstLine(getFirstLine() - getVisibleLines()\\n\\t\\t\\t+ (lastLinePartial ? 1 : 0));\\n\\t} \\n\\tpublic void scrollDownLine()\\n\\t{\\n\\t\\tsetFirstLine(getFirstLine() + 1);\\n\\t} \\n\\tpublic void scrollDownPage()\\n\\t{\\n\\t\\tsetFirstLine(getFirstLine() + getVisibleLines()\\n\\t\\t\\t- (lastLinePartial ? 1 : 0));\\n\\t} \\n\\tpublic void scrollToCaret(boolean doElectricScroll)\\n\\t{\\n\\t\\tscrollTo(caretLine,caret - buffer.getLineStartOffset(caretLine),\\n\\t\\t\\tdoElectricScroll);\\n\\t} \\n\\tpublic void scrollTo(int offset, boolean doElectricScroll)\\n\\t{\\n\\t\\tint line = buffer.getLineOfOffset(offset);\\n\\t\\tscrollTo(line,offset - buffer.getLineStartOffset(line),\\n\\t\\t\\tdoElectricScroll);\\n\\t} \\n\\tpublic void scrollTo(int line, int offset, boolean doElectricScroll)\\n\\t{\\n\\t\\tif(Debug.SCROLL_TO_DEBUG)\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"scrollTo(), lineCount=\\\"\\n\\t\\t\\t\\t+ getLineCount());\\n\\t\\t\\t\\tint extraEndVirt;\\n\\t\\tint lineLength = buffer.getLineLength(line);\\n\\t\\tif(offset > lineLength)\\n\\t\\t{\\n\\t\\t\\textraEndVirt = charWidth * (offset - lineLength);\\n\\t\\t\\toffset = lineLength;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\textraEndVirt = 0;\\n\\t\\tint _electricScroll = (doElectricScroll\\n\\t\\t\\t&& visibleLines - 1 > electricScroll * 2\\n\\t\\t\\t? electricScroll : 0); \\n\\t\\tif(visibleLines <= 1)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_TO_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"visibleLines <= 0\\\");\\n\\t\\t\\tsetFirstPhysicalLine(line,_electricScroll);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\t\\tint screenLine = chunkCache.getScreenLineOfOffset(line,offset);\\n\\t\\tint visibleLines = getVisibleLines();\\n\\t\\tif(screenLine == -1)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_TO_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"screenLine == -1\\\");\\n\\t\\t\\tChunkCache.LineInfo[] infos = chunkCache\\n\\t\\t\\t\\t.getLineInfosForPhysicalLine(line);\\n\\t\\t\\tint subregion = chunkCache.getSubregionOfOffset(\\n\\t\\t\\t\\toffset,infos);\\n\\t\\t\\tint prevLine = displayManager.getPrevVisibleLine(getFirstPhysicalLine());\\n\\t\\t\\tint nextLine = displayManager.getNextVisibleLine(getLastPhysicalLine());\\n\\t\\t\\tif(line == getFirstPhysicalLine())\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(Debug.SCROLL_TO_DEBUG)\\n\\t\\t\\t\\t\\tLog.log(Log.DEBUG,this,line + \\\" == \\\" + getFirstPhysicalLine());\\n\\t\\t\\t\\tsetFirstPhysicalLine(line,subregion\\n\\t\\t\\t\\t\\t- _electricScroll);\\n\\t\\t\\t}\\n\\t\\t\\telse if(line == prevLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(Debug.SCROLL_TO_DEBUG)\\n\\t\\t\\t\\t\\tLog.log(Log.DEBUG,this,line + \\\" == \\\" + prevLine);\\n\\t\\t\\t\\tsetFirstPhysicalLine(prevLine,subregion\\n\\t\\t\\t\\t\\t- _electricScroll);\\n\\t\\t\\t}\\n\\t\\t\\telse if(line == getLastPhysicalLine())\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(Debug.SCROLL_TO_DEBUG)\\n\\t\\t\\t\\t\\tLog.log(Log.DEBUG,this,line + \\\" == \\\" + getLastPhysicalLine());\\n\\t\\t\\t\\tsetFirstPhysicalLine(line,\\n\\t\\t\\t\\t\\tsubregion + _electricScroll\\n\\t\\t\\t\\t\\t- visibleLines\\n\\t\\t\\t\\t\\t+ (lastLinePartial ? 2 : 1));\\n\\t\\t\\t}\\n\\t\\t\\telse if(line == nextLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(Debug.SCROLL_TO_DEBUG)\\n\\t\\t\\t\\t\\tLog.log(Log.DEBUG,this,line + \\\" == \\\" + nextLine);\\n\\t\\t\\t\\tsetFirstPhysicalLine(nextLine,\\n\\t\\t\\t\\t\\tsubregion + electricScroll\\n\\t\\t\\t\\t\\t- visibleLines\\n\\t\\t\\t\\t\\t+ (lastLinePartial ? 2 : 1));\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(Debug.SCROLL_TO_DEBUG)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"neither\\\");\\n\\t\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"Last physical line is \\\" + getLastPhysicalLine());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsetFirstPhysicalLine(line,subregion\\n\\t\\t\\t\\t\\t- visibleLines / 2);\\n\\t\\t\\t\\tif(Debug.SCROLL_TO_DEBUG)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"Last physical line is \\\" + getLastPhysicalLine());\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(screenLine < _electricScroll)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_TO_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"electric up\\\");\\n\\t\\t\\tsetFirstLine(getFirstLine() - _electricScroll + screenLine);\\n\\t\\t}\\n\\t\\telse if(screenLine > visibleLines - _electricScroll\\n\\t\\t\\t- (lastLinePartial ? 2 : 1))\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_TO_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"electric down\\\");\\n\\t\\t\\tsetFirstLine(getFirstLine() + _electricScroll - visibleLines + screenLine + (lastLinePartial ? 2 : 1));\\n\\t\\t} \\n\\t\\t\\t\\tif(!displayManager.isLineVisible(line))\\n\\t\\t\\treturn;\\n\\t\\tPoint point = offsetToXY(line,offset,returnValue);\\n\\t\\tif(point == null)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.ERROR,this,\\\"BUG: screenLine=\\\" + screenLine\\n\\t\\t\\t\\t+ \\\",visibleLines=\\\" + visibleLines\\n\\t\\t\\t\\t+ \\\",physicalLine=\\\" + line\\n\\t\\t\\t\\t+ \\\",firstPhysicalLine=\\\" + getFirstPhysicalLine()\\n\\t\\t\\t\\t+ \\\",lastPhysicalLine=\\\" + getLastPhysicalLine());\\n\\t\\t}\\n\\t\\tpoint.x += extraEndVirt;\\n\\t\\tif(point.x < 0)\\n\\t\\t{\\n\\t\\t\\tsetHorizontalOffset(horizontalOffset\\n\\t\\t\\t\\t- point.x + charWidth + 5);\\n\\t\\t}\\n\\t\\telse if(point.x >= painter.getWidth() - charWidth - 5)\\n\\t\\t{\\n\\t\\t\\tsetHorizontalOffset(horizontalOffset +\\n\\t\\t\\t\\t(painter.getWidth() - point.x)\\n\\t\\t\\t\\t- charWidth - 5);\\n\\t\\t} \\t} \\n\\tpublic final void addScrollListener(ScrollListener listener)\\n\\t{\\n\\t\\tlistenerList.add(ScrollListener.class,listener);\\n\\t} \\n\\tpublic final void removeScrollListener(ScrollListener listener)\\n\\t{\\n\\t\\tlistenerList.remove(ScrollListener.class,listener);\\n\\t} \\n\\tpublic int getPhysicalLineOfScreenLine(int screenLine)\\n\\t{\\n\\t\\treturn chunkCache.getLineInfo(screenLine).physicalLine;\\n\\t} \\n\\tpublic int getScreenLineOfOffset(int offset)\\n\\t{\\n\\t\\tint line = buffer.getLineOfOffset(offset);\\n\\t\\toffset -= buffer.getLineStartOffset(line);\\n\\t\\treturn chunkCache.getScreenLineOfOffset(line,offset);\\n\\t} \\n\\tpublic int getScreenLineStartOffset(int line)\\n\\t{\\n\\t\\tChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);\\n\\t\\tif(lineInfo.physicalLine == -1)\\n\\t\\t\\treturn -1;\\n\\t\\treturn buffer.getLineStartOffset(lineInfo.physicalLine)\\n\\t\\t\\t+ lineInfo.offset;\\n\\t} \\n\\tpublic int getScreenLineEndOffset(int line)\\n\\t{\\n\\t\\tChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);\\n\\t\\tif(lineInfo.physicalLine == -1)\\n\\t\\t\\treturn -1;\\n\\t\\treturn buffer.getLineStartOffset(lineInfo.physicalLine)\\n\\t\\t\\t+ lineInfo.offset + lineInfo.length;\\n\\t} \\n\\tpublic int xyToOffset(int x, int y)\\n\\t{\\n\\t\\treturn xyToOffset(x,y,true);\\n\\t} \\n\\tpublic int xyToOffset(int x, int y, boolean round)\\n\\t{\\n\\t\\tFontMetrics fm = painter.getFontMetrics();\\n\\t\\tint height = fm.getHeight();\\n\\t\\tint line = y / height;\\n\\t\\tif(line < 0 || line >= visibleLines)\\n\\t\\t\\treturn -1;\\n\\t\\treturn xToScreenLineOffset(line,x,round);\\n\\t} \\n\\tpublic int xToScreenLineOffset(int screenLine, int x, boolean round)\\n\\t{\\n\\t\\tChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(screenLine);\\n\\t\\tif(lineInfo.physicalLine == -1)\\n\\t\\t{\\n\\t\\t\\treturn getLineEndOffset(displayManager\\n\\t\\t\\t\\t.getLastVisibleLine()) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint offset = Chunk.xToOffset(lineInfo.chunks,\\n\\t\\t\\t\\tx - horizontalOffset,round);\\n\\t\\t\\tif(offset == -1 || offset == lineInfo.offset + lineInfo.length)\\n\\t\\t\\t\\toffset = lineInfo.offset + lineInfo.length - 1;\\n\\t\\t\\treturn getLineStartOffset(lineInfo.physicalLine) + offset;\\n\\t\\t}\\n\\t} \\n\\tpublic Point offsetToXY(int offset)\\n\\t{\\n\\t\\tint line = buffer.getLineOfOffset(offset);\\n\\t\\toffset -= buffer.getLineStartOffset(line);\\n\\t\\tPoint retVal = new Point();\\n\\t\\treturn offsetToXY(line,offset,retVal);\\n\\t} \\n\\tpublic Point offsetToXY(int line, int offset)\\n\\t{\\n\\t\\treturn offsetToXY(line,offset,new Point());\\n\\t} \\n\\tpublic Point offsetToXY(int line, int offset, Point retVal)\\n\\t{\\n\\t\\tif(!displayManager.isLineVisible(line))\\n\\t\\t\\treturn null;\\n\\t\\tint screenLine = chunkCache.getScreenLineOfOffset(line,offset);\\n\\t\\tif(screenLine == -1)\\n\\t\\t\\treturn null;\\n\\t\\tFontMetrics fm = painter.getFontMetrics();\\n\\t\\tretVal.y = screenLine * fm.getHeight();\\n\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(screenLine);\\n\\t\\tretVal.x = (int)(horizontalOffset + Chunk.offsetToX(\\n\\t\\t\\tinfo.chunks,offset));\\n\\t\\treturn retVal;\\n\\t} \\n\\tpublic void invalidateScreenLineRange(int start, int end)\\n\\t{\\n\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\treturn;\\n\\t\\tif(start > end)\\n\\t\\t{\\n\\t\\t\\tint tmp = end;\\n\\t\\t\\tend = start;\\n\\t\\t\\tstart = tmp;\\n\\t\\t}\\n\\t\\tif(chunkCache.needFullRepaint())\\n\\t\\t\\tend = visibleLines;\\n\\t\\tFontMetrics fm = painter.getFontMetrics();\\n\\t\\tint y = start * fm.getHeight();\\n\\t\\tint height = (end - start + 1) * fm.getHeight();\\n\\t\\tpainter.repaint(0,y,painter.getWidth(),height);\\n\\t\\tgutter.repaint(0,y,gutter.getWidth(),height);\\n\\t} \\n\\tpublic void invalidateLine(int line)\\n\\t{\\n\\t\\tif(!isShowing()\\n\\t\\t\\t|| !buffer.isLoaded()\\n\\t\\t\\t|| line < getFirstPhysicalLine()\\n\\t\\t\\t|| line > physLastLine\\n\\t\\t\\t|| !displayManager.isLineVisible(line))\\n\\t\\t\\treturn;\\n\\t\\tint startLine = -1;\\n\\t\\tint endLine = -1;\\n\\t\\tfor(int i = 0; i < visibleLines; i++)\\n\\t\\t{\\n\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(i);\\n\\t\\t\\tif((info.physicalLine >= line || info.physicalLine == -1)\\n\\t\\t\\t\\t&& startLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstartLine = i;\\n\\t\\t\\t}\\n\\t\\t\\tif((info.physicalLine >= line && info.lastSubregion)\\n\\t\\t\\t\\t|| info.physicalLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tendLine = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(chunkCache.needFullRepaint() || endLine == -1)\\n\\t\\t\\tendLine = visibleLines;\\n\\t\\tinvalidateScreenLineRange(startLine,endLine);\\n\\t} \\n\\tpublic void invalidateLineRange(int start, int end)\\n\\t{\\n\\t\\tif(!isShowing() || !buffer.isLoaded())\\n\\t\\t\\treturn;\\n\\t\\tif(end < start)\\n\\t\\t{\\n\\t\\t\\tint tmp = end;\\n\\t\\t\\tend = start;\\n\\t\\t\\tstart = tmp;\\n\\t\\t}\\n\\t\\tif(end < getFirstPhysicalLine() || start > getLastPhysicalLine())\\n\\t\\t\\treturn;\\n\\t\\tint startScreenLine = -1;\\n\\t\\tint endScreenLine = -1;\\n\\t\\tfor(int i = 0; i < visibleLines; i++)\\n\\t\\t{\\n\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(i);\\n\\t\\t\\tif((info.physicalLine >= start || info.physicalLine == -1)\\n\\t\\t\\t\\t&& startScreenLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstartScreenLine = i;\\n\\t\\t\\t}\\n\\t\\t\\tif((info.physicalLine >= end && info.lastSubregion)\\n\\t\\t\\t\\t|| info.physicalLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tendScreenLine = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(startScreenLine == -1)\\n\\t\\t\\tstartScreenLine = 0;\\n\\t\\tif(chunkCache.needFullRepaint() || endScreenLine == -1)\\n\\t\\t\\tendScreenLine = visibleLines;\\n\\t\\tinvalidateScreenLineRange(startScreenLine,endScreenLine);\\n\\t} \\n\\tpublic final int getBufferLength()\\n\\t{\\n\\t\\treturn buffer.getLength();\\n\\t} \\n\\tpublic final int getLineCount()\\n\\t{\\n\\t\\treturn buffer.getLineCount();\\n\\t} \\n\\tpublic final int getLineOfOffset(int offset)\\n\\t{\\n\\t\\treturn buffer.getLineOfOffset(offset);\\n\\t} \\n\\tpublic int getLineStartOffset(int line)\\n\\t{\\n\\t\\treturn buffer.getLineStartOffset(line);\\n\\t} \\n\\tpublic int getLineEndOffset(int line)\\n\\t{\\n\\t\\treturn buffer.getLineEndOffset(line);\\n\\t} \\n\\tpublic int getLineLength(int line)\\n\\t{\\n\\t\\treturn buffer.getLineLength(line);\\n\\t} \\n\\tpublic final String getText(int start, int len)\\n\\t{\\n\\t\\treturn buffer.getText(start,len);\\n\\t} \\n\\tpublic final void getText(int start, int len, Segment segment)\\n\\t{\\n\\t\\tbuffer.getText(start,len,segment);\\n\\t} \\n\\tpublic final String getLineText(int lineIndex)\\n\\t{\\n\\t\\treturn buffer.getLineText(lineIndex);\\n\\t} \\n\\tpublic final void getLineText(int lineIndex, Segment segment)\\n\\t{\\n\\t\\tbuffer.getLineText(lineIndex,segment);\\n\\t} \\n\\tpublic String getText()\\n\\t{\\n\\t\\treturn buffer.getText(0,buffer.getLength());\\n\\t} \\n\\tpublic void setText(String text)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tbuffer.remove(0,buffer.getLength());\\n\\t\\t\\tbuffer.insert(0,text);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic final void selectAll()\\n\\t{\\n\\t\\tint firstLine = getFirstLine();\\n\\t\\tint horizOffset = getHorizontalOffset();\\n\\t\\tsetSelection(new Selection.Range(0,buffer.getLength()));\\n\\t\\tmoveCaretPosition(buffer.getLength(),true);\\n\\t\\tsetFirstLine(firstLine);\\n\\t\\tsetHorizontalOffset(horizOffset);\\n\\t} \\n\\tpublic void selectLine()\\n\\t{\\n\\t\\tint caretLine = getCaretLine();\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine) - 1;\\n\\t\\tSelection s = new Selection.Range(start,end);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(end);\\n\\t} \\n\\tpublic void selectParagraph()\\n\\t{\\n\\t\\tint caretLine = getCaretLine();\\n\\t\\tif(getLineLength(caretLine) == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint start = caretLine;\\n\\t\\tint end = caretLine;\\n\\t\\twhile(start >= 0)\\n\\t\\t{\\n\\t\\t\\tif(getLineLength(start) == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\telse\\n\\t\\t\\t\\tstart--;\\n\\t\\t}\\n\\t\\twhile(end < getLineCount())\\n\\t\\t{\\n\\t\\t\\tif(getLineLength(end) == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\telse\\n\\t\\t\\t\\tend++;\\n\\t\\t}\\n\\t\\tint selectionStart = getLineStartOffset(start + 1);\\n\\t\\tint selectionEnd = getLineEndOffset(end - 1) - 1;\\n\\t\\tSelection s = new Selection.Range(selectionStart,selectionEnd);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(selectionEnd);\\n\\t} \\n\\tpublic void selectWord()\\n\\t{\\n\\t\\tint line = getCaretLine();\\n\\t\\tint lineStart = getLineStartOffset(line);\\n\\t\\tint offset = getCaretPosition() - lineStart;\\n\\t\\tif(getLineLength(line) == 0)\\n\\t\\t\\treturn;\\n\\t\\tString lineText = getLineText(line);\\n\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\tif(offset == getLineLength(line))\\n\\t\\t\\toffset--;\\n\\t\\tint wordStart = TextUtilities.findWordStart(lineText,offset,noWordSep);\\n\\t\\tint wordEnd = TextUtilities.findWordEnd(lineText,offset+1,noWordSep);\\n\\t\\tSelection s = new Selection.Range(lineStart + wordStart,\\n\\t\\t\\tlineStart + wordEnd);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(lineStart + wordEnd);\\n\\t} \\n\\tpublic Selection selectToMatchingBracket(int position,\\n\\t\\tboolean quickCopy)\\n\\t{\\n\\t\\tint positionLine = buffer.getLineOfOffset(position);\\n\\t\\tint lineOffset = position - buffer.getLineStartOffset(positionLine);\\n\\t\\tif(getLineLength(positionLine) != 0)\\n\\t\\t{\\n\\t\\t\\tint bracket = TextUtilities.findMatchingBracket(buffer,\\n\\t\\t\\t\\tpositionLine,Math.max(0,lineOffset - 1));\\n\\t\\t\\tif(bracket != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s;\\n\\t\\t\\t\\tif(bracket < position)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!quickCopy)\\n\\t\\t\\t\\t\\t\\tmoveCaretPosition(position,false);\\n\\t\\t\\t\\t\\ts = new Selection.Range(bracket,position);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!quickCopy)\\n\\t\\t\\t\\t\\t\\tmoveCaretPosition(bracket + 1,false);\\n\\t\\t\\t\\t\\ts = new Selection.Range(position - 1,bracket + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!multi && !quickCopy)\\n\\t\\t\\t\\t\\tselectNone();\\n\\t\\t\\t\\taddToSelection(s);\\n\\t\\t\\t\\treturn s;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic void selectToMatchingBracket()\\n\\t{\\n\\t\\tselectToMatchingBracket(caret,false);\\n\\t} \\n\\tpublic void selectBlock()\\n\\t{\\n\\t\\tString openBrackets = \\\"([{\\\";\\n\\t\\tString closeBrackets = \\\")]}\\\";\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint start, end;\\n\\t\\tif(s == null)\\n\\t\\t\\tstart = end = caret;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstart = s.start;\\n\\t\\t\\tend = s.end;\\n\\t\\t}\\n\\t\\tString text = getText(0,buffer.getLength());\\n\\t\\t\\t\\tint count = 1;\\n\\t\\tchar openBracket = '\\\\0';\\n\\t\\tchar closeBracket = '\\\\0';\\n\\t\\t\\t\\tif(start == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\nbackward_scan:\\twhile(--start > 0)\\n\\t\\t{\\n\\t\\t\\tchar c = text.charAt(start);\\n\\t\\t\\tint index = openBrackets.indexOf(c);\\n\\t\\t\\tif(index != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(--count == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\topenBracket = c;\\n\\t\\t\\t\\t\\tcloseBracket = closeBrackets.charAt(index);\\n\\t\\t\\t\\t\\tbreak backward_scan;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(closeBrackets.indexOf(c) != -1)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\t\\t\\tcount = 1;\\n\\t\\t\\t\\tif(openBracket == '\\\\0')\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\nforward_scan:\\t\\tdo\\n\\t\\t\\t{\\n\\t\\t\\t\\tchar c = text.charAt(end);\\n\\t\\t\\t\\tif(c == closeBracket)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(--count == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend++;\\n\\t\\t\\t\\t\\t\\tbreak forward_scan;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(c == openBracket)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\twhile(++end < buffer.getLength());\\n\\t\\t}\\n\\t\\ts = new Selection.Range(start,end);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(end);\\n\\t} \\n\\tpublic boolean lineInStructureScope(int line)\\n\\t{\\n\\t\\tif(match == null)\\n\\t\\t\\treturn false;\\n\\t\\tif(match.startLine < caretLine)\\n\\t\\t\\treturn (line >= match.startLine && line <= caretLine);\\n\\t\\telse\\n\\t\\t\\treturn (line <= match.endLine && line >= caretLine);\\n\\t} \\n\\tpublic final void invertSelection()\\n\\t{\\n\\t\\tselectionManager.invertSelection();\\n\\t} \\n\\tpublic int getSelectionCount()\\n\\t{\\n\\t\\treturn selectionManager.getSelectionCount();\\n\\t} \\n\\tpublic Selection[] getSelection()\\n\\t{\\n\\t\\treturn selectionManager.getSelection();\\n\\t} \\n\\tpublic Iterator getSelectionIterator()\\n\\t{\\n\\t\\treturn selectionManager.selection.iterator();\\n\\t} \\n\\tpublic Selection getSelection(int index)\\n\\t{\\n\\t\\treturn (Selection)selectionManager.selection.get(index);\\n\\t} \\n\\tpublic void selectNone()\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tsetSelection((Selection)null);\\n\\t} \\n\\tpublic void setSelection(Selection[] selection)\\n\\t{\\n\\t\\t\\t\\tinvalidateSelectedLines();\\n\\t\\tselectionManager.setSelection(selection);\\n\\t\\tfinishCaretUpdate(caretLine,NO_SCROLL,true);\\n\\t} \\n\\tpublic void setSelection(Selection selection)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tselectionManager.setSelection(selection);\\n\\t\\tfinishCaretUpdate(caretLine,NO_SCROLL,true);\\n\\t} \\n\\tpublic void addToSelection(Selection[] selection)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tselectionManager.addToSelection(selection);\\n\\t\\tfinishCaretUpdate(caretLine,NO_SCROLL,true);\\n\\t} \\n\\tpublic void addToSelection(Selection selection)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tselectionManager.addToSelection(selection);\\n\\t\\tfinishCaretUpdate(caretLine,NO_SCROLL,true);\\n\\t} \\n\\tpublic Selection getSelectionAtOffset(int offset)\\n\\t{\\n\\t\\treturn selectionManager.getSelectionAtOffset(offset);\\n\\t} \\n\\tpublic void removeFromSelection(Selection sel)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tselectionManager.removeFromSelection(sel);\\n\\t\\tfinishCaretUpdate(caretLine,NO_SCROLL,true);\\n\\t} \\n\\tpublic void removeFromSelection(int offset)\\n\\t{\\n\\t\\tSelection sel = getSelectionAtOffset(offset);\\n\\t\\tif(sel == null)\\n\\t\\t\\treturn;\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tselectionManager.removeFromSelection(sel);\\n\\t\\tfinishCaretUpdate(caretLine,NO_SCROLL,true);\\n\\t} \\n\\tpublic void resizeSelection(int offset, int end, int extraEndVirt,\\n\\t\\tboolean rect)\\n\\t{\\n\\t\\tSelection s = selectionManager.getSelectionAtOffset(offset);\\n\\t\\tif(s != null)\\n\\t\\t{\\n\\t\\t\\tinvalidateLineRange(s.startLine,s.endLine);\\n\\t\\t\\tselectionManager.removeFromSelection(s);\\n\\t\\t}\\n\\t\\tselectionManager.resizeSelection(offset,end,extraEndVirt,rect);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void extendSelection(int offset, int end)\\n\\t{\\n\\t\\textendSelection(offset,end,0,0);\\n\\t} \\n\\tpublic void extendSelection(int offset, int end,\\n\\t\\tint extraStartVirt, int extraEndVirt)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(offset);\\n\\t\\tif(s != null)\\n\\t\\t{\\n\\t\\t\\tinvalidateLineRange(s.startLine,s.endLine);\\n\\t\\t\\tselectionManager.removeFromSelection(s);\\n\\t\\t\\tif(offset == s.start)\\n\\t\\t\\t{\\n\\t\\t\\t\\toffset = end;\\n\\t\\t\\t\\tend = s.end;\\n\\t\\t\\t}\\n\\t\\t\\telse if(offset == s.end)\\n\\t\\t\\t{\\n\\t\\t\\t\\toffset = s.start;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(end < offset)\\n\\t\\t{\\n\\t\\t\\tint tmp = end;\\n\\t\\t\\tend = offset;\\n\\t\\t\\toffset = tmp;\\n\\t\\t}\\n\\t\\tif(rectangularSelectionMode)\\n\\t\\t{\\n\\t\\t\\ts = new Selection.Rect(offset,end);\\n\\t\\t\\t((Selection.Rect)s).extraStartVirt = extraStartVirt;\\n\\t\\t\\t((Selection.Rect)s).extraEndVirt = extraEndVirt;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\ts = new Selection.Range(offset,end);\\n\\t\\tselectionManager.addToSelection(s);\\n\\t\\tfireCaretEvent();\\n\\t\\tif(rectangularSelectionMode && extraEndVirt != 0)\\n\\t\\t{\\n\\t\\t\\tint line = getLineOfOffset(end);\\n\\t\\t\\tscrollTo(line,getLineLength(line) + extraEndVirt,false);\\n\\t\\t}\\n\\t} \\n\\tpublic String getSelectedText(Selection s)\\n\\t{\\n\\t\\tStringBuffer buf = new StringBuffer();\\n\\t\\ts.getText(buffer,buf);\\n\\t\\treturn buf.toString();\\n\\t} \\n\\tpublic String getSelectedText(String separator)\\n\\t{\\n\\t\\tSelection[] sel = selectionManager.getSelection();\\n\\t\\tif(sel.length == 0)\\n\\t\\t\\treturn null;\\n\\t\\tStringBuffer buf = new StringBuffer();\\n\\t\\tfor(int i = 0; i < sel.length; i++)\\n\\t\\t{\\n\\t\\t\\tif(i != 0)\\n\\t\\t\\t\\tbuf.append(separator);\\n\\t\\t\\tsel[i].getText(buffer,buf);\\n\\t\\t}\\n\\t\\treturn buf.toString();\\n\\t} \\n\\tpublic String getSelectedText()\\n\\t{\\n\\t\\treturn getSelectedText(\\\"\\\\n\\\");\\n\\t} \\n\\tpublic void setSelectedText(Selection s, String selectedText)\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tthrow new InternalError(\\\"Text component\\\"\\n\\t\\t\\t\\t+ \\\" read only\\\");\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tmoveCaretPosition(s.setText(buffer,selectedText));\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\t\\t\\t\\t} \\n\\tpublic void setSelectedText(String selectedText)\\n\\t{\\n\\t\\tint newCaret = replaceSelection(selectedText);\\n\\t\\tif(newCaret != -1)\\n\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic void setSelectedText(String selectedText, boolean moveCaret)\\n\\t{\\n\\t\\tint newCaret = replaceSelection(selectedText);\\n\\t\\tif(moveCaret && newCaret != -1)\\n\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic int replaceSelection(String selectedText)\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t\\tthrow new RuntimeException(\\\"Text component read only\\\");\\n\\t\\tint newCaret = -1;\\n\\t\\tif(getSelectionCount() == 0)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.insert(caret,selectedText);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tSelection[] selection = getSelection();\\n\\t\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t\\t\\tnewCaret = selection[i].setText(buffer,selectedText);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn newCaret;\\n\\t} \\n\\tpublic int[] getSelectedLines()\\n\\t{\\n\\t\\tif(selectionManager.getSelectionCount() == 0)\\n\\t\\t\\treturn new int[] { caretLine };\\n\\t\\treturn selectionManager.getSelectedLines();\\n\\t} \\n\\tpublic void addStructureMatcher(StructureMatcher matcher)\\n\\t{\\n\\t\\tstructureMatchers.add(matcher);\\n\\t} \\n\\tpublic void removeStructureMatcher(StructureMatcher matcher)\\n\\t{\\n\\t\\tstructureMatchers.remove(matcher);\\n\\t} \\n\\tpublic StructureMatcher.Match getStructureMatch()\\n\\t{\\n\\t\\treturn match;\\n\\t} \\n\\tpublic final void blinkCaret()\\n\\t{\\n\\t\\tif(caretBlinks)\\n\\t\\t{\\n\\t\\t\\tblink = !blink;\\n\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tblink = true;\\n\\t} \\n\\tpublic void centerCaret()\\n\\t{\\n\\t\\tint offset = getScreenLineStartOffset(visibleLines / 2);\\n\\t\\tif(offset == -1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t\\tsetCaretPosition(offset);\\n\\t} \\n\\tpublic void setCaretPosition(int newCaret)\\n\\t{\\n\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret,true);\\n\\t} \\n\\tpublic void setCaretPosition(int newCaret, boolean doElectricScroll)\\n\\t{\\n\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret,doElectricScroll);\\n\\t} \\n\\tpublic void moveCaretPosition(int newCaret)\\n\\t{\\n\\t\\tmoveCaretPosition(newCaret,true);\\n\\t} \\n\\tpublic void moveCaretPosition(int newCaret, boolean doElectricScroll)\\n\\t{\\n\\t\\tmoveCaretPosition(newCaret,doElectricScroll ? ELECTRIC_SCROLL\\n\\t\\t\\t: NORMAL_SCROLL);\\n\\t} \\n\\t\\tpublic static int NO_SCROLL = 0;\\n\\tpublic static int NORMAL_SCROLL = 1;\\n\\tpublic static int ELECTRIC_SCROLL = 2;\\n\\tpublic void moveCaretPosition(int newCaret, int scrollMode)\\n\\t{\\n\\t\\tif(newCaret < 0 || newCaret > buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tthrow new IllegalArgumentException(\\\"caret out of bounds: \\\"\\n\\t\\t\\t\\t+ newCaret);\\n\\t\\t}\\n\\t\\tint oldCaretLine = caretLine;\\n\\t\\tif(caret == newCaret)\\n\\t\\t\\tfinishCaretUpdate(oldCaretLine,scrollMode,false);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcaret = newCaret;\\n\\t\\t\\tcaretLine = getLineOfOffset(newCaret);\\n\\t\\t\\tmagicCaret = -1;\\n\\t\\t\\tfinishCaretUpdate(oldCaretLine,scrollMode,true);\\n\\t\\t}\\n\\t} \\n\\tpublic int getCaretPosition()\\n\\t{\\n\\t\\treturn caret;\\n\\t} \\n\\tpublic int getCaretLine()\\n\\t{\\n\\t\\treturn caretLine;\\n\\t} \\n\\tpublic int getMagicCaretPosition()\\n\\t{\\n\\t\\tif(magicCaret == -1)\\n\\t\\t{\\n\\t\\t\\tmagicCaret = chunkCache.subregionOffsetToX(\\n\\t\\t\\t\\tcaretLine,caret - getLineStartOffset(caretLine));\\n\\t\\t}\\n\\t\\treturn magicCaret;\\n\\t} \\n\\tpublic void setMagicCaretPosition(int magicCaret)\\n\\t{\\n\\t\\tthis.magicCaret = magicCaret;\\n\\t} \\n\\tpublic final void addCaretListener(CaretListener listener)\\n\\t{\\n\\t\\tlistenerList.add(CaretListener.class,listener);\\n\\t} \\n\\tpublic final void removeCaretListener(CaretListener listener)\\n\\t{\\n\\t\\tlistenerList.remove(CaretListener.class,listener);\\n\\t} \\n\\tpublic void goToNextBracket(boolean select)\\n\\t{\\n\\t\\tint newCaret = -1;\\n\\t\\tif(caret != buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tString text = getText(caret,buffer.getLength()\\n\\t\\t\\t\\t- caret - 1);\\nloop:\\t\\t\\tfor(int i = 0; i < text.length(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(text.charAt(i))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ')': case ']': case '}':\\n\\t\\t\\t\\t\\tnewCaret = caret + i + 1;\\n\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(newCaret == -1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(select)\\n\\t\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\t\\telse if(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t}\\n\\t} \\n\\tpublic void goToNextCharacter(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(!select && s instanceof Selection.Range)\\n\\t\\t{\\n\\t\\t\\tif(multi)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caret != s.end)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmoveCaretPosition(s.end);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetCaretPosition(s.end);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint extraStartVirt, extraEndVirt;\\n\\t\\tif(s instanceof Selection.Rect)\\n\\t\\t{\\n\\t\\t\\textraStartVirt = ((Selection.Rect)s).extraStartVirt;\\n\\t\\t\\textraEndVirt = ((Selection.Rect)s).extraEndVirt;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\textraStartVirt = 0;\\n\\t\\t\\textraEndVirt = 0;\\n\\t\\t}\\n\\t\\tint newCaret = caret;\\n\\t\\tif(caret == buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tif(select && (rectangularSelectionMode || s instanceof Selection.Rect))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s != null && caret == s.start)\\n\\t\\t\\t\\t\\textraStartVirt++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\textraEndVirt++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(caret == getLineEndOffset(caretLine) - 1)\\n\\t\\t{\\n\\t\\t\\tif(select && (rectangularSelectionMode || s instanceof Selection.Rect))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s != null && caret == s.start)\\n\\t\\t\\t\\t\\textraStartVirt++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\textraEndVirt++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint line = displayManager.getNextVisibleLine(caretLine);\\n\\t\\t\\t\\tif(line == -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tnewCaret = getLineStartOffset(line);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tnewCaret = caret + 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret,extraStartVirt,extraEndVirt);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToNextLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tboolean rectSelect = (s == null ? rectangularSelectionMode\\n\\t\\t\\t: s instanceof Selection.Rect);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = chunkCache.getBelowPosition(caretLine,\\n\\t\\t\\tcaret - buffer.getLineStartOffset(caretLine),magic + 1,\\n\\t\\t\\trectSelect && select);\\n\\t\\tif(newCaret == -1)\\n\\t\\t{\\n\\t\\t\\tint end = getLineEndOffset(caretLine) - 1;\\n\\t\\t\\tif(caret == end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tnewCaret = end;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t{\\n\\t\\t\\tRectParams params = getRectParams(caret,newCaret);\\n\\t\\t\\tint extraStartVirt;\\n\\t\\t\\tint extraEndVirt;\\n\\t\\t\\tif(params == null)\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = 0;\\n\\t\\t\\t\\textraEndVirt = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = params.extraStartVirt;\\n\\t\\t\\t\\textraEndVirt = params.extraEndVirt;\\n\\t\\t\\t\\tnewCaret = params.newCaret;\\n\\t\\t\\t}\\n\\t\\t\\textendSelection(caret,newCaret,extraStartVirt,extraEndVirt);\\n\\t\\t}\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToNextMarker(boolean select)\\n\\t{\\n\\t\\tVector markers = buffer.getMarkers();\\n\\t\\tif(markers.size() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tMarker marker = null;\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker _marker = (Marker)markers.get(i);\\n\\t\\t\\tif(_marker.getPosition() > caret)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmarker = _marker;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(marker == null)\\n\\t\\t\\tmarker = (Marker)markers.get(0);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,marker.getPosition());\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(marker.getPosition());\\n\\t} \\n\\tpublic void goToNextPage(boolean select)\\n\\t{\\n\\t\\tscrollToCaret(false);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tif(caretLine < displayManager.getFirstVisibleLine())\\n\\t\\t{\\n\\t\\t\\tcaretLine = displayManager.getNextVisibleLine(\\n\\t\\t\\t\\tcaretLine);\\n\\t\\t}\\n\\t\\tint newCaret;\\n\\t\\tif(getFirstLine() + getVisibleLines() >= displayManager\\n\\t\\t\\t.getScrollLineCount())\\n\\t\\t{\\n\\t\\t\\tint lastVisibleLine = displayManager\\n\\t\\t\\t\\t.getLastVisibleLine();\\n\\t\\t\\tnewCaret = getLineEndOffset(lastVisibleLine) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint caretScreenLine = getScreenLineOfOffset(caret);\\n\\t\\t\\tscrollDownPage();\\n\\t\\t\\tnewCaret = xToScreenLineOffset(caretScreenLine,\\n\\t\\t\\t\\tmagic,true);\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret,false);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToNextParagraph(boolean select)\\n\\t{\\n\\t\\tint lineNo = getCaretLine();\\n\\t\\tint newCaret = getBufferLength();\\n\\t\\tboolean foundBlank = false;\\nloop:\\t\\tfor(int i = lineNo + 1; i < getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tif(!displayManager.isLineVisible(i))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif(foundBlank)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnewCaret = getLineStartOffset(i);\\n\\t\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfoundBlank = true;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToNextWord(boolean select)\\n\\t{\\n\\t\\tgoToNextWord(select,false);\\n\\t} \\n\\tpublic void goToNextWord(boolean select, boolean eatWhitespace)\\n\\t{\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint newCaret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(newCaret == lineText.length())\\n\\t\\t{\\n\\t\\t\\tint nextLine = displayManager.getNextVisibleLine(caretLine);\\n\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret = getLineStartOffset(nextLine);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tnewCaret = TextUtilities.findWordEnd(lineText,\\n\\t\\t\\t\\tnewCaret + 1,noWordSep,true,eatWhitespace);\\n\\t\\t\\tnewCaret += lineStart;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToPrevBracket(boolean select)\\n\\t{\\n\\t\\tString text = getText(0,caret);\\n\\t\\tint newCaret = -1;\\nloop:\\t\\tfor(int i = getCaretPosition() - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tswitch(text.charAt(i))\\n\\t\\t\\t{\\n\\t\\t\\tcase '(': case '[': case '{':\\n\\t\\t\\t\\tnewCaret = i;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(newCaret == -1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(select)\\n\\t\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\t\\telse if(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t}\\n\\t} \\n\\tpublic void goToPrevCharacter(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(!select && s instanceof Selection.Range)\\n\\t\\t{\\n\\t\\t\\tif(multi)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caret != s.start)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmoveCaretPosition(s.start);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetCaretPosition(s.start);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint extraStartVirt = 0;\\n\\t\\tint extraEndVirt = 0;\\n\\t\\tint newCaret = caret;\\n\\t\\tif(select && caret == getLineEndOffset(caretLine) - 1)\\n\\t\\t{\\n\\t\\t\\tif(s instanceof Selection.Rect)\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = ((Selection.Rect)s).extraStartVirt;\\n\\t\\t\\t\\textraEndVirt = ((Selection.Rect)s).extraEndVirt;\\n\\t\\t\\t\\tif(caret == s.start)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(extraStartVirt == 0)\\n\\t\\t\\t\\t\\t\\tnewCaret = caret - 1;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\textraStartVirt--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(extraEndVirt == 0)\\n\\t\\t\\t\\t\\t\\tnewCaret = caret - 1;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\textraEndVirt--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tnewCaret = caret - 1;\\n\\t\\t}\\n\\t\\telse if(caret == getLineStartOffset(caretLine))\\n\\t\\t{\\n\\t\\t\\tint line = displayManager.getPrevVisibleLine(caretLine);\\n\\t\\t\\tif(line == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret = getLineEndOffset(line) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tnewCaret = caret - 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret,extraStartVirt,extraEndVirt);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToPrevLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tboolean rectSelect = (s == null ? rectangularSelectionMode\\n\\t\\t\\t: s instanceof Selection.Rect);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = chunkCache.getAbovePosition(caretLine,\\n\\t\\t\\tcaret - buffer.getLineStartOffset(caretLine),magic + 1,\\n\\t\\t\\trectSelect && select);\\n\\t\\tif(newCaret == -1)\\n\\t\\t{\\n\\t\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\t\\tif(caret == start)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tnewCaret = start;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t{\\n\\t\\t\\tRectParams params = getRectParams(caret,newCaret);\\n\\t\\t\\tint extraStartVirt;\\n\\t\\t\\tint extraEndVirt;\\n\\t\\t\\tif(params == null)\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = 0;\\n\\t\\t\\t\\textraEndVirt = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = params.extraStartVirt;\\n\\t\\t\\t\\textraEndVirt = params.extraEndVirt;\\n\\t\\t\\t\\tnewCaret = params.newCaret;\\n\\t\\t\\t}\\n\\t\\t\\textendSelection(caret,newCaret,extraStartVirt,extraEndVirt);\\n\\t\\t}\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToPrevMarker(boolean select)\\n\\t{\\n\\t\\tVector markers = buffer.getMarkers();\\n\\t\\tif(markers.size() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tMarker marker = null;\\n\\t\\tfor(int i = markers.size() - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tMarker _marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tif(_marker.getPosition() < caret)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmarker = _marker;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(marker == null)\\n\\t\\t\\tmarker = (Marker)markers.get(markers.size() - 1);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,marker.getPosition());\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(marker.getPosition());\\n\\t} \\n\\tpublic void goToPrevPage(boolean select)\\n\\t{\\n\\t\\tscrollToCaret(false);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tif(caretLine < displayManager.getFirstVisibleLine())\\n\\t\\t{\\n\\t\\t\\tcaretLine = displayManager.getNextVisibleLine(\\n\\t\\t\\t\\tcaretLine);\\n\\t\\t}\\n\\t\\tint newCaret;\\n\\t\\tif(getFirstLine() == 0)\\n\\t\\t{\\n\\t\\t\\tint firstVisibleLine = displayManager\\n\\t\\t\\t\\t.getFirstVisibleLine();\\n\\t\\t\\tnewCaret = getLineStartOffset(firstVisibleLine);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint caretScreenLine = getScreenLineOfOffset(caret);\\n\\t\\t\\tscrollUpPage();\\n\\t\\t\\tnewCaret = xToScreenLineOffset(caretScreenLine,\\n\\t\\t\\t\\tmagic,true);\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret,false);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToPrevParagraph(boolean select)\\n\\t{\\n\\t\\tint lineNo = caretLine;\\n\\t\\tint newCaret = 0;\\n\\t\\tboolean foundBlank = false;\\nloop:\\t\\tfor(int i = lineNo - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(!displayManager.isLineVisible(i))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif(foundBlank)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnewCaret = getLineEndOffset(i) - 1;\\n\\t\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfoundBlank = true;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToPrevWord(boolean select)\\n\\t{\\n\\t\\tgoToPrevWord(select,false);\\n\\t} \\n\\tpublic void goToPrevWord(boolean select, boolean eatWhitespace)\\n\\t{\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint newCaret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(newCaret == 0)\\n\\t\\t{\\n\\t\\t\\tif(lineStart == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint prevLine = displayManager.getPrevVisibleLine(caretLine);\\n\\t\\t\\t\\tif(prevLine == -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnewCaret = getLineEndOffset(prevLine) - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tnewCaret = TextUtilities.findWordStart(lineText,\\n\\t\\t\\t\\tnewCaret - 1,noWordSep,true,eatWhitespace);\\n\\t\\t\\tnewCaret += lineStart;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void smartHome(boolean select)\\n\\t{\\n\\t\\tMacros.Recorder recorder = view.getMacroRecorder();\\n\\t\\tswitch(view.getInputHandler().getLastActionCount())\\n\\t\\t{\\n\\t\\tcase 1:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToStartOfWhiteSpace(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToStartOfWhiteSpace(select);\\n\\t\\t\\tbreak;\\n\\t\\tcase 2:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToStartOfLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToStartOfLine(select);\\n\\t\\t\\tbreak;\\n\\t\\tdefault: \\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToFirstVisibleLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToFirstVisibleLine(select);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t} \\n\\tpublic void smartEnd(boolean select)\\n\\t{\\n\\t\\tMacros.Recorder recorder = view.getMacroRecorder();\\n\\t\\tswitch(view.getInputHandler().getLastActionCount())\\n\\t\\t{\\n\\t\\tcase 1:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToEndOfWhiteSpace(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToEndOfWhiteSpace(select);\\n\\t\\t\\tbreak;\\n\\t\\tcase 2:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToEndOfLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToEndOfLine(select);\\n\\t\\t\\tbreak;\\n\\t\\tdefault: \\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToLastVisibleLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToLastVisibleLine(select);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t} \\n\\tpublic void goToStartOfLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line = (select || s == null\\n\\t\\t\\t? caretLine : s.startLine);\\n\\t\\tint newCaret = getLineStartOffset(line);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToEndOfLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line = (select || s == null\\n\\t\\t\\t? caretLine : s.endLine);\\n\\t\\tint newCaret = getLineEndOffset(line) - 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t\\t\\t\\t\\t\\t} \\n\\tpublic void goToStartOfWhiteSpace(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line, offset;\\n\\t\\tif(select || s == null)\\n\\t\\t{\\n\\t\\t\\tline = caretLine;\\n\\t\\t\\toffset = caret - buffer.getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tline = s.startLine;\\n\\t\\t\\toffset = s.start - buffer.getLineStartOffset(line);\\n\\t\\t}\\n\\t\\tint firstIndent = chunkCache.getSubregionStartOffset(line,offset);\\n\\t\\tif(firstIndent == getLineStartOffset(line))\\n\\t\\t{\\n\\t\\t\\tfirstIndent = MiscUtilities.getLeadingWhiteSpace(getLineText(line));\\n\\t\\t\\tif(firstIndent == getLineLength(line))\\n\\t\\t\\t\\tfirstIndent = 0;\\n\\t\\t\\tfirstIndent += getLineStartOffset(line);\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,firstIndent);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(firstIndent);\\n\\t} \\n\\tpublic void goToEndOfWhiteSpace(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line, offset;\\n\\t\\tif(select || s == null)\\n\\t\\t{\\n\\t\\t\\tline = caretLine;\\n\\t\\t\\toffset = caret - getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tline = s.endLine;\\n\\t\\t\\toffset = s.end - getLineStartOffset(line);\\n\\t\\t}\\n\\t\\tint lastIndent = chunkCache.getSubregionEndOffset(line,offset);\\n\\t\\tif(lastIndent == getLineEndOffset(line))\\n\\t\\t{\\n\\t\\t\\tlastIndent = getLineLength(line) - MiscUtilities.getTrailingWhiteSpace(getLineText(line));\\n\\t\\t\\tif(lastIndent == 0)\\n\\t\\t\\t\\tlastIndent = getLineLength(line);\\n\\t\\t\\tlastIndent += getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlastIndent--;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,lastIndent);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(lastIndent);\\n\\t} \\n\\tpublic void goToFirstVisibleLine(boolean select)\\n\\t{\\n\\t\\tint firstVisibleLine = getFirstLine() == 0 ? 0 : electricScroll;\\n\\t\\tint firstVisible = getScreenLineStartOffset(firstVisibleLine);\\n\\t\\tif(firstVisible == -1)\\n\\t\\t{\\n\\t\\t\\tfirstVisible = getLineStartOffset(displayManager\\n\\t\\t\\t\\t.getFirstVisibleLine());\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,firstVisible);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(firstVisible);\\n\\t} \\n\\tpublic void goToLastVisibleLine(boolean select)\\n\\t{\\n\\t\\tint lastVisible;\\n\\t\\tif(getFirstLine() + visibleLines >=\\n\\t\\t\\tdisplayManager.getScrollLineCount())\\n\\t\\t{\\n\\t\\t\\tlastVisible = getLineEndOffset(displayManager\\n\\t\\t\\t\\t.getLastVisibleLine()) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlastVisible = visibleLines - electricScroll - 1;\\n\\t\\t\\tif(lastLinePartial)\\n\\t\\t\\t\\tlastVisible--;\\n\\t\\t\\tif(lastVisible < 0)\\n\\t\\t\\t\\tlastVisible = 0;\\n\\t\\t\\tlastVisible = getScreenLineEndOffset(lastVisible) - 1;\\n\\t\\t\\tif(lastVisible == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlastVisible = getLineEndOffset(displayManager\\n\\t\\t\\t\\t\\t.getLastVisibleLine()) - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,lastVisible);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(lastVisible);\\n\\t} \\n\\tpublic void goToBufferStart(boolean select)\\n\\t{\\n\\t\\tint start = buffer.getLineStartOffset(\\n\\t\\t\\tdisplayManager.getFirstVisibleLine());\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,start);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(start);\\n\\t} \\n\\tpublic void goToBufferEnd(boolean select)\\n\\t{\\n\\t\\tint end = buffer.getLineEndOffset(\\n\\t\\t\\tdisplayManager.getLastVisibleLine()) - 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,end);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(end);\\n\\t} \\n\\tpublic void goToMatchingBracket()\\n\\t{\\n\\t\\tif(getLineLength(caretLine) != 0)\\n\\t\\t{\\n\\t\\t\\tint dot = caret - getLineStartOffset(caretLine);\\n\\t\\t\\tint bracket = TextUtilities.findMatchingBracket(\\n\\t\\t\\t\\tbuffer,caretLine,Math.max(0,dot - 1));\\n\\t\\t\\tif(bracket != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\t\\tmoveCaretPosition(bracket + 1,false);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tgetToolkit().beep();\\n\\t} \\n\\tpublic void showGoToLineDialog()\\n\\t{\\n\\t\\tString line = GUIUtilities.input(view,\\\"goto-line\\\",null);\\n\\t\\tif(line == null)\\n\\t\\t\\treturn;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tint lineNumber = Integer.parseInt(line) - 1;\\n\\t\\t\\tsetCaretPosition(getLineStartOffset(lineNumber));\\n\\t\\t}\\n\\t\\tcatch(Exception e)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t}\\n\\t} \\n\\tpublic void userInput(char ch)\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(ch == ' ' && Abbrevs.getExpandOnInput()\\n\\t\\t\\t&& Abbrevs.expandAbbrev(view,false))\\n\\t\\t\\treturn;\\n\\t\\tif(ch == '\\\\t')\\n\\t\\t{\\n\\t\\t\\tuserInputTab();\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tString indentOpenBrackets = (String)buffer\\n\\t\\t\\t\\t.getProperty(\\\"indentOpenBrackets\\\");\\n\\t\\t\\tString indentCloseBrackets = (String)buffer\\n\\t\\t\\t\\t.getProperty(\\\"indentCloseBrackets\\\");\\n\\t\\t\\tboolean indent = ((indentCloseBrackets != null\\n\\t\\t\\t\\t&& indentCloseBrackets.indexOf(ch) != -1)\\n\\t\\t\\t\\t|| (indentOpenBrackets != null\\n\\t\\t\\t\\t&& indentOpenBrackets.indexOf(ch) != -1));\\n\\t\\t\\tString str = String.valueOf(ch);\\n\\t\\t\\tif(getSelectionCount() == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(ch == ' ')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!doWordWrap(true))\\n\\t\\t\\t\\t\\t\\tinsert(str,indent);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdoWordWrap(false);\\n\\t\\t\\t\\t\\tinsert(str,indent);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\treplaceSelection(str);\\n\\t\\t}\\n\\t} \\n\\tpublic final boolean isOverwriteEnabled()\\n\\t{\\n\\t\\treturn overwrite;\\n\\t} \\n\\tpublic final void setOverwriteEnabled(boolean overwrite)\\n\\t{\\n\\t\\tblink = true;\\n\\t\\tcaretTimer.restart();\\n\\t\\tthis.overwrite = overwrite;\\n\\t\\tinvalidateLine(caretLine);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t\\tview.getStatus().updateMiscStatus();\\n\\t} \\n\\tpublic final void toggleOverwriteEnabled()\\n\\t{\\n\\t\\tsetOverwriteEnabled(!overwrite);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t{\\n\\t\\t\\tview.getStatus().setMessageAndClear(\\n\\t\\t\\t\\tjEdit.getProperty(\\\"view.status.overwrite-changed\\\",\\n\\t\\t\\t\\tnew Integer[] { new Integer(overwrite ? 1 : 0) }));\\n\\t\\t}\\n\\t} \\n\\tpublic void backspace()\\n\\t{\\n\\t\\tdelete(false);\\n\\t} \\n\\tpublic void backspaceWord()\\n\\t{\\n\\t\\tbackspaceWord(false);\\n\\t} \\n\\tpublic void backspaceWord(boolean eatWhitespace)\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(getSelectionCount() != 0)\\n\\t\\t{\\n\\t\\t\\tsetSelectedText(\\\"\\\");\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint _caret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(_caret == 0)\\n\\t\\t{\\n\\t\\t\\tif(lineStart == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t_caret--;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\t_caret = TextUtilities.findWordStart(lineText,_caret-1,\\n\\t\\t\\t\\tnoWordSep,true,eatWhitespace);\\n\\t\\t}\\n\\t\\tbuffer.remove(_caret + lineStart,\\n\\t\\t\\tcaret - (_caret + lineStart));\\n\\t} \\n\\tpublic void delete()\\n\\t{\\n\\t\\tdelete(true);\\n\\t} \\n\\tpublic void deleteToEndOfLine()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.remove(caret,getLineEndOffset(caretLine)\\n\\t\\t\\t- caret - 1);\\n\\t} \\n\\tpublic void deleteLine()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine);\\n\\t\\tint x = chunkCache.subregionOffsetToX(caretLine,caret - start);\\n\\t\\t\\t\\t\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tif(end > buffer.getLength())\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(start != 0)\\n\\t\\t\\t\\t\\tstart--;\\n\\t\\t\\t\\tend--;\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tbuffer.remove(start,end - start);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\tint lastLine = displayManager.getLastVisibleLine();\\n\\t\\tif(caretLine == lastLine)\\n\\t\\t{\\n\\t\\t\\tint offset = chunkCache.xToSubregionOffset(lastLine,0,x,true);\\n\\t\\t\\tsetCaretPosition(buffer.getLineStartOffset(lastLine)\\n\\t\\t\\t\\t+ offset);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint offset = chunkCache.xToSubregionOffset(caretLine,0,x,true);\\n\\t\\t\\tsetCaretPosition(start + offset);\\n\\t\\t}\\n\\t} \\n\\tpublic void deleteParagraph()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint start = 0, end = buffer.getLength();\\nloop:\\t\\tfor(int i = caretLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tstart = getLineStartOffset(i);\\n\\t\\t\\tbreak loop;\\n\\t\\t}\\nloop:\\t\\tfor(int i = caretLine + 1; i < getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tend = getLineEndOffset(i) - 1;\\n\\t\\t\\tbreak loop;\\n\\t\\t}\\n\\t\\tbuffer.remove(start,end - start);\\n\\t} \\n\\tpublic void deleteToStartOfLine()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.remove(getLineStartOffset(caretLine),\\n\\t\\t\\tcaret - getLineStartOffset(caretLine));\\n\\t} \\n\\tpublic void deleteWord()\\n\\t{\\n\\t\\tdeleteWord(false);\\n\\t} \\n\\tpublic void deleteWord(boolean eatWhitespace)\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(getSelectionCount() != 0)\\n\\t\\t{\\n\\t\\t\\tsetSelectedText(\\\"\\\");\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint _caret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(_caret == lineText.length())\\n\\t\\t{\\n\\t\\t\\tif(lineStart + _caret == buffer.getLength())\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t_caret++;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\t_caret = TextUtilities.findWordEnd(lineText,\\n\\t\\t\\t\\t_caret+1,noWordSep,true,eatWhitespace);\\n\\t\\t}\\n\\t\\tbuffer.remove(caret,(_caret + lineStart) - caret);\\n\\t} \\n\\tpublic final boolean isMultipleSelectionEnabled()\\n\\t{\\n\\t\\treturn multi;\\n\\t} \\n\\tpublic final void toggleMultipleSelectionEnabled()\\n\\t{\\n\\t\\tsetMultipleSelectionEnabled(!multi);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t{\\n\\t\\t\\tview.getStatus().setMessageAndClear(\\n\\t\\t\\t\\tjEdit.getProperty(\\\"view.status.multi-changed\\\",\\n\\t\\t\\t\\tnew Integer[] { new Integer(multi ? 1 : 0) }));\\n\\t\\t}\\n\\t} \\n\\tpublic final void setMultipleSelectionEnabled(boolean multi)\\n\\t{\\n\\t\\tthis.multi = multi;\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t\\tview.getStatus().updateMiscStatus();\\n\\t\\tpainter.repaint();\\n\\t} \\n\\tpublic final boolean isRectangularSelectionEnabled()\\n\\t{\\n\\t\\treturn rectangularSelectionMode;\\n\\t} \\n\\tpublic final void toggleRectangularSelectionEnabled()\\n\\t{\\n\\t\\tsetRectangularSelectionEnabled(!rectangularSelectionMode);\\n\\t\\tif(getSelectionCount() == 1)\\n\\t\\t{\\n\\t\\t\\tSelection s = getSelection(0);\\n\\t\\t\\tremoveFromSelection(s);\\n\\t\\t\\tif(rectangularSelectionMode)\\n\\t\\t\\t{\\n\\t\\t\\t\\taddToSelection(new Selection.Rect(\\n\\t\\t\\t\\t\\ts.getStart(),s.getEnd()));\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\taddToSelection(new Selection.Range(\\n\\t\\t\\t\\t\\ts.getStart(),s.getEnd()));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t{\\n\\t\\t\\tview.getStatus().setMessageAndClear(\\n\\t\\t\\t\\tjEdit.getProperty(\\\"view.status.rect-select-changed\\\",\\n\\t\\t\\t\\tnew Integer[] { new Integer(rectangularSelectionMode ? 1 : 0) }));\\n\\t\\t}\\n\\t} \\n\\tpublic final void setRectangularSelectionEnabled(\\n\\t\\tboolean rectangularSelectionMode)\\n\\t{\\n\\t\\tthis.rectangularSelectionMode = rectangularSelectionMode;\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t\\tview.getStatus().updateMiscStatus();\\n\\t\\tpainter.repaint();\\n\\t} \\n\\tpublic void goToMarker(char shortcut, boolean select)\\n\\t{\\n\\t\\tMarker marker = buffer.getMarker(shortcut);\\n\\t\\tif(marker == null)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint pos = marker.getPosition();\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,pos);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(pos);\\n\\t} \\n\\tpublic void addMarker()\\n\\t{\\n\\t\\t\\t\\tSelection[] selection = getSelection();\\n\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\tif(s.startLine != s.endLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s.startLine != caretLine)\\n\\t\\t\\t\\t\\tbuffer.addMarker('\\\\0',s.start);\\n\\t\\t\\t}\\n\\t\\t\\tif(s.endLine != caretLine)\\n\\t\\t\\t\\tbuffer.addMarker('\\\\0',s.end);\\n\\t\\t}\\n\\t\\t\\t\\tbuffer.addOrRemoveMarker('\\\\0',caret);\\n\\t} \\n\\tpublic void swapMarkerAndCaret(char shortcut)\\n\\t{\\n\\t\\tMarker marker = buffer.getMarker(shortcut);\\n\\t\\tif(marker == null)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint caret = getCaretPosition();\\n\\t\\tsetCaretPosition(marker.getPosition());\\n\\t\\tbuffer.addMarker(shortcut,caret);\\n\\t} \\n\\tpublic void goToParentFold()\\n\\t{\\n\\t\\tint line = -1;\\n\\t\\tint level = buffer.getFoldLevel(caretLine);\\n\\t\\tfor(int i = caretLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(buffer.getFoldLevel(i) < level)\\n\\t\\t\\t{\\n\\t\\t\\t\\tline = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(line == -1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = buffer.getLineStartOffset(line)\\n\\t\\t\\t+ chunkCache.xToSubregionOffset(line,0,magic + 1,true);\\n\\t\\tif(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToNextFold(boolean select)\\n\\t{\\n\\t\\tint nextFold = -1;\\n\\t\\tfor(int i = caretLine + 1; i < buffer.getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tif(buffer.isFoldStart(i)\\n\\t\\t\\t\\t&& displayManager.isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\tnextFold = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(nextFold == -1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = buffer.getLineStartOffset(nextFold)\\n\\t\\t\\t+ chunkCache.xToSubregionOffset(nextFold,0,magic + 1,true);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToPrevFold(boolean select)\\n\\t{\\n\\t\\tint prevFold = -1;\\n\\t\\tfor(int i = caretLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(buffer.isFoldStart(i)\\n\\t\\t\\t\\t&& displayManager.isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\tprevFold = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(prevFold == -1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = buffer.getLineStartOffset(prevFold)\\n\\t\\t\\t+ chunkCache.xToSubregionOffset(prevFold,0,magic + 1,true);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void collapseFold()\\n\\t{\\n\\t\\tint x = chunkCache.subregionOffsetToX(caretLine,\\n\\t\\t\\tcaret - getLineStartOffset(caretLine));\\n\\t\\tdisplayManager.collapseFold(caretLine);\\n\\t\\tif(displayManager.isLineVisible(caretLine))\\n\\t\\t\\treturn;\\n\\t\\tint line = displayManager.getPrevVisibleLine(caretLine);\\n\\t\\tif(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(buffer.getLineStartOffset(line)\\n\\t\\t\\t+ chunkCache.xToSubregionOffset(line,0,x,true));\\n\\t} \\n\\tpublic void expandFold(boolean fully)\\n\\t{\\n\\t\\tint x = chunkCache.subregionOffsetToX(caretLine,\\n\\t\\t\\tcaret - getLineStartOffset(caretLine));\\n\\t\\tint line = displayManager.expandFold(caretLine,fully);\\n\\t\\tif(!fully && line != -1)\\n\\t\\t{\\n\\t\\t\\tif(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\tmoveCaretPosition(getLineStartOffset(line)\\n\\t\\t\\t\\t+ chunkCache.xToSubregionOffset(line,0,x,true));\\n\\t\\t}\\n\\t} \\n\\tpublic void selectFold()\\n\\t{\\n\\t\\tselectFold(caretLine);\\n\\t} \\n\\tpublic void selectFold(int line)\\n\\t{\\n\\t\\tint[] lines = buffer.getFoldAtLine(line);\\n\\t\\tint newCaret = getLineEndOffset(lines[1]) - 1;\\n\\t\\tSelection s = new Selection.Range(getLineStartOffset(lines[0]),newCaret);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void narrowToFold()\\n\\t{\\n\\t\\tint[] lines = buffer.getFoldAtLine(caretLine);\\n\\t\\tif(lines[0] == 0 && lines[1] == buffer.getLineCount() - 1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t\\tdisplayManager.narrow(lines[0],lines[1]);\\n\\t} \\n\\tpublic void narrowToSelection()\\n\\t{\\n\\t\\tif(getSelectionCount() != 1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tSelection sel = getSelection(0);\\n\\t\\tdisplayManager.narrow(sel.getStartLine(),sel.getEndLine());\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic void addExplicitFold()\\n\\t{\\n\\t\\tif(!buffer.getStringProperty(\\\"folding\\\").equals(\\\"explicit\\\"))\\n\\t\\t{\\n\\t\\t\\tGUIUtilities.error(view,\\\"folding-not-explicit\\\",null);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tString lineComment = buffer.getContextSensitiveProperty(caret,\\\"lineComment\\\");\\n\\t\\tString commentStart = buffer.getContextSensitiveProperty(caret,\\\"commentStart\\\");\\n\\t\\tString commentEnd = buffer.getContextSensitiveProperty(caret,\\\"commentEnd\\\");\\n\\t\\tString start, end;\\n\\t\\tif(lineComment != null)\\n\\t\\t{\\n\\t\\t\\tstart = lineComment + \\\"{{{ \\\\n\\\";\\n\\t\\t\\tend = lineComment + \\\"}}}\\\";\\n\\t\\t}\\n\\t\\telse if(commentStart != null && commentEnd != null)\\n\\t\\t{\\n\\t\\t\\tstart = commentStart + \\\"{{{  \\\" + commentEnd + \\\"\\\\n\\\";\\n\\t\\t\\tend = commentStart + \\\"}}}\\\" + commentEnd;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstart = \\\"{{{ \\\\n\\\";\\n\\t\\t\\tend = \\\"}}}\\\";\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tif(getSelectionCount() == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tString line = buffer.getLineText(caretLine);\\n\\t\\t\\t\\tString whitespace = line.substring(0,\\n\\t\\t\\t\\t\\tMiscUtilities.getLeadingWhiteSpace(line));\\n\\t\\t\\t\\tint loc = caret + start.length() - 1;\\n\\t\\t\\t\\tstart = start + whitespace;\\n\\t\\t\\t\\tbuffer.insert(caret,start);\\n\\t\\t\\t\\t\\t\\t\\t\\tbuffer.insert(caret,end);\\n\\t\\t\\t\\tmoveCaretPosition(loc,false);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint loc = -1;\\n\\t\\t\\t\\tSelection[] sel = getSelection();\\n\\t\\t\\t\\tfor(int i = 0; i < sel.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection s = sel[i];\\n\\t\\t\\t\\t\\tString line = buffer.getLineText(s.startLine);\\n\\t\\t\\t\\t\\tString whitespace = line.substring(0,\\n\\t\\t\\t\\t\\t\\tMiscUtilities.getLeadingWhiteSpace(line));\\n\\t\\t\\t\\t\\tloc = s.start + start.length() - 1;\\n\\t\\t\\t\\t\\tbuffer.insert(s.start,start + whitespace);\\n\\t\\t\\t\\t\\tif(s.end == buffer.getLineStartOffset(\\n\\t\\t\\t\\t\\t\\ts.endLine))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.insert(s.end,end);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.insert(s.end,\\\" \\\" + end);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsetCaretPosition(loc,false);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void lineComment()\\n\\t{\\n\\t\\tString comment = buffer.getContextSensitiveProperty(caret,\\\"lineComment\\\");\\n\\t\\tif(!buffer.isEditable() || comment == null || comment.length() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tcomment = comment + ' ';\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tint[] lines = getSelectedLines();\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < lines.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tString text = getLineText(lines[i]);\\n\\t\\t\\t\\tbuffer.insert(getLineStartOffset(lines[i])\\n\\t\\t\\t\\t\\t+ MiscUtilities.getLeadingWhiteSpace(text),\\n\\t\\t\\t\\t\\tcomment);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic void rangeComment()\\n\\t{\\n\\t\\tString commentStart = buffer.getContextSensitiveProperty(caret,\\\"commentStart\\\");\\n\\t\\tString commentEnd = buffer.getContextSensitiveProperty(caret,\\\"commentEnd\\\");\\n\\t\\tif(!buffer.isEditable() || commentStart == null || commentEnd == null\\n\\t\\t\\t|| commentStart.length() == 0 || commentEnd.length() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tcommentStart = commentStart + ' ';\\n\\t\\tcommentEnd = ' ' + commentEnd;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tSelection[] selection = getSelection();\\n\\t\\t\\tif(selection.length == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint oldCaret = caret;\\n\\t\\t\\t\\tbuffer.insert(caret,commentStart);\\n\\t\\t\\t\\tbuffer.insert(caret,commentEnd);\\n\\t\\t\\t\\tsetCaretPosition(oldCaret + commentStart.length());\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tif(s instanceof Selection.Range)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbuffer.insert(s.start,commentStart);\\n\\t\\t\\t\\t\\tbuffer.insert(s.end,commentEnd);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(s instanceof Selection.Rect)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection.Rect rect = (Selection.Rect)s;\\n\\t\\t\\t\\t\\tint start = rect.getStartColumn(buffer);\\n\\t\\t\\t\\t\\tint end = rect.getEndColumn(buffer);\\n\\t\\t\\t\\t\\tfor(int j = s.startLine; j <= s.endLine; j++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.insertAtColumn(j,end,\\n\\t\\t\\t\\t\\t\\t\\tcommentEnd);\\n\\t\\t\\t\\t\\t\\tbuffer.insertAtColumn(j,start,\\n\\t\\t\\t\\t\\t\\t\\tcommentStart);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tselectNone();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void formatParagraph()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(maxLineLen <= 0)\\n\\t\\t{\\n\\t\\t\\tGUIUtilities.error(view,\\\"format-maxlinelen\\\",null);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(selection.length != 0)\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tsetSelectedText(s,TextUtilities.format(\\n\\t\\t\\t\\t\\tgetSelectedText(s),maxLineLen,\\n\\t\\t\\t\\t\\tbuffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint lineNo = getCaretLine();\\n\\t\\t\\tint start = 0, end = buffer.getLength();\\nloop:\\t\\t\\tfor(int i = lineNo - 1; i >= 0; i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstart = getLineEndOffset(i);\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\nloop:\\t\\t\\tfor(int i = lineNo + 1; i < getLineCount(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tend = getLineStartOffset(i) - 1;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tString text = buffer.getText(start,end - start);\\n\\t\\t\\t\\tbuffer.remove(start,end - start);\\n\\t\\t\\t\\tbuffer.insert(start,TextUtilities.format(\\n\\t\\t\\t\\t\\ttext,maxLineLen,buffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic void spacesToTabs()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tif(selection.length == 0)\\n\\t\\t{\\n\\t\\t\\tsetText(TextUtilities.spacesToTabs(\\n\\t\\t\\t\\tgetText(), buffer.getTabSize()));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tsetSelectedText(s,TextUtilities.spacesToTabs(\\n\\t\\t\\t\\t\\tgetSelectedText(s),buffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void tabsToSpaces()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tif(selection.length == 0)\\n\\t\\t{\\n\\t\\t\\tsetText(TextUtilities.tabsToSpaces(\\n\\t\\t\\t\\tgetText(), buffer.getTabSize()));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tsetSelectedText(s,TextUtilities.tabsToSpaces(\\n\\t\\t\\t\\t\\tgetSelectedText(s),buffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void toUpperCase()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable() || selection.length == 0)\\n                {\\n                \\tgetToolkit().beep();\\n                \\treturn;\\n                }\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\tsetSelectedText(s,getSelectedText(s).toUpperCase());\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void toLowerCase()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable() || selection.length == 0)\\n                {\\n                \\tgetToolkit().beep();\\n                \\treturn;\\n                }\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\tsetSelectedText(s,getSelectedText(s).toLowerCase());\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void removeTrailingWhiteSpace()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbuffer.removeTrailingWhiteSpace(getSelectedLines());\\n\\t\\t}\\n\\t} \\n\\t\\tpublic void insertEnterAndIndent()\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tsetSelectedText(\\\"\\\\n\\\");\\n\\t\\t\\t\\tbuffer.indentLine(caretLine,true);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tpublic void insertTabAndIndent()\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(getSelectionCount() == 0)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tString text = buffer.getLineText(caretLine);\\n\\t\\t\\tint start = buffer.getLineStartOffset(caretLine);\\n\\t\\t\\tint whiteSpace = MiscUtilities.getLeadingWhiteSpace(text);\\n\\t\\t\\tif(caret - start <= whiteSpace\\n\\t\\t\\t\\t&& buffer.indentLine(caretLine,false))\\n\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tuserInput('\\\\t');\\n\\t} \\n\\tpublic void indentSelectedLines()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbuffer.indentLines(getSelectedLines());\\n\\t\\t\\tselectNone();\\n\\t\\t}\\n\\t} \\n\\tpublic void shiftIndentLeft()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbuffer.shiftIndentLeft(getSelectedLines());\\n\\t\\t}\\n\\t} \\n\\tpublic void shiftIndentRight()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t\\tbuffer.shiftIndentRight(getSelectedLines());\\n\\t} \\n\\tpublic void joinLines()\\n\\t{\\n\\t\\tint end = getLineEndOffset(caretLine);\\n\\t\\tif(!buffer.isEditable() || end > buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tbuffer.remove(\\n\\t\\t\\t\\tend - 1,MiscUtilities.getLeadingWhiteSpace(\\n\\t\\t\\t\\tbuffer.getLineText(caretLine + 1)) + 1);\\n\\t\\t\\tbuffer.insert(end - 1, \\\" \\\");\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\tsetCaretPosition(end - 1);\\n\\t} \\n\\tpublic void showWordCountDialog()\\n\\t{\\n\\t\\tString selection = getSelectedText();\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tdoWordCount(view,selection);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tdoWordCount(view,buffer.getText(0,buffer.getLength()));\\n\\t} \\n\\tpublic boolean isRightClickPopupEnabled()\\n\\t{\\n\\t\\treturn popupEnabled;\\n\\t} \\n\\tpublic void setRightClickPopupEnabled(boolean popupEnabled)\\n\\t{\\n\\t\\tthis.popupEnabled = popupEnabled;\\n\\t} \\n\\tpublic final JPopupMenu getRightClickPopup()\\n\\t{\\n\\t\\treturn popup;\\n\\t} \\n\\tpublic final void setRightClickPopup(JPopupMenu popup)\\n\\t{\\n\\t\\tthis.popup = popup;\\n\\t} \\n\\tpublic void handlePopupTrigger(MouseEvent evt)\\n\\t{\\n\\t\\tif(popup.isVisible())\\n\\t\\t\\tpopup.setVisible(false);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint x = evt.getX();\\n\\t\\t\\tint y = evt.getY();\\n\\t\\t\\tint dragStart = xyToOffset(x,y,\\n\\t\\t\\t\\t!(painter.isBlockCaretEnabled()\\n\\t\\t\\t\\t|| isOverwriteEnabled()));\\n\\t\\t\\tif(getSelectionCount() == 0 || multi)\\n\\t\\t\\t\\tmoveCaretPosition(dragStart,false);\\n\\t\\t\\tGUIUtilities.showPopupMenu(popup,painter,x,y);\\n\\t\\t}\\n\\t} \\n\\tpublic void addLeftOfScrollBar(Component comp)\\n\\t{\\n\\t\\tverticalBox.add(comp,verticalBox.getComponentCount() - 1);\\n\\t} \\n\\tpublic void removeLeftOfScrollBar(Component comp)\\n\\t{\\n\\t\\tverticalBox.remove(comp);\\n\\t} \\n\\tpublic void addNotify()\\n\\t{\\n\\t\\tsuper.addNotify();\\n\\t\\tToolTipManager.sharedInstance().registerComponent(painter);\\n\\t\\tToolTipManager.sharedInstance().registerComponent(gutter);\\n\\t\\trecalculateVisibleLines();\\n\\t\\tif(buffer.isLoaded())\\n\\t\\t\\trecalculateLastPhysicalLine();\\n\\t\\tpropertiesChanged();\\n\\t} \\n\\tpublic void removeNotify()\\n\\t{\\n\\t\\tsuper.removeNotify();\\n\\t\\tToolTipManager.sharedInstance().unregisterComponent(painter);\\n\\t\\tToolTipManager.sharedInstance().unregisterComponent(gutter);\\n\\t\\tif(focusedComponent == this)\\n\\t\\t\\tfocusedComponent = null;\\n\\t} \\n\\tpublic boolean getFocusTraversalKeysEnabled()\\n\\t{\\n\\t\\treturn false;\\n\\t} \\n\\tpublic boolean getFocusCycleRoot()\\n\\t{\\n\\t\\treturn true;\\n\\t} \\n\\t\\tpublic void processKeyEvent(KeyEvent evt)\\n\\t{\\n\\t\\tview.processKeyEvent(evt,View.TEXT_AREA);\\n\\t\\tif(!evt.isConsumed())\\n\\t\\t\\tsuper.processKeyEvent(evt);\\n\\t} \\n\\tpublic void addTopComponent(Component comp)\\n\\t{\\n\\t\\tadd(ScrollLayout.TOP,comp);\\n\\t} \\n\\tpublic void removeTopComponent(Component comp)\\n\\t{\\n\\t\\tremove(comp);\\n\\t} \\n\\tpublic void propertiesChanged()\\n\\t{\\n\\t\\tif(buffer == null)\\n\\t\\t\\treturn;\\n\\t\\tint _tabSize = buffer.getTabSize();\\n\\t\\tchar[] foo = new char[_tabSize];\\n\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t\\tfoo[i] = ' ';\\n\\t\\ttabSize = (float)painter.getStringWidth(new String(foo));\\n\\t\\tcharWidth = (int)Math.round(\\n\\t\\t\\tpainter.getFont().getStringBounds(foo,0,1,\\n\\t\\t\\tpainter.getFontRenderContext()).getWidth());\\n\\t\\tboolean invalidateScreenLineCounts = false;\\n\\t\\tint oldWrapMargin = wrapMargin;\\n\\t\\twrap = buffer.getStringProperty(\\\"wrap\\\");\\n\\t\\thardWrap = wrap.equals(\\\"hard\\\");\\n\\t\\tsoftWrap = wrap.equals(\\\"soft\\\");\\n\\t\\tsetMaxLineLength(buffer.getIntegerProperty(\\\"maxLineLen\\\",0));\\n\\t\\tif(oldWrapMargin != wrapMargin || !wrap.equals(this.wrap))\\n\\t\\t{\\n\\t\\t\\tif(displayManager != null && !bufferChanging)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdisplayManager.firstLine.callReset = true;\\n\\t\\t\\t\\tdisplayManager.scrollLineCount.callReset = true;\\n\\t\\t\\t}\\n\\t\\t\\tinvalidateScreenLineCounts = true;\\n\\t\\t}\\n\\t\\tif(invalidateScreenLineCounts && displayManager != null\\n\\t\\t\\t&& buffer.isLoaded())\\n\\t\\t\\tdisplayManager.invalidateScreenLineCounts();\\n\\t\\tchunkCache.invalidateAll();\\n\\t\\tif(displayManager != null && !bufferChanging\\n\\t\\t\\t&& buffer.isLoaded())\\n\\t\\t\\tdisplayManager.notifyScreenLineChanges();\\n\\t\\tgutter.repaint();\\n\\t\\tpainter.repaint();\\n\\t} \\n\\tpublic final int getSelectionStart()\\n\\t{\\n\\t\\tif(getSelectionCount() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn getSelection(0).getStart();\\n\\t} \\n\\tpublic int getSelectionStart(int line)\\n\\t{\\n\\t\\tif(getSelectionCount() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn getSelection(0).getStart(buffer,line);\\n\\t} \\n\\tpublic final int getSelectionStartLine()\\n\\t{\\n\\t\\tif(getSelectionCount() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn getSelection(0).getStartLine();\\n\\t} \\n\\tpublic final void setSelectionStart(int selectionStart)\\n\\t{\\n\\t\\tselect(selectionStart,getSelectionEnd(),true);\\n\\t} \\n\\tpublic final int getSelectionEnd()\\n\\t{\\n\\t\\tif(getSelectionCount() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn getSelection(0).getEnd();\\n\\t} \\n\\tpublic int getSelectionEnd(int line)\\n\\t{\\n\\t\\tif(getSelectionCount() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn getSelection(0).getEnd(buffer,line);\\n\\t} \\n\\tpublic final int getSelectionEndLine()\\n\\t{\\n\\t\\tif(getSelectionCount() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn getSelection(0).getEndLine();\\n\\t} \\n\\tpublic final void setSelectionEnd(int selectionEnd)\\n\\t{\\n\\t\\tselect(getSelectionStart(),selectionEnd,true);\\n\\t} \\n\\tpublic final int getMarkPosition()\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(s == null)\\n\\t\\t\\treturn caret;\\n\\t\\tif(s.start == caret)\\n\\t\\t\\treturn s.end;\\n\\t\\telse if(s.end == caret)\\n\\t\\t\\treturn s.start;\\n\\t\\telse\\n\\t\\t\\treturn caret;\\n\\t} \\n\\tpublic final int getMarkLine()\\n\\t{\\n\\t\\tif(getSelectionCount() != 1)\\n\\t\\t\\treturn caretLine;\\n\\t\\tSelection s = getSelection(0);\\n\\t\\tif(s.start == caret)\\n\\t\\t\\treturn s.endLine;\\n\\t\\telse if(s.end == caret)\\n\\t\\t\\treturn s.startLine;\\n\\t\\telse\\n\\t\\t\\treturn caretLine;\\n\\t} \\n\\tpublic void select(int start, int end)\\n\\t{\\n\\t\\tselect(start,end,true);\\n\\t} \\n\\tpublic void select(int start, int end, boolean doElectricScroll)\\n\\t{\\n\\t\\tselectNone();\\n\\t\\tint newStart, newEnd;\\n\\t\\tif(start < end)\\n\\t\\t{\\n\\t\\t\\tnewStart = start;\\n\\t\\t\\tnewEnd = end;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tnewStart = end;\\n\\t\\t\\tnewEnd = start;\\n\\t\\t}\\n\\t\\tsetSelection(new Selection.Range(newStart,newEnd));\\n\\t\\tmoveCaretPosition(end,doElectricScroll);\\n\\t} \\n\\tpublic boolean isSelectionRectangular()\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(s == null)\\n\\t\\t\\treturn false;\\n\\t\\telse\\n\\t\\t\\treturn (s instanceof Selection.Rect);\\n\\t} \\n\\tstatic JEditTextArea focusedComponent;\\n\\t\\tSegment lineSegment;\\n\\tMouseHandler mouseHandler;\\n\\tChunkCache chunkCache;\\n\\tDisplayManager displayManager;\\n\\tSelectionManager selectionManager;\\n\\tboolean bufferChanging;\\n\\tint maxHorizontalScrollWidth;\\n\\tString wrap;\\n\\tboolean hardWrap;\\n\\tboolean softWrap;\\n\\tboolean wrapToWidth;\\n\\tint maxLineLen;\\n\\tint wrapMargin;\\n\\tfloat tabSize;\\n\\tint charWidth;\\n\\tboolean scrollBarsInitialized;\\n\\t\\tPoint returnValue;\\n\\tboolean lastLinePartial;\\n\\tboolean blink;\\n\\tfinal boolean isCaretVisible()\\n\\t{\\n\\t\\treturn blink && hasFocus();\\n\\t} \\n\\tfinal boolean isStructureHighlightVisible()\\n\\t{\\n\\t\\treturn match != null\\n\\t\\t\\t&& hasFocus()\\n\\t\\t\\t&& displayManager.isLineVisible(match.startLine)\\n\\t\\t\\t&& displayManager.isLineVisible(match.endLine);\\n\\t} \\n\\t\\tvoid updateMaxHorizontalScrollWidth()\\n\\t{\\n\\t\\tint max = chunkCache.getMaxHorizontalScrollWidth();\\n\\t\\tif(max != maxHorizontalScrollWidth)\\n\\t\\t{\\n\\t\\t\\tmaxHorizontalScrollWidth = max;\\n\\t\\t\\thorizontal.setValues(Math.max(0,\\n\\t\\t\\t\\tMath.min(maxHorizontalScrollWidth + charWidth\\n\\t\\t\\t\\t- painter.getWidth(),\\n\\t\\t\\t\\t-horizontalOffset)),\\n\\t\\t\\t\\tpainter.getWidth(),\\n\\t\\t\\t\\t0,maxHorizontalScrollWidth\\n\\t\\t\\t\\t+ charWidth);\\n\\t\\t}\\n\\t} \\n\\t\\tvoid recalculateVisibleLines()\\n\\t{\\n\\t\\tif(painter == null)\\n\\t\\t\\treturn;\\n\\t\\tint height = painter.getHeight();\\n\\t\\tint lineHeight = painter.getFontMetrics().getHeight();\\n\\t\\tif(lineHeight == 0)\\n\\t\\t\\tvisibleLines = 0;\\n\\t\\telse if(height <= 0)\\n\\t\\t{\\n\\t\\t\\tvisibleLines = 0;\\n\\t\\t\\tlastLinePartial = false;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tvisibleLines = height / lineHeight;\\n\\t\\t\\tlastLinePartial = (height % lineHeight != 0);\\n\\t\\t\\tif(lastLinePartial)\\n\\t\\t\\t\\tvisibleLines++;\\n\\t\\t}\\n\\t\\tchunkCache.recalculateVisibleLines();\\n\\t\\t\\t\\tif(displayManager != null && buffer != null && buffer.isLoaded())\\n\\t\\t\\tsetFirstLine(getFirstLine());\\n\\t\\tupdateScrollBars();\\n\\t} \\n\\t\\tvoid foldStructureChanged()\\n\\t{\\n\\t\\tchunkCache.invalidateAll();\\n\\t\\trecalculateLastPhysicalLine();\\n\\t\\trepaint();\\n\\t} \\n\\tvoid updateScrollBars()\\n\\t{\\n\\t\\tif(buffer == null)\\n\\t\\t\\treturn;\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"updateScrollBars(), slc=\\\"\\n\\t\\t\\t\\t+ displayManager.getScrollLineCount());\\n\\t\\tif(vertical != null && visibleLines != 0)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"Vertical ok\\\");\\n\\t\\t\\tint lineCount = displayManager.getScrollLineCount();\\n\\t\\t\\tint firstLine = getFirstLine();\\n\\t\\t\\tint visible = visibleLines - (lastLinePartial ? 1 : 0);\\n\\t\\t\\tvertical.setValues(firstLine,visible,0,lineCount);\\n\\t\\t\\tvertical.setUnitIncrement(2);\\n\\t\\t\\tvertical.setBlockIncrement(visible);\\n\\t\\t}\\n\\t\\tint width = painter.getWidth();\\n\\t\\tif(horizontal != null && width != 0)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"Horizontal ok\\\");\\n\\t\\t\\tpainter.repaint();\\n\\t\\t\\thorizontal.setValue(-horizontalOffset);\\n\\t\\t\\thorizontal.setUnitIncrement(painter.getFontMetrics()\\n\\t\\t\\t\\t.charWidth('w'));\\n\\t\\t\\thorizontal.setBlockIncrement(width / 2);\\n\\t\\t}\\n\\t} \\n\\tvoid _finishCaretUpdate()\\n\\t{\\n\\t\\tif(!queuedCaretUpdate)\\n\\t\\t\\treturn;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tif(match != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(oldCaretLine < match.startLine)\\n\\t\\t\\t\\t\\tinvalidateLineRange(oldCaretLine,match.endLine);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tinvalidateLineRange(match.startLine,oldCaretLine);\\n\\t\\t\\t\\tmatch = null;\\n\\t\\t\\t}\\n\\t\\t\\tint newCaretScreenLine = chunkCache.getScreenLineOfOffset(caretLine,\\n\\t\\t\\t\\tcaret - buffer.getLineStartOffset(caretLine));\\n\\t\\t\\tif(caretScreenLine == -1)\\n\\t\\t\\t\\tinvalidateScreenLineRange(newCaretScreenLine,newCaretScreenLine);\\n\\t\\t\\telse\\n\\t\\t\\t\\tinvalidateScreenLineRange(caretScreenLine,newCaretScreenLine);\\n\\t\\t\\tcaretScreenLine = newCaretScreenLine;\\n\\t\\t\\tinvalidateSelectedLines();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tblink = true;\\n\\t\\t\\tcaretTimer.restart();\\n\\t\\t\\tif(!displayManager.isLineVisible(caretLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caretLine < displayManager.getFirstVisibleLine()\\n\\t\\t\\t\\t\\t|| caretLine > displayManager.getLastVisibleLine())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint collapseFolds = buffer.getIntegerProperty(\\n\\t\\t\\t\\t\\t\\t\\\"collapseFolds\\\",0);\\n\\t\\t\\t\\t\\tif(collapseFolds != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdisplayManager.expandFolds(collapseFolds);\\n\\t\\t\\t\\t\\t\\tdisplayManager.expandFold(caretLine,false);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tdisplayManager.expandAllFolds();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tdisplayManager.expandFold(caretLine,false);\\n\\t\\t\\t}\\n\\t\\t\\tif(queuedScrollMode == ELECTRIC_SCROLL)\\n\\t\\t\\t\\tscrollToCaret(true);\\n\\t\\t\\telse if(queuedScrollMode == NORMAL_SCROLL)\\n\\t\\t\\t\\tscrollToCaret(false);\\n\\t\\t\\tupdateBracketHighlightWithDelay();\\n\\t\\t\\tif(queuedFireCaretEvent)\\n\\t\\t\\t\\tfireCaretEvent();\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tqueuedCaretUpdate = queuedFireCaretEvent = false;\\n\\t\\t\\tqueuedScrollMode = NO_SCROLL;\\n\\t\\t}\\n\\t} \\n\\t\\tvoid invalidateStructureMatch()\\n\\t{\\n\\t\\tif(match != null)\\n\\t\\t\\tinvalidateLineRange(match.startLine,match.endLine);\\n\\t} \\n\\t\\tvoid startDragAndDrop(InputEvent evt, boolean copy)\\n\\t{\\n\\t\\tLog.log(Log.DEBUG,this,\\\"Drag and drop callback\\\");\\n\\t\\tgetTransferHandler().exportAsDrag(this,evt,\\n\\t\\t\\tcopy ? TransferHandler.COPY\\n\\t\\t\\t: TransferHandler.MOVE);\\n\\t} \\n\\t\\tprivate static Timer caretTimer;\\n\\tprivate static Timer structureTimer;\\n\\t\\tprivate View view;\\n\\tprivate Gutter gutter;\\n\\tprivate TextAreaPainter painter;\\n\\tprivate JPopupMenu popup;\\n\\tprivate boolean popupEnabled;\\n\\tprivate EventListenerList listenerList;\\n\\tprivate MutableCaretEvent caretEvent;\\n\\tprivate boolean caretBlinks;\\n\\tprivate int physLastLine;\\n\\tprivate int screenLastLine;\\n\\tprivate int visibleLines;\\n\\tprivate int electricScroll;\\n\\tprivate int horizontalOffset;\\n\\tprivate boolean quickCopy;\\n\\t\\tprivate Box verticalBox;\\n\\tprivate JScrollBar vertical;\\n\\tprivate JScrollBar horizontal;\\n\\tprivate Buffer buffer;\\n\\tprivate int caret;\\n\\tprivate int caretLine;\\n\\tprivate int caretScreenLine;\\n\\tprivate List structureMatchers;\\n\\tprivate StructureMatcher.Match match;\\n\\tprivate int magicCaret;\\n\\tprivate boolean multi;\\n\\tprivate boolean overwrite;\\n\\tprivate boolean rectangularSelectionMode;\\n\\tprivate boolean dndEnabled;\\n\\tprivate boolean dndInProgress;\\n\\t\\tprivate boolean queuedCaretUpdate;\\n\\tprivate int queuedScrollMode;\\n\\tprivate boolean queuedFireCaretEvent;\\n\\tprivate int oldCaretLine;\\n\\tprivate void invalidateSelectedLines()\\n\\t{\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tIterator iter = selectionManager.selection.iterator();\\n\\t\\twhile(iter.hasNext())\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)iter.next();\\n\\t\\t\\tinvalidateLineRange(s.startLine,s.endLine);\\n\\t\\t}\\n\\t} \\n\\tprivate void finishCaretUpdate(int oldCaretLine,\\n\\t\\tint scrollMode, boolean fireCaretEvent)\\n\\t{\\n\\t\\tthis.queuedFireCaretEvent |= fireCaretEvent;\\n\\t\\tthis.queuedScrollMode = Math.max(scrollMode,queuedScrollMode);\\n\\t\\tif(queuedCaretUpdate)\\n\\t\\t\\treturn;\\n\\t\\tthis.oldCaretLine = oldCaretLine;\\n\\t\\tqueuedCaretUpdate = true;\\n\\t\\tif(!buffer.isTransactionInProgress())\\n\\t\\t\\t_finishCaretUpdate();\\n\\t} \\n\\t\\tprivate void fireCaretEvent()\\n\\t{\\n\\t\\tObject[] listeners = listenerList.getListenerList();\\n\\t\\tfor(int i = listeners.length - 2; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(listeners[i] == CaretListener.class)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t((CaretListener)listeners[i+1]).caretUpdate(caretEvent);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireScrollEvent(boolean vertical)\\n\\t{\\n\\t\\tObject[] listeners = listenerList.getListenerList();\\n\\t\\tfor(int i = listeners.length - 2; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(listeners[i] == ScrollListener.class)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(vertical)\\n\\t\\t\\t\\t\\t\\t((ScrollListener)listeners[i+1]).scrolledVertically(this);\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t((ScrollListener)listeners[i+1]).scrolledHorizontally(this);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void insert(String str, boolean indent)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(overwrite || indent)\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tif(overwrite)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint caretLineEnd = getLineEndOffset(caretLine);\\n\\t\\t\\t\\tif(caretLineEnd - caret > 1)\\n\\t\\t\\t\\t\\tbuffer.remove(caret,1);\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.insert(caret,str);\\n\\t\\t\\tif(indent)\\n\\t\\t\\t\\tbuffer.indentLine(caretLine,true);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tif(overwrite || indent)\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void insertTab()\\n\\t{\\n\\t\\tint tabSize = buffer.getTabSize();\\n\\t\\tif(buffer.getBooleanProperty(\\\"noTabs\\\"))\\n\\t\\t{\\n\\t\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\t\\tString line = getText(lineStart,caret - lineStart);\\n\\t\\t\\tint pos = 0;\\n\\t\\t\\tfor(int i = 0; i < line.length(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(line.charAt(pos))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tpos = 0;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif(++pos >= tabSize)\\n\\t\\t\\t\\t\\t\\tpos = 0;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treplaceSelection(MiscUtilities.createWhiteSpace(\\n\\t\\t\\t\\ttabSize - pos,0));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treplaceSelection(\\\"\\\\t\\\");\\n\\t} \\n\\t\\tprivate void userInputTab()\\n\\t{\\n\\t\\tif(getSelectionCount() == 1)\\n\\t\\t{\\n\\t\\t\\tSelection sel = getSelection(0);\\n\\t\\t\\tif(sel instanceof Selection.Rect ||\\n\\t\\t\\t\\t(sel.startLine == sel.endLine\\n\\t\\t\\t\\t&& (sel.start != buffer.getLineStartOffset(sel.startLine)\\n\\t\\t\\t\\t|| sel.end != buffer.getLineEndOffset(sel.startLine) - 1)))\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsertTab();\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tshiftIndentRight();\\n\\t\\t}\\n\\t\\telse if(getSelectionCount() != 0)\\n\\t\\t\\tshiftIndentRight();\\n\\t\\telse\\n\\t\\t\\tinsertTab();\\n\\t} \\n\\tprivate boolean doWordWrap(boolean spaceInserted)\\n\\t{\\n\\t\\tif(!hardWrap || maxLineLen <= 0)\\n\\t\\t\\treturn false;\\n\\t\\tbuffer.getLineText(caretLine,lineSegment);\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine);\\n\\t\\tint len = end - start - 1;\\n\\t\\tint caretPos = caret - start;\\n\\t\\t\\t\\t\\t\\tfor(int i = caretPos; i < len; i++)\\n\\t\\t{\\n\\t\\t\\tchar ch = lineSegment.array[lineSegment.offset + i];\\n\\t\\t\\tif(ch != ' ' && ch != '\\\\t')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tint tabSize = buffer.getTabSize();\\n\\t\\tString wordBreakChars = buffer.getStringProperty(\\\"wordBreakChars\\\");\\n\\t\\tint lastInLine = 0; \\t\\tint logicalLength = 0; \\t\\tint lastWordOffset = -1;\\n\\t\\tboolean lastWasSpace = true;\\n\\t\\tfor(int i = 0; i < caretPos; i++)\\n\\t\\t{\\n\\t\\t\\tchar ch = lineSegment.array[lineSegment.offset + i];\\n\\t\\t\\tif(ch == '\\\\t')\\n\\t\\t\\t{\\n\\t\\t\\t\\tlogicalLength += tabSize - (logicalLength % tabSize);\\n\\t\\t\\t\\tif(!lastWasSpace && logicalLength <= maxLineLen)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastInLine = i;\\n\\t\\t\\t\\t\\tlastWordOffset = i;\\n\\t\\t\\t\\t\\tlastWasSpace = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(ch == ' ')\\n\\t\\t\\t{\\n\\t\\t\\t\\tlogicalLength++;\\n\\t\\t\\t\\tif(!lastWasSpace &&\\n\\t\\t\\t\\t\\tlogicalLength <= maxLineLen + 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastInLine = i;\\n\\t\\t\\t\\t\\tlastWordOffset = i;\\n\\t\\t\\t\\t\\tlastWasSpace = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(wordBreakChars != null && wordBreakChars.indexOf(ch) != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlogicalLength++;\\n\\t\\t\\t\\tif(!lastWasSpace && logicalLength <= maxLineLen)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastInLine = i;\\n\\t\\t\\t\\t\\tlastWordOffset = i;\\n\\t\\t\\t\\t\\tlastWasSpace = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tlastInLine = i;\\n\\t\\t\\t\\tlogicalLength++;\\n\\t\\t\\t\\tlastWasSpace = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tboolean returnValue;\\n\\t\\tint insertNewLineAt;\\n\\t\\tif(spaceInserted && logicalLength == maxLineLen\\n\\t\\t\\t&& lastInLine == caretPos - 1)\\n\\t\\t{\\n\\t\\t\\tinsertNewLineAt = caretPos;\\n\\t\\t\\treturnValue = true;\\n\\t\\t}\\n\\t\\telse if(logicalLength >= maxLineLen && lastWordOffset != -1)\\n\\t\\t{\\n\\t\\t\\tinsertNewLineAt = lastWordOffset;\\n\\t\\t\\treturnValue = false;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn false;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tbuffer.insert(start + insertNewLineAt,\\\"\\\\n\\\");\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbuffer.indentLine(caretLine,true);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\treturn returnValue;\\n\\t} \\n\\t\\tprivate void doWordCount(View view, String text)\\n\\t{\\n\\t\\tchar[] chars = text.toCharArray();\\n\\t\\tint characters = chars.length;\\n\\t\\tint words;\\n\\t\\tif(characters == 0)\\n\\t\\t\\twords = 0;\\n\\t\\telse\\n\\t\\t\\twords = 1;\\n\\t\\tint lines = 1;\\n\\t\\tboolean word = false;\\n\\t\\tfor(int i = 0; i < chars.length; i++)\\n\\t\\t{\\n\\t\\t\\tswitch(chars[i])\\n\\t\\t\\t{\\n\\t\\t\\tcase '\\\\r': case '\\\\n':\\n\\t\\t\\t\\tlines++;\\n\\t\\t\\tcase ' ': case '\\\\t':\\n\\t\\t\\t\\tif(word)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twords++;\\n\\t\\t\\t\\t\\tword = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tword = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tif(!word)\\n\\t\\t\\twords--;\\n\\t\\tObject[] args = { new Integer(characters), new Integer(words),\\n\\t\\t\\tnew Integer(lines) };\\n\\t\\tGUIUtilities.message(view,\\\"wordcount\\\",args);\\n\\t} \\n\\t\\tprivate void updateBracketHighlightWithDelay()\\n\\t{\\n\\t\\tstructureTimer.stop();\\n\\t\\tstructureTimer.start();\\n\\t} \\n\\t\\tprivate void updateStructureHighlight()\\n\\t{\\n\\t\\tif(!painter.isStructureHighlightEnabled()\\n\\t\\t\\t&& !gutter.isStructureHighlightEnabled())\\n\\t\\t\\treturn;\\n\\t\\tIterator iter = structureMatchers.iterator();\\n\\t\\twhile(iter.hasNext())\\n\\t\\t{\\n\\t\\t\\tStructureMatcher matcher = (StructureMatcher)\\n\\t\\t\\t\\titer.next();\\n\\t\\t\\tmatch = matcher.getMatch(this);\\n\\t\\t\\tif(match != null)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tif(match != null)\\n\\t\\t{\\n\\t\\t\\tif(caretLine < match.startLine)\\n\\t\\t\\t\\tinvalidateLineRange(caretLine,match.endLine);\\n\\t\\t\\telse\\n\\t\\t\\t\\tinvalidateLineRange(match.startLine,caretLine);\\n\\t\\t\\tif(!displayManager.isLineVisible(match.startLine)\\n\\t\\t\\t\\t|| chunkCache.getScreenLineOfOffset(\\n\\t\\t\\t\\tmatch.startLine,match.start - getLineStartOffset(match.startLine))\\n\\t\\t\\t\\t== -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tshowStructureStatusMessage(match.startLine < caretLine);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void showStructureStatusMessage(boolean backward)\\n\\t{\\n\\t\\tString text = buffer.getLineText(match.startLine).trim();\\n\\t\\tif(backward && match.startLine != 0 && text.length() == 1)\\n\\t\\t{\\n\\t\\t\\tswitch(text.charAt(0))\\n\\t\\t\\t{\\n\\t\\t\\tcase '{': case '}':\\n\\t\\t\\tcase '[': case ']':\\n\\t\\t\\tcase '(': case ')':\\n\\t\\t\\t\\ttext = buffer.getLineText(match.startLine - 1)\\n\\t\\t\\t\\t\\t.trim() + \\\" \\\" + text;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\ttext = text.replace('\\\\t',' ');\\n\\t\\tview.getStatus().setMessageAndClear(jEdit.getProperty(\\n\\t\\t\\t\\\"view.status.bracket\\\",new Object[] {\\n\\t\\t\\tnew Integer(match.startLine + 1), text }));\\n\\t} \\n\\t\\tvoid recalculateLastPhysicalLine()\\n\\t{\\n\\t\\tint oldScreenLastLine = screenLastLine;\\n\\t\\tfor(int i = visibleLines - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(i);\\n\\t\\t\\tif(info.physicalLine != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tphysLastLine = info.physicalLine;\\n\\t\\t\\t\\tscreenLastLine = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tinvalidateScreenLineRange(oldScreenLastLine,screenLastLine);\\n\\t} \\n\\t\\tstatic class RectParams\\n\\t{\\n\\t\\tint extraStartVirt;\\n\\t\\tint extraEndVirt;\\n\\t\\tint newCaret;\\n\\t\\tRectParams(int extraStartVirt, int extraEndVirt, int newCaret)\\n\\t\\t{\\n\\t\\t\\tthis.extraStartVirt = extraStartVirt;\\n\\t\\t\\tthis.extraEndVirt = extraEndVirt;\\n\\t\\t\\tthis.newCaret = newCaret;\\n\\t\\t}\\n\\t}\\n\\tprivate RectParams getRectParams(int caret, int newCaret)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint virtualWidth;\\n\\t\\tif(s instanceof Selection.Rect)\\n\\t\\t{\\n\\t\\t\\tif(caret == s.end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvirtualWidth = buffer.getVirtualWidth(\\n\\t\\t\\t\\t\\ts.endLine,s.end - getLineStartOffset(\\n\\t\\t\\t\\t\\ts.endLine)) + ((Selection.Rect)s).extraEndVirt;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tvirtualWidth = buffer.getVirtualWidth(\\n\\t\\t\\t\\t\\ts.startLine,s.start - getLineStartOffset(\\n\\t\\t\\t\\t\\ts.startLine)) + ((Selection.Rect)s).extraStartVirt;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(rectangularSelectionMode)\\n\\t\\t{\\n\\t\\t\\tvirtualWidth = buffer.getVirtualWidth(\\n\\t\\t\\t\\tcaretLine,caret - buffer.getLineStartOffset(caretLine));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn null;\\n\\t\\tint newLine = getLineOfOffset(newCaret);\\n\\t\\tint[] totalVirtualWidth = new int[1];\\n\\t\\tint newOffset = buffer.getOffsetOfVirtualColumn(newLine,\\n\\t\\t\\tvirtualWidth,totalVirtualWidth);\\n\\t\\tif(newOffset == -1)\\n\\t\\t{\\n\\t\\t\\tint extraVirt = virtualWidth - totalVirtualWidth[0];\\n\\t\\t\\tnewCaret = getLineEndOffset(newLine) - 1;\\n\\t\\t\\tRectParams returnValue;\\n\\t\\t\\tboolean bias;\\n\\t\\t\\tif(s == null)\\n\\t\\t\\t\\tbias = (newCaret < caret);\\n\\t\\t\\telse if(s.start == caret)\\n\\t\\t\\t\\tbias = (newCaret <= s.end);\\n\\t\\t\\telse if(s.end == caret)\\n\\t\\t\\t\\tbias = (newCaret <= s.start);\\n\\t\\t\\telse\\n\\t\\t\\t\\tbias = false;\\n\\t\\t\\tif(bias)\\n\\t\\t\\t\\treturnValue = new RectParams(extraVirt,0,newCaret);\\n\\t\\t\\telse\\n\\t\\t\\t\\treturnValue = new RectParams(0,extraVirt,newCaret);\\n\\t\\t\\treturn returnValue;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\treturn new RectParams(0,0,getLineStartOffset(newLine)\\n\\t\\t\\t\\t+ newOffset);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void delete(boolean forward)\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(getSelectionCount() != 0)\\n\\t\\t{\\n\\t\\t\\tSelection[] selections = getSelection();\\n\\t\\t\\tfor(int i = 0; i < selections.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selections[i];\\n\\t\\t\\t\\tif(s instanceof Selection.Rect)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection.Rect r = (Selection.Rect)s;\\n\\t\\t\\t\\t\\tint startColumn = r.getStartColumn(buffer);\\n\\t\\t\\t\\t\\tif(startColumn == r.getEndColumn(buffer))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(!forward && startColumn == 0)\\n\\t\\t\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\ttallCaretDelete(r,forward);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tsetSelectedText(s,null);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tsetSelectedText(s,null);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(forward)\\n\\t\\t{\\n\\t\\t\\tif(caret == buffer.getLength())\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.remove(caret,1);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(caret == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.remove(caret - 1,1);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void tallCaretDelete(Selection.Rect s, boolean forward)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tint[] width = new int[1];\\n\\t\\t\\tint startCol = s.getStartColumn(buffer);\\n\\t\\t\\tint startLine = s.startLine;\\n\\t\\t\\tint endLine = s.endLine;\\n\\t\\t\\tfor(int i = startLine; i <= endLine; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint offset = buffer.getOffsetOfVirtualColumn(\\n\\t\\t\\t\\t\\ti,startCol,width);\\n\\t\\t\\t\\tif(offset == -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(width[0] == startCol)\\n\\t\\t\\t\\t\\t\\toffset = getLineLength(i);\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(i == startLine && !forward)\\n\\t\\t\\t\\t\\t\\t\\tshiftTallCaretLeft(s);\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\toffset += buffer.getLineStartOffset(i);\\n\\t\\t\\t\\tif(forward)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(offset != buffer.getLineEndOffset(i) - 1)\\n\\t\\t\\t\\t\\t\\tbuffer.remove(offset,1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbuffer.remove(offset-1,1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void shiftTallCaretLeft(Selection.Rect s)\\n\\t{\\n\\t\\tremoveFromSelection(s);\\n\\t\\taddToSelection(new Selection.Rect(\\n\\t\\t\\tbuffer,\\n\\t\\t\\ts.getStartLine(),s.getStartColumn(buffer) - 1,\\n\\t\\t\\ts.getEndLine(),s.getEndColumn(buffer) - 1));\\n\\t} \\n\\t\\tprivate void setMaxLineLength(int maxLineLen)\\n\\t{\\n\\t\\tthis.maxLineLen = maxLineLen;\\n\\t\\tif(maxLineLen <= 0)\\n\\t\\t{\\n\\t\\t\\tif(softWrap)\\n\\t\\t\\t{\\n\\t\\t\\t\\twrapToWidth = true;\\n\\t\\t\\t\\twrapMargin = painter.getWidth() - charWidth * 3;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\twrapToWidth = false;\\n\\t\\t\\t\\twrapMargin = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tchar[] foo = new char[maxLineLen];\\n\\t\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfoo[i] = ' ';\\n\\t\\t\\t}\\n\\t\\t\\twrapToWidth = false;\\n\\t\\t\\twrapMargin = (int)painter.getFont().getStringBounds(\\n\\t\\t\\t\\tfoo,0,foo.length,\\n\\t\\t\\t\\tpainter.getFontRenderContext())\\n\\t\\t\\t\\t.getWidth();\\n\\t\\t}\\n\\t} \\n\\t\\tstatic class CaretBlinker implements ActionListener\\n\\t{\\n\\t\\t\\t\\tpublic void actionPerformed(ActionEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(focusedComponent != null && focusedComponent.hasFocus())\\n\\t\\t\\t\\tfocusedComponent.blinkCaret();\\n\\t\\t} \\t} \\n\\t\\tclass MutableCaretEvent extends CaretEvent\\n\\t{\\n\\t\\t\\t\\tMutableCaretEvent()\\n\\t\\t{\\n\\t\\t\\tsuper(JEditTextArea.this);\\n\\t\\t} \\n\\t\\t\\t\\tpublic int getDot()\\n\\t\\t{\\n\\t\\t\\treturn getCaretPosition();\\n\\t\\t} \\n\\t\\t\\t\\tpublic int getMark()\\n\\t\\t{\\n\\t\\t\\treturn getMarkPosition();\\n\\t\\t} \\t} \\n\\t\\tclass AdjustHandler implements AdjustmentListener\\n\\t{\\n\\t\\t\\t\\tpublic void adjustmentValueChanged(final AdjustmentEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(!scrollBarsInitialized)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(evt.getAdjustable() == vertical)\\n\\t\\t\\t\\tsetFirstLine(vertical.getValue());\\n\\t\\t\\telse\\n\\t\\t\\t\\tsetHorizontalOffset(-horizontal.getValue());\\n\\t\\t} \\t} \\n\\t\\tclass FocusHandler implements FocusListener\\n\\t{\\n\\t\\t\\t\\tpublic void focusGained(FocusEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(bufferChanging)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(match != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caretLine < match.startLine)\\n\\t\\t\\t\\t\\tinvalidateLineRange(caretLine,match.endLine);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tinvalidateLineRange(match.startLine,caretLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t\\tfocusedComponent = JEditTextArea.this;\\n\\t\\t} \\n\\t\\t\\t\\tpublic void focusLost(FocusEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(!isShowing())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(match != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caretLine < match.startLine)\\n\\t\\t\\t\\t\\tinvalidateLineRange(caretLine,match.endLine);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tinvalidateLineRange(match.startLine,caretLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t} \\t} \\n\\t\\tclass MouseWheelHandler implements MouseWheelListener\\n\\t{\\n\\t\\tpublic void mouseWheelMoved(MouseWheelEvent e)\\n\\t\\t{\\n\\t\\t\\tif(e.isAltDown())\\n\\t\\t\\t{\\n\\t\\t\\t\\tboolean select = (e.isShiftDown()\\n\\t\\t\\t\\t\\t|| e.isControlDown());\\n\\t\\t\\t\\tif(e.getWheelRotation() < 0)\\n\\t\\t\\t\\t\\tgoToPrevLine(select);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tgoToNextLine(select);\\n\\t\\t\\t}\\n\\t\\t\\telse if(e.isShiftDown())\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(e.getWheelRotation() > 0)\\n\\t\\t\\t\\t\\tscrollDownPage();\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tscrollUpPage();\\n\\t\\t\\t}\\n\\t\\t\\telse if(e.isControlDown())\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFirstLine(getFirstLine()\\n\\t\\t\\t\\t\\t+ e.getWheelRotation());\\n\\t\\t\\t}\\n\\t\\t\\telse if(e.getScrollType()\\n\\t\\t\\t\\t== MouseWheelEvent.WHEEL_UNIT_SCROLL)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFirstLine(getFirstLine()\\n\\t\\t\\t\\t\\t+ e.getUnitsToScroll());\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFirstLine(getFirstLine()\\n\\t\\t\\t\\t\\t+ 3 * e.getWheelRotation());\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tstatic\\n\\t{\\n\\t\\tcaretTimer = new Timer(500,new CaretBlinker());\\n\\t\\tcaretTimer.setInitialDelay(500);\\n\\t\\tcaretTimer.start();\\n\\t\\tstructureTimer = new Timer(100,new ActionListener()\\n\\t\\t{\\n\\t\\t\\tpublic void actionPerformed(ActionEvent evt)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(focusedComponent != null)\\n\\t\\t\\t\\t\\tfocusedComponent.updateStructureHighlight();\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tstructureTimer.setInitialDelay(100);\\n\\t\\tstructureTimer.setRepeats(false);\\n\\t} }\""
        },
        {
            "content": "The starting entity `JEditTextArea.java` is a central component in the jEdit text editor, responsible for handling user interactions with the text content. It imports and utilizes several modules such as UI components (`javax.swing.*`, `java.awt.*`), buffer management (`org.gjt.sp.jedit.buffer.*`), syntax highlighting (`org.gjt.sp.jedit.syntax.*`), and utility classes (`org.gjt.sp.util.Log`). \n\nFrom the call graph analysis, we see that this class uses:\n- **Log**: For logging error or status messages.\n- **UI-related libraries**: To manage the visible text area, painter, scroll bars, and other GUI components.\n- **Buffer-related functionality**: To manipulate text, handle selections, and perform edits.\n\n### Key Observations\n1. The class heavily interacts with the `Buffer` class to manage text changes, selections, and caret movements.\n2. It has complex dependencies on UI components (e.g., `TextAreaPainter`, `Gutter`, `SelectionManager`) for rendering and interaction.\n3. It relies on external utilities like `TextUtilities`, `MiscUtilities`, and `Log`.\n\n### Next Steps\nTo identify entities that need synchronization due to potential ripple effects from changes in `JEditTextArea.java`, we should analyze coupling dependencies with these critical components:\n1. **Check coupling dependencies** between `JEditTextArea.java` and key classes like `Buffer`, `TextAreaPainter`, `Gutter`, `SelectionManager`, etc.\n2. If needed, **analyze semantic similarity** with related files to uncover conceptual couplings not evident through direct code references.\n\nWould you like me to check coupling dependencies between `JEditTextArea.java` and another specific file (e.g., `Buffer.java`) or proceed with a broader dependency analysis?",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        },
        {
            "role": "user",
            "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example, without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
        },
        {
            "content": "Title: Diagnosis of starting entity `JEditTextArea.java`  \nChange set: [Buffer, TextAreaPainter, Gutter, SelectionManager, DisplayManager, ChunkCache, View, Log, SyntaxStyle, EditBus, JEditMenuBar, TextAreaInputHandler, Macros, Abbrevs, TextUtilities, MiscUtilities, GUIUtilities, PluginJAR, EditPlugin, DockableWindowManager, Console, StatusBar, FoldHandler, StructureMatcher, MouseHandler, AdjustHandler, FocusHandler, MouseWheelHandler, PropertiesOptionPane, GlobalOptions, DefaultKeyMap, KeyBindingManager, ToolBar, ErrorListDialog, ProjectViewer, Document, UndoManager, SettingsManager, HistoryModel, SearchAndReplace, BeanShell, Commands, QuickNotepadPlugin, FTPPlugin, ConsolePlugin]  \n\nDetails:  \n1. **Buffer**: Central to text editing operations; methods in `JEditTextArea` heavily rely on it for inserting, deleting, and selecting text.\n2. **TextAreaPainter**: Responsible for rendering the text area; tightly coupled with painting logic and caret blinking.\n3. **Gutter**: Manages line numbers and annotations; interacts directly with the text area's layout and scroll updates.\n4. **SelectionManager**: Maintains selection state; used extensively for managing selections, ranges, and rectangular selections.\n5. **DisplayManager**: Handles visible lines, folds, and scrolling behavior; crucial for viewport management.\n6. **ChunkCache**: Caches screen line information; used for efficient rendering and scrolling calculations.\n7. **View**: Encapsulates the user interface view; controls input handling and UI context.\n8. **Log**: Used for logging error messages (e.g., when exceptions are caught).\n9. **SyntaxStyle**: Influences how syntax highlighting is rendered; may be accessed through buffer or painter.\n10. **EditBus**: Likely involved in event-driven communication between components.\n11. **JEditMenuBar**: Part of the UI that could be affected by changes to global actions or keybindings.\n12. **TextAreaInputHandler**: Handles keyboard input and command dispatching; tightly integrated with the text area.\n13. **Macros**: Invoked during macro recording and playback; tied to user input and caret movement.\n14. **Abbrevs**: Expands abbreviations on input; invoked during typing.\n15. **TextUtilities**: Provides utility functions for string manipulation, formatting, indentation.\n16. **MiscUtilities**: Offers helper functions for whitespace, tabs, and virtual column calculations.\n17. **GUIUtilities**: Displays dialogs, error messages, popups\u2014used frequently for user interaction.\n18. **PluginJAR**: May affect plugin-integrated text editing features.\n19. **EditPlugin**: Plugins might hook into text area events.\n20. **DockableWindowManager**: Coordinates docked tools that interact with the text area.\n21. **Console**: Could be impacted if console output affects text content or selection.\n22. **StatusBar**: Status messages updated from caret movements or selection changes.\n23. **FoldHandler**: Controls folding behavior, which is managed by display and navigation logic.\n24. **StructureMatcher**: Used to highlight structural elements like brackets.\n25. **MouseHandler**: Processes mouse events within the text area.\n26. **AdjustHandler**: Responds to scroll bar adjustments.\n27. **FocusHandler**: Manages focus-related visual cues.\n28. **MouseWheelHandler**: Processes mouse wheel scrolling.\n29. **PropertiesOptionPane**: If preferences affect editor behavior, changes may ripple here.\n30. **GlobalOptions**: Affects global settings such as tab size, wrap mode.\n31. **DefaultKeyMap**: Contains default key bindings used by input handlers.\n32. **KeyBindingManager**: Links key strokes to commands affecting the text area.\n33. **ToolBar**: Might be affected if tool actions modify the text area.\n34. **ErrorListDialog**: Integration with error navigation may involve caret positioning.\n35. **ProjectViewer**: Navigates files; could trigger text area updates.\n36. **Document**: Represents underlying document model; tightly related to buffer changes.\n37. **UndoManager**: Manages undo/redo stack; closely linked to compound edits.\n38. **SettingsManager**: Loads and persists settings affecting the text area.\n39. **HistoryModel**: Stores command history; possibly used in macros or input handler.\n40. **SearchAndReplace**: Uses selections and caret positioning; tightly integrated.\n41. **BeanShell**: Executes scripts that manipulate the text area.\n42. **Commands**: Core commands that operate on the text area.\n43. **QuickNotepadPlugin**: Possibly uses a text area instance internally.\n44. **FTPPlugin**: May interact with text area via file loading/saving.\n45. **ConsolePlugin**: Could link console output to the text area.\n\nThese entities are likely to need synchronization due to direct coupling, shared state, or conceptual dependencies based on their usage patterns in `JEditTextArea`.",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        }
    ],
    "interaction_records": {
        "step_histories": [
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m3",
                    "m9",
                    "m10",
                    "m4",
                    "m11",
                    "m7",
                    "m12",
                    "m4",
                    "m13",
                    "m3",
                    "m3",
                    "m14",
                    "m4",
                    "m10",
                    "m7",
                    "m4",
                    "m15",
                    "m13",
                    "m15",
                    "m16",
                    "m11",
                    "m17",
                    "m3",
                    "m4",
                    "m18",
                    "m19",
                    "m4",
                    "m20",
                    "m8",
                    "m21",
                    "m14",
                    "m18",
                    "m10",
                    "m20",
                    "m22",
                    "m4",
                    "m15",
                    "m4",
                    "m23",
                    "m3",
                    "m16",
                    "m16",
                    "m24",
                    "m25",
                    "m13",
                    "m7",
                    "m23",
                    "m13",
                    "m4",
                    "m26",
                    "m15",
                    "m27",
                    "m15",
                    "m4",
                    "m7",
                    "m5",
                    "m3",
                    "m13",
                    "m4",
                    "m19",
                    "m7",
                    "m12",
                    "m6",
                    "m9",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m3",
                    "m9",
                    "m10",
                    "m28",
                    "m4",
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m19",
                    "m10",
                    "m15",
                    "m6",
                    "m10",
                    "m18",
                    "m13",
                    "m29",
                    "m4",
                    "m3",
                    "m13",
                    "m10",
                    "m18",
                    "m10",
                    "m11",
                    "m4",
                    "m11",
                    "m7",
                    "m12",
                    "m4",
                    "m13",
                    "m3",
                    "m3",
                    "m14",
                    "m4",
                    "m10",
                    "m7",
                    "m4",
                    "m14",
                    "m3",
                    "m15",
                    "m16",
                    "m4",
                    "m23",
                    "m18",
                    "m10",
                    "m2",
                    "m4",
                    "m18",
                    "m19",
                    "m4",
                    "m26",
                    "m21",
                    "m14",
                    "m18",
                    "m10",
                    "m1",
                    "m3",
                    "m30",
                    "m10",
                    "m31",
                    "m6",
                    "m3",
                    "m15",
                    "m28",
                    "m8",
                    "m15",
                    "m27",
                    "m15",
                    "m28"
                ],
                "response_message": "m32"
            },
            {
                "prompt_messages": [
                    "m33",
                    "m34",
                    "m32",
                    "m35"
                ],
                "response_message": "m36"
            },
            {
                "prompt_messages": [
                    "m33",
                    "m34",
                    "m32",
                    "m35",
                    "m36",
                    "m37"
                ],
                "response_message": "m38"
            },
            {
                "prompt_messages": [
                    "m33",
                    "m34",
                    "m32",
                    "m35",
                    "m36",
                    "m37",
                    "m38",
                    "m39"
                ],
                "response_message": "m40"
            }
        ],
        "mid_to_message": {
            "m1": "T",
            "m2": "h",
            "m3": "e",
            "m4": " ",
            "m5": "p",
            "m6": "r",
            "m7": "o",
            "m8": "j",
            "m9": "c",
            "m10": "t",
            "m11": "y",
            "m12": "u",
            "m13": "n",
            "m14": "d",
            "m15": "a",
            "m16": "l",
            "m17": "z",
            "m18": "i",
            "m19": "s",
            "m20": "`",
            "m21": "E",
            "m22": ",",
            "m23": "w",
            "m24": "-",
            "m25": "k",
            "m26": "J",
            "m27": "v",
            "m28": ".",
            "m29": "g",
            "m30": "x",
            "m31": "A",
            "m32": {
                "content": "",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_0774b1c039c74eb9966fe4",
                        "function": {
                            "arguments": "{\"entity\": \"JEditTextArea.java\"}",
                            "name": "get_call_graph"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m33": {
                "role": "system",
                "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
            },
            "m34": {
                "role": "user",
                "content": "The project you need to analyze is `jEdit`, a well-known Java open source project. The starting entity you need to deal with is JEditTextArea.java."
            },
            "m35": {
                "role": "tool",
                "name": "get_call_graph",
                "content": "[\"\", \"\", \"\", \"\", \"Log\"]"
            },
            "m36": {
                "content": "",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_4f496e91a4c141bb880e77",
                        "function": {
                            "arguments": "{\"entity\": \"JEditTextArea.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m37": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package org.gjt.sp.jedit.textarea;\\nimport java.awt.*;\\nimport java.awt.event.*;\\nimport java.lang.reflect.Method;\\nimport java.util.Iterator;\\nimport java.util.LinkedList;\\nimport java.util.List;\\nimport java.util.Set;\\nimport java.util.TooManyListenersException;\\nimport java.util.TreeSet;\\nimport java.util.Vector;\\nimport javax.swing.*;\\nimport javax.swing.border.*;\\nimport javax.swing.event.*;\\nimport javax.swing.plaf.metal.MetalLookAndFeel;\\nimport javax.swing.text.Segment;\\nimport org.gjt.sp.jedit.*;\\nimport org.gjt.sp.jedit.buffer.*;\\nimport org.gjt.sp.jedit.gui.*;\\nimport org.gjt.sp.jedit.syntax.*;\\nimport org.gjt.sp.util.Log;\\npublic class JEditTextArea extends JComponent\\n{\\n\\tpublic JEditTextArea(View view)\\n\\t{\\n\\t\\tenableEvents(AWTEvent.FOCUS_EVENT_MASK | AWTEvent.KEY_EVENT_MASK);\\n\\t\\tthis.view = view;\\n\\t\\t\\t\\tselectionManager = new SelectionManager(this);\\n\\t\\tchunkCache = new ChunkCache(this);\\n\\t\\tpainter = new TextAreaPainter(this);\\n\\t\\tgutter = new Gutter(view,this);\\n\\t\\tlistenerList = new EventListenerList();\\n\\t\\tcaretEvent = new MutableCaretEvent();\\n\\t\\tblink = true;\\n\\t\\tlineSegment = new Segment();\\n\\t\\treturnValue = new Point();\\n\\t\\tstructureMatchers = new LinkedList();\\n\\t\\tstructureMatchers.add(new StructureMatcher.BracketMatcher());\\n\\t\\t\\t\\tsetLayout(new ScrollLayout());\\n\\t\\tadd(ScrollLayout.CENTER,painter);\\n\\t\\tadd(ScrollLayout.LEFT,gutter);\\n\\t\\t\\t\\tverticalBox = new Box(BoxLayout.X_AXIS);\\n\\t\\tverticalBox.add(vertical = new JScrollBar(JScrollBar.VERTICAL));\\n\\t\\tvertical.setRequestFocusEnabled(false);\\n\\t\\tadd(ScrollLayout.RIGHT,verticalBox);\\n\\t\\tadd(ScrollLayout.BOTTOM,\\n\\t\\t\\thorizontal = new JScrollBar(JScrollBar.HORIZONTAL));\\n\\t\\thorizontal.setRequestFocusEnabled(false);\\n\\t\\thorizontal.setValues(0,0,0,0);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(UIManager.getLookAndFeel() instanceof MetalLookAndFeel)\\n\\t\\t{\\n\\t\\t\\tsetBorder(new TextAreaBorder());\\n\\t\\t\\tvertical.putClientProperty(\\\"JScrollBar.isFreeStanding\\\",\\n\\t\\t\\t\\tBoolean.FALSE);\\n\\t\\t\\thorizontal.putClientProperty(\\\"JScrollBar.isFreeStanding\\\",\\n\\t\\t\\t\\tBoolean.FALSE);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\tvertical.addAdjustmentListener(new AdjustHandler());\\n\\t\\thorizontal.addAdjustmentListener(new AdjustHandler());\\n\\t\\tmouseHandler = new MouseHandler(this);\\n\\t\\tpainter.addMouseListener(mouseHandler);\\n\\t\\tpainter.addMouseMotionListener(mouseHandler);\\n\\t\\taddFocusListener(new FocusHandler());\\n\\t\\taddMouseWheelListener(new MouseWheelHandler());\\n\\t\\tsetTransferHandler(new TextAreaTransferHandler());\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tgetDropTarget().addDropTargetListener(\\n\\t\\t\\t\\tnew TextAreaDropHandler(this));\\n\\t\\t}\\n\\t\\tcatch(TooManyListenersException e)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.ERROR,this,e);\\n\\t\\t} \\n\\t\\t\\t\\t\\t\\t\\t\\tfocusedComponent = this;\\n\\t\\tpopupEnabled = true;\\n\\t} \\n\\tpublic void dispose()\\n\\t{\\n\\t\\tDisplayManager.textAreaDisposed(this);\\n\\t} \\n\\tpublic View getView()\\n\\t{\\n\\t\\treturn view;\\n\\t} \\n\\tpublic InputHandler getInputHandler()\\n\\t{\\n\\t\\treturn view.getInputHandler();\\n\\t} \\n\\tpublic final TextAreaPainter getPainter()\\n\\t{\\n\\t\\treturn painter;\\n\\t} \\n\\tpublic final Gutter getGutter()\\n\\t{\\n\\t\\treturn gutter;\\n\\t} \\n\\tpublic DisplayManager getDisplayManager()\\n\\t{\\n\\t\\treturn displayManager;\\n\\t} \\n\\tpublic void setStatusMessage(String msg)\\n\\t{\\n\\t\\tview.getStatus().setMessageAndClear(msg);\\n\\t} \\n\\tpublic final boolean isCaretBlinkEnabled()\\n\\t{\\n\\t\\treturn caretBlinks;\\n\\t} \\n\\tpublic void setCaretBlinkEnabled(boolean caretBlinks)\\n\\t{\\n\\t\\tthis.caretBlinks = caretBlinks;\\n\\t\\tif(!caretBlinks)\\n\\t\\t\\tblink = false;\\n\\t\\tif(buffer != null)\\n\\t\\t\\tinvalidateLine(caretLine);\\n\\t} \\n\\tpublic final int getElectricScroll()\\n\\t{\\n\\t\\treturn electricScroll;\\n\\t} \\n\\tpublic final void setElectricScroll(int electricScroll)\\n\\t{\\n\\t\\tthis.electricScroll = electricScroll;\\n\\t} \\n\\tpublic final boolean isQuickCopyEnabled()\\n\\t{\\n\\t\\treturn quickCopy;\\n\\t} \\n\\tpublic final void setQuickCopyEnabled(boolean quickCopy)\\n\\t{\\n\\t\\tthis.quickCopy = quickCopy;\\n\\t} \\n\\tpublic final Buffer getBuffer()\\n\\t{\\n\\t\\treturn buffer;\\n\\t} \\n\\tpublic void setBuffer(Buffer buffer)\\n\\t{\\n\\t\\tif(this.buffer == buffer)\\n\\t\\t\\treturn;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbufferChanging = true;\\n\\t\\t\\tif(this.buffer != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\t\\tcaretLine = caret = caretScreenLine = 0;\\n\\t\\t\\t\\tmatch = null;\\n\\t\\t\\t}\\n\\t\\t\\tthis.buffer = buffer;\\n\\t\\t\\tchunkCache.setBuffer(buffer);\\n\\t\\t\\tpropertiesChanged();\\n\\t\\t\\tif(displayManager != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tDisplayManager.releaseDisplayManager(\\n\\t\\t\\t\\t\\tdisplayManager);\\n\\t\\t\\t}\\n\\t\\t\\tdisplayManager = DisplayManager.getDisplayManager(\\n\\t\\t\\t\\tbuffer,this);\\n\\t\\t\\tdisplayManager.init();\\n\\t\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\t\\tupdateScrollBars();\\n\\t\\t\\trepaint();\\n\\t\\t\\tfireScrollEvent(true);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbufferChanging = false;\\n\\t\\t}\\n\\t} \\n\\tpublic final boolean isEditable()\\n\\t{\\n\\t\\treturn buffer.isEditable();\\n\\t} \\n\\tpublic boolean isDragInProgress()\\n\\t{\\n\\t\\treturn dndInProgress;\\n\\t} \\n\\tpublic void setDragInProgress(boolean dndInProgress)\\n\\t{\\n\\t\\tthis.dndInProgress = dndInProgress;\\n\\t} \\n\\tpublic boolean isDragEnabled()\\n\\t{\\n\\t\\treturn dndEnabled;\\n\\t} \\n\\tpublic void setDragEnabled(boolean dndEnabled)\\n\\t{\\n\\t\\tthis.dndEnabled = dndEnabled;\\n\\t} \\n\\tpublic final int getFirstLine()\\n\\t{\\n\\t\\treturn displayManager.firstLine.scrollLine\\n\\t\\t\\t+ displayManager.firstLine.skew;\\n\\t} \\n\\tpublic void setFirstLine(int firstLine)\\n\\t{\\n\\t\\t\\t\\tint max = displayManager.getScrollLineCount() - visibleLines\\n\\t\\t\\t+ (lastLinePartial ? 1 : 0);\\n\\t\\tif(firstLine > max)\\n\\t\\t\\tfirstLine = max;\\n\\t\\tif(firstLine < 0)\\n\\t\\t\\tfirstLine = 0;\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"setFirstLine() from \\\"\\n\\t\\t\\t\\t+ getFirstLine() + \\\" to \\\" + firstLine);\\n\\t\\t}\\n\\t\\tint oldFirstLine = getFirstLine();\\n\\t\\tif(firstLine == oldFirstLine)\\n\\t\\t\\treturn;\\n\\t\\tdisplayManager.setFirstLine(oldFirstLine,firstLine);\\n\\t\\trepaint();\\n\\t\\tfireScrollEvent(true);\\n\\t} \\n\\tpublic final int getFirstPhysicalLine()\\n\\t{\\n\\t\\treturn displayManager.firstLine.physicalLine;\\n\\t} \\n\\tpublic void setFirstPhysicalLine(int physFirstLine)\\n\\t{\\n\\t\\tsetFirstPhysicalLine(physFirstLine,0);\\n\\t} \\n\\tpublic void setFirstPhysicalLine(int physFirstLine, int skew)\\n\\t{\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"setFirstPhysicalLine(\\\"\\n\\t\\t\\t\\t+ physFirstLine + \\\",\\\" + skew + \\\")\\\");\\n\\t\\t}\\n\\t\\tint amount = (physFirstLine - displayManager.firstLine.physicalLine);\\n\\t\\tdisplayManager.setFirstPhysicalLine(amount,skew);\\n\\t\\trepaint();\\n\\t\\tfireScrollEvent(true);\\n\\t} \\n\\tpublic final int getLastPhysicalLine()\\n\\t{\\n\\t\\treturn physLastLine;\\n\\t} \\n\\tpublic int getLastScreenLine()\\n\\t{\\n\\t\\treturn screenLastLine;\\n\\t} \\n\\tpublic final int getVisibleLines()\\n\\t{\\n\\t\\treturn visibleLines;\\n\\t} \\n\\tpublic final int getHorizontalOffset()\\n\\t{\\n\\t\\treturn horizontalOffset;\\n\\t} \\n\\tpublic void setHorizontalOffset(int horizontalOffset)\\n\\t{\\n\\t\\tif(horizontalOffset > 0)\\n\\t\\t\\thorizontalOffset = 0;\\n\\t\\tif(horizontalOffset == this.horizontalOffset)\\n\\t\\t\\treturn;\\n\\t\\tthis.horizontalOffset = horizontalOffset;\\n\\t\\tif(horizontalOffset != horizontal.getValue())\\n\\t\\t\\tupdateScrollBars();\\n\\t\\tpainter.repaint();\\n\\t\\tfireScrollEvent(false);\\n\\t} \\n\\tpublic void scrollUpLine()\\n\\t{\\n\\t\\tsetFirstLine(getFirstLine() - 1);\\n\\t} \\n\\tpublic void scrollUpPage()\\n\\t{\\n\\t\\tsetFirstLine(getFirstLine() - getVisibleLines()\\n\\t\\t\\t+ (lastLinePartial ? 1 : 0));\\n\\t} \\n\\tpublic void scrollDownLine()\\n\\t{\\n\\t\\tsetFirstLine(getFirstLine() + 1);\\n\\t} \\n\\tpublic void scrollDownPage()\\n\\t{\\n\\t\\tsetFirstLine(getFirstLine() + getVisibleLines()\\n\\t\\t\\t- (lastLinePartial ? 1 : 0));\\n\\t} \\n\\tpublic void scrollToCaret(boolean doElectricScroll)\\n\\t{\\n\\t\\tscrollTo(caretLine,caret - buffer.getLineStartOffset(caretLine),\\n\\t\\t\\tdoElectricScroll);\\n\\t} \\n\\tpublic void scrollTo(int offset, boolean doElectricScroll)\\n\\t{\\n\\t\\tint line = buffer.getLineOfOffset(offset);\\n\\t\\tscrollTo(line,offset - buffer.getLineStartOffset(line),\\n\\t\\t\\tdoElectricScroll);\\n\\t} \\n\\tpublic void scrollTo(int line, int offset, boolean doElectricScroll)\\n\\t{\\n\\t\\tif(Debug.SCROLL_TO_DEBUG)\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"scrollTo(), lineCount=\\\"\\n\\t\\t\\t\\t+ getLineCount());\\n\\t\\t\\t\\tint extraEndVirt;\\n\\t\\tint lineLength = buffer.getLineLength(line);\\n\\t\\tif(offset > lineLength)\\n\\t\\t{\\n\\t\\t\\textraEndVirt = charWidth * (offset - lineLength);\\n\\t\\t\\toffset = lineLength;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\textraEndVirt = 0;\\n\\t\\tint _electricScroll = (doElectricScroll\\n\\t\\t\\t&& visibleLines - 1 > electricScroll * 2\\n\\t\\t\\t? electricScroll : 0); \\n\\t\\tif(visibleLines <= 1)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_TO_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"visibleLines <= 0\\\");\\n\\t\\t\\tsetFirstPhysicalLine(line,_electricScroll);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\t\\tint screenLine = chunkCache.getScreenLineOfOffset(line,offset);\\n\\t\\tint visibleLines = getVisibleLines();\\n\\t\\tif(screenLine == -1)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_TO_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"screenLine == -1\\\");\\n\\t\\t\\tChunkCache.LineInfo[] infos = chunkCache\\n\\t\\t\\t\\t.getLineInfosForPhysicalLine(line);\\n\\t\\t\\tint subregion = chunkCache.getSubregionOfOffset(\\n\\t\\t\\t\\toffset,infos);\\n\\t\\t\\tint prevLine = displayManager.getPrevVisibleLine(getFirstPhysicalLine());\\n\\t\\t\\tint nextLine = displayManager.getNextVisibleLine(getLastPhysicalLine());\\n\\t\\t\\tif(line == getFirstPhysicalLine())\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(Debug.SCROLL_TO_DEBUG)\\n\\t\\t\\t\\t\\tLog.log(Log.DEBUG,this,line + \\\" == \\\" + getFirstPhysicalLine());\\n\\t\\t\\t\\tsetFirstPhysicalLine(line,subregion\\n\\t\\t\\t\\t\\t- _electricScroll);\\n\\t\\t\\t}\\n\\t\\t\\telse if(line == prevLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(Debug.SCROLL_TO_DEBUG)\\n\\t\\t\\t\\t\\tLog.log(Log.DEBUG,this,line + \\\" == \\\" + prevLine);\\n\\t\\t\\t\\tsetFirstPhysicalLine(prevLine,subregion\\n\\t\\t\\t\\t\\t- _electricScroll);\\n\\t\\t\\t}\\n\\t\\t\\telse if(line == getLastPhysicalLine())\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(Debug.SCROLL_TO_DEBUG)\\n\\t\\t\\t\\t\\tLog.log(Log.DEBUG,this,line + \\\" == \\\" + getLastPhysicalLine());\\n\\t\\t\\t\\tsetFirstPhysicalLine(line,\\n\\t\\t\\t\\t\\tsubregion + _electricScroll\\n\\t\\t\\t\\t\\t- visibleLines\\n\\t\\t\\t\\t\\t+ (lastLinePartial ? 2 : 1));\\n\\t\\t\\t}\\n\\t\\t\\telse if(line == nextLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(Debug.SCROLL_TO_DEBUG)\\n\\t\\t\\t\\t\\tLog.log(Log.DEBUG,this,line + \\\" == \\\" + nextLine);\\n\\t\\t\\t\\tsetFirstPhysicalLine(nextLine,\\n\\t\\t\\t\\t\\tsubregion + electricScroll\\n\\t\\t\\t\\t\\t- visibleLines\\n\\t\\t\\t\\t\\t+ (lastLinePartial ? 2 : 1));\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(Debug.SCROLL_TO_DEBUG)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"neither\\\");\\n\\t\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"Last physical line is \\\" + getLastPhysicalLine());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsetFirstPhysicalLine(line,subregion\\n\\t\\t\\t\\t\\t- visibleLines / 2);\\n\\t\\t\\t\\tif(Debug.SCROLL_TO_DEBUG)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"Last physical line is \\\" + getLastPhysicalLine());\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(screenLine < _electricScroll)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_TO_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"electric up\\\");\\n\\t\\t\\tsetFirstLine(getFirstLine() - _electricScroll + screenLine);\\n\\t\\t}\\n\\t\\telse if(screenLine > visibleLines - _electricScroll\\n\\t\\t\\t- (lastLinePartial ? 2 : 1))\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_TO_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"electric down\\\");\\n\\t\\t\\tsetFirstLine(getFirstLine() + _electricScroll - visibleLines + screenLine + (lastLinePartial ? 2 : 1));\\n\\t\\t} \\n\\t\\t\\t\\tif(!displayManager.isLineVisible(line))\\n\\t\\t\\treturn;\\n\\t\\tPoint point = offsetToXY(line,offset,returnValue);\\n\\t\\tif(point == null)\\n\\t\\t{\\n\\t\\t\\tLog.log(Log.ERROR,this,\\\"BUG: screenLine=\\\" + screenLine\\n\\t\\t\\t\\t+ \\\",visibleLines=\\\" + visibleLines\\n\\t\\t\\t\\t+ \\\",physicalLine=\\\" + line\\n\\t\\t\\t\\t+ \\\",firstPhysicalLine=\\\" + getFirstPhysicalLine()\\n\\t\\t\\t\\t+ \\\",lastPhysicalLine=\\\" + getLastPhysicalLine());\\n\\t\\t}\\n\\t\\tpoint.x += extraEndVirt;\\n\\t\\tif(point.x < 0)\\n\\t\\t{\\n\\t\\t\\tsetHorizontalOffset(horizontalOffset\\n\\t\\t\\t\\t- point.x + charWidth + 5);\\n\\t\\t}\\n\\t\\telse if(point.x >= painter.getWidth() - charWidth - 5)\\n\\t\\t{\\n\\t\\t\\tsetHorizontalOffset(horizontalOffset +\\n\\t\\t\\t\\t(painter.getWidth() - point.x)\\n\\t\\t\\t\\t- charWidth - 5);\\n\\t\\t} \\t} \\n\\tpublic final void addScrollListener(ScrollListener listener)\\n\\t{\\n\\t\\tlistenerList.add(ScrollListener.class,listener);\\n\\t} \\n\\tpublic final void removeScrollListener(ScrollListener listener)\\n\\t{\\n\\t\\tlistenerList.remove(ScrollListener.class,listener);\\n\\t} \\n\\tpublic int getPhysicalLineOfScreenLine(int screenLine)\\n\\t{\\n\\t\\treturn chunkCache.getLineInfo(screenLine).physicalLine;\\n\\t} \\n\\tpublic int getScreenLineOfOffset(int offset)\\n\\t{\\n\\t\\tint line = buffer.getLineOfOffset(offset);\\n\\t\\toffset -= buffer.getLineStartOffset(line);\\n\\t\\treturn chunkCache.getScreenLineOfOffset(line,offset);\\n\\t} \\n\\tpublic int getScreenLineStartOffset(int line)\\n\\t{\\n\\t\\tChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);\\n\\t\\tif(lineInfo.physicalLine == -1)\\n\\t\\t\\treturn -1;\\n\\t\\treturn buffer.getLineStartOffset(lineInfo.physicalLine)\\n\\t\\t\\t+ lineInfo.offset;\\n\\t} \\n\\tpublic int getScreenLineEndOffset(int line)\\n\\t{\\n\\t\\tChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);\\n\\t\\tif(lineInfo.physicalLine == -1)\\n\\t\\t\\treturn -1;\\n\\t\\treturn buffer.getLineStartOffset(lineInfo.physicalLine)\\n\\t\\t\\t+ lineInfo.offset + lineInfo.length;\\n\\t} \\n\\tpublic int xyToOffset(int x, int y)\\n\\t{\\n\\t\\treturn xyToOffset(x,y,true);\\n\\t} \\n\\tpublic int xyToOffset(int x, int y, boolean round)\\n\\t{\\n\\t\\tFontMetrics fm = painter.getFontMetrics();\\n\\t\\tint height = fm.getHeight();\\n\\t\\tint line = y / height;\\n\\t\\tif(line < 0 || line >= visibleLines)\\n\\t\\t\\treturn -1;\\n\\t\\treturn xToScreenLineOffset(line,x,round);\\n\\t} \\n\\tpublic int xToScreenLineOffset(int screenLine, int x, boolean round)\\n\\t{\\n\\t\\tChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(screenLine);\\n\\t\\tif(lineInfo.physicalLine == -1)\\n\\t\\t{\\n\\t\\t\\treturn getLineEndOffset(displayManager\\n\\t\\t\\t\\t.getLastVisibleLine()) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint offset = Chunk.xToOffset(lineInfo.chunks,\\n\\t\\t\\t\\tx - horizontalOffset,round);\\n\\t\\t\\tif(offset == -1 || offset == lineInfo.offset + lineInfo.length)\\n\\t\\t\\t\\toffset = lineInfo.offset + lineInfo.length - 1;\\n\\t\\t\\treturn getLineStartOffset(lineInfo.physicalLine) + offset;\\n\\t\\t}\\n\\t} \\n\\tpublic Point offsetToXY(int offset)\\n\\t{\\n\\t\\tint line = buffer.getLineOfOffset(offset);\\n\\t\\toffset -= buffer.getLineStartOffset(line);\\n\\t\\tPoint retVal = new Point();\\n\\t\\treturn offsetToXY(line,offset,retVal);\\n\\t} \\n\\tpublic Point offsetToXY(int line, int offset)\\n\\t{\\n\\t\\treturn offsetToXY(line,offset,new Point());\\n\\t} \\n\\tpublic Point offsetToXY(int line, int offset, Point retVal)\\n\\t{\\n\\t\\tif(!displayManager.isLineVisible(line))\\n\\t\\t\\treturn null;\\n\\t\\tint screenLine = chunkCache.getScreenLineOfOffset(line,offset);\\n\\t\\tif(screenLine == -1)\\n\\t\\t\\treturn null;\\n\\t\\tFontMetrics fm = painter.getFontMetrics();\\n\\t\\tretVal.y = screenLine * fm.getHeight();\\n\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(screenLine);\\n\\t\\tretVal.x = (int)(horizontalOffset + Chunk.offsetToX(\\n\\t\\t\\tinfo.chunks,offset));\\n\\t\\treturn retVal;\\n\\t} \\n\\tpublic void invalidateScreenLineRange(int start, int end)\\n\\t{\\n\\t\\tif(!buffer.isLoaded())\\n\\t\\t\\treturn;\\n\\t\\tif(start > end)\\n\\t\\t{\\n\\t\\t\\tint tmp = end;\\n\\t\\t\\tend = start;\\n\\t\\t\\tstart = tmp;\\n\\t\\t}\\n\\t\\tif(chunkCache.needFullRepaint())\\n\\t\\t\\tend = visibleLines;\\n\\t\\tFontMetrics fm = painter.getFontMetrics();\\n\\t\\tint y = start * fm.getHeight();\\n\\t\\tint height = (end - start + 1) * fm.getHeight();\\n\\t\\tpainter.repaint(0,y,painter.getWidth(),height);\\n\\t\\tgutter.repaint(0,y,gutter.getWidth(),height);\\n\\t} \\n\\tpublic void invalidateLine(int line)\\n\\t{\\n\\t\\tif(!isShowing()\\n\\t\\t\\t|| !buffer.isLoaded()\\n\\t\\t\\t|| line < getFirstPhysicalLine()\\n\\t\\t\\t|| line > physLastLine\\n\\t\\t\\t|| !displayManager.isLineVisible(line))\\n\\t\\t\\treturn;\\n\\t\\tint startLine = -1;\\n\\t\\tint endLine = -1;\\n\\t\\tfor(int i = 0; i < visibleLines; i++)\\n\\t\\t{\\n\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(i);\\n\\t\\t\\tif((info.physicalLine >= line || info.physicalLine == -1)\\n\\t\\t\\t\\t&& startLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstartLine = i;\\n\\t\\t\\t}\\n\\t\\t\\tif((info.physicalLine >= line && info.lastSubregion)\\n\\t\\t\\t\\t|| info.physicalLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tendLine = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(chunkCache.needFullRepaint() || endLine == -1)\\n\\t\\t\\tendLine = visibleLines;\\n\\t\\tinvalidateScreenLineRange(startLine,endLine);\\n\\t} \\n\\tpublic void invalidateLineRange(int start, int end)\\n\\t{\\n\\t\\tif(!isShowing() || !buffer.isLoaded())\\n\\t\\t\\treturn;\\n\\t\\tif(end < start)\\n\\t\\t{\\n\\t\\t\\tint tmp = end;\\n\\t\\t\\tend = start;\\n\\t\\t\\tstart = tmp;\\n\\t\\t}\\n\\t\\tif(end < getFirstPhysicalLine() || start > getLastPhysicalLine())\\n\\t\\t\\treturn;\\n\\t\\tint startScreenLine = -1;\\n\\t\\tint endScreenLine = -1;\\n\\t\\tfor(int i = 0; i < visibleLines; i++)\\n\\t\\t{\\n\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(i);\\n\\t\\t\\tif((info.physicalLine >= start || info.physicalLine == -1)\\n\\t\\t\\t\\t&& startScreenLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstartScreenLine = i;\\n\\t\\t\\t}\\n\\t\\t\\tif((info.physicalLine >= end && info.lastSubregion)\\n\\t\\t\\t\\t|| info.physicalLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tendScreenLine = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(startScreenLine == -1)\\n\\t\\t\\tstartScreenLine = 0;\\n\\t\\tif(chunkCache.needFullRepaint() || endScreenLine == -1)\\n\\t\\t\\tendScreenLine = visibleLines;\\n\\t\\tinvalidateScreenLineRange(startScreenLine,endScreenLine);\\n\\t} \\n\\tpublic final int getBufferLength()\\n\\t{\\n\\t\\treturn buffer.getLength();\\n\\t} \\n\\tpublic final int getLineCount()\\n\\t{\\n\\t\\treturn buffer.getLineCount();\\n\\t} \\n\\tpublic final int getLineOfOffset(int offset)\\n\\t{\\n\\t\\treturn buffer.getLineOfOffset(offset);\\n\\t} \\n\\tpublic int getLineStartOffset(int line)\\n\\t{\\n\\t\\treturn buffer.getLineStartOffset(line);\\n\\t} \\n\\tpublic int getLineEndOffset(int line)\\n\\t{\\n\\t\\treturn buffer.getLineEndOffset(line);\\n\\t} \\n\\tpublic int getLineLength(int line)\\n\\t{\\n\\t\\treturn buffer.getLineLength(line);\\n\\t} \\n\\tpublic final String getText(int start, int len)\\n\\t{\\n\\t\\treturn buffer.getText(start,len);\\n\\t} \\n\\tpublic final void getText(int start, int len, Segment segment)\\n\\t{\\n\\t\\tbuffer.getText(start,len,segment);\\n\\t} \\n\\tpublic final String getLineText(int lineIndex)\\n\\t{\\n\\t\\treturn buffer.getLineText(lineIndex);\\n\\t} \\n\\tpublic final void getLineText(int lineIndex, Segment segment)\\n\\t{\\n\\t\\tbuffer.getLineText(lineIndex,segment);\\n\\t} \\n\\tpublic String getText()\\n\\t{\\n\\t\\treturn buffer.getText(0,buffer.getLength());\\n\\t} \\n\\tpublic void setText(String text)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tbuffer.remove(0,buffer.getLength());\\n\\t\\t\\tbuffer.insert(0,text);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic final void selectAll()\\n\\t{\\n\\t\\tint firstLine = getFirstLine();\\n\\t\\tint horizOffset = getHorizontalOffset();\\n\\t\\tsetSelection(new Selection.Range(0,buffer.getLength()));\\n\\t\\tmoveCaretPosition(buffer.getLength(),true);\\n\\t\\tsetFirstLine(firstLine);\\n\\t\\tsetHorizontalOffset(horizOffset);\\n\\t} \\n\\tpublic void selectLine()\\n\\t{\\n\\t\\tint caretLine = getCaretLine();\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine) - 1;\\n\\t\\tSelection s = new Selection.Range(start,end);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(end);\\n\\t} \\n\\tpublic void selectParagraph()\\n\\t{\\n\\t\\tint caretLine = getCaretLine();\\n\\t\\tif(getLineLength(caretLine) == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint start = caretLine;\\n\\t\\tint end = caretLine;\\n\\t\\twhile(start >= 0)\\n\\t\\t{\\n\\t\\t\\tif(getLineLength(start) == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\telse\\n\\t\\t\\t\\tstart--;\\n\\t\\t}\\n\\t\\twhile(end < getLineCount())\\n\\t\\t{\\n\\t\\t\\tif(getLineLength(end) == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\telse\\n\\t\\t\\t\\tend++;\\n\\t\\t}\\n\\t\\tint selectionStart = getLineStartOffset(start + 1);\\n\\t\\tint selectionEnd = getLineEndOffset(end - 1) - 1;\\n\\t\\tSelection s = new Selection.Range(selectionStart,selectionEnd);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(selectionEnd);\\n\\t} \\n\\tpublic void selectWord()\\n\\t{\\n\\t\\tint line = getCaretLine();\\n\\t\\tint lineStart = getLineStartOffset(line);\\n\\t\\tint offset = getCaretPosition() - lineStart;\\n\\t\\tif(getLineLength(line) == 0)\\n\\t\\t\\treturn;\\n\\t\\tString lineText = getLineText(line);\\n\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\tif(offset == getLineLength(line))\\n\\t\\t\\toffset--;\\n\\t\\tint wordStart = TextUtilities.findWordStart(lineText,offset,noWordSep);\\n\\t\\tint wordEnd = TextUtilities.findWordEnd(lineText,offset+1,noWordSep);\\n\\t\\tSelection s = new Selection.Range(lineStart + wordStart,\\n\\t\\t\\tlineStart + wordEnd);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(lineStart + wordEnd);\\n\\t} \\n\\tpublic Selection selectToMatchingBracket(int position,\\n\\t\\tboolean quickCopy)\\n\\t{\\n\\t\\tint positionLine = buffer.getLineOfOffset(position);\\n\\t\\tint lineOffset = position - buffer.getLineStartOffset(positionLine);\\n\\t\\tif(getLineLength(positionLine) != 0)\\n\\t\\t{\\n\\t\\t\\tint bracket = TextUtilities.findMatchingBracket(buffer,\\n\\t\\t\\t\\tpositionLine,Math.max(0,lineOffset - 1));\\n\\t\\t\\tif(bracket != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s;\\n\\t\\t\\t\\tif(bracket < position)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!quickCopy)\\n\\t\\t\\t\\t\\t\\tmoveCaretPosition(position,false);\\n\\t\\t\\t\\t\\ts = new Selection.Range(bracket,position);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!quickCopy)\\n\\t\\t\\t\\t\\t\\tmoveCaretPosition(bracket + 1,false);\\n\\t\\t\\t\\t\\ts = new Selection.Range(position - 1,bracket + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!multi && !quickCopy)\\n\\t\\t\\t\\t\\tselectNone();\\n\\t\\t\\t\\taddToSelection(s);\\n\\t\\t\\t\\treturn s;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn null;\\n\\t} \\n\\tpublic void selectToMatchingBracket()\\n\\t{\\n\\t\\tselectToMatchingBracket(caret,false);\\n\\t} \\n\\tpublic void selectBlock()\\n\\t{\\n\\t\\tString openBrackets = \\\"([{\\\";\\n\\t\\tString closeBrackets = \\\")]}\\\";\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint start, end;\\n\\t\\tif(s == null)\\n\\t\\t\\tstart = end = caret;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstart = s.start;\\n\\t\\t\\tend = s.end;\\n\\t\\t}\\n\\t\\tString text = getText(0,buffer.getLength());\\n\\t\\t\\t\\tint count = 1;\\n\\t\\tchar openBracket = '\\\\0';\\n\\t\\tchar closeBracket = '\\\\0';\\n\\t\\t\\t\\tif(start == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\nbackward_scan:\\twhile(--start > 0)\\n\\t\\t{\\n\\t\\t\\tchar c = text.charAt(start);\\n\\t\\t\\tint index = openBrackets.indexOf(c);\\n\\t\\t\\tif(index != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(--count == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\topenBracket = c;\\n\\t\\t\\t\\t\\tcloseBracket = closeBrackets.charAt(index);\\n\\t\\t\\t\\t\\tbreak backward_scan;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(closeBrackets.indexOf(c) != -1)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\t\\t\\tcount = 1;\\n\\t\\t\\t\\tif(openBracket == '\\\\0')\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\nforward_scan:\\t\\tdo\\n\\t\\t\\t{\\n\\t\\t\\t\\tchar c = text.charAt(end);\\n\\t\\t\\t\\tif(c == closeBracket)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(--count == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tend++;\\n\\t\\t\\t\\t\\t\\tbreak forward_scan;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(c == openBracket)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\twhile(++end < buffer.getLength());\\n\\t\\t}\\n\\t\\ts = new Selection.Range(start,end);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(end);\\n\\t} \\n\\tpublic boolean lineInStructureScope(int line)\\n\\t{\\n\\t\\tif(match == null)\\n\\t\\t\\treturn false;\\n\\t\\tif(match.startLine < caretLine)\\n\\t\\t\\treturn (line >= match.startLine && line <= caretLine);\\n\\t\\telse\\n\\t\\t\\treturn (line <= match.endLine && line >= caretLine);\\n\\t} \\n\\tpublic final void invertSelection()\\n\\t{\\n\\t\\tselectionManager.invertSelection();\\n\\t} \\n\\tpublic int getSelectionCount()\\n\\t{\\n\\t\\treturn selectionManager.getSelectionCount();\\n\\t} \\n\\tpublic Selection[] getSelection()\\n\\t{\\n\\t\\treturn selectionManager.getSelection();\\n\\t} \\n\\tpublic Iterator getSelectionIterator()\\n\\t{\\n\\t\\treturn selectionManager.selection.iterator();\\n\\t} \\n\\tpublic Selection getSelection(int index)\\n\\t{\\n\\t\\treturn (Selection)selectionManager.selection.get(index);\\n\\t} \\n\\tpublic void selectNone()\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tsetSelection((Selection)null);\\n\\t} \\n\\tpublic void setSelection(Selection[] selection)\\n\\t{\\n\\t\\t\\t\\tinvalidateSelectedLines();\\n\\t\\tselectionManager.setSelection(selection);\\n\\t\\tfinishCaretUpdate(caretLine,NO_SCROLL,true);\\n\\t} \\n\\tpublic void setSelection(Selection selection)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tselectionManager.setSelection(selection);\\n\\t\\tfinishCaretUpdate(caretLine,NO_SCROLL,true);\\n\\t} \\n\\tpublic void addToSelection(Selection[] selection)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tselectionManager.addToSelection(selection);\\n\\t\\tfinishCaretUpdate(caretLine,NO_SCROLL,true);\\n\\t} \\n\\tpublic void addToSelection(Selection selection)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tselectionManager.addToSelection(selection);\\n\\t\\tfinishCaretUpdate(caretLine,NO_SCROLL,true);\\n\\t} \\n\\tpublic Selection getSelectionAtOffset(int offset)\\n\\t{\\n\\t\\treturn selectionManager.getSelectionAtOffset(offset);\\n\\t} \\n\\tpublic void removeFromSelection(Selection sel)\\n\\t{\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tselectionManager.removeFromSelection(sel);\\n\\t\\tfinishCaretUpdate(caretLine,NO_SCROLL,true);\\n\\t} \\n\\tpublic void removeFromSelection(int offset)\\n\\t{\\n\\t\\tSelection sel = getSelectionAtOffset(offset);\\n\\t\\tif(sel == null)\\n\\t\\t\\treturn;\\n\\t\\tinvalidateSelectedLines();\\n\\t\\tselectionManager.removeFromSelection(sel);\\n\\t\\tfinishCaretUpdate(caretLine,NO_SCROLL,true);\\n\\t} \\n\\tpublic void resizeSelection(int offset, int end, int extraEndVirt,\\n\\t\\tboolean rect)\\n\\t{\\n\\t\\tSelection s = selectionManager.getSelectionAtOffset(offset);\\n\\t\\tif(s != null)\\n\\t\\t{\\n\\t\\t\\tinvalidateLineRange(s.startLine,s.endLine);\\n\\t\\t\\tselectionManager.removeFromSelection(s);\\n\\t\\t}\\n\\t\\tselectionManager.resizeSelection(offset,end,extraEndVirt,rect);\\n\\t\\tfireCaretEvent();\\n\\t} \\n\\tpublic void extendSelection(int offset, int end)\\n\\t{\\n\\t\\textendSelection(offset,end,0,0);\\n\\t} \\n\\tpublic void extendSelection(int offset, int end,\\n\\t\\tint extraStartVirt, int extraEndVirt)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(offset);\\n\\t\\tif(s != null)\\n\\t\\t{\\n\\t\\t\\tinvalidateLineRange(s.startLine,s.endLine);\\n\\t\\t\\tselectionManager.removeFromSelection(s);\\n\\t\\t\\tif(offset == s.start)\\n\\t\\t\\t{\\n\\t\\t\\t\\toffset = end;\\n\\t\\t\\t\\tend = s.end;\\n\\t\\t\\t}\\n\\t\\t\\telse if(offset == s.end)\\n\\t\\t\\t{\\n\\t\\t\\t\\toffset = s.start;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(end < offset)\\n\\t\\t{\\n\\t\\t\\tint tmp = end;\\n\\t\\t\\tend = offset;\\n\\t\\t\\toffset = tmp;\\n\\t\\t}\\n\\t\\tif(rectangularSelectionMode)\\n\\t\\t{\\n\\t\\t\\ts = new Selection.Rect(offset,end);\\n\\t\\t\\t((Selection.Rect)s).extraStartVirt = extraStartVirt;\\n\\t\\t\\t((Selection.Rect)s).extraEndVirt = extraEndVirt;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\ts = new Selection.Range(offset,end);\\n\\t\\tselectionManager.addToSelection(s);\\n\\t\\tfireCaretEvent();\\n\\t\\tif(rectangularSelectionMode && extraEndVirt != 0)\\n\\t\\t{\\n\\t\\t\\tint line = getLineOfOffset(end);\\n\\t\\t\\tscrollTo(line,getLineLength(line) + extraEndVirt,false);\\n\\t\\t}\\n\\t} \\n\\tpublic String getSelectedText(Selection s)\\n\\t{\\n\\t\\tStringBuffer buf = new StringBuffer();\\n\\t\\ts.getText(buffer,buf);\\n\\t\\treturn buf.toString();\\n\\t} \\n\\tpublic String getSelectedText(String separator)\\n\\t{\\n\\t\\tSelection[] sel = selectionManager.getSelection();\\n\\t\\tif(sel.length == 0)\\n\\t\\t\\treturn null;\\n\\t\\tStringBuffer buf = new StringBuffer();\\n\\t\\tfor(int i = 0; i < sel.length; i++)\\n\\t\\t{\\n\\t\\t\\tif(i != 0)\\n\\t\\t\\t\\tbuf.append(separator);\\n\\t\\t\\tsel[i].getText(buffer,buf);\\n\\t\\t}\\n\\t\\treturn buf.toString();\\n\\t} \\n\\tpublic String getSelectedText()\\n\\t{\\n\\t\\treturn getSelectedText(\\\"\\\\n\\\");\\n\\t} \\n\\tpublic void setSelectedText(Selection s, String selectedText)\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tthrow new InternalError(\\\"Text component\\\"\\n\\t\\t\\t\\t+ \\\" read only\\\");\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tmoveCaretPosition(s.setText(buffer,selectedText));\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\t\\t\\t\\t} \\n\\tpublic void setSelectedText(String selectedText)\\n\\t{\\n\\t\\tint newCaret = replaceSelection(selectedText);\\n\\t\\tif(newCaret != -1)\\n\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic void setSelectedText(String selectedText, boolean moveCaret)\\n\\t{\\n\\t\\tint newCaret = replaceSelection(selectedText);\\n\\t\\tif(moveCaret && newCaret != -1)\\n\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic int replaceSelection(String selectedText)\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t\\tthrow new RuntimeException(\\\"Text component read only\\\");\\n\\t\\tint newCaret = -1;\\n\\t\\tif(getSelectionCount() == 0)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.insert(caret,selectedText);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tSelection[] selection = getSelection();\\n\\t\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t\\t\\tnewCaret = selection[i].setText(buffer,selectedText);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn newCaret;\\n\\t} \\n\\tpublic int[] getSelectedLines()\\n\\t{\\n\\t\\tif(selectionManager.getSelectionCount() == 0)\\n\\t\\t\\treturn new int[] { caretLine };\\n\\t\\treturn selectionManager.getSelectedLines();\\n\\t} \\n\\tpublic void addStructureMatcher(StructureMatcher matcher)\\n\\t{\\n\\t\\tstructureMatchers.add(matcher);\\n\\t} \\n\\tpublic void removeStructureMatcher(StructureMatcher matcher)\\n\\t{\\n\\t\\tstructureMatchers.remove(matcher);\\n\\t} \\n\\tpublic StructureMatcher.Match getStructureMatch()\\n\\t{\\n\\t\\treturn match;\\n\\t} \\n\\tpublic final void blinkCaret()\\n\\t{\\n\\t\\tif(caretBlinks)\\n\\t\\t{\\n\\t\\t\\tblink = !blink;\\n\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tblink = true;\\n\\t} \\n\\tpublic void centerCaret()\\n\\t{\\n\\t\\tint offset = getScreenLineStartOffset(visibleLines / 2);\\n\\t\\tif(offset == -1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t\\tsetCaretPosition(offset);\\n\\t} \\n\\tpublic void setCaretPosition(int newCaret)\\n\\t{\\n\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret,true);\\n\\t} \\n\\tpublic void setCaretPosition(int newCaret, boolean doElectricScroll)\\n\\t{\\n\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret,doElectricScroll);\\n\\t} \\n\\tpublic void moveCaretPosition(int newCaret)\\n\\t{\\n\\t\\tmoveCaretPosition(newCaret,true);\\n\\t} \\n\\tpublic void moveCaretPosition(int newCaret, boolean doElectricScroll)\\n\\t{\\n\\t\\tmoveCaretPosition(newCaret,doElectricScroll ? ELECTRIC_SCROLL\\n\\t\\t\\t: NORMAL_SCROLL);\\n\\t} \\n\\t\\tpublic static int NO_SCROLL = 0;\\n\\tpublic static int NORMAL_SCROLL = 1;\\n\\tpublic static int ELECTRIC_SCROLL = 2;\\n\\tpublic void moveCaretPosition(int newCaret, int scrollMode)\\n\\t{\\n\\t\\tif(newCaret < 0 || newCaret > buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tthrow new IllegalArgumentException(\\\"caret out of bounds: \\\"\\n\\t\\t\\t\\t+ newCaret);\\n\\t\\t}\\n\\t\\tint oldCaretLine = caretLine;\\n\\t\\tif(caret == newCaret)\\n\\t\\t\\tfinishCaretUpdate(oldCaretLine,scrollMode,false);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcaret = newCaret;\\n\\t\\t\\tcaretLine = getLineOfOffset(newCaret);\\n\\t\\t\\tmagicCaret = -1;\\n\\t\\t\\tfinishCaretUpdate(oldCaretLine,scrollMode,true);\\n\\t\\t}\\n\\t} \\n\\tpublic int getCaretPosition()\\n\\t{\\n\\t\\treturn caret;\\n\\t} \\n\\tpublic int getCaretLine()\\n\\t{\\n\\t\\treturn caretLine;\\n\\t} \\n\\tpublic int getMagicCaretPosition()\\n\\t{\\n\\t\\tif(magicCaret == -1)\\n\\t\\t{\\n\\t\\t\\tmagicCaret = chunkCache.subregionOffsetToX(\\n\\t\\t\\t\\tcaretLine,caret - getLineStartOffset(caretLine));\\n\\t\\t}\\n\\t\\treturn magicCaret;\\n\\t} \\n\\tpublic void setMagicCaretPosition(int magicCaret)\\n\\t{\\n\\t\\tthis.magicCaret = magicCaret;\\n\\t} \\n\\tpublic final void addCaretListener(CaretListener listener)\\n\\t{\\n\\t\\tlistenerList.add(CaretListener.class,listener);\\n\\t} \\n\\tpublic final void removeCaretListener(CaretListener listener)\\n\\t{\\n\\t\\tlistenerList.remove(CaretListener.class,listener);\\n\\t} \\n\\tpublic void goToNextBracket(boolean select)\\n\\t{\\n\\t\\tint newCaret = -1;\\n\\t\\tif(caret != buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tString text = getText(caret,buffer.getLength()\\n\\t\\t\\t\\t- caret - 1);\\nloop:\\t\\t\\tfor(int i = 0; i < text.length(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(text.charAt(i))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ')': case ']': case '}':\\n\\t\\t\\t\\t\\tnewCaret = caret + i + 1;\\n\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(newCaret == -1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(select)\\n\\t\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\t\\telse if(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t}\\n\\t} \\n\\tpublic void goToNextCharacter(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(!select && s instanceof Selection.Range)\\n\\t\\t{\\n\\t\\t\\tif(multi)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caret != s.end)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmoveCaretPosition(s.end);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetCaretPosition(s.end);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint extraStartVirt, extraEndVirt;\\n\\t\\tif(s instanceof Selection.Rect)\\n\\t\\t{\\n\\t\\t\\textraStartVirt = ((Selection.Rect)s).extraStartVirt;\\n\\t\\t\\textraEndVirt = ((Selection.Rect)s).extraEndVirt;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\textraStartVirt = 0;\\n\\t\\t\\textraEndVirt = 0;\\n\\t\\t}\\n\\t\\tint newCaret = caret;\\n\\t\\tif(caret == buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tif(select && (rectangularSelectionMode || s instanceof Selection.Rect))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s != null && caret == s.start)\\n\\t\\t\\t\\t\\textraStartVirt++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\textraEndVirt++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(caret == getLineEndOffset(caretLine) - 1)\\n\\t\\t{\\n\\t\\t\\tif(select && (rectangularSelectionMode || s instanceof Selection.Rect))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s != null && caret == s.start)\\n\\t\\t\\t\\t\\textraStartVirt++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\textraEndVirt++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint line = displayManager.getNextVisibleLine(caretLine);\\n\\t\\t\\t\\tif(line == -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tnewCaret = getLineStartOffset(line);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tnewCaret = caret + 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret,extraStartVirt,extraEndVirt);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToNextLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tboolean rectSelect = (s == null ? rectangularSelectionMode\\n\\t\\t\\t: s instanceof Selection.Rect);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = chunkCache.getBelowPosition(caretLine,\\n\\t\\t\\tcaret - buffer.getLineStartOffset(caretLine),magic + 1,\\n\\t\\t\\trectSelect && select);\\n\\t\\tif(newCaret == -1)\\n\\t\\t{\\n\\t\\t\\tint end = getLineEndOffset(caretLine) - 1;\\n\\t\\t\\tif(caret == end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tnewCaret = end;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t{\\n\\t\\t\\tRectParams params = getRectParams(caret,newCaret);\\n\\t\\t\\tint extraStartVirt;\\n\\t\\t\\tint extraEndVirt;\\n\\t\\t\\tif(params == null)\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = 0;\\n\\t\\t\\t\\textraEndVirt = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = params.extraStartVirt;\\n\\t\\t\\t\\textraEndVirt = params.extraEndVirt;\\n\\t\\t\\t\\tnewCaret = params.newCaret;\\n\\t\\t\\t}\\n\\t\\t\\textendSelection(caret,newCaret,extraStartVirt,extraEndVirt);\\n\\t\\t}\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToNextMarker(boolean select)\\n\\t{\\n\\t\\tVector markers = buffer.getMarkers();\\n\\t\\tif(markers.size() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tMarker marker = null;\\n\\t\\tfor(int i = 0; i < markers.size(); i++)\\n\\t\\t{\\n\\t\\t\\tMarker _marker = (Marker)markers.get(i);\\n\\t\\t\\tif(_marker.getPosition() > caret)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmarker = _marker;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(marker == null)\\n\\t\\t\\tmarker = (Marker)markers.get(0);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,marker.getPosition());\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(marker.getPosition());\\n\\t} \\n\\tpublic void goToNextPage(boolean select)\\n\\t{\\n\\t\\tscrollToCaret(false);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tif(caretLine < displayManager.getFirstVisibleLine())\\n\\t\\t{\\n\\t\\t\\tcaretLine = displayManager.getNextVisibleLine(\\n\\t\\t\\t\\tcaretLine);\\n\\t\\t}\\n\\t\\tint newCaret;\\n\\t\\tif(getFirstLine() + getVisibleLines() >= displayManager\\n\\t\\t\\t.getScrollLineCount())\\n\\t\\t{\\n\\t\\t\\tint lastVisibleLine = displayManager\\n\\t\\t\\t\\t.getLastVisibleLine();\\n\\t\\t\\tnewCaret = getLineEndOffset(lastVisibleLine) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint caretScreenLine = getScreenLineOfOffset(caret);\\n\\t\\t\\tscrollDownPage();\\n\\t\\t\\tnewCaret = xToScreenLineOffset(caretScreenLine,\\n\\t\\t\\t\\tmagic,true);\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret,false);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToNextParagraph(boolean select)\\n\\t{\\n\\t\\tint lineNo = getCaretLine();\\n\\t\\tint newCaret = getBufferLength();\\n\\t\\tboolean foundBlank = false;\\nloop:\\t\\tfor(int i = lineNo + 1; i < getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tif(!displayManager.isLineVisible(i))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif(foundBlank)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnewCaret = getLineStartOffset(i);\\n\\t\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfoundBlank = true;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToNextWord(boolean select)\\n\\t{\\n\\t\\tgoToNextWord(select,false);\\n\\t} \\n\\tpublic void goToNextWord(boolean select, boolean eatWhitespace)\\n\\t{\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint newCaret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(newCaret == lineText.length())\\n\\t\\t{\\n\\t\\t\\tint nextLine = displayManager.getNextVisibleLine(caretLine);\\n\\t\\t\\tif(nextLine == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret = getLineStartOffset(nextLine);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tnewCaret = TextUtilities.findWordEnd(lineText,\\n\\t\\t\\t\\tnewCaret + 1,noWordSep,true,eatWhitespace);\\n\\t\\t\\tnewCaret += lineStart;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToPrevBracket(boolean select)\\n\\t{\\n\\t\\tString text = getText(0,caret);\\n\\t\\tint newCaret = -1;\\nloop:\\t\\tfor(int i = getCaretPosition() - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tswitch(text.charAt(i))\\n\\t\\t\\t{\\n\\t\\t\\tcase '(': case '[': case '{':\\n\\t\\t\\t\\tnewCaret = i;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(newCaret == -1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(select)\\n\\t\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\t\\telse if(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t}\\n\\t} \\n\\tpublic void goToPrevCharacter(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(!select && s instanceof Selection.Range)\\n\\t\\t{\\n\\t\\t\\tif(multi)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caret != s.start)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmoveCaretPosition(s.start);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetCaretPosition(s.start);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint extraStartVirt = 0;\\n\\t\\tint extraEndVirt = 0;\\n\\t\\tint newCaret = caret;\\n\\t\\tif(select && caret == getLineEndOffset(caretLine) - 1)\\n\\t\\t{\\n\\t\\t\\tif(s instanceof Selection.Rect)\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = ((Selection.Rect)s).extraStartVirt;\\n\\t\\t\\t\\textraEndVirt = ((Selection.Rect)s).extraEndVirt;\\n\\t\\t\\t\\tif(caret == s.start)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(extraStartVirt == 0)\\n\\t\\t\\t\\t\\t\\tnewCaret = caret - 1;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\textraStartVirt--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(extraEndVirt == 0)\\n\\t\\t\\t\\t\\t\\tnewCaret = caret - 1;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\textraEndVirt--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tnewCaret = caret - 1;\\n\\t\\t}\\n\\t\\telse if(caret == getLineStartOffset(caretLine))\\n\\t\\t{\\n\\t\\t\\tint line = displayManager.getPrevVisibleLine(caretLine);\\n\\t\\t\\tif(line == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tnewCaret = getLineEndOffset(line) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tnewCaret = caret - 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret,extraStartVirt,extraEndVirt);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToPrevLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tboolean rectSelect = (s == null ? rectangularSelectionMode\\n\\t\\t\\t: s instanceof Selection.Rect);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = chunkCache.getAbovePosition(caretLine,\\n\\t\\t\\tcaret - buffer.getLineStartOffset(caretLine),magic + 1,\\n\\t\\t\\trectSelect && select);\\n\\t\\tif(newCaret == -1)\\n\\t\\t{\\n\\t\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\t\\tif(caret == start)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tnewCaret = start;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t{\\n\\t\\t\\tRectParams params = getRectParams(caret,newCaret);\\n\\t\\t\\tint extraStartVirt;\\n\\t\\t\\tint extraEndVirt;\\n\\t\\t\\tif(params == null)\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = 0;\\n\\t\\t\\t\\textraEndVirt = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\textraStartVirt = params.extraStartVirt;\\n\\t\\t\\t\\textraEndVirt = params.extraEndVirt;\\n\\t\\t\\t\\tnewCaret = params.newCaret;\\n\\t\\t\\t}\\n\\t\\t\\textendSelection(caret,newCaret,extraStartVirt,extraEndVirt);\\n\\t\\t}\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToPrevMarker(boolean select)\\n\\t{\\n\\t\\tVector markers = buffer.getMarkers();\\n\\t\\tif(markers.size() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tMarker marker = null;\\n\\t\\tfor(int i = markers.size() - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tMarker _marker = (Marker)markers.elementAt(i);\\n\\t\\t\\tif(_marker.getPosition() < caret)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmarker = _marker;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(marker == null)\\n\\t\\t\\tmarker = (Marker)markers.get(markers.size() - 1);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,marker.getPosition());\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(marker.getPosition());\\n\\t} \\n\\tpublic void goToPrevPage(boolean select)\\n\\t{\\n\\t\\tscrollToCaret(false);\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tif(caretLine < displayManager.getFirstVisibleLine())\\n\\t\\t{\\n\\t\\t\\tcaretLine = displayManager.getNextVisibleLine(\\n\\t\\t\\t\\tcaretLine);\\n\\t\\t}\\n\\t\\tint newCaret;\\n\\t\\tif(getFirstLine() == 0)\\n\\t\\t{\\n\\t\\t\\tint firstVisibleLine = displayManager\\n\\t\\t\\t\\t.getFirstVisibleLine();\\n\\t\\t\\tnewCaret = getLineStartOffset(firstVisibleLine);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint caretScreenLine = getScreenLineOfOffset(caret);\\n\\t\\t\\tscrollUpPage();\\n\\t\\t\\tnewCaret = xToScreenLineOffset(caretScreenLine,\\n\\t\\t\\t\\tmagic,true);\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret,false);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToPrevParagraph(boolean select)\\n\\t{\\n\\t\\tint lineNo = caretLine;\\n\\t\\tint newCaret = 0;\\n\\t\\tboolean foundBlank = false;\\nloop:\\t\\tfor(int i = lineNo - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(!displayManager.isLineVisible(i))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif(foundBlank)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnewCaret = getLineEndOffset(i) - 1;\\n\\t\\t\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfoundBlank = true;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToPrevWord(boolean select)\\n\\t{\\n\\t\\tgoToPrevWord(select,false);\\n\\t} \\n\\tpublic void goToPrevWord(boolean select, boolean eatWhitespace)\\n\\t{\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint newCaret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(newCaret == 0)\\n\\t\\t{\\n\\t\\t\\tif(lineStart == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint prevLine = displayManager.getPrevVisibleLine(caretLine);\\n\\t\\t\\t\\tif(prevLine == -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnewCaret = getLineEndOffset(prevLine) - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\tnewCaret = TextUtilities.findWordStart(lineText,\\n\\t\\t\\t\\tnewCaret - 1,noWordSep,true,eatWhitespace);\\n\\t\\t\\tnewCaret += lineStart;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void smartHome(boolean select)\\n\\t{\\n\\t\\tMacros.Recorder recorder = view.getMacroRecorder();\\n\\t\\tswitch(view.getInputHandler().getLastActionCount())\\n\\t\\t{\\n\\t\\tcase 1:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToStartOfWhiteSpace(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToStartOfWhiteSpace(select);\\n\\t\\t\\tbreak;\\n\\t\\tcase 2:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToStartOfLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToStartOfLine(select);\\n\\t\\t\\tbreak;\\n\\t\\tdefault: \\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToFirstVisibleLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToFirstVisibleLine(select);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t} \\n\\tpublic void smartEnd(boolean select)\\n\\t{\\n\\t\\tMacros.Recorder recorder = view.getMacroRecorder();\\n\\t\\tswitch(view.getInputHandler().getLastActionCount())\\n\\t\\t{\\n\\t\\tcase 1:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToEndOfWhiteSpace(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToEndOfWhiteSpace(select);\\n\\t\\t\\tbreak;\\n\\t\\tcase 2:\\n\\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToEndOfLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToEndOfLine(select);\\n\\t\\t\\tbreak;\\n\\t\\tdefault: \\t\\t\\tif(recorder != null)\\n\\t\\t\\t\\trecorder.record(\\\"textArea.goToLastVisibleLine(\\\" + select + \\\");\\\");\\n\\t\\t\\tgoToLastVisibleLine(select);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t} \\n\\tpublic void goToStartOfLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line = (select || s == null\\n\\t\\t\\t? caretLine : s.startLine);\\n\\t\\tint newCaret = getLineStartOffset(line);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void goToEndOfLine(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line = (select || s == null\\n\\t\\t\\t? caretLine : s.endLine);\\n\\t\\tint newCaret = getLineEndOffset(line) - 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\t\\t\\t\\t\\t\\t} \\n\\tpublic void goToStartOfWhiteSpace(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line, offset;\\n\\t\\tif(select || s == null)\\n\\t\\t{\\n\\t\\t\\tline = caretLine;\\n\\t\\t\\toffset = caret - buffer.getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tline = s.startLine;\\n\\t\\t\\toffset = s.start - buffer.getLineStartOffset(line);\\n\\t\\t}\\n\\t\\tint firstIndent = chunkCache.getSubregionStartOffset(line,offset);\\n\\t\\tif(firstIndent == getLineStartOffset(line))\\n\\t\\t{\\n\\t\\t\\tfirstIndent = MiscUtilities.getLeadingWhiteSpace(getLineText(line));\\n\\t\\t\\tif(firstIndent == getLineLength(line))\\n\\t\\t\\t\\tfirstIndent = 0;\\n\\t\\t\\tfirstIndent += getLineStartOffset(line);\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,firstIndent);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(firstIndent);\\n\\t} \\n\\tpublic void goToEndOfWhiteSpace(boolean select)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint line, offset;\\n\\t\\tif(select || s == null)\\n\\t\\t{\\n\\t\\t\\tline = caretLine;\\n\\t\\t\\toffset = caret - getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tline = s.endLine;\\n\\t\\t\\toffset = s.end - getLineStartOffset(line);\\n\\t\\t}\\n\\t\\tint lastIndent = chunkCache.getSubregionEndOffset(line,offset);\\n\\t\\tif(lastIndent == getLineEndOffset(line))\\n\\t\\t{\\n\\t\\t\\tlastIndent = getLineLength(line) - MiscUtilities.getTrailingWhiteSpace(getLineText(line));\\n\\t\\t\\tif(lastIndent == 0)\\n\\t\\t\\t\\tlastIndent = getLineLength(line);\\n\\t\\t\\tlastIndent += getLineStartOffset(line);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlastIndent--;\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,lastIndent);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(lastIndent);\\n\\t} \\n\\tpublic void goToFirstVisibleLine(boolean select)\\n\\t{\\n\\t\\tint firstVisibleLine = getFirstLine() == 0 ? 0 : electricScroll;\\n\\t\\tint firstVisible = getScreenLineStartOffset(firstVisibleLine);\\n\\t\\tif(firstVisible == -1)\\n\\t\\t{\\n\\t\\t\\tfirstVisible = getLineStartOffset(displayManager\\n\\t\\t\\t\\t.getFirstVisibleLine());\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,firstVisible);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(firstVisible);\\n\\t} \\n\\tpublic void goToLastVisibleLine(boolean select)\\n\\t{\\n\\t\\tint lastVisible;\\n\\t\\tif(getFirstLine() + visibleLines >=\\n\\t\\t\\tdisplayManager.getScrollLineCount())\\n\\t\\t{\\n\\t\\t\\tlastVisible = getLineEndOffset(displayManager\\n\\t\\t\\t\\t.getLastVisibleLine()) - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlastVisible = visibleLines - electricScroll - 1;\\n\\t\\t\\tif(lastLinePartial)\\n\\t\\t\\t\\tlastVisible--;\\n\\t\\t\\tif(lastVisible < 0)\\n\\t\\t\\t\\tlastVisible = 0;\\n\\t\\t\\tlastVisible = getScreenLineEndOffset(lastVisible) - 1;\\n\\t\\t\\tif(lastVisible == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlastVisible = getLineEndOffset(displayManager\\n\\t\\t\\t\\t\\t.getLastVisibleLine()) - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,lastVisible);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(lastVisible);\\n\\t} \\n\\tpublic void goToBufferStart(boolean select)\\n\\t{\\n\\t\\tint start = buffer.getLineStartOffset(\\n\\t\\t\\tdisplayManager.getFirstVisibleLine());\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,start);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(start);\\n\\t} \\n\\tpublic void goToBufferEnd(boolean select)\\n\\t{\\n\\t\\tint end = buffer.getLineEndOffset(\\n\\t\\t\\tdisplayManager.getLastVisibleLine()) - 1;\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,end);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(end);\\n\\t} \\n\\tpublic void goToMatchingBracket()\\n\\t{\\n\\t\\tif(getLineLength(caretLine) != 0)\\n\\t\\t{\\n\\t\\t\\tint dot = caret - getLineStartOffset(caretLine);\\n\\t\\t\\tint bracket = TextUtilities.findMatchingBracket(\\n\\t\\t\\t\\tbuffer,caretLine,Math.max(0,dot - 1));\\n\\t\\t\\tif(bracket != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\t\\tmoveCaretPosition(bracket + 1,false);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tgetToolkit().beep();\\n\\t} \\n\\tpublic void showGoToLineDialog()\\n\\t{\\n\\t\\tString line = GUIUtilities.input(view,\\\"goto-line\\\",null);\\n\\t\\tif(line == null)\\n\\t\\t\\treturn;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tint lineNumber = Integer.parseInt(line) - 1;\\n\\t\\t\\tsetCaretPosition(getLineStartOffset(lineNumber));\\n\\t\\t}\\n\\t\\tcatch(Exception e)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t}\\n\\t} \\n\\tpublic void userInput(char ch)\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(ch == ' ' && Abbrevs.getExpandOnInput()\\n\\t\\t\\t&& Abbrevs.expandAbbrev(view,false))\\n\\t\\t\\treturn;\\n\\t\\tif(ch == '\\\\t')\\n\\t\\t{\\n\\t\\t\\tuserInputTab();\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tString indentOpenBrackets = (String)buffer\\n\\t\\t\\t\\t.getProperty(\\\"indentOpenBrackets\\\");\\n\\t\\t\\tString indentCloseBrackets = (String)buffer\\n\\t\\t\\t\\t.getProperty(\\\"indentCloseBrackets\\\");\\n\\t\\t\\tboolean indent = ((indentCloseBrackets != null\\n\\t\\t\\t\\t&& indentCloseBrackets.indexOf(ch) != -1)\\n\\t\\t\\t\\t|| (indentOpenBrackets != null\\n\\t\\t\\t\\t&& indentOpenBrackets.indexOf(ch) != -1));\\n\\t\\t\\tString str = String.valueOf(ch);\\n\\t\\t\\tif(getSelectionCount() == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(ch == ' ')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!doWordWrap(true))\\n\\t\\t\\t\\t\\t\\tinsert(str,indent);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdoWordWrap(false);\\n\\t\\t\\t\\t\\tinsert(str,indent);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\treplaceSelection(str);\\n\\t\\t}\\n\\t} \\n\\tpublic final boolean isOverwriteEnabled()\\n\\t{\\n\\t\\treturn overwrite;\\n\\t} \\n\\tpublic final void setOverwriteEnabled(boolean overwrite)\\n\\t{\\n\\t\\tblink = true;\\n\\t\\tcaretTimer.restart();\\n\\t\\tthis.overwrite = overwrite;\\n\\t\\tinvalidateLine(caretLine);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t\\tview.getStatus().updateMiscStatus();\\n\\t} \\n\\tpublic final void toggleOverwriteEnabled()\\n\\t{\\n\\t\\tsetOverwriteEnabled(!overwrite);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t{\\n\\t\\t\\tview.getStatus().setMessageAndClear(\\n\\t\\t\\t\\tjEdit.getProperty(\\\"view.status.overwrite-changed\\\",\\n\\t\\t\\t\\tnew Integer[] { new Integer(overwrite ? 1 : 0) }));\\n\\t\\t}\\n\\t} \\n\\tpublic void backspace()\\n\\t{\\n\\t\\tdelete(false);\\n\\t} \\n\\tpublic void backspaceWord()\\n\\t{\\n\\t\\tbackspaceWord(false);\\n\\t} \\n\\tpublic void backspaceWord(boolean eatWhitespace)\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(getSelectionCount() != 0)\\n\\t\\t{\\n\\t\\t\\tsetSelectedText(\\\"\\\");\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint _caret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(_caret == 0)\\n\\t\\t{\\n\\t\\t\\tif(lineStart == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t_caret--;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\t_caret = TextUtilities.findWordStart(lineText,_caret-1,\\n\\t\\t\\t\\tnoWordSep,true,eatWhitespace);\\n\\t\\t}\\n\\t\\tbuffer.remove(_caret + lineStart,\\n\\t\\t\\tcaret - (_caret + lineStart));\\n\\t} \\n\\tpublic void delete()\\n\\t{\\n\\t\\tdelete(true);\\n\\t} \\n\\tpublic void deleteToEndOfLine()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.remove(caret,getLineEndOffset(caretLine)\\n\\t\\t\\t- caret - 1);\\n\\t} \\n\\tpublic void deleteLine()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine);\\n\\t\\tint x = chunkCache.subregionOffsetToX(caretLine,caret - start);\\n\\t\\t\\t\\t\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tif(end > buffer.getLength())\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(start != 0)\\n\\t\\t\\t\\t\\tstart--;\\n\\t\\t\\t\\tend--;\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tbuffer.remove(start,end - start);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\tint lastLine = displayManager.getLastVisibleLine();\\n\\t\\tif(caretLine == lastLine)\\n\\t\\t{\\n\\t\\t\\tint offset = chunkCache.xToSubregionOffset(lastLine,0,x,true);\\n\\t\\t\\tsetCaretPosition(buffer.getLineStartOffset(lastLine)\\n\\t\\t\\t\\t+ offset);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint offset = chunkCache.xToSubregionOffset(caretLine,0,x,true);\\n\\t\\t\\tsetCaretPosition(start + offset);\\n\\t\\t}\\n\\t} \\n\\tpublic void deleteParagraph()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint start = 0, end = buffer.getLength();\\nloop:\\t\\tfor(int i = caretLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tstart = getLineStartOffset(i);\\n\\t\\t\\tbreak loop;\\n\\t\\t}\\nloop:\\t\\tfor(int i = caretLine + 1; i < getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tend = getLineEndOffset(i) - 1;\\n\\t\\t\\tbreak loop;\\n\\t\\t}\\n\\t\\tbuffer.remove(start,end - start);\\n\\t} \\n\\tpublic void deleteToStartOfLine()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.remove(getLineStartOffset(caretLine),\\n\\t\\t\\tcaret - getLineStartOffset(caretLine));\\n\\t} \\n\\tpublic void deleteWord()\\n\\t{\\n\\t\\tdeleteWord(false);\\n\\t} \\n\\tpublic void deleteWord(boolean eatWhitespace)\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(getSelectionCount() != 0)\\n\\t\\t{\\n\\t\\t\\tsetSelectedText(\\\"\\\");\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\tint _caret = caret - lineStart;\\n\\t\\tString lineText = getLineText(caretLine);\\n\\t\\tif(_caret == lineText.length())\\n\\t\\t{\\n\\t\\t\\tif(lineStart + _caret == buffer.getLength())\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t_caret++;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tString noWordSep = buffer.getStringProperty(\\\"noWordSep\\\");\\n\\t\\t\\t_caret = TextUtilities.findWordEnd(lineText,\\n\\t\\t\\t\\t_caret+1,noWordSep,true,eatWhitespace);\\n\\t\\t}\\n\\t\\tbuffer.remove(caret,(_caret + lineStart) - caret);\\n\\t} \\n\\tpublic final boolean isMultipleSelectionEnabled()\\n\\t{\\n\\t\\treturn multi;\\n\\t} \\n\\tpublic final void toggleMultipleSelectionEnabled()\\n\\t{\\n\\t\\tsetMultipleSelectionEnabled(!multi);\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t{\\n\\t\\t\\tview.getStatus().setMessageAndClear(\\n\\t\\t\\t\\tjEdit.getProperty(\\\"view.status.multi-changed\\\",\\n\\t\\t\\t\\tnew Integer[] { new Integer(multi ? 1 : 0) }));\\n\\t\\t}\\n\\t} \\n\\tpublic final void setMultipleSelectionEnabled(boolean multi)\\n\\t{\\n\\t\\tthis.multi = multi;\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t\\tview.getStatus().updateMiscStatus();\\n\\t\\tpainter.repaint();\\n\\t} \\n\\tpublic final boolean isRectangularSelectionEnabled()\\n\\t{\\n\\t\\treturn rectangularSelectionMode;\\n\\t} \\n\\tpublic final void toggleRectangularSelectionEnabled()\\n\\t{\\n\\t\\tsetRectangularSelectionEnabled(!rectangularSelectionMode);\\n\\t\\tif(getSelectionCount() == 1)\\n\\t\\t{\\n\\t\\t\\tSelection s = getSelection(0);\\n\\t\\t\\tremoveFromSelection(s);\\n\\t\\t\\tif(rectangularSelectionMode)\\n\\t\\t\\t{\\n\\t\\t\\t\\taddToSelection(new Selection.Rect(\\n\\t\\t\\t\\t\\ts.getStart(),s.getEnd()));\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\taddToSelection(new Selection.Range(\\n\\t\\t\\t\\t\\ts.getStart(),s.getEnd()));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t{\\n\\t\\t\\tview.getStatus().setMessageAndClear(\\n\\t\\t\\t\\tjEdit.getProperty(\\\"view.status.rect-select-changed\\\",\\n\\t\\t\\t\\tnew Integer[] { new Integer(rectangularSelectionMode ? 1 : 0) }));\\n\\t\\t}\\n\\t} \\n\\tpublic final void setRectangularSelectionEnabled(\\n\\t\\tboolean rectangularSelectionMode)\\n\\t{\\n\\t\\tthis.rectangularSelectionMode = rectangularSelectionMode;\\n\\t\\tif(view.getStatus() != null)\\n\\t\\t\\tview.getStatus().updateMiscStatus();\\n\\t\\tpainter.repaint();\\n\\t} \\n\\tpublic void goToMarker(char shortcut, boolean select)\\n\\t{\\n\\t\\tMarker marker = buffer.getMarker(shortcut);\\n\\t\\tif(marker == null)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint pos = marker.getPosition();\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,pos);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(pos);\\n\\t} \\n\\tpublic void addMarker()\\n\\t{\\n\\t\\t\\t\\tSelection[] selection = getSelection();\\n\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\tif(s.startLine != s.endLine)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s.startLine != caretLine)\\n\\t\\t\\t\\t\\tbuffer.addMarker('\\\\0',s.start);\\n\\t\\t\\t}\\n\\t\\t\\tif(s.endLine != caretLine)\\n\\t\\t\\t\\tbuffer.addMarker('\\\\0',s.end);\\n\\t\\t}\\n\\t\\t\\t\\tbuffer.addOrRemoveMarker('\\\\0',caret);\\n\\t} \\n\\tpublic void swapMarkerAndCaret(char shortcut)\\n\\t{\\n\\t\\tMarker marker = buffer.getMarker(shortcut);\\n\\t\\tif(marker == null)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint caret = getCaretPosition();\\n\\t\\tsetCaretPosition(marker.getPosition());\\n\\t\\tbuffer.addMarker(shortcut,caret);\\n\\t} \\n\\tpublic void goToParentFold()\\n\\t{\\n\\t\\tint line = -1;\\n\\t\\tint level = buffer.getFoldLevel(caretLine);\\n\\t\\tfor(int i = caretLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(buffer.getFoldLevel(i) < level)\\n\\t\\t\\t{\\n\\t\\t\\t\\tline = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(line == -1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = buffer.getLineStartOffset(line)\\n\\t\\t\\t+ chunkCache.xToSubregionOffset(line,0,magic + 1,true);\\n\\t\\tif(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToNextFold(boolean select)\\n\\t{\\n\\t\\tint nextFold = -1;\\n\\t\\tfor(int i = caretLine + 1; i < buffer.getLineCount(); i++)\\n\\t\\t{\\n\\t\\t\\tif(buffer.isFoldStart(i)\\n\\t\\t\\t\\t&& displayManager.isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\tnextFold = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(nextFold == -1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = buffer.getLineStartOffset(nextFold)\\n\\t\\t\\t+ chunkCache.xToSubregionOffset(nextFold,0,magic + 1,true);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void goToPrevFold(boolean select)\\n\\t{\\n\\t\\tint prevFold = -1;\\n\\t\\tfor(int i = caretLine - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(buffer.isFoldStart(i)\\n\\t\\t\\t\\t&& displayManager.isLineVisible(i))\\n\\t\\t\\t{\\n\\t\\t\\t\\tprevFold = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(prevFold == -1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint magic = getMagicCaretPosition();\\n\\t\\tint newCaret = buffer.getLineStartOffset(prevFold)\\n\\t\\t\\t+ chunkCache.xToSubregionOffset(prevFold,0,magic + 1,true);\\n\\t\\tif(select)\\n\\t\\t\\textendSelection(caret,newCaret);\\n\\t\\telse if(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t\\tsetMagicCaretPosition(magic);\\n\\t} \\n\\tpublic void collapseFold()\\n\\t{\\n\\t\\tint x = chunkCache.subregionOffsetToX(caretLine,\\n\\t\\t\\tcaret - getLineStartOffset(caretLine));\\n\\t\\tdisplayManager.collapseFold(caretLine);\\n\\t\\tif(displayManager.isLineVisible(caretLine))\\n\\t\\t\\treturn;\\n\\t\\tint line = displayManager.getPrevVisibleLine(caretLine);\\n\\t\\tif(!multi)\\n\\t\\t\\tselectNone();\\n\\t\\tmoveCaretPosition(buffer.getLineStartOffset(line)\\n\\t\\t\\t+ chunkCache.xToSubregionOffset(line,0,x,true));\\n\\t} \\n\\tpublic void expandFold(boolean fully)\\n\\t{\\n\\t\\tint x = chunkCache.subregionOffsetToX(caretLine,\\n\\t\\t\\tcaret - getLineStartOffset(caretLine));\\n\\t\\tint line = displayManager.expandFold(caretLine,fully);\\n\\t\\tif(!fully && line != -1)\\n\\t\\t{\\n\\t\\t\\tif(!multi)\\n\\t\\t\\t\\tselectNone();\\n\\t\\t\\tmoveCaretPosition(getLineStartOffset(line)\\n\\t\\t\\t\\t+ chunkCache.xToSubregionOffset(line,0,x,true));\\n\\t\\t}\\n\\t} \\n\\tpublic void selectFold()\\n\\t{\\n\\t\\tselectFold(caretLine);\\n\\t} \\n\\tpublic void selectFold(int line)\\n\\t{\\n\\t\\tint[] lines = buffer.getFoldAtLine(line);\\n\\t\\tint newCaret = getLineEndOffset(lines[1]) - 1;\\n\\t\\tSelection s = new Selection.Range(getLineStartOffset(lines[0]),newCaret);\\n\\t\\tif(multi)\\n\\t\\t\\taddToSelection(s);\\n\\t\\telse\\n\\t\\t\\tsetSelection(s);\\n\\t\\tmoveCaretPosition(newCaret);\\n\\t} \\n\\tpublic void narrowToFold()\\n\\t{\\n\\t\\tint[] lines = buffer.getFoldAtLine(caretLine);\\n\\t\\tif(lines[0] == 0 && lines[1] == buffer.getLineCount() - 1)\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t\\tdisplayManager.narrow(lines[0],lines[1]);\\n\\t} \\n\\tpublic void narrowToSelection()\\n\\t{\\n\\t\\tif(getSelectionCount() != 1)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tSelection sel = getSelection(0);\\n\\t\\tdisplayManager.narrow(sel.getStartLine(),sel.getEndLine());\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic void addExplicitFold()\\n\\t{\\n\\t\\tif(!buffer.getStringProperty(\\\"folding\\\").equals(\\\"explicit\\\"))\\n\\t\\t{\\n\\t\\t\\tGUIUtilities.error(view,\\\"folding-not-explicit\\\",null);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tString lineComment = buffer.getContextSensitiveProperty(caret,\\\"lineComment\\\");\\n\\t\\tString commentStart = buffer.getContextSensitiveProperty(caret,\\\"commentStart\\\");\\n\\t\\tString commentEnd = buffer.getContextSensitiveProperty(caret,\\\"commentEnd\\\");\\n\\t\\tString start, end;\\n\\t\\tif(lineComment != null)\\n\\t\\t{\\n\\t\\t\\tstart = lineComment + \\\"{{{ \\\\n\\\";\\n\\t\\t\\tend = lineComment + \\\"}}}\\\";\\n\\t\\t}\\n\\t\\telse if(commentStart != null && commentEnd != null)\\n\\t\\t{\\n\\t\\t\\tstart = commentStart + \\\"{{{  \\\" + commentEnd + \\\"\\\\n\\\";\\n\\t\\t\\tend = commentStart + \\\"}}}\\\" + commentEnd;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstart = \\\"{{{ \\\\n\\\";\\n\\t\\t\\tend = \\\"}}}\\\";\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tif(getSelectionCount() == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tString line = buffer.getLineText(caretLine);\\n\\t\\t\\t\\tString whitespace = line.substring(0,\\n\\t\\t\\t\\t\\tMiscUtilities.getLeadingWhiteSpace(line));\\n\\t\\t\\t\\tint loc = caret + start.length() - 1;\\n\\t\\t\\t\\tstart = start + whitespace;\\n\\t\\t\\t\\tbuffer.insert(caret,start);\\n\\t\\t\\t\\t\\t\\t\\t\\tbuffer.insert(caret,end);\\n\\t\\t\\t\\tmoveCaretPosition(loc,false);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint loc = -1;\\n\\t\\t\\t\\tSelection[] sel = getSelection();\\n\\t\\t\\t\\tfor(int i = 0; i < sel.length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection s = sel[i];\\n\\t\\t\\t\\t\\tString line = buffer.getLineText(s.startLine);\\n\\t\\t\\t\\t\\tString whitespace = line.substring(0,\\n\\t\\t\\t\\t\\t\\tMiscUtilities.getLeadingWhiteSpace(line));\\n\\t\\t\\t\\t\\tloc = s.start + start.length() - 1;\\n\\t\\t\\t\\t\\tbuffer.insert(s.start,start + whitespace);\\n\\t\\t\\t\\t\\tif(s.end == buffer.getLineStartOffset(\\n\\t\\t\\t\\t\\t\\ts.endLine))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.insert(s.end,end);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.insert(s.end,\\\" \\\" + end);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsetCaretPosition(loc,false);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void lineComment()\\n\\t{\\n\\t\\tString comment = buffer.getContextSensitiveProperty(caret,\\\"lineComment\\\");\\n\\t\\tif(!buffer.isEditable() || comment == null || comment.length() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tcomment = comment + ' ';\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tint[] lines = getSelectedLines();\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < lines.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tString text = getLineText(lines[i]);\\n\\t\\t\\t\\tbuffer.insert(getLineStartOffset(lines[i])\\n\\t\\t\\t\\t\\t+ MiscUtilities.getLeadingWhiteSpace(text),\\n\\t\\t\\t\\t\\tcomment);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\tselectNone();\\n\\t} \\n\\tpublic void rangeComment()\\n\\t{\\n\\t\\tString commentStart = buffer.getContextSensitiveProperty(caret,\\\"commentStart\\\");\\n\\t\\tString commentEnd = buffer.getContextSensitiveProperty(caret,\\\"commentEnd\\\");\\n\\t\\tif(!buffer.isEditable() || commentStart == null || commentEnd == null\\n\\t\\t\\t|| commentStart.length() == 0 || commentEnd.length() == 0)\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tcommentStart = commentStart + ' ';\\n\\t\\tcommentEnd = ' ' + commentEnd;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tSelection[] selection = getSelection();\\n\\t\\t\\tif(selection.length == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint oldCaret = caret;\\n\\t\\t\\t\\tbuffer.insert(caret,commentStart);\\n\\t\\t\\t\\tbuffer.insert(caret,commentEnd);\\n\\t\\t\\t\\tsetCaretPosition(oldCaret + commentStart.length());\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tif(s instanceof Selection.Range)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbuffer.insert(s.start,commentStart);\\n\\t\\t\\t\\t\\tbuffer.insert(s.end,commentEnd);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(s instanceof Selection.Rect)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection.Rect rect = (Selection.Rect)s;\\n\\t\\t\\t\\t\\tint start = rect.getStartColumn(buffer);\\n\\t\\t\\t\\t\\tint end = rect.getEndColumn(buffer);\\n\\t\\t\\t\\t\\tfor(int j = s.startLine; j <= s.endLine; j++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbuffer.insertAtColumn(j,end,\\n\\t\\t\\t\\t\\t\\t\\tcommentEnd);\\n\\t\\t\\t\\t\\t\\tbuffer.insertAtColumn(j,start,\\n\\t\\t\\t\\t\\t\\t\\tcommentStart);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tselectNone();\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\tpublic void formatParagraph()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(maxLineLen <= 0)\\n\\t\\t{\\n\\t\\t\\tGUIUtilities.error(view,\\\"format-maxlinelen\\\",null);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(selection.length != 0)\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tsetSelectedText(s,TextUtilities.format(\\n\\t\\t\\t\\t\\tgetSelectedText(s),maxLineLen,\\n\\t\\t\\t\\t\\tbuffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint lineNo = getCaretLine();\\n\\t\\t\\tint start = 0, end = buffer.getLength();\\nloop:\\t\\t\\tfor(int i = lineNo - 1; i >= 0; i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstart = getLineEndOffset(i);\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\nloop:\\t\\t\\tfor(int i = lineNo + 1; i < getLineCount(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetLineText(i,lineSegment);\\n\\t\\t\\t\\tfor(int j = 0; j < lineSegment.count; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tswitch(lineSegment.array[lineSegment.offset + j])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\tcontinue loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tend = getLineStartOffset(i) - 1;\\n\\t\\t\\t\\tbreak loop;\\n\\t\\t\\t}\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tString text = buffer.getText(start,end - start);\\n\\t\\t\\t\\tbuffer.remove(start,end - start);\\n\\t\\t\\t\\tbuffer.insert(start,TextUtilities.format(\\n\\t\\t\\t\\t\\ttext,maxLineLen,buffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\tpublic void spacesToTabs()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tif(selection.length == 0)\\n\\t\\t{\\n\\t\\t\\tsetText(TextUtilities.spacesToTabs(\\n\\t\\t\\t\\tgetText(), buffer.getTabSize()));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tsetSelectedText(s,TextUtilities.spacesToTabs(\\n\\t\\t\\t\\t\\tgetSelectedText(s),buffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void tabsToSpaces()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tif(selection.length == 0)\\n\\t\\t{\\n\\t\\t\\tsetText(TextUtilities.tabsToSpaces(\\n\\t\\t\\t\\tgetText(), buffer.getTabSize()));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\t\\tsetSelectedText(s,TextUtilities.tabsToSpaces(\\n\\t\\t\\t\\t\\tgetSelectedText(s),buffer.getTabSize()));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void toUpperCase()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable() || selection.length == 0)\\n                {\\n                \\tgetToolkit().beep();\\n                \\treturn;\\n                }\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\tsetSelectedText(s,getSelectedText(s).toUpperCase());\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void toLowerCase()\\n\\t{\\n\\t\\tSelection[] selection = getSelection();\\n\\t\\tif(!buffer.isEditable() || selection.length == 0)\\n                {\\n                \\tgetToolkit().beep();\\n                \\treturn;\\n                }\\n\\t\\tbuffer.beginCompoundEdit();\\n\\t\\tfor(int i = 0; i < selection.length; i++)\\n\\t\\t{\\n\\t\\t\\tSelection s = selection[i];\\n\\t\\t\\tsetSelectedText(s,getSelectedText(s).toLowerCase());\\n\\t\\t}\\n\\t\\tbuffer.endCompoundEdit();\\n\\t} \\n\\tpublic void removeTrailingWhiteSpace()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbuffer.removeTrailingWhiteSpace(getSelectedLines());\\n\\t\\t}\\n\\t} \\n\\t\\tpublic void insertEnterAndIndent()\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ttry\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\t\\tsetSelectedText(\\\"\\\\n\\\");\\n\\t\\t\\t\\tbuffer.indentLine(caretLine,true);\\n\\t\\t\\t}\\n\\t\\t\\tfinally\\n\\t\\t\\t{\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tpublic void insertTabAndIndent()\\n\\t{\\n\\t\\tif(!isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(getSelectionCount() == 0)\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tString text = buffer.getLineText(caretLine);\\n\\t\\t\\tint start = buffer.getLineStartOffset(caretLine);\\n\\t\\t\\tint whiteSpace = MiscUtilities.getLeadingWhiteSpace(text);\\n\\t\\t\\tif(caret - start <= whiteSpace\\n\\t\\t\\t\\t&& buffer.indentLine(caretLine,false))\\n\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tuserInput('\\\\t');\\n\\t} \\n\\tpublic void indentSelectedLines()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbuffer.indentLines(getSelectedLines());\\n\\t\\t\\tselectNone();\\n\\t\\t}\\n\\t} \\n\\tpublic void shiftIndentLeft()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tbuffer.shiftIndentLeft(getSelectedLines());\\n\\t\\t}\\n\\t} \\n\\tpublic void shiftIndentRight()\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\telse\\n\\t\\t\\tbuffer.shiftIndentRight(getSelectedLines());\\n\\t} \\n\\tpublic void joinLines()\\n\\t{\\n\\t\\tint end = getLineEndOffset(caretLine);\\n\\t\\tif(!buffer.isEditable() || end > buffer.getLength())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tbuffer.remove(\\n\\t\\t\\t\\tend - 1,MiscUtilities.getLeadingWhiteSpace(\\n\\t\\t\\t\\tbuffer.getLineText(caretLine + 1)) + 1);\\n\\t\\t\\tbuffer.insert(end - 1, \\\" \\\");\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\tsetCaretPosition(end - 1);\\n\\t} \\n\\tpublic void showWordCountDialog()\\n\\t{\\n\\t\\tString selection = getSelectedText();\\n\\t\\tif(selection != null)\\n\\t\\t{\\n\\t\\t\\tdoWordCount(view,selection);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tdoWordCount(view,buffer.getText(0,buffer.getLength()));\\n\\t} \\n\\tpublic boolean isRightClickPopupEnabled()\\n\\t{\\n\\t\\treturn popupEnabled;\\n\\t} \\n\\tpublic void setRightClickPopupEnabled(boolean popupEnabled)\\n\\t{\\n\\t\\tthis.popupEnabled = popupEnabled;\\n\\t} \\n\\tpublic final JPopupMenu getRightClickPopup()\\n\\t{\\n\\t\\treturn popup;\\n\\t} \\n\\tpublic final void setRightClickPopup(JPopupMenu popup)\\n\\t{\\n\\t\\tthis.popup = popup;\\n\\t} \\n\\tpublic void handlePopupTrigger(MouseEvent evt)\\n\\t{\\n\\t\\tif(popup.isVisible())\\n\\t\\t\\tpopup.setVisible(false);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint x = evt.getX();\\n\\t\\t\\tint y = evt.getY();\\n\\t\\t\\tint dragStart = xyToOffset(x,y,\\n\\t\\t\\t\\t!(painter.isBlockCaretEnabled()\\n\\t\\t\\t\\t|| isOverwriteEnabled()));\\n\\t\\t\\tif(getSelectionCount() == 0 || multi)\\n\\t\\t\\t\\tmoveCaretPosition(dragStart,false);\\n\\t\\t\\tGUIUtilities.showPopupMenu(popup,painter,x,y);\\n\\t\\t}\\n\\t} \\n\\tpublic void addLeftOfScrollBar(Component comp)\\n\\t{\\n\\t\\tverticalBox.add(comp,verticalBox.getComponentCount() - 1);\\n\\t} \\n\\tpublic void removeLeftOfScrollBar(Component comp)\\n\\t{\\n\\t\\tverticalBox.remove(comp);\\n\\t} \\n\\tpublic void addNotify()\\n\\t{\\n\\t\\tsuper.addNotify();\\n\\t\\tToolTipManager.sharedInstance().registerComponent(painter);\\n\\t\\tToolTipManager.sharedInstance().registerComponent(gutter);\\n\\t\\trecalculateVisibleLines();\\n\\t\\tif(buffer.isLoaded())\\n\\t\\t\\trecalculateLastPhysicalLine();\\n\\t\\tpropertiesChanged();\\n\\t} \\n\\tpublic void removeNotify()\\n\\t{\\n\\t\\tsuper.removeNotify();\\n\\t\\tToolTipManager.sharedInstance().unregisterComponent(painter);\\n\\t\\tToolTipManager.sharedInstance().unregisterComponent(gutter);\\n\\t\\tif(focusedComponent == this)\\n\\t\\t\\tfocusedComponent = null;\\n\\t} \\n\\tpublic boolean getFocusTraversalKeysEnabled()\\n\\t{\\n\\t\\treturn false;\\n\\t} \\n\\tpublic boolean getFocusCycleRoot()\\n\\t{\\n\\t\\treturn true;\\n\\t} \\n\\t\\tpublic void processKeyEvent(KeyEvent evt)\\n\\t{\\n\\t\\tview.processKeyEvent(evt,View.TEXT_AREA);\\n\\t\\tif(!evt.isConsumed())\\n\\t\\t\\tsuper.processKeyEvent(evt);\\n\\t} \\n\\tpublic void addTopComponent(Component comp)\\n\\t{\\n\\t\\tadd(ScrollLayout.TOP,comp);\\n\\t} \\n\\tpublic void removeTopComponent(Component comp)\\n\\t{\\n\\t\\tremove(comp);\\n\\t} \\n\\tpublic void propertiesChanged()\\n\\t{\\n\\t\\tif(buffer == null)\\n\\t\\t\\treturn;\\n\\t\\tint _tabSize = buffer.getTabSize();\\n\\t\\tchar[] foo = new char[_tabSize];\\n\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t\\tfoo[i] = ' ';\\n\\t\\ttabSize = (float)painter.getStringWidth(new String(foo));\\n\\t\\tcharWidth = (int)Math.round(\\n\\t\\t\\tpainter.getFont().getStringBounds(foo,0,1,\\n\\t\\t\\tpainter.getFontRenderContext()).getWidth());\\n\\t\\tboolean invalidateScreenLineCounts = false;\\n\\t\\tint oldWrapMargin = wrapMargin;\\n\\t\\twrap = buffer.getStringProperty(\\\"wrap\\\");\\n\\t\\thardWrap = wrap.equals(\\\"hard\\\");\\n\\t\\tsoftWrap = wrap.equals(\\\"soft\\\");\\n\\t\\tsetMaxLineLength(buffer.getIntegerProperty(\\\"maxLineLen\\\",0));\\n\\t\\tif(oldWrapMargin != wrapMargin || !wrap.equals(this.wrap))\\n\\t\\t{\\n\\t\\t\\tif(displayManager != null && !bufferChanging)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdisplayManager.firstLine.callReset = true;\\n\\t\\t\\t\\tdisplayManager.scrollLineCount.callReset = true;\\n\\t\\t\\t}\\n\\t\\t\\tinvalidateScreenLineCounts = true;\\n\\t\\t}\\n\\t\\tif(invalidateScreenLineCounts && displayManager != null\\n\\t\\t\\t&& buffer.isLoaded())\\n\\t\\t\\tdisplayManager.invalidateScreenLineCounts();\\n\\t\\tchunkCache.invalidateAll();\\n\\t\\tif(displayManager != null && !bufferChanging\\n\\t\\t\\t&& buffer.isLoaded())\\n\\t\\t\\tdisplayManager.notifyScreenLineChanges();\\n\\t\\tgutter.repaint();\\n\\t\\tpainter.repaint();\\n\\t} \\n\\tpublic final int getSelectionStart()\\n\\t{\\n\\t\\tif(getSelectionCount() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn getSelection(0).getStart();\\n\\t} \\n\\tpublic int getSelectionStart(int line)\\n\\t{\\n\\t\\tif(getSelectionCount() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn getSelection(0).getStart(buffer,line);\\n\\t} \\n\\tpublic final int getSelectionStartLine()\\n\\t{\\n\\t\\tif(getSelectionCount() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn getSelection(0).getStartLine();\\n\\t} \\n\\tpublic final void setSelectionStart(int selectionStart)\\n\\t{\\n\\t\\tselect(selectionStart,getSelectionEnd(),true);\\n\\t} \\n\\tpublic final int getSelectionEnd()\\n\\t{\\n\\t\\tif(getSelectionCount() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn getSelection(0).getEnd();\\n\\t} \\n\\tpublic int getSelectionEnd(int line)\\n\\t{\\n\\t\\tif(getSelectionCount() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn getSelection(0).getEnd(buffer,line);\\n\\t} \\n\\tpublic final int getSelectionEndLine()\\n\\t{\\n\\t\\tif(getSelectionCount() != 1)\\n\\t\\t\\treturn caret;\\n\\t\\treturn getSelection(0).getEndLine();\\n\\t} \\n\\tpublic final void setSelectionEnd(int selectionEnd)\\n\\t{\\n\\t\\tselect(getSelectionStart(),selectionEnd,true);\\n\\t} \\n\\tpublic final int getMarkPosition()\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(s == null)\\n\\t\\t\\treturn caret;\\n\\t\\tif(s.start == caret)\\n\\t\\t\\treturn s.end;\\n\\t\\telse if(s.end == caret)\\n\\t\\t\\treturn s.start;\\n\\t\\telse\\n\\t\\t\\treturn caret;\\n\\t} \\n\\tpublic final int getMarkLine()\\n\\t{\\n\\t\\tif(getSelectionCount() != 1)\\n\\t\\t\\treturn caretLine;\\n\\t\\tSelection s = getSelection(0);\\n\\t\\tif(s.start == caret)\\n\\t\\t\\treturn s.endLine;\\n\\t\\telse if(s.end == caret)\\n\\t\\t\\treturn s.startLine;\\n\\t\\telse\\n\\t\\t\\treturn caretLine;\\n\\t} \\n\\tpublic void select(int start, int end)\\n\\t{\\n\\t\\tselect(start,end,true);\\n\\t} \\n\\tpublic void select(int start, int end, boolean doElectricScroll)\\n\\t{\\n\\t\\tselectNone();\\n\\t\\tint newStart, newEnd;\\n\\t\\tif(start < end)\\n\\t\\t{\\n\\t\\t\\tnewStart = start;\\n\\t\\t\\tnewEnd = end;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tnewStart = end;\\n\\t\\t\\tnewEnd = start;\\n\\t\\t}\\n\\t\\tsetSelection(new Selection.Range(newStart,newEnd));\\n\\t\\tmoveCaretPosition(end,doElectricScroll);\\n\\t} \\n\\tpublic boolean isSelectionRectangular()\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tif(s == null)\\n\\t\\t\\treturn false;\\n\\t\\telse\\n\\t\\t\\treturn (s instanceof Selection.Rect);\\n\\t} \\n\\tstatic JEditTextArea focusedComponent;\\n\\t\\tSegment lineSegment;\\n\\tMouseHandler mouseHandler;\\n\\tChunkCache chunkCache;\\n\\tDisplayManager displayManager;\\n\\tSelectionManager selectionManager;\\n\\tboolean bufferChanging;\\n\\tint maxHorizontalScrollWidth;\\n\\tString wrap;\\n\\tboolean hardWrap;\\n\\tboolean softWrap;\\n\\tboolean wrapToWidth;\\n\\tint maxLineLen;\\n\\tint wrapMargin;\\n\\tfloat tabSize;\\n\\tint charWidth;\\n\\tboolean scrollBarsInitialized;\\n\\t\\tPoint returnValue;\\n\\tboolean lastLinePartial;\\n\\tboolean blink;\\n\\tfinal boolean isCaretVisible()\\n\\t{\\n\\t\\treturn blink && hasFocus();\\n\\t} \\n\\tfinal boolean isStructureHighlightVisible()\\n\\t{\\n\\t\\treturn match != null\\n\\t\\t\\t&& hasFocus()\\n\\t\\t\\t&& displayManager.isLineVisible(match.startLine)\\n\\t\\t\\t&& displayManager.isLineVisible(match.endLine);\\n\\t} \\n\\t\\tvoid updateMaxHorizontalScrollWidth()\\n\\t{\\n\\t\\tint max = chunkCache.getMaxHorizontalScrollWidth();\\n\\t\\tif(max != maxHorizontalScrollWidth)\\n\\t\\t{\\n\\t\\t\\tmaxHorizontalScrollWidth = max;\\n\\t\\t\\thorizontal.setValues(Math.max(0,\\n\\t\\t\\t\\tMath.min(maxHorizontalScrollWidth + charWidth\\n\\t\\t\\t\\t- painter.getWidth(),\\n\\t\\t\\t\\t-horizontalOffset)),\\n\\t\\t\\t\\tpainter.getWidth(),\\n\\t\\t\\t\\t0,maxHorizontalScrollWidth\\n\\t\\t\\t\\t+ charWidth);\\n\\t\\t}\\n\\t} \\n\\t\\tvoid recalculateVisibleLines()\\n\\t{\\n\\t\\tif(painter == null)\\n\\t\\t\\treturn;\\n\\t\\tint height = painter.getHeight();\\n\\t\\tint lineHeight = painter.getFontMetrics().getHeight();\\n\\t\\tif(lineHeight == 0)\\n\\t\\t\\tvisibleLines = 0;\\n\\t\\telse if(height <= 0)\\n\\t\\t{\\n\\t\\t\\tvisibleLines = 0;\\n\\t\\t\\tlastLinePartial = false;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tvisibleLines = height / lineHeight;\\n\\t\\t\\tlastLinePartial = (height % lineHeight != 0);\\n\\t\\t\\tif(lastLinePartial)\\n\\t\\t\\t\\tvisibleLines++;\\n\\t\\t}\\n\\t\\tchunkCache.recalculateVisibleLines();\\n\\t\\t\\t\\tif(displayManager != null && buffer != null && buffer.isLoaded())\\n\\t\\t\\tsetFirstLine(getFirstLine());\\n\\t\\tupdateScrollBars();\\n\\t} \\n\\t\\tvoid foldStructureChanged()\\n\\t{\\n\\t\\tchunkCache.invalidateAll();\\n\\t\\trecalculateLastPhysicalLine();\\n\\t\\trepaint();\\n\\t} \\n\\tvoid updateScrollBars()\\n\\t{\\n\\t\\tif(buffer == null)\\n\\t\\t\\treturn;\\n\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\tLog.log(Log.DEBUG,this,\\\"updateScrollBars(), slc=\\\"\\n\\t\\t\\t\\t+ displayManager.getScrollLineCount());\\n\\t\\tif(vertical != null && visibleLines != 0)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"Vertical ok\\\");\\n\\t\\t\\tint lineCount = displayManager.getScrollLineCount();\\n\\t\\t\\tint firstLine = getFirstLine();\\n\\t\\t\\tint visible = visibleLines - (lastLinePartial ? 1 : 0);\\n\\t\\t\\tvertical.setValues(firstLine,visible,0,lineCount);\\n\\t\\t\\tvertical.setUnitIncrement(2);\\n\\t\\t\\tvertical.setBlockIncrement(visible);\\n\\t\\t}\\n\\t\\tint width = painter.getWidth();\\n\\t\\tif(horizontal != null && width != 0)\\n\\t\\t{\\n\\t\\t\\tif(Debug.SCROLL_DEBUG)\\n\\t\\t\\t\\tLog.log(Log.DEBUG,this,\\\"Horizontal ok\\\");\\n\\t\\t\\tpainter.repaint();\\n\\t\\t\\thorizontal.setValue(-horizontalOffset);\\n\\t\\t\\thorizontal.setUnitIncrement(painter.getFontMetrics()\\n\\t\\t\\t\\t.charWidth('w'));\\n\\t\\t\\thorizontal.setBlockIncrement(width / 2);\\n\\t\\t}\\n\\t} \\n\\tvoid _finishCaretUpdate()\\n\\t{\\n\\t\\tif(!queuedCaretUpdate)\\n\\t\\t\\treturn;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tif(match != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(oldCaretLine < match.startLine)\\n\\t\\t\\t\\t\\tinvalidateLineRange(oldCaretLine,match.endLine);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tinvalidateLineRange(match.startLine,oldCaretLine);\\n\\t\\t\\t\\tmatch = null;\\n\\t\\t\\t}\\n\\t\\t\\tint newCaretScreenLine = chunkCache.getScreenLineOfOffset(caretLine,\\n\\t\\t\\t\\tcaret - buffer.getLineStartOffset(caretLine));\\n\\t\\t\\tif(caretScreenLine == -1)\\n\\t\\t\\t\\tinvalidateScreenLineRange(newCaretScreenLine,newCaretScreenLine);\\n\\t\\t\\telse\\n\\t\\t\\t\\tinvalidateScreenLineRange(caretScreenLine,newCaretScreenLine);\\n\\t\\t\\tcaretScreenLine = newCaretScreenLine;\\n\\t\\t\\tinvalidateSelectedLines();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tblink = true;\\n\\t\\t\\tcaretTimer.restart();\\n\\t\\t\\tif(!displayManager.isLineVisible(caretLine))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caretLine < displayManager.getFirstVisibleLine()\\n\\t\\t\\t\\t\\t|| caretLine > displayManager.getLastVisibleLine())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint collapseFolds = buffer.getIntegerProperty(\\n\\t\\t\\t\\t\\t\\t\\\"collapseFolds\\\",0);\\n\\t\\t\\t\\t\\tif(collapseFolds != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdisplayManager.expandFolds(collapseFolds);\\n\\t\\t\\t\\t\\t\\tdisplayManager.expandFold(caretLine,false);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tdisplayManager.expandAllFolds();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tdisplayManager.expandFold(caretLine,false);\\n\\t\\t\\t}\\n\\t\\t\\tif(queuedScrollMode == ELECTRIC_SCROLL)\\n\\t\\t\\t\\tscrollToCaret(true);\\n\\t\\t\\telse if(queuedScrollMode == NORMAL_SCROLL)\\n\\t\\t\\t\\tscrollToCaret(false);\\n\\t\\t\\tupdateBracketHighlightWithDelay();\\n\\t\\t\\tif(queuedFireCaretEvent)\\n\\t\\t\\t\\tfireCaretEvent();\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tqueuedCaretUpdate = queuedFireCaretEvent = false;\\n\\t\\t\\tqueuedScrollMode = NO_SCROLL;\\n\\t\\t}\\n\\t} \\n\\t\\tvoid invalidateStructureMatch()\\n\\t{\\n\\t\\tif(match != null)\\n\\t\\t\\tinvalidateLineRange(match.startLine,match.endLine);\\n\\t} \\n\\t\\tvoid startDragAndDrop(InputEvent evt, boolean copy)\\n\\t{\\n\\t\\tLog.log(Log.DEBUG,this,\\\"Drag and drop callback\\\");\\n\\t\\tgetTransferHandler().exportAsDrag(this,evt,\\n\\t\\t\\tcopy ? TransferHandler.COPY\\n\\t\\t\\t: TransferHandler.MOVE);\\n\\t} \\n\\t\\tprivate static Timer caretTimer;\\n\\tprivate static Timer structureTimer;\\n\\t\\tprivate View view;\\n\\tprivate Gutter gutter;\\n\\tprivate TextAreaPainter painter;\\n\\tprivate JPopupMenu popup;\\n\\tprivate boolean popupEnabled;\\n\\tprivate EventListenerList listenerList;\\n\\tprivate MutableCaretEvent caretEvent;\\n\\tprivate boolean caretBlinks;\\n\\tprivate int physLastLine;\\n\\tprivate int screenLastLine;\\n\\tprivate int visibleLines;\\n\\tprivate int electricScroll;\\n\\tprivate int horizontalOffset;\\n\\tprivate boolean quickCopy;\\n\\t\\tprivate Box verticalBox;\\n\\tprivate JScrollBar vertical;\\n\\tprivate JScrollBar horizontal;\\n\\tprivate Buffer buffer;\\n\\tprivate int caret;\\n\\tprivate int caretLine;\\n\\tprivate int caretScreenLine;\\n\\tprivate List structureMatchers;\\n\\tprivate StructureMatcher.Match match;\\n\\tprivate int magicCaret;\\n\\tprivate boolean multi;\\n\\tprivate boolean overwrite;\\n\\tprivate boolean rectangularSelectionMode;\\n\\tprivate boolean dndEnabled;\\n\\tprivate boolean dndInProgress;\\n\\t\\tprivate boolean queuedCaretUpdate;\\n\\tprivate int queuedScrollMode;\\n\\tprivate boolean queuedFireCaretEvent;\\n\\tprivate int oldCaretLine;\\n\\tprivate void invalidateSelectedLines()\\n\\t{\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\tIterator iter = selectionManager.selection.iterator();\\n\\t\\twhile(iter.hasNext())\\n\\t\\t{\\n\\t\\t\\tSelection s = (Selection)iter.next();\\n\\t\\t\\tinvalidateLineRange(s.startLine,s.endLine);\\n\\t\\t}\\n\\t} \\n\\tprivate void finishCaretUpdate(int oldCaretLine,\\n\\t\\tint scrollMode, boolean fireCaretEvent)\\n\\t{\\n\\t\\tthis.queuedFireCaretEvent |= fireCaretEvent;\\n\\t\\tthis.queuedScrollMode = Math.max(scrollMode,queuedScrollMode);\\n\\t\\tif(queuedCaretUpdate)\\n\\t\\t\\treturn;\\n\\t\\tthis.oldCaretLine = oldCaretLine;\\n\\t\\tqueuedCaretUpdate = true;\\n\\t\\tif(!buffer.isTransactionInProgress())\\n\\t\\t\\t_finishCaretUpdate();\\n\\t} \\n\\t\\tprivate void fireCaretEvent()\\n\\t{\\n\\t\\tObject[] listeners = listenerList.getListenerList();\\n\\t\\tfor(int i = listeners.length - 2; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(listeners[i] == CaretListener.class)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t((CaretListener)listeners[i+1]).caretUpdate(caretEvent);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void fireScrollEvent(boolean vertical)\\n\\t{\\n\\t\\tObject[] listeners = listenerList.getListenerList();\\n\\t\\tfor(int i = listeners.length - 2; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(listeners[i] == ScrollListener.class)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttry\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(vertical)\\n\\t\\t\\t\\t\\t\\t((ScrollListener)listeners[i+1]).scrolledVertically(this);\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t((ScrollListener)listeners[i+1]).scrolledHorizontally(this);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch(Throwable t)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tLog.log(Log.ERROR,this,t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void insert(String str, boolean indent)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(overwrite || indent)\\n\\t\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tif(overwrite)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint caretLineEnd = getLineEndOffset(caretLine);\\n\\t\\t\\t\\tif(caretLineEnd - caret > 1)\\n\\t\\t\\t\\t\\tbuffer.remove(caret,1);\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.insert(caret,str);\\n\\t\\t\\tif(indent)\\n\\t\\t\\t\\tbuffer.indentLine(caretLine,true);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tif(overwrite || indent)\\n\\t\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void insertTab()\\n\\t{\\n\\t\\tint tabSize = buffer.getTabSize();\\n\\t\\tif(buffer.getBooleanProperty(\\\"noTabs\\\"))\\n\\t\\t{\\n\\t\\t\\tint lineStart = getLineStartOffset(caretLine);\\n\\t\\t\\tString line = getText(lineStart,caret - lineStart);\\n\\t\\t\\tint pos = 0;\\n\\t\\t\\tfor(int i = 0; i < line.length(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswitch(line.charAt(pos))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tpos = 0;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif(++pos >= tabSize)\\n\\t\\t\\t\\t\\t\\tpos = 0;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treplaceSelection(MiscUtilities.createWhiteSpace(\\n\\t\\t\\t\\ttabSize - pos,0));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treplaceSelection(\\\"\\\\t\\\");\\n\\t} \\n\\t\\tprivate void userInputTab()\\n\\t{\\n\\t\\tif(getSelectionCount() == 1)\\n\\t\\t{\\n\\t\\t\\tSelection sel = getSelection(0);\\n\\t\\t\\tif(sel instanceof Selection.Rect ||\\n\\t\\t\\t\\t(sel.startLine == sel.endLine\\n\\t\\t\\t\\t&& (sel.start != buffer.getLineStartOffset(sel.startLine)\\n\\t\\t\\t\\t|| sel.end != buffer.getLineEndOffset(sel.startLine) - 1)))\\n\\t\\t\\t{\\n\\t\\t\\t\\tinsertTab();\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tshiftIndentRight();\\n\\t\\t}\\n\\t\\telse if(getSelectionCount() != 0)\\n\\t\\t\\tshiftIndentRight();\\n\\t\\telse\\n\\t\\t\\tinsertTab();\\n\\t} \\n\\tprivate boolean doWordWrap(boolean spaceInserted)\\n\\t{\\n\\t\\tif(!hardWrap || maxLineLen <= 0)\\n\\t\\t\\treturn false;\\n\\t\\tbuffer.getLineText(caretLine,lineSegment);\\n\\t\\tint start = getLineStartOffset(caretLine);\\n\\t\\tint end = getLineEndOffset(caretLine);\\n\\t\\tint len = end - start - 1;\\n\\t\\tint caretPos = caret - start;\\n\\t\\t\\t\\t\\t\\tfor(int i = caretPos; i < len; i++)\\n\\t\\t{\\n\\t\\t\\tchar ch = lineSegment.array[lineSegment.offset + i];\\n\\t\\t\\tif(ch != ' ' && ch != '\\\\t')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tint tabSize = buffer.getTabSize();\\n\\t\\tString wordBreakChars = buffer.getStringProperty(\\\"wordBreakChars\\\");\\n\\t\\tint lastInLine = 0; \\t\\tint logicalLength = 0; \\t\\tint lastWordOffset = -1;\\n\\t\\tboolean lastWasSpace = true;\\n\\t\\tfor(int i = 0; i < caretPos; i++)\\n\\t\\t{\\n\\t\\t\\tchar ch = lineSegment.array[lineSegment.offset + i];\\n\\t\\t\\tif(ch == '\\\\t')\\n\\t\\t\\t{\\n\\t\\t\\t\\tlogicalLength += tabSize - (logicalLength % tabSize);\\n\\t\\t\\t\\tif(!lastWasSpace && logicalLength <= maxLineLen)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastInLine = i;\\n\\t\\t\\t\\t\\tlastWordOffset = i;\\n\\t\\t\\t\\t\\tlastWasSpace = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(ch == ' ')\\n\\t\\t\\t{\\n\\t\\t\\t\\tlogicalLength++;\\n\\t\\t\\t\\tif(!lastWasSpace &&\\n\\t\\t\\t\\t\\tlogicalLength <= maxLineLen + 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastInLine = i;\\n\\t\\t\\t\\t\\tlastWordOffset = i;\\n\\t\\t\\t\\t\\tlastWasSpace = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(wordBreakChars != null && wordBreakChars.indexOf(ch) != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlogicalLength++;\\n\\t\\t\\t\\tif(!lastWasSpace && logicalLength <= maxLineLen)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlastInLine = i;\\n\\t\\t\\t\\t\\tlastWordOffset = i;\\n\\t\\t\\t\\t\\tlastWasSpace = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tlastInLine = i;\\n\\t\\t\\t\\tlogicalLength++;\\n\\t\\t\\t\\tlastWasSpace = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tboolean returnValue;\\n\\t\\tint insertNewLineAt;\\n\\t\\tif(spaceInserted && logicalLength == maxLineLen\\n\\t\\t\\t&& lastInLine == caretPos - 1)\\n\\t\\t{\\n\\t\\t\\tinsertNewLineAt = caretPos;\\n\\t\\t\\treturnValue = true;\\n\\t\\t}\\n\\t\\telse if(logicalLength >= maxLineLen && lastWordOffset != -1)\\n\\t\\t{\\n\\t\\t\\tinsertNewLineAt = lastWordOffset;\\n\\t\\t\\treturnValue = false;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn false;\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tbuffer.insert(start + insertNewLineAt,\\\"\\\\n\\\");\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbuffer.indentLine(caretLine,true);\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t\\treturn returnValue;\\n\\t} \\n\\t\\tprivate void doWordCount(View view, String text)\\n\\t{\\n\\t\\tchar[] chars = text.toCharArray();\\n\\t\\tint characters = chars.length;\\n\\t\\tint words;\\n\\t\\tif(characters == 0)\\n\\t\\t\\twords = 0;\\n\\t\\telse\\n\\t\\t\\twords = 1;\\n\\t\\tint lines = 1;\\n\\t\\tboolean word = false;\\n\\t\\tfor(int i = 0; i < chars.length; i++)\\n\\t\\t{\\n\\t\\t\\tswitch(chars[i])\\n\\t\\t\\t{\\n\\t\\t\\tcase '\\\\r': case '\\\\n':\\n\\t\\t\\t\\tlines++;\\n\\t\\t\\tcase ' ': case '\\\\t':\\n\\t\\t\\t\\tif(word)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twords++;\\n\\t\\t\\t\\t\\tword = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tword = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\tif(!word)\\n\\t\\t\\twords--;\\n\\t\\tObject[] args = { new Integer(characters), new Integer(words),\\n\\t\\t\\tnew Integer(lines) };\\n\\t\\tGUIUtilities.message(view,\\\"wordcount\\\",args);\\n\\t} \\n\\t\\tprivate void updateBracketHighlightWithDelay()\\n\\t{\\n\\t\\tstructureTimer.stop();\\n\\t\\tstructureTimer.start();\\n\\t} \\n\\t\\tprivate void updateStructureHighlight()\\n\\t{\\n\\t\\tif(!painter.isStructureHighlightEnabled()\\n\\t\\t\\t&& !gutter.isStructureHighlightEnabled())\\n\\t\\t\\treturn;\\n\\t\\tIterator iter = structureMatchers.iterator();\\n\\t\\twhile(iter.hasNext())\\n\\t\\t{\\n\\t\\t\\tStructureMatcher matcher = (StructureMatcher)\\n\\t\\t\\t\\titer.next();\\n\\t\\t\\tmatch = matcher.getMatch(this);\\n\\t\\t\\tif(match != null)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tif(match != null)\\n\\t\\t{\\n\\t\\t\\tif(caretLine < match.startLine)\\n\\t\\t\\t\\tinvalidateLineRange(caretLine,match.endLine);\\n\\t\\t\\telse\\n\\t\\t\\t\\tinvalidateLineRange(match.startLine,caretLine);\\n\\t\\t\\tif(!displayManager.isLineVisible(match.startLine)\\n\\t\\t\\t\\t|| chunkCache.getScreenLineOfOffset(\\n\\t\\t\\t\\tmatch.startLine,match.start - getLineStartOffset(match.startLine))\\n\\t\\t\\t\\t== -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tshowStructureStatusMessage(match.startLine < caretLine);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void showStructureStatusMessage(boolean backward)\\n\\t{\\n\\t\\tString text = buffer.getLineText(match.startLine).trim();\\n\\t\\tif(backward && match.startLine != 0 && text.length() == 1)\\n\\t\\t{\\n\\t\\t\\tswitch(text.charAt(0))\\n\\t\\t\\t{\\n\\t\\t\\tcase '{': case '}':\\n\\t\\t\\tcase '[': case ']':\\n\\t\\t\\tcase '(': case ')':\\n\\t\\t\\t\\ttext = buffer.getLineText(match.startLine - 1)\\n\\t\\t\\t\\t\\t.trim() + \\\" \\\" + text;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\t\\ttext = text.replace('\\\\t',' ');\\n\\t\\tview.getStatus().setMessageAndClear(jEdit.getProperty(\\n\\t\\t\\t\\\"view.status.bracket\\\",new Object[] {\\n\\t\\t\\tnew Integer(match.startLine + 1), text }));\\n\\t} \\n\\t\\tvoid recalculateLastPhysicalLine()\\n\\t{\\n\\t\\tint oldScreenLastLine = screenLastLine;\\n\\t\\tfor(int i = visibleLines - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tChunkCache.LineInfo info = chunkCache.getLineInfo(i);\\n\\t\\t\\tif(info.physicalLine != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tphysLastLine = info.physicalLine;\\n\\t\\t\\t\\tscreenLastLine = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tinvalidateScreenLineRange(oldScreenLastLine,screenLastLine);\\n\\t} \\n\\t\\tstatic class RectParams\\n\\t{\\n\\t\\tint extraStartVirt;\\n\\t\\tint extraEndVirt;\\n\\t\\tint newCaret;\\n\\t\\tRectParams(int extraStartVirt, int extraEndVirt, int newCaret)\\n\\t\\t{\\n\\t\\t\\tthis.extraStartVirt = extraStartVirt;\\n\\t\\t\\tthis.extraEndVirt = extraEndVirt;\\n\\t\\t\\tthis.newCaret = newCaret;\\n\\t\\t}\\n\\t}\\n\\tprivate RectParams getRectParams(int caret, int newCaret)\\n\\t{\\n\\t\\tSelection s = getSelectionAtOffset(caret);\\n\\t\\tint virtualWidth;\\n\\t\\tif(s instanceof Selection.Rect)\\n\\t\\t{\\n\\t\\t\\tif(caret == s.end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvirtualWidth = buffer.getVirtualWidth(\\n\\t\\t\\t\\t\\ts.endLine,s.end - getLineStartOffset(\\n\\t\\t\\t\\t\\ts.endLine)) + ((Selection.Rect)s).extraEndVirt;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tvirtualWidth = buffer.getVirtualWidth(\\n\\t\\t\\t\\t\\ts.startLine,s.start - getLineStartOffset(\\n\\t\\t\\t\\t\\ts.startLine)) + ((Selection.Rect)s).extraStartVirt;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(rectangularSelectionMode)\\n\\t\\t{\\n\\t\\t\\tvirtualWidth = buffer.getVirtualWidth(\\n\\t\\t\\t\\tcaretLine,caret - buffer.getLineStartOffset(caretLine));\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn null;\\n\\t\\tint newLine = getLineOfOffset(newCaret);\\n\\t\\tint[] totalVirtualWidth = new int[1];\\n\\t\\tint newOffset = buffer.getOffsetOfVirtualColumn(newLine,\\n\\t\\t\\tvirtualWidth,totalVirtualWidth);\\n\\t\\tif(newOffset == -1)\\n\\t\\t{\\n\\t\\t\\tint extraVirt = virtualWidth - totalVirtualWidth[0];\\n\\t\\t\\tnewCaret = getLineEndOffset(newLine) - 1;\\n\\t\\t\\tRectParams returnValue;\\n\\t\\t\\tboolean bias;\\n\\t\\t\\tif(s == null)\\n\\t\\t\\t\\tbias = (newCaret < caret);\\n\\t\\t\\telse if(s.start == caret)\\n\\t\\t\\t\\tbias = (newCaret <= s.end);\\n\\t\\t\\telse if(s.end == caret)\\n\\t\\t\\t\\tbias = (newCaret <= s.start);\\n\\t\\t\\telse\\n\\t\\t\\t\\tbias = false;\\n\\t\\t\\tif(bias)\\n\\t\\t\\t\\treturnValue = new RectParams(extraVirt,0,newCaret);\\n\\t\\t\\telse\\n\\t\\t\\t\\treturnValue = new RectParams(0,extraVirt,newCaret);\\n\\t\\t\\treturn returnValue;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\treturn new RectParams(0,0,getLineStartOffset(newLine)\\n\\t\\t\\t\\t+ newOffset);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void delete(boolean forward)\\n\\t{\\n\\t\\tif(!buffer.isEditable())\\n\\t\\t{\\n\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(getSelectionCount() != 0)\\n\\t\\t{\\n\\t\\t\\tSelection[] selections = getSelection();\\n\\t\\t\\tfor(int i = 0; i < selections.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSelection s = selections[i];\\n\\t\\t\\t\\tif(s instanceof Selection.Rect)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSelection.Rect r = (Selection.Rect)s;\\n\\t\\t\\t\\t\\tint startColumn = r.getStartColumn(buffer);\\n\\t\\t\\t\\t\\tif(startColumn == r.getEndColumn(buffer))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(!forward && startColumn == 0)\\n\\t\\t\\t\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\ttallCaretDelete(r,forward);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tsetSelectedText(s,null);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tsetSelectedText(s,null);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(forward)\\n\\t\\t{\\n\\t\\t\\tif(caret == buffer.getLength())\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.remove(caret,1);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(caret == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgetToolkit().beep();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tbuffer.remove(caret - 1,1);\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void tallCaretDelete(Selection.Rect s, boolean forward)\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tbuffer.beginCompoundEdit();\\n\\t\\t\\tint[] width = new int[1];\\n\\t\\t\\tint startCol = s.getStartColumn(buffer);\\n\\t\\t\\tint startLine = s.startLine;\\n\\t\\t\\tint endLine = s.endLine;\\n\\t\\t\\tfor(int i = startLine; i <= endLine; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint offset = buffer.getOffsetOfVirtualColumn(\\n\\t\\t\\t\\t\\ti,startCol,width);\\n\\t\\t\\t\\tif(offset == -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(width[0] == startCol)\\n\\t\\t\\t\\t\\t\\toffset = getLineLength(i);\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(i == startLine && !forward)\\n\\t\\t\\t\\t\\t\\t\\tshiftTallCaretLeft(s);\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\toffset += buffer.getLineStartOffset(i);\\n\\t\\t\\t\\tif(forward)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(offset != buffer.getLineEndOffset(i) - 1)\\n\\t\\t\\t\\t\\t\\tbuffer.remove(offset,1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbuffer.remove(offset-1,1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally\\n\\t\\t{\\n\\t\\t\\tbuffer.endCompoundEdit();\\n\\t\\t}\\n\\t} \\n\\t\\tprivate void shiftTallCaretLeft(Selection.Rect s)\\n\\t{\\n\\t\\tremoveFromSelection(s);\\n\\t\\taddToSelection(new Selection.Rect(\\n\\t\\t\\tbuffer,\\n\\t\\t\\ts.getStartLine(),s.getStartColumn(buffer) - 1,\\n\\t\\t\\ts.getEndLine(),s.getEndColumn(buffer) - 1));\\n\\t} \\n\\t\\tprivate void setMaxLineLength(int maxLineLen)\\n\\t{\\n\\t\\tthis.maxLineLen = maxLineLen;\\n\\t\\tif(maxLineLen <= 0)\\n\\t\\t{\\n\\t\\t\\tif(softWrap)\\n\\t\\t\\t{\\n\\t\\t\\t\\twrapToWidth = true;\\n\\t\\t\\t\\twrapMargin = painter.getWidth() - charWidth * 3;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\twrapToWidth = false;\\n\\t\\t\\t\\twrapMargin = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\\t\\t\\tchar[] foo = new char[maxLineLen];\\n\\t\\t\\tfor(int i = 0; i < foo.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfoo[i] = ' ';\\n\\t\\t\\t}\\n\\t\\t\\twrapToWidth = false;\\n\\t\\t\\twrapMargin = (int)painter.getFont().getStringBounds(\\n\\t\\t\\t\\tfoo,0,foo.length,\\n\\t\\t\\t\\tpainter.getFontRenderContext())\\n\\t\\t\\t\\t.getWidth();\\n\\t\\t}\\n\\t} \\n\\t\\tstatic class CaretBlinker implements ActionListener\\n\\t{\\n\\t\\t\\t\\tpublic void actionPerformed(ActionEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(focusedComponent != null && focusedComponent.hasFocus())\\n\\t\\t\\t\\tfocusedComponent.blinkCaret();\\n\\t\\t} \\t} \\n\\t\\tclass MutableCaretEvent extends CaretEvent\\n\\t{\\n\\t\\t\\t\\tMutableCaretEvent()\\n\\t\\t{\\n\\t\\t\\tsuper(JEditTextArea.this);\\n\\t\\t} \\n\\t\\t\\t\\tpublic int getDot()\\n\\t\\t{\\n\\t\\t\\treturn getCaretPosition();\\n\\t\\t} \\n\\t\\t\\t\\tpublic int getMark()\\n\\t\\t{\\n\\t\\t\\treturn getMarkPosition();\\n\\t\\t} \\t} \\n\\t\\tclass AdjustHandler implements AdjustmentListener\\n\\t{\\n\\t\\t\\t\\tpublic void adjustmentValueChanged(final AdjustmentEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(!scrollBarsInitialized)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(evt.getAdjustable() == vertical)\\n\\t\\t\\t\\tsetFirstLine(vertical.getValue());\\n\\t\\t\\telse\\n\\t\\t\\t\\tsetHorizontalOffset(-horizontal.getValue());\\n\\t\\t} \\t} \\n\\t\\tclass FocusHandler implements FocusListener\\n\\t{\\n\\t\\t\\t\\tpublic void focusGained(FocusEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(bufferChanging)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(match != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caretLine < match.startLine)\\n\\t\\t\\t\\t\\tinvalidateLineRange(caretLine,match.endLine);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tinvalidateLineRange(match.startLine,caretLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t\\tfocusedComponent = JEditTextArea.this;\\n\\t\\t} \\n\\t\\t\\t\\tpublic void focusLost(FocusEvent evt)\\n\\t\\t{\\n\\t\\t\\tif(!isShowing())\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(match != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(caretLine < match.startLine)\\n\\t\\t\\t\\t\\tinvalidateLineRange(caretLine,match.endLine);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tinvalidateLineRange(match.startLine,caretLine);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tinvalidateLine(caretLine);\\n\\t\\t} \\t} \\n\\t\\tclass MouseWheelHandler implements MouseWheelListener\\n\\t{\\n\\t\\tpublic void mouseWheelMoved(MouseWheelEvent e)\\n\\t\\t{\\n\\t\\t\\tif(e.isAltDown())\\n\\t\\t\\t{\\n\\t\\t\\t\\tboolean select = (e.isShiftDown()\\n\\t\\t\\t\\t\\t|| e.isControlDown());\\n\\t\\t\\t\\tif(e.getWheelRotation() < 0)\\n\\t\\t\\t\\t\\tgoToPrevLine(select);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tgoToNextLine(select);\\n\\t\\t\\t}\\n\\t\\t\\telse if(e.isShiftDown())\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(e.getWheelRotation() > 0)\\n\\t\\t\\t\\t\\tscrollDownPage();\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tscrollUpPage();\\n\\t\\t\\t}\\n\\t\\t\\telse if(e.isControlDown())\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFirstLine(getFirstLine()\\n\\t\\t\\t\\t\\t+ e.getWheelRotation());\\n\\t\\t\\t}\\n\\t\\t\\telse if(e.getScrollType()\\n\\t\\t\\t\\t== MouseWheelEvent.WHEEL_UNIT_SCROLL)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFirstLine(getFirstLine()\\n\\t\\t\\t\\t\\t+ e.getUnitsToScroll());\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsetFirstLine(getFirstLine()\\n\\t\\t\\t\\t\\t+ 3 * e.getWheelRotation());\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\t\\tstatic\\n\\t{\\n\\t\\tcaretTimer = new Timer(500,new CaretBlinker());\\n\\t\\tcaretTimer.setInitialDelay(500);\\n\\t\\tcaretTimer.start();\\n\\t\\tstructureTimer = new Timer(100,new ActionListener()\\n\\t\\t{\\n\\t\\t\\tpublic void actionPerformed(ActionEvent evt)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(focusedComponent != null)\\n\\t\\t\\t\\t\\tfocusedComponent.updateStructureHighlight();\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tstructureTimer.setInitialDelay(100);\\n\\t\\tstructureTimer.setRepeats(false);\\n\\t} }\""
            },
            "m38": {
                "content": "The starting entity `JEditTextArea.java` is a central component in the jEdit text editor, responsible for handling user interactions with the text content. It imports and utilizes several modules such as UI components (`javax.swing.*`, `java.awt.*`), buffer management (`org.gjt.sp.jedit.buffer.*`), syntax highlighting (`org.gjt.sp.jedit.syntax.*`), and utility classes (`org.gjt.sp.util.Log`). \n\nFrom the call graph analysis, we see that this class uses:\n- **Log**: For logging error or status messages.\n- **UI-related libraries**: To manage the visible text area, painter, scroll bars, and other GUI components.\n- **Buffer-related functionality**: To manipulate text, handle selections, and perform edits.\n\n### Key Observations\n1. The class heavily interacts with the `Buffer` class to manage text changes, selections, and caret movements.\n2. It has complex dependencies on UI components (e.g., `TextAreaPainter`, `Gutter`, `SelectionManager`) for rendering and interaction.\n3. It relies on external utilities like `TextUtilities`, `MiscUtilities`, and `Log`.\n\n### Next Steps\nTo identify entities that need synchronization due to potential ripple effects from changes in `JEditTextArea.java`, we should analyze coupling dependencies with these critical components:\n1. **Check coupling dependencies** between `JEditTextArea.java` and key classes like `Buffer`, `TextAreaPainter`, `Gutter`, `SelectionManager`, etc.\n2. If needed, **analyze semantic similarity** with related files to uncover conceptual couplings not evident through direct code references.\n\nWould you like me to check coupling dependencies between `JEditTextArea.java` and another specific file (e.g., `Buffer.java`) or proceed with a broader dependency analysis?",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            },
            "m39": {
                "role": "user",
                "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example, without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
            },
            "m40": {
                "content": "Title: Diagnosis of starting entity `JEditTextArea.java`  \nChange set: [Buffer, TextAreaPainter, Gutter, SelectionManager, DisplayManager, ChunkCache, View, Log, SyntaxStyle, EditBus, JEditMenuBar, TextAreaInputHandler, Macros, Abbrevs, TextUtilities, MiscUtilities, GUIUtilities, PluginJAR, EditPlugin, DockableWindowManager, Console, StatusBar, FoldHandler, StructureMatcher, MouseHandler, AdjustHandler, FocusHandler, MouseWheelHandler, PropertiesOptionPane, GlobalOptions, DefaultKeyMap, KeyBindingManager, ToolBar, ErrorListDialog, ProjectViewer, Document, UndoManager, SettingsManager, HistoryModel, SearchAndReplace, BeanShell, Commands, QuickNotepadPlugin, FTPPlugin, ConsolePlugin]  \n\nDetails:  \n1. **Buffer**: Central to text editing operations; methods in `JEditTextArea` heavily rely on it for inserting, deleting, and selecting text.\n2. **TextAreaPainter**: Responsible for rendering the text area; tightly coupled with painting logic and caret blinking.\n3. **Gutter**: Manages line numbers and annotations; interacts directly with the text area's layout and scroll updates.\n4. **SelectionManager**: Maintains selection state; used extensively for managing selections, ranges, and rectangular selections.\n5. **DisplayManager**: Handles visible lines, folds, and scrolling behavior; crucial for viewport management.\n6. **ChunkCache**: Caches screen line information; used for efficient rendering and scrolling calculations.\n7. **View**: Encapsulates the user interface view; controls input handling and UI context.\n8. **Log**: Used for logging error messages (e.g., when exceptions are caught).\n9. **SyntaxStyle**: Influences how syntax highlighting is rendered; may be accessed through buffer or painter.\n10. **EditBus**: Likely involved in event-driven communication between components.\n11. **JEditMenuBar**: Part of the UI that could be affected by changes to global actions or keybindings.\n12. **TextAreaInputHandler**: Handles keyboard input and command dispatching; tightly integrated with the text area.\n13. **Macros**: Invoked during macro recording and playback; tied to user input and caret movement.\n14. **Abbrevs**: Expands abbreviations on input; invoked during typing.\n15. **TextUtilities**: Provides utility functions for string manipulation, formatting, indentation.\n16. **MiscUtilities**: Offers helper functions for whitespace, tabs, and virtual column calculations.\n17. **GUIUtilities**: Displays dialogs, error messages, popups\u2014used frequently for user interaction.\n18. **PluginJAR**: May affect plugin-integrated text editing features.\n19. **EditPlugin**: Plugins might hook into text area events.\n20. **DockableWindowManager**: Coordinates docked tools that interact with the text area.\n21. **Console**: Could be impacted if console output affects text content or selection.\n22. **StatusBar**: Status messages updated from caret movements or selection changes.\n23. **FoldHandler**: Controls folding behavior, which is managed by display and navigation logic.\n24. **StructureMatcher**: Used to highlight structural elements like brackets.\n25. **MouseHandler**: Processes mouse events within the text area.\n26. **AdjustHandler**: Responds to scroll bar adjustments.\n27. **FocusHandler**: Manages focus-related visual cues.\n28. **MouseWheelHandler**: Processes mouse wheel scrolling.\n29. **PropertiesOptionPane**: If preferences affect editor behavior, changes may ripple here.\n30. **GlobalOptions**: Affects global settings such as tab size, wrap mode.\n31. **DefaultKeyMap**: Contains default key bindings used by input handlers.\n32. **KeyBindingManager**: Links key strokes to commands affecting the text area.\n33. **ToolBar**: Might be affected if tool actions modify the text area.\n34. **ErrorListDialog**: Integration with error navigation may involve caret positioning.\n35. **ProjectViewer**: Navigates files; could trigger text area updates.\n36. **Document**: Represents underlying document model; tightly related to buffer changes.\n37. **UndoManager**: Manages undo/redo stack; closely linked to compound edits.\n38. **SettingsManager**: Loads and persists settings affecting the text area.\n39. **HistoryModel**: Stores command history; possibly used in macros or input handler.\n40. **SearchAndReplace**: Uses selections and caret positioning; tightly integrated.\n41. **BeanShell**: Executes scripts that manipulate the text area.\n42. **Commands**: Core commands that operate on the text area.\n43. **QuickNotepadPlugin**: Possibly uses a text area instance internally.\n44. **FTPPlugin**: May interact with text area via file loading/saving.\n45. **ConsolePlugin**: Could link console output to the text area.\n\nThese entities are likely to need synchronization due to direct coupling, shared state, or conceptual dependencies based on their usage patterns in `JEditTextArea`.",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            }
        }
    }
}