{
    "time": 1749622366.8936489,
    "messages": [
        {
            "role": "system",
            "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
        },
        {
            "role": "user",
            "content": "The project you need to analyze is `Makagiga`, a well-known Java open source project. The starting entity you need to deal with is MText.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
        },
        {
            "content": "",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_e0aac15a07154b4fb237f7",
                    "function": {
                        "arguments": "{\"entity\": \"MText.java\"}",
                        "name": "get_co_change_relationship"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "name": "get_co_change_relationship",
            "role": "tool",
            "content": "[[\"MSmallColorButton\", \"2\", \"0.037037037037037035\"], [\"MFileChooser\", \"4\", \"0.07407407407407407\"], [\"Blend\", \"3\", \"0.05555555555555555\"], [\"InternetSearch\", \"2\", \"0.037037037037037035\"], [\"MNotification\", \"2\", \"0.037037037037037035\"], [\"MDialog\", \"3\", \"0.05555555555555555\"], [\"Main\", \"2\", \"0.037037037037037035\"], [\"MURLButton\", \"2\", \"0.037037037037037035\"], [\"AutoCompletion\", \"8\", \"0.14814814814814814\"], [\"PluginRenderer\", \"1\", \"0.018518518518518517\"], [\"RenameEditor\", \"2\", \"0.037037037037037035\"], [\"ItemRenderer\", \"1\", \"0.018518518518518517\"], [\"MProgressBar\", \"1\", \"0.018518518518518517\"], [\"AbstractRenderer\", \"1\", \"0.018518518518518517\"], [\"Net\", \"1\", \"0.018518518518518517\"], [\"MaximumLengthDocumentFilter\", \"1\", \"0.018518518518518517\"], [\"HelpGenerator\", \"2\", \"0.037037037037037035\"], [\"HelpAction\", \"2\", \"0.037037037037037035\"], [\"MTextPane\", \"6\", \"0.1111111111111111\"], [\"NoteWidgetPlugin\", \"2\", \"0.037037037037037035\"], [\"Desktop\", \"1\", \"0.018518518518518517\"], [\"LinkAction\", \"1\", \"0.018518518518518517\"], [\"MCharacterChooser\", \"2\", \"0.037037037037037035\"], [\"DragAdapter\", \"1\", \"0.018518518518518517\"], [\"Widget\", \"1\", \"0.018518518518518517\"], [\"AbstractSpinner\", \"6\", \"0.1111111111111111\"], [\"MTextField\", \"5\", \"0.09259259259259259\"], [\"Permission\", \"1\", \"0.018518518518518517\"], [\"Syntax\", \"1\", \"0.018518518518518517\"], [\"PrintDialog\", \"1\", \"0.018518518518518517\"], [\"ScriptCommand\", \"1\", \"0.018518518518518517\"], [\"MEditorPane\", \"4\", \"0.07407407407407407\"], [\"NotepadEditor\", \"5\", \"0.09259259259259259\"], [\"Query\", \"1\", \"0.018518518518518517\"], [\"ImportExport\", \"1\", \"0.018518518518518517\"], [\"NoObjectView\", \"1\", \"0.018518518518518517\"], [\"HowToAction\", \"1\", \"0.018518518518518517\"], [\"LinkEditor\", \"4\", \"0.07407407407407407\"], [\"MPanel\", \"1\", \"0.018518518518518517\"], [\"TodoEditorCore\", \"2\", \"0.037037037037037035\"], [\"FeedsFS\", \"1\", \"0.018518518518518517\"], [\"HTMLAutodiscovery\", \"1\", \"0.018518518518518517\"], [\"LinkEditorPlugin\", \"1\", \"0.018518518518518517\"], [\"TestRepeatRule\", \"1\", \"0.018518518518518517\"], [\"MZip\", \"1\", \"0.018518518518518517\"], [\"Tabs\", \"3\", \"0.05555555555555555\"], [\"FindLocationDialog\", \"1\", \"0.018518518518518517\"], [\"StaticAction\", \"2\", \"0.037037037037037035\"], [\"DateAction\", \"1\", \"0.018518518518518517\"], [\"URIBookmark\", \"1\", \"0.018518518518518517\"], [\"InsertAction\", \"1\", \"0.018518518518518517\"], [\"DefaultPreview\", \"1\", \"0.018518518518518517\"], [\"InsertCharacterAction\", \"2\", \"0.037037037037037035\"], [\"BookmarkAction\", \"1\", \"0.018518518518518517\"], [\"MRegexPanel\", \"2\", \"0.037037037037037035\"], [\"SetOpenCommandAction\", \"1\", \"0.018518518518518517\"], [\"CommonExtensions\", \"2\", \"0.037037037037037035\"], [\"Tree\", \"1\", \"0.018518518518518517\"], [\"MPasswordField\", \"4\", \"0.07407407407407407\"], [\"MComboBox\", \"3\", \"0.05555555555555555\"], [\"MLabeledTextField\", \"2\", \"0.037037037037037035\"], [\"TextEditor\", \"4\", \"0.07407407407407407\"], [\"Item\", \"3\", \"0.05555555555555555\"], [\"MountPanel\", \"1\", \"0.018518518518518517\"], [\"EditorQuickFind\", \"1\", \"0.018518518518518517\"], [\"InternetBrowserSettings\", \"1\", \"0.018518518518518517\"], [\"TextEditorCore\", \"3\", \"0.05555555555555555\"], [\"NoteWidget\", \"5\", \"0.09259259259259259\"], [\"ScriptIDE\", \"3\", \"0.05555555555555555\"], [\"MCalendar\", \"1\", \"0.018518518518518517\"], [\"Events\", \"1\", \"0.018518518518518517\"], [\"MDateSpinner\", \"1\", \"0.018518518518518517\"], [\"CalendarDesklet\", \"1\", \"0.018518518518518517\"], [\"TodoEditor\", \"3\", \"0.05555555555555555\"], [\"Feed\", \"2\", \"0.037037037037037035\"], [\"CalendarComponent\", \"1\", \"0.018518518518518517\"], [\"Info\", \"1\", \"0.018518518518518517\"], [\"Factory\", \"1\", \"0.018518518518518517\"], [\"MUndoManager\", \"3\", \"0.05555555555555555\"], [\"Listener\", \"1\", \"0.018518518518518517\"], [\"MainWindow\", \"3\", \"0.05555555555555555\"], [\"MWebBrowser\", \"1\", \"0.018518518518518517\"], [\"Kiosk\", \"1\", \"0.018518518518518517\"], [\"AutoCompletionData\", \"1\", \"0.018518518518518517\"], [\"EditorCrypto\", \"1\", \"0.018518518518518517\"], [\"SessionManager\", \"1\", \"0.018518518518518517\"], [\"NotepadEditorPlugin\", \"1\", \"0.018518518518518517\"], [\"TodoEditorPlugin\", \"2\", \"0.037037037037037035\"], [\"HTMLPreviewAction\", \"1\", \"0.018518518518518517\"], [\"Clear\", \"1\", \"0.018518518518518517\"], [\"ClearAction\", \"1\", \"0.018518518518518517\"], [\"Output\", \"2\", \"0.037037037037037035\"], [\"MHTMLViewer\", \"3\", \"0.05555555555555555\"], [\"ProxyModel\", \"1\", \"0.018518518518518517\"], [\"ConsoleConfig\", \"1\", \"0.018518518518518517\"], [\"GHNSDialog\", \"1\", \"0.018518518518518517\"], [\"PluginDownloader\", \"1\", \"0.018518518518518517\"], [\"MouseGestures\", \"1\", \"0.018518518518518517\"], [\"MSizeGrip\", \"1\", \"0.018518518518518517\"], [\"MSettingsPage\", \"1\", \"0.018518518518518517\"], [\"MWhatsThis\", \"1\", \"0.018518518518518517\"], [\"ScriptError\", \"1\", \"0.018518518518518517\"], [\"Console\", \"1\", \"0.018518518518518517\"], [\"FeedUtils\", \"1\", \"0.018518518518518517\"], [\"InsertDateAction\", \"1\", \"0.018518518518518517\"], [\"Action\", \"2\", \"0.037037037037037035\"], [\"InsertSymbolAction\", \"1\", \"0.018518518518518517\"], [\"FetchAllFeedsAction\", \"1\", \"0.018518518518518517\"], [\"NotepadEditorDesigner\", \"1\", \"0.018518518518518517\"], [\"ConsoleOutput\", \"1\", \"0.018518518518518517\"], [\"BooleanRenderer\", \"1\", \"0.018518518518518517\"], [\"CompleteRenderer\", \"1\", \"0.018518518518518517\"], [\"CompoundFilter\", \"1\", \"0.018518518518518517\"], [\"BeanProperty\", \"1\", \"0.018518518518518517\"], [\"Handler\", \"2\", \"0.037037037037037035\"], [\"InternetSearchPlugin\", \"1\", \"0.018518518518518517\"], [\"Reflection\", \"1\", \"0.018518518518518517\"], [\"FeedViewer\", \"1\", \"0.018518518518518517\"], [\"SwingWebBrowser\", \"1\", \"0.018518518518518517\"], [\"StaticHandler\", \"2\", \"0.037037037037037035\"], [\"Title\", \"1\", \"0.018518518518518517\"], [\"ColumnManager\", \"2\", \"0.037037037037037035\"], [\"ComponentHighlight\", \"1\", \"0.018518518518518517\"], [\"ConsoleIO\", \"1\", \"0.018518518518518517\"], [\"CircleEditor\", \"1\", \"0.018518518518518517\"], [\"StaticDragHandler\", \"1\", \"0.018518518518518517\"], [\"TagsEditor\", \"2\", \"0.037037037037037035\"], [\"HistoryCommand\", \"1\", \"0.018518518518518517\"], [\"InternetSearchPanel\", \"1\", \"0.018518518518518517\"], [\"MTextFieldPanel\", \"1\", \"0.018518518518518517\"], [\"MFormattedTextField\", \"2\", \"0.037037037037037035\"], [\"SummaryEditor\", \"3\", \"0.05555555555555555\"], [\"SearchBar\", \"1\", \"0.018518518518518517\"], [\"ConsoleCommandLine\", \"2\", \"0.037037037037037035\"], [\"NewFileDialog\", \"1\", \"0.018518518518518517\"], [\"ComponentBeanInfo\", \"1\", \"0.018518518518518517\"], [\"StaticRedoAction\", \"1\", \"0.018518518518518517\"], [\"StaticUndoAction\", \"1\", \"0.018518518518518517\"], [\"RichTextPane\", \"1\", \"0.018518518518518517\"], [\"Editor\", \"2\", \"0.037037037037037035\"], [\"MCalendarPanel\", \"2\", \"0.037037037037037035\"], [\"Label\", \"1\", \"0.018518518518518517\"], [\"MAboutDialog\", \"1\", \"0.018518518518518517\"], [\"Renderer\", \"1\", \"0.018518518518518517\"], [\"EmptyCell\", \"1\", \"0.018518518518518517\"], [\"MTree\", \"1\", \"0.018518518518518517\"], [\"BackupDialog\", \"1\", \"0.018518518518518517\"], [\"ShowHideLocationBarAction\", \"1\", \"0.018518518518518517\"], [\"MList\", \"2\", \"0.037037037037037035\"], [\"Pager\", \"1\", \"0.018518518518518517\"], [\"StyleButton\", \"1\", \"0.018518518518518517\"], [\"TextEditorDesigner\", \"1\", \"0.018518518518518517\"], [\"Button\", \"1\", \"0.018518518518518517\"], [\"MToggleButton\", \"1\", \"0.018518518518518517\"], [\"MSearchPanel\", \"1\", \"0.018518518518518517\"], [\"FeedComponent\", \"1\", \"0.018518518518518517\"], [\"InternetSearchWidget\", \"1\", \"0.018518518518518517\"], [\"CategoryMenu\", \"1\", \"0.018518518518518517\"], [\"CompletionWindow\", \"2\", \"0.037037037037037035\"], [\"HistoryDialog\", \"1\", \"0.018518518518518517\"], [\"CompletionList\", \"2\", \"0.037037037037037035\"], [\"SecurityDialog\", \"1\", \"0.018518518518518517\"], [\"MColorIcon\", \"1\", \"0.018518518518518517\"], [\"WikiPanel\", \"1\", \"0.018518518518518517\"], [\"Armor\", \"2\", \"0.037037037037037035\"], [\"MTabbedPane\", \"1\", \"0.018518518518518517\"], [\"Impl\", \"1\", \"0.018518518518518517\"], [\"PickerColorChooserPanel\", \"1\", \"0.018518518518518517\"], [\"MSmallColorChooser\", \"1\", \"0.018518518518518517\"], [\"MActionInfo\", \"1\", \"0.018518518518518517\"], [\"MWrapperPanel\", \"1\", \"0.018518518518518517\"], [\"FormPanel\", \"1\", \"0.018518518518518517\"], [\"MMessage\", \"2\", \"0.037037037037037035\"], [\"StaticFocusHandler\", \"1\", \"0.018518518518518517\"], [\"HTMLColorChooserPanel\", \"1\", \"0.018518518518518517\"], [\"MLabel\", \"1\", \"0.018518518518518517\"], [\"ImageEditorCore\", \"1\", \"0.018518518518518517\"], [\"ProxySettings\", \"1\", \"0.018518518518518517\"], [\"DateTimeEditor\", \"1\", \"0.018518518518518517\"], [\"FeedsConfigPanel\", \"1\", \"0.018518518518518517\"], [\"TextChangedListener\", \"1\", \"0.018518518518518517\"], [\"CategoryPropertiesPanel\", \"1\", \"0.018518518518518517\"], [\"AddFeedDialog\", \"1\", \"0.018518518518518517\"], [\"TaskTable\", \"2\", \"0.037037037037037035\"], [\"Input\", \"2\", \"0.037037037037037035\"], [\"TaskPanel\", \"1\", \"0.018518518518518517\"], [\"SnippetAction\", \"1\", \"0.018518518518518517\"], [\"TaskPropertiesPanel\", \"1\", \"0.018518518518518517\"], [\"AddAction\", \"1\", \"0.018518518518518517\"], [\"MMenu\", \"1\", \"0.018518518518518517\"], [\"HelpMenu\", \"1\", \"0.018518518518518517\"], [\"StyleSupport\", \"1\", \"0.018518518518518517\"], [\"MScrollPane\", \"1\", \"0.018518518518518517\"], [\"MTable\", \"1\", \"0.018518518518518517\"], [\"ProxyPanel\", \"1\", \"0.018518518518518517\"], [\"TextUtils\", \"1\", \"0.018518518518518517\"], [\"PrintAction\", \"1\", \"0.018518518518518517\"]]"
        },
        {
            "content": "The co-change relationships for `MText.java` show several files that are frequently modified together with `MText.java`. The confidence value indicates the likelihood that a file is modified alongside `MText.java`. Files with higher confidence values are more likely to be impacted by changes in `MText.java`.\n\n### Observations:\n1. **High Confidence Relationships (Confidence \u2265 0.1):**\n   - `AutoCompletion` (confidence: ~0.148)\n   - `MTextPane` (confidence: ~0.111)\n   - `AbstractSpinner` (confidence: ~0.111)\n\n2. **Moderate Confidence Relationships (0.05 \u2264 Confidence < 0.1):**\n   - Examples include `MTextField`, `NotepadEditor`, `LinkEditor`, etc.\n\n3. **Low Confidence Relationships (Confidence < 0.05):**\n   - Most of the other files fall into this category, such as `MFileChooser`, `MDialog`, and `HelpAction`.\n\n### Recommendations:\n- Entities with **high confidence** values should definitely be considered for synchronization since they have a strong historical correlation with `MText.java`.\n- Entities with **moderate confidence** should also be reviewed carefully, especially if the change in `MText.java` involves shared functionality or core logic.\n- Entities with **low confidence** may not always require synchronization unless there is an explicit dependency revealed through further analysis.\n\nNext, we should analyze the coupling dependencies between `MText.java` and these co-changed entities to identify direct or indirect dependencies. Start with checking coupling dependencies between `MText.java` and `AutoCompletion.java`, which has the highest confidence value. \n\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_826308a7b39f4ec293fca1",
                    "function": {
                        "arguments": "{\"entity1\": \"MText.java\", \"entity2\": \"AutoCompletion.java\"}",
                        "name": "get_coupling_dependencies"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_coupling_dependencies",
            "content": "[\"MText has been removed from the project due to project version iteration\"]"
        },
        {
            "content": "It appears that `MText.java` has been removed from the project in a newer version, which might explain why some of the co-change relationships seem outdated. This removal could also mean that its functionalities have been replaced or refactored into other components.\n\nSince `AutoCompletion.java` showed a strong historical relationship with `MText.java`, and considering that `MText.java` no longer exists, it would be valuable to understand how `AutoCompletion.java` is used within the system. We should examine its code to determine if it still references any logic or structures previously handled by `MText.java`. Let's retrieve the source code for `AutoCompletion.java` to further analyze potential impacts.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_df0a241de50c4883b39073",
                    "function": {
                        "arguments": "{\"entity\": \"AutoCompletion.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package org.makagiga.commons.autocompletion;\\nimport static java.awt.event.KeyEvent.*;\\nimport static org.makagiga.commons.UI._;\\nimport java.awt.AWTEvent;\\nimport java.awt.Color;\\nimport java.awt.Component;\\nimport java.awt.Dimension;\\nimport java.awt.Frame;\\nimport java.awt.Point;\\nimport java.awt.Toolkit;\\nimport java.awt.Window;\\nimport java.awt.event.AWTEventListener;\\nimport java.awt.event.ComponentEvent;\\nimport java.awt.event.FocusEvent;\\nimport java.awt.event.KeyAdapter;\\nimport java.awt.event.KeyEvent;\\nimport java.awt.event.MouseEvent;\\nimport java.lang.ref.WeakReference;\\nimport java.util.List;\\nimport java.util.Set;\\nimport java.util.TreeSet;\\nimport javax.swing.BorderFactory;\\nimport javax.swing.Popup;\\nimport javax.swing.PopupFactory;\\nimport javax.swing.SwingUtilities;\\nimport javax.swing.event.DocumentEvent;\\nimport javax.swing.text.BadLocationException;\\nimport javax.swing.text.JTextComponent;\\nimport javax.swing.text.Utilities;\\nimport org.makagiga.commons.BooleanProperty;\\nimport org.makagiga.commons.FS;\\nimport org.makagiga.commons.IntegerProperty;\\nimport org.makagiga.commons.MActionInfo;\\nimport org.makagiga.commons.MArrayList;\\nimport org.makagiga.commons.MColor;\\nimport org.makagiga.commons.MDataAction;\\nimport org.makagiga.commons.TK;\\nimport org.makagiga.commons.UI;\\nimport org.makagiga.commons.WTFError;\\nimport org.makagiga.commons.mv.MRenderer;\\nimport org.makagiga.commons.swing.ContainerIterator;\\nimport org.makagiga.commons.swing.MComponent;\\nimport org.makagiga.commons.swing.MDialog;\\nimport org.makagiga.commons.swing.MFrame;\\nimport org.makagiga.commons.swing.MList;\\nimport org.makagiga.commons.swing.MList.ActionType;\\nimport org.makagiga.commons.swing.MPanel;\\nimport org.makagiga.commons.swing.MScrollPane;\\nimport org.makagiga.commons.swing.MSearchPanel;\\nimport org.makagiga.commons.swing.MText;\\nimport org.makagiga.commons.swing.MWindow;\\nimport org.makagiga.commons.swing.event.MDocumentAdapter;\\nimport org.makagiga.commons.swing.event.MMouseAdapter;\\nimport org.makagiga.commons.validator.ListSelectionValidator;\\npublic class AutoCompletion {\\n\\tpublic final BooleanProperty caseSensitive = new BooleanProperty();\\n\\tpublic final BooleanProperty consumeEnter = new BooleanProperty(true);\\n\\tpublic final BooleanProperty enabled = new BooleanProperty(true);\\n\\tpublic final IntegerProperty limit = new IntegerProperty(100);\\n\\tpublic final IntegerProperty yOffset = new IntegerProperty(0);\\n\\tpublic static final String TEXT_COMPONENT_IN_UPDATE_PROPERTY = \\\"org.makagiga.commons.autocompletion.AutoCompletion.TEXT_COMPONENT_IN_UPDATE_PROPERTY\\\";\\n\\tpublic enum Mode {\\n\\t\\tCURRENT_WORD,\\n\\t\\tANY_TEXT\\n\\t};\\n\\tprivate AutoCompletionData data;\\n\\tprivate boolean showPopupOnUpDownKeyPress = true;\\n\\tprivate static CompletionWindow window;\\n\\tprivate Mode mode = Mode.ANY_TEXT;\\n\\tprivate Renderer userRenderer;\\n\\tprivate final String id;\\n\\tprivate final WeakReference<JTextComponent> textComponentRef;\\n\\tpublic AutoCompletion(final JTextComponent textComponent, final String id) {\\n\\t\\ttextComponentRef = new WeakReference<>(textComponent);\\n\\t\\tthis.id = TK.validateID(id);\\n\\t\\tinstall();\\n\\t}\\n\\tpublic void addItem(final String text) {\\n\\t\\tinit();\\n\\t\\tint i = data.indexOf(text);\\n\\t\\tif (i == -1)\\n\\t\\t\\tdata.add(text);\\n\\t\\telse\\n\\t\\t\\tdata.getList().get(i).usage++;\\n\\t}\\n\\tpublic void clear() {\\n\\t\\tif ((data != null) && (data.getList() != null)) {\\n\\t\\t\\tdata.getList().clear();\\n\\t\\t\\tsave();\\n\\t\\t}\\n\\t}\\n\\tpublic static void deletePrivateData() {\\n\\t\\tFS.deleteFiles(FS.makeConfigFile(\\\"autocompletion\\\"), null);\\n\\t\\t\\t\\tfor (Frame frame : Frame.getFrames()) {\\n\\t\\t\\tfor (JTextComponent i : ContainerIterator.findAll(frame, JTextComponent.class)) {\\n\\t\\t\\t\\tAutoCompletion ac = MText.getAutoCompletion(i);\\n\\t\\t\\t\\tif (ac != null)\\n\\t\\t\\t\\t\\tac.clear();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tpublic static JTextComponent getCurrentTextComponent() {\\n\\t\\tif (window == null)\\n\\t\\t\\treturn null;\\n\\t\\treturn window.getTextComponent();\\n\\t}\\n\\tpublic String getID() { return id; }\\n\\tpublic Mode getMode() { return mode; }\\n\\tpublic void setMode(final Mode value) { mode = value; }\\n\\tpublic AutoCompletion.Renderer getRenderer() { return userRenderer; }\\n\\tpublic void setRenderer(final AutoCompletion.Renderer value) { userRenderer = value; }\\n\\tpublic static void hidePopupWindow() {\\n\\t\\tif (window != null) {\\n\\t\\t\\twindow.destroy();\\n\\t\\t\\twindow = null;\\n\\t\\t}\\n\\t}\\n\\tpublic boolean getShowPopupOnUpDownKeyPress() { return showPopupOnUpDownKeyPress; }\\n\\tpublic void setShowPopupOnUpDownKeyPress(final boolean value) { showPopupOnUpDownKeyPress = value; }\\n\\tpublic void save() {\\n\\t\\tif (data != null)\\n\\t\\t\\tdata.save();\\n\\t}\\n\\tprivate void cancel() {\\n\\t\\t\\t\\tif ((window != null) && (window.originalText != null)) {\\n\\t\\t\\tupdateText(window.originalText);\\n\\t\\t}\\n\\t\\thidePopupWindow();\\n\\t}\\n\\tprivate void complete(final boolean showAll) {\\n\\t\\tif (!enabled.get())\\n\\t\\t\\treturn;\\n\\t\\tJTextComponent textComponent = textComponentRef.get();\\n\\t\\tif (textComponent == null)\\n\\t\\t\\treturn;\\n\\t\\tif (window != null)\\n\\t\\t\\twindow.originalText = textComponent.getText();\\n\\t\\tString text = null;\\n\\t\\tswitch (mode) {\\n\\t\\t\\tcase CURRENT_WORD:\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tint begin = Utilities.getWordStart(textComponent, textComponent.getCaretPosition());\\n\\t\\t\\t\\t\\tint end = Utilities. getWordEnd(textComponent, begin);\\n\\t\\t\\t\\t\\ttext = textComponent.getText(begin, end - begin);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch (BadLocationException exception) { \\t\\t\\t\\t\\ttext = textComponent.getText();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase ANY_TEXT:\\n\\t\\t\\t\\ttext = textComponent.getText();\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tthrow new WTFError(mode);\\n\\t\\t}\\n\\t\\tif (text == null)\\n\\t\\t\\treturn;\\n\\t\\tif (text.isEmpty() && !showAll)\\n\\t\\t\\treturn;\\n\\t\\tif (!caseSensitive.get())\\n\\t\\t\\ttext = text.toUpperCase();\\n\\t\\tinit();\\n\\t\\tif (data.getList() == null)\\n\\t\\t\\treturn;\\n\\t\\tSet<AutoCompletionData.Item> allItems = new TreeSet<>();\\n\\t\\tallItems.addAll(data.getList());\\n\\t\\tMArrayList<AutoCompletionData.Item> items = new MArrayList<>(allItems.size());\\n\\t\\tfor (AutoCompletionData.Item i : allItems) {\\n\\t\\t\\tif (showAll || i.matches(text, caseSensitive.get(), mode))\\n\\t\\t\\t\\titems.add(i);\\n\\t\\t}\\n\\t\\tif (items.isEmpty()) {\\n\\t\\t\\thidePopupWindow();\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (window == null)\\n\\t\\t\\t\\twindow = new CompletionWindow();\\n\\t\\t\\twindow.init(this, textComponent);\\n\\t\\t\\twindow.show(items);\\n\\t\\t}\\n\\t}\\n\\tprivate void init() {\\n\\t\\tif (data == null) {\\n\\t\\t\\tdata = AutoCompletionData.load(id);\\n\\t\\t\\tif (data == null)\\n\\t\\t\\t\\tdata = new AutoCompletionData(id);\\n\\t\\t\\tdata.max = limit.get();\\n\\t\\t}\\n\\t}\\n\\tprivate void install() {\\n\\t\\tJTextComponent textComponent = textComponentRef.get();\\n\\t\\tif (textComponent == null)\\n\\t\\t\\treturn;\\n\\t\\ttextComponent.getDocument().addDocumentListener(new MDocumentAdapter<JTextComponent>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tprotected void onChange(final DocumentEvent e) {\\n\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\t(e.getType() == DocumentEvent.EventType.INSERT) ||\\n\\t\\t\\t\\t\\t(e.getType() == DocumentEvent.EventType.REMOVE)\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\tcomplete(false);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t\\ttextComponent.addKeyListener(new KeyAdapter() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic void keyPressed(final KeyEvent e) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif (showPopupOnUpDownKeyPress && (window == null) && (e.getModifiers() == 0)) {\\n\\t\\t\\t\\t\\tswitch (e.getKeyCode()) {\\n\\t\\t\\t\\t\\t\\tcase VK_UP:\\n\\t\\t\\t\\t\\t\\tcase VK_DOWN:\\n\\t\\t\\t\\t\\t\\t\\tcomplete(true);\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (window == null)\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\tswitch (e.getKeyCode()) {\\n\\t\\t\\t\\t\\tcase VK_ENTER:\\n\\t\\t\\t\\t\\t\\tAutoCompletionData.Item selection = window.list.getSelectedItem();\\n\\t\\t\\t\\t\\t\\tsetText(selection);\\n\\t\\t\\t\\t\\t\\tif ((selection != null) && consumeEnter.get())\\n\\t\\t\\t\\t\\t\\t\\te.consume();\\n\\t\\t\\t\\t\\t\\thidePopupWindow();\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase VK_ESCAPE:\\n\\t\\t\\t\\t\\t\\tcancel();\\n\\t\\t\\t\\t\\t\\te.consume();\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase VK_UP:\\n\\t\\t\\t\\t\\t\\tif (!window.list.isEmpty() && (window.list.getSelectedIndex() == 0))\\n\\t\\t\\t\\t\\t\\t\\twindow.list.setSelectedIndex(window.list.getItemCount() - 1, true);\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\twindow.list.selectRelativeIndex(-1, true);\\n\\t\\t\\t\\t\\t\\te.consume();\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase VK_DOWN:\\n\\t\\t\\t\\t\\t\\tif (!window.list.isEmpty() && (window.list.getSelectedIndex() == window.list.getItemCount() - 1))\\n\\t\\t\\t\\t\\t\\t\\twindow.list.setSelectedIndex(0, true);\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\twindow.list.selectRelativeIndex(+1, true);\\n\\t\\t\\t\\t\\t\\te.consume();\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t\\ttextComponent.addMouseListener(new MMouseAdapter() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic void mouseClicked(final MouseEvent e) {\\n\\t\\t\\t\\tif (window != null) {\\n\\t\\t\\t\\t\\thidePopupWindow();\\n\\t\\t\\t\\t\\te.consume();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t}\\n\\tprivate void setText(final AutoCompletionData.Item value) {\\n\\t\\tif (value == null)\\n\\t\\t\\treturn;\\n\\t\\tJTextComponent textComponent = textComponentRef.get();\\n\\t\\tif (textComponent == null)\\n\\t\\t\\treturn;\\n\\t\\tString text = value.text;\\n\\t\\ttry {\\n\\t\\t\\tenabled.no();\\n\\t\\t\\tswitch (mode) {\\n\\t\\t\\t\\tcase CURRENT_WORD:\\n\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\tint pos = textComponent.getCaretPosition();\\n\\t\\t\\t\\t\\t\\tint begin = Utilities.getWordStart(textComponent, pos);\\n\\t\\t\\t\\t\\t\\tint end = Utilities. getWordEnd(textComponent, begin);\\n\\t\\t\\t\\t\\t\\tString part1 = textComponent.getText(begin, end - begin);\\n\\t\\t\\t\\t\\t\\tString part2 = text.substring(part1.length());\\n\\t\\t\\t\\t\\t\\ttextComponent.getDocument().insertString(pos, part2, null);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcatch (BadLocationException exception) { \\t\\t\\t\\t\\t\\tupdateText(text);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase ANY_TEXT:\\n\\t\\t\\t\\t\\tupdateText(text);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tthrow new WTFError(mode);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally {\\n\\t\\t\\tenabled.yes();\\n\\t\\t}\\n\\t}\\n\\tprivate void updateText(final String text) {\\n\\t\\tJTextComponent textComponent = textComponentRef.get();\\n\\t\\tif (textComponent == null)\\n\\t\\t\\treturn;\\n\\t\\ttry {\\n\\t\\t\\ttextComponent.getDocument().putProperty(TEXT_COMPONENT_IN_UPDATE_PROPERTY, true);\\n\\t\\t\\ttextComponent.setText(text);\\n\\t\\t}\\n\\t\\tfinally {\\n\\t\\t\\ttextComponent.getDocument().putProperty(TEXT_COMPONENT_IN_UPDATE_PROPERTY, null);\\n\\t\\t}\\n\\t}\\n\\tpublic static final class HistoryAction extends MDataAction.Weak<JTextComponent> {\\n\\t\\tpublic HistoryAction(final JTextComponent textComponent) {\\n\\t\\t\\tsuper(textComponent, _(\\\"History...\\\"));\\n\\t\\t}\\n\\t\\t@Override\\n\\t\\tpublic void onAction() {\\n\\t\\t\\tJTextComponent textComponent = get();\\n\\t\\t\\tHistoryDialog dialog = new HistoryDialog(getSourceWindow(), textComponent);\\n\\t\\t\\tif (dialog.exec(dialog.filter)) {\\n\\t\\t\\t\\tAutoCompletionData.Item item = dialog.list.getSelectedItem();\\n\\t\\t\\t\\tif (item != null) {\\n\\t\\t\\t\\t\\ttextComponent.setText(item.text);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tpublic static interface Renderer {\\n\\t\\tpublic void onRender(final MRenderer<AutoCompletionData.Item> listRenderer, final AutoCompletionData.Item value);\\n\\t}\\n\\tprivate static class CompletionList extends MList<AutoCompletionData.Item> {\\n\\t\\tprivate WeakReference<AutoCompletion.Renderer> userRendererRef;\\n\\t\\tprivate CompletionList() {\\n\\t\\t\\tMRenderer<AutoCompletionData.Item> renderer = new MRenderer<AutoCompletionData.Item>() {\\n\\t\\t\\t\\t@Override\\n\\t\\t\\t\\tprotected void onRender(final AutoCompletionData.Item value) {\\n\\t\\t\\t\\t\\tthis.setText(value.toString());\\n\\t\\t\\t\\t\\tAutoCompletion.Renderer userRenderer =\\n\\t\\t\\t\\t\\t\\t(CompletionList.this.userRendererRef == null)\\n\\t\\t\\t\\t\\t\\t? null\\n\\t\\t\\t\\t\\t\\t: CompletionList.this.userRendererRef.get();\\n\\t\\t\\t\\t\\tif (userRenderer != null)\\n\\t\\t\\t\\t\\t\\tuserRenderer.onRender(this, value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\trenderer.setHTMLEnabled(false);\\n\\t\\t\\tsetCellRenderer(renderer, new AutoCompletionData.Item(\\\"X\\\"));\\n\\t\\t\\tsetSingleSelectionMode();\\n\\t\\t\\tsetText(AUTO_TEXT);\\n\\t\\t}\\n\\t}\\n\\tprivate static final class CompletionWindow {\\n\\t\\tprivate final AWTEventListener awtListener;\\n\\t\\tprivate boolean visible;\\n\\t\\tprivate final CompletionList list;\\n\\t\\tprivate Popup popup;\\n\\t\\tprivate String originalText;\\n\\t\\tprivate WeakReference<AutoCompletion> autoCompletionRef;\\n\\t\\tprivate WeakReference<JTextComponent> textComponentRef;\\n\\t\\tprivate CompletionWindow() {\\n\\t\\t\\tlist = new CompletionList() {\\n\\t\\t\\t\\t@Override\\n\\t\\t\\t\\tprotected void onAction() {\\n\\t\\t\\t\\t\\tif (getActionType() == ActionType.TRIGGER) {\\n\\t\\t\\t\\t\\t\\tAutoCompletion autoCompletion = getAutoCompletion();\\n\\t\\t\\t\\t\\t\\tif (autoCompletion.mode == AutoCompletion.Mode.CURRENT_WORD)\\n\\t\\t\\t\\t\\t\\t\\tautoCompletion.setText(getSelectedItem());\\n\\t\\t\\t\\t\\t\\tAutoCompletion.hidePopupWindow();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t@Override\\n\\t\\t\\t\\tprotected void onSelect() {\\n\\t\\t\\t\\t\\tAutoCompletion autoCompletion = getAutoCompletion();\\n\\t\\t\\t\\t\\tif (autoCompletion.mode != AutoCompletion.Mode.CURRENT_WORD)\\n\\t\\t\\t\\t\\t\\tautoCompletion.setText(getSelectedItem());\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\tlist.addKeyListener(new KeyAdapter() {\\n\\t\\t\\t\\t@Override\\n\\t\\t\\t\\tpublic void keyPressed(final KeyEvent e) {\\n\\t\\t\\t\\t\\tif (e.getKeyCode() == VK_ESCAPE) {\\n\\t\\t\\t\\t\\t\\tgetAutoCompletion().cancel();\\n\\t\\t\\t\\t\\t\\tJTextComponent textComponent = getTextComponent();\\n\\t\\t\\t\\t\\t\\tif (textComponent != null)\\n\\t\\t\\t\\t\\t\\t\\ttextComponent.requestFocusInWindow();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t\\tawtListener = new AWTEventListener() {\\n\\t\\t\\t\\tpublic void eventDispatched(final AWTEvent e) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (e instanceof FocusEvent) {\\n\\t\\t\\t\\t\\t\\tFocusEvent fe = (FocusEvent)e;\\n\\t\\t\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\t\\t\\t(fe.getID() == FocusEvent.FOCUS_GAINED) &&\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(fe.getComponent() != CompletionWindow.this.list)\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t\\tAutoCompletion.hidePopupWindow();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\telse if (e instanceof ComponentEvent) {\\n\\t\\t\\t\\t\\t\\tComponentEvent ce = (ComponentEvent)e;\\n\\t\\t\\t\\t\\t\\tComponent c = ce.getComponent();\\n\\t\\t\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\t\\t\\t((c instanceof MDialog) || (c instanceof MFrame) || (c instanceof MWindow)) &&\\n\\t\\t\\t\\t\\t\\t\\t(\\n\\t\\t\\t\\t\\t\\t\\t\\t(ce.getID() == ComponentEvent.COMPONENT_HIDDEN) ||\\n\\t\\t\\t\\t\\t\\t\\t\\t(ce.getID() == ComponentEvent.COMPONENT_MOVED)\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\t\\t\\tAutoCompletion.hidePopupWindow();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\tToolkit.getDefaultToolkit().addAWTEventListener(awtListener, AWTEvent.COMPONENT_EVENT_MASK | AWTEvent.FOCUS_EVENT_MASK);\\n\\t\\t}\\n\\t\\tprivate void destroy() {\\n\\t\\t\\toriginalText = null;\\n\\t\\t\\t\\t\\t\\tif (popup != null)\\n\\t\\t\\t\\tpopup.hide();\\n\\t\\t\\tToolkit.getDefaultToolkit().removeAWTEventListener(awtListener);\\n\\t\\t}\\n\\t\\tprivate AutoCompletion getAutoCompletion() {\\n\\t\\t\\treturn autoCompletionRef.get();\\n\\t\\t}\\n\\t\\tprivate JTextComponent getTextComponent() {\\n\\t\\t\\treturn textComponentRef.get();\\n\\t\\t}\\n\\t\\tprivate void init(final AutoCompletion autoCompletion, final JTextComponent owner) {\\n\\t\\t\\tautoCompletionRef = new WeakReference<>(autoCompletion);\\n\\t\\t\\ttextComponentRef = new WeakReference<>(owner);\\n\\t\\t\\tlist.userRendererRef = new WeakReference<>(autoCompletion.userRenderer);\\n\\t\\t}\\n\\t\\tprivate void show(final List<AutoCompletionData.Item> items) {\\n\\t\\t\\tlist.clear();\\n\\t\\t\\tlist.addAllItems(items);\\n\\t\\t\\tif (!visible) {\\n\\t\\t\\t\\tJTextComponent owner = getTextComponent();\\n\\t\\t\\t\\toriginalText = owner.getText();\\n\\t\\t\\t\\t\\t\\t\\t\\tPoint location = SwingUtilities.convertPoint(owner, list.getLocation(), list);\\n\\t\\t\\t\\tlocation.setLocation(location.x, location.y + owner.getHeight());\\n\\t\\t\\t\\t\\t\\t\\t\\tMScrollPane content = new MScrollPane(list, MScrollPane.NO_BORDER);\\n\\t\\t\\t\\t\\t\\t\\t\\tif (!UI.isGTK()) {\\n\\t\\t\\t\\t\\tColor borderColor = MColor.getContrast(UI.getBackground(list));\\n\\t\\t\\t\\t\\tcontent.setBorder(BorderFactory.createLineBorder(borderColor, 1));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tDimension size = new Dimension(\\n\\t\\t\\t\\t\\tMath.max(owner.getWidth(), 200),\\n\\t\\t\\t\\t\\tlist.getFixedCellHeight() * Math.min(10, Math.max(list.getItemCount(), 5)) + 4\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\tif ((location.y + size.height) > UI.getScreenSize().height) {\\n\\t\\t\\t\\t\\tlocation.y -= (size.height + owner.getHeight());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tAutoCompletion ac = getAutoCompletion();\\n\\t\\t\\t\\t\\tif (ac != null)\\n\\t\\t\\t\\t\\t\\tlocation.y += ac.yOffset.get();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\tMComponent.setFixedSize(content, size.width, size.height);\\n\\t\\t\\t\\t\\t\\t\\t\\tpopup = PopupFactory.getSharedInstance().getPopup(owner, content, location.x, location.y);\\n\\t\\t\\t\\tpopup.show();\\n\\t\\t\\t\\tvisible = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tprivate static final class HistoryDialog extends MDialog {\\n\\t\\tprivate final AutoCompletion autoCompletion;\\n\\t\\tprivate final CompletionList list;\\n\\t\\tprivate final MSearchPanel filter;\\n\\t\\t@Override\\n\\t\\tprotected void onUserClick() {\\n\\t\\t\\tautoCompletion.clear();\\n\\t\\t\\tlist.clear();\\n\\t\\t}\\n\\t\\tprivate HistoryDialog(final Window owner, final JTextComponent textComponent) {\\n\\t\\t\\tsuper(owner, _(\\\"History\\\"), STANDARD_DIALOG | USER_BUTTON);\\n\\t\\t\\tlist = new CompletionList() {\\n\\t\\t\\t\\t@Override\\n\\t\\t\\t\\tprotected void onAction() {\\n\\t\\t\\t\\t\\tif (this.getActionType() == ActionType.TRIGGER) {\\n\\t\\t\\t\\t\\t\\tHistoryDialog dialog = (HistoryDialog)UI.windowFor(this);\\n\\t\\t\\t\\t\\t\\tdialog.accept(); \\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\tfilter = new MSearchPanel(false, MSearchPanel.Type.FILTER) {\\n\\t\\t\\t\\t@Override\\n\\t\\t\\t\\tprotected void onChange(final DocumentEvent e) {\\n\\t\\t\\t\\t\\tHistoryDialog dialog = (HistoryDialog)UI.windowFor(this);\\n\\t\\t\\t\\t\\tdialog.list.filter(this, dialog.autoCompletion.data.getList(), new MList.Filter<AutoCompletionData.Item, String>(this.getText()) {\\n\\t\\t\\t\\t\\t\\tpublic boolean include(final AutoCompletionData.Item item) {\\n\\t\\t\\t\\t\\t\\t\\treturn TK.containsIgnoreCase(item.text, this.getFilter());\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\tfilter.setList(list);\\n\\t\\t\\tautoCompletion = MText.getAutoCompletion(textComponent);\\n\\t\\t\\tautoCompletion.init(); \\t\\t\\tif (!TK.isEmpty(autoCompletion.data.getList())) {\\n\\t\\t\\t\\tlist.addAllItems(autoCompletion.data.getList());\\n\\t\\t\\t\\tlist.sort();\\n\\t\\t\\t\\tlist.setSelectedIndex(0);\\n\\t\\t\\t}\\n\\t\\t\\tchangeButton(getOKButton(), _(\\\"Insert Selected Item\\\"));\\n\\t\\t\\tif (list.isEmpty())\\n\\t\\t\\t\\tgetUserButton().setEnabled(false);\\n\\t\\t\\tchangeButton(getUserButton(), MActionInfo.CLEAR_HISTORY);\\n\\t\\t\\tgetValidatorSupport().add(new ListSelectionValidator(list));\\n\\t\\t\\taddNorth(filter);\\n\\t\\t\\taddCenter(MPanel.createVLabelPanel(list, _(\\\"Items:\\\")));\\n\\t\\t\\tpackFixed(UI.WindowSize.MEDIUM);\\n\\t\\t}\\n\\t}\\n}\""
        },
        {
            "content": "The source code of `AutoCompletion.java` reveals that it is a component responsible for providing auto-completion functionality in text components within the Makagiga application. Here are some key observations:\n\n### Key Observations:\n1. **Dependencies and Imports**:\n   - The class imports several components from the `org.makagiga.commons` and `org.makagiga.commons.swing` packages, indicating integration with other parts of the Makagiga framework.\n   - Notably, it references `MText`, which was previously removed from the project.\n\n2. **Usage of `MText`**:\n   - Line `import org.makagiga.commons.swing.MText;`: This indicates that `AutoCompletion.java` directly depends on `MText.java`.\n   - There are usages of `MText.getAutoCompletion(...)`, suggesting that `AutoCompletion` may have historically relied on `MText` to function properly.\n   - Since `MText.java` has been removed, this raises concerns about how `AutoCompletion.java` behaves without it.\n\n3. **Implications of Removal**:\n   - If `MText` was central to managing auto-completion in text components, its removal could mean that either:\n     - Functionality has been refactored into another class or mechanism.\n     - AutoCompletion might be broken or incomplete if no replacement exists.\n\n4. **Next Steps**:\n   - Investigate whether there's a new or alternative implementation that replaces the role of `MText` in handling auto-completion logic.\n   - Analyze the call graph of `AutoCompletion.java` to see what classes interact with it, especially looking for any potential replacements for `MText`.\n\nLet\u2019s retrieve the call graph for `AutoCompletion.java` to identify which entities use it and possibly uncover newer dependencies that may have replaced the link to `MText.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_6e3dd4772b6f4899a4a353",
                    "function": {
                        "arguments": "{\"entity\": \"AutoCompletion.java\"}",
                        "name": "get_call_graph"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_call_graph",
            "content": "[\"FS\", \"TK\", \"IntegerProperty\", \"UI\", \"BooleanProperty\"]"
        },
        {
            "content": "The call graph for `AutoCompletion.java` reveals that it interacts with the following entities:\n\n1. **FS** \u2013 Likely related to file system operations.\n2. **TK** \u2013 Possibly a utility or toolkit class for common functions.\n3. **IntegerProperty** \u2013 Used for managing integer-based properties.\n4. **UI** \u2013 Related to user interface components and utilities.\n5. **BooleanProperty** \u2013 Used for managing boolean-based properties.\n\nThese entities appear to be general utility or configuration-related classes, which suggests that `AutoCompletion.java` relies on foundational libraries rather than direct UI components like `MText.java`.\n\n### Analysis:\n- The absence of any recent UI-related text component in the call graph (that could have replaced `MText.java`) indicates that either:\n  - The functionality previously tied to `MText` has been abstracted into a different mechanism not directly visible here.\n  - There may be a gap in functionality if `AutoCompletion` still expects certain behaviors from `MText`, now removed.\n\n### Next Steps:\nTo better understand how `AutoCompletion` is used in the current system and whether it's affected by the removal of `MText`, we should:\n1. Examine the source code of `UI.java` and `TK.java`, as they are central to the current behavior of `AutoCompletion`.\n2. Specifically look for any references or replacements for text-component handling that might have superseded `MText`.\n\nWe'll start by retrieving the origin code for `UI.java`, as it likely contains UI-related utilities or configurations critical to `AutoCompletion`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_0e20a2483b6e4370a77622",
                    "function": {
                        "arguments": "{\"entity\": \"UI.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package org.makagiga.commons;\\nimport static java.awt.event.KeyEvent.*;\\nimport java.awt.BasicStroke;\\nimport java.awt.BorderLayout;\\nimport java.awt.Color;\\nimport java.awt.Component;\\nimport java.awt.ComponentOrientation;\\nimport java.awt.Container;\\nimport java.awt.Cursor;\\nimport java.awt.Dimension;\\nimport java.awt.EventQueue;\\nimport java.awt.Font;\\nimport java.awt.FontMetrics;\\nimport java.awt.Graphics2D;\\nimport java.awt.GraphicsConfiguration;\\nimport java.awt.GraphicsDevice;\\nimport java.awt.GraphicsEnvironment;\\nimport java.awt.Image;\\nimport java.awt.Insets;\\nimport java.awt.Point;\\nimport java.awt.Rectangle;\\nimport java.awt.RenderingHints;\\nimport java.awt.Shape;\\nimport java.awt.Stroke;\\nimport java.awt.SystemColor;\\nimport java.awt.Toolkit;\\nimport java.awt.Transparency;\\nimport java.awt.Window;\\nimport java.awt.event.KeyEvent;\\nimport java.awt.event.MouseEvent;\\nimport java.awt.image.BufferedImage;\\nimport java.awt.image.VolatileImage;\\nimport java.beans.PropertyChangeEvent;\\nimport java.beans.PropertyChangeListener;\\nimport java.lang.ref.WeakReference;\\nimport java.lang.reflect.InvocationTargetException;\\nimport java.text.ParseException;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.concurrent.Callable;\\nimport javax.swing.AbstractButton;\\nimport javax.swing.Action;\\nimport javax.swing.ActionMap;\\nimport javax.swing.BorderFactory;\\nimport javax.swing.Box;\\nimport javax.swing.ButtonGroup;\\nimport javax.swing.FocusManager;\\nimport javax.swing.Icon;\\nimport javax.swing.JComponent;\\nimport javax.swing.JLayer;\\nimport javax.swing.JScrollPane;\\nimport javax.swing.JTextField;\\nimport javax.swing.LookAndFeel;\\nimport javax.swing.Scrollable;\\nimport javax.swing.SwingConstants;\\nimport javax.swing.SwingUtilities;\\nimport javax.swing.UIDefaults;\\nimport javax.swing.UIManager;\\nimport javax.swing.border.Border;\\nimport javax.swing.plaf.BorderUIResource;\\nimport javax.swing.plaf.ButtonUI;\\nimport javax.swing.plaf.ColorUIResource;\\nimport javax.swing.plaf.metal.MetalLookAndFeel;\\nimport javax.swing.plaf.metal.OceanTheme;\\nimport javax.swing.plaf.synth.SynthLookAndFeel;\\nimport javax.swing.text.JTextComponent;\\nimport makagiga.commons.DropShadowBorder;\\nimport org.makagiga.commons.annotation.ConfigEntry;\\nimport org.makagiga.commons.annotation.Important;\\nimport org.makagiga.commons.annotation.Uninstantiable;\\nimport org.makagiga.commons.style.Style;\\nimport org.makagiga.commons.swing.MLinkAction;\\nimport org.makagiga.commons.swing.MScrollPane;\\nimport org.makagiga.commons.swing.MToolBar;\\nimport org.makagiga.commons.swing.MainView;\\npublic final class UI implements SwingConstants {\\n\\t@ConfigEntry(\\\"UI.animations\\\")\\n\\tpublic static final BooleanProperty animations = new BooleanProperty(true);\\n\\t@ConfigEntry(value = \\\"UI.buttonIcons\\\", platform = true)\\n\\tpublic static final BooleanProperty buttonIcons = new BooleanProperty(true);\\n\\t@ConfigEntry(value = \\\"UI.customFont\\\", platform = true)\\n\\tpublic static final FontProperty customFont = new FontProperty();\\n\\t@ConfigEntry(value = \\\"UI.hideMainWindowInTray\\\", platform = true)\\n\\tpublic static final BooleanProperty hideMainWindowInTray = new BooleanProperty();\\n\\t@ConfigEntry(\\\"UI.iconSize\\\")\\n\\tpublic static final IntegerProperty iconSize = new IntegerProperty(24);\\n\\t@ConfigEntry(\\\"UI.mouseGestures\\\")\\n\\tpublic static final BooleanProperty mouseGestures = new BooleanProperty(true);\\n\\t@ConfigEntry(value = \\\"UI.okCancelLayout\\\", platform = true)\\n\\tpublic static final EnumProperty<OKCancelLayout> okCancelLayout = new EnumProperty<>(OKCancelLayout.AUTO);\\n\\t@ConfigEntry(value = \\\"UI.systemTray\\\", platform = true)\\n\\tpublic static final BooleanProperty systemTray = new BooleanProperty(false);\\n\\t@ConfigEntry(\\\"UI.toolBarTextPosition\\\")\\n\\tpublic static final EnumProperty<MToolBar.TextPosition> toolBarTextPosition = new EnumProperty<>(MToolBar.TextPosition.UNDER_ICONS);\\n\\t@ConfigEntry(value = \\\"UI.useCustomFont\\\", platform = true)\\n\\tpublic static final BooleanProperty useCustomFont = new BooleanProperty();\\n\\t@ConfigEntry(value = \\\"UI.notificationSnapRight\\\", platform = true)\\n\\tpublic static final EnumProperty<HorizontalPosition> horizontalNotificationPosition = new EnumProperty<>(HorizontalPosition.RIGHT);\\n\\t@ConfigEntry(value = \\\"UI.notificationSnapBottom\\\", platform = true)\\n\\tpublic static final EnumProperty<VerticalPosition> verticalNotificationPosition = new EnumProperty<>(VerticalPosition.BOTTOM);\\n\\t@ConfigEntry(value = \\\"UI.notificationX\\\", platform = true)\\n\\tpublic static final IntegerProperty notificationX = new IntegerProperty(-1);\\n\\t@ConfigEntry(value = \\\"UI.notificationY\\\", platform = true)\\n\\tpublic static final IntegerProperty notificationY = new IntegerProperty(-1);\\n\\t@ConfigEntry(value = \\\"UI.notificationTransparent\\\", platform = true)\\n\\tpublic static final BooleanProperty notificationTransparent = new BooleanProperty(true);\\n\\t@ConfigEntry(\\\"UI.statusBarTimeout\\\")\\n\\tpublic static final IntegerProperty statusBarTimeout = new IntegerProperty(10);\\n\\t@ConfigEntry(\\\"UI.customColor\\\")\\n\\tpublic static final ColorProperty customColor = new ColorProperty();\\n\\t@ConfigEntry(\\\"UI.useCustomColor\\\")\\n\\tpublic static final BooleanProperty useCustomColor = new BooleanProperty();\\n\\tpublic static final Color INVISIBLE = new Color(255, 255, 255, 0);\\n\\tpublic static final Color TOOL_TIP_BACKGROUND_COLOR = new Color(0xffffdc);\\n\\tpublic static final Color TOOL_TIP_FOREGROUND_COLOR = Color.BLACK;\\n\\tpublic static final Color TRANSPARENT_BLACK = new Color(0, 0, 0, 127);\\n\\tpublic static final Color TRANSPARENT_GRAY = new Color(127, 127, 127, 127);\\n\\tpublic static final Color TRANSPARENT_WHITE = new Color(255, 255, 255, 127);\\n\\tpublic static final String DYNAMIC_TOOL_TIP_TEXT = \\\"\\\";\\n\\tpublic enum HorizontalPosition { LEFT, RIGHT };\\n\\tpublic enum OKCancelLayout {\\n\\t\\tAUTO, OK_CANCEL, CANCEL_OK;\\n\\t\\tpublic static OKCancelLayout getDefault() {\\n\\t\\t\\tif (OS.isGNOME() || OS.isMac() || OS.isXfce() || OS.isLXDE() || OS.isUnity())\\n\\t\\t\\t\\treturn CANCEL_OK;\\n\\t\\t\\treturn OK_CANCEL;\\n\\t\\t}\\n\\t\\tpublic static boolean isReversed() {\\n\\t\\t\\tif (UI.okCancelLayout.get() == AUTO)\\n\\t\\t\\t\\treturn getDefault() == CANCEL_OK;\\n\\t\\t\\treturn UI.okCancelLayout.get() == CANCEL_OK;\\n\\t\\t}\\n\\t\\tpublic static void setupUI(final UIDefaults defaults) {\\n\\t\\t\\tdefaults.put(\\\"OptionPane.isYesLast\\\", isReversed());\\n\\t\\t}\\n\\t\\t@Override\\n\\t\\tpublic String toString() {\\n\\t\\t\\tswitch (this) {\\n\\t\\t\\t\\tcase AUTO: return _(\\\"Auto\\\");\\n\\t\\t\\t\\tcase OK_CANCEL: return MActionInfo.OK.getText() + \\\" - \\\" + MActionInfo.CANCEL.getText();\\n\\t\\t\\t\\tcase CANCEL_OK: return MActionInfo.CANCEL.getText() + \\\" - \\\" + MActionInfo.OK.getText();\\n\\t\\t\\t\\tdefault: throw new WTFError(this);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\tpublic enum Quality { LOW, MEDIUM, HIGH };\\n\\tpublic enum ToolTipLocationPolicy {\\n\\t\\tDEFAULT,\\n\\t\\tALONGSIDE,\\n\\t\\tALONGSIDE_PARENT,\\n\\t\\tABOVE,\\n\\t\\tUNDER;\\n\\t\\tpublic Point getLocation(final Component c, final MouseEvent e) {\\n\\t\\t\\tswitch (this) {\\n\\t\\t\\t\\tcase DEFAULT: return null;\\n\\t\\t\\t\\tcase ALONGSIDE: return new Point(c.getWidth() + 5, 0);\\n\\t\\t\\t\\tcase ALONGSIDE_PARENT:\\n\\t\\t\\t\\t\\tContainer parent = c.getParent();\\n\\t\\t\\t\\t\\tif (parent == null)\\n\\t\\t\\t\\t\\t\\treturn null;\\n\\t\\t\\t\\t\\treturn new Point(parent.getWidth() - c.getX(), 0);\\n\\t\\t\\t\\tcase ABOVE:\\n\\t\\t\\t\\t\\tFont f = UI.getFont(c);\\n\\t\\t\\t\\t\\treturn new Point(0, -(f.getSize() + 10));\\n\\t\\t\\t\\tcase UNDER: return new Point(0, c.getHeight() + 5);\\n\\t\\t\\t\\tdefault: throw new WTFError(this);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tprivate static final int SIZE_VARIANT_SUPPORTED = 1;\\n\\tprivate static final int HAS_ALTERNATE_LIST_ROW_COLOR = 1 << 1;\\n\\tprivate static final int HAS_ALTERNATE_TREE_ROW_COLOR = 1 << 2;\\n\\tprivate static final int HAS_ALTERNATE_TABLE_ROW_COLOR = 1 << 3;\\n\\tprivate static final int NO_CELL_TIP_SUPPORT = 1 << 4;\\n\\tpublic enum LookAndFeelType {\\n\\t\\tUNKNOWN(0),\\n\\t\\tGTK(NO_CELL_TIP_SUPPORT ),\\n\\t\\tMETAL(0),\\n\\t\\tSUBSTANCE(NO_CELL_TIP_SUPPORT),\\n\\t\\tWINDOWS(0),\\n\\t\\tNIMBUS(SIZE_VARIANT_SUPPORTED),\\n\\t\\tLIPSTIK(0),\\n\\t\\tA03(HAS_ALTERNATE_LIST_ROW_COLOR | HAS_ALTERNATE_TABLE_ROW_COLOR | HAS_ALTERNATE_TREE_ROW_COLOR),\\n\\t\\tSEA_GLASS(HAS_ALTERNATE_TABLE_ROW_COLOR | SIZE_VARIANT_SUPPORTED),\\n\\t\\tRETRO(NO_CELL_TIP_SUPPORT),\\n\\t\\tQUAQUA(0),\\n\\t\\tMAC(SIZE_VARIANT_SUPPORTED),\\n\\t\\tPGS(0);\\n\\t\\tprivate Flags flags;\\n\\t\\tpublic boolean hasAlternateListRowColor() { return flags.isSet(HAS_ALTERNATE_LIST_ROW_COLOR); }\\n\\t\\tpublic boolean hasAlternateTableRowColor() { return flags.isSet(HAS_ALTERNATE_TABLE_ROW_COLOR); }\\n\\t\\tpublic boolean hasAlternateTreeRowColor() { return flags.isSet(HAS_ALTERNATE_TREE_ROW_COLOR); }\\n\\t\\tpublic boolean isCellTipSupported() { return flags.isClear(NO_CELL_TIP_SUPPORT); }\\n\\t\\tpublic boolean isSizeVariantSupported() { return flags.isSet(SIZE_VARIANT_SUPPORTED); }\\n\\t\\tprivate LookAndFeelType(final int flags) {\\n\\t\\t\\tthis.flags = Flags.valueOf(flags);\\n\\t\\t}\\n\\t};\\n\\tpublic enum SizeVariant {\\n\\t\\tNORMAL(null),\\n\\t\\tMINI(\\\"mini\\\"),\\n\\t\\tSMALL(\\\"small\\\"),\\n\\t\\tLARGE(\\\"large\\\");\\n\\t\\tprivate final String value;\\n\\t\\tpublic void apply(final JComponent c) {\\n\\t\\t\\tc.putClientProperty(\\\"JComponent.sizeVariant\\\", value);\\n\\t\\t}\\n\\t\\t@Important\\n\\t\\t@Override\\n\\t\\tpublic String toString() { return value; }\\n\\t\\tprivate SizeVariant(final String value) {\\n\\t\\t\\tthis.value = value;\\n\\t\\t}\\n\\t};\\n\\tpublic enum VerticalPosition { TOP, BOTTOM };\\n\\tpublic enum WindowSize {\\n\\t\\tMEDIUM,\\n\\t\\tLARGE,\\n\\t\\tSCREEN,\\n\\t\\tSMALL;\\n\\t\\tpublic Dimension getDimension() {\\n\\t\\t\\tDimension d = new Dimension();\\n\\t\\t\\tDimension screen = UI.getScreenSize();\\n\\t\\t\\tswitch (this) {\\n\\t\\t\\t\\tcase MEDIUM:\\n\\t\\t\\t\\t\\td.width = (int)(screen.width / 1.6f);\\n\\t\\t\\t\\t\\td.height = (int)(screen.height / 1.6f);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase LARGE:\\n\\t\\t\\t\\t\\td.width = (int)(screen.width / 1.28);\\n\\t\\t\\t\\t\\td.height = (int)(screen.height / 1.28);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase SCREEN:\\n\\t\\t\\t\\t\\td.setSize(screen);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase SMALL:\\n\\t\\t\\t\\t\\td.width = (int)(screen.width / 2.0f);\\n\\t\\t\\t\\t\\td.height = (int)(screen.height / 2.0f);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tthrow new WTFError(this);\\n\\t\\t\\t}\\n\\t\\t\\treturn d;\\n\\t\\t}\\n\\t\\tpublic Dimension getDimensionForDialog() {\\n\\t\\t\\tDimension d = getDimension();\\n\\t\\t\\tswitch (this) {\\n\\t\\t\\t\\tcase MEDIUM:\\n\\t\\t\\t\\t\\td.width = Math.min(d.width, 800);\\n\\t\\t\\t\\t\\td.height = Math.min(d.height, 600);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase LARGE:\\n\\t\\t\\t\\t\\td.width = Math.min(d.width, 1024);\\n\\t\\t\\t\\t\\td.height = Math.min(d.height, 768);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase SMALL:\\n\\t\\t\\t\\t\\td.width = Math.min(d.width, 640);\\n\\t\\t\\t\\t\\td.height = Math.min(d.height, 480);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\treturn d;\\n\\t\\t}\\n\\t\\tpublic int getHeight() {\\n\\t\\t\\treturn getDimension().height;\\n\\t\\t}\\n\\t\\tpublic int getWidth() {\\n\\t\\t\\treturn getDimension().width;\\n\\t\\t}\\n\\t};\\n\\tpublic static final int PAINT_TEXT_TRIM_LINES = 1;\\n\\tpublic static final String HTML_BEGIN = \\\"<html><body>\\\";\\n\\tpublic static final String HTML_END = \\\"</body></html>\\\";\\n\\tpublic static final String LEFT_POINTER = \\\"\\\\u25c4\\\";\\n\\tpublic static final String RIGHT_POINTER = \\\"\\\\u25ba\\\";\\n\\tpublic static final String TM = \\\"\\\\u2122\\\";\\n\\tprivate static BasicStroke basicFocusStroke;\\n\\tprivate static boolean synth;\\n\\tprivate static boolean textAAInitialized;\\n\\tprivate static Cursor invisibleCursor;\\n\\tprivate static Font customFontValue;\\n\\tprivate static Font _defaultFont;\\n\\tprivate static LookAndFeelType lookAndFeelType;\\n\\tprivate static Map<Object, Object> textAA;\\n\\t@SuppressWarnings(\\\"PMD.ShortMethodName\\\")\\n\\tpublic static String _(final String id) {\\n\\t\\treturn Gettext.translate(id);\\n\\t}\\n\\t@SuppressWarnings(\\\"PMD.ShortMethodName\\\")\\n\\tpublic static String _(final String id, final Object... args) {\\n\\t\\treturn Gettext._(id, args);\\n\\t}\\n\\tpublic static void addCenter(final Container parent, final JComponent component) {\\n\\t\\tif (needScrollPane(component))\\n\\t\\t\\tparent.add(new MScrollPane(component), BorderLayout.CENTER);\\n\\t\\telse\\n\\t\\t\\tparent.add(component, BorderLayout.CENTER);\\n\\t}\\n\\tpublic static Font changeFontSize(final Component component, final int relativeSize) {\\n\\t\\treturn changeFontSize(component, relativeSize, 11, 40);\\n\\t}\\n\\tpublic static Font changeFontSize(final Component component, final int relativeSize, final int minimum, final int maximum) {\\n\\t\\tFont oldFont = component.getFont();\\n\\t\\tif (oldFont == null)\\n\\t\\t\\treturn null;\\n\\t\\tif (relativeSize == 0)\\n\\t\\t\\treturn oldFont;\\n\\t\\tint newSize = oldFont.getSize() + relativeSize;\\n\\t\\tif (minimum != -1)\\n\\t\\t\\tnewSize = Math.max(newSize, minimum);\\n\\t\\tif (maximum != -1)\\n\\t\\t\\tnewSize = Math.min(newSize, maximum);\\n\\t\\tif (newSize == oldFont.getSize())\\n\\t\\t\\treturn oldFont;\\n\\t\\tFont newFont = oldFont.deriveFont((float)newSize);\\n\\t\\tcomponent.setFont(newFont);\\n\\t\\treturn newFont;\\n\\t}\\n\\tpublic synchronized static Font createDefaultFont() {\\n\\t\\tif (_defaultFont == null)\\n\\t\\t\\t_defaultFont = new Font(Font.DIALOG, Font.PLAIN, getDefaultFontSize());\\n\\t\\treturn _defaultFont;\\n\\t}\\n\\tpublic static Border createDropShadowBorder() {\\n\\t\\treturn new DropShadowBorder();\\n\\t}\\n\\tpublic static Border createEmptyBorder(final int size) {\\n\\t\\treturn BorderFactory.createEmptyBorder(size, size, size, size);\\n\\t}\\n\\tpublic static JComponent createGap(final int w, final int h) {\\n\\t\\treturn (JComponent)Box.createRigidArea(new Dimension(w, h));\\n\\t}\\n\\tpublic static List<Object> createGradient(final Color color1, final Color color2) {\\n\\t\\treturn createGradient(1.0f, 0.0f, color1, color2);\\n\\t}\\n\\t\\t\\t\\tpublic static List<Object> createGradient(final float firstGradient, final float filledRegion, final Color color1, final Color color2) {\\n\\t\\treturn new MArrayList<Object>(\\n\\t\\t\\tfirstGradient,\\n\\t\\t\\tfilledRegion,\\n\\t\\t\\tnew ColorUIResource(color1),\\n\\t\\t\\tnew ColorUIResource(color2),\\n\\t\\t\\tnew ColorUIResource(color1)\\n\\t\\t);\\n\\t}\\n\\tpublic static Insets createInsets(final int size) {\\n\\t\\treturn new Insets(size, size, size, size);\\n\\t}\\n\\tpublic static Font createMonospacedFont(final int size) {\\n\\t\\tString name;\\n\\t\\tif (OS.isWindows())\\n\\t\\t\\tname = \\\"Consolas\\\";\\n\\t\\telse\\n\\t\\t\\tname = \\\"DejaVu Sans Mono\\\";\\n\\t\\tFont f = new Font(name, Font.PLAIN, size);\\n\\t\\t\\t\\tif (f.getFamily().equals(Font.DIALOG))\\n\\t\\t\\treturn new Font(Font.MONOSPACED, Font.PLAIN, size);\\n\\t\\treturn f;\\n\\t}\\n\\tpublic static Font deriveFontSize(final Font baseFont, final int newSize) {\\n\\t\\tif (baseFont.getSize() == newSize)\\n\\t\\t\\treturn baseFont;\\n\\t\\treturn baseFont.deriveFont((float)newSize);\\n\\t}\\n\\t@SuppressWarnings(\\\"unchecked\\\")\\n\\tpublic static <T extends Container> T getAncestorOfClass(final Class<T> containerClass, final Component c) {\\n\\t\\treturn (T)SwingUtilities.getAncestorOfClass(containerClass, c);\\n\\t}\\n\\tpublic static double getAutoScale(final Image image, final Dimension maxSize) {\\n\\t\\treturn getAutoScale(new Dimension(image.getWidth(null), image.getHeight(null)), maxSize);\\n\\t}\\n\\tpublic static double getAutoScale(final Dimension imageSize, final Dimension maxSize) {\\n\\t\\tdouble result;\\n\\t\\tif (imageSize.width > maxSize.width)\\n\\t\\t\\tresult = (double)maxSize.width / (double)imageSize.width;\\n\\t\\telse\\n\\t\\t\\tresult = 1.0d;\\n\\t\\tint height = (int)((double)imageSize.height * result);\\n\\t\\tif (height > maxSize.height)\\n\\t\\t\\tresult *= (double)maxSize.height / (double)height;\\n\\t\\treturn result;\\n\\t}\\n\\tpublic static Color getBackground(final Component c) {\\n\\t\\tColor result = c.getBackground();\\n\\t\\treturn (result == null) ? Color.WHITE : result;\\n\\t}\\n\\tpublic static Color getForeground(final Component c) {\\n\\t\\tColor result = c.getForeground();\\n\\t\\treturn (result == null) ? Color.BLACK : result;\\n\\t}\\n\\t@edu.umd.cs.findbugs.annotation.SuppressWarnings(\\\"OCP_OVERLY_CONCRETE_PARAMETER\\\")\\n\\tpublic static Color getBrighter(final Color color, final int percent, final Color safeColor) {\\n\\t\\treturn (color == null) ? safeColor : MColor.getBrighter(color, percent);\\n\\t}\\n\\t@SuppressWarnings(\\\"unchecked\\\")\\n\\tpublic static <T> T getClientProperty(final JComponent component, final String key, final T defaultValue) {\\n\\t\\tObject value = component.getClientProperty(key);\\n\\t\\treturn (value == null) ? defaultValue : (T)value;\\n\\t}\\n\\tpublic static Color getColor(final String key) {\\n\\t\\treturn UIManager.getColor(key);\\n\\t}\\n\\t@edu.umd.cs.findbugs.annotation.SuppressWarnings(\\\"OCP_OVERLY_CONCRETE_PARAMETER\\\")\\n\\tpublic static Color getColor(final Color color, final float factor, final Color safeColor) {\\n\\t\\treturn (color == null) ? safeColor : MColor.deriveColor(color, factor);\\n\\t}\\n\\t@edu.umd.cs.findbugs.annotation.SuppressWarnings(\\\"OCP_OVERLY_CONCRETE_PARAMETER\\\")\\n\\tpublic static Color getDarker(final Color color, final Color safeColor) {\\n\\t\\treturn (color == null) ? safeColor : MColor.getDarker(color);\\n\\t}\\n\\tpublic static int getDefaultFontSize() { return 12; }\\n\\tpublic static int getDialogButtonSpacing() { return 15; }\\n\\tpublic static Font getFont(final Component c) {\\n\\t\\tFont font = c.getFont();\\n\\t\\treturn (font != null) ? font : createDefaultFont();\\n\\t}\\n\\tpublic synchronized static Cursor getInvisibleCursor() {\\n\\t\\tif (invisibleCursor == null) {\\n\\t\\t\\tinvisibleCursor = Toolkit.getDefaultToolkit().createCustomCursor(\\n\\t\\t\\t\\tcreateCompatibleImage(1, 1, true),\\n\\t\\t\\t\\tnew Point(),\\n\\t\\t\\t\\t\\\"invisible\\\"\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\treturn invisibleCursor;\\n\\t}\\n\\tpublic static String getLinkToolTipText(final String url) {\\n\\t\\tif (url == null)\\n\\t\\t\\treturn null;\\n\\t\\tString linkTag = String.format(\\n\\t\\t\\t\\\"<a href=\\\\\\\"%s\\\\\\\" style=\\\\\\\"color: %s; text-decoration: none\\\\\\\">%s</a>\\\",\\n\\t\\t\\turl,\\n\\t\\t\\tColorProperty.toString(MColor.getLinkForeground(getColor(\\\"ToolTip.background\\\"))),\\n\\t\\t\\tTK.centerSqueeze(MLinkAction.simplifyURI(url), 128)\\n\\t\\t);\\n\\t\\treturn makeHTML(_(\\\"Open {0}\\\", linkTag));\\n\\t}\\n\\tprivate static LookAndFeelType detectLookAndFeelType() { \\t\\tLookAndFeel laf = UIManager.getLookAndFeel();\\n\\t\\tsynth = (laf instanceof SynthLookAndFeel);\\n\\t\\tString className = (laf == null) ? null : laf.getClass().getName();\\n\\t\\tif (className == null)\\n\\t\\t\\treturn LookAndFeelType.UNKNOWN;\\n\\t\\tswitch (className) {\\n\\t\\t\\t\\t\\t\\tcase \\\"com.sun.java.swing.plaf.gtk.GTKLookAndFeel\\\":\\n\\t\\t\\t\\treturn LookAndFeelType.GTK;\\n\\t\\t\\tcase \\\"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\\\":\\n\\t\\t\\tcase \\\"com.sun.java.swing.plaf.windows.WindowsClassicLookAndFeel\\\":\\n\\t\\t\\t\\treturn LookAndFeelType.WINDOWS;\\n\\t\\t\\tcase \\\"javax.swing.plaf.nimbus.NimbusLookAndFeel\\\":\\n\\t\\t\\t\\treturn LookAndFeelType.NIMBUS;\\n\\t\\t\\tcase \\\"apple.laf.AquaLookAndFeel\\\":\\n\\t\\t\\tcase \\\"com.apple.laf.AquaLookAndFeel\\\":\\n\\t\\t\\tcase \\\"com.apple.mrj.swing.MacLookAndFeel\\\":\\n\\t\\t\\t\\treturn LookAndFeelType.MAC;\\n\\t\\t\\t\\t\\t\\tcase \\\"a03.swing.plaf.A03LookAndFeel\\\":\\n\\t\\t\\t\\treturn LookAndFeelType.A03;\\n\\t\\t\\tcase \\\"ch.randelshofer.quaqua.QuaquaLookAndFeel\\\":\\n\\t\\t\\t\\treturn LookAndFeelType.QUAQUA;\\n\\t\\t\\tcase \\\"com.lipstikLF.LipstikLookAndFeel\\\":\\n\\t\\t\\t\\treturn LookAndFeelType.LIPSTIK;\\n\\t\\t\\tcase \\\"com.pagosoft.plaf.PgsLookAndFeel\\\":\\n\\t\\t\\t\\treturn LookAndFeelType.PGS;\\n\\t\\t\\tcase \\\"com.seaglasslookandfeel.SeaGlassLookAndFeel\\\":\\n\\t\\t\\t\\treturn LookAndFeelType.SEA_GLASS;\\n\\t\\t\\tcase \\\"org.makagiga.retro.RetroLookAndFeel\\\":\\n\\t\\t\\t\\treturn LookAndFeelType.RETRO;\\n\\t\\t}\\n\\t\\tif (\\n\\t\\t\\t(laf instanceof MetalLookAndFeel) &&\\n\\t\\t\\t(MetalLookAndFeel.getCurrentTheme() instanceof OceanTheme)\\n\\t\\t)\\n\\t\\t\\treturn LookAndFeelType.METAL;\\n\\t\\tif (\\n\\t\\t\\tclassName.startsWith(\\\"org.jvnet.substance.\\\") ||\\n\\t\\t\\t((laf != null) && laf.getName().startsWith(\\\"Substance \\\"))\\n\\t\\t)\\n\\t\\t\\treturn LookAndFeelType.SUBSTANCE;\\n\\t\\treturn LookAndFeelType.UNKNOWN;\\n\\t}\\n\\tpublic static LookAndFeelType getLookAndFeelType() {\\n\\t\\tsynchronized (UI.class) {\\n\\t\\t\\tif (lookAndFeelType == null)\\n\\t\\t\\t\\tlookAndFeelType = detectLookAndFeelType();\\n\\t\\t}\\n\\t\\treturn lookAndFeelType;\\n\\t}\\n\\tpublic static String getPreferredLookAndFeelClassName() {\\n\\t\\tString laf = UIManager.getSystemLookAndFeelClassName();\\n\\t\\tif (isBlacklisted(laf) || \\\"com.sun.java.swing.plaf.gtk.GTKLookAndFeel\\\".equals(laf))\\n\\t\\t\\tlaf = \\\"javax.swing.plaf.metal.MetalLookAndFeel\\\";\\n\\t\\t\\t\\tif (\\\"javax.swing.plaf.metal.MetalLookAndFeel\\\".equals(laf))\\n\\t\\t\\tlaf = \\\"javax.swing.plaf.nimbus.NimbusLookAndFeel\\\";\\n\\t\\treturn laf;\\n\\t}\\n\\tpublic static Dimension getScreenSize() {\\n\\t\\treturn Toolkit.getDefaultToolkit().getScreenSize();\\n\\t}\\n\\tpublic static Color getSelectionBackground() {\\n\\t\\tColor c;\\n\\t\\t\\t\\tif (isNimbus()) {\\n\\t\\t\\tc = getColor(\\\"textHighlight\\\");\\n\\t\\t\\tif (c != null)\\n\\t\\t\\t\\tc = new MColor(c);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tc = getColor(\\\"TextField.selectionBackground\\\");\\n\\t\\treturn (c == null) ? MColor.SKY_BLUE : c;\\n\\t}\\n\\tpublic static ButtonUI getSimpleButtonUI() {\\n\\t\\treturn LazySimpleButtonUIHolder.INSTANCE;\\n\\t}\\n\\tpublic static ButtonGroup group(final AbstractButton... buttons) {\\n\\t\\tButtonGroup buttonGroup = new ButtonGroup();\\n\\t\\tfor (AbstractButton i : buttons) {\\n\\t\\t\\tif (i != null)\\n\\t\\t\\t\\tbuttonGroup.add(i);\\n\\t\\t}\\n\\t\\treturn buttonGroup;\\n\\t}\\n\\tpublic static void hideToolTip(final JComponent c) {\\n\\t\\tActionMap am = c.getActionMap();\\n\\t\\tif (am != null) {\\n\\t\\t\\tAction hideAction = am.get(\\\"hideTip\\\");\\n\\t\\t\\tif (hideAction != null)\\n\\t\\t\\t\\tMAction.fire(hideAction, c);\\n\\t\\t}\\n\\t}\\n\\tpublic static PropertyChangeListener installLookAndFeelListener(final Component c) {\\n\\t\\tLookAndFeelListener lookAndFeelListener = new LookAndFeelListener(c);\\n\\t\\tUIManager.addPropertyChangeListener(lookAndFeelListener);\\n\\t\\treturn lookAndFeelListener;\\n\\t}\\n\\tpublic static <T> T invokeAndWait(final Callable<T> c) throws Exception {\\n\\t\\tif (EventQueue.isDispatchThread()) {\\n\\t\\t\\treturn c.call();\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tfinal Property<Exception> exception = new Property<>();\\n\\t\\t\\tfinal Property<T> result = new Property<>();\\n\\t\\t\\tEventQueue.invokeAndWait(new Runnable() {\\n\\t\\t\\t\\tpublic void run() {\\n\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\tresult.set(c.call());\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcatch (Exception e) {\\n\\t\\t\\t\\t\\t\\texception.set(e);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t\\tif (!exception.isNull())\\n\\t\\t\\t\\tthrow exception.get();\\n\\t\\t\\treturn result.get();\\n\\t\\t}\\n\\t}\\n\\tpublic static void invokeAndWait(final Runnable r) throws InterruptedException, InvocationTargetException {\\n\\t\\tif (EventQueue.isDispatchThread())\\n\\t\\t\\tr.run();\\n\\t\\telse\\n\\t\\t\\tEventQueue.invokeAndWait(r);\\n\\t}\\n\\tpublic static void invokeLater(final Runnable r) {\\n\\t\\tif (EventQueue.isDispatchThread())\\n\\t\\t\\tr.run();\\n\\t\\telse\\n\\t\\t\\tEventQueue.invokeLater(r);\\n\\t}\\n\\tpublic static boolean isA03() {\\n\\t\\treturn getLookAndFeelType() == LookAndFeelType.A03;\\n\\t}\\n\\tpublic static boolean isBlacklisted(final String lafClassName) {\\n\\t\\treturn \\\"com.sun.java.swing.plaf.motif.MotifLookAndFeel\\\".equals(lafClassName);\\n\\t}\\n\\tpublic static boolean isLipstik() {\\n\\t\\treturn getLookAndFeelType() == LookAndFeelType.LIPSTIK;\\n\\t}\\n\\tpublic static boolean isMac() {\\n\\t\\treturn getLookAndFeelType() == LookAndFeelType.MAC;\\n\\t}\\n\\tpublic static boolean isNimbus() {\\n\\t\\treturn getLookAndFeelType() == LookAndFeelType.NIMBUS;\\n\\t}\\n\\tpublic static boolean isQuaqua() {\\n\\t\\treturn getLookAndFeelType() == LookAndFeelType.QUAQUA;\\n\\t}\\n\\tpublic static boolean isRTL(final Component c) {\\n\\t\\treturn c.getComponentOrientation() == ComponentOrientation.RIGHT_TO_LEFT;\\n\\t}\\n\\tpublic static boolean isSynth() {\\n\\t\\tgetLookAndFeelType(); \\t\\tsynchronized (UI.class) {\\n\\t\\t\\treturn synth;\\n\\t\\t}\\n\\t}\\n\\tpublic static void paintFocus(final Component c, final Graphics2D g, final Color color, final int insets) {\\n\\t\\tint w = c.getWidth();\\n\\t\\tint h = c.getHeight();\\n\\t\\tColor fg = (color == null) ? getForeground(c) : color;\\n\\t\\tg.setColor(MColor.deriveAlpha(fg, 127));\\n\\t\\tStroke oldStroke = g.getStroke();\\n\\t\\tif (basicFocusStroke == null) {\\n\\t\\t\\tbasicFocusStroke = new BasicStroke(\\n\\t\\t\\t\\t1, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND,\\n\\t\\t\\t\\t1.0f, new float[] { 2.0f }, 1.0f\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\tg.setStroke(basicFocusStroke);\\n\\t\\tg.drawRect(insets, insets, w - insets * 2 - 1, h - insets * 2 - 1);\\n\\t\\tg.setStroke(oldStroke);\\n\\t}\\n\\tpublic static void setHTMLEnabled(final JComponent c, final boolean enabled) {\\n\\t\\tc.putClientProperty(\\\"html.disable\\\", enabled ? null : true);\\n\\t}\\n\\tpublic static void setStyle(final String style, final Component... components) {\\n\\t\\tif (TK.isEmpty(style))\\n\\t\\t\\treturn;\\n\\t\\ttry {\\n\\t\\t\\t\\t\\t\\tStyle s = new Style(components[0].getFont(), style);\\n\\t\\t\\tfor (Component i : components)\\n\\t\\t\\t\\ts.apply(i);\\n\\t\\t\\t\\t\\t}\\n\\t\\tcatch (ParseException exception) {\\n\\t\\t\\tMLogger.exception(exception);\\n\\t\\t}\\n\\t}\\n\\tpublic static int getTypeForImageFormat(final String format) {\\n\\t\\tif (format == null)\\n\\t\\t\\treturn BufferedImage.TYPE_INT_ARGB;\\n\\t\\tif (format.equalsIgnoreCase(\\\"BMP\\\"))\\n\\t\\t\\treturn BufferedImage.TYPE_3BYTE_BGR;\\n\\t\\tif (format.equalsIgnoreCase(\\\"JPG\\\"))\\n\\t\\t\\treturn BufferedImage.TYPE_INT_RGB;\\n\\t\\treturn BufferedImage.TYPE_INT_ARGB;\\n\\t}\\n\\tpublic static Color getXorColor(final Color color) {\\n\\t\\tif (color == null)\\n\\t\\t\\treturn null;\\n\\t\\treturn new Color(color.getRGB() ^ 0xffffff);\\n\\t}\\n\\tpublic static void init() {\\n\\t\\tMLogger.debug(\\\"ui\\\", \\\"Current look and feel: %s\\\", getLookAndFeelType());\\n\\t\\tUIDefaults defaults = UIManager.getDefaults();\\n\\t\\t\\t\\tIcon cancelIcon = buttonIcons.booleanValue() ? MActionInfo.CANCEL.getIcon() : null;\\n\\t\\tIcon okIcon = buttonIcons.booleanValue() ? MActionInfo.OK.getIcon() : null;\\n\\t\\tdefaults.put(\\\"OptionPane.cancelButtonText\\\", MActionInfo.CANCEL.getText());\\n\\t\\tdefaults.put(\\\"OptionPane.cancelIcon\\\", cancelIcon);\\n\\t\\tdefaults.put(\\\"OptionPane.errorIcon\\\", MIcon.stock(\\\"ui/error\\\"));\\n\\t\\tdefaults.put(\\\"OptionPane.informationIcon\\\", MIcon.stock(\\\"ui/info\\\"));\\n\\t\\tdefaults.put(\\\"OptionPane.noIcon\\\", cancelIcon);\\n\\t\\tdefaults.put(\\\"OptionPane.okButtonText\\\", MActionInfo.OK.getText());\\n\\t\\tdefaults.put(\\\"OptionPane.okIcon\\\", okIcon);\\n\\t\\tdefaults.put(\\\"OptionPane.questionIcon\\\", MIcon.stock(\\\"ui/question\\\"));\\n\\t\\tdefaults.put(\\\"OptionPane.yesIcon\\\", okIcon);\\n\\t\\tdefaults.put(\\\"OptionPane.warningIcon\\\", MIcon.stock(\\\"ui/warning\\\"));\\n\\t\\t\\t\\tdefaults.put(\\\"OptionPane.buttonOrientation\\\", RIGHT);\\n\\t\\tdefaults.put(\\\"OptionPane.buttonPadding\\\", getDialogButtonSpacing());\\n\\t\\tdefaults.put(\\\"OptionPane.sameSizeButtons\\\", true);\\n\\t\\tOKCancelLayout.setupUI(defaults);\\n\\t\\t\\t\\tdefaults.put(\\\"Slider.paintValue\\\", false); \\t\\t\\n\\t\\tif (isGTK()) {\\n\\t\\t\\tdefaults.put(\\\"ComboBox.squareButton\\\", false);\\n\\t\\t}\\n\\t\\telse if (isMetal()) {\\n\\t\\t\\tdefaults.put(\\\"swing.boldMetal\\\", false);\\n\\t\\t\\t\\t\\t\\tObject gradient = createGradient(new Color(0xDDE8F3), Color.WHITE);\\n\\t\\t\\tdefaults.put(\\\"Button.gradient\\\", gradient);\\n\\t\\t\\tdefaults.put(\\\"MenuBar.gradient\\\", gradient);\\n\\t\\t\\tdefaults.put(\\\"Slider.gradient\\\", gradient);\\n\\t\\t\\tdefaults.put(\\\"Slider.focusGradient\\\", gradient);\\n\\t\\t\\tdefaults.put(\\\"ScrollBar.gradient\\\", gradient);\\n\\t\\t\\tdefaults.put(\\\"RadioButton.gradient\\\", gradient);\\n\\t\\t\\tdefaults.put(\\\"RadioButtonMenuItem.gradient\\\", gradient);\\n\\t\\t\\tdefaults.put(\\\"ToggleButton.gradient\\\", gradient);\\n\\t\\t\\t\\t\\t\\tdefaults.put(\\\"CheckBoxMenuItem.background\\\", Color.WHITE);\\n\\t\\t\\tdefaults.put(\\\"Menu.background\\\", Color.WHITE);\\n\\t\\t\\tdefaults.put(\\\"MenuItem.background\\\", Color.WHITE);\\n\\t\\t\\tdefaults.put(\\\"PopupMenu.background\\\", Color.WHITE);\\n\\t\\t\\tdefaults.put(\\\"RadioButtonMenuItem.background\\\", Color.WHITE);\\n\\t\\t\\tdefaults.put(\\\"Separator.background\\\", Color.WHITE);\\n\\t\\t\\t\\t\\t\\tBorder border;\\n\\t\\t\\tColorUIResource bg;\\n\\t\\t\\tColorUIResource fg;\\n\\t\\t\\tif (OS.isMac() || OS.isWindows()) {\\n\\t\\t\\t\\tbg = new ColorUIResource(SystemColor.info);\\n\\t\\t\\t\\tfg = new ColorUIResource(SystemColor.infoText);\\n\\t\\t\\t\\tborder = new BorderUIResource.LineBorderUIResource(fg, 1);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbg = new ColorUIResource(TOOL_TIP_BACKGROUND_COLOR);\\n\\t\\t\\t\\tfg = new ColorUIResource(TOOL_TIP_FOREGROUND_COLOR);\\n\\t\\t\\t\\tborder = BorderUIResource.getBlackLineBorderUIResource();\\n\\t\\t\\t}\\n\\t\\t\\tdefaults.put(\\\"ToolTip.background\\\", bg);\\n\\t\\t\\tdefaults.put(\\\"ToolTip.backgroundInactive\\\", bg);\\n\\t\\t\\tdefaults.put(\\\"ToolTip.foreground\\\", fg);\\n\\t\\t\\tdefaults.put(\\\"ToolTip.foregroundInactive\\\", fg);\\n\\t\\t\\tdefaults.put(\\\"ToolTip.border\\\", border);\\n\\t\\t\\tdefaults.put(\\\"ToolTip.borderInactive\\\", border);\\n\\t\\t\\t\\t\\t\\tdefaults.put(\\\"TabbedPane.contentBorderInsets\\\", createInsets(1));\\n\\t\\t\\t\\t\\t\\tdefaults.put(\\\"Tree.leafIcon\\\", null);\\n\\t\\t}\\n\\t\\telse if (isSynth()) {\\n\\t\\t\\tdefaults.put(\\\"ScrollBar.allowsAbsolutePositioning\\\", true); \\t\\t}\\n\\t\\tif (useCustomColor.get())\\n\\t\\t\\tinitCustomColor(defaults);\\n\\t}\\n\\tprivate static Color oldControl;\\n\\tprivate static Color oldNimbusFocus;\\n\\tprivate static Color oldNimbusSelectionBackground;\\n\\tpublic static void initCustomColor(final UIDefaults defaults) {\\n\\t\\tColor color = customColor.get();\\n\\t\\tif (color == null)\\n\\t\\t\\treturn;\\n\\t\\tif (isNimbus()) {\\n\\t\\t\\tif (oldControl == null)\\n\\t\\t\\t\\toldControl = defaults.getColor(\\\"control\\\");\\n\\t\\t\\tif (oldNimbusFocus == null)\\n\\t\\t\\t\\toldNimbusFocus = defaults.getColor(\\\"nimbusFocus\\\");\\n\\t\\t\\tif (oldNimbusSelectionBackground == null)\\n\\t\\t\\t\\toldNimbusSelectionBackground = defaults.getColor(\\\"nimbusSelectionBackground\\\");\\n\\t\\t\\tdefaults.put(\\\"nimbusBase\\\", color);\\n\\t\\t\\tif (customColor.isDefaultValue()) {\\n\\t\\t\\t\\tif (oldNimbusSelectionBackground != null)\\n\\t\\t\\t\\t\\tdefaults.put(\\\"nimbusSelectionBackground\\\", oldNimbusSelectionBackground);\\n\\t\\t\\t\\tif (oldNimbusFocus != null)\\n\\t\\t\\t\\t\\tdefaults.put(\\\"nimbusFocus\\\", oldNimbusFocus);\\n\\t\\t\\t\\tif (oldControl != null)\\n\\t\\t\\t\\t\\tdefaults.put(\\\"control\\\", oldControl);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tdefaults.put(\\\"nimbusSelectionBackground\\\", color);\\n\\t\\t\\t\\tdefaults.put(\\\"nimbusFocus\\\", MColor.getBrighter(color, 25));\\n\\t\\t\\t\\tdefaults.put(\\\"control\\\", MColor.getBrighter(color, 90));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tpublic static boolean isEmpty(final Image image) {\\n\\t\\treturn (image == null) || (image.getWidth(null) < 1) || (image.getHeight(null) < 1);\\n\\t}\\n\\tpublic static boolean isGTK() {\\n\\t\\treturn getLookAndFeelType() == LookAndFeelType.GTK;\\n\\t}\\n\\tpublic static boolean isMetal() {\\n\\t\\treturn getLookAndFeelType() == LookAndFeelType.METAL;\\n\\t}\\n\\tpublic static boolean isPgs() {\\n\\t\\treturn getLookAndFeelType() == LookAndFeelType.PGS;\\n\\t}\\n\\tpublic static boolean isPopupTrigger(final KeyEvent e) {\\n\\t\\tif (TK.isKeyStroke(e, VK_CONTEXT_MENU) || TK.isKeyStroke(e, VK_F10, SHIFT_MASK)) {\\n\\t\\t\\te.consume();\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\tpublic static boolean isRetro() {\\n\\t\\treturn getLookAndFeelType() == LookAndFeelType.RETRO;\\n\\t}\\n\\tpublic static boolean isSeaGlass() {\\n\\t\\treturn getLookAndFeelType() == LookAndFeelType.SEA_GLASS;\\n\\t}\\n\\tpublic static boolean isSubstance() {\\n\\t\\treturn getLookAndFeelType() == LookAndFeelType.SUBSTANCE;\\n\\t}\\n\\tpublic static boolean isWindows() {\\n\\t\\treturn (getLookAndFeelType() == LookAndFeelType.WINDOWS);\\n\\t}\\n\\tpublic static String makeHTML(final String code) {\\n\\t\\treturn HTML_BEGIN + code + HTML_END;\\n\\t}\\n\\tpublic static void paintText(\\n\\t\\tfinal int flags,\\n\\t\\tfinal Graphics2D g,\\n\\t\\tfinal Rectangle r,\\n\\t\\tfinal Color background,\\n\\t\\tfinal Color foreground,\\n\\t\\tfinal String... lines\\n\\t) {\\n\\t\\tif (TK.isEmpty(lines))\\n\\t\\t\\treturn;\\n\\t\\tFlags f = Flags.valueOf(flags);\\n\\t\\tFontMetrics metrics = g.getFontMetrics();\\n\\t\\tint textHeight = metrics.getHeight();\\n\\t\\tif (background != null) {\\n\\t\\t\\tg.setColor(background);\\n\\t\\t\\tint h = textHeight * lines.length;\\n\\t\\t\\tg.fillRect(r.x, r.y, r.width, h + metrics.getDescent());\\n\\t\\t}\\n\\t\\tShape oldClip = g.getClip();\\n\\t\\tint y = r.y;\\n\\t\\tg.setClip(r);\\n\\t\\tg.setColor(foreground);\\n\\t\\tfor (String i : lines) {\\n\\t\\t\\ty += textHeight;\\n\\t\\t\\tif (f.isSet(PAINT_TEXT_TRIM_LINES))\\n\\t\\t\\t\\tg.drawString(i.trim(), r.x + 4, y);\\n\\t\\t\\telse\\n\\t\\t\\t\\tg.drawString(i, r.x + 4, y);\\n\\t\\t\\tif (y > r.x + r.height)\\n\\t\\t\\t\\tbreak; \\t\\t}\\n\\t\\tg.setClip(oldClip);\\n\\t}\\n\\tpublic static BufferedImage createCompatibleImage(final int w, final int h, final boolean alpha) {\\n\\t\\tGraphicsEnvironment environment = GraphicsEnvironment.getLocalGraphicsEnvironment();\\n\\t\\tGraphicsDevice device = environment.getDefaultScreenDevice();\\n\\t\\tGraphicsConfiguration configuration = device.getDefaultConfiguration();\\n\\t\\tif (alpha)\\n\\t\\t\\treturn configuration.createCompatibleImage(w, h, Transparency.TRANSLUCENT);\\n\\t\\treturn configuration.createCompatibleImage(w, h);\\n\\t}\\n\\tpublic static VolatileImage createCompatibleVolatileImage(final int w, final int h, final int transparency) {\\n\\t\\tGraphicsEnvironment environment = GraphicsEnvironment.getLocalGraphicsEnvironment();\\n\\t\\tGraphicsDevice device = environment.getDefaultScreenDevice();\\n\\t\\tGraphicsConfiguration configuration = device.getDefaultConfiguration();\\n\\t\\treturn configuration.createCompatibleVolatileImage(w, h, transparency);\\n\\t}\\n\\tpublic static boolean needScrollPane(final JComponent component) {\\n\\t\\treturn\\n\\t\\t\\t(component instanceof Scrollable) &&\\n\\t\\t\\t!(component instanceof JScrollPane) &&\\n\\t\\t\\t!(component instanceof JTextField) &&\\n\\t\\t\\t!(component instanceof JLayer);\\n\\t}\\n\\tpublic static Image scaleImage(final Image image, int targetWidth, int targetHeight, final Quality quality) {\\n\\t\\tif ((targetWidth < 0) && (targetHeight < 0))\\n\\t\\t\\treturn image;\\n\\t\\tint w = image.getWidth(null);\\n\\t\\tint h = image.getHeight(null);\\n\\t\\tif (targetWidth < 0) {\\n\\t\\t\\tfloat f = (float)targetHeight / (float)h;\\n\\t\\t\\ttargetWidth = (int)((float)w * f);\\n\\t\\t}\\n\\t\\tif (targetHeight < 0) {\\n\\t\\t\\tfloat f = (float)targetWidth / (float)w;\\n\\t\\t\\ttargetHeight = (int)((float)h * f);\\n\\t\\t}\\n\\t\\tif ((w == targetWidth) && (h == targetHeight))\\n\\t\\t\\treturn image;\\n\\t\\tswitch (quality) {\\n\\t\\t\\tcase LOW:\\n\\t\\t\\t\\treturn doScale(image, targetWidth, targetHeight, RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR, true);\\n\\t\\t\\tcase MEDIUM:\\n\\t\\t\\t\\treturn doScale(image, targetWidth, targetHeight, RenderingHints.VALUE_INTERPOLATION_BILINEAR, true);\\n\\t\\t\\tcase HIGH:\\n\\t\\t\\t\\tif ((targetWidth < w) || (targetHeight < h)) {\\n\\t\\t\\t\\t\\tboolean done = false;\\n\\t\\t\\t\\t\\tfloat fw = w;\\n\\t\\t\\t\\t\\tfloat fh = h;\\n\\t\\t\\t\\t\\tBufferedImage result = null;\\n\\t\\t\\t\\t\\twhile (!done) {\\n\\t\\t\\t\\t\\t\\tif (fw > targetWidth) {\\n\\t\\t\\t\\t\\t\\t\\tfw /= 2f;\\n\\t\\t\\t\\t\\t\\t\\tif (fw < targetWidth)\\n\\t\\t\\t\\t\\t\\t\\t\\tfw = targetWidth;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (fh > targetHeight) {\\n\\t\\t\\t\\t\\t\\t\\tfh /= 2f;\\n\\t\\t\\t\\t\\t\\t\\tif (fh < targetHeight)\\n\\t\\t\\t\\t\\t\\t\\t\\tfh = targetHeight;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tw = (int)fw;\\n\\t\\t\\t\\t\\t\\th = (int)fh;\\n\\t\\t\\t\\t\\t\\tdone = (w == targetWidth) && (h == targetHeight);\\n\\t\\t\\t\\t\\t\\tresult = doScale(\\n\\t\\t\\t\\t\\t\\t\\t(result != null) ? result : image,\\n\\t\\t\\t\\t\\t\\t\\tw,\\n\\t\\t\\t\\t\\t\\t\\th,\\n\\t\\t\\t\\t\\t\\t\\tRenderingHints.VALUE_INTERPOLATION_BILINEAR,\\n\\t\\t\\t\\t\\t\\t\\tdone\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\treturn doScale(image, targetWidth, targetHeight, RenderingHints.VALUE_INTERPOLATION_BICUBIC, true);\\n\\t\\t\\t\\t}\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tthrow new WTFError(quality);\\n\\t\\t}\\n\\t}\\n\\tpublic static Object setAntialiasing(final Graphics2D g, final boolean value) {\\n\\t\\tRenderingHints.Key key = RenderingHints.KEY_ANTIALIASING;\\n\\t\\tObject oldRenderingHint = g.getRenderingHint(key);\\n\\t\\tg.setRenderingHint(key, value ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);\\n\\t\\treturn oldRenderingHint;\\n\\t}\\n\\tpublic static void setHTMLHelp(final JComponent component, final String text) {\\n\\t\\tcomponent.setToolTipText((text == null) ? null : makeHTML(text));\\n\\t}\\n\\tpublic static void setLookAndFeel(final LookAndFeel laf) throws Exception {\\n\\t\\tsynchronized (UI.class) {\\n\\t\\t\\tlookAndFeelType = null;\\n\\t\\t}\\n\\t\\tMLogger.info(\\\"core\\\", \\\"Setting look and feel: %s\\\", laf.getName());\\n\\t\\tinitCustomFont();\\n\\t\\tUIManager.setLookAndFeel(laf);\\n\\t\\tinit();\\n\\t}\\n\\tpublic static void setLookAndFeel(final String className) throws Exception {\\n\\t\\tsynchronized (UI.class) {\\n\\t\\t\\tlookAndFeelType = null;\\n\\t\\t}\\n\\t\\tMLogger.info(\\\"core\\\", \\\"Setting look and feel by class name: %s\\\", className);\\n\\t\\tinitCustomFont();\\n\\t\\tUIManager.setLookAndFeel(className);\\n\\t\\tinit();\\n\\t}\\n\\tpublic static void setTextAntialiasing(final Graphics2D g, final RenderingHints savedHints) {\\n\\t\\tif (savedHints != null) {\\n\\t\\t\\tsavedHints.clear();\\n\\t\\t\\tfor (RenderingHints.Entry<Object, Object> i : g.getRenderingHints().entrySet())\\n\\t\\t\\t\\tsavedHints.put(i.getKey(), i.getValue());\\n\\t\\t}\\n\\t\\tsynchronized (UI.class) {\\n\\t\\t\\tif (!textAAInitialized) {\\n\\t\\t\\t\\ttextAAInitialized = true;\\n\\t\\t\\t\\tToolkit toolkit = Toolkit.getDefaultToolkit();\\n\\t\\t\\t\\tupdateTextAA(toolkit);\\n\\t\\t\\t\\ttoolkit.addPropertyChangeListener(\\\"awt.font.desktophints\\\", new PropertyChangeListener() {\\n\\t\\t\\t\\t\\t@Override\\n\\t\\t\\t\\t\\tpublic void propertyChange(final PropertyChangeEvent e) {\\n\\t\\t\\t\\t\\t\\tMLogger.debug(\\\"ui\\\", \\\"Text Antialiasing: Settings changed\\\");\\n\\t\\t\\t\\t\\t\\tsynchronized (UI.class) {\\n\\t\\t\\t\\t\\t\\t\\tUI.updateTextAA(Toolkit.getDefaultToolkit());\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (textAA == null) {\\n\\t\\t\\tsetBasicTextAntialiasing(g, true);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tg.addRenderingHints(textAA);\\n\\t\\t}\\n\\t}\\n\\tpublic static Object setBasicTextAntialiasing(final Graphics2D g, final boolean on) {\\n\\t\\tRenderingHints.Key key = RenderingHints.KEY_TEXT_ANTIALIASING;\\n\\t\\tObject oldRenderingHint = g.getRenderingHint(key);\\n\\t\\tg.setRenderingHint(key, on ? RenderingHints.VALUE_TEXT_ANTIALIAS_ON : RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);\\n\\t\\treturn oldRenderingHint;\\n\\t}\\n\\tpublic static void setHandCursor(final Component component, final boolean yes) {\\n\\t\\tif (component != null)\\n\\t\\t\\tcomponent.setCursor(Cursor.getPredefinedCursor(yes ? Cursor.HAND_CURSOR : Cursor.DEFAULT_CURSOR));\\n\\t}\\n\\tpublic static void setWaitCursor(final Component component, final boolean wait) {\\n\\t\\tif (component == null)\\n\\t\\t\\treturn;\\n\\t\\tif (!wait && (component instanceof JTextComponent)) {\\n\\t\\t\\tboolean editable = JTextComponent.class.cast(component).isEditable();\\n\\t\\t\\tcomponent.setCursor(Cursor.getPredefinedCursor(editable ? Cursor.TEXT_CURSOR : Cursor.DEFAULT_CURSOR));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tcomponent.setCursor(Cursor.getPredefinedCursor(wait ? Cursor.WAIT_CURSOR : Cursor.DEFAULT_CURSOR));\\n\\t}\\n\\tpublic static void setWaitCursor(final boolean yes) {\\n\\t\\tsetWaitCursor(MainView.getWindow(), yes);\\n\\t}\\n\\tpublic static BufferedImage toBufferedImage(final Icon source) {\\n\\t\\tBufferedImage result = createCompatibleImage(source.getIconWidth(), source.getIconHeight(), true);\\n\\t\\tGraphics2D g = result.createGraphics();\\n\\t\\tsource.paintIcon(null, g, 0, 0);\\n\\t\\tg.dispose();\\n\\t\\treturn result;\\n\\t}\\n\\tpublic static BufferedImage toBufferedImage(final Image source, final boolean useSource) {\\n\\t\\tif (useSource && (source instanceof BufferedImage))\\n\\t\\t\\treturn (BufferedImage)source;\\n\\t\\t\\t\\tBufferedImage result = createCompatibleImage(source.getWidth(null), source.getHeight(null), true);\\n\\t\\tGraphics2D g = result.createGraphics();\\n\\t\\tg.drawImage(source, 0, 0, null, null);\\n\\t\\tg.dispose();\\n\\t\\treturn result;\\n\\t}\\n\\tpublic static void update() {\\n\\t\\ttry {\\n\\t\\t\\tsetWaitCursor(true);\\n\\t\\t\\tfor (Window i : Window.getWindows())\\n\\t\\t\\t\\tSwingUtilities.updateComponentTreeUI(i);\\n\\t\\t}\\n\\t\\tfinally {\\n\\t\\t\\tsetWaitCursor(false);\\n\\t\\t}\\n\\t}\\n\\tpublic static Window windowFor(final Component c) {\\n\\t\\tif (c == null)\\n\\t\\t\\treturn FocusManager.getCurrentManager().getActiveWindow();\\n\\t\\treturn SwingUtilities.getWindowAncestor(c);\\n\\t}\\n\\t@Uninstantiable\\n\\tprivate UI() { }\\n\\tprivate static BufferedImage doScale(final Image image, final int w, final int h, final Object hint, final boolean compatible) {\\n\\t\\tBufferedImage result =\\n\\t\\t\\tcompatible\\n\\t\\t\\t? createCompatibleImage(w, h, true)\\n\\t\\t\\t: new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\\n\\t\\tGraphics2D g = result.createGraphics();\\n\\t\\tg.setRenderingHint(RenderingHints.KEY_INTERPOLATION, hint);\\n\\t\\tg.drawImage(image, 0, 0, w, h, null);\\n\\t\\tg.dispose();\\n\\t\\treturn result;\\n\\t}\\n\\tprivate static void initCustomFont() {\\n\\t\\tif (useCustomFont.get()) {\\n\\t\\t\\tcustomFontValue = customFont.get();\\n\\t\\t\\t\\t\\t\\tfloat size = (float)TK.limit(customFontValue.getSize(), 8, 32);\\n\\t\\t\\tcustomFontValue = customFontValue.deriveFont(size);\\n\\t\\t\\t\\t\\t\\tUIDefaults defaults = UIManager.getDefaults();\\n\\t\\t\\tdefaults.put(\\\"defaultFont\\\", customFontValue);\\n\\t\\t\\tfor (Map.Entry<Object, Object> i : defaults.entrySet()) {\\n\\t\\t\\t\\tString name = i.getKey().toString();\\n\\t\\t\\t\\tputFont(defaults, name, \\\".font\\\", customFontValue);\\n\\t\\t\\t\\tputFont(defaults, name, \\\".acceleratorFont\\\", customFontValue);\\n\\t\\t\\t\\tputFont(defaults, name, \\\"InternalFrame.titleFont\\\", customFontValue);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tcustomFontValue = null;\\n\\t\\t}\\n\\t}\\n\\tprivate static void putFont(final UIDefaults defaults, final String name, final String suffix, final Font font) {\\n\\t\\tint i = name.lastIndexOf(suffix);\\n\\t\\tif (i != -1) {\\n\\t\\t\\tdefaults.put(name, font);\\n\\t\\t\\tString baseName = name.substring(0, i);\\n\\t\\t\\tdefaults.put(baseName + \\\"[Enabled]\\\" + suffix, font);\\n\\t\\t\\tdefaults.put(baseName + \\\"[Disabled]\\\" + suffix, font);\\n\\t\\t}\\n\\t}\\n\\t@SuppressWarnings(\\\"unchecked\\\")\\n\\tprivate static void updateTextAA(final Toolkit toolkit) {\\n\\t\\ttextAA = (Map<Object, Object>)toolkit.getDesktopProperty(\\\"awt.font.desktophints\\\");\\n\\t\\tif (textAA != null) {\\n\\t\\t\\tfor (Map.Entry<Object, Object> i : textAA.entrySet()) {\\n\\t\\t\\t\\tMLogger.debug(\\\"ui\\\", \\\"Text Antialiasing: %s = %s\\\", i.getKey(), i.getValue());\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tpublic static interface EventsControl {\\n\\t\\tpublic boolean getEventsEnabled();\\n\\t\\tpublic void setEventsEnabled(final boolean value);\\n\\t}\\n\\tpublic static interface MouseWheelEventsControl {\\n\\t\\tpublic boolean getMouseWheelEventsEnabled();\\n\\t\\tpublic void setMouseWheelEventsEnabled(final boolean value);\\n\\t}\\n\\tpublic static class NimbusOverrides extends UIDefaults {\\n\\t\\tpublic NimbusOverrides() { }\\n\\t\\tpublic void install(final JComponent c, final boolean inheritDefaults) {\\n\\t\\t\\tc.putClientProperty(\\\"Nimbus.Overrides.InheritDefaults\\\", inheritDefaults);\\n\\t\\t\\tc.putClientProperty(\\\"Nimbus.Overrides\\\", this);\\n\\t\\t}\\n\\t}\\n\\tprivate static final class LazySimpleButtonUIHolder {\\n\\t\\tprivate static final SimpleButtonUI INSTANCE = new SimpleButtonUI();\\n\\t\\tprivate LazySimpleButtonUIHolder() { }\\n\\t}\\n\\tprivate static final class LookAndFeelListener implements PropertyChangeListener {\\n\\t\\tprivate final WeakReference<Component> componentRef;\\n\\t\\tpublic LookAndFeelListener(final Component c) {\\n\\t\\t\\tcomponentRef = new WeakReference<>(c);\\n\\t\\t}\\n\\t\\t@Override\\n\\t\\tpublic void propertyChange(final PropertyChangeEvent e) {\\n\\t\\t\\tif (\\\"lookAndFeel\\\".equals(e.getPropertyName())) {\\n\\t\\t\\t\\tComponent c = TK.get(componentRef);\\n\\t\\t\\t\\tif ((c != null) && (UI.windowFor(c) == null))\\n\\t\\t\\t\\t\\tSwingUtilities.updateComponentTreeUI(c);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\""
        },
        {
            "content": "The `UI.java` file is a comprehensive utility class focused on user interface management within the Makagiga framework. It provides a wide range of functionalities, including:\n\n1. **UI Configuration and Properties**:\n   - Manages global UI settings such as fonts, colors, icon sizes, and layout preferences.\n   - Contains properties like `iconSize`, `customFont`, `systemTray`, and others that influence the application's appearance and behavior.\n\n2. **Look and Feel Management**:\n   - Handles different LookAndFeel implementations (e.g., GTK, Nimbus, Metal) through methods like `getLookAndFeelType()` and `setLookAndFeel()`.\n   - Adjusts UI defaults dynamically based on the selected theme.\n\n3. **Rendering and Graphics Utilities**:\n   - Offers utilities for rendering text, images, and components with support for anti-aliasing, scaling, and custom painting.\n   - Includes helper methods like `paintFocus()`, `scaleImage()`, and `setAntialiasing()`.\n\n4. **Component Helpers**:\n   - Provides convenience methods for working with Swing components, such as setting tooltips (`setHTMLHelp()`), managing cursors (`setHandCursor()`), and handling scrollable content (`needScrollPane()`).\n\n5. **Event Handling and Threading**:\n   - Supports event dispatching and threading via methods like `invokeAndWait()` and `invokeLater()` to ensure thread-safe UI updates.\n\n### Relevance to `AutoCompletion.java`:\n- `AutoCompletion.java` uses `UI` extensively for rendering and theming purposes, especially when displaying auto-complete suggestions in a popup window.\n- The removal of `MText.java` may not directly impact `UI.java`, but it could affect how `AutoCompletion` integrates with text components if `MText` was previously part of that flow.\n\n### Next Steps:\nSince `UI.java` doesn't directly reference `MText`, we should continue investigating other entities that might have replaced or refactored the functionality previously handled by `MText`. We already examined `AutoCompletion.java` and `UI.java`; now, let's look into `TK.java`, which is another heavily used utility referenced by both files.\n\nWe'll retrieve the origin code for `TK.java` next.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_03044c636a4547dea8f29f",
                    "function": {
                        "arguments": "{\"entity\": \"TK.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"package org.makagiga.commons;\\nimport java.awt.Toolkit;\\nimport java.awt.event.ActionEvent;\\nimport java.awt.event.ActionListener;\\nimport java.awt.event.KeyEvent;\\nimport java.beans.PropertyChangeEvent;\\nimport java.beans.PropertyChangeListener;\\nimport java.io.IOException;\\nimport java.io.ObjectInputStream;\\nimport java.io.ObjectOutputStream;\\nimport java.io.Serializable;\\nimport java.io.UnsupportedEncodingException;\\nimport java.lang.ref.Reference;\\nimport java.lang.reflect.Array;\\nimport java.net.URLDecoder;\\nimport java.net.URLEncoder;\\nimport java.text.ParseException;\\nimport java.util.Arrays;\\nimport java.util.Collection;\\nimport java.util.Collections;\\nimport java.util.Comparator;\\nimport java.util.EnumSet;\\nimport java.util.Enumeration;\\nimport java.util.HashMap;\\nimport java.util.HashSet;\\nimport java.util.Iterator;\\nimport java.util.LinkedHashMap;\\nimport java.util.List;\\nimport java.util.Locale;\\nimport java.util.Map;\\nimport java.util.Objects;\\nimport java.util.Set;\\nimport java.util.TreeMap;\\nimport java.util.UUID;\\nimport java.util.regex.Pattern;\\nimport javax.swing.KeyStroke;\\nimport javax.swing.event.ChangeEvent;\\nimport javax.swing.event.ChangeListener;\\nimport org.w3c.dom.Node;\\nimport org.w3c.dom.NodeList;\\nimport org.makagiga.commons.annotation.Obsolete;\\nimport org.makagiga.commons.annotation.Uninstantiable;\\npublic final class TK {\\n\\tpublic static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\\n\\tpublic static final ChangeListener[] EMPTY_CHANGE_LISTENER_ARRAY = new ChangeListener[0];\\n\\tpublic static final char[] EMPTY_CHAR_ARRAY = new char[0];\\n\\tpublic static final int[] EMPTY_INT_ARRAY = new int[0];\\n\\tpublic static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\\n\\tpublic static final PropertyChangeListener[] EMPTY_PROPERTY_CHANGE_LISTENER_ARRAY = new PropertyChangeListener[0];\\n\\tpublic static final String[] EMPTY_STRING_ARRAY = new String[0];\\n\\tpublic static final int ESCAPE_ASTERISK = 1;\\n\\tpublic static final int ESCAPE_SPACE = 1 << 1;\\n\\tpublic static final int SPLIT_PAIR_TRIM = 1;\\n\\tpublic static final int SPLIT_PAIR_NULL_ERROR = 1 << 1;\\n\\tpublic static final int SPLIT_PAIR_NO_MEMORY_LEAK = 1 << 2;\\n\\tprivate static Pattern validateIDPattern = Pattern.compile(\\\"(\\\\\\\\w|\\\\\\\\-)+\\\");\\n\\tpublic static void beep() {\\n\\t\\tToolkit.getDefaultToolkit().beep();\\n\\t}\\n\\tpublic static String buildErrorMessage(final Throwable throwable) {\\n\\t\\tObjects.requireNonNull(throwable);\\n\\t\\tint level = 0;\\n\\t\\tString last = null;\\n\\t\\tStringBuilder s = new StringBuilder();\\n\\t\\tThrowable cause = throwable;\\n\\t\\tdo {\\n\\t\\t\\tString message = cause.toString();\\n\\t\\t\\t\\t\\t\\tif (Objects.equals(last, message))\\n\\t\\t\\t\\tcontinue; \\n\\t\\t\\tlast = message;\\n\\t\\t\\tif (s.length() > 0)\\n\\t\\t\\t\\ts.append('\\\\n');\\n\\t\\t\\tif (level > 0)\\n\\t\\t\\t\\ts.append(\\\"- \\\");\\n\\t\\t\\ts.append(message);\\n\\t\\t\\tlevel++;\\n\\t\\t} while ((cause = cause.getCause()) != null);\\n\\t\\treturn s.toString();\\n\\t}\\n\\tpublic static String capitalize(final String s) {\\n\\t\\tif (isEmpty(s))\\n\\t\\t\\treturn s;\\n\\t\\tint l = s.length();\\n\\t\\tStringBuilder result = new StringBuilder(l);\\n\\t\\tresult.append(Character.toUpperCase(s.charAt(0)));\\n\\t\\tif (l > 1)\\n\\t\\t\\tresult.append(s.substring(1));\\n\\t\\treturn result.toString();\\n\\t}\\n\\t@Obsolete\\n\\tpublic static <T> T checkNull(final T object) {\\n\\t\\treturn Objects.requireNonNull(object);\\n\\t}\\n\\t@Obsolete\\n\\tpublic static <T> T checkNull(final T object, final String name) {\\n\\t\\treturn Objects.requireNonNull(object, name);\\n\\t}\\n\\tpublic static String checkNullOrEmpty(final String string) {\\n\\t\\tif (isEmpty(string))\\n\\t\\t\\tthrow new IllegalArgumentException(\\\"String is null or empty\\\");\\n\\t\\treturn string;\\n\\t}\\n\\tpublic static String checkNullOrEmpty(final String string, final String name) {\\n\\t\\tif (isEmpty(string))\\n\\t\\t\\tthrow new IllegalArgumentException(\\\"\\\\\\\"\\\" + name + \\\"\\\\\\\" string is null or empty\\\");\\n\\t\\treturn string;\\n\\t}\\n\\tpublic static <T extends Comparable<T>> int compare(final T o1, final T o2, final T defaultValue) {\\n\\t\\tT item1 = (o1 == null) ? defaultValue : o1;\\n\\t\\tT item2 = (o2 == null) ? defaultValue : o2;\\n\\t\\treturn item1.compareTo(item2);\\n\\t}\\n\\tpublic static <T> T[] copyOf(final T[] array) {\\n\\t\\tif (array == null)\\n\\t\\t\\treturn null;\\n\\t\\tif (array.length == 0)\\n\\t\\t\\treturn array;\\n\\t\\treturn array.clone();\\n\\t}\\n\\tpublic static String createRandomUUID() {\\n\\t\\treturn \\\"{\\\" + UUID.randomUUID() + \\\"}\\\";\\n\\t}\\n\\t@Obsolete\\n\\tpublic static Object deserialize(final ObjectInputStream input, final String name) throws ClassNotFoundException, IOException {\\n\\t\\tObjects.requireNonNull(name);\\n\\t\\t\\t\\tObject[] data = (Object[])input.readObject();\\n\\t\\tif ((data.length == 2) && data[0].equals(name))\\n\\t\\t\\treturn data[1];\\n\\t\\treturn null;\\n\\t}\\n\\tpublic static <T> T dispose(final MDisposable o) {\\n\\t\\tif (o != null)\\n\\t\\t\\to.dispose();\\n\\t\\treturn null;\\n\\t}\\n\\tpublic static String escapeURL(final String value) {\\n\\t\\treturn escapeURL(value, 0);\\n\\t}\\n\\tpublic static String escapeURL(final String value, final int flags) {\\n\\t\\ttry {\\n\\t\\t\\tif (flags == 0)\\n\\t\\t\\t\\treturn URLEncoder.encode(value, \\\"UTF-8\\\");\\n\\t\\t\\tStringBuilder result = new StringBuilder(value.length() * 2);\\n\\t\\t\\tresult.append(URLEncoder.encode(value, \\\"UTF-8\\\"));\\n\\t\\t\\tif ((flags & ESCAPE_ASTERISK) != 0)\\n\\t\\t\\t\\tfastReplace(result, \\\"*\\\", \\\"%2A\\\");\\n\\t\\t\\tif ((flags & ESCAPE_SPACE) != 0)\\n\\t\\t\\t\\tfastReplace(result, \\\"+\\\", \\\"%20\\\");\\n\\t\\t\\treturn result.toString();\\n\\t\\t}\\n\\t\\tcatch (UnsupportedEncodingException exception) {\\n\\t\\t\\tMLogger.exception(exception);\\n\\t\\t\\treturn value;\\n\\t\\t}\\n\\t}\\n\\tpublic static String escapeXML(final String value) {\\n\\t\\tStringBuilder s = escapeXML(null, value);\\n\\t\\treturn (s == null) ? value : s.toString();\\n\\t}\\n\\tpublic static StringBuilder escapeXML(StringBuilder buf, final CharSequence value) {\\n\\t\\tif (value == null)\\n\\t\\t\\treturn buf;\\n\\t\\tint len = value.length();\\n\\t\\tif (len == 0)\\n\\t\\t\\treturn buf;\\n\\t\\tif (buf == null)\\n\\t\\t\\tbuf = new StringBuilder(len * 2);\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tchar c = value.charAt(i);\\n\\t\\t\\tswitch (c) {\\n\\t\\t\\t\\tcase '<':\\n\\t\\t\\t\\t\\tbuf.append(\\\"&lt;\\\");\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase '>':\\n\\t\\t\\t\\t\\tbuf.append(\\\"&gt;\\\");\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase '&':\\n\\t\\t\\t\\t\\tbuf.append(\\\"&amp;\\\");\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase '\\\\'':\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbuf.append(\\\"&#039;\\\");\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase '\\\\\\\"':\\n\\t\\t\\t\\t\\tbuf.append(\\\"&quot;\\\");\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbuf.append(c);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn buf;\\n\\t}\\n\\tpublic static String filler(final char fill, final int length) {\\n\\t\\tif (length < 0)\\n\\t\\t\\tthrow new IllegalArgumentException(\\\"\\\\\\\"length\\\\\\\" cannot be less than zero\\\");\\n\\t\\tchar[] c = new char[length];\\n\\t\\tArrays.fill(c, fill);\\n\\t\\treturn new String(c);\\n\\t}\\n\\tpublic static void fireActionPerformed(final Object source, final ActionListener[] al) {\\n\\t\\tif (al.length > 0) {\\n\\t\\t\\tActionEvent ae = new ActionEvent(source, ActionEvent.ACTION_PERFORMED, \\\"\\\");\\n\\t\\t\\tfor (ActionListener i : al)\\n\\t\\t\\t\\ti.actionPerformed(ae);\\n\\t\\t}\\n\\t}\\n\\tpublic static void fireStateChanged(final Object source, final ChangeListener[] cl) {\\n\\t\\tif (cl.length > 0) {\\n\\t\\t\\tChangeEvent ce = new ChangeEvent(source);\\n\\t\\t\\tfor (ChangeListener i : cl)\\n\\t\\t\\t\\ti.stateChanged(ce);\\n\\t\\t}\\n\\t}\\n\\tpublic static <T> void fireValueChanged(final Object source, final ValueListener<T>[] vl, final T oldValue, final T newValue) {\\n\\t\\tfireValueChanged(source, vl, oldValue, newValue, null);\\n\\t}\\n\\tpublic static <T> void fireValueChanged(final Object source, final ValueListener<T>[] vl, final T oldValue, final T newValue, final Object reason) {\\n\\t\\tif (vl.length > 0) {\\n\\t\\t\\tValueEvent<T> ve = new ValueEvent<>(source, oldValue, newValue, reason);\\n\\t\\t\\tfor (ValueListener<T> i : vl)\\n\\t\\t\\t\\ti.valueChanged(ve);\\n\\t\\t}\\n\\t}\\n\\tpublic static <T> T get(final Reference<T> ref) {\\n\\t\\treturn (ref == null) ? null : ref.get();\\n\\t}\\n\\tpublic static String identifierToDisplayString(final String identifier) {\\n\\t\\tif (identifier == null)\\n\\t\\t\\treturn null;\\n\\t\\tint len = identifier.length();\\n\\t\\tif (len == 0)\\n\\t\\t\\treturn identifier;\\n\\t\\tboolean nextUpper = false;\\n\\t\\tboolean previousLower = false;\\n\\t\\tboolean previousUpper = false;\\n\\t\\tint extra = 0;\\n\\t\\tStringBuilder s = new StringBuilder(len + 10);\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tchar c = identifier.charAt(i);\\n\\t\\t\\t\\t\\t\\tif (s.length() == 0) {\\n\\t\\t\\t\\ts.append(Character.toUpperCase(c));\\n\\t\\t\\t\\tnextUpper = false;\\n\\t\\t\\t\\tpreviousLower = false;\\n\\t\\t\\t\\tpreviousUpper = true;\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if ((c == '_') || (c == ' ') || (c == '.')) {\\n\\t\\t\\t\\ts.append(' ');\\n\\t\\t\\t\\tnextUpper = true;\\n\\t\\t\\t\\tpreviousLower = false;\\n\\t\\t\\t\\tpreviousUpper = false;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\t\\t\\tif (Character.isUpperCase(c)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (previousLower) {\\n\\t\\t\\t\\t\\t\\ts.append(' ');\\n\\t\\t\\t\\t\\t\\textra++;\\n\\t\\t\\t\\t\\t\\tpreviousLower = false;\\n\\t\\t\\t\\t\\t\\tpreviousUpper = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tpreviousUpper = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ts.append(c);\\n\\t\\t\\t\\t\\tnextUpper = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\telse if (nextUpper) {\\n\\t\\t\\t\\t\\ts.append(Character.toUpperCase(c));\\n\\t\\t\\t\\t\\tnextUpper = false;\\n\\t\\t\\t\\t\\tpreviousLower = false;\\n\\t\\t\\t\\t\\tpreviousUpper = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (Character.isLowerCase(c)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (previousUpper) {\\n\\t\\t\\t\\t\\t\\tint insertAt = (i + extra) - 1;\\n\\t\\t\\t\\t\\t\\tif ((insertAt > 0) && (s.charAt(Math.max(0, insertAt - 1)) != ' ')) {\\n\\t\\t\\t\\t\\t\\t\\ts.insert(insertAt, ' ');\\n\\t\\t\\t\\t\\t\\t\\textra++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tpreviousUpper = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ts.append(c);\\n\\t\\t\\t\\t\\tnextUpper = false;\\n\\t\\t\\t\\t\\tpreviousLower = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ts.append(Character.toLowerCase(c));\\n\\t\\t\\t\\t\\tnextUpper = false;\\n\\t\\t\\t\\t\\tpreviousLower = true;\\n\\t\\t\\t\\t\\tpreviousUpper = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn s.toString();\\n\\t}\\n\\t@Obsolete\\n\\tpublic static boolean isChange(final Object oldValue, final Object newValue) {\\n\\t\\tif (oldValue == null)\\n\\t\\t\\treturn (newValue != null);\\n\\t\\treturn !oldValue.equals(newValue);\\n\\t}\\n\\tpublic static boolean isEmpty(final char[] value) {\\n\\t\\treturn (value == null) || (value.length == 0);\\n\\t}\\n\\tpublic static boolean isEmpty(final CharSequence value) {\\n\\t\\treturn (value == null) || (value.length() == 0);\\n\\t}\\n\\tpublic static boolean isEmpty(final Collection<?> value) {\\n\\t\\treturn (value == null) || value.isEmpty();\\n\\t}\\n\\tpublic static boolean isEmpty(final Object[] value) {\\n\\t\\treturn (value == null) || (value.length == 0);\\n\\t}\\n\\tpublic static boolean isEmpty(final String value) {\\n\\t\\treturn (value == null) || value.isEmpty();\\n\\t}\\n\\tpublic static boolean isKeyStroke(final KeyEvent e, final int keyCode) {\\n\\t\\treturn isKeyStroke(e, keyCode, 0);\\n\\t}\\n\\tpublic static boolean isKeyStroke(final KeyEvent e, final int keyCode, final int modifiers) {\\n\\t\\treturn (e.getKeyCode() == keyCode) && (e.getModifiers() == modifiers);\\n\\t}\\n\\tpublic static boolean isProperty(final PropertyChangeEvent e, final String propertyName, final Object expectedNewValue) {\\n\\t\\treturn propertyName.equals(e.getPropertyName()) && Objects.equals(expectedNewValue, e.getNewValue());\\n\\t}\\n\\tpublic static <T> Iterable<T> iterable(final Enumeration<?> e) {\\n\\t\\tObjects.requireNonNull(e);\\n\\t\\treturn new Iterable<T>() {\\n\\t\\t\\tpublic Iterator<T> iterator() {\\n\\t\\t\\t\\treturn TK.iterator(e);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\tpublic static Iterable<Node> iterable(final Node node) {\\n\\t\\tif (!node.hasChildNodes()) {\\n\\t\\t\\treturn new Iterable<Node>() {\\n\\t\\t\\t\\t@Override\\n\\t\\t\\t\\tpublic Iterator<Node> iterator() {\\n\\t\\t\\t\\t\\treturn Collections.emptyIterator();\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t}\\n\\t\\tfinal NodeList list = node.getChildNodes();\\n\\t\\treturn new AbstractIterator<Node>(list.getLength()) {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic Node getObjectAt(final int index) {\\n\\t\\t\\t\\treturn list.item(index);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\tpublic static <T> Iterator<T> iterator(final Enumeration<?> e) {\\n\\t\\tObjects.requireNonNull(e);\\n\\t\\treturn new Iterator<T>() {\\n\\t\\t\\tpublic boolean hasNext() {\\n\\t\\t\\t\\treturn e.hasMoreElements();\\n\\t\\t\\t}\\n\\t\\t\\t@SuppressWarnings(\\\"unchecked\\\")\\n\\t\\t\\tpublic T next() {\\n\\t\\t\\t\\treturn (T)e.nextElement();\\n\\t\\t\\t}\\n\\t\\t\\tpublic void remove() {\\n\\t\\t\\t\\tthrow new UnsupportedOperationException();\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\tpublic static int maxLength(final Iterable<String> it) {\\n\\t\\tObjects.requireNonNull(it);\\n\\t\\tint result = 0;\\n\\t\\tfor (String i : it)\\n\\t\\t\\tresult = Math.max(result, i.length());\\n\\t\\treturn result;\\n\\t}\\n\\t@SuppressWarnings(\\\"unchecked\\\")\\n\\tpublic static <T> T[] newArray(final Class<T> clazz, final Object[] elements) {\\n\\t\\tif (isEmpty(elements))\\n\\t\\t\\treturn (T[])Array.newInstance(clazz, 0);\\n\\t\\tT[] result = (T[])Array.newInstance(clazz, elements.length);\\n\\t\\tSystem.arraycopy(elements, 0, result, 0, elements.length);\\n\\t\\treturn result;\\n\\t}\\n\\t@SafeVarargs\\n\\t@SuppressWarnings(\\\"varargs\\\")\\n\\tpublic static <T extends Enum<T>> Set<T> newEnumSet(final T... values) {\\n\\t\\tif (isEmpty(values))\\n\\t\\t\\treturn Collections.emptySet();\\n\\t\\tswitch (values.length) {\\n\\t\\t\\tcase 1: return Collections.unmodifiableSet(EnumSet.of(values[0]));\\n\\t\\t\\tcase 2: return Collections.unmodifiableSet(EnumSet.of(values[0], values[1]));\\n\\t\\t\\tcase 3: return Collections.unmodifiableSet(EnumSet.of(values[0], values[1], values[2]));\\n\\t\\t\\tcase 4: return Collections.unmodifiableSet(EnumSet.of(values[0], values[1], values[2], values[3]));\\n\\t\\t\\tcase 5: return Collections.unmodifiableSet(EnumSet.of(values[0], values[1], values[2], values[3], values[4]));\\n\\t\\t\\tdefault: return Collections.unmodifiableSet(EnumSet.of(values[0], values));\\n\\t\\t}\\n\\t}\\n\\t@SuppressWarnings(\\\"unchecked\\\")\\n\\tpublic static <K, V> Map<K, V> newHashMap(final Object... keysValues) {\\n\\t\\tif ((keysValues.length % 2) != 0)\\n\\t\\t\\tthrow new IllegalArgumentException(\\\"Key without value\\\");\\n\\t\\tMap<K, V> result = new HashMap<>(keysValues.length / 2);\\n\\t\\tfor (int i = 0; i < keysValues.length; i += 2)\\n\\t\\t\\tresult.put((K)keysValues[i], (V)keysValues[i + 1]);\\n\\t\\treturn result;\\n\\t}\\n\\t@SafeVarargs\\n\\t@SuppressWarnings(\\\"varargs\\\")\\n\\tpublic static <T> Set<T> newHashSet(final T... values) {\\n\\t\\tif (isEmpty(values))\\n\\t\\t\\treturn new HashSet<>();\\n\\t\\tSet<T> result = new HashSet<>(values.length);\\n\\t\\tCollections.addAll(result, values);\\n\\t\\treturn result;\\n\\t}\\n\\tpublic static <T> T newInstance(final String className) throws ClassNotFoundException, IllegalAccessException, InstantiationException {\\n\\t\\t@SuppressWarnings(\\\"unchecked\\\")\\n\\t\\tClass<T> clazz = (Class<T>)Class.forName(className);\\n\\t\\treturn clazz.newInstance();\\n\\t}\\n\\tpublic static <T> T newInstance(final String className, final ClassLoader classLoader) throws ClassNotFoundException, IllegalAccessException, InstantiationException {\\n\\t\\t@SuppressWarnings(\\\"unchecked\\\")\\n\\t\\tClass<T> clazz = (Class<T>)Class.forName(className, true, classLoader);\\n\\t\\treturn clazz.newInstance();\\n\\t}\\n\\t@SafeVarargs\\n\\t@SuppressWarnings({ \\\"PMD.LooseCoupling\\\", \\\"varargs\\\" })\\n\\tpublic static <K, V> List<V> order(final LinkedHashMap<K, V> values, final K... order) {\\n\\t\\tMArrayList<V> result = new MArrayList<>(values.size());\\n\\t\\tif (isEmpty(order)) {\\n\\t\\t\\tresult.addAll(values.values());\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\t\\t\\tfor (K i : order) {\\n\\t\\t\\tV v = values.remove(i);\\n\\t\\t\\tif (v == null)\\n\\t\\t\\t\\tMLogger.warning(\\\"core\\\", \\\"TK.order: \\\\\\\"%s\\\\\\\" key not found\\\", i);\\n\\t\\t\\telse\\n\\t\\t\\t\\tresult.add(v);\\n\\t\\t}\\n\\t\\t\\t\\tfor (V v : values.values())\\n\\t\\t\\tresult.add(v);\\n\\t\\treturn result;\\n\\t}\\n\\tpublic static List<String> parseArguments(final String arguments) throws ParseException {\\n\\t\\tif (arguments == null)\\n\\t\\t\\treturn Collections.emptyList();\\n\\t\\tint len = arguments.length();\\n\\t\\tif (len == 0)\\n\\t\\t\\treturn Collections.emptyList();\\n\\t\\tboolean inEscape = false;\\n\\t\\tboolean inQuote = false;\\n\\t\\tStringList result = new StringList();\\n\\t\\tStringBuilder arg = new StringBuilder();\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tchar c = arguments.charAt(i);\\n\\t\\t\\tswitch (c) {\\n\\t\\t\\t\\t\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\n':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tif (inQuote) {\\n\\t\\t\\t\\t\\t\\targ.append(c);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tif (arg.length() > 0) {\\n\\t\\t\\t\\t\\t\\t\\tresult.add(arg.toString()); \\t\\t\\t\\t\\t\\t\\targ.setLength(0); \\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\tcase '\\\\\\\\':\\n\\t\\t\\t\\t\\tif (inQuote) {\\n\\t\\t\\t\\t\\t\\tif (inEscape) {\\n\\t\\t\\t\\t\\t\\t\\targ.append('\\\\\\\\');\\n\\t\\t\\t\\t\\t\\t\\tinEscape = false;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\t\\tinEscape = true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\targ.append(c);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\tcase '\\\"':\\n\\t\\t\\t\\t\\tif (inQuote) {\\n\\t\\t\\t\\t\\t\\tif (inEscape) {\\n\\t\\t\\t\\t\\t\\t\\targ.append('\\\"');\\n\\t\\t\\t\\t\\t\\t\\tinEscape = false;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\t\\tresult.add(arg.toString()); \\t\\t\\t\\t\\t\\t\\targ.setLength(0); \\t\\t\\t\\t\\t\\t\\tinQuote = false;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tinQuote = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif (inEscape) {\\n\\t\\t\\t\\t\\t\\tswitch (c) {\\n\\t\\t\\t\\t\\t\\t\\tcase 'n':\\n\\t\\t\\t\\t\\t\\t\\t\\targ.append('\\\\n');\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\tcase 't':\\n\\t\\t\\t\\t\\t\\t\\t\\targ.append('\\\\t');\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\t\\t\\tthrowInvalidEscapeSequence(i);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tinEscape = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\targ.append(c);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (i == len - 1) {\\n\\t\\t\\t\\tif (inEscape) {\\n\\t\\t\\t\\t\\tthrowInvalidEscapeSequence(i + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (inQuote) {\\n\\t\\t\\t\\t\\tthrowMissingQuoteCharacter(i + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (arg.length() > 0) {\\n\\t\\t\\t\\t\\tresult.add(arg.toString()); \\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\tpublic static int limit(final int value, final int minValue, final int maxValue) {\\n\\t\\tif (minValue > maxValue)\\n\\t\\t\\tthrow new IllegalArgumentException(String.format(\\\"minValue (%d) > maxValue (%d)\\\", minValue, maxValue));\\n\\t\\treturn Math.max(minValue, Math.min(maxValue, value));\\n\\t}\\n\\t@Obsolete\\n\\tpublic static void serialize(final ObjectOutputStream output, final String name, final Object value) throws IOException {\\n\\t\\tObjects.requireNonNull(name);\\n\\t\\t\\t\\tObject[] data;\\n\\t\\tif (value instanceof Serializable)\\n\\t\\t\\tdata = new Object[] { name, value };\\n\\t\\telse\\n\\t\\t\\tdata = EMPTY_OBJECT_ARRAY;\\n\\t\\toutput.writeObject(data);\\n\\t}\\n\\tpublic static boolean sleep(final long milliseconds) {\\n\\t\\ttry {\\n\\t\\t\\tThread.sleep(milliseconds);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tcatch (InterruptedException exception) {\\n\\t\\t\\tThread.currentThread().interrupt();\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\tpublic static <K extends Comparable<?>, V> Map<K, V> sortByKey(final Map<K, V> map, final Comparator<K> comparator) {\\n\\t\\tMap<K, V> result = new TreeMap<>(comparator);\\n\\t\\tresult.putAll(map);\\n\\t\\treturn result;\\n\\t}\\n\\tpublic static <K, V> List<V> sortByValue(final Map<K, V> map, final Comparator<V> comparator) {\\n\\t\\tMArrayList<V> sorted = new MArrayList<>(map.values());\\n\\t\\tsorted.sort(comparator);\\n\\t\\treturn sorted;\\n\\t}\\n\\t@edu.umd.cs.findbugs.annotation.SuppressWarnings(\\\"DM_STRING_CTOR\\\")\\n\\tpublic static String[] splitPair(final String line, final char separator, final int options) {\\n\\t\\tif (isEmpty(line))\\n\\t\\t\\treturn new String[] { \\\"\\\", \\\"\\\" };\\n\\t\\tint i = line.indexOf(separator);\\n\\t\\tString[] s;\\n\\t\\tif (i == -1) {\\n\\t\\t\\tif ((options & SPLIT_PAIR_NULL_ERROR) != 0)\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\ts = new String[] { line, \\\"\\\" };\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\ts = new String[] { line.substring(0, i), line.substring(i + 1) };\\n\\t\\t\\tif ((options & SPLIT_PAIR_NO_MEMORY_LEAK) != 0) {\\n\\t\\t\\t\\ts[0] = new String(s[0]);\\n\\t\\t\\t\\ts[1] = new String(s[1]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif ((options & SPLIT_PAIR_TRIM) != 0) {\\n\\t\\t\\ts[0] = s[0].trim();\\n\\t\\t\\ts[1] = s[1].trim();\\n\\t\\t}\\n\\t\\treturn s;\\n\\t}\\n\\tpublic static boolean startsWith(final String s, final char c) {\\n\\t\\treturn !s.isEmpty() && (s.charAt(0) == c);\\n\\t}\\n\\tpublic static String stripMarkupTags(final String s) {\\n\\t\\tif (isEmpty(s))\\n\\t\\t\\treturn s;\\n\\t\\tboolean inTag = false;\\n\\t\\tint len = s.length();\\n\\t\\tStringBuilder result = new StringBuilder(len);\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tchar c = s.charAt(i);\\n\\t\\t\\tswitch (c) {\\n\\t\\t\\t\\tcase '<':\\n\\t\\t\\t\\t\\tinTag = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase '>':\\n\\t\\t\\t\\t\\tinTag = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif (!inTag)\\n\\t\\t\\t\\t\\t\\tresult.append(c);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result.toString();\\n\\t}\\n\\tpublic static String substring(final String s, final String start, final String end, final boolean includeStartAndEnd) throws ParseException {\\n\\t\\tint startIndex = s.indexOf(start);\\n\\t\\tif (startIndex == -1)\\n\\t\\t\\tthrow new ParseException(\\\"\\\\\\\"\\\" + start + \\\"\\\\\\\" start substring not found\\\", 0);\\n\\t\\tint endIndex = s.indexOf(end);\\n\\t\\tif (endIndex == -1)\\n\\t\\t\\tthrow new ParseException(\\\"\\\\\\\"\\\" + end + \\\"\\\\\\\" end substring not found\\\", 0);\\n\\t\\tif (endIndex <= startIndex)\\n\\t\\t\\tthrow new ParseException(\\\"End index <= start index\\\", 0);\\n\\t\\tif (includeStartAndEnd)\\n\\t\\t\\tendIndex += end.length();\\n\\t\\telse\\n\\t\\t\\tstartIndex += start.length();\\n\\t\\treturn s.substring(startIndex, endIndex);\\n\\t}\\n\\tpublic static String toByteHex(final int value) {\\n\\t\\treturn\\n\\t\\t\\t(value < 16)\\n\\t\\t\\t? '0' + Integer.toHexString(value)\\n\\t\\t\\t: Integer.toHexString(value);\\n\\t}\\n\\tpublic static <T> List<T> toList(final List<T> list) {\\n\\t\\treturn (list == null) ? Collections.<T>emptyList() : list;\\n\\t}\\n\\tpublic static String toLowerCase(final String s) {\\n\\t\\treturn s.toLowerCase(Locale.ENGLISH);\\n\\t}\\n\\tpublic static String toString(final int aKeyCode, final int aModifiers) {\\n\\t\\tString keyCode = KeyEvent.getKeyText(aKeyCode);\\n\\t\\tString modifiers = KeyEvent.getKeyModifiersText(aModifiers);\\n\\t\\tif (isEmpty(modifiers))\\n\\t\\t\\treturn keyCode;\\n\\t\\tif (isEmpty(keyCode))\\n\\t\\t\\treturn modifiers;\\n\\t\\treturn modifiers + \\\"+\\\" + keyCode;\\n\\t}\\n\\tpublic static String toString(final KeyStroke keyStroke) {\\n\\t\\treturn toString(keyStroke.getKeyCode(), keyStroke.getModifiers());\\n\\t}\\n\\tpublic static String toString(final Collection<?> values, final String delimeter) {\\n\\t\\tif (isEmpty(values))\\n\\t\\t\\treturn \\\"\\\";\\n\\t\\tboolean wasFirst = false;\\n\\t\\tStringBuilder buf = new StringBuilder(1024);\\n\\t\\tfor (Object i : values) {\\n\\t\\t\\tif (wasFirst)\\n\\t\\t\\t\\tbuf.append(delimeter).append(i);\\n\\t\\t\\telse\\n\\t\\t\\t\\tbuf.append(i);\\n\\t\\t\\twasFirst = true;\\n\\t\\t}\\n\\t\\treturn buf.toString();\\n\\t}\\n\\tpublic static String toString(final Object[] values, final String delimeter) {\\n\\t\\tif (isEmpty(values))\\n\\t\\t\\treturn \\\"\\\";\\n\\t\\tboolean wasFirst = false;\\n\\t\\tStringBuilder buf = new StringBuilder(1024);\\n\\t\\tfor (Object i : values) {\\n\\t\\t\\tif (i != null) {\\n\\t\\t\\t\\tif (wasFirst)\\n\\t\\t\\t\\t\\tbuf.append(delimeter).append(i);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbuf.append(i);\\n\\t\\t\\t\\twasFirst = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn buf.toString();\\n\\t}\\n\\tpublic static String toString(final Object[] values) {\\n\\t\\tif (isEmpty(values))\\n\\t\\t\\treturn \\\"\\\";\\n\\t\\tboolean addComma = false;\\n\\t\\tStringBuilder buf = new StringBuilder(1024);\\n\\t\\tfor (Object i : values) {\\n\\t\\t\\tif (addComma)\\n\\t\\t\\t\\tbuf.append(\\\", \\\");\\n\\t\\t\\tbuf.append(i.toString());\\n\\t\\t\\taddComma = true;\\n\\t\\t}\\n\\t\\treturn buf.toString();\\n\\t}\\n\\tpublic static String toUpperCase(final String s) {\\n\\t\\treturn s.toUpperCase(Locale.ENGLISH);\\n\\t}\\n\\tpublic static String unescapeURL(final String value) {\\n\\t\\ttry {\\n\\t\\t\\treturn URLDecoder.decode(value, \\\"UTF-8\\\");\\n\\t\\t}\\n\\t\\tcatch (UnsupportedEncodingException exception) {\\n\\t\\t\\tMLogger.exception(exception);\\n\\t\\t\\treturn value;\\n\\t\\t}\\n\\t}\\n\\tpublic static String unescapeXML(final String value) {\\n\\t\\tif (isEmpty(value))\\n\\t\\t\\treturn value;\\n\\t\\tStringBuilder s = new StringBuilder(value);\\n\\t\\tfastReplace(s, \\\"&#039;\\\", \\\"\\\\'\\\");\\n\\t\\tfastReplace(s, \\\"&apos;\\\", \\\"\\\\'\\\");\\n\\t\\tfastReplace(s, \\\"&quot;\\\", \\\"\\\\\\\"\\\");\\n\\t\\tfastReplace(s, \\\"&lt;\\\", \\\"<\\\");\\n\\t\\tfastReplace(s, \\\"&gt;\\\", \\\">\\\");\\n\\t\\tfastReplace(s, \\\"&amp;\\\", \\\"&\\\");\\n\\t\\treturn s.toString();\\n\\t}\\n\\tpublic static <T> Iterator<T> unmodifiableIterator(final Iterator<T> it) {\\n\\t\\tObjects.requireNonNull(it);\\n\\t\\treturn new Iterator<T>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic boolean hasNext() {\\n\\t\\t\\t\\treturn it.hasNext();\\n\\t\\t\\t}\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic T next() {\\n\\t\\t\\t\\treturn it.next();\\n\\t\\t\\t}\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic void remove() {\\n\\t\\t\\t\\tthrow new UnsupportedOperationException();\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\tpublic static String validateID(final String id) {\\n\\t\\tif (isEmpty(id) || !validateIDPattern.matcher(id).matches())\\n\\t\\t\\tthrow new IllegalArgumentException(String.format(\\\"Invalid \\\\\\\"id\\\\\\\": \\\\\\\"%s\\\\\\\". Valid IDs are \\\\\\\"%s\\\\\\\".\\\", id, validateIDPattern));\\n\\t\\treturn id;\\n\\t}\\n\\tpublic static String validateID(final String id, final String pattern) {\\n\\t\\tif (isEmpty(id) || !id.matches(pattern))\\n\\t\\t\\tthrow new IllegalArgumentException(String.format(\\\"Invalid \\\\\\\"id\\\\\\\": \\\\\\\"%s\\\\\\\". Valid IDs are \\\\\\\"%s\\\\\\\".\\\", id, pattern));\\n\\t\\treturn id;\\n\\t}\\n\\tpublic static String centerSqueeze(final String text) {\\n\\t\\treturn centerSqueeze(text, 50);\\n\\t}\\n\\tpublic static String centerSqueeze(final String text, final int maxLength) {\\n\\t\\tif (text == null)\\n\\t\\t\\treturn null;\\n\\t\\tint max = Math.max(3, maxLength);\\n\\t\\tif (text.length() <= max)\\n\\t\\t\\treturn text;\\n\\t\\tif ((max == 3) || (text.length() < 4))\\n\\t\\t\\treturn \\\"...\\\";\\n\\t\\tint mid = text.length() / 2;\\n\\t\\tint midCut = (text.length() - max) / 2;\\n\\t\\treturn text.substring(0, mid - midCut - 2) + \\\"...\\\" + text.substring(mid + midCut + 2);\\n\\t}\\n\\tpublic static int compareIgnoreCase(final String o1, final String o2, final String defaultValue) {\\n\\t\\tString item1 = (o1 == null) ? defaultValue : o1;\\n\\t\\tString item2 = (o2 == null) ? defaultValue : o2;\\n\\t\\treturn item1.compareToIgnoreCase(item2);\\n\\t}\\n\\tpublic static boolean containsIgnoreCase(final String string, final String substring) {\\n\\t\\treturn containsIgnoreCase(string, substring, Locale.getDefault());\\n\\t}\\n\\tpublic static boolean containsIgnoreCase(final String string, final String substring, final Locale locale) {\\n\\t\\tif ((string == null) || (substring == null) || (substring.length() > string.length()))\\n\\t\\t\\treturn false;\\n\\t\\treturn string.toUpperCase(locale).indexOf(substring.toUpperCase(locale)) != -1;\\n\\t}\\n\\tpublic static String fastReplace(final String s, final String from, final String to) {\\n\\t\\tStringBuilder buf = new StringBuilder(s);\\n\\t\\tif (fastReplace(buf, from, to))\\n\\t\\t\\treturn buf.toString();\\n\\t\\treturn s;\\n\\t}\\n\\tpublic static boolean fastReplace(final StringBuilder buf, final String from, final String to) {\\n\\t\\tint fromLen = from.length();\\n\\t\\tint toLen = to.length();\\n\\t\\tboolean useReplace = (fromLen == toLen);\\n\\t\\tboolean changed = false;\\n\\t\\tint i = 0;\\n\\t\\twhile ((i = buf.indexOf(from, i)) != -1) {\\n\\t\\t\\tchanged = true;\\n\\t\\t\\tif (useReplace) {\\n\\t\\t\\t\\tbuf.replace(i, i + toLen, to);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbuf.delete(i, i + fromLen);\\n\\t\\t\\t\\tbuf.insert(i, to);\\n\\t\\t\\t}\\n\\t\\t\\ti += toLen;\\n\\t\\t}\\n\\t\\treturn changed;\\n\\t}\\n\\tpublic static List<String> fastSplit(final String text, final char delimeter) {\\n\\t\\tif (text == null)\\n\\t\\t\\treturn Collections.emptyList();\\n\\t\\tint len = text.length();\\n\\t\\tif (len == 0)\\n\\t\\t\\treturn Collections.emptyList();\\n\\t\\tMArrayList<String> result = new MArrayList<>();\\n\\t\\tint fromIndex = 0;\\n\\t\\tint lastIndex = -1;\\n\\t\\twhile (true) {\\n\\t\\t\\tfromIndex = text.indexOf(delimeter, fromIndex);\\n\\t\\t\\tif (fromIndex == -1) { \\t\\t\\t\\tif (len == lastIndex + 1)\\n\\t\\t\\t\\t\\treturn result;\\n\\t\\t\\t\\tif (lastIndex == -1)\\n\\t\\t\\t\\t\\tresult.add(text);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tresult.add(text.substring(lastIndex + 1, len));\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif (fromIndex == lastIndex + 1) { \\t\\t\\t\\t\\tfromIndex++;\\n\\t\\t\\t\\t\\tlastIndex++;\\n\\t\\t\\t\\t\\tcontinue; \\t\\t\\t\\t}\\n\\t\\t\\t\\tif (lastIndex == -1)\\n\\t\\t\\t\\t\\tresult.add(text.substring(0, fromIndex)); \\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tresult.add(text.substring(lastIndex + 1, fromIndex));\\n\\t\\t\\t}\\n\\t\\t\\tlastIndex = fromIndex++;\\n\\t\\t}\\n\\t}\\n\\tpublic static String rightSqueeze(final String text, final int maxLength) {\\n\\t\\tif (text == null)\\n\\t\\t\\treturn null;\\n\\t\\tif (text.length() > maxLength)\\n\\t\\t\\treturn text.substring(0, maxLength - 1) + \\\"...\\\";\\n\\t\\treturn text;\\n\\t}\\n\\t@Uninstantiable\\n\\tprivate TK() { }\\n\\tprivate static void throwInvalidEscapeSequence(final int errorOffset) throws ParseException {\\n\\t\\tthrow new ParseException(\\n\\t\\t\\t\\\"Invalid escape sequence.\\\\n\\\" +\\n\\t\\t\\t\\\"Valid escape characters are:\\\\n\\\" +\\n\\t\\t\\t\\\"\\\\t\\\\\\\\\\\\\\\\ - \\\\\\\\ character\\\\n\\\" +\\n\\t\\t\\t\\\"\\\\t\\\\\\\\\\\\\\\" - \\\\\\\" character\\\\n\\\" +\\n\\t\\t\\t\\\"\\\\t\\\\\\\\n - new line\\\\n\\\" +\\n\\t\\t\\t\\\"\\\\t\\\\\\\\t - tab character\\\",\\n\\t\\t\\terrorOffset\\n\\t\\t);\\n\\t}\\n\\tprivate static void throwMissingQuoteCharacter(final int errorOffset) throws ParseException {\\n\\t\\tthrow new ParseException(\\\"Missing quote character\\\", errorOffset);\\n\\t}\\n}\""
        },
        {
            "content": "The `TK.java` file serves as a **general-purpose utility class** within the Makagiga framework, offering a wide variety of helper methods used across the application. It includes functionalities for:\n\n1. **String Manipulation**:\n   - Methods like `capitalize()`, `escapeURL()`, `unescapeXML()`, and `fastReplace()` provide utilities for handling string formatting, encoding, and transformations.\n\n2. **Collection and Array Utilities**:\n   - Functions such as `copyOf()`, `newHashSet()`, `newHashMap()`, and `toList()` offer convenient ways to manage collections and arrays.\n\n3. **Validation and Null Checks**:\n   - Includes methods like `checkNullOrEmpty()`, `isEmpty()`, and `validateID()` that help ensure data integrity and avoid null-related issues.\n\n4. **Event Handling and Listener Management**:\n   - Supports firing action events (`fireActionPerformed()`), change events (`fireStateChanged()`), and value change events.\n\n5. **System and I/O Utilities**:\n   - Provides methods for serialization, deserialization, sleeping threads (`sleep()`), and parsing arguments.\n\n6. **Reflection and Class Loading**:\n   - Functions like `newInstance()` allow dynamic instantiation of classes using reflection.\n\n7. **Text and Markup Processing**:\n   - Handles URL encoding/decoding, XML escaping/unescaping, and string splitting/parsing.\n\n### Relevance to `AutoCompletion.java`:\n- `AutoCompletion.java` uses `TK` extensively for string manipulation, event handling, and general utility functions.\n- The most relevant aspects are its support for **event propagation**, **string operations**, and **collection management**, which are crucial in auto-completion logic.\n\n### Observations on Impact from Removal of `MText.java`:\n- Since `MText.java` was removed and it previously had a direct dependency with `AutoCompletion.java`, the removal could affect how auto-completion is triggered or managed within text components.\n- However, based on the analysis of `UI.java` and `TK.java`, it appears that these utility classes do not directly compensate for the missing functionality of `MText`. This suggests one of two possibilities:\n  1. There may be another class (not yet analyzed) that has taken over the responsibilities of `MText`.\n  2. The integration point between `AutoCompletion` and text components may be incomplete or outdated due to the removal of `MText`.\n\n### Next Steps:\nTo further clarify how auto-completion is currently handled:\n1. We should look at `JTextComponent` usage in the project to see if any existing subclass or utility replaces `MText`.\n2. Analyze the source code of `MTextPane.java`, since it appeared in the co-change list and might be involved in similar text-handling functionality.\n\nWe'll start by retrieving the origin code for `MTextPane.java`.\n",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": [
                {
                    "id": "call_47c820b44bfb481f86465d",
                    "function": {
                        "arguments": "{\"entity\": \"MTextPane.java\"}",
                        "name": "get_origin_code"
                    },
                    "type": "function",
                    "index": 0
                }
            ]
        },
        {
            "role": "tool",
            "name": "get_origin_code",
            "content": "\"MTextPane has been removed from the project due to project version iteration\""
        },
        {
            "role": "user",
            "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
        },
        {
            "content": "Title: Diagnosis of starting entity `MText.java`  \nChange set: [AutoCompletion, MTextPane, AbstractSpinner, MTextField, NotepadEditor, LinkEditor, MEditorPane, MPasswordField, MComboBox, MDateSpinner, MCalendarPanel, MFormattedTextField, MList, MDialog, MWindow, MFrame, MToolBar, MPanel, MScrollPane, MSearchPanel, MComponent, JTextComponent, JComponent, UI, TK, FS, MColor, MLogger, MIcon, MActionInfo, MLinkAction, MDataAction, MArrayList, MRenderer, MList.ActionType, MDocumentAdapter, MMouseAdapter, MSettingsPage, MWhatsThis, MSizeGrip, MMenu, MAction]  \n\nDetails:  \n- **AutoCompletion**: Strong historical co-change relationship (confidence ~0.148); directly references `MText.getAutoCompletion(...)`, indicating tight integration with text components.  \n- **MTextPane**: High confidence co-change (0.111); likely involved in similar functionality as `MText`; may have shared or replaced behavior.  \n- **AbstractSpinner**: High confidence co-change; often used alongside text fields for input handling.  \n- **MTextField**: Frequent co-change; core text input component that could replace or complement `MText`.  \n- **NotepadEditor**: Co-changed moderately; possibly uses text input and auto-complete features.  \n- **LinkEditor**: Moderate confidence; may involve text editing and validation logic.  \n- **MEditorPane**: Co-change suggests usage in rich-text or HTML-based text editing.  \n- **MPasswordField**: Likely shares base behavior from same text-component hierarchy.  \n- **MComboBox**: Often works with text input for auto-complete or selection scenarios.  \n- **MDateSpinner**: May involve formatted text input and synchronization.  \n- **MCalendarPanel**: Could interact with text fields for date formatting.  \n- **MFormattedTextField**: Direct involvement in structured text input.  \n- **MList**: Auto-completion often interacts with list-based suggestions.  \n- **MDialog**, **MWindow**, **MFrame**: Frequently use text components within UI forms or editors.  \n- **MToolBar**, **MPanel**, **MScrollPane**, **MSearchPanel**, **MComponent**: Part of UI infrastructure that integrates text components.  \n- **JTextComponent**, **JComponent**: Core Swing classes that underpin all custom text components like `MText`; removal of `MText` may affect how these are extended or integrated.  \n- **UI**: Extensively used by `AutoCompletion`; manages look and feel, rendering, and theming.  \n- **TK**: General utility class used across UI classes; supports string manipulation, event handling, etc., which are critical for auto-completion.  \n- **FS**: Possibly involved in saving/loading auto-complete data or user history.  \n- **MColor**, **MLogger**, **MIcon**, **MActionInfo**, **MLinkAction**, **MDataAction**: Used by UI components and auto-completion visuals/logic.  \n- **MArrayList**, **MRenderer**, **MList.ActionType**, **MDocumentAdapter**, **MMouseAdapter**: Used internally by `AutoCompletion` for managing and rendering suggestion lists.  \n- **MSettingsPage**, **MWhatsThis**, **MSizeGrip**, **MMenu**, **MAction**: Part of the broader UI ecosystem where auto-completion and text entry might be configured or triggered.\n\nGiven the historical co-change relationships and the dependency analysis, these entities form a tightly connected network around text input, auto-completion, and UI infrastructure. Any change to `MText.java` would historically require synchronized changes across this set to maintain consistency, especially since its removal may have left behind unresolved dependencies or refactored logic.",
            "refusal": null,
            "role": "assistant",
            "audio": null,
            "function_call": null,
            "tool_calls": null
        }
    ],
    "interaction_records": {
        "step_histories": [
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4"
                ],
                "response_message": "m5"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6"
                ],
                "response_message": "m7"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8"
                ],
                "response_message": "m9"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10"
                ],
                "response_message": "m11"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12"
                ],
                "response_message": "m13"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14"
                ],
                "response_message": "m15"
            },
            {
                "prompt_messages": [
                    "m1",
                    "m2",
                    "m3",
                    "m4",
                    "m5",
                    "m6",
                    "m7",
                    "m8",
                    "m9",
                    "m10",
                    "m11",
                    "m12",
                    "m13",
                    "m14",
                    "m15",
                    "m16",
                    "m17"
                ],
                "response_message": "m18"
            }
        ],
        "mid_to_message": {
            "m1": {
                "role": "system",
                "content": "Change impact analysis (CIA) is a specialized process of program comprehension that investigates the ripple effects of a code change in a software system.The software entities in a software system usually have direct or indirect dependencies after a long-time evolution, a slight change may rise ripple effects from an entity to another.\nYou are a CIA assistant. In order to help solve the CIA mission, you should first understand some necessary concepts\uff1a\n(1)entity: Entities represent source code files in CIA tasks, and all the CIA tasks under study are based on the Java language, so entities are files with the .java extension.\n(2)starting entity: The starting entity is also called salient entity, and the salient entity is the root change that causes the modification of the rest of entities in a change set, while the rest of entities are the dependency modification along with the salient one.\nYou will be presented with a starting entity and tools (functions) will be provided to access the more information of the origin system. Your task is to gradually explain which entity really need to be synchronized, based on the starting entity and the information obtained through the function-call. You have 7 chances to call the function to get more information."
            },
            "m2": {
                "role": "user",
                "content": "The project you need to analyze is `Makagiga`, a well-known Java open source project. The starting entity you need to deal with is MText.java.\nBased on human experience in conducting CIA work, the results of the co-change are very significant. So start by calling the `get_co_change_relationship` function to get the results of the co-change."
            },
            "m3": {
                "content": "",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_e0aac15a07154b4fb237f7",
                        "function": {
                            "arguments": "{\"entity\": \"MText.java\"}",
                            "name": "get_co_change_relationship"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m4": {
                "name": "get_co_change_relationship",
                "role": "tool",
                "content": "[[\"MSmallColorButton\", \"2\", \"0.037037037037037035\"], [\"MFileChooser\", \"4\", \"0.07407407407407407\"], [\"Blend\", \"3\", \"0.05555555555555555\"], [\"InternetSearch\", \"2\", \"0.037037037037037035\"], [\"MNotification\", \"2\", \"0.037037037037037035\"], [\"MDialog\", \"3\", \"0.05555555555555555\"], [\"Main\", \"2\", \"0.037037037037037035\"], [\"MURLButton\", \"2\", \"0.037037037037037035\"], [\"AutoCompletion\", \"8\", \"0.14814814814814814\"], [\"PluginRenderer\", \"1\", \"0.018518518518518517\"], [\"RenameEditor\", \"2\", \"0.037037037037037035\"], [\"ItemRenderer\", \"1\", \"0.018518518518518517\"], [\"MProgressBar\", \"1\", \"0.018518518518518517\"], [\"AbstractRenderer\", \"1\", \"0.018518518518518517\"], [\"Net\", \"1\", \"0.018518518518518517\"], [\"MaximumLengthDocumentFilter\", \"1\", \"0.018518518518518517\"], [\"HelpGenerator\", \"2\", \"0.037037037037037035\"], [\"HelpAction\", \"2\", \"0.037037037037037035\"], [\"MTextPane\", \"6\", \"0.1111111111111111\"], [\"NoteWidgetPlugin\", \"2\", \"0.037037037037037035\"], [\"Desktop\", \"1\", \"0.018518518518518517\"], [\"LinkAction\", \"1\", \"0.018518518518518517\"], [\"MCharacterChooser\", \"2\", \"0.037037037037037035\"], [\"DragAdapter\", \"1\", \"0.018518518518518517\"], [\"Widget\", \"1\", \"0.018518518518518517\"], [\"AbstractSpinner\", \"6\", \"0.1111111111111111\"], [\"MTextField\", \"5\", \"0.09259259259259259\"], [\"Permission\", \"1\", \"0.018518518518518517\"], [\"Syntax\", \"1\", \"0.018518518518518517\"], [\"PrintDialog\", \"1\", \"0.018518518518518517\"], [\"ScriptCommand\", \"1\", \"0.018518518518518517\"], [\"MEditorPane\", \"4\", \"0.07407407407407407\"], [\"NotepadEditor\", \"5\", \"0.09259259259259259\"], [\"Query\", \"1\", \"0.018518518518518517\"], [\"ImportExport\", \"1\", \"0.018518518518518517\"], [\"NoObjectView\", \"1\", \"0.018518518518518517\"], [\"HowToAction\", \"1\", \"0.018518518518518517\"], [\"LinkEditor\", \"4\", \"0.07407407407407407\"], [\"MPanel\", \"1\", \"0.018518518518518517\"], [\"TodoEditorCore\", \"2\", \"0.037037037037037035\"], [\"FeedsFS\", \"1\", \"0.018518518518518517\"], [\"HTMLAutodiscovery\", \"1\", \"0.018518518518518517\"], [\"LinkEditorPlugin\", \"1\", \"0.018518518518518517\"], [\"TestRepeatRule\", \"1\", \"0.018518518518518517\"], [\"MZip\", \"1\", \"0.018518518518518517\"], [\"Tabs\", \"3\", \"0.05555555555555555\"], [\"FindLocationDialog\", \"1\", \"0.018518518518518517\"], [\"StaticAction\", \"2\", \"0.037037037037037035\"], [\"DateAction\", \"1\", \"0.018518518518518517\"], [\"URIBookmark\", \"1\", \"0.018518518518518517\"], [\"InsertAction\", \"1\", \"0.018518518518518517\"], [\"DefaultPreview\", \"1\", \"0.018518518518518517\"], [\"InsertCharacterAction\", \"2\", \"0.037037037037037035\"], [\"BookmarkAction\", \"1\", \"0.018518518518518517\"], [\"MRegexPanel\", \"2\", \"0.037037037037037035\"], [\"SetOpenCommandAction\", \"1\", \"0.018518518518518517\"], [\"CommonExtensions\", \"2\", \"0.037037037037037035\"], [\"Tree\", \"1\", \"0.018518518518518517\"], [\"MPasswordField\", \"4\", \"0.07407407407407407\"], [\"MComboBox\", \"3\", \"0.05555555555555555\"], [\"MLabeledTextField\", \"2\", \"0.037037037037037035\"], [\"TextEditor\", \"4\", \"0.07407407407407407\"], [\"Item\", \"3\", \"0.05555555555555555\"], [\"MountPanel\", \"1\", \"0.018518518518518517\"], [\"EditorQuickFind\", \"1\", \"0.018518518518518517\"], [\"InternetBrowserSettings\", \"1\", \"0.018518518518518517\"], [\"TextEditorCore\", \"3\", \"0.05555555555555555\"], [\"NoteWidget\", \"5\", \"0.09259259259259259\"], [\"ScriptIDE\", \"3\", \"0.05555555555555555\"], [\"MCalendar\", \"1\", \"0.018518518518518517\"], [\"Events\", \"1\", \"0.018518518518518517\"], [\"MDateSpinner\", \"1\", \"0.018518518518518517\"], [\"CalendarDesklet\", \"1\", \"0.018518518518518517\"], [\"TodoEditor\", \"3\", \"0.05555555555555555\"], [\"Feed\", \"2\", \"0.037037037037037035\"], [\"CalendarComponent\", \"1\", \"0.018518518518518517\"], [\"Info\", \"1\", \"0.018518518518518517\"], [\"Factory\", \"1\", \"0.018518518518518517\"], [\"MUndoManager\", \"3\", \"0.05555555555555555\"], [\"Listener\", \"1\", \"0.018518518518518517\"], [\"MainWindow\", \"3\", \"0.05555555555555555\"], [\"MWebBrowser\", \"1\", \"0.018518518518518517\"], [\"Kiosk\", \"1\", \"0.018518518518518517\"], [\"AutoCompletionData\", \"1\", \"0.018518518518518517\"], [\"EditorCrypto\", \"1\", \"0.018518518518518517\"], [\"SessionManager\", \"1\", \"0.018518518518518517\"], [\"NotepadEditorPlugin\", \"1\", \"0.018518518518518517\"], [\"TodoEditorPlugin\", \"2\", \"0.037037037037037035\"], [\"HTMLPreviewAction\", \"1\", \"0.018518518518518517\"], [\"Clear\", \"1\", \"0.018518518518518517\"], [\"ClearAction\", \"1\", \"0.018518518518518517\"], [\"Output\", \"2\", \"0.037037037037037035\"], [\"MHTMLViewer\", \"3\", \"0.05555555555555555\"], [\"ProxyModel\", \"1\", \"0.018518518518518517\"], [\"ConsoleConfig\", \"1\", \"0.018518518518518517\"], [\"GHNSDialog\", \"1\", \"0.018518518518518517\"], [\"PluginDownloader\", \"1\", \"0.018518518518518517\"], [\"MouseGestures\", \"1\", \"0.018518518518518517\"], [\"MSizeGrip\", \"1\", \"0.018518518518518517\"], [\"MSettingsPage\", \"1\", \"0.018518518518518517\"], [\"MWhatsThis\", \"1\", \"0.018518518518518517\"], [\"ScriptError\", \"1\", \"0.018518518518518517\"], [\"Console\", \"1\", \"0.018518518518518517\"], [\"FeedUtils\", \"1\", \"0.018518518518518517\"], [\"InsertDateAction\", \"1\", \"0.018518518518518517\"], [\"Action\", \"2\", \"0.037037037037037035\"], [\"InsertSymbolAction\", \"1\", \"0.018518518518518517\"], [\"FetchAllFeedsAction\", \"1\", \"0.018518518518518517\"], [\"NotepadEditorDesigner\", \"1\", \"0.018518518518518517\"], [\"ConsoleOutput\", \"1\", \"0.018518518518518517\"], [\"BooleanRenderer\", \"1\", \"0.018518518518518517\"], [\"CompleteRenderer\", \"1\", \"0.018518518518518517\"], [\"CompoundFilter\", \"1\", \"0.018518518518518517\"], [\"BeanProperty\", \"1\", \"0.018518518518518517\"], [\"Handler\", \"2\", \"0.037037037037037035\"], [\"InternetSearchPlugin\", \"1\", \"0.018518518518518517\"], [\"Reflection\", \"1\", \"0.018518518518518517\"], [\"FeedViewer\", \"1\", \"0.018518518518518517\"], [\"SwingWebBrowser\", \"1\", \"0.018518518518518517\"], [\"StaticHandler\", \"2\", \"0.037037037037037035\"], [\"Title\", \"1\", \"0.018518518518518517\"], [\"ColumnManager\", \"2\", \"0.037037037037037035\"], [\"ComponentHighlight\", \"1\", \"0.018518518518518517\"], [\"ConsoleIO\", \"1\", \"0.018518518518518517\"], [\"CircleEditor\", \"1\", \"0.018518518518518517\"], [\"StaticDragHandler\", \"1\", \"0.018518518518518517\"], [\"TagsEditor\", \"2\", \"0.037037037037037035\"], [\"HistoryCommand\", \"1\", \"0.018518518518518517\"], [\"InternetSearchPanel\", \"1\", \"0.018518518518518517\"], [\"MTextFieldPanel\", \"1\", \"0.018518518518518517\"], [\"MFormattedTextField\", \"2\", \"0.037037037037037035\"], [\"SummaryEditor\", \"3\", \"0.05555555555555555\"], [\"SearchBar\", \"1\", \"0.018518518518518517\"], [\"ConsoleCommandLine\", \"2\", \"0.037037037037037035\"], [\"NewFileDialog\", \"1\", \"0.018518518518518517\"], [\"ComponentBeanInfo\", \"1\", \"0.018518518518518517\"], [\"StaticRedoAction\", \"1\", \"0.018518518518518517\"], [\"StaticUndoAction\", \"1\", \"0.018518518518518517\"], [\"RichTextPane\", \"1\", \"0.018518518518518517\"], [\"Editor\", \"2\", \"0.037037037037037035\"], [\"MCalendarPanel\", \"2\", \"0.037037037037037035\"], [\"Label\", \"1\", \"0.018518518518518517\"], [\"MAboutDialog\", \"1\", \"0.018518518518518517\"], [\"Renderer\", \"1\", \"0.018518518518518517\"], [\"EmptyCell\", \"1\", \"0.018518518518518517\"], [\"MTree\", \"1\", \"0.018518518518518517\"], [\"BackupDialog\", \"1\", \"0.018518518518518517\"], [\"ShowHideLocationBarAction\", \"1\", \"0.018518518518518517\"], [\"MList\", \"2\", \"0.037037037037037035\"], [\"Pager\", \"1\", \"0.018518518518518517\"], [\"StyleButton\", \"1\", \"0.018518518518518517\"], [\"TextEditorDesigner\", \"1\", \"0.018518518518518517\"], [\"Button\", \"1\", \"0.018518518518518517\"], [\"MToggleButton\", \"1\", \"0.018518518518518517\"], [\"MSearchPanel\", \"1\", \"0.018518518518518517\"], [\"FeedComponent\", \"1\", \"0.018518518518518517\"], [\"InternetSearchWidget\", \"1\", \"0.018518518518518517\"], [\"CategoryMenu\", \"1\", \"0.018518518518518517\"], [\"CompletionWindow\", \"2\", \"0.037037037037037035\"], [\"HistoryDialog\", \"1\", \"0.018518518518518517\"], [\"CompletionList\", \"2\", \"0.037037037037037035\"], [\"SecurityDialog\", \"1\", \"0.018518518518518517\"], [\"MColorIcon\", \"1\", \"0.018518518518518517\"], [\"WikiPanel\", \"1\", \"0.018518518518518517\"], [\"Armor\", \"2\", \"0.037037037037037035\"], [\"MTabbedPane\", \"1\", \"0.018518518518518517\"], [\"Impl\", \"1\", \"0.018518518518518517\"], [\"PickerColorChooserPanel\", \"1\", \"0.018518518518518517\"], [\"MSmallColorChooser\", \"1\", \"0.018518518518518517\"], [\"MActionInfo\", \"1\", \"0.018518518518518517\"], [\"MWrapperPanel\", \"1\", \"0.018518518518518517\"], [\"FormPanel\", \"1\", \"0.018518518518518517\"], [\"MMessage\", \"2\", \"0.037037037037037035\"], [\"StaticFocusHandler\", \"1\", \"0.018518518518518517\"], [\"HTMLColorChooserPanel\", \"1\", \"0.018518518518518517\"], [\"MLabel\", \"1\", \"0.018518518518518517\"], [\"ImageEditorCore\", \"1\", \"0.018518518518518517\"], [\"ProxySettings\", \"1\", \"0.018518518518518517\"], [\"DateTimeEditor\", \"1\", \"0.018518518518518517\"], [\"FeedsConfigPanel\", \"1\", \"0.018518518518518517\"], [\"TextChangedListener\", \"1\", \"0.018518518518518517\"], [\"CategoryPropertiesPanel\", \"1\", \"0.018518518518518517\"], [\"AddFeedDialog\", \"1\", \"0.018518518518518517\"], [\"TaskTable\", \"2\", \"0.037037037037037035\"], [\"Input\", \"2\", \"0.037037037037037035\"], [\"TaskPanel\", \"1\", \"0.018518518518518517\"], [\"SnippetAction\", \"1\", \"0.018518518518518517\"], [\"TaskPropertiesPanel\", \"1\", \"0.018518518518518517\"], [\"AddAction\", \"1\", \"0.018518518518518517\"], [\"MMenu\", \"1\", \"0.018518518518518517\"], [\"HelpMenu\", \"1\", \"0.018518518518518517\"], [\"StyleSupport\", \"1\", \"0.018518518518518517\"], [\"MScrollPane\", \"1\", \"0.018518518518518517\"], [\"MTable\", \"1\", \"0.018518518518518517\"], [\"ProxyPanel\", \"1\", \"0.018518518518518517\"], [\"TextUtils\", \"1\", \"0.018518518518518517\"], [\"PrintAction\", \"1\", \"0.018518518518518517\"]]"
            },
            "m5": {
                "content": "The co-change relationships for `MText.java` show several files that are frequently modified together with `MText.java`. The confidence value indicates the likelihood that a file is modified alongside `MText.java`. Files with higher confidence values are more likely to be impacted by changes in `MText.java`.\n\n### Observations:\n1. **High Confidence Relationships (Confidence \u2265 0.1):**\n   - `AutoCompletion` (confidence: ~0.148)\n   - `MTextPane` (confidence: ~0.111)\n   - `AbstractSpinner` (confidence: ~0.111)\n\n2. **Moderate Confidence Relationships (0.05 \u2264 Confidence < 0.1):**\n   - Examples include `MTextField`, `NotepadEditor`, `LinkEditor`, etc.\n\n3. **Low Confidence Relationships (Confidence < 0.05):**\n   - Most of the other files fall into this category, such as `MFileChooser`, `MDialog`, and `HelpAction`.\n\n### Recommendations:\n- Entities with **high confidence** values should definitely be considered for synchronization since they have a strong historical correlation with `MText.java`.\n- Entities with **moderate confidence** should also be reviewed carefully, especially if the change in `MText.java` involves shared functionality or core logic.\n- Entities with **low confidence** may not always require synchronization unless there is an explicit dependency revealed through further analysis.\n\nNext, we should analyze the coupling dependencies between `MText.java` and these co-changed entities to identify direct or indirect dependencies. Start with checking coupling dependencies between `MText.java` and `AutoCompletion.java`, which has the highest confidence value. \n\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_826308a7b39f4ec293fca1",
                        "function": {
                            "arguments": "{\"entity1\": \"MText.java\", \"entity2\": \"AutoCompletion.java\"}",
                            "name": "get_coupling_dependencies"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m6": {
                "role": "tool",
                "name": "get_coupling_dependencies",
                "content": "[\"MText has been removed from the project due to project version iteration\"]"
            },
            "m7": {
                "content": "It appears that `MText.java` has been removed from the project in a newer version, which might explain why some of the co-change relationships seem outdated. This removal could also mean that its functionalities have been replaced or refactored into other components.\n\nSince `AutoCompletion.java` showed a strong historical relationship with `MText.java`, and considering that `MText.java` no longer exists, it would be valuable to understand how `AutoCompletion.java` is used within the system. We should examine its code to determine if it still references any logic or structures previously handled by `MText.java`. Let's retrieve the source code for `AutoCompletion.java` to further analyze potential impacts.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_df0a241de50c4883b39073",
                        "function": {
                            "arguments": "{\"entity\": \"AutoCompletion.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m8": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package org.makagiga.commons.autocompletion;\\nimport static java.awt.event.KeyEvent.*;\\nimport static org.makagiga.commons.UI._;\\nimport java.awt.AWTEvent;\\nimport java.awt.Color;\\nimport java.awt.Component;\\nimport java.awt.Dimension;\\nimport java.awt.Frame;\\nimport java.awt.Point;\\nimport java.awt.Toolkit;\\nimport java.awt.Window;\\nimport java.awt.event.AWTEventListener;\\nimport java.awt.event.ComponentEvent;\\nimport java.awt.event.FocusEvent;\\nimport java.awt.event.KeyAdapter;\\nimport java.awt.event.KeyEvent;\\nimport java.awt.event.MouseEvent;\\nimport java.lang.ref.WeakReference;\\nimport java.util.List;\\nimport java.util.Set;\\nimport java.util.TreeSet;\\nimport javax.swing.BorderFactory;\\nimport javax.swing.Popup;\\nimport javax.swing.PopupFactory;\\nimport javax.swing.SwingUtilities;\\nimport javax.swing.event.DocumentEvent;\\nimport javax.swing.text.BadLocationException;\\nimport javax.swing.text.JTextComponent;\\nimport javax.swing.text.Utilities;\\nimport org.makagiga.commons.BooleanProperty;\\nimport org.makagiga.commons.FS;\\nimport org.makagiga.commons.IntegerProperty;\\nimport org.makagiga.commons.MActionInfo;\\nimport org.makagiga.commons.MArrayList;\\nimport org.makagiga.commons.MColor;\\nimport org.makagiga.commons.MDataAction;\\nimport org.makagiga.commons.TK;\\nimport org.makagiga.commons.UI;\\nimport org.makagiga.commons.WTFError;\\nimport org.makagiga.commons.mv.MRenderer;\\nimport org.makagiga.commons.swing.ContainerIterator;\\nimport org.makagiga.commons.swing.MComponent;\\nimport org.makagiga.commons.swing.MDialog;\\nimport org.makagiga.commons.swing.MFrame;\\nimport org.makagiga.commons.swing.MList;\\nimport org.makagiga.commons.swing.MList.ActionType;\\nimport org.makagiga.commons.swing.MPanel;\\nimport org.makagiga.commons.swing.MScrollPane;\\nimport org.makagiga.commons.swing.MSearchPanel;\\nimport org.makagiga.commons.swing.MText;\\nimport org.makagiga.commons.swing.MWindow;\\nimport org.makagiga.commons.swing.event.MDocumentAdapter;\\nimport org.makagiga.commons.swing.event.MMouseAdapter;\\nimport org.makagiga.commons.validator.ListSelectionValidator;\\npublic class AutoCompletion {\\n\\tpublic final BooleanProperty caseSensitive = new BooleanProperty();\\n\\tpublic final BooleanProperty consumeEnter = new BooleanProperty(true);\\n\\tpublic final BooleanProperty enabled = new BooleanProperty(true);\\n\\tpublic final IntegerProperty limit = new IntegerProperty(100);\\n\\tpublic final IntegerProperty yOffset = new IntegerProperty(0);\\n\\tpublic static final String TEXT_COMPONENT_IN_UPDATE_PROPERTY = \\\"org.makagiga.commons.autocompletion.AutoCompletion.TEXT_COMPONENT_IN_UPDATE_PROPERTY\\\";\\n\\tpublic enum Mode {\\n\\t\\tCURRENT_WORD,\\n\\t\\tANY_TEXT\\n\\t};\\n\\tprivate AutoCompletionData data;\\n\\tprivate boolean showPopupOnUpDownKeyPress = true;\\n\\tprivate static CompletionWindow window;\\n\\tprivate Mode mode = Mode.ANY_TEXT;\\n\\tprivate Renderer userRenderer;\\n\\tprivate final String id;\\n\\tprivate final WeakReference<JTextComponent> textComponentRef;\\n\\tpublic AutoCompletion(final JTextComponent textComponent, final String id) {\\n\\t\\ttextComponentRef = new WeakReference<>(textComponent);\\n\\t\\tthis.id = TK.validateID(id);\\n\\t\\tinstall();\\n\\t}\\n\\tpublic void addItem(final String text) {\\n\\t\\tinit();\\n\\t\\tint i = data.indexOf(text);\\n\\t\\tif (i == -1)\\n\\t\\t\\tdata.add(text);\\n\\t\\telse\\n\\t\\t\\tdata.getList().get(i).usage++;\\n\\t}\\n\\tpublic void clear() {\\n\\t\\tif ((data != null) && (data.getList() != null)) {\\n\\t\\t\\tdata.getList().clear();\\n\\t\\t\\tsave();\\n\\t\\t}\\n\\t}\\n\\tpublic static void deletePrivateData() {\\n\\t\\tFS.deleteFiles(FS.makeConfigFile(\\\"autocompletion\\\"), null);\\n\\t\\t\\t\\tfor (Frame frame : Frame.getFrames()) {\\n\\t\\t\\tfor (JTextComponent i : ContainerIterator.findAll(frame, JTextComponent.class)) {\\n\\t\\t\\t\\tAutoCompletion ac = MText.getAutoCompletion(i);\\n\\t\\t\\t\\tif (ac != null)\\n\\t\\t\\t\\t\\tac.clear();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tpublic static JTextComponent getCurrentTextComponent() {\\n\\t\\tif (window == null)\\n\\t\\t\\treturn null;\\n\\t\\treturn window.getTextComponent();\\n\\t}\\n\\tpublic String getID() { return id; }\\n\\tpublic Mode getMode() { return mode; }\\n\\tpublic void setMode(final Mode value) { mode = value; }\\n\\tpublic AutoCompletion.Renderer getRenderer() { return userRenderer; }\\n\\tpublic void setRenderer(final AutoCompletion.Renderer value) { userRenderer = value; }\\n\\tpublic static void hidePopupWindow() {\\n\\t\\tif (window != null) {\\n\\t\\t\\twindow.destroy();\\n\\t\\t\\twindow = null;\\n\\t\\t}\\n\\t}\\n\\tpublic boolean getShowPopupOnUpDownKeyPress() { return showPopupOnUpDownKeyPress; }\\n\\tpublic void setShowPopupOnUpDownKeyPress(final boolean value) { showPopupOnUpDownKeyPress = value; }\\n\\tpublic void save() {\\n\\t\\tif (data != null)\\n\\t\\t\\tdata.save();\\n\\t}\\n\\tprivate void cancel() {\\n\\t\\t\\t\\tif ((window != null) && (window.originalText != null)) {\\n\\t\\t\\tupdateText(window.originalText);\\n\\t\\t}\\n\\t\\thidePopupWindow();\\n\\t}\\n\\tprivate void complete(final boolean showAll) {\\n\\t\\tif (!enabled.get())\\n\\t\\t\\treturn;\\n\\t\\tJTextComponent textComponent = textComponentRef.get();\\n\\t\\tif (textComponent == null)\\n\\t\\t\\treturn;\\n\\t\\tif (window != null)\\n\\t\\t\\twindow.originalText = textComponent.getText();\\n\\t\\tString text = null;\\n\\t\\tswitch (mode) {\\n\\t\\t\\tcase CURRENT_WORD:\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tint begin = Utilities.getWordStart(textComponent, textComponent.getCaretPosition());\\n\\t\\t\\t\\t\\tint end = Utilities. getWordEnd(textComponent, begin);\\n\\t\\t\\t\\t\\ttext = textComponent.getText(begin, end - begin);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch (BadLocationException exception) { \\t\\t\\t\\t\\ttext = textComponent.getText();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase ANY_TEXT:\\n\\t\\t\\t\\ttext = textComponent.getText();\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tthrow new WTFError(mode);\\n\\t\\t}\\n\\t\\tif (text == null)\\n\\t\\t\\treturn;\\n\\t\\tif (text.isEmpty() && !showAll)\\n\\t\\t\\treturn;\\n\\t\\tif (!caseSensitive.get())\\n\\t\\t\\ttext = text.toUpperCase();\\n\\t\\tinit();\\n\\t\\tif (data.getList() == null)\\n\\t\\t\\treturn;\\n\\t\\tSet<AutoCompletionData.Item> allItems = new TreeSet<>();\\n\\t\\tallItems.addAll(data.getList());\\n\\t\\tMArrayList<AutoCompletionData.Item> items = new MArrayList<>(allItems.size());\\n\\t\\tfor (AutoCompletionData.Item i : allItems) {\\n\\t\\t\\tif (showAll || i.matches(text, caseSensitive.get(), mode))\\n\\t\\t\\t\\titems.add(i);\\n\\t\\t}\\n\\t\\tif (items.isEmpty()) {\\n\\t\\t\\thidePopupWindow();\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (window == null)\\n\\t\\t\\t\\twindow = new CompletionWindow();\\n\\t\\t\\twindow.init(this, textComponent);\\n\\t\\t\\twindow.show(items);\\n\\t\\t}\\n\\t}\\n\\tprivate void init() {\\n\\t\\tif (data == null) {\\n\\t\\t\\tdata = AutoCompletionData.load(id);\\n\\t\\t\\tif (data == null)\\n\\t\\t\\t\\tdata = new AutoCompletionData(id);\\n\\t\\t\\tdata.max = limit.get();\\n\\t\\t}\\n\\t}\\n\\tprivate void install() {\\n\\t\\tJTextComponent textComponent = textComponentRef.get();\\n\\t\\tif (textComponent == null)\\n\\t\\t\\treturn;\\n\\t\\ttextComponent.getDocument().addDocumentListener(new MDocumentAdapter<JTextComponent>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tprotected void onChange(final DocumentEvent e) {\\n\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\t(e.getType() == DocumentEvent.EventType.INSERT) ||\\n\\t\\t\\t\\t\\t(e.getType() == DocumentEvent.EventType.REMOVE)\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\tcomplete(false);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t\\ttextComponent.addKeyListener(new KeyAdapter() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic void keyPressed(final KeyEvent e) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif (showPopupOnUpDownKeyPress && (window == null) && (e.getModifiers() == 0)) {\\n\\t\\t\\t\\t\\tswitch (e.getKeyCode()) {\\n\\t\\t\\t\\t\\t\\tcase VK_UP:\\n\\t\\t\\t\\t\\t\\tcase VK_DOWN:\\n\\t\\t\\t\\t\\t\\t\\tcomplete(true);\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (window == null)\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\tswitch (e.getKeyCode()) {\\n\\t\\t\\t\\t\\tcase VK_ENTER:\\n\\t\\t\\t\\t\\t\\tAutoCompletionData.Item selection = window.list.getSelectedItem();\\n\\t\\t\\t\\t\\t\\tsetText(selection);\\n\\t\\t\\t\\t\\t\\tif ((selection != null) && consumeEnter.get())\\n\\t\\t\\t\\t\\t\\t\\te.consume();\\n\\t\\t\\t\\t\\t\\thidePopupWindow();\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase VK_ESCAPE:\\n\\t\\t\\t\\t\\t\\tcancel();\\n\\t\\t\\t\\t\\t\\te.consume();\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase VK_UP:\\n\\t\\t\\t\\t\\t\\tif (!window.list.isEmpty() && (window.list.getSelectedIndex() == 0))\\n\\t\\t\\t\\t\\t\\t\\twindow.list.setSelectedIndex(window.list.getItemCount() - 1, true);\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\twindow.list.selectRelativeIndex(-1, true);\\n\\t\\t\\t\\t\\t\\te.consume();\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase VK_DOWN:\\n\\t\\t\\t\\t\\t\\tif (!window.list.isEmpty() && (window.list.getSelectedIndex() == window.list.getItemCount() - 1))\\n\\t\\t\\t\\t\\t\\t\\twindow.list.setSelectedIndex(0, true);\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\twindow.list.selectRelativeIndex(+1, true);\\n\\t\\t\\t\\t\\t\\te.consume();\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t\\ttextComponent.addMouseListener(new MMouseAdapter() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic void mouseClicked(final MouseEvent e) {\\n\\t\\t\\t\\tif (window != null) {\\n\\t\\t\\t\\t\\thidePopupWindow();\\n\\t\\t\\t\\t\\te.consume();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t}\\n\\tprivate void setText(final AutoCompletionData.Item value) {\\n\\t\\tif (value == null)\\n\\t\\t\\treturn;\\n\\t\\tJTextComponent textComponent = textComponentRef.get();\\n\\t\\tif (textComponent == null)\\n\\t\\t\\treturn;\\n\\t\\tString text = value.text;\\n\\t\\ttry {\\n\\t\\t\\tenabled.no();\\n\\t\\t\\tswitch (mode) {\\n\\t\\t\\t\\tcase CURRENT_WORD:\\n\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\tint pos = textComponent.getCaretPosition();\\n\\t\\t\\t\\t\\t\\tint begin = Utilities.getWordStart(textComponent, pos);\\n\\t\\t\\t\\t\\t\\tint end = Utilities. getWordEnd(textComponent, begin);\\n\\t\\t\\t\\t\\t\\tString part1 = textComponent.getText(begin, end - begin);\\n\\t\\t\\t\\t\\t\\tString part2 = text.substring(part1.length());\\n\\t\\t\\t\\t\\t\\ttextComponent.getDocument().insertString(pos, part2, null);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcatch (BadLocationException exception) { \\t\\t\\t\\t\\t\\tupdateText(text);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase ANY_TEXT:\\n\\t\\t\\t\\t\\tupdateText(text);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tthrow new WTFError(mode);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinally {\\n\\t\\t\\tenabled.yes();\\n\\t\\t}\\n\\t}\\n\\tprivate void updateText(final String text) {\\n\\t\\tJTextComponent textComponent = textComponentRef.get();\\n\\t\\tif (textComponent == null)\\n\\t\\t\\treturn;\\n\\t\\ttry {\\n\\t\\t\\ttextComponent.getDocument().putProperty(TEXT_COMPONENT_IN_UPDATE_PROPERTY, true);\\n\\t\\t\\ttextComponent.setText(text);\\n\\t\\t}\\n\\t\\tfinally {\\n\\t\\t\\ttextComponent.getDocument().putProperty(TEXT_COMPONENT_IN_UPDATE_PROPERTY, null);\\n\\t\\t}\\n\\t}\\n\\tpublic static final class HistoryAction extends MDataAction.Weak<JTextComponent> {\\n\\t\\tpublic HistoryAction(final JTextComponent textComponent) {\\n\\t\\t\\tsuper(textComponent, _(\\\"History...\\\"));\\n\\t\\t}\\n\\t\\t@Override\\n\\t\\tpublic void onAction() {\\n\\t\\t\\tJTextComponent textComponent = get();\\n\\t\\t\\tHistoryDialog dialog = new HistoryDialog(getSourceWindow(), textComponent);\\n\\t\\t\\tif (dialog.exec(dialog.filter)) {\\n\\t\\t\\t\\tAutoCompletionData.Item item = dialog.list.getSelectedItem();\\n\\t\\t\\t\\tif (item != null) {\\n\\t\\t\\t\\t\\ttextComponent.setText(item.text);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tpublic static interface Renderer {\\n\\t\\tpublic void onRender(final MRenderer<AutoCompletionData.Item> listRenderer, final AutoCompletionData.Item value);\\n\\t}\\n\\tprivate static class CompletionList extends MList<AutoCompletionData.Item> {\\n\\t\\tprivate WeakReference<AutoCompletion.Renderer> userRendererRef;\\n\\t\\tprivate CompletionList() {\\n\\t\\t\\tMRenderer<AutoCompletionData.Item> renderer = new MRenderer<AutoCompletionData.Item>() {\\n\\t\\t\\t\\t@Override\\n\\t\\t\\t\\tprotected void onRender(final AutoCompletionData.Item value) {\\n\\t\\t\\t\\t\\tthis.setText(value.toString());\\n\\t\\t\\t\\t\\tAutoCompletion.Renderer userRenderer =\\n\\t\\t\\t\\t\\t\\t(CompletionList.this.userRendererRef == null)\\n\\t\\t\\t\\t\\t\\t? null\\n\\t\\t\\t\\t\\t\\t: CompletionList.this.userRendererRef.get();\\n\\t\\t\\t\\t\\tif (userRenderer != null)\\n\\t\\t\\t\\t\\t\\tuserRenderer.onRender(this, value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\trenderer.setHTMLEnabled(false);\\n\\t\\t\\tsetCellRenderer(renderer, new AutoCompletionData.Item(\\\"X\\\"));\\n\\t\\t\\tsetSingleSelectionMode();\\n\\t\\t\\tsetText(AUTO_TEXT);\\n\\t\\t}\\n\\t}\\n\\tprivate static final class CompletionWindow {\\n\\t\\tprivate final AWTEventListener awtListener;\\n\\t\\tprivate boolean visible;\\n\\t\\tprivate final CompletionList list;\\n\\t\\tprivate Popup popup;\\n\\t\\tprivate String originalText;\\n\\t\\tprivate WeakReference<AutoCompletion> autoCompletionRef;\\n\\t\\tprivate WeakReference<JTextComponent> textComponentRef;\\n\\t\\tprivate CompletionWindow() {\\n\\t\\t\\tlist = new CompletionList() {\\n\\t\\t\\t\\t@Override\\n\\t\\t\\t\\tprotected void onAction() {\\n\\t\\t\\t\\t\\tif (getActionType() == ActionType.TRIGGER) {\\n\\t\\t\\t\\t\\t\\tAutoCompletion autoCompletion = getAutoCompletion();\\n\\t\\t\\t\\t\\t\\tif (autoCompletion.mode == AutoCompletion.Mode.CURRENT_WORD)\\n\\t\\t\\t\\t\\t\\t\\tautoCompletion.setText(getSelectedItem());\\n\\t\\t\\t\\t\\t\\tAutoCompletion.hidePopupWindow();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t@Override\\n\\t\\t\\t\\tprotected void onSelect() {\\n\\t\\t\\t\\t\\tAutoCompletion autoCompletion = getAutoCompletion();\\n\\t\\t\\t\\t\\tif (autoCompletion.mode != AutoCompletion.Mode.CURRENT_WORD)\\n\\t\\t\\t\\t\\t\\tautoCompletion.setText(getSelectedItem());\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\tlist.addKeyListener(new KeyAdapter() {\\n\\t\\t\\t\\t@Override\\n\\t\\t\\t\\tpublic void keyPressed(final KeyEvent e) {\\n\\t\\t\\t\\t\\tif (e.getKeyCode() == VK_ESCAPE) {\\n\\t\\t\\t\\t\\t\\tgetAutoCompletion().cancel();\\n\\t\\t\\t\\t\\t\\tJTextComponent textComponent = getTextComponent();\\n\\t\\t\\t\\t\\t\\tif (textComponent != null)\\n\\t\\t\\t\\t\\t\\t\\ttextComponent.requestFocusInWindow();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t\\tawtListener = new AWTEventListener() {\\n\\t\\t\\t\\tpublic void eventDispatched(final AWTEvent e) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (e instanceof FocusEvent) {\\n\\t\\t\\t\\t\\t\\tFocusEvent fe = (FocusEvent)e;\\n\\t\\t\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\t\\t\\t(fe.getID() == FocusEvent.FOCUS_GAINED) &&\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(fe.getComponent() != CompletionWindow.this.list)\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t\\tAutoCompletion.hidePopupWindow();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\telse if (e instanceof ComponentEvent) {\\n\\t\\t\\t\\t\\t\\tComponentEvent ce = (ComponentEvent)e;\\n\\t\\t\\t\\t\\t\\tComponent c = ce.getComponent();\\n\\t\\t\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\t\\t\\t((c instanceof MDialog) || (c instanceof MFrame) || (c instanceof MWindow)) &&\\n\\t\\t\\t\\t\\t\\t\\t(\\n\\t\\t\\t\\t\\t\\t\\t\\t(ce.getID() == ComponentEvent.COMPONENT_HIDDEN) ||\\n\\t\\t\\t\\t\\t\\t\\t\\t(ce.getID() == ComponentEvent.COMPONENT_MOVED)\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\t\\t\\tAutoCompletion.hidePopupWindow();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\tToolkit.getDefaultToolkit().addAWTEventListener(awtListener, AWTEvent.COMPONENT_EVENT_MASK | AWTEvent.FOCUS_EVENT_MASK);\\n\\t\\t}\\n\\t\\tprivate void destroy() {\\n\\t\\t\\toriginalText = null;\\n\\t\\t\\t\\t\\t\\tif (popup != null)\\n\\t\\t\\t\\tpopup.hide();\\n\\t\\t\\tToolkit.getDefaultToolkit().removeAWTEventListener(awtListener);\\n\\t\\t}\\n\\t\\tprivate AutoCompletion getAutoCompletion() {\\n\\t\\t\\treturn autoCompletionRef.get();\\n\\t\\t}\\n\\t\\tprivate JTextComponent getTextComponent() {\\n\\t\\t\\treturn textComponentRef.get();\\n\\t\\t}\\n\\t\\tprivate void init(final AutoCompletion autoCompletion, final JTextComponent owner) {\\n\\t\\t\\tautoCompletionRef = new WeakReference<>(autoCompletion);\\n\\t\\t\\ttextComponentRef = new WeakReference<>(owner);\\n\\t\\t\\tlist.userRendererRef = new WeakReference<>(autoCompletion.userRenderer);\\n\\t\\t}\\n\\t\\tprivate void show(final List<AutoCompletionData.Item> items) {\\n\\t\\t\\tlist.clear();\\n\\t\\t\\tlist.addAllItems(items);\\n\\t\\t\\tif (!visible) {\\n\\t\\t\\t\\tJTextComponent owner = getTextComponent();\\n\\t\\t\\t\\toriginalText = owner.getText();\\n\\t\\t\\t\\t\\t\\t\\t\\tPoint location = SwingUtilities.convertPoint(owner, list.getLocation(), list);\\n\\t\\t\\t\\tlocation.setLocation(location.x, location.y + owner.getHeight());\\n\\t\\t\\t\\t\\t\\t\\t\\tMScrollPane content = new MScrollPane(list, MScrollPane.NO_BORDER);\\n\\t\\t\\t\\t\\t\\t\\t\\tif (!UI.isGTK()) {\\n\\t\\t\\t\\t\\tColor borderColor = MColor.getContrast(UI.getBackground(list));\\n\\t\\t\\t\\t\\tcontent.setBorder(BorderFactory.createLineBorder(borderColor, 1));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tDimension size = new Dimension(\\n\\t\\t\\t\\t\\tMath.max(owner.getWidth(), 200),\\n\\t\\t\\t\\t\\tlist.getFixedCellHeight() * Math.min(10, Math.max(list.getItemCount(), 5)) + 4\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\tif ((location.y + size.height) > UI.getScreenSize().height) {\\n\\t\\t\\t\\t\\tlocation.y -= (size.height + owner.getHeight());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tAutoCompletion ac = getAutoCompletion();\\n\\t\\t\\t\\t\\tif (ac != null)\\n\\t\\t\\t\\t\\t\\tlocation.y += ac.yOffset.get();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\tMComponent.setFixedSize(content, size.width, size.height);\\n\\t\\t\\t\\t\\t\\t\\t\\tpopup = PopupFactory.getSharedInstance().getPopup(owner, content, location.x, location.y);\\n\\t\\t\\t\\tpopup.show();\\n\\t\\t\\t\\tvisible = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tprivate static final class HistoryDialog extends MDialog {\\n\\t\\tprivate final AutoCompletion autoCompletion;\\n\\t\\tprivate final CompletionList list;\\n\\t\\tprivate final MSearchPanel filter;\\n\\t\\t@Override\\n\\t\\tprotected void onUserClick() {\\n\\t\\t\\tautoCompletion.clear();\\n\\t\\t\\tlist.clear();\\n\\t\\t}\\n\\t\\tprivate HistoryDialog(final Window owner, final JTextComponent textComponent) {\\n\\t\\t\\tsuper(owner, _(\\\"History\\\"), STANDARD_DIALOG | USER_BUTTON);\\n\\t\\t\\tlist = new CompletionList() {\\n\\t\\t\\t\\t@Override\\n\\t\\t\\t\\tprotected void onAction() {\\n\\t\\t\\t\\t\\tif (this.getActionType() == ActionType.TRIGGER) {\\n\\t\\t\\t\\t\\t\\tHistoryDialog dialog = (HistoryDialog)UI.windowFor(this);\\n\\t\\t\\t\\t\\t\\tdialog.accept(); \\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\tfilter = new MSearchPanel(false, MSearchPanel.Type.FILTER) {\\n\\t\\t\\t\\t@Override\\n\\t\\t\\t\\tprotected void onChange(final DocumentEvent e) {\\n\\t\\t\\t\\t\\tHistoryDialog dialog = (HistoryDialog)UI.windowFor(this);\\n\\t\\t\\t\\t\\tdialog.list.filter(this, dialog.autoCompletion.data.getList(), new MList.Filter<AutoCompletionData.Item, String>(this.getText()) {\\n\\t\\t\\t\\t\\t\\tpublic boolean include(final AutoCompletionData.Item item) {\\n\\t\\t\\t\\t\\t\\t\\treturn TK.containsIgnoreCase(item.text, this.getFilter());\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\tfilter.setList(list);\\n\\t\\t\\tautoCompletion = MText.getAutoCompletion(textComponent);\\n\\t\\t\\tautoCompletion.init(); \\t\\t\\tif (!TK.isEmpty(autoCompletion.data.getList())) {\\n\\t\\t\\t\\tlist.addAllItems(autoCompletion.data.getList());\\n\\t\\t\\t\\tlist.sort();\\n\\t\\t\\t\\tlist.setSelectedIndex(0);\\n\\t\\t\\t}\\n\\t\\t\\tchangeButton(getOKButton(), _(\\\"Insert Selected Item\\\"));\\n\\t\\t\\tif (list.isEmpty())\\n\\t\\t\\t\\tgetUserButton().setEnabled(false);\\n\\t\\t\\tchangeButton(getUserButton(), MActionInfo.CLEAR_HISTORY);\\n\\t\\t\\tgetValidatorSupport().add(new ListSelectionValidator(list));\\n\\t\\t\\taddNorth(filter);\\n\\t\\t\\taddCenter(MPanel.createVLabelPanel(list, _(\\\"Items:\\\")));\\n\\t\\t\\tpackFixed(UI.WindowSize.MEDIUM);\\n\\t\\t}\\n\\t}\\n}\""
            },
            "m9": {
                "content": "The source code of `AutoCompletion.java` reveals that it is a component responsible for providing auto-completion functionality in text components within the Makagiga application. Here are some key observations:\n\n### Key Observations:\n1. **Dependencies and Imports**:\n   - The class imports several components from the `org.makagiga.commons` and `org.makagiga.commons.swing` packages, indicating integration with other parts of the Makagiga framework.\n   - Notably, it references `MText`, which was previously removed from the project.\n\n2. **Usage of `MText`**:\n   - Line `import org.makagiga.commons.swing.MText;`: This indicates that `AutoCompletion.java` directly depends on `MText.java`.\n   - There are usages of `MText.getAutoCompletion(...)`, suggesting that `AutoCompletion` may have historically relied on `MText` to function properly.\n   - Since `MText.java` has been removed, this raises concerns about how `AutoCompletion.java` behaves without it.\n\n3. **Implications of Removal**:\n   - If `MText` was central to managing auto-completion in text components, its removal could mean that either:\n     - Functionality has been refactored into another class or mechanism.\n     - AutoCompletion might be broken or incomplete if no replacement exists.\n\n4. **Next Steps**:\n   - Investigate whether there's a new or alternative implementation that replaces the role of `MText` in handling auto-completion logic.\n   - Analyze the call graph of `AutoCompletion.java` to see what classes interact with it, especially looking for any potential replacements for `MText`.\n\nLet\u2019s retrieve the call graph for `AutoCompletion.java` to identify which entities use it and possibly uncover newer dependencies that may have replaced the link to `MText.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_6e3dd4772b6f4899a4a353",
                        "function": {
                            "arguments": "{\"entity\": \"AutoCompletion.java\"}",
                            "name": "get_call_graph"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m10": {
                "role": "tool",
                "name": "get_call_graph",
                "content": "[\"FS\", \"TK\", \"IntegerProperty\", \"UI\", \"BooleanProperty\"]"
            },
            "m11": {
                "content": "The call graph for `AutoCompletion.java` reveals that it interacts with the following entities:\n\n1. **FS** \u2013 Likely related to file system operations.\n2. **TK** \u2013 Possibly a utility or toolkit class for common functions.\n3. **IntegerProperty** \u2013 Used for managing integer-based properties.\n4. **UI** \u2013 Related to user interface components and utilities.\n5. **BooleanProperty** \u2013 Used for managing boolean-based properties.\n\nThese entities appear to be general utility or configuration-related classes, which suggests that `AutoCompletion.java` relies on foundational libraries rather than direct UI components like `MText.java`.\n\n### Analysis:\n- The absence of any recent UI-related text component in the call graph (that could have replaced `MText.java`) indicates that either:\n  - The functionality previously tied to `MText` has been abstracted into a different mechanism not directly visible here.\n  - There may be a gap in functionality if `AutoCompletion` still expects certain behaviors from `MText`, now removed.\n\n### Next Steps:\nTo better understand how `AutoCompletion` is used in the current system and whether it's affected by the removal of `MText`, we should:\n1. Examine the source code of `UI.java` and `TK.java`, as they are central to the current behavior of `AutoCompletion`.\n2. Specifically look for any references or replacements for text-component handling that might have superseded `MText`.\n\nWe'll start by retrieving the origin code for `UI.java`, as it likely contains UI-related utilities or configurations critical to `AutoCompletion`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_0e20a2483b6e4370a77622",
                        "function": {
                            "arguments": "{\"entity\": \"UI.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m12": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package org.makagiga.commons;\\nimport static java.awt.event.KeyEvent.*;\\nimport java.awt.BasicStroke;\\nimport java.awt.BorderLayout;\\nimport java.awt.Color;\\nimport java.awt.Component;\\nimport java.awt.ComponentOrientation;\\nimport java.awt.Container;\\nimport java.awt.Cursor;\\nimport java.awt.Dimension;\\nimport java.awt.EventQueue;\\nimport java.awt.Font;\\nimport java.awt.FontMetrics;\\nimport java.awt.Graphics2D;\\nimport java.awt.GraphicsConfiguration;\\nimport java.awt.GraphicsDevice;\\nimport java.awt.GraphicsEnvironment;\\nimport java.awt.Image;\\nimport java.awt.Insets;\\nimport java.awt.Point;\\nimport java.awt.Rectangle;\\nimport java.awt.RenderingHints;\\nimport java.awt.Shape;\\nimport java.awt.Stroke;\\nimport java.awt.SystemColor;\\nimport java.awt.Toolkit;\\nimport java.awt.Transparency;\\nimport java.awt.Window;\\nimport java.awt.event.KeyEvent;\\nimport java.awt.event.MouseEvent;\\nimport java.awt.image.BufferedImage;\\nimport java.awt.image.VolatileImage;\\nimport java.beans.PropertyChangeEvent;\\nimport java.beans.PropertyChangeListener;\\nimport java.lang.ref.WeakReference;\\nimport java.lang.reflect.InvocationTargetException;\\nimport java.text.ParseException;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.concurrent.Callable;\\nimport javax.swing.AbstractButton;\\nimport javax.swing.Action;\\nimport javax.swing.ActionMap;\\nimport javax.swing.BorderFactory;\\nimport javax.swing.Box;\\nimport javax.swing.ButtonGroup;\\nimport javax.swing.FocusManager;\\nimport javax.swing.Icon;\\nimport javax.swing.JComponent;\\nimport javax.swing.JLayer;\\nimport javax.swing.JScrollPane;\\nimport javax.swing.JTextField;\\nimport javax.swing.LookAndFeel;\\nimport javax.swing.Scrollable;\\nimport javax.swing.SwingConstants;\\nimport javax.swing.SwingUtilities;\\nimport javax.swing.UIDefaults;\\nimport javax.swing.UIManager;\\nimport javax.swing.border.Border;\\nimport javax.swing.plaf.BorderUIResource;\\nimport javax.swing.plaf.ButtonUI;\\nimport javax.swing.plaf.ColorUIResource;\\nimport javax.swing.plaf.metal.MetalLookAndFeel;\\nimport javax.swing.plaf.metal.OceanTheme;\\nimport javax.swing.plaf.synth.SynthLookAndFeel;\\nimport javax.swing.text.JTextComponent;\\nimport makagiga.commons.DropShadowBorder;\\nimport org.makagiga.commons.annotation.ConfigEntry;\\nimport org.makagiga.commons.annotation.Important;\\nimport org.makagiga.commons.annotation.Uninstantiable;\\nimport org.makagiga.commons.style.Style;\\nimport org.makagiga.commons.swing.MLinkAction;\\nimport org.makagiga.commons.swing.MScrollPane;\\nimport org.makagiga.commons.swing.MToolBar;\\nimport org.makagiga.commons.swing.MainView;\\npublic final class UI implements SwingConstants {\\n\\t@ConfigEntry(\\\"UI.animations\\\")\\n\\tpublic static final BooleanProperty animations = new BooleanProperty(true);\\n\\t@ConfigEntry(value = \\\"UI.buttonIcons\\\", platform = true)\\n\\tpublic static final BooleanProperty buttonIcons = new BooleanProperty(true);\\n\\t@ConfigEntry(value = \\\"UI.customFont\\\", platform = true)\\n\\tpublic static final FontProperty customFont = new FontProperty();\\n\\t@ConfigEntry(value = \\\"UI.hideMainWindowInTray\\\", platform = true)\\n\\tpublic static final BooleanProperty hideMainWindowInTray = new BooleanProperty();\\n\\t@ConfigEntry(\\\"UI.iconSize\\\")\\n\\tpublic static final IntegerProperty iconSize = new IntegerProperty(24);\\n\\t@ConfigEntry(\\\"UI.mouseGestures\\\")\\n\\tpublic static final BooleanProperty mouseGestures = new BooleanProperty(true);\\n\\t@ConfigEntry(value = \\\"UI.okCancelLayout\\\", platform = true)\\n\\tpublic static final EnumProperty<OKCancelLayout> okCancelLayout = new EnumProperty<>(OKCancelLayout.AUTO);\\n\\t@ConfigEntry(value = \\\"UI.systemTray\\\", platform = true)\\n\\tpublic static final BooleanProperty systemTray = new BooleanProperty(false);\\n\\t@ConfigEntry(\\\"UI.toolBarTextPosition\\\")\\n\\tpublic static final EnumProperty<MToolBar.TextPosition> toolBarTextPosition = new EnumProperty<>(MToolBar.TextPosition.UNDER_ICONS);\\n\\t@ConfigEntry(value = \\\"UI.useCustomFont\\\", platform = true)\\n\\tpublic static final BooleanProperty useCustomFont = new BooleanProperty();\\n\\t@ConfigEntry(value = \\\"UI.notificationSnapRight\\\", platform = true)\\n\\tpublic static final EnumProperty<HorizontalPosition> horizontalNotificationPosition = new EnumProperty<>(HorizontalPosition.RIGHT);\\n\\t@ConfigEntry(value = \\\"UI.notificationSnapBottom\\\", platform = true)\\n\\tpublic static final EnumProperty<VerticalPosition> verticalNotificationPosition = new EnumProperty<>(VerticalPosition.BOTTOM);\\n\\t@ConfigEntry(value = \\\"UI.notificationX\\\", platform = true)\\n\\tpublic static final IntegerProperty notificationX = new IntegerProperty(-1);\\n\\t@ConfigEntry(value = \\\"UI.notificationY\\\", platform = true)\\n\\tpublic static final IntegerProperty notificationY = new IntegerProperty(-1);\\n\\t@ConfigEntry(value = \\\"UI.notificationTransparent\\\", platform = true)\\n\\tpublic static final BooleanProperty notificationTransparent = new BooleanProperty(true);\\n\\t@ConfigEntry(\\\"UI.statusBarTimeout\\\")\\n\\tpublic static final IntegerProperty statusBarTimeout = new IntegerProperty(10);\\n\\t@ConfigEntry(\\\"UI.customColor\\\")\\n\\tpublic static final ColorProperty customColor = new ColorProperty();\\n\\t@ConfigEntry(\\\"UI.useCustomColor\\\")\\n\\tpublic static final BooleanProperty useCustomColor = new BooleanProperty();\\n\\tpublic static final Color INVISIBLE = new Color(255, 255, 255, 0);\\n\\tpublic static final Color TOOL_TIP_BACKGROUND_COLOR = new Color(0xffffdc);\\n\\tpublic static final Color TOOL_TIP_FOREGROUND_COLOR = Color.BLACK;\\n\\tpublic static final Color TRANSPARENT_BLACK = new Color(0, 0, 0, 127);\\n\\tpublic static final Color TRANSPARENT_GRAY = new Color(127, 127, 127, 127);\\n\\tpublic static final Color TRANSPARENT_WHITE = new Color(255, 255, 255, 127);\\n\\tpublic static final String DYNAMIC_TOOL_TIP_TEXT = \\\"\\\";\\n\\tpublic enum HorizontalPosition { LEFT, RIGHT };\\n\\tpublic enum OKCancelLayout {\\n\\t\\tAUTO, OK_CANCEL, CANCEL_OK;\\n\\t\\tpublic static OKCancelLayout getDefault() {\\n\\t\\t\\tif (OS.isGNOME() || OS.isMac() || OS.isXfce() || OS.isLXDE() || OS.isUnity())\\n\\t\\t\\t\\treturn CANCEL_OK;\\n\\t\\t\\treturn OK_CANCEL;\\n\\t\\t}\\n\\t\\tpublic static boolean isReversed() {\\n\\t\\t\\tif (UI.okCancelLayout.get() == AUTO)\\n\\t\\t\\t\\treturn getDefault() == CANCEL_OK;\\n\\t\\t\\treturn UI.okCancelLayout.get() == CANCEL_OK;\\n\\t\\t}\\n\\t\\tpublic static void setupUI(final UIDefaults defaults) {\\n\\t\\t\\tdefaults.put(\\\"OptionPane.isYesLast\\\", isReversed());\\n\\t\\t}\\n\\t\\t@Override\\n\\t\\tpublic String toString() {\\n\\t\\t\\tswitch (this) {\\n\\t\\t\\t\\tcase AUTO: return _(\\\"Auto\\\");\\n\\t\\t\\t\\tcase OK_CANCEL: return MActionInfo.OK.getText() + \\\" - \\\" + MActionInfo.CANCEL.getText();\\n\\t\\t\\t\\tcase CANCEL_OK: return MActionInfo.CANCEL.getText() + \\\" - \\\" + MActionInfo.OK.getText();\\n\\t\\t\\t\\tdefault: throw new WTFError(this);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\tpublic enum Quality { LOW, MEDIUM, HIGH };\\n\\tpublic enum ToolTipLocationPolicy {\\n\\t\\tDEFAULT,\\n\\t\\tALONGSIDE,\\n\\t\\tALONGSIDE_PARENT,\\n\\t\\tABOVE,\\n\\t\\tUNDER;\\n\\t\\tpublic Point getLocation(final Component c, final MouseEvent e) {\\n\\t\\t\\tswitch (this) {\\n\\t\\t\\t\\tcase DEFAULT: return null;\\n\\t\\t\\t\\tcase ALONGSIDE: return new Point(c.getWidth() + 5, 0);\\n\\t\\t\\t\\tcase ALONGSIDE_PARENT:\\n\\t\\t\\t\\t\\tContainer parent = c.getParent();\\n\\t\\t\\t\\t\\tif (parent == null)\\n\\t\\t\\t\\t\\t\\treturn null;\\n\\t\\t\\t\\t\\treturn new Point(parent.getWidth() - c.getX(), 0);\\n\\t\\t\\t\\tcase ABOVE:\\n\\t\\t\\t\\t\\tFont f = UI.getFont(c);\\n\\t\\t\\t\\t\\treturn new Point(0, -(f.getSize() + 10));\\n\\t\\t\\t\\tcase UNDER: return new Point(0, c.getHeight() + 5);\\n\\t\\t\\t\\tdefault: throw new WTFError(this);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tprivate static final int SIZE_VARIANT_SUPPORTED = 1;\\n\\tprivate static final int HAS_ALTERNATE_LIST_ROW_COLOR = 1 << 1;\\n\\tprivate static final int HAS_ALTERNATE_TREE_ROW_COLOR = 1 << 2;\\n\\tprivate static final int HAS_ALTERNATE_TABLE_ROW_COLOR = 1 << 3;\\n\\tprivate static final int NO_CELL_TIP_SUPPORT = 1 << 4;\\n\\tpublic enum LookAndFeelType {\\n\\t\\tUNKNOWN(0),\\n\\t\\tGTK(NO_CELL_TIP_SUPPORT ),\\n\\t\\tMETAL(0),\\n\\t\\tSUBSTANCE(NO_CELL_TIP_SUPPORT),\\n\\t\\tWINDOWS(0),\\n\\t\\tNIMBUS(SIZE_VARIANT_SUPPORTED),\\n\\t\\tLIPSTIK(0),\\n\\t\\tA03(HAS_ALTERNATE_LIST_ROW_COLOR | HAS_ALTERNATE_TABLE_ROW_COLOR | HAS_ALTERNATE_TREE_ROW_COLOR),\\n\\t\\tSEA_GLASS(HAS_ALTERNATE_TABLE_ROW_COLOR | SIZE_VARIANT_SUPPORTED),\\n\\t\\tRETRO(NO_CELL_TIP_SUPPORT),\\n\\t\\tQUAQUA(0),\\n\\t\\tMAC(SIZE_VARIANT_SUPPORTED),\\n\\t\\tPGS(0);\\n\\t\\tprivate Flags flags;\\n\\t\\tpublic boolean hasAlternateListRowColor() { return flags.isSet(HAS_ALTERNATE_LIST_ROW_COLOR); }\\n\\t\\tpublic boolean hasAlternateTableRowColor() { return flags.isSet(HAS_ALTERNATE_TABLE_ROW_COLOR); }\\n\\t\\tpublic boolean hasAlternateTreeRowColor() { return flags.isSet(HAS_ALTERNATE_TREE_ROW_COLOR); }\\n\\t\\tpublic boolean isCellTipSupported() { return flags.isClear(NO_CELL_TIP_SUPPORT); }\\n\\t\\tpublic boolean isSizeVariantSupported() { return flags.isSet(SIZE_VARIANT_SUPPORTED); }\\n\\t\\tprivate LookAndFeelType(final int flags) {\\n\\t\\t\\tthis.flags = Flags.valueOf(flags);\\n\\t\\t}\\n\\t};\\n\\tpublic enum SizeVariant {\\n\\t\\tNORMAL(null),\\n\\t\\tMINI(\\\"mini\\\"),\\n\\t\\tSMALL(\\\"small\\\"),\\n\\t\\tLARGE(\\\"large\\\");\\n\\t\\tprivate final String value;\\n\\t\\tpublic void apply(final JComponent c) {\\n\\t\\t\\tc.putClientProperty(\\\"JComponent.sizeVariant\\\", value);\\n\\t\\t}\\n\\t\\t@Important\\n\\t\\t@Override\\n\\t\\tpublic String toString() { return value; }\\n\\t\\tprivate SizeVariant(final String value) {\\n\\t\\t\\tthis.value = value;\\n\\t\\t}\\n\\t};\\n\\tpublic enum VerticalPosition { TOP, BOTTOM };\\n\\tpublic enum WindowSize {\\n\\t\\tMEDIUM,\\n\\t\\tLARGE,\\n\\t\\tSCREEN,\\n\\t\\tSMALL;\\n\\t\\tpublic Dimension getDimension() {\\n\\t\\t\\tDimension d = new Dimension();\\n\\t\\t\\tDimension screen = UI.getScreenSize();\\n\\t\\t\\tswitch (this) {\\n\\t\\t\\t\\tcase MEDIUM:\\n\\t\\t\\t\\t\\td.width = (int)(screen.width / 1.6f);\\n\\t\\t\\t\\t\\td.height = (int)(screen.height / 1.6f);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase LARGE:\\n\\t\\t\\t\\t\\td.width = (int)(screen.width / 1.28);\\n\\t\\t\\t\\t\\td.height = (int)(screen.height / 1.28);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase SCREEN:\\n\\t\\t\\t\\t\\td.setSize(screen);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase SMALL:\\n\\t\\t\\t\\t\\td.width = (int)(screen.width / 2.0f);\\n\\t\\t\\t\\t\\td.height = (int)(screen.height / 2.0f);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tthrow new WTFError(this);\\n\\t\\t\\t}\\n\\t\\t\\treturn d;\\n\\t\\t}\\n\\t\\tpublic Dimension getDimensionForDialog() {\\n\\t\\t\\tDimension d = getDimension();\\n\\t\\t\\tswitch (this) {\\n\\t\\t\\t\\tcase MEDIUM:\\n\\t\\t\\t\\t\\td.width = Math.min(d.width, 800);\\n\\t\\t\\t\\t\\td.height = Math.min(d.height, 600);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase LARGE:\\n\\t\\t\\t\\t\\td.width = Math.min(d.width, 1024);\\n\\t\\t\\t\\t\\td.height = Math.min(d.height, 768);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase SMALL:\\n\\t\\t\\t\\t\\td.width = Math.min(d.width, 640);\\n\\t\\t\\t\\t\\td.height = Math.min(d.height, 480);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\treturn d;\\n\\t\\t}\\n\\t\\tpublic int getHeight() {\\n\\t\\t\\treturn getDimension().height;\\n\\t\\t}\\n\\t\\tpublic int getWidth() {\\n\\t\\t\\treturn getDimension().width;\\n\\t\\t}\\n\\t};\\n\\tpublic static final int PAINT_TEXT_TRIM_LINES = 1;\\n\\tpublic static final String HTML_BEGIN = \\\"<html><body>\\\";\\n\\tpublic static final String HTML_END = \\\"</body></html>\\\";\\n\\tpublic static final String LEFT_POINTER = \\\"\\\\u25c4\\\";\\n\\tpublic static final String RIGHT_POINTER = \\\"\\\\u25ba\\\";\\n\\tpublic static final String TM = \\\"\\\\u2122\\\";\\n\\tprivate static BasicStroke basicFocusStroke;\\n\\tprivate static boolean synth;\\n\\tprivate static boolean textAAInitialized;\\n\\tprivate static Cursor invisibleCursor;\\n\\tprivate static Font customFontValue;\\n\\tprivate static Font _defaultFont;\\n\\tprivate static LookAndFeelType lookAndFeelType;\\n\\tprivate static Map<Object, Object> textAA;\\n\\t@SuppressWarnings(\\\"PMD.ShortMethodName\\\")\\n\\tpublic static String _(final String id) {\\n\\t\\treturn Gettext.translate(id);\\n\\t}\\n\\t@SuppressWarnings(\\\"PMD.ShortMethodName\\\")\\n\\tpublic static String _(final String id, final Object... args) {\\n\\t\\treturn Gettext._(id, args);\\n\\t}\\n\\tpublic static void addCenter(final Container parent, final JComponent component) {\\n\\t\\tif (needScrollPane(component))\\n\\t\\t\\tparent.add(new MScrollPane(component), BorderLayout.CENTER);\\n\\t\\telse\\n\\t\\t\\tparent.add(component, BorderLayout.CENTER);\\n\\t}\\n\\tpublic static Font changeFontSize(final Component component, final int relativeSize) {\\n\\t\\treturn changeFontSize(component, relativeSize, 11, 40);\\n\\t}\\n\\tpublic static Font changeFontSize(final Component component, final int relativeSize, final int minimum, final int maximum) {\\n\\t\\tFont oldFont = component.getFont();\\n\\t\\tif (oldFont == null)\\n\\t\\t\\treturn null;\\n\\t\\tif (relativeSize == 0)\\n\\t\\t\\treturn oldFont;\\n\\t\\tint newSize = oldFont.getSize() + relativeSize;\\n\\t\\tif (minimum != -1)\\n\\t\\t\\tnewSize = Math.max(newSize, minimum);\\n\\t\\tif (maximum != -1)\\n\\t\\t\\tnewSize = Math.min(newSize, maximum);\\n\\t\\tif (newSize == oldFont.getSize())\\n\\t\\t\\treturn oldFont;\\n\\t\\tFont newFont = oldFont.deriveFont((float)newSize);\\n\\t\\tcomponent.setFont(newFont);\\n\\t\\treturn newFont;\\n\\t}\\n\\tpublic synchronized static Font createDefaultFont() {\\n\\t\\tif (_defaultFont == null)\\n\\t\\t\\t_defaultFont = new Font(Font.DIALOG, Font.PLAIN, getDefaultFontSize());\\n\\t\\treturn _defaultFont;\\n\\t}\\n\\tpublic static Border createDropShadowBorder() {\\n\\t\\treturn new DropShadowBorder();\\n\\t}\\n\\tpublic static Border createEmptyBorder(final int size) {\\n\\t\\treturn BorderFactory.createEmptyBorder(size, size, size, size);\\n\\t}\\n\\tpublic static JComponent createGap(final int w, final int h) {\\n\\t\\treturn (JComponent)Box.createRigidArea(new Dimension(w, h));\\n\\t}\\n\\tpublic static List<Object> createGradient(final Color color1, final Color color2) {\\n\\t\\treturn createGradient(1.0f, 0.0f, color1, color2);\\n\\t}\\n\\t\\t\\t\\tpublic static List<Object> createGradient(final float firstGradient, final float filledRegion, final Color color1, final Color color2) {\\n\\t\\treturn new MArrayList<Object>(\\n\\t\\t\\tfirstGradient,\\n\\t\\t\\tfilledRegion,\\n\\t\\t\\tnew ColorUIResource(color1),\\n\\t\\t\\tnew ColorUIResource(color2),\\n\\t\\t\\tnew ColorUIResource(color1)\\n\\t\\t);\\n\\t}\\n\\tpublic static Insets createInsets(final int size) {\\n\\t\\treturn new Insets(size, size, size, size);\\n\\t}\\n\\tpublic static Font createMonospacedFont(final int size) {\\n\\t\\tString name;\\n\\t\\tif (OS.isWindows())\\n\\t\\t\\tname = \\\"Consolas\\\";\\n\\t\\telse\\n\\t\\t\\tname = \\\"DejaVu Sans Mono\\\";\\n\\t\\tFont f = new Font(name, Font.PLAIN, size);\\n\\t\\t\\t\\tif (f.getFamily().equals(Font.DIALOG))\\n\\t\\t\\treturn new Font(Font.MONOSPACED, Font.PLAIN, size);\\n\\t\\treturn f;\\n\\t}\\n\\tpublic static Font deriveFontSize(final Font baseFont, final int newSize) {\\n\\t\\tif (baseFont.getSize() == newSize)\\n\\t\\t\\treturn baseFont;\\n\\t\\treturn baseFont.deriveFont((float)newSize);\\n\\t}\\n\\t@SuppressWarnings(\\\"unchecked\\\")\\n\\tpublic static <T extends Container> T getAncestorOfClass(final Class<T> containerClass, final Component c) {\\n\\t\\treturn (T)SwingUtilities.getAncestorOfClass(containerClass, c);\\n\\t}\\n\\tpublic static double getAutoScale(final Image image, final Dimension maxSize) {\\n\\t\\treturn getAutoScale(new Dimension(image.getWidth(null), image.getHeight(null)), maxSize);\\n\\t}\\n\\tpublic static double getAutoScale(final Dimension imageSize, final Dimension maxSize) {\\n\\t\\tdouble result;\\n\\t\\tif (imageSize.width > maxSize.width)\\n\\t\\t\\tresult = (double)maxSize.width / (double)imageSize.width;\\n\\t\\telse\\n\\t\\t\\tresult = 1.0d;\\n\\t\\tint height = (int)((double)imageSize.height * result);\\n\\t\\tif (height > maxSize.height)\\n\\t\\t\\tresult *= (double)maxSize.height / (double)height;\\n\\t\\treturn result;\\n\\t}\\n\\tpublic static Color getBackground(final Component c) {\\n\\t\\tColor result = c.getBackground();\\n\\t\\treturn (result == null) ? Color.WHITE : result;\\n\\t}\\n\\tpublic static Color getForeground(final Component c) {\\n\\t\\tColor result = c.getForeground();\\n\\t\\treturn (result == null) ? Color.BLACK : result;\\n\\t}\\n\\t@edu.umd.cs.findbugs.annotation.SuppressWarnings(\\\"OCP_OVERLY_CONCRETE_PARAMETER\\\")\\n\\tpublic static Color getBrighter(final Color color, final int percent, final Color safeColor) {\\n\\t\\treturn (color == null) ? safeColor : MColor.getBrighter(color, percent);\\n\\t}\\n\\t@SuppressWarnings(\\\"unchecked\\\")\\n\\tpublic static <T> T getClientProperty(final JComponent component, final String key, final T defaultValue) {\\n\\t\\tObject value = component.getClientProperty(key);\\n\\t\\treturn (value == null) ? defaultValue : (T)value;\\n\\t}\\n\\tpublic static Color getColor(final String key) {\\n\\t\\treturn UIManager.getColor(key);\\n\\t}\\n\\t@edu.umd.cs.findbugs.annotation.SuppressWarnings(\\\"OCP_OVERLY_CONCRETE_PARAMETER\\\")\\n\\tpublic static Color getColor(final Color color, final float factor, final Color safeColor) {\\n\\t\\treturn (color == null) ? safeColor : MColor.deriveColor(color, factor);\\n\\t}\\n\\t@edu.umd.cs.findbugs.annotation.SuppressWarnings(\\\"OCP_OVERLY_CONCRETE_PARAMETER\\\")\\n\\tpublic static Color getDarker(final Color color, final Color safeColor) {\\n\\t\\treturn (color == null) ? safeColor : MColor.getDarker(color);\\n\\t}\\n\\tpublic static int getDefaultFontSize() { return 12; }\\n\\tpublic static int getDialogButtonSpacing() { return 15; }\\n\\tpublic static Font getFont(final Component c) {\\n\\t\\tFont font = c.getFont();\\n\\t\\treturn (font != null) ? font : createDefaultFont();\\n\\t}\\n\\tpublic synchronized static Cursor getInvisibleCursor() {\\n\\t\\tif (invisibleCursor == null) {\\n\\t\\t\\tinvisibleCursor = Toolkit.getDefaultToolkit().createCustomCursor(\\n\\t\\t\\t\\tcreateCompatibleImage(1, 1, true),\\n\\t\\t\\t\\tnew Point(),\\n\\t\\t\\t\\t\\\"invisible\\\"\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\treturn invisibleCursor;\\n\\t}\\n\\tpublic static String getLinkToolTipText(final String url) {\\n\\t\\tif (url == null)\\n\\t\\t\\treturn null;\\n\\t\\tString linkTag = String.format(\\n\\t\\t\\t\\\"<a href=\\\\\\\"%s\\\\\\\" style=\\\\\\\"color: %s; text-decoration: none\\\\\\\">%s</a>\\\",\\n\\t\\t\\turl,\\n\\t\\t\\tColorProperty.toString(MColor.getLinkForeground(getColor(\\\"ToolTip.background\\\"))),\\n\\t\\t\\tTK.centerSqueeze(MLinkAction.simplifyURI(url), 128)\\n\\t\\t);\\n\\t\\treturn makeHTML(_(\\\"Open {0}\\\", linkTag));\\n\\t}\\n\\tprivate static LookAndFeelType detectLookAndFeelType() { \\t\\tLookAndFeel laf = UIManager.getLookAndFeel();\\n\\t\\tsynth = (laf instanceof SynthLookAndFeel);\\n\\t\\tString className = (laf == null) ? null : laf.getClass().getName();\\n\\t\\tif (className == null)\\n\\t\\t\\treturn LookAndFeelType.UNKNOWN;\\n\\t\\tswitch (className) {\\n\\t\\t\\t\\t\\t\\tcase \\\"com.sun.java.swing.plaf.gtk.GTKLookAndFeel\\\":\\n\\t\\t\\t\\treturn LookAndFeelType.GTK;\\n\\t\\t\\tcase \\\"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\\\":\\n\\t\\t\\tcase \\\"com.sun.java.swing.plaf.windows.WindowsClassicLookAndFeel\\\":\\n\\t\\t\\t\\treturn LookAndFeelType.WINDOWS;\\n\\t\\t\\tcase \\\"javax.swing.plaf.nimbus.NimbusLookAndFeel\\\":\\n\\t\\t\\t\\treturn LookAndFeelType.NIMBUS;\\n\\t\\t\\tcase \\\"apple.laf.AquaLookAndFeel\\\":\\n\\t\\t\\tcase \\\"com.apple.laf.AquaLookAndFeel\\\":\\n\\t\\t\\tcase \\\"com.apple.mrj.swing.MacLookAndFeel\\\":\\n\\t\\t\\t\\treturn LookAndFeelType.MAC;\\n\\t\\t\\t\\t\\t\\tcase \\\"a03.swing.plaf.A03LookAndFeel\\\":\\n\\t\\t\\t\\treturn LookAndFeelType.A03;\\n\\t\\t\\tcase \\\"ch.randelshofer.quaqua.QuaquaLookAndFeel\\\":\\n\\t\\t\\t\\treturn LookAndFeelType.QUAQUA;\\n\\t\\t\\tcase \\\"com.lipstikLF.LipstikLookAndFeel\\\":\\n\\t\\t\\t\\treturn LookAndFeelType.LIPSTIK;\\n\\t\\t\\tcase \\\"com.pagosoft.plaf.PgsLookAndFeel\\\":\\n\\t\\t\\t\\treturn LookAndFeelType.PGS;\\n\\t\\t\\tcase \\\"com.seaglasslookandfeel.SeaGlassLookAndFeel\\\":\\n\\t\\t\\t\\treturn LookAndFeelType.SEA_GLASS;\\n\\t\\t\\tcase \\\"org.makagiga.retro.RetroLookAndFeel\\\":\\n\\t\\t\\t\\treturn LookAndFeelType.RETRO;\\n\\t\\t}\\n\\t\\tif (\\n\\t\\t\\t(laf instanceof MetalLookAndFeel) &&\\n\\t\\t\\t(MetalLookAndFeel.getCurrentTheme() instanceof OceanTheme)\\n\\t\\t)\\n\\t\\t\\treturn LookAndFeelType.METAL;\\n\\t\\tif (\\n\\t\\t\\tclassName.startsWith(\\\"org.jvnet.substance.\\\") ||\\n\\t\\t\\t((laf != null) && laf.getName().startsWith(\\\"Substance \\\"))\\n\\t\\t)\\n\\t\\t\\treturn LookAndFeelType.SUBSTANCE;\\n\\t\\treturn LookAndFeelType.UNKNOWN;\\n\\t}\\n\\tpublic static LookAndFeelType getLookAndFeelType() {\\n\\t\\tsynchronized (UI.class) {\\n\\t\\t\\tif (lookAndFeelType == null)\\n\\t\\t\\t\\tlookAndFeelType = detectLookAndFeelType();\\n\\t\\t}\\n\\t\\treturn lookAndFeelType;\\n\\t}\\n\\tpublic static String getPreferredLookAndFeelClassName() {\\n\\t\\tString laf = UIManager.getSystemLookAndFeelClassName();\\n\\t\\tif (isBlacklisted(laf) || \\\"com.sun.java.swing.plaf.gtk.GTKLookAndFeel\\\".equals(laf))\\n\\t\\t\\tlaf = \\\"javax.swing.plaf.metal.MetalLookAndFeel\\\";\\n\\t\\t\\t\\tif (\\\"javax.swing.plaf.metal.MetalLookAndFeel\\\".equals(laf))\\n\\t\\t\\tlaf = \\\"javax.swing.plaf.nimbus.NimbusLookAndFeel\\\";\\n\\t\\treturn laf;\\n\\t}\\n\\tpublic static Dimension getScreenSize() {\\n\\t\\treturn Toolkit.getDefaultToolkit().getScreenSize();\\n\\t}\\n\\tpublic static Color getSelectionBackground() {\\n\\t\\tColor c;\\n\\t\\t\\t\\tif (isNimbus()) {\\n\\t\\t\\tc = getColor(\\\"textHighlight\\\");\\n\\t\\t\\tif (c != null)\\n\\t\\t\\t\\tc = new MColor(c);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tc = getColor(\\\"TextField.selectionBackground\\\");\\n\\t\\treturn (c == null) ? MColor.SKY_BLUE : c;\\n\\t}\\n\\tpublic static ButtonUI getSimpleButtonUI() {\\n\\t\\treturn LazySimpleButtonUIHolder.INSTANCE;\\n\\t}\\n\\tpublic static ButtonGroup group(final AbstractButton... buttons) {\\n\\t\\tButtonGroup buttonGroup = new ButtonGroup();\\n\\t\\tfor (AbstractButton i : buttons) {\\n\\t\\t\\tif (i != null)\\n\\t\\t\\t\\tbuttonGroup.add(i);\\n\\t\\t}\\n\\t\\treturn buttonGroup;\\n\\t}\\n\\tpublic static void hideToolTip(final JComponent c) {\\n\\t\\tActionMap am = c.getActionMap();\\n\\t\\tif (am != null) {\\n\\t\\t\\tAction hideAction = am.get(\\\"hideTip\\\");\\n\\t\\t\\tif (hideAction != null)\\n\\t\\t\\t\\tMAction.fire(hideAction, c);\\n\\t\\t}\\n\\t}\\n\\tpublic static PropertyChangeListener installLookAndFeelListener(final Component c) {\\n\\t\\tLookAndFeelListener lookAndFeelListener = new LookAndFeelListener(c);\\n\\t\\tUIManager.addPropertyChangeListener(lookAndFeelListener);\\n\\t\\treturn lookAndFeelListener;\\n\\t}\\n\\tpublic static <T> T invokeAndWait(final Callable<T> c) throws Exception {\\n\\t\\tif (EventQueue.isDispatchThread()) {\\n\\t\\t\\treturn c.call();\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tfinal Property<Exception> exception = new Property<>();\\n\\t\\t\\tfinal Property<T> result = new Property<>();\\n\\t\\t\\tEventQueue.invokeAndWait(new Runnable() {\\n\\t\\t\\t\\tpublic void run() {\\n\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\tresult.set(c.call());\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcatch (Exception e) {\\n\\t\\t\\t\\t\\t\\texception.set(e);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t\\tif (!exception.isNull())\\n\\t\\t\\t\\tthrow exception.get();\\n\\t\\t\\treturn result.get();\\n\\t\\t}\\n\\t}\\n\\tpublic static void invokeAndWait(final Runnable r) throws InterruptedException, InvocationTargetException {\\n\\t\\tif (EventQueue.isDispatchThread())\\n\\t\\t\\tr.run();\\n\\t\\telse\\n\\t\\t\\tEventQueue.invokeAndWait(r);\\n\\t}\\n\\tpublic static void invokeLater(final Runnable r) {\\n\\t\\tif (EventQueue.isDispatchThread())\\n\\t\\t\\tr.run();\\n\\t\\telse\\n\\t\\t\\tEventQueue.invokeLater(r);\\n\\t}\\n\\tpublic static boolean isA03() {\\n\\t\\treturn getLookAndFeelType() == LookAndFeelType.A03;\\n\\t}\\n\\tpublic static boolean isBlacklisted(final String lafClassName) {\\n\\t\\treturn \\\"com.sun.java.swing.plaf.motif.MotifLookAndFeel\\\".equals(lafClassName);\\n\\t}\\n\\tpublic static boolean isLipstik() {\\n\\t\\treturn getLookAndFeelType() == LookAndFeelType.LIPSTIK;\\n\\t}\\n\\tpublic static boolean isMac() {\\n\\t\\treturn getLookAndFeelType() == LookAndFeelType.MAC;\\n\\t}\\n\\tpublic static boolean isNimbus() {\\n\\t\\treturn getLookAndFeelType() == LookAndFeelType.NIMBUS;\\n\\t}\\n\\tpublic static boolean isQuaqua() {\\n\\t\\treturn getLookAndFeelType() == LookAndFeelType.QUAQUA;\\n\\t}\\n\\tpublic static boolean isRTL(final Component c) {\\n\\t\\treturn c.getComponentOrientation() == ComponentOrientation.RIGHT_TO_LEFT;\\n\\t}\\n\\tpublic static boolean isSynth() {\\n\\t\\tgetLookAndFeelType(); \\t\\tsynchronized (UI.class) {\\n\\t\\t\\treturn synth;\\n\\t\\t}\\n\\t}\\n\\tpublic static void paintFocus(final Component c, final Graphics2D g, final Color color, final int insets) {\\n\\t\\tint w = c.getWidth();\\n\\t\\tint h = c.getHeight();\\n\\t\\tColor fg = (color == null) ? getForeground(c) : color;\\n\\t\\tg.setColor(MColor.deriveAlpha(fg, 127));\\n\\t\\tStroke oldStroke = g.getStroke();\\n\\t\\tif (basicFocusStroke == null) {\\n\\t\\t\\tbasicFocusStroke = new BasicStroke(\\n\\t\\t\\t\\t1, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND,\\n\\t\\t\\t\\t1.0f, new float[] { 2.0f }, 1.0f\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\tg.setStroke(basicFocusStroke);\\n\\t\\tg.drawRect(insets, insets, w - insets * 2 - 1, h - insets * 2 - 1);\\n\\t\\tg.setStroke(oldStroke);\\n\\t}\\n\\tpublic static void setHTMLEnabled(final JComponent c, final boolean enabled) {\\n\\t\\tc.putClientProperty(\\\"html.disable\\\", enabled ? null : true);\\n\\t}\\n\\tpublic static void setStyle(final String style, final Component... components) {\\n\\t\\tif (TK.isEmpty(style))\\n\\t\\t\\treturn;\\n\\t\\ttry {\\n\\t\\t\\t\\t\\t\\tStyle s = new Style(components[0].getFont(), style);\\n\\t\\t\\tfor (Component i : components)\\n\\t\\t\\t\\ts.apply(i);\\n\\t\\t\\t\\t\\t}\\n\\t\\tcatch (ParseException exception) {\\n\\t\\t\\tMLogger.exception(exception);\\n\\t\\t}\\n\\t}\\n\\tpublic static int getTypeForImageFormat(final String format) {\\n\\t\\tif (format == null)\\n\\t\\t\\treturn BufferedImage.TYPE_INT_ARGB;\\n\\t\\tif (format.equalsIgnoreCase(\\\"BMP\\\"))\\n\\t\\t\\treturn BufferedImage.TYPE_3BYTE_BGR;\\n\\t\\tif (format.equalsIgnoreCase(\\\"JPG\\\"))\\n\\t\\t\\treturn BufferedImage.TYPE_INT_RGB;\\n\\t\\treturn BufferedImage.TYPE_INT_ARGB;\\n\\t}\\n\\tpublic static Color getXorColor(final Color color) {\\n\\t\\tif (color == null)\\n\\t\\t\\treturn null;\\n\\t\\treturn new Color(color.getRGB() ^ 0xffffff);\\n\\t}\\n\\tpublic static void init() {\\n\\t\\tMLogger.debug(\\\"ui\\\", \\\"Current look and feel: %s\\\", getLookAndFeelType());\\n\\t\\tUIDefaults defaults = UIManager.getDefaults();\\n\\t\\t\\t\\tIcon cancelIcon = buttonIcons.booleanValue() ? MActionInfo.CANCEL.getIcon() : null;\\n\\t\\tIcon okIcon = buttonIcons.booleanValue() ? MActionInfo.OK.getIcon() : null;\\n\\t\\tdefaults.put(\\\"OptionPane.cancelButtonText\\\", MActionInfo.CANCEL.getText());\\n\\t\\tdefaults.put(\\\"OptionPane.cancelIcon\\\", cancelIcon);\\n\\t\\tdefaults.put(\\\"OptionPane.errorIcon\\\", MIcon.stock(\\\"ui/error\\\"));\\n\\t\\tdefaults.put(\\\"OptionPane.informationIcon\\\", MIcon.stock(\\\"ui/info\\\"));\\n\\t\\tdefaults.put(\\\"OptionPane.noIcon\\\", cancelIcon);\\n\\t\\tdefaults.put(\\\"OptionPane.okButtonText\\\", MActionInfo.OK.getText());\\n\\t\\tdefaults.put(\\\"OptionPane.okIcon\\\", okIcon);\\n\\t\\tdefaults.put(\\\"OptionPane.questionIcon\\\", MIcon.stock(\\\"ui/question\\\"));\\n\\t\\tdefaults.put(\\\"OptionPane.yesIcon\\\", okIcon);\\n\\t\\tdefaults.put(\\\"OptionPane.warningIcon\\\", MIcon.stock(\\\"ui/warning\\\"));\\n\\t\\t\\t\\tdefaults.put(\\\"OptionPane.buttonOrientation\\\", RIGHT);\\n\\t\\tdefaults.put(\\\"OptionPane.buttonPadding\\\", getDialogButtonSpacing());\\n\\t\\tdefaults.put(\\\"OptionPane.sameSizeButtons\\\", true);\\n\\t\\tOKCancelLayout.setupUI(defaults);\\n\\t\\t\\t\\tdefaults.put(\\\"Slider.paintValue\\\", false); \\t\\t\\n\\t\\tif (isGTK()) {\\n\\t\\t\\tdefaults.put(\\\"ComboBox.squareButton\\\", false);\\n\\t\\t}\\n\\t\\telse if (isMetal()) {\\n\\t\\t\\tdefaults.put(\\\"swing.boldMetal\\\", false);\\n\\t\\t\\t\\t\\t\\tObject gradient = createGradient(new Color(0xDDE8F3), Color.WHITE);\\n\\t\\t\\tdefaults.put(\\\"Button.gradient\\\", gradient);\\n\\t\\t\\tdefaults.put(\\\"MenuBar.gradient\\\", gradient);\\n\\t\\t\\tdefaults.put(\\\"Slider.gradient\\\", gradient);\\n\\t\\t\\tdefaults.put(\\\"Slider.focusGradient\\\", gradient);\\n\\t\\t\\tdefaults.put(\\\"ScrollBar.gradient\\\", gradient);\\n\\t\\t\\tdefaults.put(\\\"RadioButton.gradient\\\", gradient);\\n\\t\\t\\tdefaults.put(\\\"RadioButtonMenuItem.gradient\\\", gradient);\\n\\t\\t\\tdefaults.put(\\\"ToggleButton.gradient\\\", gradient);\\n\\t\\t\\t\\t\\t\\tdefaults.put(\\\"CheckBoxMenuItem.background\\\", Color.WHITE);\\n\\t\\t\\tdefaults.put(\\\"Menu.background\\\", Color.WHITE);\\n\\t\\t\\tdefaults.put(\\\"MenuItem.background\\\", Color.WHITE);\\n\\t\\t\\tdefaults.put(\\\"PopupMenu.background\\\", Color.WHITE);\\n\\t\\t\\tdefaults.put(\\\"RadioButtonMenuItem.background\\\", Color.WHITE);\\n\\t\\t\\tdefaults.put(\\\"Separator.background\\\", Color.WHITE);\\n\\t\\t\\t\\t\\t\\tBorder border;\\n\\t\\t\\tColorUIResource bg;\\n\\t\\t\\tColorUIResource fg;\\n\\t\\t\\tif (OS.isMac() || OS.isWindows()) {\\n\\t\\t\\t\\tbg = new ColorUIResource(SystemColor.info);\\n\\t\\t\\t\\tfg = new ColorUIResource(SystemColor.infoText);\\n\\t\\t\\t\\tborder = new BorderUIResource.LineBorderUIResource(fg, 1);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbg = new ColorUIResource(TOOL_TIP_BACKGROUND_COLOR);\\n\\t\\t\\t\\tfg = new ColorUIResource(TOOL_TIP_FOREGROUND_COLOR);\\n\\t\\t\\t\\tborder = BorderUIResource.getBlackLineBorderUIResource();\\n\\t\\t\\t}\\n\\t\\t\\tdefaults.put(\\\"ToolTip.background\\\", bg);\\n\\t\\t\\tdefaults.put(\\\"ToolTip.backgroundInactive\\\", bg);\\n\\t\\t\\tdefaults.put(\\\"ToolTip.foreground\\\", fg);\\n\\t\\t\\tdefaults.put(\\\"ToolTip.foregroundInactive\\\", fg);\\n\\t\\t\\tdefaults.put(\\\"ToolTip.border\\\", border);\\n\\t\\t\\tdefaults.put(\\\"ToolTip.borderInactive\\\", border);\\n\\t\\t\\t\\t\\t\\tdefaults.put(\\\"TabbedPane.contentBorderInsets\\\", createInsets(1));\\n\\t\\t\\t\\t\\t\\tdefaults.put(\\\"Tree.leafIcon\\\", null);\\n\\t\\t}\\n\\t\\telse if (isSynth()) {\\n\\t\\t\\tdefaults.put(\\\"ScrollBar.allowsAbsolutePositioning\\\", true); \\t\\t}\\n\\t\\tif (useCustomColor.get())\\n\\t\\t\\tinitCustomColor(defaults);\\n\\t}\\n\\tprivate static Color oldControl;\\n\\tprivate static Color oldNimbusFocus;\\n\\tprivate static Color oldNimbusSelectionBackground;\\n\\tpublic static void initCustomColor(final UIDefaults defaults) {\\n\\t\\tColor color = customColor.get();\\n\\t\\tif (color == null)\\n\\t\\t\\treturn;\\n\\t\\tif (isNimbus()) {\\n\\t\\t\\tif (oldControl == null)\\n\\t\\t\\t\\toldControl = defaults.getColor(\\\"control\\\");\\n\\t\\t\\tif (oldNimbusFocus == null)\\n\\t\\t\\t\\toldNimbusFocus = defaults.getColor(\\\"nimbusFocus\\\");\\n\\t\\t\\tif (oldNimbusSelectionBackground == null)\\n\\t\\t\\t\\toldNimbusSelectionBackground = defaults.getColor(\\\"nimbusSelectionBackground\\\");\\n\\t\\t\\tdefaults.put(\\\"nimbusBase\\\", color);\\n\\t\\t\\tif (customColor.isDefaultValue()) {\\n\\t\\t\\t\\tif (oldNimbusSelectionBackground != null)\\n\\t\\t\\t\\t\\tdefaults.put(\\\"nimbusSelectionBackground\\\", oldNimbusSelectionBackground);\\n\\t\\t\\t\\tif (oldNimbusFocus != null)\\n\\t\\t\\t\\t\\tdefaults.put(\\\"nimbusFocus\\\", oldNimbusFocus);\\n\\t\\t\\t\\tif (oldControl != null)\\n\\t\\t\\t\\t\\tdefaults.put(\\\"control\\\", oldControl);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tdefaults.put(\\\"nimbusSelectionBackground\\\", color);\\n\\t\\t\\t\\tdefaults.put(\\\"nimbusFocus\\\", MColor.getBrighter(color, 25));\\n\\t\\t\\t\\tdefaults.put(\\\"control\\\", MColor.getBrighter(color, 90));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tpublic static boolean isEmpty(final Image image) {\\n\\t\\treturn (image == null) || (image.getWidth(null) < 1) || (image.getHeight(null) < 1);\\n\\t}\\n\\tpublic static boolean isGTK() {\\n\\t\\treturn getLookAndFeelType() == LookAndFeelType.GTK;\\n\\t}\\n\\tpublic static boolean isMetal() {\\n\\t\\treturn getLookAndFeelType() == LookAndFeelType.METAL;\\n\\t}\\n\\tpublic static boolean isPgs() {\\n\\t\\treturn getLookAndFeelType() == LookAndFeelType.PGS;\\n\\t}\\n\\tpublic static boolean isPopupTrigger(final KeyEvent e) {\\n\\t\\tif (TK.isKeyStroke(e, VK_CONTEXT_MENU) || TK.isKeyStroke(e, VK_F10, SHIFT_MASK)) {\\n\\t\\t\\te.consume();\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\tpublic static boolean isRetro() {\\n\\t\\treturn getLookAndFeelType() == LookAndFeelType.RETRO;\\n\\t}\\n\\tpublic static boolean isSeaGlass() {\\n\\t\\treturn getLookAndFeelType() == LookAndFeelType.SEA_GLASS;\\n\\t}\\n\\tpublic static boolean isSubstance() {\\n\\t\\treturn getLookAndFeelType() == LookAndFeelType.SUBSTANCE;\\n\\t}\\n\\tpublic static boolean isWindows() {\\n\\t\\treturn (getLookAndFeelType() == LookAndFeelType.WINDOWS);\\n\\t}\\n\\tpublic static String makeHTML(final String code) {\\n\\t\\treturn HTML_BEGIN + code + HTML_END;\\n\\t}\\n\\tpublic static void paintText(\\n\\t\\tfinal int flags,\\n\\t\\tfinal Graphics2D g,\\n\\t\\tfinal Rectangle r,\\n\\t\\tfinal Color background,\\n\\t\\tfinal Color foreground,\\n\\t\\tfinal String... lines\\n\\t) {\\n\\t\\tif (TK.isEmpty(lines))\\n\\t\\t\\treturn;\\n\\t\\tFlags f = Flags.valueOf(flags);\\n\\t\\tFontMetrics metrics = g.getFontMetrics();\\n\\t\\tint textHeight = metrics.getHeight();\\n\\t\\tif (background != null) {\\n\\t\\t\\tg.setColor(background);\\n\\t\\t\\tint h = textHeight * lines.length;\\n\\t\\t\\tg.fillRect(r.x, r.y, r.width, h + metrics.getDescent());\\n\\t\\t}\\n\\t\\tShape oldClip = g.getClip();\\n\\t\\tint y = r.y;\\n\\t\\tg.setClip(r);\\n\\t\\tg.setColor(foreground);\\n\\t\\tfor (String i : lines) {\\n\\t\\t\\ty += textHeight;\\n\\t\\t\\tif (f.isSet(PAINT_TEXT_TRIM_LINES))\\n\\t\\t\\t\\tg.drawString(i.trim(), r.x + 4, y);\\n\\t\\t\\telse\\n\\t\\t\\t\\tg.drawString(i, r.x + 4, y);\\n\\t\\t\\tif (y > r.x + r.height)\\n\\t\\t\\t\\tbreak; \\t\\t}\\n\\t\\tg.setClip(oldClip);\\n\\t}\\n\\tpublic static BufferedImage createCompatibleImage(final int w, final int h, final boolean alpha) {\\n\\t\\tGraphicsEnvironment environment = GraphicsEnvironment.getLocalGraphicsEnvironment();\\n\\t\\tGraphicsDevice device = environment.getDefaultScreenDevice();\\n\\t\\tGraphicsConfiguration configuration = device.getDefaultConfiguration();\\n\\t\\tif (alpha)\\n\\t\\t\\treturn configuration.createCompatibleImage(w, h, Transparency.TRANSLUCENT);\\n\\t\\treturn configuration.createCompatibleImage(w, h);\\n\\t}\\n\\tpublic static VolatileImage createCompatibleVolatileImage(final int w, final int h, final int transparency) {\\n\\t\\tGraphicsEnvironment environment = GraphicsEnvironment.getLocalGraphicsEnvironment();\\n\\t\\tGraphicsDevice device = environment.getDefaultScreenDevice();\\n\\t\\tGraphicsConfiguration configuration = device.getDefaultConfiguration();\\n\\t\\treturn configuration.createCompatibleVolatileImage(w, h, transparency);\\n\\t}\\n\\tpublic static boolean needScrollPane(final JComponent component) {\\n\\t\\treturn\\n\\t\\t\\t(component instanceof Scrollable) &&\\n\\t\\t\\t!(component instanceof JScrollPane) &&\\n\\t\\t\\t!(component instanceof JTextField) &&\\n\\t\\t\\t!(component instanceof JLayer);\\n\\t}\\n\\tpublic static Image scaleImage(final Image image, int targetWidth, int targetHeight, final Quality quality) {\\n\\t\\tif ((targetWidth < 0) && (targetHeight < 0))\\n\\t\\t\\treturn image;\\n\\t\\tint w = image.getWidth(null);\\n\\t\\tint h = image.getHeight(null);\\n\\t\\tif (targetWidth < 0) {\\n\\t\\t\\tfloat f = (float)targetHeight / (float)h;\\n\\t\\t\\ttargetWidth = (int)((float)w * f);\\n\\t\\t}\\n\\t\\tif (targetHeight < 0) {\\n\\t\\t\\tfloat f = (float)targetWidth / (float)w;\\n\\t\\t\\ttargetHeight = (int)((float)h * f);\\n\\t\\t}\\n\\t\\tif ((w == targetWidth) && (h == targetHeight))\\n\\t\\t\\treturn image;\\n\\t\\tswitch (quality) {\\n\\t\\t\\tcase LOW:\\n\\t\\t\\t\\treturn doScale(image, targetWidth, targetHeight, RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR, true);\\n\\t\\t\\tcase MEDIUM:\\n\\t\\t\\t\\treturn doScale(image, targetWidth, targetHeight, RenderingHints.VALUE_INTERPOLATION_BILINEAR, true);\\n\\t\\t\\tcase HIGH:\\n\\t\\t\\t\\tif ((targetWidth < w) || (targetHeight < h)) {\\n\\t\\t\\t\\t\\tboolean done = false;\\n\\t\\t\\t\\t\\tfloat fw = w;\\n\\t\\t\\t\\t\\tfloat fh = h;\\n\\t\\t\\t\\t\\tBufferedImage result = null;\\n\\t\\t\\t\\t\\twhile (!done) {\\n\\t\\t\\t\\t\\t\\tif (fw > targetWidth) {\\n\\t\\t\\t\\t\\t\\t\\tfw /= 2f;\\n\\t\\t\\t\\t\\t\\t\\tif (fw < targetWidth)\\n\\t\\t\\t\\t\\t\\t\\t\\tfw = targetWidth;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (fh > targetHeight) {\\n\\t\\t\\t\\t\\t\\t\\tfh /= 2f;\\n\\t\\t\\t\\t\\t\\t\\tif (fh < targetHeight)\\n\\t\\t\\t\\t\\t\\t\\t\\tfh = targetHeight;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tw = (int)fw;\\n\\t\\t\\t\\t\\t\\th = (int)fh;\\n\\t\\t\\t\\t\\t\\tdone = (w == targetWidth) && (h == targetHeight);\\n\\t\\t\\t\\t\\t\\tresult = doScale(\\n\\t\\t\\t\\t\\t\\t\\t(result != null) ? result : image,\\n\\t\\t\\t\\t\\t\\t\\tw,\\n\\t\\t\\t\\t\\t\\t\\th,\\n\\t\\t\\t\\t\\t\\t\\tRenderingHints.VALUE_INTERPOLATION_BILINEAR,\\n\\t\\t\\t\\t\\t\\t\\tdone\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\treturn doScale(image, targetWidth, targetHeight, RenderingHints.VALUE_INTERPOLATION_BICUBIC, true);\\n\\t\\t\\t\\t}\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tthrow new WTFError(quality);\\n\\t\\t}\\n\\t}\\n\\tpublic static Object setAntialiasing(final Graphics2D g, final boolean value) {\\n\\t\\tRenderingHints.Key key = RenderingHints.KEY_ANTIALIASING;\\n\\t\\tObject oldRenderingHint = g.getRenderingHint(key);\\n\\t\\tg.setRenderingHint(key, value ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);\\n\\t\\treturn oldRenderingHint;\\n\\t}\\n\\tpublic static void setHTMLHelp(final JComponent component, final String text) {\\n\\t\\tcomponent.setToolTipText((text == null) ? null : makeHTML(text));\\n\\t}\\n\\tpublic static void setLookAndFeel(final LookAndFeel laf) throws Exception {\\n\\t\\tsynchronized (UI.class) {\\n\\t\\t\\tlookAndFeelType = null;\\n\\t\\t}\\n\\t\\tMLogger.info(\\\"core\\\", \\\"Setting look and feel: %s\\\", laf.getName());\\n\\t\\tinitCustomFont();\\n\\t\\tUIManager.setLookAndFeel(laf);\\n\\t\\tinit();\\n\\t}\\n\\tpublic static void setLookAndFeel(final String className) throws Exception {\\n\\t\\tsynchronized (UI.class) {\\n\\t\\t\\tlookAndFeelType = null;\\n\\t\\t}\\n\\t\\tMLogger.info(\\\"core\\\", \\\"Setting look and feel by class name: %s\\\", className);\\n\\t\\tinitCustomFont();\\n\\t\\tUIManager.setLookAndFeel(className);\\n\\t\\tinit();\\n\\t}\\n\\tpublic static void setTextAntialiasing(final Graphics2D g, final RenderingHints savedHints) {\\n\\t\\tif (savedHints != null) {\\n\\t\\t\\tsavedHints.clear();\\n\\t\\t\\tfor (RenderingHints.Entry<Object, Object> i : g.getRenderingHints().entrySet())\\n\\t\\t\\t\\tsavedHints.put(i.getKey(), i.getValue());\\n\\t\\t}\\n\\t\\tsynchronized (UI.class) {\\n\\t\\t\\tif (!textAAInitialized) {\\n\\t\\t\\t\\ttextAAInitialized = true;\\n\\t\\t\\t\\tToolkit toolkit = Toolkit.getDefaultToolkit();\\n\\t\\t\\t\\tupdateTextAA(toolkit);\\n\\t\\t\\t\\ttoolkit.addPropertyChangeListener(\\\"awt.font.desktophints\\\", new PropertyChangeListener() {\\n\\t\\t\\t\\t\\t@Override\\n\\t\\t\\t\\t\\tpublic void propertyChange(final PropertyChangeEvent e) {\\n\\t\\t\\t\\t\\t\\tMLogger.debug(\\\"ui\\\", \\\"Text Antialiasing: Settings changed\\\");\\n\\t\\t\\t\\t\\t\\tsynchronized (UI.class) {\\n\\t\\t\\t\\t\\t\\t\\tUI.updateTextAA(Toolkit.getDefaultToolkit());\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (textAA == null) {\\n\\t\\t\\tsetBasicTextAntialiasing(g, true);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tg.addRenderingHints(textAA);\\n\\t\\t}\\n\\t}\\n\\tpublic static Object setBasicTextAntialiasing(final Graphics2D g, final boolean on) {\\n\\t\\tRenderingHints.Key key = RenderingHints.KEY_TEXT_ANTIALIASING;\\n\\t\\tObject oldRenderingHint = g.getRenderingHint(key);\\n\\t\\tg.setRenderingHint(key, on ? RenderingHints.VALUE_TEXT_ANTIALIAS_ON : RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);\\n\\t\\treturn oldRenderingHint;\\n\\t}\\n\\tpublic static void setHandCursor(final Component component, final boolean yes) {\\n\\t\\tif (component != null)\\n\\t\\t\\tcomponent.setCursor(Cursor.getPredefinedCursor(yes ? Cursor.HAND_CURSOR : Cursor.DEFAULT_CURSOR));\\n\\t}\\n\\tpublic static void setWaitCursor(final Component component, final boolean wait) {\\n\\t\\tif (component == null)\\n\\t\\t\\treturn;\\n\\t\\tif (!wait && (component instanceof JTextComponent)) {\\n\\t\\t\\tboolean editable = JTextComponent.class.cast(component).isEditable();\\n\\t\\t\\tcomponent.setCursor(Cursor.getPredefinedCursor(editable ? Cursor.TEXT_CURSOR : Cursor.DEFAULT_CURSOR));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tcomponent.setCursor(Cursor.getPredefinedCursor(wait ? Cursor.WAIT_CURSOR : Cursor.DEFAULT_CURSOR));\\n\\t}\\n\\tpublic static void setWaitCursor(final boolean yes) {\\n\\t\\tsetWaitCursor(MainView.getWindow(), yes);\\n\\t}\\n\\tpublic static BufferedImage toBufferedImage(final Icon source) {\\n\\t\\tBufferedImage result = createCompatibleImage(source.getIconWidth(), source.getIconHeight(), true);\\n\\t\\tGraphics2D g = result.createGraphics();\\n\\t\\tsource.paintIcon(null, g, 0, 0);\\n\\t\\tg.dispose();\\n\\t\\treturn result;\\n\\t}\\n\\tpublic static BufferedImage toBufferedImage(final Image source, final boolean useSource) {\\n\\t\\tif (useSource && (source instanceof BufferedImage))\\n\\t\\t\\treturn (BufferedImage)source;\\n\\t\\t\\t\\tBufferedImage result = createCompatibleImage(source.getWidth(null), source.getHeight(null), true);\\n\\t\\tGraphics2D g = result.createGraphics();\\n\\t\\tg.drawImage(source, 0, 0, null, null);\\n\\t\\tg.dispose();\\n\\t\\treturn result;\\n\\t}\\n\\tpublic static void update() {\\n\\t\\ttry {\\n\\t\\t\\tsetWaitCursor(true);\\n\\t\\t\\tfor (Window i : Window.getWindows())\\n\\t\\t\\t\\tSwingUtilities.updateComponentTreeUI(i);\\n\\t\\t}\\n\\t\\tfinally {\\n\\t\\t\\tsetWaitCursor(false);\\n\\t\\t}\\n\\t}\\n\\tpublic static Window windowFor(final Component c) {\\n\\t\\tif (c == null)\\n\\t\\t\\treturn FocusManager.getCurrentManager().getActiveWindow();\\n\\t\\treturn SwingUtilities.getWindowAncestor(c);\\n\\t}\\n\\t@Uninstantiable\\n\\tprivate UI() { }\\n\\tprivate static BufferedImage doScale(final Image image, final int w, final int h, final Object hint, final boolean compatible) {\\n\\t\\tBufferedImage result =\\n\\t\\t\\tcompatible\\n\\t\\t\\t? createCompatibleImage(w, h, true)\\n\\t\\t\\t: new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\\n\\t\\tGraphics2D g = result.createGraphics();\\n\\t\\tg.setRenderingHint(RenderingHints.KEY_INTERPOLATION, hint);\\n\\t\\tg.drawImage(image, 0, 0, w, h, null);\\n\\t\\tg.dispose();\\n\\t\\treturn result;\\n\\t}\\n\\tprivate static void initCustomFont() {\\n\\t\\tif (useCustomFont.get()) {\\n\\t\\t\\tcustomFontValue = customFont.get();\\n\\t\\t\\t\\t\\t\\tfloat size = (float)TK.limit(customFontValue.getSize(), 8, 32);\\n\\t\\t\\tcustomFontValue = customFontValue.deriveFont(size);\\n\\t\\t\\t\\t\\t\\tUIDefaults defaults = UIManager.getDefaults();\\n\\t\\t\\tdefaults.put(\\\"defaultFont\\\", customFontValue);\\n\\t\\t\\tfor (Map.Entry<Object, Object> i : defaults.entrySet()) {\\n\\t\\t\\t\\tString name = i.getKey().toString();\\n\\t\\t\\t\\tputFont(defaults, name, \\\".font\\\", customFontValue);\\n\\t\\t\\t\\tputFont(defaults, name, \\\".acceleratorFont\\\", customFontValue);\\n\\t\\t\\t\\tputFont(defaults, name, \\\"InternalFrame.titleFont\\\", customFontValue);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tcustomFontValue = null;\\n\\t\\t}\\n\\t}\\n\\tprivate static void putFont(final UIDefaults defaults, final String name, final String suffix, final Font font) {\\n\\t\\tint i = name.lastIndexOf(suffix);\\n\\t\\tif (i != -1) {\\n\\t\\t\\tdefaults.put(name, font);\\n\\t\\t\\tString baseName = name.substring(0, i);\\n\\t\\t\\tdefaults.put(baseName + \\\"[Enabled]\\\" + suffix, font);\\n\\t\\t\\tdefaults.put(baseName + \\\"[Disabled]\\\" + suffix, font);\\n\\t\\t}\\n\\t}\\n\\t@SuppressWarnings(\\\"unchecked\\\")\\n\\tprivate static void updateTextAA(final Toolkit toolkit) {\\n\\t\\ttextAA = (Map<Object, Object>)toolkit.getDesktopProperty(\\\"awt.font.desktophints\\\");\\n\\t\\tif (textAA != null) {\\n\\t\\t\\tfor (Map.Entry<Object, Object> i : textAA.entrySet()) {\\n\\t\\t\\t\\tMLogger.debug(\\\"ui\\\", \\\"Text Antialiasing: %s = %s\\\", i.getKey(), i.getValue());\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tpublic static interface EventsControl {\\n\\t\\tpublic boolean getEventsEnabled();\\n\\t\\tpublic void setEventsEnabled(final boolean value);\\n\\t}\\n\\tpublic static interface MouseWheelEventsControl {\\n\\t\\tpublic boolean getMouseWheelEventsEnabled();\\n\\t\\tpublic void setMouseWheelEventsEnabled(final boolean value);\\n\\t}\\n\\tpublic static class NimbusOverrides extends UIDefaults {\\n\\t\\tpublic NimbusOverrides() { }\\n\\t\\tpublic void install(final JComponent c, final boolean inheritDefaults) {\\n\\t\\t\\tc.putClientProperty(\\\"Nimbus.Overrides.InheritDefaults\\\", inheritDefaults);\\n\\t\\t\\tc.putClientProperty(\\\"Nimbus.Overrides\\\", this);\\n\\t\\t}\\n\\t}\\n\\tprivate static final class LazySimpleButtonUIHolder {\\n\\t\\tprivate static final SimpleButtonUI INSTANCE = new SimpleButtonUI();\\n\\t\\tprivate LazySimpleButtonUIHolder() { }\\n\\t}\\n\\tprivate static final class LookAndFeelListener implements PropertyChangeListener {\\n\\t\\tprivate final WeakReference<Component> componentRef;\\n\\t\\tpublic LookAndFeelListener(final Component c) {\\n\\t\\t\\tcomponentRef = new WeakReference<>(c);\\n\\t\\t}\\n\\t\\t@Override\\n\\t\\tpublic void propertyChange(final PropertyChangeEvent e) {\\n\\t\\t\\tif (\\\"lookAndFeel\\\".equals(e.getPropertyName())) {\\n\\t\\t\\t\\tComponent c = TK.get(componentRef);\\n\\t\\t\\t\\tif ((c != null) && (UI.windowFor(c) == null))\\n\\t\\t\\t\\t\\tSwingUtilities.updateComponentTreeUI(c);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\""
            },
            "m13": {
                "content": "The `UI.java` file is a comprehensive utility class focused on user interface management within the Makagiga framework. It provides a wide range of functionalities, including:\n\n1. **UI Configuration and Properties**:\n   - Manages global UI settings such as fonts, colors, icon sizes, and layout preferences.\n   - Contains properties like `iconSize`, `customFont`, `systemTray`, and others that influence the application's appearance and behavior.\n\n2. **Look and Feel Management**:\n   - Handles different LookAndFeel implementations (e.g., GTK, Nimbus, Metal) through methods like `getLookAndFeelType()` and `setLookAndFeel()`.\n   - Adjusts UI defaults dynamically based on the selected theme.\n\n3. **Rendering and Graphics Utilities**:\n   - Offers utilities for rendering text, images, and components with support for anti-aliasing, scaling, and custom painting.\n   - Includes helper methods like `paintFocus()`, `scaleImage()`, and `setAntialiasing()`.\n\n4. **Component Helpers**:\n   - Provides convenience methods for working with Swing components, such as setting tooltips (`setHTMLHelp()`), managing cursors (`setHandCursor()`), and handling scrollable content (`needScrollPane()`).\n\n5. **Event Handling and Threading**:\n   - Supports event dispatching and threading via methods like `invokeAndWait()` and `invokeLater()` to ensure thread-safe UI updates.\n\n### Relevance to `AutoCompletion.java`:\n- `AutoCompletion.java` uses `UI` extensively for rendering and theming purposes, especially when displaying auto-complete suggestions in a popup window.\n- The removal of `MText.java` may not directly impact `UI.java`, but it could affect how `AutoCompletion` integrates with text components if `MText` was previously part of that flow.\n\n### Next Steps:\nSince `UI.java` doesn't directly reference `MText`, we should continue investigating other entities that might have replaced or refactored the functionality previously handled by `MText`. We already examined `AutoCompletion.java` and `UI.java`; now, let's look into `TK.java`, which is another heavily used utility referenced by both files.\n\nWe'll retrieve the origin code for `TK.java` next.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_03044c636a4547dea8f29f",
                        "function": {
                            "arguments": "{\"entity\": \"TK.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m14": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"package org.makagiga.commons;\\nimport java.awt.Toolkit;\\nimport java.awt.event.ActionEvent;\\nimport java.awt.event.ActionListener;\\nimport java.awt.event.KeyEvent;\\nimport java.beans.PropertyChangeEvent;\\nimport java.beans.PropertyChangeListener;\\nimport java.io.IOException;\\nimport java.io.ObjectInputStream;\\nimport java.io.ObjectOutputStream;\\nimport java.io.Serializable;\\nimport java.io.UnsupportedEncodingException;\\nimport java.lang.ref.Reference;\\nimport java.lang.reflect.Array;\\nimport java.net.URLDecoder;\\nimport java.net.URLEncoder;\\nimport java.text.ParseException;\\nimport java.util.Arrays;\\nimport java.util.Collection;\\nimport java.util.Collections;\\nimport java.util.Comparator;\\nimport java.util.EnumSet;\\nimport java.util.Enumeration;\\nimport java.util.HashMap;\\nimport java.util.HashSet;\\nimport java.util.Iterator;\\nimport java.util.LinkedHashMap;\\nimport java.util.List;\\nimport java.util.Locale;\\nimport java.util.Map;\\nimport java.util.Objects;\\nimport java.util.Set;\\nimport java.util.TreeMap;\\nimport java.util.UUID;\\nimport java.util.regex.Pattern;\\nimport javax.swing.KeyStroke;\\nimport javax.swing.event.ChangeEvent;\\nimport javax.swing.event.ChangeListener;\\nimport org.w3c.dom.Node;\\nimport org.w3c.dom.NodeList;\\nimport org.makagiga.commons.annotation.Obsolete;\\nimport org.makagiga.commons.annotation.Uninstantiable;\\npublic final class TK {\\n\\tpublic static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\\n\\tpublic static final ChangeListener[] EMPTY_CHANGE_LISTENER_ARRAY = new ChangeListener[0];\\n\\tpublic static final char[] EMPTY_CHAR_ARRAY = new char[0];\\n\\tpublic static final int[] EMPTY_INT_ARRAY = new int[0];\\n\\tpublic static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\\n\\tpublic static final PropertyChangeListener[] EMPTY_PROPERTY_CHANGE_LISTENER_ARRAY = new PropertyChangeListener[0];\\n\\tpublic static final String[] EMPTY_STRING_ARRAY = new String[0];\\n\\tpublic static final int ESCAPE_ASTERISK = 1;\\n\\tpublic static final int ESCAPE_SPACE = 1 << 1;\\n\\tpublic static final int SPLIT_PAIR_TRIM = 1;\\n\\tpublic static final int SPLIT_PAIR_NULL_ERROR = 1 << 1;\\n\\tpublic static final int SPLIT_PAIR_NO_MEMORY_LEAK = 1 << 2;\\n\\tprivate static Pattern validateIDPattern = Pattern.compile(\\\"(\\\\\\\\w|\\\\\\\\-)+\\\");\\n\\tpublic static void beep() {\\n\\t\\tToolkit.getDefaultToolkit().beep();\\n\\t}\\n\\tpublic static String buildErrorMessage(final Throwable throwable) {\\n\\t\\tObjects.requireNonNull(throwable);\\n\\t\\tint level = 0;\\n\\t\\tString last = null;\\n\\t\\tStringBuilder s = new StringBuilder();\\n\\t\\tThrowable cause = throwable;\\n\\t\\tdo {\\n\\t\\t\\tString message = cause.toString();\\n\\t\\t\\t\\t\\t\\tif (Objects.equals(last, message))\\n\\t\\t\\t\\tcontinue; \\n\\t\\t\\tlast = message;\\n\\t\\t\\tif (s.length() > 0)\\n\\t\\t\\t\\ts.append('\\\\n');\\n\\t\\t\\tif (level > 0)\\n\\t\\t\\t\\ts.append(\\\"- \\\");\\n\\t\\t\\ts.append(message);\\n\\t\\t\\tlevel++;\\n\\t\\t} while ((cause = cause.getCause()) != null);\\n\\t\\treturn s.toString();\\n\\t}\\n\\tpublic static String capitalize(final String s) {\\n\\t\\tif (isEmpty(s))\\n\\t\\t\\treturn s;\\n\\t\\tint l = s.length();\\n\\t\\tStringBuilder result = new StringBuilder(l);\\n\\t\\tresult.append(Character.toUpperCase(s.charAt(0)));\\n\\t\\tif (l > 1)\\n\\t\\t\\tresult.append(s.substring(1));\\n\\t\\treturn result.toString();\\n\\t}\\n\\t@Obsolete\\n\\tpublic static <T> T checkNull(final T object) {\\n\\t\\treturn Objects.requireNonNull(object);\\n\\t}\\n\\t@Obsolete\\n\\tpublic static <T> T checkNull(final T object, final String name) {\\n\\t\\treturn Objects.requireNonNull(object, name);\\n\\t}\\n\\tpublic static String checkNullOrEmpty(final String string) {\\n\\t\\tif (isEmpty(string))\\n\\t\\t\\tthrow new IllegalArgumentException(\\\"String is null or empty\\\");\\n\\t\\treturn string;\\n\\t}\\n\\tpublic static String checkNullOrEmpty(final String string, final String name) {\\n\\t\\tif (isEmpty(string))\\n\\t\\t\\tthrow new IllegalArgumentException(\\\"\\\\\\\"\\\" + name + \\\"\\\\\\\" string is null or empty\\\");\\n\\t\\treturn string;\\n\\t}\\n\\tpublic static <T extends Comparable<T>> int compare(final T o1, final T o2, final T defaultValue) {\\n\\t\\tT item1 = (o1 == null) ? defaultValue : o1;\\n\\t\\tT item2 = (o2 == null) ? defaultValue : o2;\\n\\t\\treturn item1.compareTo(item2);\\n\\t}\\n\\tpublic static <T> T[] copyOf(final T[] array) {\\n\\t\\tif (array == null)\\n\\t\\t\\treturn null;\\n\\t\\tif (array.length == 0)\\n\\t\\t\\treturn array;\\n\\t\\treturn array.clone();\\n\\t}\\n\\tpublic static String createRandomUUID() {\\n\\t\\treturn \\\"{\\\" + UUID.randomUUID() + \\\"}\\\";\\n\\t}\\n\\t@Obsolete\\n\\tpublic static Object deserialize(final ObjectInputStream input, final String name) throws ClassNotFoundException, IOException {\\n\\t\\tObjects.requireNonNull(name);\\n\\t\\t\\t\\tObject[] data = (Object[])input.readObject();\\n\\t\\tif ((data.length == 2) && data[0].equals(name))\\n\\t\\t\\treturn data[1];\\n\\t\\treturn null;\\n\\t}\\n\\tpublic static <T> T dispose(final MDisposable o) {\\n\\t\\tif (o != null)\\n\\t\\t\\to.dispose();\\n\\t\\treturn null;\\n\\t}\\n\\tpublic static String escapeURL(final String value) {\\n\\t\\treturn escapeURL(value, 0);\\n\\t}\\n\\tpublic static String escapeURL(final String value, final int flags) {\\n\\t\\ttry {\\n\\t\\t\\tif (flags == 0)\\n\\t\\t\\t\\treturn URLEncoder.encode(value, \\\"UTF-8\\\");\\n\\t\\t\\tStringBuilder result = new StringBuilder(value.length() * 2);\\n\\t\\t\\tresult.append(URLEncoder.encode(value, \\\"UTF-8\\\"));\\n\\t\\t\\tif ((flags & ESCAPE_ASTERISK) != 0)\\n\\t\\t\\t\\tfastReplace(result, \\\"*\\\", \\\"%2A\\\");\\n\\t\\t\\tif ((flags & ESCAPE_SPACE) != 0)\\n\\t\\t\\t\\tfastReplace(result, \\\"+\\\", \\\"%20\\\");\\n\\t\\t\\treturn result.toString();\\n\\t\\t}\\n\\t\\tcatch (UnsupportedEncodingException exception) {\\n\\t\\t\\tMLogger.exception(exception);\\n\\t\\t\\treturn value;\\n\\t\\t}\\n\\t}\\n\\tpublic static String escapeXML(final String value) {\\n\\t\\tStringBuilder s = escapeXML(null, value);\\n\\t\\treturn (s == null) ? value : s.toString();\\n\\t}\\n\\tpublic static StringBuilder escapeXML(StringBuilder buf, final CharSequence value) {\\n\\t\\tif (value == null)\\n\\t\\t\\treturn buf;\\n\\t\\tint len = value.length();\\n\\t\\tif (len == 0)\\n\\t\\t\\treturn buf;\\n\\t\\tif (buf == null)\\n\\t\\t\\tbuf = new StringBuilder(len * 2);\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tchar c = value.charAt(i);\\n\\t\\t\\tswitch (c) {\\n\\t\\t\\t\\tcase '<':\\n\\t\\t\\t\\t\\tbuf.append(\\\"&lt;\\\");\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase '>':\\n\\t\\t\\t\\t\\tbuf.append(\\\"&gt;\\\");\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase '&':\\n\\t\\t\\t\\t\\tbuf.append(\\\"&amp;\\\");\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase '\\\\'':\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbuf.append(\\\"&#039;\\\");\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase '\\\\\\\"':\\n\\t\\t\\t\\t\\tbuf.append(\\\"&quot;\\\");\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbuf.append(c);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn buf;\\n\\t}\\n\\tpublic static String filler(final char fill, final int length) {\\n\\t\\tif (length < 0)\\n\\t\\t\\tthrow new IllegalArgumentException(\\\"\\\\\\\"length\\\\\\\" cannot be less than zero\\\");\\n\\t\\tchar[] c = new char[length];\\n\\t\\tArrays.fill(c, fill);\\n\\t\\treturn new String(c);\\n\\t}\\n\\tpublic static void fireActionPerformed(final Object source, final ActionListener[] al) {\\n\\t\\tif (al.length > 0) {\\n\\t\\t\\tActionEvent ae = new ActionEvent(source, ActionEvent.ACTION_PERFORMED, \\\"\\\");\\n\\t\\t\\tfor (ActionListener i : al)\\n\\t\\t\\t\\ti.actionPerformed(ae);\\n\\t\\t}\\n\\t}\\n\\tpublic static void fireStateChanged(final Object source, final ChangeListener[] cl) {\\n\\t\\tif (cl.length > 0) {\\n\\t\\t\\tChangeEvent ce = new ChangeEvent(source);\\n\\t\\t\\tfor (ChangeListener i : cl)\\n\\t\\t\\t\\ti.stateChanged(ce);\\n\\t\\t}\\n\\t}\\n\\tpublic static <T> void fireValueChanged(final Object source, final ValueListener<T>[] vl, final T oldValue, final T newValue) {\\n\\t\\tfireValueChanged(source, vl, oldValue, newValue, null);\\n\\t}\\n\\tpublic static <T> void fireValueChanged(final Object source, final ValueListener<T>[] vl, final T oldValue, final T newValue, final Object reason) {\\n\\t\\tif (vl.length > 0) {\\n\\t\\t\\tValueEvent<T> ve = new ValueEvent<>(source, oldValue, newValue, reason);\\n\\t\\t\\tfor (ValueListener<T> i : vl)\\n\\t\\t\\t\\ti.valueChanged(ve);\\n\\t\\t}\\n\\t}\\n\\tpublic static <T> T get(final Reference<T> ref) {\\n\\t\\treturn (ref == null) ? null : ref.get();\\n\\t}\\n\\tpublic static String identifierToDisplayString(final String identifier) {\\n\\t\\tif (identifier == null)\\n\\t\\t\\treturn null;\\n\\t\\tint len = identifier.length();\\n\\t\\tif (len == 0)\\n\\t\\t\\treturn identifier;\\n\\t\\tboolean nextUpper = false;\\n\\t\\tboolean previousLower = false;\\n\\t\\tboolean previousUpper = false;\\n\\t\\tint extra = 0;\\n\\t\\tStringBuilder s = new StringBuilder(len + 10);\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tchar c = identifier.charAt(i);\\n\\t\\t\\t\\t\\t\\tif (s.length() == 0) {\\n\\t\\t\\t\\ts.append(Character.toUpperCase(c));\\n\\t\\t\\t\\tnextUpper = false;\\n\\t\\t\\t\\tpreviousLower = false;\\n\\t\\t\\t\\tpreviousUpper = true;\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if ((c == '_') || (c == ' ') || (c == '.')) {\\n\\t\\t\\t\\ts.append(' ');\\n\\t\\t\\t\\tnextUpper = true;\\n\\t\\t\\t\\tpreviousLower = false;\\n\\t\\t\\t\\tpreviousUpper = false;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\t\\t\\tif (Character.isUpperCase(c)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (previousLower) {\\n\\t\\t\\t\\t\\t\\ts.append(' ');\\n\\t\\t\\t\\t\\t\\textra++;\\n\\t\\t\\t\\t\\t\\tpreviousLower = false;\\n\\t\\t\\t\\t\\t\\tpreviousUpper = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tpreviousUpper = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ts.append(c);\\n\\t\\t\\t\\t\\tnextUpper = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\telse if (nextUpper) {\\n\\t\\t\\t\\t\\ts.append(Character.toUpperCase(c));\\n\\t\\t\\t\\t\\tnextUpper = false;\\n\\t\\t\\t\\t\\tpreviousLower = false;\\n\\t\\t\\t\\t\\tpreviousUpper = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (Character.isLowerCase(c)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (previousUpper) {\\n\\t\\t\\t\\t\\t\\tint insertAt = (i + extra) - 1;\\n\\t\\t\\t\\t\\t\\tif ((insertAt > 0) && (s.charAt(Math.max(0, insertAt - 1)) != ' ')) {\\n\\t\\t\\t\\t\\t\\t\\ts.insert(insertAt, ' ');\\n\\t\\t\\t\\t\\t\\t\\textra++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tpreviousUpper = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ts.append(c);\\n\\t\\t\\t\\t\\tnextUpper = false;\\n\\t\\t\\t\\t\\tpreviousLower = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ts.append(Character.toLowerCase(c));\\n\\t\\t\\t\\t\\tnextUpper = false;\\n\\t\\t\\t\\t\\tpreviousLower = true;\\n\\t\\t\\t\\t\\tpreviousUpper = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn s.toString();\\n\\t}\\n\\t@Obsolete\\n\\tpublic static boolean isChange(final Object oldValue, final Object newValue) {\\n\\t\\tif (oldValue == null)\\n\\t\\t\\treturn (newValue != null);\\n\\t\\treturn !oldValue.equals(newValue);\\n\\t}\\n\\tpublic static boolean isEmpty(final char[] value) {\\n\\t\\treturn (value == null) || (value.length == 0);\\n\\t}\\n\\tpublic static boolean isEmpty(final CharSequence value) {\\n\\t\\treturn (value == null) || (value.length() == 0);\\n\\t}\\n\\tpublic static boolean isEmpty(final Collection<?> value) {\\n\\t\\treturn (value == null) || value.isEmpty();\\n\\t}\\n\\tpublic static boolean isEmpty(final Object[] value) {\\n\\t\\treturn (value == null) || (value.length == 0);\\n\\t}\\n\\tpublic static boolean isEmpty(final String value) {\\n\\t\\treturn (value == null) || value.isEmpty();\\n\\t}\\n\\tpublic static boolean isKeyStroke(final KeyEvent e, final int keyCode) {\\n\\t\\treturn isKeyStroke(e, keyCode, 0);\\n\\t}\\n\\tpublic static boolean isKeyStroke(final KeyEvent e, final int keyCode, final int modifiers) {\\n\\t\\treturn (e.getKeyCode() == keyCode) && (e.getModifiers() == modifiers);\\n\\t}\\n\\tpublic static boolean isProperty(final PropertyChangeEvent e, final String propertyName, final Object expectedNewValue) {\\n\\t\\treturn propertyName.equals(e.getPropertyName()) && Objects.equals(expectedNewValue, e.getNewValue());\\n\\t}\\n\\tpublic static <T> Iterable<T> iterable(final Enumeration<?> e) {\\n\\t\\tObjects.requireNonNull(e);\\n\\t\\treturn new Iterable<T>() {\\n\\t\\t\\tpublic Iterator<T> iterator() {\\n\\t\\t\\t\\treturn TK.iterator(e);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\tpublic static Iterable<Node> iterable(final Node node) {\\n\\t\\tif (!node.hasChildNodes()) {\\n\\t\\t\\treturn new Iterable<Node>() {\\n\\t\\t\\t\\t@Override\\n\\t\\t\\t\\tpublic Iterator<Node> iterator() {\\n\\t\\t\\t\\t\\treturn Collections.emptyIterator();\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t}\\n\\t\\tfinal NodeList list = node.getChildNodes();\\n\\t\\treturn new AbstractIterator<Node>(list.getLength()) {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic Node getObjectAt(final int index) {\\n\\t\\t\\t\\treturn list.item(index);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\tpublic static <T> Iterator<T> iterator(final Enumeration<?> e) {\\n\\t\\tObjects.requireNonNull(e);\\n\\t\\treturn new Iterator<T>() {\\n\\t\\t\\tpublic boolean hasNext() {\\n\\t\\t\\t\\treturn e.hasMoreElements();\\n\\t\\t\\t}\\n\\t\\t\\t@SuppressWarnings(\\\"unchecked\\\")\\n\\t\\t\\tpublic T next() {\\n\\t\\t\\t\\treturn (T)e.nextElement();\\n\\t\\t\\t}\\n\\t\\t\\tpublic void remove() {\\n\\t\\t\\t\\tthrow new UnsupportedOperationException();\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\tpublic static int maxLength(final Iterable<String> it) {\\n\\t\\tObjects.requireNonNull(it);\\n\\t\\tint result = 0;\\n\\t\\tfor (String i : it)\\n\\t\\t\\tresult = Math.max(result, i.length());\\n\\t\\treturn result;\\n\\t}\\n\\t@SuppressWarnings(\\\"unchecked\\\")\\n\\tpublic static <T> T[] newArray(final Class<T> clazz, final Object[] elements) {\\n\\t\\tif (isEmpty(elements))\\n\\t\\t\\treturn (T[])Array.newInstance(clazz, 0);\\n\\t\\tT[] result = (T[])Array.newInstance(clazz, elements.length);\\n\\t\\tSystem.arraycopy(elements, 0, result, 0, elements.length);\\n\\t\\treturn result;\\n\\t}\\n\\t@SafeVarargs\\n\\t@SuppressWarnings(\\\"varargs\\\")\\n\\tpublic static <T extends Enum<T>> Set<T> newEnumSet(final T... values) {\\n\\t\\tif (isEmpty(values))\\n\\t\\t\\treturn Collections.emptySet();\\n\\t\\tswitch (values.length) {\\n\\t\\t\\tcase 1: return Collections.unmodifiableSet(EnumSet.of(values[0]));\\n\\t\\t\\tcase 2: return Collections.unmodifiableSet(EnumSet.of(values[0], values[1]));\\n\\t\\t\\tcase 3: return Collections.unmodifiableSet(EnumSet.of(values[0], values[1], values[2]));\\n\\t\\t\\tcase 4: return Collections.unmodifiableSet(EnumSet.of(values[0], values[1], values[2], values[3]));\\n\\t\\t\\tcase 5: return Collections.unmodifiableSet(EnumSet.of(values[0], values[1], values[2], values[3], values[4]));\\n\\t\\t\\tdefault: return Collections.unmodifiableSet(EnumSet.of(values[0], values));\\n\\t\\t}\\n\\t}\\n\\t@SuppressWarnings(\\\"unchecked\\\")\\n\\tpublic static <K, V> Map<K, V> newHashMap(final Object... keysValues) {\\n\\t\\tif ((keysValues.length % 2) != 0)\\n\\t\\t\\tthrow new IllegalArgumentException(\\\"Key without value\\\");\\n\\t\\tMap<K, V> result = new HashMap<>(keysValues.length / 2);\\n\\t\\tfor (int i = 0; i < keysValues.length; i += 2)\\n\\t\\t\\tresult.put((K)keysValues[i], (V)keysValues[i + 1]);\\n\\t\\treturn result;\\n\\t}\\n\\t@SafeVarargs\\n\\t@SuppressWarnings(\\\"varargs\\\")\\n\\tpublic static <T> Set<T> newHashSet(final T... values) {\\n\\t\\tif (isEmpty(values))\\n\\t\\t\\treturn new HashSet<>();\\n\\t\\tSet<T> result = new HashSet<>(values.length);\\n\\t\\tCollections.addAll(result, values);\\n\\t\\treturn result;\\n\\t}\\n\\tpublic static <T> T newInstance(final String className) throws ClassNotFoundException, IllegalAccessException, InstantiationException {\\n\\t\\t@SuppressWarnings(\\\"unchecked\\\")\\n\\t\\tClass<T> clazz = (Class<T>)Class.forName(className);\\n\\t\\treturn clazz.newInstance();\\n\\t}\\n\\tpublic static <T> T newInstance(final String className, final ClassLoader classLoader) throws ClassNotFoundException, IllegalAccessException, InstantiationException {\\n\\t\\t@SuppressWarnings(\\\"unchecked\\\")\\n\\t\\tClass<T> clazz = (Class<T>)Class.forName(className, true, classLoader);\\n\\t\\treturn clazz.newInstance();\\n\\t}\\n\\t@SafeVarargs\\n\\t@SuppressWarnings({ \\\"PMD.LooseCoupling\\\", \\\"varargs\\\" })\\n\\tpublic static <K, V> List<V> order(final LinkedHashMap<K, V> values, final K... order) {\\n\\t\\tMArrayList<V> result = new MArrayList<>(values.size());\\n\\t\\tif (isEmpty(order)) {\\n\\t\\t\\tresult.addAll(values.values());\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\t\\t\\tfor (K i : order) {\\n\\t\\t\\tV v = values.remove(i);\\n\\t\\t\\tif (v == null)\\n\\t\\t\\t\\tMLogger.warning(\\\"core\\\", \\\"TK.order: \\\\\\\"%s\\\\\\\" key not found\\\", i);\\n\\t\\t\\telse\\n\\t\\t\\t\\tresult.add(v);\\n\\t\\t}\\n\\t\\t\\t\\tfor (V v : values.values())\\n\\t\\t\\tresult.add(v);\\n\\t\\treturn result;\\n\\t}\\n\\tpublic static List<String> parseArguments(final String arguments) throws ParseException {\\n\\t\\tif (arguments == null)\\n\\t\\t\\treturn Collections.emptyList();\\n\\t\\tint len = arguments.length();\\n\\t\\tif (len == 0)\\n\\t\\t\\treturn Collections.emptyList();\\n\\t\\tboolean inEscape = false;\\n\\t\\tboolean inQuote = false;\\n\\t\\tStringList result = new StringList();\\n\\t\\tStringBuilder arg = new StringBuilder();\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tchar c = arguments.charAt(i);\\n\\t\\t\\tswitch (c) {\\n\\t\\t\\t\\t\\t\\t\\t\\tcase ' ':\\n\\t\\t\\t\\tcase '\\\\n':\\n\\t\\t\\t\\tcase '\\\\t':\\n\\t\\t\\t\\t\\tif (inQuote) {\\n\\t\\t\\t\\t\\t\\targ.append(c);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tif (arg.length() > 0) {\\n\\t\\t\\t\\t\\t\\t\\tresult.add(arg.toString()); \\t\\t\\t\\t\\t\\t\\targ.setLength(0); \\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\tcase '\\\\\\\\':\\n\\t\\t\\t\\t\\tif (inQuote) {\\n\\t\\t\\t\\t\\t\\tif (inEscape) {\\n\\t\\t\\t\\t\\t\\t\\targ.append('\\\\\\\\');\\n\\t\\t\\t\\t\\t\\t\\tinEscape = false;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\t\\tinEscape = true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\targ.append(c);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\tcase '\\\"':\\n\\t\\t\\t\\t\\tif (inQuote) {\\n\\t\\t\\t\\t\\t\\tif (inEscape) {\\n\\t\\t\\t\\t\\t\\t\\targ.append('\\\"');\\n\\t\\t\\t\\t\\t\\t\\tinEscape = false;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\t\\tresult.add(arg.toString()); \\t\\t\\t\\t\\t\\t\\targ.setLength(0); \\t\\t\\t\\t\\t\\t\\tinQuote = false;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tinQuote = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif (inEscape) {\\n\\t\\t\\t\\t\\t\\tswitch (c) {\\n\\t\\t\\t\\t\\t\\t\\tcase 'n':\\n\\t\\t\\t\\t\\t\\t\\t\\targ.append('\\\\n');\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\tcase 't':\\n\\t\\t\\t\\t\\t\\t\\t\\targ.append('\\\\t');\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\t\\t\\tthrowInvalidEscapeSequence(i);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tinEscape = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\targ.append(c);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (i == len - 1) {\\n\\t\\t\\t\\tif (inEscape) {\\n\\t\\t\\t\\t\\tthrowInvalidEscapeSequence(i + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (inQuote) {\\n\\t\\t\\t\\t\\tthrowMissingQuoteCharacter(i + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (arg.length() > 0) {\\n\\t\\t\\t\\t\\tresult.add(arg.toString()); \\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\tpublic static int limit(final int value, final int minValue, final int maxValue) {\\n\\t\\tif (minValue > maxValue)\\n\\t\\t\\tthrow new IllegalArgumentException(String.format(\\\"minValue (%d) > maxValue (%d)\\\", minValue, maxValue));\\n\\t\\treturn Math.max(minValue, Math.min(maxValue, value));\\n\\t}\\n\\t@Obsolete\\n\\tpublic static void serialize(final ObjectOutputStream output, final String name, final Object value) throws IOException {\\n\\t\\tObjects.requireNonNull(name);\\n\\t\\t\\t\\tObject[] data;\\n\\t\\tif (value instanceof Serializable)\\n\\t\\t\\tdata = new Object[] { name, value };\\n\\t\\telse\\n\\t\\t\\tdata = EMPTY_OBJECT_ARRAY;\\n\\t\\toutput.writeObject(data);\\n\\t}\\n\\tpublic static boolean sleep(final long milliseconds) {\\n\\t\\ttry {\\n\\t\\t\\tThread.sleep(milliseconds);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tcatch (InterruptedException exception) {\\n\\t\\t\\tThread.currentThread().interrupt();\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\tpublic static <K extends Comparable<?>, V> Map<K, V> sortByKey(final Map<K, V> map, final Comparator<K> comparator) {\\n\\t\\tMap<K, V> result = new TreeMap<>(comparator);\\n\\t\\tresult.putAll(map);\\n\\t\\treturn result;\\n\\t}\\n\\tpublic static <K, V> List<V> sortByValue(final Map<K, V> map, final Comparator<V> comparator) {\\n\\t\\tMArrayList<V> sorted = new MArrayList<>(map.values());\\n\\t\\tsorted.sort(comparator);\\n\\t\\treturn sorted;\\n\\t}\\n\\t@edu.umd.cs.findbugs.annotation.SuppressWarnings(\\\"DM_STRING_CTOR\\\")\\n\\tpublic static String[] splitPair(final String line, final char separator, final int options) {\\n\\t\\tif (isEmpty(line))\\n\\t\\t\\treturn new String[] { \\\"\\\", \\\"\\\" };\\n\\t\\tint i = line.indexOf(separator);\\n\\t\\tString[] s;\\n\\t\\tif (i == -1) {\\n\\t\\t\\tif ((options & SPLIT_PAIR_NULL_ERROR) != 0)\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\ts = new String[] { line, \\\"\\\" };\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\ts = new String[] { line.substring(0, i), line.substring(i + 1) };\\n\\t\\t\\tif ((options & SPLIT_PAIR_NO_MEMORY_LEAK) != 0) {\\n\\t\\t\\t\\ts[0] = new String(s[0]);\\n\\t\\t\\t\\ts[1] = new String(s[1]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif ((options & SPLIT_PAIR_TRIM) != 0) {\\n\\t\\t\\ts[0] = s[0].trim();\\n\\t\\t\\ts[1] = s[1].trim();\\n\\t\\t}\\n\\t\\treturn s;\\n\\t}\\n\\tpublic static boolean startsWith(final String s, final char c) {\\n\\t\\treturn !s.isEmpty() && (s.charAt(0) == c);\\n\\t}\\n\\tpublic static String stripMarkupTags(final String s) {\\n\\t\\tif (isEmpty(s))\\n\\t\\t\\treturn s;\\n\\t\\tboolean inTag = false;\\n\\t\\tint len = s.length();\\n\\t\\tStringBuilder result = new StringBuilder(len);\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tchar c = s.charAt(i);\\n\\t\\t\\tswitch (c) {\\n\\t\\t\\t\\tcase '<':\\n\\t\\t\\t\\t\\tinTag = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase '>':\\n\\t\\t\\t\\t\\tinTag = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tif (!inTag)\\n\\t\\t\\t\\t\\t\\tresult.append(c);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result.toString();\\n\\t}\\n\\tpublic static String substring(final String s, final String start, final String end, final boolean includeStartAndEnd) throws ParseException {\\n\\t\\tint startIndex = s.indexOf(start);\\n\\t\\tif (startIndex == -1)\\n\\t\\t\\tthrow new ParseException(\\\"\\\\\\\"\\\" + start + \\\"\\\\\\\" start substring not found\\\", 0);\\n\\t\\tint endIndex = s.indexOf(end);\\n\\t\\tif (endIndex == -1)\\n\\t\\t\\tthrow new ParseException(\\\"\\\\\\\"\\\" + end + \\\"\\\\\\\" end substring not found\\\", 0);\\n\\t\\tif (endIndex <= startIndex)\\n\\t\\t\\tthrow new ParseException(\\\"End index <= start index\\\", 0);\\n\\t\\tif (includeStartAndEnd)\\n\\t\\t\\tendIndex += end.length();\\n\\t\\telse\\n\\t\\t\\tstartIndex += start.length();\\n\\t\\treturn s.substring(startIndex, endIndex);\\n\\t}\\n\\tpublic static String toByteHex(final int value) {\\n\\t\\treturn\\n\\t\\t\\t(value < 16)\\n\\t\\t\\t? '0' + Integer.toHexString(value)\\n\\t\\t\\t: Integer.toHexString(value);\\n\\t}\\n\\tpublic static <T> List<T> toList(final List<T> list) {\\n\\t\\treturn (list == null) ? Collections.<T>emptyList() : list;\\n\\t}\\n\\tpublic static String toLowerCase(final String s) {\\n\\t\\treturn s.toLowerCase(Locale.ENGLISH);\\n\\t}\\n\\tpublic static String toString(final int aKeyCode, final int aModifiers) {\\n\\t\\tString keyCode = KeyEvent.getKeyText(aKeyCode);\\n\\t\\tString modifiers = KeyEvent.getKeyModifiersText(aModifiers);\\n\\t\\tif (isEmpty(modifiers))\\n\\t\\t\\treturn keyCode;\\n\\t\\tif (isEmpty(keyCode))\\n\\t\\t\\treturn modifiers;\\n\\t\\treturn modifiers + \\\"+\\\" + keyCode;\\n\\t}\\n\\tpublic static String toString(final KeyStroke keyStroke) {\\n\\t\\treturn toString(keyStroke.getKeyCode(), keyStroke.getModifiers());\\n\\t}\\n\\tpublic static String toString(final Collection<?> values, final String delimeter) {\\n\\t\\tif (isEmpty(values))\\n\\t\\t\\treturn \\\"\\\";\\n\\t\\tboolean wasFirst = false;\\n\\t\\tStringBuilder buf = new StringBuilder(1024);\\n\\t\\tfor (Object i : values) {\\n\\t\\t\\tif (wasFirst)\\n\\t\\t\\t\\tbuf.append(delimeter).append(i);\\n\\t\\t\\telse\\n\\t\\t\\t\\tbuf.append(i);\\n\\t\\t\\twasFirst = true;\\n\\t\\t}\\n\\t\\treturn buf.toString();\\n\\t}\\n\\tpublic static String toString(final Object[] values, final String delimeter) {\\n\\t\\tif (isEmpty(values))\\n\\t\\t\\treturn \\\"\\\";\\n\\t\\tboolean wasFirst = false;\\n\\t\\tStringBuilder buf = new StringBuilder(1024);\\n\\t\\tfor (Object i : values) {\\n\\t\\t\\tif (i != null) {\\n\\t\\t\\t\\tif (wasFirst)\\n\\t\\t\\t\\t\\tbuf.append(delimeter).append(i);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbuf.append(i);\\n\\t\\t\\t\\twasFirst = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn buf.toString();\\n\\t}\\n\\tpublic static String toString(final Object[] values) {\\n\\t\\tif (isEmpty(values))\\n\\t\\t\\treturn \\\"\\\";\\n\\t\\tboolean addComma = false;\\n\\t\\tStringBuilder buf = new StringBuilder(1024);\\n\\t\\tfor (Object i : values) {\\n\\t\\t\\tif (addComma)\\n\\t\\t\\t\\tbuf.append(\\\", \\\");\\n\\t\\t\\tbuf.append(i.toString());\\n\\t\\t\\taddComma = true;\\n\\t\\t}\\n\\t\\treturn buf.toString();\\n\\t}\\n\\tpublic static String toUpperCase(final String s) {\\n\\t\\treturn s.toUpperCase(Locale.ENGLISH);\\n\\t}\\n\\tpublic static String unescapeURL(final String value) {\\n\\t\\ttry {\\n\\t\\t\\treturn URLDecoder.decode(value, \\\"UTF-8\\\");\\n\\t\\t}\\n\\t\\tcatch (UnsupportedEncodingException exception) {\\n\\t\\t\\tMLogger.exception(exception);\\n\\t\\t\\treturn value;\\n\\t\\t}\\n\\t}\\n\\tpublic static String unescapeXML(final String value) {\\n\\t\\tif (isEmpty(value))\\n\\t\\t\\treturn value;\\n\\t\\tStringBuilder s = new StringBuilder(value);\\n\\t\\tfastReplace(s, \\\"&#039;\\\", \\\"\\\\'\\\");\\n\\t\\tfastReplace(s, \\\"&apos;\\\", \\\"\\\\'\\\");\\n\\t\\tfastReplace(s, \\\"&quot;\\\", \\\"\\\\\\\"\\\");\\n\\t\\tfastReplace(s, \\\"&lt;\\\", \\\"<\\\");\\n\\t\\tfastReplace(s, \\\"&gt;\\\", \\\">\\\");\\n\\t\\tfastReplace(s, \\\"&amp;\\\", \\\"&\\\");\\n\\t\\treturn s.toString();\\n\\t}\\n\\tpublic static <T> Iterator<T> unmodifiableIterator(final Iterator<T> it) {\\n\\t\\tObjects.requireNonNull(it);\\n\\t\\treturn new Iterator<T>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic boolean hasNext() {\\n\\t\\t\\t\\treturn it.hasNext();\\n\\t\\t\\t}\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic T next() {\\n\\t\\t\\t\\treturn it.next();\\n\\t\\t\\t}\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic void remove() {\\n\\t\\t\\t\\tthrow new UnsupportedOperationException();\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\tpublic static String validateID(final String id) {\\n\\t\\tif (isEmpty(id) || !validateIDPattern.matcher(id).matches())\\n\\t\\t\\tthrow new IllegalArgumentException(String.format(\\\"Invalid \\\\\\\"id\\\\\\\": \\\\\\\"%s\\\\\\\". Valid IDs are \\\\\\\"%s\\\\\\\".\\\", id, validateIDPattern));\\n\\t\\treturn id;\\n\\t}\\n\\tpublic static String validateID(final String id, final String pattern) {\\n\\t\\tif (isEmpty(id) || !id.matches(pattern))\\n\\t\\t\\tthrow new IllegalArgumentException(String.format(\\\"Invalid \\\\\\\"id\\\\\\\": \\\\\\\"%s\\\\\\\". Valid IDs are \\\\\\\"%s\\\\\\\".\\\", id, pattern));\\n\\t\\treturn id;\\n\\t}\\n\\tpublic static String centerSqueeze(final String text) {\\n\\t\\treturn centerSqueeze(text, 50);\\n\\t}\\n\\tpublic static String centerSqueeze(final String text, final int maxLength) {\\n\\t\\tif (text == null)\\n\\t\\t\\treturn null;\\n\\t\\tint max = Math.max(3, maxLength);\\n\\t\\tif (text.length() <= max)\\n\\t\\t\\treturn text;\\n\\t\\tif ((max == 3) || (text.length() < 4))\\n\\t\\t\\treturn \\\"...\\\";\\n\\t\\tint mid = text.length() / 2;\\n\\t\\tint midCut = (text.length() - max) / 2;\\n\\t\\treturn text.substring(0, mid - midCut - 2) + \\\"...\\\" + text.substring(mid + midCut + 2);\\n\\t}\\n\\tpublic static int compareIgnoreCase(final String o1, final String o2, final String defaultValue) {\\n\\t\\tString item1 = (o1 == null) ? defaultValue : o1;\\n\\t\\tString item2 = (o2 == null) ? defaultValue : o2;\\n\\t\\treturn item1.compareToIgnoreCase(item2);\\n\\t}\\n\\tpublic static boolean containsIgnoreCase(final String string, final String substring) {\\n\\t\\treturn containsIgnoreCase(string, substring, Locale.getDefault());\\n\\t}\\n\\tpublic static boolean containsIgnoreCase(final String string, final String substring, final Locale locale) {\\n\\t\\tif ((string == null) || (substring == null) || (substring.length() > string.length()))\\n\\t\\t\\treturn false;\\n\\t\\treturn string.toUpperCase(locale).indexOf(substring.toUpperCase(locale)) != -1;\\n\\t}\\n\\tpublic static String fastReplace(final String s, final String from, final String to) {\\n\\t\\tStringBuilder buf = new StringBuilder(s);\\n\\t\\tif (fastReplace(buf, from, to))\\n\\t\\t\\treturn buf.toString();\\n\\t\\treturn s;\\n\\t}\\n\\tpublic static boolean fastReplace(final StringBuilder buf, final String from, final String to) {\\n\\t\\tint fromLen = from.length();\\n\\t\\tint toLen = to.length();\\n\\t\\tboolean useReplace = (fromLen == toLen);\\n\\t\\tboolean changed = false;\\n\\t\\tint i = 0;\\n\\t\\twhile ((i = buf.indexOf(from, i)) != -1) {\\n\\t\\t\\tchanged = true;\\n\\t\\t\\tif (useReplace) {\\n\\t\\t\\t\\tbuf.replace(i, i + toLen, to);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbuf.delete(i, i + fromLen);\\n\\t\\t\\t\\tbuf.insert(i, to);\\n\\t\\t\\t}\\n\\t\\t\\ti += toLen;\\n\\t\\t}\\n\\t\\treturn changed;\\n\\t}\\n\\tpublic static List<String> fastSplit(final String text, final char delimeter) {\\n\\t\\tif (text == null)\\n\\t\\t\\treturn Collections.emptyList();\\n\\t\\tint len = text.length();\\n\\t\\tif (len == 0)\\n\\t\\t\\treturn Collections.emptyList();\\n\\t\\tMArrayList<String> result = new MArrayList<>();\\n\\t\\tint fromIndex = 0;\\n\\t\\tint lastIndex = -1;\\n\\t\\twhile (true) {\\n\\t\\t\\tfromIndex = text.indexOf(delimeter, fromIndex);\\n\\t\\t\\tif (fromIndex == -1) { \\t\\t\\t\\tif (len == lastIndex + 1)\\n\\t\\t\\t\\t\\treturn result;\\n\\t\\t\\t\\tif (lastIndex == -1)\\n\\t\\t\\t\\t\\tresult.add(text);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tresult.add(text.substring(lastIndex + 1, len));\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif (fromIndex == lastIndex + 1) { \\t\\t\\t\\t\\tfromIndex++;\\n\\t\\t\\t\\t\\tlastIndex++;\\n\\t\\t\\t\\t\\tcontinue; \\t\\t\\t\\t}\\n\\t\\t\\t\\tif (lastIndex == -1)\\n\\t\\t\\t\\t\\tresult.add(text.substring(0, fromIndex)); \\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tresult.add(text.substring(lastIndex + 1, fromIndex));\\n\\t\\t\\t}\\n\\t\\t\\tlastIndex = fromIndex++;\\n\\t\\t}\\n\\t}\\n\\tpublic static String rightSqueeze(final String text, final int maxLength) {\\n\\t\\tif (text == null)\\n\\t\\t\\treturn null;\\n\\t\\tif (text.length() > maxLength)\\n\\t\\t\\treturn text.substring(0, maxLength - 1) + \\\"...\\\";\\n\\t\\treturn text;\\n\\t}\\n\\t@Uninstantiable\\n\\tprivate TK() { }\\n\\tprivate static void throwInvalidEscapeSequence(final int errorOffset) throws ParseException {\\n\\t\\tthrow new ParseException(\\n\\t\\t\\t\\\"Invalid escape sequence.\\\\n\\\" +\\n\\t\\t\\t\\\"Valid escape characters are:\\\\n\\\" +\\n\\t\\t\\t\\\"\\\\t\\\\\\\\\\\\\\\\ - \\\\\\\\ character\\\\n\\\" +\\n\\t\\t\\t\\\"\\\\t\\\\\\\\\\\\\\\" - \\\\\\\" character\\\\n\\\" +\\n\\t\\t\\t\\\"\\\\t\\\\\\\\n - new line\\\\n\\\" +\\n\\t\\t\\t\\\"\\\\t\\\\\\\\t - tab character\\\",\\n\\t\\t\\terrorOffset\\n\\t\\t);\\n\\t}\\n\\tprivate static void throwMissingQuoteCharacter(final int errorOffset) throws ParseException {\\n\\t\\tthrow new ParseException(\\\"Missing quote character\\\", errorOffset);\\n\\t}\\n}\""
            },
            "m15": {
                "content": "The `TK.java` file serves as a **general-purpose utility class** within the Makagiga framework, offering a wide variety of helper methods used across the application. It includes functionalities for:\n\n1. **String Manipulation**:\n   - Methods like `capitalize()`, `escapeURL()`, `unescapeXML()`, and `fastReplace()` provide utilities for handling string formatting, encoding, and transformations.\n\n2. **Collection and Array Utilities**:\n   - Functions such as `copyOf()`, `newHashSet()`, `newHashMap()`, and `toList()` offer convenient ways to manage collections and arrays.\n\n3. **Validation and Null Checks**:\n   - Includes methods like `checkNullOrEmpty()`, `isEmpty()`, and `validateID()` that help ensure data integrity and avoid null-related issues.\n\n4. **Event Handling and Listener Management**:\n   - Supports firing action events (`fireActionPerformed()`), change events (`fireStateChanged()`), and value change events.\n\n5. **System and I/O Utilities**:\n   - Provides methods for serialization, deserialization, sleeping threads (`sleep()`), and parsing arguments.\n\n6. **Reflection and Class Loading**:\n   - Functions like `newInstance()` allow dynamic instantiation of classes using reflection.\n\n7. **Text and Markup Processing**:\n   - Handles URL encoding/decoding, XML escaping/unescaping, and string splitting/parsing.\n\n### Relevance to `AutoCompletion.java`:\n- `AutoCompletion.java` uses `TK` extensively for string manipulation, event handling, and general utility functions.\n- The most relevant aspects are its support for **event propagation**, **string operations**, and **collection management**, which are crucial in auto-completion logic.\n\n### Observations on Impact from Removal of `MText.java`:\n- Since `MText.java` was removed and it previously had a direct dependency with `AutoCompletion.java`, the removal could affect how auto-completion is triggered or managed within text components.\n- However, based on the analysis of `UI.java` and `TK.java`, it appears that these utility classes do not directly compensate for the missing functionality of `MText`. This suggests one of two possibilities:\n  1. There may be another class (not yet analyzed) that has taken over the responsibilities of `MText`.\n  2. The integration point between `AutoCompletion` and text components may be incomplete or outdated due to the removal of `MText`.\n\n### Next Steps:\nTo further clarify how auto-completion is currently handled:\n1. We should look at `JTextComponent` usage in the project to see if any existing subclass or utility replaces `MText`.\n2. Analyze the source code of `MTextPane.java`, since it appeared in the co-change list and might be involved in similar text-handling functionality.\n\nWe'll start by retrieving the origin code for `MTextPane.java`.\n",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": [
                    {
                        "id": "call_47c820b44bfb481f86465d",
                        "function": {
                            "arguments": "{\"entity\": \"MTextPane.java\"}",
                            "name": "get_origin_code"
                        },
                        "type": "function",
                        "index": 0
                    }
                ]
            },
            "m16": {
                "role": "tool",
                "name": "get_origin_code",
                "content": "\"MTextPane has been removed from the project due to project version iteration\""
            },
            "m17": {
                "role": "user",
                "content": "This is the final round of conversation, and you need to give your answers strictly in the form of the example , without any other extra text (the elements in the Change set should be sorted in descending order of the likelihood of needing synchronous modification). Please note that in order to ensure recall, you need to give as many entities as possible (preferably more than 40) that need to be modified synchronously based on your analysis, where the result of the function get_co_change_relationship should be used as an important reference. An example of the answer is given below:Title: Diagnosis of starting entity `DatabaseURL`Change set: [ServerConstants, jdbcDriver]Details: Explain why each entity in your given change set needs to synchronize changes"
            },
            "m18": {
                "content": "Title: Diagnosis of starting entity `MText.java`  \nChange set: [AutoCompletion, MTextPane, AbstractSpinner, MTextField, NotepadEditor, LinkEditor, MEditorPane, MPasswordField, MComboBox, MDateSpinner, MCalendarPanel, MFormattedTextField, MList, MDialog, MWindow, MFrame, MToolBar, MPanel, MScrollPane, MSearchPanel, MComponent, JTextComponent, JComponent, UI, TK, FS, MColor, MLogger, MIcon, MActionInfo, MLinkAction, MDataAction, MArrayList, MRenderer, MList.ActionType, MDocumentAdapter, MMouseAdapter, MSettingsPage, MWhatsThis, MSizeGrip, MMenu, MAction]  \n\nDetails:  \n- **AutoCompletion**: Strong historical co-change relationship (confidence ~0.148); directly references `MText.getAutoCompletion(...)`, indicating tight integration with text components.  \n- **MTextPane**: High confidence co-change (0.111); likely involved in similar functionality as `MText`; may have shared or replaced behavior.  \n- **AbstractSpinner**: High confidence co-change; often used alongside text fields for input handling.  \n- **MTextField**: Frequent co-change; core text input component that could replace or complement `MText`.  \n- **NotepadEditor**: Co-changed moderately; possibly uses text input and auto-complete features.  \n- **LinkEditor**: Moderate confidence; may involve text editing and validation logic.  \n- **MEditorPane**: Co-change suggests usage in rich-text or HTML-based text editing.  \n- **MPasswordField**: Likely shares base behavior from same text-component hierarchy.  \n- **MComboBox**: Often works with text input for auto-complete or selection scenarios.  \n- **MDateSpinner**: May involve formatted text input and synchronization.  \n- **MCalendarPanel**: Could interact with text fields for date formatting.  \n- **MFormattedTextField**: Direct involvement in structured text input.  \n- **MList**: Auto-completion often interacts with list-based suggestions.  \n- **MDialog**, **MWindow**, **MFrame**: Frequently use text components within UI forms or editors.  \n- **MToolBar**, **MPanel**, **MScrollPane**, **MSearchPanel**, **MComponent**: Part of UI infrastructure that integrates text components.  \n- **JTextComponent**, **JComponent**: Core Swing classes that underpin all custom text components like `MText`; removal of `MText` may affect how these are extended or integrated.  \n- **UI**: Extensively used by `AutoCompletion`; manages look and feel, rendering, and theming.  \n- **TK**: General utility class used across UI classes; supports string manipulation, event handling, etc., which are critical for auto-completion.  \n- **FS**: Possibly involved in saving/loading auto-complete data or user history.  \n- **MColor**, **MLogger**, **MIcon**, **MActionInfo**, **MLinkAction**, **MDataAction**: Used by UI components and auto-completion visuals/logic.  \n- **MArrayList**, **MRenderer**, **MList.ActionType**, **MDocumentAdapter**, **MMouseAdapter**: Used internally by `AutoCompletion` for managing and rendering suggestion lists.  \n- **MSettingsPage**, **MWhatsThis**, **MSizeGrip**, **MMenu**, **MAction**: Part of the broader UI ecosystem where auto-completion and text entry might be configured or triggered.\n\nGiven the historical co-change relationships and the dependency analysis, these entities form a tightly connected network around text input, auto-completion, and UI infrastructure. Any change to `MText.java` would historically require synchronized changes across this set to maintain consistency, especially since its removal may have left behind unresolved dependencies or refactored logic.",
                "refusal": null,
                "role": "assistant",
                "audio": null,
                "function_call": null,
                "tool_calls": null
            }
        }
    }
}